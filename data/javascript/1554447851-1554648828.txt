You can't trust callbacks. You may expect your callback function to only get called once, but whatever code is in charge of calling your callback can fail and call your callback more than once. Nothing guarantees your callback to only get called once. Promises are the solution to that problem. A promise will only ever resolve (or fail to a catch) once. Indentation looks ugly, but that's not a real problem to the machine as it is a problem with readability to us.
Project Page (?): https://github.com/redixhumayun/functional *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
Good point, but it's someone else!
Link?
LOL, thanks I left out the link :)))))
Async/await is the worst thing that has ever happened to JS. In a time when everyone tries to move to declarative code style, AW brings us back to imperative one. Use RxJS, people, there are no excuses.
Enter RxJS!
Nice work! Funnily enough, I was working on some custom error handling for Typescript today as well, so I’ll def check this out!
Promise or async/await are just syntactical sugar, you can implement the same functionality on your own easily, and there are lot of opinions regarding this newly added feature, some likes to use callback, some likes promise. If any library/application uses callback, It doesn't mean that it is legecy code, it is their opinion. Anyway, I like Promise/async await, also I implemented the whole Promise functionality in ES5 code, checkout https://github.com/rousan/belofte.js 
Shouldn't your url be "https://localhost:6030" [here](https://github.com/jelmished/NCRCTennis/blob/7c5e30a2397b1defd830250f668a5926822c9326/client/test/dom.js#L13) if you're running https server? And same in webpack config.
Take a look how [Node.js implements error code](https://github.com/nodejs/node/blob/master/lib/internal/errors.js). This is the biggest project that I know who do it in right way. Good luck.
They are 2 different things with their own use case. I really don't get why people opposes them. Promises (and async/await) gives you way more guarantees than callbacks. They will be called once and only once. Also you are sure that they won't get tampered with by the library, because it won't even have a ref your `then` callback (yes, you still have callbacks with promises of course). You also know the library won't keep a ref to your callback needlessly. For these reasons, promises are to be preferred *every* time they can be used. They actually enforce a contract ([see the 2 "inversion of controls" part of this article](https://medium.com/beginners-guide-to-mobile-web-development/javascript-essentials-understanding-promises-200657e11667)) But these guarantees comes with some constraints. For example, you *cannot* use promises with event-based api, or when you expect your callback to be called several times. (Well it *is* possible, but very unnatural and ugly). Use the best tool for each task. For a task that needs to be fired once when another task finishes, use promises, because of the guarantees they offer. For repeating tasks or events, use callbacks. And of course, as always, this rules of thumb must pass the pragmatism test: sometimes it's just more convenient to use callback even though you know the code will be called only once. 
Thanks mate!
As a passionate JS developer I ask just for one thing.. Let it DIE! This language is so bad..
&gt;and will slowly render them obsolete The keyword is *slowly*. Very *slowly*. Extremely *slowly*.
The base class constructor starts first.
Async/Await are gifts from heaven and anyone who thinks otherwise doesn't know what he's talking about or hasn't suffered enough in JS to know better. Your code is better with async/await in that it is easier to read for anyone. I personally think what your coworker said is complete nonsense but if you have to argue about it: if anything, callbacks are the harder abstraction. It's very easy to get someone to understand why and when to use async/await but try to teach someone why a certain problem needs three levels deep of callbacks.
Base class constructor starts first always it couldn't be changed. But what is the console output which you expect to see?
Agreed. If happy path is the only path that matters, async/await is great. But as soon as there are multiple possibilities that may not always travel through a happy "edge", then you are screwed.
I certainly downvoted you because you don't know what you're talking about. The amount you can clean up code with async/await is simply unmatched by that of arrow functions. Heck, in that regard even the deconstruct features are more useful than them. Arrow functions are neat, especially when mixed with deconstructoring, but I could live without them. Not without async/await and deconstruct though
Well if you run it in Chrome the output is "x is not defined", which is about what I was expecting. Setting x outside the constructor isn't standardised afaik.
Ryan Dahl thinks Node in general is a mistake though too so...
Ooops. It's a bug. Just switched from solidity where \`this\` is unnecessary. Thanks.
I don't know, they look too fishy for me...
thank you! :)
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/reactjs] [Luna v3 - npm management through a modern UI](https://www.reddit.com/r/reactjs/comments/b9okmz/luna_v3_npm_management_through_a_modern_ui/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Apple loses money if PWAs work as good as App Store apps
The problem with callbacks is that many nest them and abuse them to do horrible things, accessing data in objects far away that they have [no business touching at all](https://en.wikipedia.org/wiki/Law_of_Demeter). Callback hell is real and should be avoided by better designs. My problem with promises is that it is still callback hell and still does all the same bad things, it just hides them behind a somewhat prettier syntax. It does not remove the problem. You are still, in almost every case, asking someone to provide you some object so you can poke at something that you should not be poking at because it does not belong to you. It just exposes a lot of implementation details everywhere and ties objects together in a huge mess.
I love it 😀.
That is a false dichotomy though. If you have a pyramid of doom you did things wrong, and using the nicer syntax of promises will just hide the ugliness and allow you to keep digging a deeper hole for yourself. If you end up with trainwrecks in your sync code everyone understands that is a problem. You should strive to never have to do getX().getY().getZ().doSomething(). Very basic design knowledge. Pyramid of doom (or a chain of promises) is the exact same thing for async. You have a problem and ideally you solve it rather than hide it behind another layer of abstractions.
I expected pretty much what I got: SyntaxError: fields are not currently supported
Am I the only one who gets a build error if i put a const in a try statement?
Exactly this. Promises fixes the ugly syntax of callback hell and makes it less error-prone to insert exception-handling code, but does not solve the problem you had to begin with at all. It is a Law of Demeter issue. An object should not ask another object to go fetch it a third object so it can ask that object to go find it a fourth object and so on. Every time I see a chain of promises (or equivalent callback hell) it is all about someone poking around at things far away that they should have no business even knowing exists since it should be hidden behind well-designed APIs with methods they should have called to perform work, instead of just a big mud ball of get-methods where very object communicates with every other object.
I also dislike the class syntax, but that's mainly because it seems to exist as a crutch to people coming in form other programming languages that haven't adjusted to javascript. In most cases, it feels like classes require more code that code without them without any real added benefit.
But also a smell that you are probably doing things in that code that does not belong there, calling methods on objects in some far far away part of the system that you have no business even knowing it exists. At least that is my experience every time I see a long then-chain (or the equivalent callback hell pyramid of doom).
Thank you! :D
It's also far easier to test when broken up as you can just return a promise from a function but returning a partially applied cb function can become a huge pain. The promise also reflects your API far better, with cb functions you end up with the logic to start the computation at the top but the logic to end it all the way down at the bottom. Promises give you a flat structure to view the computation, the only way around this would be to use some kind of task runner as is used in express.
weird definition and react, wikipedia and w3 are apperently wrong then. 
Callbacks isn't going anywhere. They are still needed for things that Promises/Async/Await don't cover. That being said, was not a huge fan of promises and preferred callbacks -- but now with the Async/Await sugar it's really good. Remember, Promises/Async/Await are just wrappers around callbacks for specific use-cases -- they don't replace callbacks.
Arrow functions are absolutely trash compared to Async/Await. Arrow functions are not needed, but can be a nice shorthand in some cases (like with Array operation functions).
Though, haven't we heard this for years now? And still they haven't caught on in the slightest. Personally i just wonder how putting a naked dom node into a shadowed document is supposed to solve any of the issues we've had. It doesn't solve our problems, and that's a common sentiment that people seem to have. More recently i have seen prominent figures in the web component space taking a step back, as the promises that were made simply don't hold. They're talking of these components as mere presentational directives now, without interconnectivity. But even that seems misguided. I think the spec was a major mistake, and good for the web community rejecting it.
&gt; User agent sends a request to service A using fetch (promise) Yes. &gt; Service A sends a request to service B using request (callback) Actually, this too is handled entirely with promises in service A &gt; Service B runs a job and waits for it to finish (either) Both. Service B validates the incoming request using a promise. It then returns an appropriate response to service A. If the request is deemed as valid, the promise handler then starts the job, registering a callback that should always execute, regardless of whether the job succeeds or fails (in other words, there is no “then” or “catch”
Normally off-by-one is no big deal to me. But off by one \_paradigm\_?
Sorry, bud. The language is great, is the most used (or was it the most popular? Both?) programming language in the world, and is growing each session. JavaScript is the future :)
A paradigm is merely a way of thinking about something. Doesn't necessitate that something being fundamental to the underlying system, can be a minor thing... like callbacks vs Promises vs async.
That is false in two ways. Number one, the word "paradigm" _does_ imply "fundamental to the underlying system". Two, the example of callbacks vs Promises vs async _is_ a major and fundamental aspect of the system, _not_ a minor one.
That's really good! Well done :D
Just use regex.
JavaScript in the browser runs single threaded and is built off scheduling tasks. The concept is asynchronous and non-blocking. It finishes executing the current call stack before it has the opportunity to check for the next task. And when that next tasks runs it finishes that call stack before it picks up the next one. There is nothing fancy going on. Whenever you register task you are giving control over to the scheduler whether it's a setTimeout, or requestAnimationFrame, or resolving a Promise. The scheduling gets more complicated as you look into it, but that's the general idea. &amp;#x200B; So when you call setTimeout 0 you are saying run this task as soon as you can after 0 milliseconds have passed. There is no guarentee of when this happens as the currently running task and scheduled tasks can take priority. No task should take too long to run in JavaScript for this reason since you need to keep from blocking the scheduler. You don't pause a program by running a while loop for 5 seconds. You set a timeout so that you don't block execution. If you take too long the browser will tend to kill your active task and terminate execution on the page. &amp;#x200B; Hopefully that makes sense.
Beginning ? We're more like already in since 2 years -at least- I developped my PWA 1.5 years ago, electron is there since 4 years, and I can already use the same codebase for desktop, web, pwa, mobile application with some framework (like Quasar JS) without knowing much about JS, Vue, and electron/PWA/Cordova/SPA.
What does that very last bit mean?
As somebody making a purely html and HD game I have huge respect for this, I love it
I would recommand to use sprite animation rather than gif wich are heavy files and i might be wrong but it a better practice in terms of gaming Here is a little ressource https://medium.com/dailyjs/how-to-build-a-simple-sprite-animation-in-javascript-b764644244aa
The scrolling is broken on iPhone safari, doesn’t scroll at all on iOS chrome. Otherwise good job
I too never experienced "callback hell" - because I used named functions written "flat" instead of inline functions reflecting the call stack. I'm comfortable with all three mentioned methods. Here is my take: Callbacks are nice for very low-level code. A lot of the initial node.js use cases, and probably still quite a but of code now, along the lines of the many "node.js chat server" examples, fall into that category. For higher level code more interested in implementing business logic async/await is nicer. The reason is because in the first case I have to structure my functions and code according to the needs of the system (the "breaks" forced by some calls being asynchronous are purely for technical reasons, slow network and I/O and so on). For a business algorithm you don't (want to!) care that there is an asynchronous I/O, you want to write the sequential business algorithm. This is easy to do with `await`. A problem of async/await is that now something can happen that before generators and `yield` was impossible to happen in Javascript: A function could be interrupted in the middle. Without `yield` or `await`functions were guaranteed to be "atomic". So if there is a careless programmer, a structure they use which is not wholly and completely and solely owned by the function could be mutated by code other than the function between start and end of the function. That was not possible to happen before.
That's b/c iOS sucks
I believe the issue at hand is \`scope\`. the reason the result is \`6\` is because the \`i\` is declared using \`var\` which places it in the global scope, meaning that \`i\` is still available after the for loop ends. When the for loop finished \`i === 6\` and that's what the timeouts pick up. Using \`let\` scopes each timeout to the instance of \`i\` in that closure. \`i\` is no longer global. \`for (var i = 1; i &lt;=5; i++) { setTimeout(()=&gt;console.log(i), i \* 500); }\` 6 (5 times) \`for (let i = 1; i &lt;=5; i++) { setTimeout(()=&gt;console.log(i), i \* 500); }\` 1 2 3 4 5
Looks great!
nice game bro! well done and i'll pin it and bookmark it haha. awesome! :D &amp;#x200B;
I think they're talking about in the creation of the promise, rather than the receiving of the promise. For example, let's say you're writing a function that reads a file and you want to stream it so that you get it back in chunks as you read it. You can't `resolve` multiple times from within one promise, so the only way you'd be able to write this function is with a callback that gets called on every chunk (or a generator)
So, where's the part where you call the function that expects a callback? Can you show an example of that part? Honestly, one of the things that makes Promises so much easier to reason about is that they're a variable.
Wow that's amazing, good work! 
How to create a simple News Reader with Vue JS. I used the API from [newsapi.org](https://newsapi.org). The top messages are displayed and you have the opportunity to search news. The Javascript intersection observer is used for paging. I look forward for any feedback. Link to the full video: [https://youtu.be/8wPClWnmmCc](https://youtu.be/8wPClWnmmCc)
Ah, yeah I didn't optimize it for iPhone since it's also an app on the App Store, where it works better :) It's just not updated to the new version of the game yet
Yeah, I was considering this as well, but my GIFs are very lightweight so it seemed the fastest/best option. But thanks for the advice :)
Thanks!
Thanks! Would love to see your project :)
It's the most used because you literally can't use anything else for frontend web, not because it's amazingly good.
Because base class constructor starts first it is obvious that the result will be 1. It’s too easy :)
This is great. Good job. 
Very nice article, thank you!
Your gifs look great too. The texts are funny. It's really impressive. 
It's not a quiz :) It's couldn't be easy or hard. But ok. Take a point. &amp;#x200B; My first OOP language was not JS and it's totally not obvious for me. This is why I'm asking. 
I enjoyed the game, but unfortunately got some strange bug that destroyed some of the the joy. Derek got 15'999 in health, and he is now super strong (I rarely lose any health) in the dungeon. Health potion heals 1040 hp, and I got 399 for free. Upgrade is still only to heal 60 hp. I don't know how this happened at all, so I can't really help with fixing it... &amp;#x200B; [Print screen](https://imgur.com/a/Q8uOPWl)
Damn I played it for a couple min and that really impressed me.
Ditto to this bug. Loved the game though. Hope you make it available on Android too. 
Fun and quirky! Well done.
Nice alternatives. I think I like the first option, but with parentheses around the arrow function's params (readability, ease of improving).
Sorry, didnt mean to be rude
Thanks for commiserating, the frustration is real
And you didn't 👍
For me a bit of the wow factor is lost by the text-based game type button actions. I think simply having these buttons in a more 'game ui' like position would improve the feel of the game. E.g. 'build workshop' being a button from a pull-out somewhere, rather than a 'reply option'. This is a personal opinion though I hate text based adventure games.
&gt;For example, you might want to inherit multiple prototypes from several “parent” functions. When you say that, do you mean inherit multiple of the same named prototype, or have multiple parents?
Be pragmatic. Sometimes returning a function is just easier than creating a `new Promise` and all that jazz. The problem starts to arise when you have callbacks nested several layers deep. That's hard to manage. But someone who insists on using only callback functions should be reeducated or otherwise fired from the job.
You can't be finished, the workflow in my scenario requires that you accomplish 7 or 8 operations in serial. I'm familiar with producer/consumer, and what you're talking about sounds like microservices, but having a microservice for every atomic action when mutating some data is definitely overkill.
If anyone interested in taking the HTML and JavaScript approach with a framework, I would advise: https://phaser.io/
Async await is just easier and clearer. 
great post and if you are interested in scraping i would recommend also looking at; &amp;#x200B; arc90 readability - [https://github.com/masukomi/arc90-readability](https://github.com/masukomi/arc90-readability) mercury parser - [https://github.com/postlight/mercury-parser](https://github.com/postlight/mercury-parser) &amp;#x200B; these use less direct approach such as heuristics and looking for areas of dense text in a page to identify main content, ive found this is a much easier that writing a specific parser for every site you want to scrape,
The buttons are so satisfying to click. I want to click them all day.
Sounds like someone malicious got access to your web server. I would contact your provider. 
LocalStorage might work for this. Depends on the size of the data of course. 
It's not the webserver, it's just one .js file, when I remove the file everything is good
Remove the file then?
That's kinda genius, but the file have something else, that makes the website work 
Works pretty well for me
What is this js file and where does he come from ?
It's a js file that manage inputs on the website. But there is something malicious about it, that redirects people
PWAs are already severely hampered by the browser sandbox, they won't ever fully displace installed apps. Applying extra restrictions to WebViews and then forcing "installed to home screen" PWAs to use WebView is just being an asshole. All it means is I have to force my PWA to launch safari with the shell for a kind of ugly experience. It is of no user benefit.
Huh? Chrome android doesn’t even return the proper key codes in keyboard events. 
Yeah, I understand that but where did the source code come from, a library, a reddit post, stackoverflow ? Maybe you can find a non-malicious version of it or just remove the malicious part ?
this
I asked someone to make it for me,it's kinda long story, i'd like to take the malicious part out yes but I just dont know how 😢
Ah, sorry about that! It should be fixed now. Maybe you can just buy the upgrades for him and he will be back to normal?
Hi /u/Krellzar, this post was removed. To show off a project (i.e. a finished or semi-finished page, demo, working example, etc.), please include one (1) of the following: * A link to a project page with unbuilt/unminified source code -- sites like GitHub are perfect for this. * A write-up about the development of the project. This can take the form of a blog post, a `README.md` within the project, or a comment on the post itself. The details are up-to-you; you can write from a high-level about your architectural decisions, or you can write on a lower-level about the pros &amp; cons of specific libraries and frameworks you used. The main point is that you're discussing your code -- or your approach in creating the code -- in some way. * A working codepen/jsfiddle/etc. of the code. One of the easiest and most common ways to satisfy this requirement is to simply include a ["Fork me on GitHub"](https://github.com/blog/273-github-ribbons) ribbon your site. Another way to satisfy this requirement is to comment on the post itself, with either a link to a write-up, or with the write-up as the comment. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Thanks! I hope you'll like the rest of the game :)
Hi /u/difoltuser, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/mukesh_reddit, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/Blackwright, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/ihatethisjob42, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/rmkn, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
&gt; JavaScript is the future :) ...the same way global warming and resource shortages are the future.
Hi /u/johnbenrichard, this post was removed. To show off a project (i.e. a finished or semi-finished page, demo, working example, etc.), please include one (1) of the following: * A link to a project page with unbuilt/unminified source code -- sites like GitHub are perfect for this. * A write-up about the development of the project. This can take the form of a blog post, a `README.md` within the project, or a comment on the post itself. The details are up-to-you; you can write from a high-level about your architectural decisions, or you can write on a lower-level about the pros &amp; cons of specific libraries and frameworks you used. The main point is that you're discussing your code -- or your approach in creating the code -- in some way. * A working codepen/jsfiddle/etc. of the code. One of the easiest and most common ways to satisfy this requirement is to simply include a ["Fork me on GitHub"](https://github.com/blog/273-github-ribbons) ribbon your site. Another way to satisfy this requirement is to comment on the post itself, with either a link to a write-up, or with the write-up as the comment. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/jelmished, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Whatever. Just keep it consistent. 
I use them with imports and wherever the statement appears confusing and I feel the need to use them.
Hi /u/keyboard_2387, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/rcklmk_id, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/hello_I_am_bad_dev, this post was removed. Prohibited low-effort content includes: * Questions that are easily Google'd. * Memes, jokes, etc. Please post to /r/ProgrammerHumor instead. * Most images and gifs. * [Listicles](https://en.wikipedia.org/wiki/Listicle). Please just no. * Polls, surveys, etc. unless from an accredited academic body or trusted source (StateofJS, etc.). Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Can confirm. Am developer who gleefully adopted promises, and hasn't adopted async/await because I don't want to adjust. (also helps that I can't use them in my day job where I have to support IE11, so it would only be a thing in side projects)
But it wasn't a help request. It was a poll. I'm a senior developer I know what stackoverflow.com is :)
^ this.
Hi /u/rmkn, this post was removed. Prohibited low-effort content includes: * Questions that are easily Google'd. * Memes, jokes, etc. Please post to /r/ProgrammerHumor instead. * Most images and gifs. * [Listicles](https://en.wikipedia.org/wiki/Listicle). Please just no. * Polls, surveys, etc. unless from an accredited academic body or trusted source (StateofJS, etc.). Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
IMHO Just use semicolons, do not depend on JS ASI ([http://www.ecma-international.org/ecma-262/6.0/index.html#sec-automatic-semicolon-insertion](http://www.ecma-international.org/ecma-262/6.0/index.html#sec-automatic-semicolon-insertion)). Developers not always will run Eslint that can catch possible problems with semicolons, do not depend on specific IDE that shows errors for you.
the reddit preview pulls up the wrong video. It points to the first video in the playlist, and the video I linked is around 6 or 7th or something like that
change the display property
You need to set the style back to display block for the visible element.
One of the things is that "callbacks" can be a very clean way to write JavaScript code - you just need to add the "bind" operation so you can write properly decoupled code.
Ok. It was the last time. I promise
Truly living up to "General Purpose Language".
Ohh ok thanks
Thanks! I have been looking for something like this.
Nope. My vote's for spread operator
Will give it a try later
:)
Not even remotely the same thing.
I also made a backend independent visual composer a few years ago with angularjs. Using this block architecture was a novel idea, at least I thought that at the time and I was very proud of that. You know what is interesting? This is basically the same thing... I used the same layout, I used almost the same buttons, I even used the same json structure. This is so similar that if one of my client would see this, he would think this is the same thing. The only big difference I could find is that I used markdown for the text content and I have more block types with less options. Don't get me wrong, I am absolutely sure you didn't even see my stuff. It is just interesting how different developers can find very similar solutions for the same problems. 
IDK, it was never really confusing for me, the only real difference is how they return - which is also the use case. It's kind of like saying that JS is super confusing because it has `function` and `=&gt;` or that Python is super confusing because it has two kinds of dictionaries. In other words, it's only cofusing if you learned something else first.
FP isn't about eliminating side effects, but rather about isolating where they can occur (among other goals).
Sounds like something I could use for site I'm building. Has a CMS in it but the editing capabilities are pretty limited (besides editing HTML directly). Thanks, will check it out.
I think this is the best comment in the thread.
this is awesome :)
in some cases adding semicolons prevents the compiler from doing something unintended, but devs are debating for a looong time on this. so no YES/NO answer this time. \- [https://mislav.net/2010/05/semicolons/](https://mislav.net/2010/05/semicolons/) \- [https://news.codecademy.com/your-guide-to-semicolons-in-javascript/](https://news.codecademy.com/your-guide-to-semicolons-in-javascript/) \- [https://flaviocopes.com/javascript-automatic-semicolon-insertion/](https://flaviocopes.com/javascript-automatic-semicolon-insertion/)
Post the code and more information please.
This seems pretty neat, and especially helpful for limited free hosts like glitch. I've been struggling with builds there and this might be be a perfect fit. I'd only use it for demos/prototypes at this stage, but I think that's in line with the state of the project. Good stuff!
Hi /u/miipapito, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/its_just_aname, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Did you miss the part where I said “I don’t defend this code?”
You do make a very good argument, maybe I'm starting to come around. My code actually does sometimes end up just like how you wrote. Curious though, the 3 lines of async/await don't include errors right? how would that look?
Hi /u/mournful-tits, please refrain from personal attacks. Thanks.
Hi /u/Devika12134, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
I don't believe its working anymore :(
This is the correct answer. No need for separate try catch blocks.
Why have you to replace one with another one? Just simply hide one and show another one. Try jQuery. It can help you more.
Okay, I think I get what you’re asking. Technically there is no such thing as a “parent” or “child” in JS, but there is a way to simply apply the supposed parent’s constructor function within the child constructor’s context, which partially simulates a one aspect of the parent/child relationship. The other half of that process is setting the prototype of the child to the parent’s prototype. And if you want, you can event assign the parent’s static properties and methods to the child. Those are all independent steps that don’t have to be performed all at once if you don’t want to. Now, I was talking about specifically: You can have a “child class” adopt more than one prototype, although only one will be recognized as the primary link in the prototype chain. Still, you can assign all the properties from multiple prototypes to single class’s prototype through a call to `Object.assign` or `Object.create`. It’s not something I would advise most of the time, but it can be done. As for the constructors, can also apply multiple parents’ constructor functions within a single child’s context. You have to be careful with how you implement multiple inheritance in JS, as there can be several different ways of handling it. [this S.O. question](https://stackoverflow.com/questions/9163341/multiple-inheritance-prototypes-in-javascript) provides an interesting discussion on the specifics. All that to say, there are ways of doing multiple inheritance in JS, but the ES6 class syntax does not make that clear. You have a single “extends” decorator available, and a call to `super()`. If you try to call multiple supers, it will produce an error. The ES6 class syntax obfuscates a lot of what is going on under the hood, which are legitimate JS quasi-class inheritance constructs, and forces you to use a specific format. It’s still useful, but it’s definitely more of a crutch than anything else.
Browser standard will never, and \*should never\* completely replace the use of libraries. There are standards bodies involved and once developed and recommended, these standards have to be implemented everywhere. New standards work best when enabling developers to do new things they couldn't do before and should focus on building the lower layer in a way that makes things easier to build on top of. For simple things, that might mean being able to do more things easily without libraries, but the goal should never be to compete with an opinionated framework. I would rather them work on exposing the guts more so that better more efficient libraries can be made, rather than trying to get rid of them.
The day I stop using a keyboard is the day Jarvis becomes an actual reality
The language is absolutely amazing. Stop using it if you don't like it. 
How do you handle errors in functional way with async / await?
&gt;Arrow functions are not needed And async/await is?
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
Very nice. Just a heads up, your demo site is not very mobile friendly.
Thanks a lot. Just added the license.
And all you have to do is give up 8% of the market. (IE11) This is nice, and I might even choose to do this for some personal projects, because it's really nice to be able to skip that compile step. But I have absolutely no choice but to support IE11 at work. And the hot reload is so fast that I actually prefer it to manually hitting refresh to check my changes anyhow, so the compile time is definitely not an issue. At the very least, this is a very informative post about the current state of Javascript as browsers implement it today.
Exit interview: Interviewer: So, what's the main reason you're leaving us? Interviewee: Well you see, you don't use the language feature I think you should use. Interviewer: I see, so you're leaving us because you need things to go your own way all of the time. Interviewee: That's not what I said, I simply mean... Interviewer: You were right to leave us. Thanks for saving us the trouble of firing you for insubordination or needing to pay you unemployment or any other number of stupid wastes of our time. Don't let the door hit you on the ass on your way out. 
Not a problem. It's a fun and good looking game. I still have it running in the browser collecting gold. Will try to buy an upgrade tomorrow, will go to sleep now.
Sweet, thanks!
I'm not saying anyone is wrong... I just shared my personal *opinion* about what coding style I (me, personally) prefer...
The `async` library is my favorite for doing flow control with callbacks, I would probably use something like this: https://caolan.github.io/async/docs.html#series
following
For callback flow control I typically use the `async` library. I believe `async.parallel` would be the functional equivalent to Promise.all (https://caolan.github.io/async/docs.html#parallel)
Yeah, it is interesting. My idea here is to make it extensible via easier block creation. Eventually the number of block will be big, and there will be integrations with couple of frameworks and CMSs. As a software engineer we have to work on different platforms based on client's requirements. I think it would be nice to have a similar api for same kind of problem in different platforms. &amp;#x200B; It was nice to know that you had basically the same idea, and its a funny coincidence that my design matched with yours :-)
Thanks for notifying that. Will work on it.
Nice to hear that. 
I am totally just taking a stab here, throw it in a try catch block? 
The async/await example does include errors. Consider a more complete example: ```js async function main() { const thing = await getThing(1); const friend = await getThing(thing.friendId); return { thing, friend }; } main() .then(({ thing, friend }) =&gt; console.log('done', thing, friend)) .catch(error =&gt; { console.log(error); }); ``` The `.catch` block in the above example will get called if either of the `getThing` calls in `main` return promises that reject. You can also use `try/catch` blocks in the async function: ```js async function main() { try { const thing = await getThing(1); const friend = await getThing(thing.friendId); return { thing, friend }; } catch(error) { console.log('Caught', error); } } ```
But he's just so danged *passionate* about it! I don't know about you, but I usually want to kill off the things I'm passionate about
Like every other error; try/catch. When a promise is rejected with an error, await will throw that same error. 
"I'm a snowflake developer and JavaScript is ruining the planet"
 chmod u+x
Async/Await is a huge advancement in conceptional control flow. Arrow functions are at best a cleaner way to express extremely simple functions and at worst a hard to maintain mess that encourages bad practices. The cons for Arrow Functions far outweigh the pros IMO.
I used it for about 2 minutes. Just wanted to qualify. I like the idea. Congrats on building something. Most just look for already made solutions and dont even consider building anything new. Some suggestions I have are: 1. When clicking an empty block area. Try to make the whole area clickable, not just the tiny add block button. 2. once ive added a block, open up that blocks editor automatically. Dont make me click the block again to edit it. I just added it, of course i want to edit it. 3. Don't make me click a pencil icon with no info text on it to edit it. Took me about a minute to find where to edit the block. Just let me click on the block 4. Drag and drop. I like the idea, but let me just drag the whole block. Not click and drag an icon. 5. The undo and redo is a bit weird, but i think it could be useful. Just not sure how yet Ok, thats my take on it in 2 minutes. Dont take this as negative. You are at a good starting place.
I have a discord bot using Eris; https://github.com/jacebenson/cajunbot
How is this different to https://github.com/google/incremental-dom ?
/s lmao
nice, that is much better for performance i added the "const" prefix and also array notation in the promise.all: try { const promise1 = processInput(str) const promise2 = processInput2(str) const [result1, result2] = await Promise.all([promise1, promise2]) } 
yes i think that's just you const/let can be used in any block if, for, try, catch, or even a naked block (curly braces alone can be used for scoping)
It's moreso that I don't have a preference moreso than I have one. I think people also don't have a preference for promises over callbacks or async/await over promises, but moreso they have a preference against all the times that the previous practices were used poorly.
When I click the decimal button it does weird things; Press 1.2 Press + Press 1 Press . Notice how 1 now is 1.2 but you didnt press .2, you just pressed . Press + Notice how the history shows 1.2 + 1 + Also I'd map the follwoing keys to the buttons; esc = c + = + * = X - = - / = /
I suppose those are done with function Keywords as arrow functions are "harder to read" by the same margin.
...I think I'd rather have my Typescript and not depend on five different CDNs datamining my users, thanks. It might be my backend background, but the amount of resistance Webpack receives baffles me somewhat, the only bad experience I personally had with it was when some tool (CRP I'm looking at you) tried to hide it away. 
thanks for this. I just meant the 3 lines didnt have the error clause, but its still not much more. Next project I may try this out. Thanks
The Promise API is horrible. The only good thing about them is how they are related to Async/Await. There's nothing about them that makes them easier to reason about than callbacks, which makes sense because Promises are actually built on top of callbacks. I'd say that's even true for higher level control flow abstractions although then it's more of a trade-off against traditional callback based solutions (which I would argue were still better). However, now with Async/Await it's kind of a different ballgame altogether; You get the best of both worlds.
I've tried to use modules natively in my app (`script type="module"`), and loading times were reaching 20 sec in Lighthouse tests, because of the network delays when loading every module. Did I do something wrong?
Those are really important observations. I will keep those into my task list.
Yeah, Webpack is seriously great, I’ve also gone with RequireJS a few times, but Webpack is just so robust and useful.
Fortunately you didn't get the job? What kind of nonsense talk is that?
As someone who is trying to learn, why does it seem like there are 50,000 new frameworks, libraries, and tools popping up every. Single. Day. Like, is this sort of saturation necessary? Or is every framework so bad that there arises a need for a better one? It's just crazy daunting to see constant new tools on this subreddit every day when I'm trying to learn basic ones lol. 
Might be a typo 
Maybe he couldn't release the project if he would've got the job
Maybe after the interview they showed him a room full of developers forced to use Vim
Did you use http2? If not and you have a lot of modules (and other files to load), that might be it.
I did not write the [JS Frameworks Benchmark](https://github.com/krausest/js-framework-benchmark) and you are correct no one has submitted Increment DOM it appears . If you are familiar with it you should make a pull request. &amp;#x200B; I am not super familiar with Incremental DOM but my understanding is it still uses a Virtual DOM it just does the diffing between the rendered virtual tree and the real DOM rather than diffing between the current and previous state of the virtual tree. That still requires top down reconciliation. The advantage of Solid is it through fine grained subscription doesn't do a full VDOM render cycle and just directly updates one change. 
Maybe, just maybe, it's a joke?
Just bind? 
Yeah, it was on localhost, and my app is now hosted on github pages, so it doesn't support http2 :(
I've always been taught that this is considered very bad programming style.
Looks great! BTW, just noticed a little typo on the main page which says "bowse a file from computer"
a = 1; b = a; ++a; console.log(a,b); // 2 1 a = [1]; b = a; a.push(2); console.log(a,b); // [1,2] [1,2]
https://github.com/DivineITLimited/hyper-editor/blob/4a383c91718b283bf84d0bb3b4af3b3e78cb75db/src/App.vue#L62 `JSON.stringify(this.editorData, null, " ")` will produce a much nicer output in editor view.
It's that really so different?
Can you explain why does tree node drag and drop needs O(n) or O(n^2)? Shouldn’t it just be O(log n) for accessing and grabbing the node and then another O(log n) to relocate it? Making the total O(log n)? Maybe I am missing something
Good bot
And you could define your callbacks explicitly as standalone functions ahead of time and then invoke as a then-chain without using asynchronous await. Luckily we can have all the features without having to debate which is more important. Having to pollute the code with bind this everywhere is approximately as annoying as the callback pyramid of doom.
Only if you need special handling for certain errors. Otherwise I don't see why that would be bad style. It's a much cleaner code flow.
I'm sure if one were to boil all the libraries published down to syntax trees and generalize the purpose and procedures, you'd end up with quite a few identical libraries, even though they may have been built from scratch and take different ways to get to the output.
My experience with voice controlled interfaces is that we have a long way to go. As humans, we can communicate to each other with voice because we have a shared set of contextual information to draw from. And even then we still have miscommunication between humans all the time! With computers it's even worse. Keyboards and visual interfaces allow a much greater degree of specificity and explicitness than voice does. I don't imagine keyboards or visual interfaces going away any time soon.
We've been using grape.js for this type of thing and been very happy. Curious though, I'll give this a look. Thanks!
The article makes some good points. JS has had a monopoly on the frontend web and that has pushed the need for JS skills, increasing the number of JS developers. What we are seeing, like the article mentions, is JS bleeding out into other area (serverside, embedded, etc). Because of the popularity of JS this was bound to happen. What I also find interesting though, and the author alludes to it by mentioning Kotlin, is that we are also seeing other technologies bleeding into traditional JS territory. The JS frontend monopoly is starting to fall. WebAssembly comes to mind immediately. What I think we are really seeing is that many traditional language walls surrounding the various platforms coming down ... everywhere. 
**notice in this thread:** everybody in favor of callbacks over promises have one thing in common they're not talking about the importance of proper error handling you see, people who don't understand good error handling don't understand why promises are so necessary -- this is why all of the promise-pushers in this thread seem *very anal* with their concerns over error handling ;)
sigh... so few devs understand why promises are necessary over callbacks... it has nothing to do with callback hell, or nice syntax or whatever, those are merely perks and side-benefits ***it's the error handling*** you can catch all of the errors at a high level -- errors bubble up through promise chains -- that doesn't happen with callbacks, once you understand this, it's a dealbreaker for callbacks promises return results or throw errors callbacks are good for onProgress updates and events and stuff use the right tool, and understand the important differences 
Still sounds like it would be better to just implement this as a Promise instead of writing all the extra code for the seperate error http request and having to pair the incoming error request with the context of the original call.
oh certainly, there's a huge difference: the errors don't bubble so handling them is atrocious better set uncaughtExceptionHandler lmao
I mean, a lot of these projects are just resume builders for developers. But occasionally you’ll find some use case for whatever... Strangely, I find the availability of all these tools allows for smaller code bundles, if you’re smart about what to use. Using small, specialized libraries and mixing them in when you need them can result in a more lightweight codebase. However, I tend to avoid tools that are built on top of large frameworks. I want to minimize my dependency tree.
If you look, there are arrays in the JSON. That’s why. 
Can you make mobile friendly? Can you have a button for demo that just has some generic json data to show off what it can do? 
again, here's another dev talking about callbacks vs promises without talking about error handling error handling is the only important difference between using callbacks vs promises you see, errors bubble up through promise chains and allow you to catch them at a high level let that sink in, and you'll never return another result with a callback again promises are the best tool for returning results or throwing errors callbacks are the best tool for onProgress updates and events and such understand the important differences, and use the right tool
You should include default json on the example site so I can test functionality without finding my own data
man i'm running out of breath in this thread... so few people really understand promises the only value is the error handling error bubble up the promise chain, so you could catch ALL of the errors in your application with A SINGLE try/catch with callbacks, you have to write an error handler for every callback, so in switching to async/await, you are worried you'll have to replace it all with ugly try/catch blocks everywhere hahah not at all, that's the whole point of promises! let your errors bubble up, catch them once at the top level! ok, i've set you free from your mind-prison.... fly, my pretties, fly!
you guys, it's the error handling that matters! promise errors bubble up for us to catch at the high level, callbacks are bad for this
again, another dev in this thread talking about callbacks vs promises without even mentioning error handling the fact that errors bubble up through promise chains is THE important difference with callbacks, we can't cast a wide net to catch all errors at a high level -- that's what promises are for go have fun building an application on callbacks with proper error handling.. good luck that's the trend of this thread and topic: every single person defending callbacks is blissfully oblivious to error handling
I like the idea behind your framework. Seems to have a similar goal to Svelte v3: making reactive javascript UIs easier to author, through clever compilation. Using Proxy is certainly a big win here, but at the cost of older browsers. I'm not sure I could use this because of it, but hopefully we can all drop IE11 someday. Is there an alternative that could keep the same developer egonomics? How does it look if you use the signals directly, and would that work in older browsers?
&gt; never found need for promises or async. tell me about you app's error handling without using promise chains to bubble errors up and catch them with wide nets on a high level, i'll go out on a limb and guess that your app's error handling is precarious, brittle, and probably also atrociously hideous ;) i'd be very interested to hear otherwise
[There is a sample JSON file in the repo](https://github.com/shoumma/organigram/blob/master/sample_json.json), but maybe it could be made more prominent/put in the README.
If it diffs state, doesn't that mean that performance is then dependent on the size of state? How is that handled? Recursive descent a la Angular 1 or is there something more sophisticated going on?
oh man, is time going backwards for you guys? where i am, us devs are headed towards 2020, not 2010 i mean come on, they are about to shut off long term support for node 8 -- you guy are working with an unmaintained runtime **without security updates!!** what on earth are you guys thinking? i'd jump ship right away... keep it cutting edge, that situation sounds like a sinking stinker
I can understand your point. But you see, all you need to do is to understand the concept behind those tools. If you look closer you will see that not many new concepts are poping up everyday. Most projects are combination of existing proven concepts (there might be 1 or 2 exceptions). And when you get the hang of it, you will see, you are facing some issues that are partially solved, so you make a new tool. Also off-course all projects are some way resume builders for its developer. Some times you start working on a project just to learn the underlying principals. And you don't need to learn everything. Learn the language you are working one, then see the trend to pick one or two frameworks. Other libraries you can learn as you need them.
Yeah signals are completely usable on their own. I promote state for ease of use for people coming from a React background. But you can completely just not include State and use Signals and do most anything. It makes it more involved to solve certain types of situations (like ones you find in synthetic benchmarks) but in general development as long as you are fine with calling your variables as functions you are good to go. Basically treat data you set(including arrays) as immutable and you are fine. The state Object's Immutable JS like API handles that for you but you can always do it manually.
&gt;SON based tree structure with drag and drop functionally to re-arrange the tree. Show-cases some useful tree operations for deeply nested JSON data and webpack configuration for red A button to load it directly from the demo would easier
This is very cool, but seems extreme for a code challenge or interview question. How many hours did it take you? If it was more than a few hours, that's bullshit. I'm so tired of this, "hey we can't evaluate talent, so why don't you do a day of free work for us" crap.
Thanks for pointing out error handling. Obviously callbacks have no inherent idiom for error handling. I wasn’t making the case for callbacks being superior, nor the majority of an apps async approach. I’m just saying callbacks have a time and place in functional design. Not everything last thing needs to be promisified. 
Generally it is not diffing state. This is SRP using Adam Haile's [S.js](https://github.com/adamhaile/S) under the hood. So this is all through basically event subscription only updating the data that has updated. There is no reconciliation consideration on general updates except list diffing in the DOM. &amp;#x200B; I've additionally provided the means to do data diffing and there is a means to do so only on subsets of that data (say from a Redux store) but it isn't expected to be the general pattern. If data is large there is a bit of a cost and the reconciler has the ability to configure a key field. But I've used this approach to good effect in benchmarks like UIBench and DBMon both benchmarks designed to punish fine-grained approaches like Solid uses.
Who exactly are these prominent figures?
How does it compare to work-box? 
Agreed. For some reason I thought you could just paste the data in on the demo. But I'm tired and dumb.
that's what patterns are, not Code Design Patterns but I think it's common for us developers achieving almost the same UIs to common problems &amp;#x200B; Also done something like that when I worked for a newspaper website but simpler for usage (with predefined blocks) and using a structure like a React tree. In the end I think that I could do better if I just integrated the React tree itself and not translating blocks to Components. &amp;#x200B; That was a cool project (my first React Project I think) but later was abandoned and migrated to PHP because after I left they couldn't find developers to continue that :(
First example you can just use Object.values Second example you can just do Object.values.includes(3) Nice post but some better examples would be nice like converting from Object.entires back to an object or reducing a pipe of functions into a value.
&gt;How does it compare to work-box? The lib uses workbox mainly for precaching and caching but also takes into account other features such as push notifications that are not included in the workbox. 
Hi /u/underdogwebdesign, welcome to reddit! Unfortunately, this post was removed because you are a new user. This is a spam-prevention measure, we hope you'll understand. You'll be able to post in a few days, however, you can start commenting now! We'd love to get to know you. In the meantime, please read the site [reddiquette](http://www.reddit.com/wiki/reddiquette) and [/r/javascript's guidelines](http://www.reddit.com/r/javascript/wiki/index). Also, **/r/javascript is not a support channel.** For help with javascript, please post to /r/LearnJavascript instead. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
Sure, React itself is a library. However, when most people talk about using React they're referring to building their app around the React ecosystem (such as create-react-app, redux, etc) and that ecosystem is very much like working with a loosely coupled framework. &amp;#x200B; Also, how is pointing that out relevant to the discussion about Web Components?
This is awesome! Why is it a good thing you didn't get the job?
Interesting. Thanks for the info. 
Oh, nice!
 No thanks to you for the interest. 
I actually am using work-box right now for a project. I need to include some PWA functionality but I am entirely sure when to use IndexDB and when to use the browser cache, I understand of course that the appshell and static assets are to be stored in the cache but I just cant grasp the concept as what kind of data do I store in the IndexDB. If yes, with a promise wrapper? 
 In fact, the recourses that appear in indexDB are resources in which an expiration date has been defined (timestamp). That's why entries are created in the indexDB for those resources with their url and timestamp. 
&gt;Why is it a good thing you didn't get the job? &amp;#x200B;
Very much like is still not the same. The topic is web components will replace your frontend. React even states in the docs that it's built to solve a different problem than web components. I'm pointing this out so rookies aren't scared away to learn react.
Not OP, but I suspect it has something to do with not wanting to work for a company that thinks this is an appropriate interview question. 
Exactly what I thought. But what are the benefits of time stamps and the url? How can take advantage of this strategy? Sorry if my questions sounds a bit vague or too generic. 
Try catch is a strictly imperative construction. 
How does compare with other FP libraries like RxJS OR Ramda?
&gt;&gt;Why is it a good thing you didn't get the job? &gt; &gt;&amp;#x200B; &gt; &gt;same question same
I interpreted it as a tongue in cheek way as in "Fortunately for you, the code can now be released to the public, instead of belonging to my would-be employer". 
I find this hilarious because JavaScript has already basically been in this position for a long time, but has also hit some pretty obvious limits when it comes to performance as well as native interactions and as a result WebAssembly exists. If anything, I think we're finally on the verge of multiple languages being able to be first class citizens in the browser. As a result, I think there might be room for either more polyglot programming or even a decline in JavaScript. It used to be that JavaScript was the lowest common denominator - it was ubiquitous and even if it wasn't the best tool for the job, it was the only available tool for the job. I like JavaScript, but I welcome a future with more choice. I think the new era will be an era of choice.
 Check out [https://github.com/jfadev/jfa-pwa-toolkit/blob/master/pwa/sw/cache-images-sw.js](https://github.com/jfadev/jfa-pwa-toolkit/blob/master/pwa/sw/cache-images-sw.js) that for example to cache images using worbox, I have included the plugin **workbox.expiration.Plugin** with the parameter **maxAgeSeconds**. Doing this workbox will create an entry in indexedDB `{url: 'http: //...jpg', timestamp: 1554492018245}` but it will also create an entry in **Cache Storage** with the content of the image. Thanks to this workbox will eliminate the cache of this file once the current timestamp be above the timestamp of the file. In summary, this is the strategy to be able to define how long should the file remain in the cache. 
Ya basically this. So fucking dumb
Just like with "global warming", you better get ready for it, cause it's happening.
You still looking for a job? 
A quick thought is that you could associate the DOM node with a direct reference to the Object/Array and proceed to change the in-memory object with that info. domNode.ref = { sourceVal: obj.someKey, sourceKeyPath: ['key1', 'key2', 1/*for arrays*/,4,'key3'] }; You would then drop the sourceVal into the new position and you could cleanup the old position for the keyPath
Was the test data in the sample the same you showed in the interview?
Create and add the image to your page with JavaScript. You'll then have the ability to change the .src of the image dynamically. I've purposely kept this quite vague, hopefully this is how you like to learn. 
Thanks, I spend hours looking through the web for solutions that would work before posting. What I have found is people making if else statements listing every combination (is that what your note is nudging me towards?), but that will not work for 100's of items. I don't know how I can "stitch" the variable value into the image path to get it to work.
const image = document.createElement("img"); image.src = 'assets/[word].jpg' That last part me could be done when changing the value of a select box for instance. Hope this sets you on the right path.
Thank you! I was really stuck so it opens a new path forward!
Type safety does very little to actually reduce bugs: [https://medium.com/javascript-scene/the-shocking-secret-about-static-types-514d39bf30a3](https://medium.com/javascript-scene/the-shocking-secret-about-static-types-514d39bf30a3) Spending time on increased code coverage would probably result in a better capture rate for defects. &amp;#x200B;
Maybe you didn't get the job because you spelt the company name wrong ;) But tbh, not sure if Munich would be the best place to start in Germany. The bavarians are a bit... special. You should look for something else in Berlin or Hamburg!
I just started converting my app and I agree it's busy work more than anything
GitHub pages does serve over http2!
You know unpkg is a CDN mirror of npm? I don’t see why you would need another. Also if you are looking for types then you could use something like Flow’s comment types; best of both world (minus the added comment character noise). Not sure if typescript supports that yet.
Even if you don't like webpack there are (often easier) alternatives like browserify, parcel and rollup.
Im working on it. In the next minor release will be implemented. 
I find _you_ weird... why should they be more active on Reddit than anywhere else? Reddit is not the ultimate web site, just one of many, and it's quite US-centric
Whichever you're more comfortable working with. If your ordering app is simple enough, and you're extra worried about SEO, I'd go with Gatsby. There's still conflicting opinions on SEO with single page apps, even if you use server rendering. For what it's worth, I usually default to Gatsby for websites, and Next for apps.
I still can't get my head around people considering Storybook a "testing" framework
I had to do something similar at work for managing a folder/file-like structure. Mine wasn't perfect but did the job pretty great. This one seems a lot better, I'll definitely learn something from it. Thanks. 
There are definitely studies on defect capture rates. As part of software I worked on I needed to look at those rates and spent significant research time. The biggest ways of catching defects were hands on testing by people followed by automatic regression testing and unit testing. 
Why would I ever use Flow, for one. For another, unkpg is hosted on Google via Cloud*F*lare, so excuse me but no.
You are right !
yep, a recent bug i had: i have derived data (i.e. it's generated from a function, and it's not in our database). let's just say, for practical purposes, is impossible to write tests against, and is very rarely likely to ever show up in actual data. typescript found a bug where i was using the wrong property name. i was using `client.deal_name` when i should have been using `client.deal_title`. it's hard to test in automated way, and it's very rare to have data shaped in a way that triggered the bug in dev (or on prod). this is in a 5 year old repo that is in the initial stages of being converted to TS. it doesn't have a lot of js test coverage. i'm a strong proponent of automated testing - from a hierarchy of needs perspective on writing good code, good testing should come before ts which should come before linting. good testing would _likely_ have caught this, but there isn't any guarantee - we may not have even written a test for this case. i'm trying to answer your question realistically. sure you can just say "test coverage should find anything ts can find" and make a blanket statement, but realistically, under real conditions, it made very little engineering sense to spend the time testing this.
I'm happy to collaborate, this is going to be a fairly complicated project and right now it's just me working on it.
well I don't know react I'm more of a vue person but in my project I wanted to implement it in vanilla javascript 
It's absolutely stupid from the point of view of the employer too. A few months ago I had to implement a very basic REST API, complete with unit tests, for an interview submission. I passed the test and the subsequent interviews, and later found out that: * Some members of staff spent entire days reviewing batches of tests. * Despite the relatively small number of people who passed, it wasn't that good a filter, as more people failed at interview. Considering it was for a company that exclusively recruited senior engineers, and the recruitment process could take around 2 months, I often wondered how many candidates they lost out on, and how many hours of productivity from existing members of staff were lost.
Hi! For easing the preview (like using the sample file you provided in your repo) I'd enable reading a JSON from the clipboard.
Personally I love async/await. And I totally get what you’re saying. That said, you’re incorrect about the definition of a callback. A callback is, in simplest terms, a function that you pass as an argument to another function. That’s it. Callbacks are commonly used to respond to the results of asynchronous operations, but callbacks are not *intrinsically* related to async. Callbacks are much more fundamental to the JS language. You can find info here: https://javascript.info/callbacks https://www.learn-js.org/en/Callbacks You can also just look at the MDN docs on some of the native Array.prototype methods (e.g. map, filter, reduce), which take an explicitly named “callback” for their first argument, and are 100% synchronous. Now, I’m not pointing this out for the sake of argument. I think your points make some sense, given the broader context of this thread. However... I was responding to the idea that “callbacks are hard to reason about,” and that callbacks should not have been implemented in the first place. If that’s the argument, then my counterargument makes sense, I think. But maybe I totally misunderstood the intention. Maybe they meant “callbacks” to mean some specific API for handling network requests, which takes a callback to handle the results. But I took it to mean that “callbacks in general are an anti-pattern, and should be avoided.” And I would totally disagree with that.
A callback is, in simplest terms, a function that you pass as an argument to another function. That’s it. Callbacks are commonly used to respond to the results of asynchronous operations, but callbacks are not *intrinsically* related to async. Callbacks are much more fundamental to the JS language. You can find info here: https://javascript.info/callbacks https://www.learn-js.org/en/Callbacks You can also just look at the MDN docs on some of the native Array.prototype methods (e.g. map, filter, reduce), which take an explicitly named “callback” for their first argument, and are 100% synchronous. In broader context, I was responding to the idea that “callbacks are hard to reason about,” and that callbacks should not have been implemented in the first place. If that’s the argument, then my counterargument makes sense, I think. But maybe I totally misunderstood the intention. Maybe they meant “callbacks” to mean some specific API for handling network requests, which takes a callback to handle the results. But I took it to mean that “callbacks in general are an anti-pattern, and should be avoided.” And I would totally disagree with that.
Please read my whole comment because I’m gonna disagree with you first before swinging back around. I consider myself a top-notch talent evaluator; to be honest while I think I’m a good engineer as well for whatever reasons this particular thing is where I shine. I also weigh the coding exercise more heavily than anything else because we as a field have fundamental problems in how we evaluate talent - in person interviews are often unhelpful, because they don’t even remotely resemble the real-world environment engineers exist in. The idea that you can’t evaluate talent so you assign them to write code is fundamentally flawed; the only way to truly evaluate talent is by looking at produced code and using the in-person to get a sense of the human behind it. I also often walk through the code with them in the interview and ask them to explain their rationale and process. About a third of the time I sit down with them and refactor part of it with them. I haven’t asked a question like “worst case search time of a binary tree” in interviews in years. There’s too high of a chance that you ask a good engineer a question they can’t come up with the answer to or a bad engineer something they happen to have at instant recall to rely on this. With that said, I also don’t use coding exercises that take anywhere remotely that long. I give people stuff maybe a couple of orders magnitude more complex than fizz buzz, and I deliberately include a mistake or two and an ambiguous directive in the design doc to see if they pick up on it. I also tell them that the programming language is their choice and to pick whatever they feel is well suited to the problem. It’s preposterous to ask people for multiple days of their time. My exercises usually take strong engineers an hour, and rarely anyone more than four. 
Don’t get me wrong, I still use ES6 classes precisely for their convenience. They definitely look a lot cleaner on the page, which is awesome. But I do think there is a trend for people to look at terms like “prototype” and “constructor” and get lost on what those things actually mean, and using the ES6 class syntax is sort of a crutch to abstract all of that. Granted, for ES5 I’ve written some helper functions that essentially perform all the tasks that the ES6 syntax is doing under the hood, but at least I have more low level control over what’s going on, and it forces me to understand it on a deep level. It’s really not comparable to using a higher level programming language. It’s really just abstracting some of the fundamentals of JavaScript. That’s essentially the role of a library. Instead they added it to the native spec. If the new syntax were totally robust for handling edge cases (like multiple inheritance, for example, which you can only do by manipulating prototypes and constructors directly), then I would be fine with adding it to the spec. But it’s not robust. It enforces a single commonly used class-like abstraction, when other options should be available. That’s my only beef. I think it should be implemented in a common library, not natively.
&gt; i have derived data (i.e. it's generated from a function, and it's not in our database). let's just say, for practical purposes, is impossible to write tests against, and is very rarely likely to ever show up in actual data. &gt; &gt; typescript found a bug where i was using the wrong property name. i was using client.deal_name when i should have been using client.deal_title. it's hard to test in automated way, and it's very rare to have data shaped in a way that triggered the bug in dev (or on prod). That's a great example- easy for TS, hard or impossible for JS. I wonder if using TDD would have forced it to be more testable. &gt; this is in a 5 year old repo that is in the initial stages of being converted to TS. it doesn't have a lot of js test coverage. i'm a strong proponent of automated testing - from a hierarchy of needs perspective on writing good code, good testing should come before ts which should come before linting. good testing would likely have caught this, but there isn't any guarantee - we may not have even written a test for this case. &gt; &gt; i'm trying to answer your question realistically. sure you can just say "test coverage should find anything ts can find" but realistically, under real conditions, it sometimes isn't realistic to expect that. in this case, it made very little engineering sense to spend the time testing this. having TS here absolutely did head off a bug a prod user would have found. &gt; &gt; i guess i come at it from the perspective of: sure one safety net is probably more effective than another type, but if you can have multiple safety nets, why would you only limit yourself to one because of some intellectual argument about one being more pure than the other? I agree multiple safety nets are better, but what if they catch %99.9999999 of the same thing? 
Java doesn't allow multiple inheritance, so it's not that core a feature. Python does, and it's useful sometimes, but like you said it's an edge case. Agree to disagree on language/library abstractions, modern languages all abstract from byte code.
Yup can confirm that. My guess is the localhost server is what's not http2, as a lot of easy setup Node web servers use http1.1 by default (eg. Next.js dev server with default config).
The only dependency in this project is Typescript. So it is as vanilla as you can get, with types :) The example just wraps the editor in React because that's probably going to be a popular use case for the editor.
Okay cool I could help you out then, if you are still interested
No option for RxJS based Observables ? :)
Great response. 100% agree with you here and we do something very similar. However I don't allow the candidate to submit in a language of their choice - its predetermined by the role applied for, but love the idea of this, infact would like to be in a position where all problems could be solved by the most appropriate language - I'd worry about the reality of it though, maintainablity, justification of choice and so on.
Definitely. I've never done open-source before so I'm still learning how to manage collaboration. Right now I have somewhat high-level tickets in the project board, but I'll move them to issues instead, I think it makes more sense. Then we can go from there, whether it be contributing to an issue or starting some discussions about the project's details. I think this is an interesting project because there are many mature editors out that we can learn from, but when it comes to handling layout and rendering word-processor style, examples are non-existent since successful implementations are all close-source, so we have to pioneer our own approach.
Yeah &gt; examples are non-existent since successful implementations are all close-source (e.g. Google Docs, MS Word Online) was thinking about this on the bus ride home. So how do you suggest we stay in touch ? I am going to dive into the source code fit everything together, mentally. &amp;#x200B;
FYI on your demo site: " **or, bowse a file from computer** " &amp;#x200B; Unless we're talking about the Mario universe, you're missing an "r" :) 
We just use is[word] or has[word]
Yea, that seems to be the most common by a mile.
The "b" in front is helpful sometimes but I think it's harder to read. I will keep it in format like isAtctive or so. Again, that really depends on the project and the team you have to work with. As long as there is one standard for the project and everyone follows it, there is really no big deal. 
Dont know why the 'b' is necessary. Typically we only use B when noting a button with getElementById on front end javascript files
Oh yeah definitely, I think consistency is key in a project. Would have no problems naming booleans with "has", "is", or similar prefixes if need be.
It's just an article to pad a resume. That's all these ever amount to be. Just throw out all the reasons why you'd want to bundle your code, like security. I'm pretty sure JS has the largest amount of non-engineers who call themselves _coders_ or _developers_. Really it's just people who like to write their poorly thought out thoughts on a blog.
Webpack is really not _that_ hard.
I saw the "b" thing waay back for the first time then never again until recently. In TypeScript, based on the "b" prefix for booleans, I also started naming interfaces as "I\[Name\]", or enums as "E\[Name\]", types as "T\[Name\]", and so on. This is so that when I declare and define variables down the road I know what I'm using, although I do that almost entirely for personal projects but is kind of why we do the "b" for booleans.
Just having autorefresh and autocompile is a big plus. That's actually what accounts for most of my time developing is going to a terminal to rebuild. It's seconds but seconds add up over days, weeks, and months. Also using webpack/babel you can always use whatever features you want on any browser because it handles transpilation for you. Something that you'd need to be mindful of when you use features is availability on all browsers, and consistency on each browser. Then all the versions that you may or may not encounter in the wild. Yeah, why waste time being _minimal_ if it doesn't save you time in the long run.
I just made a discord channel, let's discuss further there! [https://discord.gg/n9C98dm](https://discord.gg/n9C98dm)
Shouldn't it be Made With Love, Built With JavaScript? 50% /s
Isn't it a bad idea to rely on a plain Object's property order when iterating over an object when it comes to sequencing? I know that Maps guarantee order, but I thought Objects could be potentially unreliable (but I don't know why specifically).
For me, always and forever: bolThing, numThing, strThing, arrThing, objThing, funcThing 
The term you're looking for is Hungarian Notation and it's *not* recommended as it makes your code hard to read. is/hasSomething or IS/HAS_SOMETHING (for constants) seems like the generally recognised convention.
&gt;Hungarian Notation Thank you for sharing that! I didn't know how it was technically called, this is something I learned years back during a course module and then probably forgot about it or just never learned that. So, TIL!
What a completely half-assed set of "studies". And of course I'm not surprised to see people conflate static typing with type safety.
Keep practicing mate. That’s the only way you become better. Do tasks you hate and perhaps, challenging several times till it becomes very easy and not too bad for you. 
You can add typescript without Babel or webpack and you could install the node_modules if ya don't want cdn
Pls explain? I don't know much about Germany
Do you just like shit talking instead of saying anything constructive
Coverage is only good for telling you what isn't being tested yet. It isn't going to catch a null ref exception if you misuse an optional field. and might even give a false sense of security if you only test success cases and neglect testing degenerate cases. On a side note, Eric Elliott is somewhat infamous for pushing his own opinions as facts, and not really considered an authorative resource around these parts.
I would tell past Pookles it's worth exploring and contributing to open source projects! Everything in FOSS is exposed for you to see and there's a lot of opportunities to ask questions through mailing lists. It's hard learning to read other people's code, heck sometimes it's hard to even politely articulate a question about a piece of code, but it is a skill worth having and one that will carry you far.
Quite a few typos and CSS errors. Example: "**What Our Partnership Will Result To**" should be "**What Our Partnership Will Result In**"
Just so you know, this is commonly referred to as Hungarian Notation and has a decently long Wikipedia article on its use and practice.
While not relevant to tools and commands, My "trick" in a new workplace is taking notes of absolutely everything. I find that it helps me quite a bit learning what the environment is, and where things are. Each place I've been to had their own flavor for commits, and code review etc. So writing everything down helped me a lot to get up to speed faster.
JavaScript is not good at concurrency not of these solutions are good.. the quicker you get over Javascript in someway having good language features the better.. The sooner you see how elegant it is elsewhere the better.
Working on a personal project like this now. ES6 Modules and no runtime dependencies at all. I’m also am using comments for TS type checking. It’s been fun, I’ve learned a lot, and it’s not too bad. But I think build steps are going to stick around for awhile. You just get so much utility for not too much additional complexity. 
It's an attitude thing, really. What we often call "technician" might be less validated than an engineer, but you still expect them to sometimes say "no" to the client. And that responsibility they take is the reason why they _can_ take it: the confidence it's unlikely anyone else will say "yes" to a terrible idea - though reality sometimes gets in the way, see WV case. In IT, saying "no" is likely to stunt your career. So you get used to it, until it grounds down your morale, and just do the fastest thing forever, not considering whether the job is done well, or whether the job should be done at all. Because you really, really don't want to be seen saying "no," ever. 
[removed]
What's the point of that in Typescript? It has a good typing system, and with all the IDE magic these days, that convention becomes unnecessary imho.
The TypeScript personal naming convention I mentioned before is also based on Unreal Engine's I forgot to add, it's just a way to improve readability and sort of categorize everything with prefixes. I wouldn't say it's unnecessary at all since it really helps me figure out where's everything at especially when reading old code, but I very rarely really use it outside of my own personal stuff.
Berlin's tech scene is poppin'! …if you wouldn't mind being in Berlin.
Look at laserweb. It might give you some hints.
...yes, you could invent Webpack from first principles, in shell scripts and makefiles. Why would I want to do that, though?
&gt; I grabbed today Mead's node course, since I was very happy with his vanilla JS course - If anyone is interested, I can share my thoughts after getting my hands on it. I am interested in your opinion after you get your hands on it!
I've had more than one massive project (in one case 10+ developers having spent 10+ years working on the code), dropped in my lap, sometimes with as little as 8 hours to get up to speed before the lead dev left for another job, with no one else around to help (I was supposed to be the go-to guy when *they* had problems), first big deadline a week away, and the assurance that "you're a senior developer--it should be no problem!" &amp;#x200B; Not having enough time to detail everything or take much in the way of notes I found it best to create an "entry map", or general outline of where and how the main functionality starts and flows outward (initial file loads, config files, main/shared assets, modules, etc.) I could then use this to conceptually "enter" the functional path of the application I wanted to focus on. It was also extremely useful when I was getting other developers up to speed. &amp;#x200B; For example, an online game may start by loading a main "index.js" file which loads "config.json" that's dynamically loaded from a Mongo database. The "index.js" entry point would then load "assets.js" to pre-load assets and finally "game.js" to load up the game code. I'd break this down into something like: * Main page loads: index.js * Loads: config.json from database (`loadConfig` function) * Loads: assets.js * Loads assets: 1.jpg, 2.png, 3.svg * Loads: game.js Now if we needed to add a new asset I'd at least know where to start looking. This is obviously a simple example but when the code gets very complex it really helps to pinpoint areas to focus on (for new development, bug fixes, etc.) Generally speaking, I would stop describing at any point where a someone else or some other third-party library takes over (the MongoDB module, for example), except maybe to note the function that's responsible for the interaction. Leaving off specifics (like an extensive list of assets), is probably also a good idea--you want this to be easily digestible and fairly brief. &amp;#x200B; Other than trying to understand the purpose of the project as a whole (which required that I just sit with it and use it for some time), I didn't really worry about *overall* implementation details and instead I focused on the part of the application I was to work on next, and only the details that pertained to that task. If I didn't need to change the configuration, for example, I might not even know that Mongo was being used. When the deadline was tight I often didn't have a choice. &amp;#x200B; This tunnel-vision approach to a large code base was the only thing that kept me sane until, after a few months, I was able to pick up the more holistic features of the architecture and better understand how the details I'd been working all fit together. &amp;#x200B; Another thing that I could recommend would be to look at the developer output (console.log, etc.), to see what patterns, if any, were used by previous developers so that you can create your own and **make them stand out**. Watching reams and reams of log output can be tough unless you have some clearly-visible visual cues that you can pick up on. &amp;#x200B; Finally, [breakpoints](https://developers.google.com/web/tools/chrome-devtools/javascript/breakpoints) can be amazingly helpful when those logs get long or something unexpected is happening in your code. &amp;#x200B; Hope this helps!
The general benefits of the improved intellisense helps to prevent bugs in your code by providing readily accessible source documentation and immediate compile-time error feedback. I will admit I'm a TS fanboy...
I work in C so I can't offer anything JavaScript specific but I can cover the large codebase aspect. Forget trying to learn the whole thing in detail. I work on a million plus lines of code project and I can barely keep the area of the code base I maintain straight in my head, let alone the project at large. The best thing you can do is learn and memorize how the project works at the 10,000 foot level, how individual functional areas are laid out, and then load implementation details into your head on demand by reading the code in the area you're going to work on. As you work on it day in and day out, some things will become second nature. You'll start reading a function and be able to visualize how it maps into the larger scope of the project, code paths to get there, and so on. Another thing you can do is participate in code reviews. They give you not just the opportunity to see how the code is modified for a specific fix or feature, but also insight into how your colleagues approach the code base. 
Yeah, I agree with all of that. The best coding challenges I've done were interesting enough that I actually wanted to spend more time on them. Both were doable within an afternoon. I also agree that reviewing code with someone is the best way to assess whether you want to work with someone. But I've also seen coding challenges that were like "build us a little app." That's just crazy. Thanks for the response.
Hi, noob thinking about teaching myself code. Can you please think of the best / worst interaction during an interview you’ve had and what the candidate did to create that impression?
Thanks for such a detailed answer. I particularly like the idea of an 'entry map' as well as writing things down. And I think the tunnel-vision approach you're describing is probably good advice for learning any large and complex system. Thanks for the thoughtful response.
Compile to wasn't?
Underrated comment, but I'm in the same boat as OP and also have another new guy with less experience who started at the same time as me. I told him the third day the best advice I can give him to not get overwhelmed is document things. We've been helping each other document different areas of the codebase, it's been a great way to build this communication path for later and get an understanding of my teammates line of thinking. 
This sounds really similar to what /u/monican_agent said. I appreciate the feedback - it helps me understand the process. From what I've seen so far, this is pretty much how they've been approaching training me. 
I believe it would make more sense to adopt typescript features into native javascript, rather than support typescript, since typescript just transpiles into javascript anyway.
You’re crazy. JS does not have a range operator. `[3..6]` is a syntax error.
Advantage would be that parsing and running typescript code would be similarely as fast as javascript, and that developers won't need transpilation build steps anymore. If TS ever get's supported natively, I'll immediately transition from JS to TS simply because of the static typing advantages.
Looks like CoffeeScript.
Uhhhh don’t reference any libraries 
&gt; but what if they catch %99.9999999 of the same thing? Type errors are well-defined, pre-made, and pleasant to deal with.
You can't use `[3..6]` specifically, but you can replicate the functionality. function range(size, startAt = 0) { return [...Array(size).keys()].map(i =&gt; i + startAt); } // usage range(3,6); // outputs =&gt; [3, 4, 5, 6] [Credit to this StackOverflow post](https://stackoverflow.com/a/10050831/1265817) Then it's just a matter of [comparing your two arrays](https://stackoverflow.com/a/14853974/1265817).
It's not about catching bugs; it's about making it easier and faster to write bug-free code in the first place and to correctly refactor that code. It's especially useful with large teams or open-source, where developers have brief interactions with code they aren't intimately familiar with. For example, when using a third-party library or a section of code I haven't touched before, I want tooling to help me quickly write correct code the first time, following the API. Also, when submitting a patch to an open-source library, I want tooling to help me quickly navigate and modify the codebase, following the established structure.
Like... Build a browser out of JavaScript... Without libs? Good luck.
Eric Elliott is a hack, and the work he references is not in any way scientific. Neither is what I'm about to say, but I'm going to say it anyway: in JavaScript, my bugs are often due to its dynamic nature and its type system. My wariness about bugs is factored into the logic that I write. When I write in some statically-typed language, I can rest assured a whole class of bugs flies out the window, which gives me room to introduce other bugs. What I'm saying is that there's some acceptable threshold of bugs that developers tolerate when balancing everything else. And I'd rather work on logic bugs than figuring out why `undefined is not a function` for the millionth time.
It will have all the disadvantages from every language that tries to be a first class browser language. 1. It’s been tried and failed multiple times: Dart, Native Client, ActiveX 2. It will create fragmentation in the development community. 3. It is redundant for all dissimilar languages with the introduction of WASM, and to a lesser extent, Emscripten and ASM.js. 4. It is redundant for all compile-to-JS languages because you can already compile them to JS (indeed, this is what they were designed for). 5. Typescript is owned by a single company, rather than a standards body. This will be incentive not to implement it in all browsers, making it less useful (see Dart). 6. Typescript is owned by a single company, which can cause situations of no practical recourse should the web standards bodies disagree with implementation details. They could fork it, but then it wouldn’t be “Typescript” anymore. 7. Not that Microsoft wouldn’t do the same, but the web standards body has as one of its prime directives not to break the web. As much as possible, updates to the language are as forwards and backwards compatible as possible. An entity like Microsoft could ignore this, and drop support for something or make some other kind of breaking change. Browsers would have to try to (again, as they once tried to do with JS) manage multiple engines in the browser for different sites on different supported versions of typescript. That, or we would have to use a build system that converts newer versions of typescript to older versions (or vice versa)... hey, this sounds familiar. 8. A significant percentage of scripts are of sufficient simplicity that the burden of adding types would not provide any overall benefit. Yes, it could be safer and prone to less of certain classes of bugs, but by the same token, there are yet safer languages than typescript that could also be used and compiled with WASM, with better performance characteristics to boot. There is no logical reason to assert that a program should be more secure than JS, but scoff at the idea of using an even more secure language. Typescript, for better or worse, is a middle-of the-road language. This is similar to the problem of people asserting the performance superiority of their pet JS structure using microbenchmarks, but then failing to see the irony when they refuse to even test writing their code in C and the using WASM to run it in the browser, yet claim to care about performance.
&gt; The general benefits of the improved intellisense helps to prevent bugs in your code by providing readily accessible source documentation and immediate compile-time error feedback. I'm far from convinced that these types of errors wouldn't be caught with tests easily, they are the low hanging fruit of unit testing.
Drop this habit. It's one of the most criticized conventions.
I think I’ll end up doing that, been reading for a while now and I think it’s not the right choice. God bless whoever designed find all and replace in the VS Code IDE.
&gt; It's not about catching bugs; it's about making it easier and faster to write bug-free code in the first place and to correctly refactor that code. Sorry but this sounds like marketing. I'm sure you could say good things about JS over TS too. Dynamic typing isn't a deficiency in a language, and adding static typing doesn't necessarily make things better.
Ruby has `..` and `...` range operators. JS doesn't.
This is my experience, having worked on both JS and TS projects. When I say "tooling" I am *specifically* referring to the TS language service and what it offers the developer at design-time. Leveraging the language service is possible from js and TS, but the experience is better, easier, and has more features when writing TS.
That outputs [6, 7, 8]. Fixed: function range(from, to) { return [...Array(to - from + 1).keys()].map(i =&gt; i + from); } console.log(range(3, 6)); // [3, 4, 5, 6] To get the same result with your function, you'd have to call it like this: range(4, 3) // 4 numbers, starting a 3
The idea is the static checker catches that class of bugs for you, allowing you to save time by not having to write all those unit tests for that class of bugs. 
Vue is gaining in their ass. 
Extremely conservative area of an already conservative country.
Assuming you start with a basic HTML page within a browser, use the browser provided “document” object to create HTML elements, modify as needed, and then append said elements to DOM. let div = createElement(“div”); let p = createElement(“p”); p.innerText = “Hello”; div.appendChild(p); document.body.appendChild(div); This process can clearly be long but it is possible to build anything you want with Vanilla JS. If you are trying to render HTML from a Node server, I recommend [Pug](https://github.com/pugjs/pug).
No, but I can give you examples of bugs that Typescript would catch but JS wouldn’t without *unreasonable* testing. Typing is really useful for edge cases, or finding dependencies in object requirements when the requirement exists far away from your initial calls site behind a rare conditional so you wouldn’t reasonably think to test for it.
You mean spread operator? https://developer.mozilla.org/pl/docs/Web/JavaScript/Referencje/Operatory/Spread_operator
Are you asking if there is a Google search API, rather than trying to parse the HTML response?
Please vote Yes or No on my Twitter poll. Thanks!
Hi /u/MaryDBlackwell, this submission was removed because you used a URL shortener. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
Maybe, but types are faster to refactor and write than tests. Also the compiler enforces it. Unit tests have to be written by hand and you will forget cases. For me static typing is the foundation on which to build unit tests on. And on typescript its actually very little overhead (this isnt java).
Yeah you will need to use some sort of higher language like pug, jade, jsx, etc if you are trying to render an html page purely out of javascript. If however you are simply trying to render html elements, there are many different ways to do so, and you will likely need to be a bit more precise in your question.
Bug free code is bs but the rest is true. I had to refactor stuff in a big js codebase with good unit tests and it was horrible. With a typed language it would have been a couple of shortcuts and I wouldnt need to rewrite as many unit tests
Repost after one day ( original by same author: [https://www.reddit.com/r/javascript/comments/b9m62o/error3\_package\_for\_advanced\_error\_handling\_in\_js/](https://www.reddit.com/r/javascript/comments/b9m62o/error3_package_for_advanced_error_handling_in_js/) )
Yep, it was mine. I want to understand why it's not interesting to community. Is it an idea or explanation. I fulfilled lack of explanation to estimate it. I'm not going to turn the community into my personal blog.
It's good to hear that :) I'm just too tired of the large number of people who just post their project again and again every time they commit something, or those that submit every piece they publish on their blogs.
If you’re interested in 2D I’d recommend Pixi.js which has good features and is very performant. 
The closest thing I can think of is the spread operator but it doesn't work quite like this.
Also consider was[word], mightBe[word], and couldHaveBeen[word]
even then he'd be missing an "r"
I'm always suspicious of JS's representation in these polls. Its really the only language in the list where you might need to "know" just to do trivial website things. Its like that with job listings too. 
Or use the .innerHTML method on a DOM element and output the HTML manually.
I'm not that kind of guy. Well, probably you will see my name soon again. Because I have a bunch of libraries which were in development for a long time and got production ready in the same time.
What do you think about this package? Do you like it? How do you think could it be helpful for you?
Upvote for the humorous typo
Aye for pixi.js, easy to use, powerful, and lighting fast.
Thanks. I got confused because it seemed like a special property of promises or something. What would Promise.resolve()'s arguments be, in a normal situation?
Vue does sick gains up their ass man. 
Similar background here. I once had a candidate who somehow learned the content of one of our tests (the problem solving one, basically, it is testing your ability to write algorithms). People talk and it happens and in order to be fair, we use a standardized test we run in « peer programming mode » with the candidate. Well. This candidate... He memorized part of the wikipedia page about that very problem. At first, I was quite excited as algorithms are often dreaded by candidates because they think they would have a bad time, which is wrong and usually because they underestimate their skills and are afraid of maths. We usually end up having interesting discussions around optimization, research and stuff or at least, I can motivate them to train that skill (I’m pretty lenient, as long as someone is able to solve a problem and explain it to me, I’m more than OK, you don’t have to be scientist to be a great software engineer). Not that time. Basically, he activated my CS mode and I started asking more advanced questions (as the test can be pretty boring if you’re good as CS). Confused pikachu face on the candidate. Ok. I start questioning him why did he chose this algorithm, and that’s when I understood he was trying to bullshit me : he told me he was using it everyday. Note, I’m not against people using wikipedia, and if someone needs to use documentation to solve a problem, they ‘re more than welcome, it also shows they are not afraid to show they don’t know everything and that they are willing to learn. So. He was using everyday an algorithm that you’re not supposed to use directly, as some really well written libraries exist to perform that task. I’m curious, I’m asking about the context (nothing in his background showed that he had a CS oriented job, he was a software architect), more confused pikachu face. Ok. At this point I went back in full interviewer mode and offered him to solve the problem using a more « naive » approach. It went downhill from there. He was struggling to write a basic loop, didn’t know any data structure and spent his time trying to impress me by using CS oriented techno babble. I could go on, but it’s a pain to remember what was my worst interview ever. Out of respect for the candidates, I usually turn the interview in a CS course when they are struggling (my interview is one in a set of interviews, depending on what the job is, candidate failure may or may not be important) and all of them told me they loved the way I conducted the interview :) That time, I struggled to stay. Don’t pretend. People are expecting to see you solving problems, it’s ok to struggle with problems designed to be thought inducing. But if you pretend to be an expert to scare the interviewer out of questions, be ready to be interviewed as an expert. And if you have an ounce of awareness and you’re candidating in a firm that is known to have high standards, remember that they respect their candidates by giving them interviews with actual experts. TL;DR: Interviewer for a CS position. First question of the test leaked, candidates memorizes wikipedia page. Interviewer excited at first because of his love for science, asks questions. Confused pikachu face candidate. Ask basic questions. Still confused. Candidate starts bullshiting. Interviewer sad Tennant face. PS: Cherry on top, I learned afterward from our HR department that the candidate had a reputation of being a compulsive liar. And I had two different sources that told me he was somehow harassing women at work.
it depends what your needs are of course - I've recently implemented a 3d editor in vanilla JavaScript. I derived a lot of inspiration from three.js and more notably [glMatrix](http://glmatrix.net/). I prefer glMatrix because it sets out to do one thing and do it really well. Its code is pretty clean yet pretty clearly written by mathematically-minded folk. three.js code is a nightmare to me personally but as a suite of tools it's fantastic. One thing to recognize is that if you are dealing with 2D operations only _use these libraries very carefully_. They will do their best to optimize for the parameters you give them, but ultimately you're better off using something that is built for 2 dimensions if that's what you're working with. It's just much simpler. My advice would be not to look for something that "deals in terms of canvas". Absolutely leverage a math library like glMatrix, but deal with the canvas interactions on your own terms. Otherwise you might find yourself in a situation where you are overly limited by "convenience"
This looks great! But I don't seem to be able to visualize any JSON files from my project. (e.g.: [https://github.com/Enteee/plantuml-parser/blob/master/test/fixtures/class-classes/parse-out.default](https://github.com/Enteee/plantuml-parser/blob/master/test/fixtures/class-classes/parse-out.default)) Maybe the code does not handle arrays as root nodes properly?
Ah, uh.. I see. The JSON files have to follow your \`employee\` structure. I get It that's why my files are not working. :) Would be cool if your project could handle any valid JSON. But anyways great job, thanks for posting.
Ctrl+Shift+F. All the time. 
Morning! I've made a checkers game (tried) and am having a bit of a kerfuffle tidying the finishing touches. I'd absolutely adore anyone that could help me tie it all up. [https://github.com/Whispergnome/Checkers/blob/master/checkers%20unique.html](https://github.com/Whispergnome/Checkers/blob/master/checkers%20unique.html) &amp;#x200B; &amp;#x200B; Thank you very much for your time. 
I think this gets to the crux of the matter of an inherent tension between typed systems and "partial" static analysis solutions towards quality, vs tailored test suites. &amp;#x200B; A JS developer who can manage unit scoping well, is rigorous and efficient at TDD &amp; UT coverage can verify the behavior of their system to a strong degree - undoubtedly with much better rates of detection than the best automated solutions. Arguing on this basis isn't a fruitful conversation, in my opinion, but that doesn't really matter, as most developers are less than optimal at their UT coverage. &amp;#x200B; Large teams don't tend to have the benefit of a uniform cohort of engineers who all share the exact same priorities for unit testing, design philosophies or other characteristics. Some developers in a large org will be diligent, and conscientious, but one can run into situations where some devs played fast and loose with their test coverage, and delivered functionality in a short amount of time which made their resume nice and flashy to move to their next role, while leaving behind gaping test holes, which weren't obvious to the managers. Strong typing forces developers to be clear about contractual expectations, for which the compiler will catch a range of dumb mistakes before run time - many of which, as you mention, unit tests would also catch. &amp;#x200B; A big strength of the checks to me is also in providing semantic guard rails between component authors and consumers, especially as component contracts need to evolve and change to support new scenarios. Let's say you want to change a data interface contract to start disallowing nullables on a member, but you don't know where it is used, or how that data is makes its way to be passed in by consumers. Large codebases entail expansive internal dependency hierarchies. UT's depending on how they are written aren't necessarily concerned about the exact formats your dependencies are expecting- your UT's may have dependency injection operating with assumptions which are oblivious to this change, and would stay green here. In this kind of situation, the type checker can help you work through the ultimate implications of such a change, and to be mindful of sub-areas you'd want to re-test to verify. &amp;#x200B; If any single approach was taken, the best primary solution would be for solid suites of UT's to be written in the first place, but that often isn't an option after the fact, and UT quality is never uniform across a large team codebase. Static analysers and typed languages can help provide a strong, consistent level of protection for specific classes of problems, especially on areas where you have low quality UTs or limited coverage .
 I've added reference to Node.js as an example of big project who switched to error codes. Well, what about your concerns: &amp;#x200B; 1) The native Error object already provides enough information (line number, stack, message). You add a few things on this, but... *are they worth it?* Native Error in JS is one of the worst error in the programming languages. It has no structured stack trace which PHP had in 2004. This is why \[library which captures stack as object\]([https://www.npmjs.com/package/capture-stack-trace](https://www.npmjs.com/package/capture-stack-trace)) has 3M downloads. I think some people don't known that it could be better and others just humble themselves. 2) They will most probably end up doing so themselves There is some helper code: arguments validation, helper methods like valueOf and toJSON. I think noone won't write it again and again. Isn't it what libraries serve for? &amp;#x200B; 3) ...that more precisely fits their needs Of cause general library couldn't fit all needs. There are things that always missing by library. But I've collected those of them which I met during years of my work. &amp;#x200B; 4) important than having a code or a format method, which some people will not even need. If your error contains some details you will always need a method to create a message. You can put this method in error once or write it right in place probably several times. &amp;#x200B; 5) (And having a code property... well, you can just add it *if you need it*.) All errors should have a code. This is what make them a data, not a string. Except if you just write some one-time code. &amp;#x200B; 6) Finally, I'm afraid *Error3* is a fairly unattractive name. And here I'm agree with you, need to think about it. &amp;#x200B; Thanks for your feedback. 
Why pack a utility function into one line? It also creates 3 arrays and a inline function every call. const range = (from, to) =&gt; { const output = [] const ascending = to &gt; from const delta = ascending ? 1 : -1 for (let i = from; ascending ? i &lt;= to : i &gt;= to; i += delta) output.push(i) return output } \^ Creates one array, handles descending ranges. The pressure these kids today put on the garbage collector, I swear. &amp;#x200B;
This article does a poor job of summarizing the report, which has it's own summary text: https://research.hackerrank.com/developer-skills/2019
Interesting. I’m currently working on a Page Builder SaaS and my implementation is also very much like this. My idea features sections (as seen here) and components (blocks). A component can be anything from basic markdown text to headlines and slideshows.
Just put 2 as second argument which will give you indentation with two spaces 
Phaser.js is a game engine library built on top of pixie.js. it does a few additional things for you such as handling animations. Still very flexible, performant and easy to learn. I'd recommend this library.
Hi /u/w3hubs18, this post was removed. Since we are a programming subreddit, there are very few instances where visual media is valid content for /r/javascript, including screenshots, demos, etc. Memes and other low-effort content are already prohibited. Please use the `submit a new link` option with a valid source URL, whether it's the project homepage, a blog post, etc. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
What do you mean by “rendering”? That word has multiple related meanings.
&gt; Yeah you will need to use some sort of higher language like pug, jade, jsx, etc if you are trying to render an html page purely out of javascript. You're the epitomy of what's wrong with the JavaScript community. Can't render a simple page without bringing in libraries and the kitchen sink to do it for you.
Maybe OP once saw something like `[3..n]` or `[3..f()]` which *isn't* a syntax error. The first snippet is the same as `[3.0.n]` or `[Number.prototype.n]` and the second one the same as `[3.0.f()]` or verbosely `[Number.prototype.f.call(3.0)]`. /u/10secondhandshake
What do you mean by boilerplate? Angular targets enterprise applications IMO , if your app is simple and doesn't require let's say form builders and services , etc then yes it's over kill , I'm using the ng cli and the setup and wiring of things is almost eliminated , In our company we like it very much since it's full fledged , I don't need a seperate http lib , or forms validation , etc ... And testing side is awesome too . I almost forgot first class typescript support .
&gt;It has no structured stack trace Oh, but then again, neither does your library, right? In any case, I wasn't arguing any of these: - That native Error is great, or even good in general. - That your library doesn't add anything over it - That codes aren't a good thing Instead, my argument is more like this: - Native Error is _good enough as a base_ to extend. - Most places I've been, usually prefer defining more precisely _how_ they extend the native Error. - The thing about `code` was just an example of the previous point. Sure, _most_ people will want error codes, but not all. And more importantly, a lot of people will not want a _generic_ container like your `details` and/or the `errors` collection. Also, regarding `code`, the thing is _it's very easy to add the property_ and requires little effort, while there are other, much more important concerns about error codes.
Done this on numerous occasions across a career. I'll assume you're presented with the usual maintenance problem - you've been asked to modify or extend some functionality Assuming you don't have access to someone who knows the codebase in detail already (in which the answer is simply - keep asking questions) then there's really only a few things you need to know. A, How does the flow of control work in the system to get to the functionality I need to modify, B where is the functionality I need to modify. and C. how does modifying that functionality impact elsewhere. What you shouldn't worry about too much is any detail for functionality outside the area of interest. Certainly you should try to pick up some idea of the overall structure of the program, but in the first instance what you'll gain enough from A. If you try to get up to speed with all of a large codebase all at once to make one small change you're going to get overwhelmed, try and focus as tightly as possible on just the functionality needed to change for the task in hand. Of course the tool to do this is the debugger. There's several approaches to getting started, you can put a breakpoint at the start of the system and follow down, or find some suitable action against a location in the code and put a breakpoint there. Whichever way your objective is to understand how you get to the code of interest and how that code works, but you don't need to understand much outside this in the first instance. However, that said, anything that happens that you don't understand should be followed rigorously down as that's how you'll most likely miss important things. Obviously the best way to make any actual change is generally to find a piece of functionality that does something similar to what you need, then copy that For instance in the simple case where you're adding something like a new input field, you duplicate an existing one. Understanding a whole codebase is really just a question of progressively expanding your knowledge through repeated applications of the above. If you know any psychology you'll know that the human mind can only hold 7+-1 'chunks' of information in it at a time, although each chunk can itself contain 7 'chunks' and so forth. No-one actually understands a whole codebase in detail in one go, instead we understand at some top level, then can progressively drill down. Someone who does understand all the code mentally has that tree structure filled in for the whole system, but in the first instance you can be productive by understanding the particular branch you need,
It's all about the gainz bro!
This is a library I author: https://github.com/drcmda/react-three-fiber Uses Threejs, but allows you to componetize your app through React, which you can tap into the React eco system for things like state, animation, etc. It has game loop semantics built in.
&gt; error handling is the only important difference LOL Moron detected 
Good news: It already does! Just remove the type annotations. TS is JS apart from a handful of stuff, enums I think. Type annotations are not used for code execution, they are used for checking code at development time, not used at run time. (type annotations *could* be used by a runtime to decide how to internally store something efficiently, but that has much less of an impact than you may think, compared to current runtimes "wait and see (what values will be stored)" method, which only fails if inside large loops you change types a lot, e.g. calling the same function sometimes with number, sometimes with string, in the same argument position. That is easily prevented by good coding style and adding type annotations makes such style even worse, so you should not do that kind of stuff anyway, types (TS) or not (plain JS).
\&gt; Oh, but then again, neither does your library, right? It was an example that JS Error in its current view isn't good. Even in things that couldn't be changed. So it's better not to use Error and "good" together : ) I'll just connect it all in two theses: 1. Error could be extended. There is no need to add something between. 2. The way library do it isn't the way that everyone need. &amp;#x200B; 1. Library adds more. It doesn't simply extend Error. 2. I described issues which this library solves. This solution based on experience of big projects like Node.js. It doesn't give any sense to tell that there are another cases. The main idea is to use codes and details instead of concrete strings because the last is antipattern. If it's not enough, then probably you're doing something wrong. &amp;#x200B;
I've built enterprise apps with all three, and have to say that angular is by far the worst. and a ton of people start moving away from it (if you check the latest industry reports) but that does not mean that angular jobs will just disappear from one day to another. there is plenty of software and teams that still use angular. this (satirical) article is completely identical to my experience, when moving to a studio that used to work with angular mostly. https://hackernoon.com/why-angular-made-me-quit-web-dev-f63b83a157af
I sometimes wonder what these think "higher languages like pug, jade, jsx, etc" are built with. Magic and fairy dust?
I would definitely recommend the p5.js library, its great and easy to use. Big plus if you already know how to code in Java in Processing, that's how I got into it. 
Ionic is built on Angular, so it's not going anywhere.
&gt; huge amounts of boilerplate, i can't reuse components as easily as i can in react. Bundle sizes and load times. It depends on what patterns are you using, and what people wrote that code. You can have this in react too.
Also, in Visual Studio, I use Ctrl + “,” for stuff like types and methods, I don’t know if this is available in VS Code 
Angular is still around because there is a lot of companies that built their core product in it and can't afford to switch to a new framework. So if you join a company that needs an angular Dev, you're working on broken and outdated code
&gt; And all you have to do is give up 8% of the market. (IE11) Where are you getting the 8% stat from? [StatCounter puts it at 2.2%.](http://gs.statcounter.com/browser-version-partially-combined-market-share#monthly-201903-201903-bar). Obviously your stats may differ, but those are your stats, not the market stats.
Why did you get +3 upvotes and I got -5 downvotes for the same question xD
well you can either render it directly into your document with writeln or use an existing html outlet which innerHtml you can write into that then will be rendered by your browser into the dom structure. 
Pick something that solves a problem that **you** face. I find that having a problem that I can relate to pushes me to finish the project.
I'm gonna give you the only realistic answer: look for jobs in your area, and count if there's more for angular or react. In italy, e.g., till very recently there were at least 4 angular jobs for each react job, but the gap has been diminishing. Still, knowing angular is more in demand than knowing React (here). That's why I tell you, look for jobs in your area and try to understand.
 [https://github.com/tortikolis/Slot](https://github.com/tortikolis/Slot) Here is slot game I have made using Pixi.js. It has predetermined outcomes. PLEASE if someone can review code. This is my first time making anything related to games/animation. Thanks!
Is it? [https://blog.ionicframework.com/announcing-the-ionic-react-beta/](https://blog.ionicframework.com/announcing-the-ionic-react-beta/)
What do the examples you provided do? I'm not sure I understand the syntax.
That they're confusing AngularJS with Angular doesn't speak too much of the report...
This comment doesn’t speak too much of the state of the JavaScript ecosystem. 
Keep calm and code Ruby as JS sucks.
Couple things I've noticed in my part of the world, and working with both. &amp;#x200B; React is very 'javascripty'. What I mean by that is if you know JavaScript well you're going to pick up React and apply common patterns to solve problems. Not every team or organization has people with strong JavaScript skills and knowledge. For instance, concepts like services, interfaces, and types are not foreign to Java or .NET/ C# devs. So Angular makes sense as a framework. However concepts like destructuring, functional programing, and Async/Await can be foreign. So React may not be the best front end UI for them. For your questions: Angular 8/9 is going to be very similar from to newby as 7 is. There is no reason to wait. Maybe? Depends on the project and team. Look up `&lt;ng-content&gt;`. That allows you to wrap components in a react way. And I don't know if you're using Angular CLI but that should reduce all the boilerplate &amp;#x200B;
That's true, but ionic 4 has split the core framework into ionic-core and ionic-angular modules specifically to become framework-agnostic, and there are ionic-react and ionic-vue modules in the works. Angular isn't going anywhere due to the massive quantity of existing production systems that use it, but ionic's use of it currently isn't really a strong argument that it'll stay popular in the future given ionic's stated repositioning.
Cmd + Shift + F: Find in project. I find this absolutely essential, but a lot of juniors don't know it because when you've only built your own projects, you kinda know where everything is. Cmd + T: Jump to file. Pretty good because you can just start typing and it'll fuzzy search for you, e.g. if you have a `Animal` prototype in Node, Cmd-T and start typing 'anim' and you'll find `models/Animal.js` that defines it, `controllers/animal.js` that defines the endpoints, `client/components/Animal/Animal.test.js` that has your React tests for the `client/components/Animal/Animal.js` component which is exported by `client/components/Animal/index.js`... Install a Git Blame plugin for VS Code. I like [this one](https://github.com/waderyan/vscode-gitblame) because it doesn't get in the way. Plenty of people like [this one](https://gitlens.amod.io/) which is like a swiss army knife for Git, but I think it adds far too much into my view that I just don't need. Git Blame tells you who last committed the line of code you're on. It should show you the commit message and/or link to the PR where it was merged, which would lead you to some discussion on why the commit was made, and why the code is the way it is. At the very least, it gives you the name of someone on the team that you can go and ask about the code, but chances are that person's memory of code they wrote months ago is rusty. My general tip is, if you're not getting tickets and the boss just wants you to spend time learning the codebase, make a branch and start refactoring something. Find a React component with more than 100 lines of code (not counting CSS-in-JS) and try to break it up into smaller components without breaking the tests or the render. Find a big Node class (not including schemas) and come up with a better abstraction. You'll find that big files in legacy code tend to do something important and touch lots of other files. Worst case scenario, you trash the branch. Best case scenario, you fire up a PR for your changes and impress the new boss. It's so so easy to feel overwhelmed in the first few days/weeks/months because you're surrounded by developers who "grew up" with this app, and know the code pretty well. No one expects you to be at that standard for a good long while, and it's totally ok to say "I don't know yet." 
Where does your passion lie? That said if you do a self guided project it doesn't matter because you can do both. Find or do something you're interested in. Or see if you can join a project with someone else, just let them know you're new to it. Alternatively there's things like project Euler which you could do.
Wow, Thank you so much for your time! This is more than I’d hoped for I really appreciate your help!
Well, valid question. I used `n` and `f` as placeholder. I can provide you with a more realistic example … code that OP might have seen in some code base: Number.prototype.median = function (other) { return (this + other) + 2; }; const array = [3..median(8)]; Above, I add a method to numbers which you should never do actually. In the last line, I define an array of one element, namely 5.5=(3+8)/2 and *not* an array of some elements from 3 to the result of the call to some function `median` as OP might've incorrectly thought.
Really looks like coffeescript; won't work there too btw: [3..6] would return [3,4,5]. You'd need [3...6] (three dots). Try lodash's _.range or use Array(4).fill(3).map((v,i) =&gt; v+i))
I've been grappling with this question myself. I have more of a JavaScript background, so React fits like a glove for me. It just makes more sense, it easier to use and far more intuitive. I recently picked up Angular. It is like a different programming language that is entirely different from JavaScript. I had to learn Typescript, and though I appreciate a typed language, I don't feel it was necessary. I don't have a background in C# or .Net or any other language that Microsoft is catering to, so why should I learn Typescript when I've delved deep into JavaScript? These are some of the things that irked me. In conjunction with the aforementioned irritations, Angular just does things different. If you are coming strictly from a JS background, it will take some time to learn the *Angular Way* of doing things. It is hard to be choosy when you live in an area that primarily caters to Angular. So in the end, perhaps there is nothing wrong with learning both. 
This is a good thread to pull. Maybe consider a task in your day you find tedious, or something wrought with human error, which you could solve with some code. That might be a promising place to start!
Exactly! I use React, Redux, Redux-Saga with Typescript Integration and I have to initialize a lot of boilerplate for simple forms
Exactly what I've been looking for, thanks!
I finished the largest piece of text I've probably ever written: [https://staleclosures.dev/from-redux-to-hooks-case-study/](https://staleclosures.dev/from-redux-to-hooks-case-study/) 
nope
Don't use shortcuts. Don't focus too much about "perfect looking code". I tended to always use the parameter \`id\` for everything. (because it was nice and short) These days I've payed my debt and I'm trying to use \`areaId\`, \`userId\`, \`fooId\` instead.. You get the drill. :D &amp;#x200B; Also, modules are great if you use them carefully... I also tended to break my code up in to 15 smaller modules... and trying to have all 15 modules in your head at once while debugging can be quite the headache.. :D So yeah, MVC is great, if you don't do it toooo much :D &amp;#x200B;
You have it almost exactly backward. "Dynamic typing" isn't actually a thing. All it means is that the language *isn't* statically typed. It is, literally, a deficiency. *That* is the power of marketing.
Savage
https://youtu.be/Dk6sphzmKO8
For my money (and my time is money) all of them. I would not consider adding testing an app that doesn't have static type checking.
Why?
This is interesting because I 100% agree with your points on Angular, but 100% disagree with your points on Typescript. I used to feel the same way about Typescript - that it wasn't necessary. Well, it still isn't. But what I found is that Typescript, with good IDE support (i.e., VScode), helps you catch errors before the code is even compiled, as you're typing them. Misspelled property names, treating a string as a number, etc. I'm not 100% satisfied with every aspect of Typescript, I think decorators are confusing and an easy way to write tightly coupled code, (and one of the many reasons I don't like Angular) but for the most part, I program faster in Typescript because I spend less time debugging, and it's easier to work with typescript in a team, since your IDE will tell you how your teammate has set up the function \*they\* were working on. &amp;#x200B; &amp;#x200B;
So that devs will have a hint to correct usage. Just like react hooks have linting rules to prevent conditional hooks creation.
FWIW I use React with Typescript and love that combination :-)
Note that the latest version (3.x) doesn't use Pixie but has its own renderer.
&gt; with all three Angular + React.... what's the 3rd thing? Vue?
the question is still why. why not just talk to the devs? whats the worst that could happen if they DID use promises? i mean you anyway cant await anything outside an "async" function. sounds more like you're trying to wall off / secure badly written block.
If you want to do 2d, take a look at Phaser at phaser.io.
Is it worth in 2019? sure. Will it be worth in 2022? sure. It is worth to start learning Angular now? imho, no.
Your position on typescript is naive at best
* Don't finish learning it. And don't bother learning 8/9. * Yep, it is a bit unreasonable. * Yes, to some degree, but its still going to be a bit convoluted due to its core nature. The only reason I know of to use Angular is if your job requires you to. Ideally you would get a better job though. 
Huge red flag imo
Because the function must be pure and synchronous, and the devs are junior/interns.
Ionic **started** as Angular, but now they aren't attached to any framework.
Nice vue btw.
If everyone just worked fine together, that will be just great.
i have the same stack, except typescript, and very happy with it. React for view, redux for decoupled data and explicit data flow (sometimes a bit of boilerplate, but worth it), and saga for decoupled async logic. Works like a charm. That being said, i have seen pretty messed up react codebases though...
I think you should simply use comments, or communicate better with them.
Maybe look into Formik. If you're storing form state in Redux, then yeah, that can definitely overcomplicate things.
Write _and maintiain_ those test cases. The more tests you have the more time you have to spend taking care of them as the system evolves. So being able to delegate part of that effort to the IDE and compiler is nice.
You might like https://p5js.org
Don't get me wrong, TypeScript is growing on me. The point I was trying to make, is that most people that use Angular also use TypeScript, which means that seldomly do you have the choice to opt out of learning TypeScript if you are learning Angular to work with a team. This coupling of new language plus new framework can be a marriage that React and JS developers such as myself find tedious; especially when first learning the Angular framework.
This is the only reasonable answer. 
Well, if it is an async function, it will necessarily return a Promise, which you can detect for (instanceof, thenability) and throw or console.error. &amp;#x200B; If you want to go for the jugular (and by necessity make your code quite weird and not acceptable to a lot of people), you could possibly override methods in the Promise builtin before you call the junior's functions, and then reverse those changes after the function has been called. That, however, is a bit paranoid (code review will probably have better results) and earn you the ire of anyone who thinks that builtins shouldn't be messed with.
That actually gives me a pretty nice idea haha thanks :) &amp;#x200B;
https://netmarketshare.com/browser-market-share.aspx?options=%7B%22filter%22%3A%7B%22%24and%22%3A%5B%7B%22deviceType%22%3A%7B%22%24in%22%3A%5B%22Desktop%2Flaptop%22%5D%7D%7D%5D%7D%2C%22dateLabel%22%3A%22Trend%22%2C%22attributes%22%3A%22share%22%2C%22group%22%3A%22browserVersion%22%2C%22sort%22%3A%7B%22share%22%3A-1%7D%2C%22id%22%3A%22browsersDesktopVersions%22%2C%22dateInterval%22%3A%22Monthly%22%2C%22dateStart%22%3A%222018-04%22%2C%22dateEnd%22%3A%222019-03%22%2C%22segments%22%3A%22-1000%22%7D
\[dev who is working on huge angular app and absolutely love it\] I am not sure if its a rant or a sincere question. But here is my answer. 1. **I can't reuse components as easily as i can in react.** 1. This is true. Angular has something called modules and its kinda fucked up. You need to learn about Angular module, and how you can/can't reuse component. This is the **only** thing I hate in angular. But once you learn modules, you will be good. 2. **Bundle size and load time:** 1. What bundle size did you experience in your react app? You should divide your app into modules and lazy load them. After gzipping you can reach about 100kb initial load and lazy load rest. Angular 8 and 9, will reduce those 100kb to less than 15kb (without any code change). 3. **is it worth it to finish learning it now or i should i wait for angular 8/9 and see how it goes?** 1. There will also absolutely no API changes in angular 8/9. Only compiler and renderer changes. So effectively Angular 7 = 8 = 9. 4. **Building relatively small and medium size with angular seems really unreasonable, any thoughts?** 1. Can you explain why is it unreasonable? I am working on two project. One very big and one barely 10 component. I love to work on angular in both. You should learn Smart-Dumb component pattern and how it applies to angular. Its probably most important topic. 2. Are you using redux (ngrx)? I am sure, you aren't. Using that will enhance your dev experience. 5. **Any way to reduce boilerplate in angular and improve code reuse?** 1. Honestly, I have no idea which boilerplate you want to reduce. Its a framework, like sprint/django, not a library like react/jquery. There will be some bootstrap/modules/configuration files, like all framework. 2. A very things an angular dev should learn is how to keep logic away from component. This involve learning about services, smart/dumb component and later, ngrx/effects. This will greatly improve code reuse. &amp;#x200B; Once you set up you framework, you would be surprised (shocked) how fast you development will be. Also, if you go to europe, you dont complain how you can't buy rifles as easily as in US. Europe isn't US. It has different advantages/disavantages. Allow yourself to be comfertable in the new environment. I am sure you didnt learn (React+ React forms + React router+ Redux) etc in just one day. &amp;#x200B; Also, people in this thread don't know shit. &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B;
/* Please only use synchronous code */
this is solid gold advice i used to be one the guys who would bookmark those "great" lists of project ideas, start one and then immediately fizzle out. the notion of building something to just build it isn't very motivating to me. i find it way easier to stick to building something if it's scratching a itch i have about a particular technology or it's something i find neat. i have been curious about graphql for a while and building something using that has been a blast op, you should take a step back and think about what you wanna do because the pool of potential projects is so large, it's hard to recommend one that would appeal to you and you don't have to choose between back-end/front-end, you can do both! i was always find the best way to get an idea for a project is to take a look at websites you frequent and see if you could adequately recreate them or specific parts of them you like.
This won't show as they'll just extend the class. I'd prefer big red squiggly lines.
I’m sorry if this is a stupid question but what do they mean by “an internet of things”? 
 function myFunc(arg1, arg2, flag=true) { if (flag) {return “Please use only synchronous code”;} // actual code here } Force them to provide flag=false or it won’t work?
Projects that produce good eye candy are always quite nice for playing around. Not only do they look good when you want to wow someone (facile, but true), debugging tends to be more immediate as you can see what the output is directly rather than checking data. Not necessarily games though, visualisation tends to be nice. 
Yes it is still worth it, looking at agularDart because of flutter.
Try writing an app to split bills and expenses amongst a group of people. (see splitwise) Start off with doing everything on the front end, and saving to the browser local storage. Then once you have the user experience down, start storing the data to a back end. Make sure you write tests for the business logic! 
Do you often find yourself in situations where you don't know know what type a variable is, and it's hard to find out? If it's just a project between the two of you, you can decide for yourselves. But whenever you end up working on projects with other people, option 1 will always be the convention. 
I agree with you, once you take the steps to learn TS it can be quite beneficial and it does exude a certain warm feeling seeing everything typed on screen and having VScode catch all the errors before you even lift a finger to compile. But harken back to a time before you learned TS and try to recall the drawbacks: 1. Microsoft produced. Why? To cast a bigger net (no pun intended) on more programmers using Java and C# so that they can enter our JS community and space. 2. The time it takes to learn TS well, when you already fully knew JS and did not need this extra time expenditure. 3. You really do need it for a framework like Angular which is a framework that does not play well with JS, and does not do things in a pure JavaScript way like React. So in the end, if you are a JS developer and you like React but all of a sudden decide to switch to Angular for work or other related project, you find yourself having to learn a) a new language b) a totally new framework c) Using less of the very JS you took so much time to learn.
Just figured out how to print 2d array with proper formatting lol
So basically, make it look like a proper website?
I've never been a fan of Hungarian notation. (Though with jQuery I would prefix with $)
Well in every JS projects you can have types error. Our projects are pretty common JS projects. We are not writing a compiler or something hard like that.
Unit test them describe('myPureSynchronousFunction', () =&gt; { it('returns X', () =&gt; ....) it('does not return a promise', () =&gt; ...) })
That's an odd question. What's this about?
I was searching for the name of this convention, thx ! I love using $ for HTMLElement object. Example: \`const $button = document.querySelector("button");\`
Work within the parameters of the task. Ask more seasoned teammates to guide you once you get stuck or do not understand how one part connects to another. If it's one big monolith it should be relatively simple to get going even on your own. Although it may take some time, so don't beat yourself over if you take longer than expected. I would also start considering JetBrain IDE's. As they are designed for this kind of work.
Well, if they're juniors/interns then guide them directly by either pairing with them or white boarding the solution before they implement it. Have them PR their implementation and code review before merging. IF they have implemented something that doesn't fit the architecture, then go over why their solution wasn't the correct fit with them so they don't make the same mistake in the future. Enforcing a linting rule for something like this is super passive aggressive. 
The double dots isn't new syntax, rather a consequence of the ambiguity between the dot operator for accessing properties and the dot for decimal places in number literals. Given a dot after a number, which usage should be used? JavaScript will assume decimal, but you can follow it with another dot (0 decimal presumed) to get to property access. 3..toString() Is the same as (3.0).toString() You can also simply wrap your integer literal in parens to avoid having to do this in the first place (3).toString()
I agree with this in general. I will say the reload times are probably going to feel slower especially if you weren't using typescript with react. Typescript compilation is notoriously slow because it basically has to compile all your code. It only very recently (in v3.4.2) introduced incremental compilation which will make a huge improvement to rebuilds. I expect the angular team to build this into the cli pretty shortly
Internet of Things or IoT refers to basically any device that has a connection to the internet. A popular example is a smart fridge that can connect to the internet to give you weather reports. Some people call it a convergence of modern tech with the internet, i.e. internet connected cars, watches, glasses, pens, 'books' etc. List goes on!
What are you trying to do?
Your fridge could be an IOT device now. So is Google Home and your television. IOT is quickly taking over everything, because it enables devices to update themselves and interact with the larger world. It's happening so quickly that we kind of take it for granted. My new garage door system is WiFi connected. WTF. You could also call it the Internet of Shit. A lot of shitty stuff is becoming Internet connected for dumb reasons.
It depends on the company. Are you trying to build a team of great engineers, time not an issue? Language is meaningless. Do you need stuff done, _right now_? Language expertise is key. 
By weird coincidence (or not?) I just noticed something similar in /r/javascript where it came up as well https://www.reddit.com/r/javascript/comments/b9yb7l/what_naming_conventions_do_you_guys_use_for/
Yes, I can’t take the report seriously when I see AngularJS in the list.
I agree with other commenters, you’re taking a lazy and passive aggressive approach here. If you don’t want her to make her mistake work with them, pair with them, code review with them. 
I think that a good place to start is to make a portfolio website as in a website all about you!
Thanks!
For Redux, we found **ngxs** to be easier to use and more Angular-y than ngrx. Ymmv, of course. And we love Angular in our environment, too!
Sooo, write the structure of the website on Visual Studio or whatever, then show my employer the website (using the source files) during the interview? or do you mean an actual website that you can visit and is genuinely up there on the web?
It's pretty common to put up a portfolio website on the web. It's a good way to show off your skills in both programming and website design
All the best programmers I've known have been opposed to dynamic types or neutral at best. I dont understand why they are so popular; seems like pure overhead. 
Here ya go https://github.com/florinpop17/app-ideas All credit to u/florinpop17
Seems like your friend should learn TypeScript and have a real static type system to work with
DUDEEEEEE. Do you know something called angular-hmr? If not, google it. We dont need incremental compilation.
Thank you!
Ah ok! Thanks!
yes, I am using ngxs in both the apps. But i hasitate to recommend it since its not created by angular team.
Eh that’s not a good determining factor. Most companies would hire anyone who knows any of the major frameworks if they cared about frameworks. Most companies would also hire someone good at vanilla JavaScript over someone who has framework experience. Frameworks are tools and they generally aren’t hard to use if you know one of them.
If you name your variables well, you should be able to infer the type easily without any kind of annotation. If types are so important to you, I’m not sure why you wouldn’t use Typescript even in its most basic form. Also, arrow functions are cool but you should consider using the function keyword for easier debugging and improved readability. Most of the time you probably don’t need them.
What a coincidence lol ! We have no relations with this guy haha. Thanks a lot !
Wait, Angular is still a thing?
Those aren't good reasons to not learn TS, IMO. In fact, those are reasons *to* learn TS. I don't know why MS supporting TS is a bad thing either, they're not a bad company
Is it bad that I can't tell if these are real things, or you're just throwing out random acronyms? FFS this industry moves too fast. 
As somebody with TWENTY years Javascript experience (albeit only on and off for the first half of that) I can tell you that based on HUNDREDS of employer enquiries, that "Most companies would NOT hire someone good at vanilla JavaScript over someone who has framework experience "
You’re right but the guy you’re responding to is a realist. And the reality is hiring managers do look at these things. A lot of the time your resume might not even make it to the manager if you don’t have the relevant framework on your resume. That’s a fact. And I worked at a startup where the hiring manager was a dope and specifically looked for someone with angular experience, even though he should have just hired a smart JS dev as you say. 
Workers in factories have videos, flyers, talks and warning signs in-location. It's not unreasonable that our libraries remove cognitive load from the developers. One red line can save hours of debugging, talking, expounding and explaining. Errors and linting **are** communication. Better than any manual, documentation or talk. 
lol, I hear that. Give it five minutes - I’m sure there will be another bowl of alphabet soup to learn by then.
I fricking love typescript. It forces you to write better code, if you follow the linters. I love types as well, and declarations. They really help me out personally. 
Can you specify an example where a constant boolean might be useful ?
As a related question - moving from react to angular at my most recent job switch - has anyone found it much, much harder to find online resources and documentation for a specific problem your stuck on? It might just be me, but finding the appropriate StackOverflow answer has seemed much more time consuming (and often leads to questions for Angular 1/2)
This will literally be every year of your life as a web developer for as long as you stay in the career. There is always going to be something new to learn, a new language or framework, a new abstraction of JS that simplifies things. If you’re resistant to that, and believe you’ll just journey through life as a pure JS dev, you’re going to hit a wall quickly. 
Typescript isn't a new language though. It is adding type annotation to JavaScript. Otherwise nothing changes. You can pick up the basics in less than an hour an progressively enhance from there.
Typescript isn’t C++, it’s still JavaScript with typing and some extra features. You can still write JavaScript in TS files. Heck, I worn with some offshore devs who write almost 100% bad JS only without leveraging any of the benefits of TS, on an angular project. I feel like this is a stretch complaint. 
Coming very soon is the 'ivy renderer' that is supposed to make the bundle size much, much smaller https://is-angular-ivy-ready.firebaseapp.com/#/status
Definitely they do. One big example is Salesforce where all the interview questions I was given were based on actually knowing JavaScript and not a framework. I had similar experiences at my interviews at Google, Apple, Microsoft, and IBM. I’d say web shops definitely care more about frameworks. I am not sure about start ups as I generally steer clear of them as they don’t pay as well.
Ember? I always considered that to be one of the big players.
I’ve never had that issue applying for jobs. Most resumes also are highly fabricated imo. I interview people often as part of my role and generally I mark more things out of resumes then anything. I don’t disagree that hiring managers are inept.
I would not write every single JS notations cases dude lol. I chose to assign a function to a variable but you can't say if it's the right notation is this case because it's out of context. In some cases, it's useful for more readable NodeJS modules: \`myModule.sayHello = () =&gt; {console.log('Hello')}\`; We don't use Typescript for reasons. I will not debate on that, we got private arguments. I'm a fan of Typescript btw.
Well my area definitely has more demand for angular oh, they basically want someone that knows a front-end framework. Knowing vanilla JavaScript alone isn't good enough, but it is obviously a prerequisite to fully understand the frameworks that they're looking for. They even mention Vue in some of the ones I've seen which makes me super happy to see, as it is my preferred framework, however it is not very common to see it in my area.
I disagree, that's why I said to look for the jobs first. &amp;#x200B; I have sent plenty of CVs for jobs requiring Angular without having Angular on my cv and I got almost no response (I have mid seniority) even for junior positions. &amp;#x200B; Not every area is desperate for developers the same way, nor companies are run in the same way. If they need technology X and a candidate doesn't have it he likely won't even get a phone interview, let alone a technical one.
Hiring managers go consult tech leads to make any relevant hiring decisions. And if that's a company where's that not the case when you don't want to work there in the first place.
Remember when no one was hiring for javascript but jquery developers where in high demand? Everything old is new again.
You're cherrypicking a handful of top level companies that are much more interested in your academic and open source career (and obviously experience). But those companies amount for the 0.1% of open positions out there. Hell, Accenture alone has likely more developers than Google and Amazon alone and it is a consulting company where your technological stack is much more important to sell you to their clients than being technically strong on JS.
If were coming from an Angular background there would be many things about react you don’t like. It’s just part of being used to something. It would be the same if you were to switch programming languages. At the end of the day, are all component based SPA development libraries built by talented engineers. -You can produce a rich websites with any of them. -You can find jobs for any of them. -You can build performance apps with any of them. Most posts like this are people looking for confirmation that what they use is superior. Developers should be open minded and willing to try new things. 
It depends on what I am hiring for. If I'm looking for a contractor to come in and assist with a project, I want them walking in the door with as much experience in the tech stack of the project as possible (read framework experience). If I'm looking for someone to bring on full time and long term, I want someone who knows the fundamentals deeply and has a passion for mentoring those around them. &amp;#x200B; I don't think we can make blanket statements about what hiring managers will prefer. It really just depends on the situation.
Wow i'm really surprised. Angular being more regarded than React really shows how undeveloped/primitive software development in Italy is. 
Yeah my experience says that doesn’t happen always. I’ve interviewed about 36 times in the past five years. It’s been frustrating. 
I didn't say it's more regarded, I said it's more requested for jobs.
I've been working as a front end dev for 25 years now. I've used all the major frameworks and libraries in that time. I recently changed jobs from a Microsoft .NET/Angular shop to a Node/React shop and what I found during that time was that recruiters in the southeast US are ravenous for React developers. I had to buy an app for my phone to block all the recruiter calls I started getting because somehow my cell number got into someone's database somewhere. &amp;#x200B; React's recent 16.x releases have included so many improvements to React that I can't recommend using anything else at this point, unless your team is already stacked with Angular and .NET developers (.NET guys like Angular better, generally, because of TypeScript looking like C# and the opinionated way its projects are structured). React Context and Hooks are such a powerful combination that we've been able to dump Redux, which was the single largest stumbling block for new developers during the learning process. The new patterns my team and I have built are reusable, easily testable and can be split into packages with little effort from inside a Yarn workspace. &amp;#x200B; Angular also forces you to use TypeScript, which doesn't have a sensible return on investment for people who understand ES6 and use modern tools. Eric Elliot can explains this perfectly: [https://medium.com/javascript-scene/the-typescript-tax-132ff4cb175b](https://medium.com/javascript-scene/the-typescript-tax-132ff4cb175b) &amp;#x200B; I'll also refer you to the State of JavaScript 2018 survey. [https://2018.stateofjs.com/front-end-frameworks/overview/](https://2018.stateofjs.com/front-end-frameworks/overview/) Angular is still lagging behind React among developers. Look at the **massive** difference between those who have used and rejected React vs those who have used and rejected Angular. This is even before the 16.x version of React took hold. I predict 2019 will widen that gap.
I wish I had read your comment a year ago... Would have saved some heart and head ache 😆
Using react + babel+ typescript + eslint and webpack for bundling. When using babel there's almost no difference between js and ts compile times.
&gt; Most companies would hire anyone who knows any of the major frameworks if they cared about frameworks. Most *good* companies. Everyone says this but at the end of the day a lot of companies are still going to drill you about framework specific knowledge.
I'm curious about what tools you use for this? Is it directly in the code via javadoc style comments? In a README, a Confluence wiki, in Evernote?
I've worked with all the major libraries and frameworks and provided you're capable enough, there is absolutely not that big of a difference in performance and developer experience that it would justify such frustration and hatred towards any of them. I have a feeling that you guys have worked on mismanaged or misconfigured projects that were a nightmare for reasons other than the framework.
My general viewpoint is if you are building something really large, angular is the way to go. If you're building an app in a larger web site react is simpler. For example, I recently built a CMS for my company in angular. It consists of hundreds of components, dozens of services and tons of routes. Building this in react would have been a nightmare. The way angular allows you to pass services around with dependency injection is a life saver. Angular's router is more full featured IMHO. And things like http interceptors are a life saver. Not sure why you're having trouble reusing components in angular. Its dependency injection model means that parents dont need to be aware of what props their children need, which is super convinient and makes refactoring so much easier. If I decide that a component needs some new service all I have to do is add it to the constructor. No going to the components parents and figuring out which has access to the thing I need and passing it down through props. If you separate your app into lazy loaded modules page load time isn't much of an issue. And if you're building an spa, which is really what angular is for, the page load is a one time hit. In my experience working on a large angular project, the page load isnt something people notice. Is it slower than react? Maybe, but it's still under 500 ms so who cares?
nickyoung.gif
Valuable, articulate insights you bring. 
Ngrx isn't made by the angular team either but both ngrx and ngxs have angular team members involved in the project. Neither is official.
IBM here only hires for Angular. I applied with React, and tough luck they only hire for Angular. 
New hot techs being used / promoted means that the area is growing and creating new products / start-up. Hence IMO you can tell quality of software development in an area by the demanded technology. If old techs are still highly demanded, it means that the area is not growing much in terms of tech. Most used tech (you said PHP) and most demanded tech are two different things. The former can be caused due to legacy but they might be migrating. The latter is caused by growth.
Hi /u/Altessaire, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/AbdrahmanDiab, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/cerulean-skies, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/dfam02, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/drink_with_me_to_day, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/10secondhandshake, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/michael2ib1989, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/astrodoge, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Valuable, articulate comment you bring. Why don't we argue intellectually instead of making edgy sarcastic comment? Would love to see your counter-argument.
Sorry, i couldn't give you names, twitter search is weird and finding back such things is like finding the needle in a haystack. It's usually something like this: [https://twitter.com/\_mjuric/status/1114243546687725569](https://twitter.com/_mjuric/status/1114243546687725569) but i am dead sure i have seen it from people that evangelize WC professionally.
I would definitely go with the first approach. The whole Hungarian notation thing looks useful on the first glance but is totally useless in the end. I've tried it when Microsoft made it popular (long time ago...) These days you have IDEs that support you with such things. In my opinion code must be readable like a book. oMyFancyObject... what a c... I would recommend to go with Typescript instead of JS. This would be by far more valuable than this style guide discussion. Don't get me wrong, a style guide is a good thing but refactoring these days works really well but if your project grows, adding types is quite hard...
I'm in Italy, but I wish I was in a city like Milan or Rome with jobs near me ahah. I have to work remotely, or nothing.
yes, vue. its my absolute favourite in terms of efficiency, weight, docs, and maintainability, but i dont want to make this another vue promo post :) but you can see that vue has started overtaking angular in a lot of European and most Asian markets. which i love
No.
What if you want to extend your sayHello() method to something like this? const myModule = { language: 'en', greetings: { 'en': 'Hello', 'fr': 'Bonjour', 'es': 'Hola', 'de': 'Hallo' } } myModule.setLanguage = language =&gt; { this.language = language } myModule.sayHello = () =&gt; { console.log(this.greetings[this.language]) } myModule.addTwo = num =&gt; { console.log(num + 2) } myModule.setLanguage('fr') myModule.sayHello() The methods that use 'this' need to be changed to standard function definitions in order for it to work. At this point you've got a mixture of standard functions and arrow functions. If you're writing a style guide, your ultimate aim is readability and consistency is it not? &amp;#x200B; Just my opinion though :)
I hate so much that Google named it Angular!!! 
Yeah agreed with this. For enterprise apps, Angular is a solid choice. Its reactive forms library is top rate.
Finally someone with some sense. Aside from having too many Angular positions around you (which is unfortunately a case for me - there's probably like 7:1 ratio in favor of Angular), there's hardly a reason to choose it. React is better in almost every way, and if you use modern linters, latest ecmascripts, you get all advantages Typescript offers... without actually having to learn and use it.
This was really helpful to read. I started to use breakpoints more often and just step through all the code, with a piece of paper in my hand where I’ve written expected variable values and conditional branches, so I can quickly identify problems. That’s worked pretty well when there is a lot going on. But before that’s possible, you do have to start from top, like you said, and get your bearings.
But his statement is also about job availability. Seeing as you state the nature of contract jobs must be shorter than often the number of jobs specific to frameworks would be inflated. There are obviously lots of reasons why people hire. I don’t doubt that many of their approaches are flawed or short sighted.
I agree to a good extent. That being said, Angular 2+ is younger than React, it was first released in late 2016, embraced reactive programming, typescript and many other "in fashion" concepts much sooner than pretty much every other framework.
That’s true, where would you make the most money at should be considered as well. None of the big companies aren’t looking for talent. I know the company I know the one I’m currently employed at has something like 15,000 developer openings at any given time. I’ve also seen the salaries and benefits much better at these companies. So if we are considering what to know for job reasons then sinking time into vanilla is more profitable.
Yeah, documentation can often seem boring and tedious, but it’s genuinely one of the most useful things you can do for yourself and for others.
&gt; This is true. Angular has something called modules and its kinda fucked up. You need to learn about Angular module, and how you can/can't reuse component. This is the only thing I hate in angular. But once you learn modules, you will be good. How is that something to hate? It literally makes reusing components EASIER than in React. You bundle all of the dependencies in your module, and simply import that module wherever you need it.
I just started a Node project and decided to use TypeScript with it and I'm really loving it. I like that I can reuse a lot of code with abstract classes and generics.
Of course ! But I will not post all my styleguide. I would write this module like this: ```js const myModule = {}; var language = 'en'; var greetings = { 'en': 'Hello', 'fr': 'Bonjour', 'es': 'Hola', 'de': 'Hallo' } myModule.setLanguage = lang =&gt; { language = lang; } myModule.sayHello = () =&gt; { console.log(this.greetings[language]) } myModule.addTwo = num =&gt; { console.log(num + 2) } module.exports = myModule; // In another file myModule.setLanguage('fr') myModule.sayHello() ``` By writing this module like that, variables `language` and `greetings` are not exposed outsite of this module. It's making them private variables. With your suggestion, method `setLanguage` would have been useless because you can do: myModule.language = 'fr'.
it was created by *Rob Wormald (ngrx core team).* I didn't use the word official
Interviewing is okay when you don't need the job. Like if you're in another job already or if you've got an offer from some other company already.
Made a little icecast player in typescript (I know, not javascript! but still) [https://github.com/robotoms/termice](https://github.com/robotoms/termice)
Which makes us come back at square one: depends on where you live and what companies are there. If somebody's priority is money then even being a master of js is absolutely irrelevant compared to stuff like network, open source contribution and academic career. In a realistic scenario and non elité jobs the tech stack matters a lot.
The rules aren't intuitive. All module aren't alike. If they are lazy loading all of their services will have a new instance. If eagerly loaded, they will be merge to root module. Everytime I create a new component, I have to make sure to import it in right module otherwise i will get error. Sometime, module related errors are not descriptive enought (ex: `can't read call of undefined`). If angular modules were good, angular team wont plan phasing them out. I see no real benefit of using ng modules. But they are worth the pain to enable lazy loading. &amp;#x200B;
According to your logic, Google must be primitive because it uses Angular. You singled out a country calling them underdeveloped/primitive because they use angular you twat. 
Angular is a joke at every US tech company that tried it. We killed Angular nearly 3 years ago. 
FYI: https://github.com/sirisian/ecmascript-types
if you think purity of functions is broken by asynchronous/synchronous operations, i think you have a much bigger problem to solve. no linter or tool will help you or your juniors understand code quality principles like that.
If I wanted to build a small website with mostly static content, I would use Gatsby, without a doubt. You don’t really need server-side rendering for account management or to order food from a simple menu, but with modern SEO algorithms, you can absolutely benefit from having your site’s main content load and become interactive very, very quickly, and that is what Gatsby excels at. You basically just have to build out your layout with JSX, tell Gatsby what content to pull in from where as well as where to put it(GraphQL is amazingly well suited for this, if you’ve never used it), run a single command and then a minute or so later you’ve got a complete PWA that’s ready to be served up from just about anywhere. I’ve been using all kinds of static site generators over the past ten years or so, and Gatsby is far and away my favorite tool for this sort of thing. It’s nothing revolutionary, it is just so well thought-out that it manages to be ridiculously simple to use, without sacrificing so much that you feel limited in any way while using it. I use Gatsby for my personal blog as well as for my business’ site, and I can’t imagine anything replacing it any time soon.
so many post mortems on failed projects mention a statement along the lines of: "i focused way too much on little tech things because that's what i enjoyed, to the detriment of the project. i should have been building features instead of re-writing my build tool from grunt to gulp, to webpack." if you absolutely need typescript, do it.but before commit to it, take a hard, honest look at your goals and what you're going for and ask yourself if typescript really helps you reach those.
It's not about making them understand. Understanding comes from from many other venues. This is just a safety net.
That has nothing to do with eagerly or lazy loading modules. The instance your component gets depends on where you provided the service. If you want a different instance for each component, you provide the service in the @Component decorator. If you want the service to be a singleton you can provide it once in your toor module, or even better, let Angular handle the dependency injection for you like this: @Injectable({ providedIn: 'root' }) export class SomeService{} This is so awesome that you no longer even have to provide this service anywhere and you can simply go ahead and inject it whereever you want, and Angular will take care of the dependency injection for you. No to mention that if you don't actually end up using a service declared this way, it won't even be included in the final bundle.
Are you based in Japan by any chance? If so, what's tech scene like in terms of frontend/backend? Last I heard (a few years out of date) it was all RoR and AngularJS.
If you're getting those errors you're doing something wrong with your implementation. 
Why are you talking about a company? I'm talking about an indicator of the quality of software development in an area, in this case a country. You can see my reasoning in other comment. I'm surprised to see Angular being more demanded than React in Italy. It's literally the opposite in many high growing tech area such as SF, India, and Singapore. By the way, obviously google will use Angular, they're the one who creates it. It will be a joke if they use React instead. However, even with that, they still only use it internally or in unpopular products while React is heavily used in production by Facebook and many other companies. What a mature response you make.
&gt; It literally makes reusing components EASIER than in React. I'm not sure how you get easier than "tree-shakably export the things you want to be available".
&gt;Most companies would also hire someone good at vanilla JavaScript over someone who has framework experience. Most companies? No that's not true at all. MOST companies HR department are ruled by people that know close to nothing in web/software development. If the CTO guy tell them they want a angular guy, they'll filter everything but "angular" from the profiles they get. This is what MOST companies do. Only a minority know that a talented vanilla JS developer can get comfortable with Angular/Vue/React in an afternoon.
Absolutely, I guess you mean rewrite as in use existing code and port it to TypeScript? I wouldn't start from scratch. I ported several projects from JS to TS and every time it uncovered some inconsistencies in the code base that then turned out to be real bugs but have gone unnoticed so far, so definitely worth it.
I built a side project recently in TypeScript for the first time recently. My take on it: &amp;#x200B; It's *nice*, but definitely isn't necessary if you're working alone. I can see the benefits when a team is working on a relatively complex project. Typescript makes onboarding new members easier and most likely fewer errors when different people work on each others code. However, if you're the one designing the architecture and it's reasonably sane, you won't see huge benefits. I don't have any particular regrets picking it for the project in question, but I also considered rewriting the other larger one and decided it wasn't worth it.
In my experience hiring managers will rely on tech leads for the final decision, but NOT for the initial screen of applicants. That is where having the right keyword on your resume can sink, or rise, your chances.
Yeah I'll just use that Ruby run-time built in to every browser. Oh wait...
Thanks @benihana @wisepresident and @vexos ! That helped me a lot. I am indeed programming everything on my own. There is actually no problem atm, but I was worried that I might not be able to handle the growing complexity without a type system. Guess I'll stick with JS :) 
Config
Agreed. If you take the time to learn how to use the cli and schematics for modules you use, you have to write very little of the boilerplate yourself.
If someone offers you a Salesforce job, turn it down lol
That’s is true. I would hire someone with strong JS skills over someone that only knows a framework.
i read simple treatment for cancer doctors .... powered by nodejs????
What you are looking for is [page override](https://developer.chrome.com/extensions/override).
Think this is the part you need: in manifest.json "chrome_url_overrides" : { "newtab" : "newtab.html" }, I think you'll also need the tabs permission "permissions": ["tabs", ....] 
Semi-related answer, TypeScript can also cause a false sense of security which may make it more difficult to find a bug (although the same bug could be caused in JS). I was recently working on an Angular project which worked with an API. JSON was returned from an endpoint and the data was stored as a model type in the client. This model had a numerical field, but it was behaving oddly. Using it in comparisons resulted in checks where 2 was greater than 10. This threw me off, the thinking was "the field is a number but it's not getting evaluated right, what the hell is going on?". It turns out that the response JSON was declaring the field as a string, and TS happily loaded the data into an invalid model. The number was declared as a number but it behaved like a string, hence, alphabetically "2" was greater than "10".
The nice thing about TypeScript is that it can be adopted incrementally with very little up-front commitment. Instead of doing a rewrite, just add type annotations in a few places where you really want them or in new code and see if it is useful. You can even add [type annotations via JSDoc comments](http://seg.phault.net/blog/2017/10/typescript-without-transpiling/) and keep the code in JavaScript if you don’t want to transpile.
Hi /u/rmkn, please don't repost projects unless there's been significant updates.
ow yeah .I thought overriding is a feature to override only the current active [page.So](https://page.So) did not read it through.But now i know whats up. Anyway thanks :)
They have one of the highest employee happiness rates for companies. Why turn it down?
Thanks there. :) this is really helpful :)
I bet you haven't heard of rthx or xjui either
We had to start using 4 letter acronyms cuz we ran out of 3 letter ones
I think you misspelled the company name personio as personia on GitHub.
Well, you have to understand that most frameworks would prefer that people see them as libraries, because that looks better for them. Most developers have some bias toward libraries because it implies they have more control over their code. So everyone wants to be seen as a “library.” But React definitely expects you to bend over backward to work with it. Don’t get me wrong, once you refactor your entire project to fit the expected design patterns, it’s a breeze to work with it, and quite useful. But you can’t just sprinkle some React into your code. It’s pretty much all or nothing for whatever DOM tree you’re trying to render. And that’s not a bad thing.
This is really, really, a big deal. I know react native is capable but Ionic was just so fast to build a POC from that our clients always required it due to time. I also like how it pushes TypeScript. Strict typing gets pretty sweet once your sharing JSON models with other teams. 
&gt;But cross framework support is quite rare requirement. Funny you mention that. A good friend of mine recently told me about a project where he had to fit several React render trees inside of an Angular app, which itself was placed inside of another React app. Probably would be nice to just have a web component library for that, lol.
Accenture has massive teams at google and amazon. Facebook too
I do technical interviews at Uber. We have both vanilla questions and framework-specific ones, but mostly do vanilla because not every candidate knows React and we want to evaluate them fairly on other skills. Also, not many positions require in-depth knowledge of React (e.g. we have a team dedicated to our component library) Another thing to keep in mind is that big tech companies tend to avoid hiring junior level people, because they don't yet have the experience to be able to pick up a new thing easily. Unlike most parts of the world, the Bay Area has an exceptionally high supply of highly qualified people. And for senior level people, looking for signals about fundamentals is important. On the other hand, if you're in, say, Saskatchewan, you probably should learn to talk about Angular 1 and jQuery for your interviews, because that's where the high end professional skill level is at (source: my wife consults for a bigcorp there).
I agree with this 100%, but I do think the web components implementation will actually expose a lot more low-level control to developers, which is good for the standard. But sure, diffing the DOM or binding data to elements is still totally within the scope of libraries, as it should be.
If you're doing any compile step you already have dependency management in node with import. That's the most annoying part about modules to me. But angular hasn't been my cup of tea for a while.
Wow this JSDoc approach is new to me! That would be a nice alternative. Thanks! 
We had to do both React and Angular 7 stuff this semester in our front-end web course (And some knockout stuff). They were both cool frameworks but in the end I felt Angular to be more inline with my way of structuring projects (personal pref). The HackerRank survey seems to only take into account for AngularJS and mention some TypeScript popularity stuff (but TS can be used outside of ng). Does this survey suggest that its time to move over to React for now? I know I can pickup any framework but as a new developer I feel it is best if I am at least competent in one.
I’m in Midwest US. Angular is very popular on the front end to be sure, but Rails has kind of fallen out favor for Web API and Node.
Am I totally going crazy, or did your name change from FoxCity to duxdude418?
So long as you don't end up disliking Typescript (and you can bail out at any time by compiling to ESNext,) it sounds like the perfect time. Your app is getting bigger and you want to do some architecture and refactoring before it gets out of control. Clear object types and function signatures are exactly what you want here IMO. Just go easy on the classes and inheritance. There's a bit of a (sub)culture within Typescript of developers who treat it like C# or Java OOP. IMO it's better to treat it as JS with types than as a different language. I'm mostly a solo dev and I still love TS for short scripts. There are nice tools like `ts-node` that let you run TS scripts directly with node. For a node app you might find the build step inconvenient if you were using uncompiled JS previously. Keep in mind you can get pretty far with type hinting using plain JS and VSCode's `//@ts-check` with TSDoc type annotations, and maybe some external `.d.ts` files for more complicated types.
I'm fairly beginner in Angular (My wip thesis is an angular app) can you elaborate on component reusability?
I don’t find books as good resources for learning about programming. Why not buy a udemy or similar course or read one of the many articles online. 
I was just about to mention --incremental but then I've read the rest of your comment :D
I like it more to read a book than something online. 
Have you tried Akita? I've heard it needs way less boilerplate then others.
great, thanks
You still using legacy rthx? We already moved onto rthx2. There are a lot of breaking changes.
I got sweatson, but he's bugged - no gold unless I have the robot mining gold too (and then I get 3/sec instead of 2)
For smaller companies that may be true. For many larger ones though, the hiring process usually starts off being all HR process. If the recruiter determines you check off enough points then they'll pass you onto the hiring manager who might then know what they're talking about. 
Duh? Error messages should be informative though.
How can typescript be adopted incrementally?
Let's just use ruby shitty VM, shitty performance and shitty community that thinks that they're the only cool kids in world.
You can use Ionic 4 with vanilla JavaScript if you want. 
Lots of ways. By adding JSDoc comments. By converting one file at a time. By just renaming all your files to TS, and then slowly turning on all the rules one by one.
There are not so many changes to a programming language in a year that makes it completely unapproachable ...you can buy a 2018 book and see that not much changes in a year ....and if it does you can look it up on the internet. Cheers :)
I'd say Uber absolutely qualifies for top level companies tho.
Haha I actually just discoverd phaser the other night, pretty nifty tool. Think I might try Babylon next.
Thank you :)
Hmmm functional for android and PI, looks promising. Thanks for the suggestion!!
Thanks. In my inexperience, I had a lot of difficulty setting up the transpiling and such. I simply took a tsconfig with some rules set already, and it was very difficult for me to type all of the files I've converted to ts. So I could have done it much easier by converting files into ts one at a time? Transpile the ts files into js, and everything that I kept as js should just be "copied"... Is that how I should have configured it? Maybe I should have just used ts node for my node project.
Yup. You may never get to talk to me because you lacked some buzzword. Regardless of your skill or experience. I'm hoping to work with a few managers in the future to try and denoise the candidates I get, as well as hopefully miss less good ones due to lack of good 'or' style sorting. 
No problem 
Just remember that no book contains ALL you need to know about JS. I've read books that were almost 10 years old. The fundamentals in JS don't change. Each year JS get some new features. But again, it can take a lifetime to learn all there is to JS. You have the wrong mindset. I've started reading Javascript for professional web developers 3th edition, soon the 4th edition will release. The 3th edition is still very relevant. Each edition just cover new features which you can also find online for free. Its a great book to own for anyone who want to thoroughly study the subject. My advice is, if the newest edition is about to release, just wait for it. But Im guessing your refering to books from another author. I'd say buy it. 
Great way to make yourself unemployable.
Rthx2 is crwp compliant
Here are some great 'free' books [http://jsbooks.revolunet.com/](http://jsbooks.revolunet.com/)
Italy is very conservative technology wise (and not only...), they barely use Macs and wasn't Silverlight still mainstream until only a few years ago?
With crwpifyer you can make anything crwp compliant. It's released yesterday, don't you know? People these days...
You sound like someone who hasn't been on a job hunt for years... that is an idealistic view that doesn't correspond to reality. 
I just want to learn the Basics of JavaScript and have a book next to me so I can look it up anytime I want and have a short recap of that this code does or why I should use it. I know that you can look it up on the internet anytime but it's something else when you have it next to you. It's a book in German called: Javascript Das umfassende Handbuch by Philip Ackermann So I don't know if he will release another edition this year.
Yeah true, I'm mostly elaborating on your point 
Sweet I do have a little Java background! Two reccomendations, lets check out p5! Thanks guys :)
Pretty simple concept I borrowed from Jason Miller (@\_developit on Twitter) and expanded on displaying how to implement [HTML and CSS modules](https://codesandbox.io/s/yknzpww21) (using a constructible stylesheets/\`adoptedStyleSheets\` polyfill) and custom elements. Essentially you create a service worker to modify import types.
Ooh this sounds interesting! I am working heavily in react lately, and many of the things I want to do may need a react version too :) Thanks!
Thank you :)
Ah, that sounds like a bug yeah. I'll take a look at it, and see if I can fix it. Thanks for providing the info :)
TOP answer :) Thank you for that. I think I want to get used to working with three dimensional maps and sprites, but, that is very good advice you're right, I'd imagine for a game like brick-breaker, you don't need much more than vanilla. Very well said about the convenience factor as well, I have avoided game engines for a while because of this issue, but, I just really want to start branching out so who knows. I think I will explore a bit in both directions. Furthering my vanilla canvas skills, as well as perhaps learning how to use a game engine or two. Thanks for your response man!
IMO it's beneficial even if you work on a project alone. Refactoring is made much easier. Reading and reasoning about your own code is also easier. Both crucial for the velocity of development
That's ... uninspiring to say the least. However it's hard for me to relate. That being said, I don't go to many interviews as applicant. And if I do it's to reassess my market value when I'm asking a raise in my company each year. In our company, we don't even care what language programmer is programming in as long as it's one of the business oriented ones like Java, C#, php, python, scala etc.. HR consults the CTO before they make any posters. HR are the ones who will send the test exercise, introduce to the company. When applicant sends back the exercise, normally tech lead checks it and when said to HR to set up a meeting. Where both HR and the tech lead in question will participate. In our particular case -&gt; day of work with the team follows and entire team unanimously needs to say YAY before the person is hired. The team part might not be as common, but the first part is what it's most common in where I work. And as I talk with programmers in other companies, they seem to have a very similar flow. &amp;#x200B; Perhaps you were referring to head hunters? As if, HR guys and gals who are not employed by the company they are looking for applicants?
(not OP) I went ahead and spend some time doing just that! [here is the code](https://github.com/ldd/better-package-json) I just published it. I guess it'll be live in [the store](https://marketplace.visualstudio.com/items?itemName=ldd-vs-code.better-package-json) soon enough
I don't really understand what's that supposed to mean. &amp;#x200B; Me and the overwhelming amount of my colleagues and most people I know use osx, and I don't see how's that more progressive than using Ubuntu or Windows or something else. &amp;#x200B; There's an overabundance of companies using "new" technologies, from serverless to elixir to elm or whatever. &amp;#x200B; Moreover, if anything, your point validates my previous point: what to study, as a beginner/junior obviously depends on the companies in your area and the requirements they have. &amp;#x200B; I remember mentoring a guy from US on JavaScript one year ago, and in the end we found out that if he started with Java he would've found a job much more easily because Java jobs in his area where much more than JS jobs (especially for juniors/internships).
So, a couple of days ago someone posted about [NPM-GUI](https://www.npmjs.com/package/npm-gui) I thought that a VSCode extension would be sweet, so I built one from scratch. [Here is the code](https://github.com/ldd/better-package-json) I just published it. I guess it'll be live in [the store](https://marketplace.visualstudio.com/items?itemName=ldd-vs-code.better-package-json) soon enough.
I think I was mining gold while I got the new friend - that might have something to do with it - now I got the horse and I get 5 gold/sec while the robot is mining (ui says 3), but only 1 when only the horse and dog are at it. (ui says 2)
I’m actually someone who has risen up within a company and been offered positions multiple times in the last few years at various companies. Maybe you should heed my words instead of prejudging? 
You should write good, well-organized code, then let the obfuscation tool do its job.
Cool. Check https://www.youtube.com/user/shiffman, this guy has some very nice tutorials about it.
&gt; Just go easy on the classes and inheritance. There's a bit of a (sub)culture within Typescript of developers who treat it like C# or Java OOP. IMO it's better to treat it as JS with types than as a different language. Im glad (or disappointed really) that I’m not the only one who’s experienced that. Yes, TypeScript adds some features to classes, but allowing OOP is tangential to the real value of TypeScript. I’m currently maintaining a project where the original author, in his own words, “wanted to prove that a dedicated developer could reproduce TypeScript in plain JavaScript.” The resulting codebase is a mess of class hierarchies for the sake of them, dependency injected classes with only a single static method, and ten layers of ApiResponseHandlerFactory boilerplate where a simple function would suffice. The whole thing completely missed the point. 
If the frame is loaded from a different domain than the parent, you cannot do this. If it is loaded from your own domain, just add the stylesheet to the html. If the intention is to load css on the fly to a loaded iframe on your domain, have some script on the iframe that registers to the opener iframe so the opener/parent has context to the iframe. Then you can call a function in the iframe that attaches the stylesheet as you need.
If there's inline documentation then I use that otherwise I have to rely on console.log output and DevTools integration. If you want to lay stuff out visually I can recommend [yEd](https://www.yworks.com/products/yed) \-- it's pretty easy to use and produces nice graphics.
Jordan Harband from TC39, working on specs for the new private fields, told me that everyone thinks about internal slots while coding in JavaScript, and that that's the reason why the new private fields should be modeled after internal slots. &amp;#x200B; I disagree with that, and believe they should be modeled for whatever makes the most sense for the experience that most people will have, and so I was looking to prove that most people don't think about internal slots while coding in JavaScript. That conversation is here: [https://github.com/tc39/proposal-class-fields/issues/230#issuecomment-476027383](https://github.com/tc39/proposal-class-fields/issues/230#issuecomment-476027383) &amp;#x200B; The link to the slides there, proposes to follow internal slot semantics for private fields, and I replied asking why they should follow internal slot semantics, and then Jordan eventually replied "because we all think about them while coding JavaScript", etc.
A professional software engineer follows the specifications of the language being used because he knows that other people will have to use and maintain the code. People who insist on using their own hacks are unprofessional children who never learned how to work well with others.
I'm OK with things being in someone's own style provided it is readable. You're more than welcome to use your own commenting or spacing conventions, primarily because I can easily format these things to \_my\_ standards with an IDE setting. However, having to go through 100+ files without semicolons is potentially the most frustrating thing I've dealt with in awhile. For what reason? To save you one key stroke? A semicolon very clearly marks an end of an expression, which is especially helpful when you are dealing with a lot of anonymous functions and callbacks. Finding the delineation of expressions should not be this hard. While I'm at it, ALL if statements should be wrapped in brackets. Conventions matter, people.
I program in several languages and the one's I deal with the most need semicolons endings. So for me, they are like a punctuation mark in a sentence and just feels natural. For 'because you do it', I feel the same way about short tags in PHP.
Thank you, fixed!
Once I was with you. No longer, they are useless garbage as you should not have multiple statements in same line anyways - and that’s the only reason to have em.
You never had a conversation with a recruiter? "This company are looking for a developer with experience in Angular." Well I've been building with React for 3 years at my current job, I have a pretty varied portfolio of open source JavaScript projects, including plenty in vanilla. I'm also really excited about Vue... "That's great but this company are looking for an Angular developer." OK fine I'm an Angular developer. "That's great! Could you just update your CV to highlight your Angular experience, and I'll pass it on..."
Fantastic I’ll check it out. Thanks 
It’s been a whole two hours, so we’re now up to five letters!
Some newer tech things are better, but your actual point of "just because it's new doesn't mean it's better" stands as both reasonable and advice most people should heed. That said, I'm very happy after making the leap to k8s, terraform, consul and vault for managing backend stuff. There's still some issues with it all but it's leaps and bounds better than what my company was doing before. But we also did a bunch of research on if and how they addressed issues rather than just blindly adopting them.
In the spirit of Uncle Bob's Clean Code and having code read as comments, I have a shortlist of standard prefixes I pick from as needed: isXXX hasXXX shouldXXX mustXXX canXXX and (less frequently) their negative equivalents isNotXXX hasNoXXX etc.
Haha you need to inclide a link to the Jquery CDN &amp;#x200B; You will need to include the following in your html, \`\`\` &lt;script src="jquery-3.3.1.min.js"&gt;&lt;/script&gt; \`\`\` &amp;#x200B; As well as visit the following link, [http://jquery.com/download/](http://jquery.com/download/) and download your required version of jquery.
Risen within a company doesn't sound like going to a lot of interviews... Your words don't match my experience or that of many of my peers, that's why I don't agree with you
Wish the error message was more helpful in figuring that out but thanks for your suggestion. 
&gt; building relatively small and medium size with angular seems really unreasonable, Building relatively small or medium size sites with any major JS framework is unreasonable. We need to rediscover the lost art of progressive enhancement. The major JS frameworks should only be used when they add more value than the costs they impose. Lately people are underrating the costs and overusing the frameworks. The vast majority of us are not coding Google Maps. We don't need an uberframework.
I am sorry but as someone who knows Italy quite well I remain convinced that it's pretty backwards when it comes to technology. You can tell by the lack of conferences or cutting edge companies from over there. And yes, in technology newer is more likely to be better, that's why we use React and not Backbone, Windows 10 and not Windows 95, etc. Anyway, it was just a passing OT comment
This past week I spent some time developing a URL-shortener / bundler that's used to share connectivity information: [https://github.com/monicanagent/sdb](https://github.com/monicanagent/sdb) &amp;#x200B; I use this primarily for use with [CypherPoker.JS](https://github.com/monicanagent/cypherpoker.js) where peer connections are often denoted by IP addresses and ports and where multiple options are usually needed (independent API *and* P2P connectivity, for example). The SDB is a [binary data format](https://github.com/monicanagent/sdb/blob/master/TECHNICAL.md) that's fairly [easy to encrypt](https://github.com/monicanagent/sdb/blob/master/example/cryptoSDB.js) and, at the very least, obfuscates connectivity information from the casual user. It makes use of a somewhat less common encoding called [Ascii85/Base85](https://en.wikipedia.org/wiki/Ascii85) that produces smaller output than something like Base64. &amp;#x200B; It's not ideal for use with named URLs ([`http://www.something.com/`](http://www.something.com/)`...`), but it may still offer a slight data size reduction.
So true buddy! It took me a little while myself to figure this one out. Thank god for places like this :D
With typescript you can remove an entire category of bugs. Compile with strictNullChecks and you are very unlikely to get null or undefined reference errors.
The image is tiled...how do I change that to stretch 100% width and height?
&gt;pens Let me know when I can download more ink
Just watched this -- very interesting. Thanks for sharing.
Don't use jQuery, learn JavaScript..
Well I'm new to programming in general so whatever works to get a job done is most important. 
https://github.com/Realytics/fork-ts-checker-webpack-plugin you can do the type checking in a separate process which speeds this up. The transpile alone is pretty quick
Just use prettier and avoid clever code. There's no reason in this day and age to be wasting time on inconsequential stuff a machine can fix for you.
This is a challenge because you get a lot of angularjs answers. I typically search for angular 5 which reduces the number of super outdated responses. 
There are plenty of legitimate reasons to have multiple statements on one line, but far more importantly, its common to have a single statements spread across multiple lines, and therefor, is good to have a semicolon delineate the statements. I'm not even sure where you heard that, or your reasons for "not being with me", but I implore you to reconsider whatever life choices lead you to abandon a key feature of nearly every programming language on the planet for no other reason than you think its useless garbage, despite the fact it absolutely isn't. &amp;#x200B; There are a multitude of bugs which this introduces. Its bad practice.
what is angular ?
It took me around 2 complete days of work to build the project. I did it in the span of 5 days along aside my regular job. I put a lot of effort into the project as I was really very much looking forward to join the company. &amp;#x200B; When I was interviewed for my current active job, they didn't asked for any coding test, or any other stupid complex interview questions. It was enough for them to check my existing works and open source projects. They interviewed me to know me as a person. Like as @jeremy1015 mentioned. As far as I can say, when interviewers are really in need of an engineer, they don't ask stupid questions. When they have enough support already to continue their project, just looking for another dev to speed up things, they starts to make things complex and stupid. &amp;#x200B; BTW, I got a job in Germany and relocated here anyway. I'm glad that I was rejected from that company.
```js document.addEventListener('DOMContentLoaded', () =&gt; setBackground()); const setBackground = () =&gt; { const images = [ 'https://images.unsplash.com/photo-1553532070-e2c5714303e6?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=800&amp;q=80', 'https://images.unsplash.com/photo-1554342872-034a06541bad?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80', 'https://images.unsplash.com/photo-1554372938-d30c2d851d5d?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=634&amp;q=80', ]; const body = document.querySelector('body'); const image = images[Math.random() * images.length | 0]; body.style.backgroundImage = `url(${ image })`; }; ```
https://codepen.io/anon/pen/vMKMby
Just merged a pull request that fixed the typo. A nice guy made a pull request for that. :-)
Very industry specific but I created an app that lets you view the results of water network simulations on a map. It's a niche area, mostly look after by big corporate software, hardly anyone does open source software in civil engineering. There is a demo model you can load to test out the app, should have tried a little hard to make it more mobile friendly... https://modelview.matrado.ca/ The source code is on GitHub below; it uses React and Typescript (both firsts for me) and MapBox GL https://github.com/modelcreate/model-view/
I got another job and I have relocated to Germany anyway. I'm glad that I didn't get that job. I'm quite sure it would have been a horrible experience.
buy as many books as you can. A book is worth the investment if you learn 1 or 2 new concepts. You're investing in your knowledge. Like I stated previously, books from a few years ago are still relevant. Especially concerning JS. The new features in JS mostly introduces new functions or objects that lessens the amount of code neccesary to perform a certain task. The old ways of coding will remain part of the foundation. See it as building blocks. Older techniques are level 1, newer features are level 2 etc. You cant skip level 1. 
Thanks man. But I got one already. :-)
fixed. A nice guy made a pull request to fix that.
\&gt; You can tell by the lack of conferences Just in these 30 days in Rome I attended Codemotion, Oracle's Code 2 days ago, a (free) Elixir workshop organized by BEAM Italia and I have Azure Days in few days. There are regular monthly meetups and communities, in fact I'd say that in Italy we have much more of them than many other places. In Italy alone we have 6 cities organizing meetups for JavaScript, Milan has even a TypeScript meetup. There's more of these things here than in the United Kingdom. &amp;#x200B; \&gt; Just compare the quality of the website of any of your major newspapers with that of a European equivalent. Care to show an example? Because I just run Lighthouse on [repubblica.it](https://repubblica.it) and it got: 71 performance, 62 accessibility, 100 seo and 71 on best practices. Meanwhile [nytimes.com](https://nytimes.com) has 31 for performance (atrocious), 64 accessibility, 0 seo, and 79 for best practices. &amp;#x200B; \&gt; or cutting edge companies from over there &amp;#x200B; This is mostly on beaurocracy and taxation, moreover, I'd even say your statement is arguable but don't want to fall for this discussion. &amp;#x200B; In the end you're chunking just clichés. I know that Italy isn't the biggest behemot in technological advancement, for many reasons, but you're describing a picture that honestly applies to 95% of companies and areas out there. 
I will add the demo button. Thanks for the idea. Not sure if I would do the mobile friendly, as it would take some time.
Exactly right. You could, if poetry is any indication, write English without any formal punctuation or spacing conventions. That doesn't mean we can do without the punctuation. The push towards leaving out the semicolon is like English without the punctuation, because that is somehow more "clean." I don't get it. It is clearly a trend, and I think more people should put their foot down to stop it.
After angular 1, I decided not to rely on Google. React is most jobs nowadays. I just throw the angular job requests in the trash.
You know you can take interviews and rise in a company at the same time. It’s actually the best way of doing it. Apply for jobs when you have a job and you have some actual bargaining power. I don’t really care about internet points. You seem to have messed up priorities.
Hmm, that largely depends on your structure. but you can try a view things. If the image is the background to the BODY element, then you want the body to fit the width and height of the screen. So you would so something like getElementById("myBody").width = 100% or getElementById("myBody").width = 100vw &amp;#x200B; or getElementById("myBody").width = window.innerWidth;
Imo, angular is more oriented towards enterprise shake application development. We use it in all our applications. On the flip side I never really understand people struggling with the concepts of angular; everything it does, it does right. The agnosticism that other Frameworks pride themselves in never made sense to me; I see it as a weakness. To get in the same ballpark as angular you still end up bolting everything on but instead of a uniform thing everybody has their own shit. If you want an application angular offers the bare minimum.
Just use this vanilla JS script to package your stuff up and you'll be _minimal_. Wait, does using that vanilla script count as using a dependency since you didn't write it yourself?
No way and what’s the likelihood that job is good paying or better paying that other jobs in the area? You don’t need to fit every job out there and the key is to fit the better paying jobs in the market you live in. 
I'm referring to HR employees. I work at a very large company (50k+) so YMMV
I think you're the MVP answer in this thread. A lot of answers feel like I'll informed sour grapes. We build massive, critical applications in angular and yet they are fast, safe and the load chunks are tiny. 
For Electron it may not make much difference. For a browser-based app, a good bundling split can improve performance by optimizing caching. 
https://stackoverflow.com/questions/1458633/how-to-deal-with-floating-point-number-precision-in-javascript
/r/iamverysmart
You need assistance with your reading 
does not seem to be working...getting error (google chrome): Uncaught ReferenceError: getElementById is not defined at init (V3AcustomBGrandomizer.js:9) &amp;#x200B;
But why? How it work? Why such a big mistake exist?
Haha you should be using three backticks for multi-line code blocks. You should only use single backticks for inline code. Also using `window.onload` is not recommended, as it can only be set once. So if you use a third party library or script that also defines a `window.onload` handler, one of them will be overwritten. It's *much* better to use the `DOMContentLoaded` event on the global document object, like so: ``` document.addEventListener("DOMContentLoaded", function() { var images=['Tile1_C1_R1.jpg', 'Tile43_C2_R1.jpg', 'Tile85_C3_R1.jpg'], randomNumber = Math.floor(Math.random() * images.length), bgImg = 'url(' + images[randomNumber] + ')'; document.querySelector('body') .style.background = bgImg; }); ```
Fam that’s not the point of the sub. The other guy was the first to bring up credentials / experience, I didn’t bring anything up out of the blue.
Not surprised by the silence lmao. 
Thanks for the suggestion... Now I'm wondering if there's a way to run a slide show after the initial background load? Like every few seconds or so have a new random image chosen. 
I just want to add that NGRX that you mentioned couple of times are not always needed and this is something you need to remember. (just in a very big app cases, imo). Rxjs on the other hand is a must. 
Yup, sure is. ``` function setRandomBackground() { var images=['Tile1_C1_R1.jpg', 'Tile43_C2_R1.jpg', 'Tile85_C3_R1.jpg'], randomNumber = Math.floor(Math.random() * images.length), bgImg = 'url(' + images[randomNumber] + ')'; document.querySelector('body').style.background = bgImg; } document.addEventListener("DOMContentLoaded", function() { setTimeout(setRandomBackground, 3000); }); ``` Will change to a different random background image every three seconds. 
This is way too much fun
"worth" is a subjective concept. 
Try looking into Github repos
https://floating-point-gui.de/basic/
The page does not seem to change images. Also the image is tiled again.
I don't think it matters, but I for one do use semicolons. JavaScript isn't opinionated, just like you can't knock someone for solving a problem functionally versus object-oriented. &amp;#x200B; Personal preference wins at the end of the day, and I can see the argument that it looks cleaner as being valid. I use semicolons because I think it looks as descriptive as possible. To each their own
If you write normal code you can omit them. I do and I never experienced an error that was caused by the automatic semicolon insertion. It's incredible how many people argue with that they don't trust the machine. The argument that it's "clever" code is so wrong because it's a freaking semicolon loly it's always on the end and omitting them is not clever code wtf
Released a major for my threejs React reconciler react-three-fiber this week: https://twitter.com/0xca0a/status/1113218466050387971
Last year's code will definitely apply. Newer JavaScript features just build on top of the existing JavaScript features and don't fundamentally change the way that you overall program JavaScript. I think most of today's fundamental JavaScript programming practices are built out of concepts at latest introduced in about 2016 (namely ES6 syntax, promises, and async/await). Anything 2016 or later that is comprehensive should have everything you need to know. Really the core "need to know" parts of JavaScript, like events, Dom manipulation, variables, and general syntax should be plenty up to date in any book back to 2005 or so.
Working remotely is awesome! I love the flexible schedule and the commute cannot be beat :) 'Course... I also have social outlets besides work, namely martial arts and kids activities (plays, sports) so social interaction-wise I'm super ok. Without that it could be less than optimal I guess, but I'd have a really hard time going back to a regular office gig after nearly 3 years 100% remote.
Try ant, it’s really good.
You are correct! Mixed up my `setTimeout`'s with my `setIntervals`'s! Check the edits I made, they should fix those issues.
Worked on a blog for my bike trip - written in js and us in d3 for a map :) https://howfarsouth.com
React is a view layer, not a framework. A view layer and a proper component model always make sense, small, big, it doesn’t matter. Similar to how you would always prefer modules over IIFEs and concatenation. Layout inflating is dead, it has never been an art, not for small things, not for anything, just a really terrible way to handle UI.
I write normal code. I can give you a completely normal statement which will not execute without the semicolon. I am in bed at the moment or I'd write it out for you. if you're interested I can post in the morning here. Declare a variable. On the next line, make an inline array, and call the forEach function on it, and print the results of the array to the console. Shit breaks. Totally fine with semicolons. Even beyond the semantics of properly punctuating logical statements, leaving out semicolons introduces non-deterministic execution of statements in an already janky language. It's bad practice. Use semicolons.
You say you write normal code and you declare a variable but put the value of that variable on the next line? You kidding xD
I don't foresee there being much a difference between 7 and 8. I believe angular 8 is supposed to come out some time this month.
Also, the image is tiled. How do I make it stretch to fill the entire web page without tiling? 
Thanks
That's not a mistake. 2.8 can't be perfectly represented as the sum of powers of two (which binary works with exclusively) so the number you see there is as close as your data register will allow. If you want better accuracy seek out a BigInteger / BigDecimal tool and you can obtain arbitrary precision similar to the classic pencil on paper method you may be used to.
You make some silly assumptions. The benefit of a framework is based on the rules it sets. unless you are forced to use a framework those rules are chosen and hence under control. i also fail to see how false claims would benefit a framework at all. using plain react just for rendering ui is perfectly possible. use whatever statemanagement, router etc you see fit. 
Don't die on this hill. I use semi-colons and we enforce it via linter at work but I don't care that much. Yes it's possible to concoct a bug scenario but those examples are not common code constructs IME. 
No one formats code by hand any longer. The few people that still go through the hassle worry about semicolons, to everyone else it’s just a prettier config preference. 
&gt; `document.body.style.backgroundSize = "cover";` This line will accomplish that, you may possibly have missed it in the edit.
I don't get why any enterprise would choose to use the new Angular, the api changes drastically between versions and it's really not a very conservative bet IMO. But jokes aside the real reason is that the Angular marketing team uses the right buzzwords and nows how to appeal to their sensibilities. In practice however React is a much safer approach since unlike Angular which was built as an external product with consulting services designed around it, React is actually used in FB's core product which means: 1. It maintains backwards compatibility and does not suddenly break old APIs. 2. It's battle tested and designed actual real world apps rather than gimmicks. 3. It doesn't risk being randomly abandoned one day like almost every other Google library that has come before it. Also given that Angular was designed to have a whole consulting services built around it means the following: 1. The API is intentionally obtuse to encourage the need for hired help 2. The API will randomly change a lot because there is no core services at risk and doing so only increases the consulting business. 3. If the adoption rate is not great enough for consulting to continue the project will be abandoned. You see Angular isn't even used by Google for any of it's external services, when they say "we use it" what they mean is "we built an internal app that shows which bathrooms in the office are currently occupied". The new Angular is less of framework and more a service. 
Don't worry, I won't die on any hill. However, I do enforce this for my employees via the linter as well. The fact I CAN concat a bug scenario, in addition to the reduced readability of the code, in my opinion, proves this trend is wrong. The readability is certainly the most important factor, but an introduction of bugs into the code base or having to have special cases where sometimes we need to use a semicolon, and sometimes it's ok to skip is silly, inconsistent, and bad code. I feel it is unprofessional. It's for people who take the "break often" approach way too far.
Hi /u/python_roma, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/hagstrom66, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Ok. I'm new on Reddit. Still learning. Thanks.
Why? 
8o0is8bsv
ccscccccgibis
There's many more bugs a misplaced semicolon can introduce, especially in Javascript, where there are some really janky rules for when ASI does it's stupid thing. If you typed: return true; You'd end up returning an undefined. The language would really need a pragma for disabling ASI altogether in order for your semi-colon enforced world to have real world benefit beyond your own sensibility.
use them. like that period
Maybe it's possible to use WebAssembly to compile the Ruby to asm, then run that in the browser. Would be a pain to debug though.
My pleasure, a portfolio is a great asset in interviews :) Take your time !
That's why linting exists. So people like you and me could enforce rules instead of just yelling "conventions matter" into the wind
I often had cases where a line of code starts with a square bracket (creating inline array and immediately calling forEach on it for example). If the previous line ends with ) it messes up ASI. I never want to think about it and if there are cases where a semicolon is mandatory, it's easier to just put it everywhere 
This looks good! Would it be possible to just have a function one can use that has an api something like this: `throw createError(code, message, details);` &amp;#x200B; That way I wouldn't have to implement a new Error class for every error I throw. Are there any reasons not to use a function? Or would I be missing some best practices?
Here's one [https://dmitriid.com/blog/2017/03/the-broken-promise-of-web-components/](https://dmitriid.com/blog/2017/03/the-broken-promise-of-web-components/) 
That is if you only knew Angular and not javascript since other than JSX and some patterns React is just modern javascript. I hated learning angular's DSL, it makes me mad when I have to spend time that could be used learning a whole new Programming language, just for a single purpose that's useless in a couple of years. I am still angry at all of the annoying DSL I had to learn when I worked for a Rails shop. Creating a DSL for something that isn't hiding a lot of complexity is the ultimate form of self important fart smelling there is. Angular came about during the Rails epidemic, a time in which every fucking library had a pointlessly stupid DSL in which they rewrote the entire base API of whatever language it was built on top of . . . . . . and for NO REASON other then the developer liked the smell of their farts and assumed we would too. Now just to be clear there are times DSLs are a good thing and that's only when it abstracts a lot of complexity like D3. But the difference between D3 which only abstracts a complex thing like SVG manipulation, Angular decides to change how arrays are iterated or conditional logic is expressed. 
Well both libraries are &gt;not created by angular team So I don't understand what your reasoning is for suggesting 1 over the other.
I do both. Sometimes I inherit something I had no control over and to fall in line with broader standards I have to spend a weekend fixing it across hundreds of files. I will yell into the wind in hopes someone out there will hear it and agree, saving me and others like me unneeded effort.
Angular bad, Typescript good. At my company we use Typescript with React which ironically actually works better with React than Angular since the last time I checked Typescript didn't work for the template side of Angular. But the reason why Typing exists is because it severs as a form of documentation and explains what to expect when it comes to a functions arguments and what it will return. There is nothing more time consuming then having to figure out what the parameter `data` contains and how I am supposed to interact with it especially when debugging and trying to figure out why some random function written by someone else threw an error. 
Function is worse, then constructor because it add one more record to stack trace. Constructor is preferable. &amp;#x200B; Using message as string with code and details is senseless. Error3 use equation \`message = format(code, details, errors)\` the code is always known and is constant so it could be omitted. And we receive \`message=format(details, error)\`. Thus we do not should use code, message and details together. &amp;#x200B; Using codes as argument also not good, because there could be a typo which IDE or runtime will skip. This is why each error should be realized as a class. 
Yesss exactly, I don't even care what conventions I use now. Semicolons, bracket spacing, double or single quotes, etc. When I format on save, it will adjust my code to the preferred .prettierrc setup of the project, and the difference in style doesn't bother me at all because the formatting becomes Prettier's responsibility. Caring about style is so pre-2017, Prettier completely killed any of the bikeshedding I felt around style preferences, except in very minor cases related to line spacing, etc. It's incredibly freeing actually. 
I think you misunderstood. I will post for you when I get up an example, which is fairly common, which will break without a semicolon. It caused a major bug in bootstrap, where a developer went way out of their way to avoid using the semicolon, and started a pretty major argument in the PR. For your enjoyment: https://github.com/twbs/bootstrap/issues/3057 Also, thanks for all the down votes. Appreciate it. If the current js community is disagreeing with me, I know I must be right
And of course, you can still write some very nice React with TSX.
Hah, downloadmoreink.com doesn't work for you? Nah am referring to the smart pens like Livescribe
Looks like you have your method inside of the constructor. Try moving it into the outer class. ``` class Rectangle { constructor(length, width) { this.length = length; this.width = width; } isSquare() { return this.width === this.length; } } ```
I honestly would challenge someone to build virtually any app in less code with angular, than React. Angular is half a decade of boiler plate city.
Lerna Or Submodules Or NPM/yarn install from a github repo if you need it to be private Research sharing code in poly repos
Prefix with four spaces to get code -- class Rectangle { constructor(length, width) { this.length = length; this.width = width; isSquare(){ if(this.width===this.length){ return true } } } } It's incredibly difficult to read it to diagnose the problem. 
What about Vue?
&gt; It also creates 3 arrays and a inline function every call. Yes, you can skip the creation of unnecessary arrays by using Array.from with a map function: function range(from, to) { return Array.from({length: to - from + 1}, (_, i) =&gt; i + from); } console.log(range(3, 6)); This would look a bit nicer if JS' arrays had a generate function à la Dart. Then it would be just: Array.generate(to - from + 1, i =&gt; i + from)
I am surprised by the use of bitwise OR with zero. JavaScript never ceases to amuse
I don't think utility functions need to be terse. One liners are for debugging, scaffolding, doing things quickly. If we really care about getting it all in one line, why not use a generator? function * range (from, to) { for (let i = from; i &lt;= to; i++) yield i } More readable, in my opinion. Less readable, but we can also handle descending ranges in one line: function * range (from, to) { for (let i = from, up = to &gt; from; up ? i &lt;= to : i &gt;= to; i += up ? 1 : -1) yield i } &amp;#x200B;
Neat. I used riot for a project about 3 years ago. I really enjoyed it over the prior project when I used knockout. And it was way easier to get started with and to learn than angular. But my last 3 projects have been in React and there would have to be some really persuasive arguments to look elsewhere again.
Hmm. I've honestly never run into an ussue using onload, but interesting, thank you for that tidbit I will try to keep it in mind for the future.
I would argue that “control over you code” is similar to control over anything: If you make a choice for your code at point in time *A*, and that choice prevents you from easily doing what you want with your code at a *later* point in time *B*... then going from A to B you have lost some amount of control. Basically, if I want to use jQuery for DOM Node selection, for example, and the later I want to use vanilla JS, or lodash, some helper function, or whatever, I can pretty much expect all of those methods to easily work well together, because I haven’t forced any binding constraints for the rest of my code. That’s how libraries work. I can pull out a tool, use it, put it away, and never worry about whether my future code now has to fit a certain set of rules. But with React, the rules you set up are binding for the duration of your project, unless you want to break up your app’s view concerns into parts that are totally dependent on React and those that are totally independent from (and not controlled by) React. Don’t get me wrong, I love React, and I definitely think there are huge benefits to using frameworks that force your code to adhere to certain rules on a large scale (it’s more maintainable that way!). But that makes it a framework, and not just a library. I realize the line you draw there is going to be fuzzy. But I don’t think you can deny that there is a difference.
FWIW, since writing up that approach, we've evolved it a bit to take advantage of JavaScript template literals: https://component.kitchen/blog/posts/using-javascript-template-literals-with-jsx-for-server-side-rendering This keeps the simple feel of our original JS function approach, and adds the readability and syntax highlighting of JSX (without using JSX or some similar build-time transpilation step).
"Market stats" depend on your audience. Trendy 20 somethings? Don't worry about IE. Targetings businesses with a line-of-business app? 8% might even be a bit low
That's an interesting discussion, and even though your poll is short lived, I think the results already speak to what I think would be the obvious answer: no, developers usually don't think about internal slots. If I asked, I doubt most of the people on my team would even know what an internal slot was. I also wouldn't agree with: &gt; ...devs have an innate sense that certain objects have an identity - something not directly observable that makes them what they are. I think to most would think identity is almost entirely based on (more or less) two things: Is it primitive (typeof)? What is its prototype (instanceof)? If you've been around pre-ES6 and tried to extend Array, you might start to realize that something like Array is a special case because it doesn't quite work. But I don't think that speaks so much to object's identity other than it being another one of JS's many quirks. _Arrays are funky. Ok, we get it, another "weird" part._ Unless you dig deeper, you might not realize its due to the dependence on internal slot for `length`. With ES6, though the array extending problem seems to have been solved with the `class` syntax, you also have access to more general purpose object types depending on slots which may also cause unexpected behavior... m = new Map([['a', 1]]) m.get('a') // 1 om = Object.create(m) typeof om === typeof m // true om instanceof m.constructor // true om.get('a') // Error In fact I asked about this behavior with respect to privates a couple of years ago on es discuss and was given a response basically saying its nothing new and happens elsewhere, another example being (pre-ES6): Object.create(new Number(1)).valueOf() // Error This seemed to satisfy me, but I remember that I left thinking that if people weren't aware of these kinds of conflicts with internal slots before, once private members start to take off, they'll start to. 
&gt; I don't think utility functions need to be terse. Neither do I. I don't think there is anything wrong with either of my examples, though. They are way below the character limit. I also don't have a need for a range function, by the way. It would be nice if we could just go from one value to another via dedicated syntax, but other than that I don't really care about this kind of functionality. By the way, there is no point in assigning a function expression to a const. Just use a function declaration if you want to declare a function. (Redeclaring functions is a syntax error inside modules. By using a const, you merely exchange one type of syntax error for another. The claim that it prevents this kind of mistake is bogus.)
&gt; It does not make the code look "cleaner" by not using a semicolon While I don't agree with that (I think not having them makes the code look much cleaner), I've run into enough problems trying to write code that doesn't use them, that I'm fully on board with the just-use-semicolons train. And tooling now makes it easy to enforce. The lack of "cleanliness" is worth it.
I agree, a range operator would be nice. I feel like js has become bloated, but I'm still thrilled about all of the proposals coming down the pipe. I didn't know redeclaring functions was a syntax error inside of modules. I thought that was just a lint rule. Do you mean **.mjs** files, or any js file with a **import/export** statements? I've never written an **.mjs**, so maybe that's why. I use webpack for all my browser code. &amp;#x200B; However, that's not why I declare arrow functions. Here's why: \- not hoisted \- lighter, with no prototype or lexical scope \- can't be instanced, so I feel like writing an arrow function more accurately illustrates intent. &amp;#x200B; I use the function keyword if I have to: \- generators \- method that's going to be optionally bindable: function capitalize (str) { if (this !== undefined) str = this return str.charAt(0).toUpperCase() + str.slice(1) } &amp;#x200B;
Front end is in a sort of weird place right now, but a definite through line is that you need to know JavaScript. Other than that, so much depends on where you're working. Frameworks like Angular and especially React are extremely popular right now, and it'll be impossible to learn them if you don't have strong fundamentals. That said, there are still plenty of places that are building on top of CMSes and such, where you're more likely to need strong CSS (and probably Sass or LESS) and can use minimal JS, but you'll still be expected to know things like event listeners, AJAX, working with APIs, etc. 
This is a very strong statement and I have no have no idea which side of the argument you are on. 
Yep, I think this is what OP meant to do. Also agree with @tswaters, originally post was really tough to read.
Go ahead, make it a Vue promo. Anyone who doesn't already know must learn the holy gospel.
Really nice site, great topic. Biking through snow in February must've been a bitch! I take it you're heading all the way to the southern tip of Argentina and, if so, when do you expect to make it?
&gt; Do you mean .mjs files, or any js file with a import/export statements? Any JS file which imports/exports. &gt; not hoisted And that's good, because...your editor doesn't support "go to definition" and you prefer to read the code sequentially in its entirety? &gt; lighter Is it? I doubt it's possible to create a semi realistic benchmark where it would result in a measurable difference. JS' memory usage is generally pretty high. Saving a minute amount here and there doesn't really change anything. &gt; can't be instanced, so I feel like writing an arrow function more accurately illustrates intent. Why would you call a non-capitalized function with `new`? Besides, there are classes for classes. Just use those. You can't call those without `new`. &gt; method that's going to be optionally bindable I wouldn't write functions like that, because documenting them would be annoying, it's not part of the signature, and the tooling doesn't really seem to fully support @this. function capitalize(str = this) { return str.charAt(0).toUpperCase() + str.slice(1) } console.assert(capitalize('foo') === 'Foo'); console.assert(capitalize.bind('bar')() === 'Bar'); String.prototype.capitalize = capitalize; console.assert('baz'.capitalize() === 'Baz'); That also works, but I'm not a fan.
Or `options` parameter, another good one
For most places? Node, React, Angular, Vue, Abobe Illustrator, Sketch, core CSS. Helps to understand the finer points on HTML5. Don't try to ram them all into your brain at once though. Most of the time what they'll really be interested in is your portfolio, repos, dribble, etc.
Firstly if it’s a class function then it is by default Bound to the class not the instance you are creating so you either need to use class properties , create it inside your constructor or bind it in there 
&gt;And that's good, because...your editor doesn't support "go to definition" and you prefer to read the code sequentially in its entirety? Because I prefer it, in theory. &gt;JS' memory usage is generally pretty high. Saving a minute amount here and there doesn't really change anything. If it doesn't change anything, then it doesn't matter either way. Why declare an instanceable, thisable entity if you don't need it to have those properties. Once again, I prefer it in theory. &gt;Why would you call a non-capitalized function with new? I wouldn't. So why declare an entity where it's possible? I prefer it not to be, in theory. &gt;Besides, there are classes for classes. Just use those. I do use classes! When used sparingly, I think they're great! As for your example, I'm not a fan of monkey patching, either. Big no-no. I'm a big fan, however, of the bind operator, [check it out](https://github.com/tc39/proposal-bind-operator). Ahh, nothing like a riveting internet discussion to start the day. Take care, man!
For internship, I wouldn't care if you had any experience with a particular framework like React/Angular/Vue. What would be valuable to me is if you had a decent understanding of the DOM and could manipulate it with vanilla Javascript. Those skills then map fairly easily into whatever they might be using to build the front end. You said you know html/css, so now get comfortable adding some JS that can find elements on your page, change the CSS classes of those elements, add event listeners so that interesting things happen when you click, hover, etc. 
Cool to read your opinion after you've experienced both! I also started going through Andrew's course now. I haven't really had issues with following Max's course but I can definitely see why some people would prefer Andrew's approach In the end, I think both courses complement each other really well and can be taken together. I myself started with Max's course and could skip many of the sections at the beginning of Andrew's course since I'm already familiar with those. If you're short on time or don't want to think about which sections to skip if you were to take both courses, I probably would recommend that you go with Andrew's course, it's probably ahead after the big update some time ago.
He actually did! And I answered there too with my thoughts. [Here's the link to that comment](https://www.reddit.com/r/javascript/comments/9r9owd/andrew_meads_vs_maximilian_schwarzmullers_node/ek31gp6/) if you're interested.
Personal Anecdote. I do code reviews every single day (mostly for js). I have never seen a bug due to missing semi-colons (eg. starting a line with []). I have however seen this... more times than I would like... from more junior/mid level devs who might not even be aware ASI exists. return { "foo": "bar" }; This returns undefined because ASI inserts the ; on the return line.
&gt; I'm not a fan of monkey patching, either Monkey patching was only done for the sake of further illustrating the bindability of this function. I meant that I'm not a fan of having a parameter default to `this`. (Which is essentially what you did, just without using this particular language feature.) &gt; bind operator The bind operator is still stage 0. The proposal is 4 years old. I won't hold my breath. The problem with doing "virtual methods" like that is that you don't actually state on what kind of object your method is supposed to operate. So, this is another thing you'd have to write documentation for. Or imagine you're using things like "length" and "forEach" and someone reads your code and thinks that they could use it for a NodeList... and then you update your library and start using other Array methods and it stops working for NodeList. Now that would be shite, wouldn't it? C#'s extension methods, for example, do specify what their `this` is. In C# you have method signatures like this: public static int WordCount(this String str) https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods Using :: virtual methods instead of monkey patching would of course be a lot better, but it just isn't good enough. The author's intent should be clearly communicated in a declarative manner.
Going deep with one framework is better than dabbling in a few, and there are tons of Angular jobs. If you're enjoying Angular stick with it.
Well that was their brief on jobstreet. I guess I'm just saying everyone knows React is better than Angular, but the other guy is right, it depends on where you want to work. I studied React because that's what everyone said in every forum and Angular sucks, but it's what they're hiring for here.
Maybe it has something to do with having more senior developers who still buy into the whole OOP dogma i.e. inheritance trees hundreds of levels deep, state distributed amongst thousands of classes each mutating state in different ways depending on what instances it interacted with and in what order each hiding their implementation details resulting in elusive bugs that never get solved. 
You can just run tsc get the output and follow the article, dynamic import no bundling required
You don't know what is most important dumbass, you are asking for help and think you know shit? lmao
That seems extremely wishy-washy to me. 
+1 for Formik
LOL. You'd make a good salesman. Evil, but good.
oh it was completely a joke haha sorry
I'm a developer that onboard new employee. Depend on the job, try to get as much information you can in the interview. We rarely expect new frontend developer to know more than, vanilla JavaScript, CSS, HTML. Some basic stuff like REST. Everything else can be learned pretty quickly with the existing code. Be flexible and adapt to the business standards. Ask alot of questions early on.
No front-end framework?
oh cool I'm glad I was able to offer some helpful insight! I don't mean to say that convenience should be avoided - but the canvas API is already super powerful and for a simple game it is probably easiest just to make your own shapes. Anyway good luck I hope it goes well!
I had created my [Personal Portfolio](https://wenghan.me/?q=reddit) and it's finally done! There's a [Terminal](https://wenghan.me/terminal?q=reddit) in the site :) &amp;#x200B; Using Quasar Framework, Vue.js, Server Side Rendering etc
This template uses jQuery, Bootstrap and Gulp — not something you'd want to use in a new project. package.json also states it's licensed under [CC0-1.0](https://choosealicense.com/licenses/cc0-1.0/) (while LICENSE says MIT, which one should we believe?) which is restrictive in some ways.
Also ngrx is not for complex models/entities. One can cause too many subscriptions.
It is awesome, but also a lot harder to find a job. Since I lost my last job, I've been applying to jobs non-stop, and doing some freelancing in the meantime.
Is it possible you are taking about AngularJS not Angular?
Since you onboard new employees, do you have any other advice? Any tips on how to get noticed? Been looking for a job for a few months but they are either not interested or I don't hear anything back. 
Hang in there! Network network network (as in the people version)! I've been lucky enough to get my last 4 full time gigs from personal references and/or freelance to full time.
Thanks, I think I have some promising offers lined up, hopefully one of them will hire me.
Definitely be honest with your answers. When I've interviewed interns we'll talk about your recent classes, the big project you are proud of, and since I like college football we'll talk about that. For direct coding questions there won't be any ultra complex scenarios but we'd go over what you know about the DOM, HTML, CSS, and Javascript. Might ask you about a couple elements or how you would style something. Other general questions may be What other languages you used and frameworks. Also you won't be working on anything production. Also also you won't be questioned on this but it's not a bad idea to have a high level idea about multi tier architecture -presentation (fronted), application (middle tier) and data management (back office/databases/etc.).
React or something like it is arguably the future. If you can, I'd suggest switching so you have more experience with those concepts over the long-term. It's not even just about React, the name. It's about all the things that React does and is.
Riot is archaic at this point. Only old hats that think they're being cool/alternative go with Riot.
Use prettier and format on save in your editor. Just having consistent formatting can help you see what's happening in your code. 
mostly yes
This is the best advice do far. I went from vue to angular/typescript recently. Why? Because I got a much better paying job with angular. Do I like angular? Not even a little bit, but I like all the extra money from this job. I just write all my side projects in vue and react and remember how much easier and more efficient they are than the behemoth angular application I have to deal with at work.
Unless this is a “front-end designer” role or something that, JavaScript is THE skill you need to know. I don’t want to be alarmist, and I’m sure the expectations aren’t too high for an internship but you should probably cram as much JS info down your face as possible in the interim. In particular, DOM manipulation, closures &amp; scope, async programming (how promises work) and general problem solving (think leetcode). But really, you should just ask the company how what sorts of things are fair game for the interview. Totally fair thing to ask ahead of time.
Add "-angular.js" without quotes to your search.
How much per hour are you willing to pay?
Yeah, it's also way neater than `Math.floor()` :)
More common imo to start a line with [ than ever mess up return. That's a pretty simple one to catch.
The irony is you wont get response from him
That return statement ends up messed up with or without the semicolon. It's just the semicolon might give the impression that it will work as intended, when it will not. There's lots of other ways to futz up where a semicolon is placed. Someone with less experience might type a semicolon after a loop statement: for (let x=1; x&gt;1; x++); { doStuff(x) } Of course, the linter is going to catch those. The linter is also going to catch not putting a semicolon after this: [a,b] = someArray I very much doubt array destructing is all that common, anyway.
Yup agree http://opalrb.com/
At work we actually got a bug due to missing semicolon. Not sure if it was a browser specific issue or general, but if I recall it was something with an IIFE. Might even have been two after eachother 
&gt; I can definitely see why some people would prefer Andrew's approach Why?
Your problem is that you "studied" for React. You should study JavaScript, and be able to pick up any framework you need to. In this day and age, knowing only a single language or framework does not cut it. Try harder.
They are probably senior because they realise there is more to development than programming paradigms, and each problem can be better solved by one paradigm or another. It just so happens that more often than not, OOP is a better option for designing enterprise business systems. It's far easier to model a business problem using classes. Functional programming definitely has it's place, but it doesn't need to be all the time.
I can’t imagine getting a single number mixed up with a non-number with extra parentheses. Other languages do have this operator, just not JS.
 var foo = function (x) { console.log(x * 3) } (function() { return 5 }()) Logs 15. var foo = 'bar' [1,2,3].forEach(x =&gt; console.log(x)) TypeError: Cannot read property 'forEach' of undefined &gt; It's incredible how many people argue with that they don't trust the machine. What? No, I certainly trust that JS engines will exactly do what the spec says. Thing is, the spec is very long and complicated. &gt; it's a freaking semicolon lol Yea, it's not. It's not purely decorative. It actually does have an effect. If you don't use semicolons, you have to be aware of the list of things you cannot do anymore. https://www.ecma-international.org/ecma-262/8.0/#sec-automatic-semicolon-insertion
isX, hasX, and far less common: canX, shouldX, expectsX, prefersX.
I just don’t like dealing with webpack config files. I was okay with Gulp. But I really like parcel 
Angular is designed around big picture/enterprise problems. Dependency injection is a pain until you need to mock something out. Modules are a pain until you need to update a version of a service "over here" and keep that updated version isolated from so that code "over there." I happen to like a lot of the architectural decisions in Angular quite a lot, and chose it for our company over Vue and React based on some of that higher level thinking. It's very opinionated, but sometimes that's a good thing. It's also regularly improving on some of the earlier questionable design decisions (like how they modified service injection from being explicit to implicit). A lot of the things you are citing as problems seem like they are likely issues with your implementation. Lazy load modules not used for the initial load. Tree shaking is one of the areas where it's had regular improvements, and Ivy (the new renderer coming... eventually?) will improve it further. As for performance, use AOT over JIT compilation. Every "benchmark" has it roughly on par with React except for bootstrapping the application, but a large part of that will likely be resolved when Ivy releases, and according to the design proposals, it shouldn't require almost any new knowledge to get the benefit out of that switch, so no point in waiting longer. If you don't already know rxjs, that's likely going to be your biggest "hump" in learning Angular. If you already know it, the other aspects are fairly trivial to learn and you can just read over the official documentation in a weekend and then refer to it as needed when building something.
What benefit do you find ngrx gives over using services for tracking state? I'd looked into ngrx fairly heavily, but figured because services are singletons a lot of the benefits seemed to be redundant, and that at least with services there's greater ability for code/state isolation vs essentially passing a global state management system/service. I'd love to hear about your expertise with ngrx.
Honestly, I think "shared" modules are a bit of an anti-pattern, despite being officially sanctioned as a strategy. While library support in the CLI isn't yet ideal (libraries don't auto-compile after changes), I've found libraries are a better way to approach shared code/resources. The problem with shared modules is that it can't be lazy loaded, and it's quite common that shared modules end up bloating quite a bit, so you end up unnecessarily bloating that initial load with code that isn't needed immediately. I prefer letting the compiler tree shaking/chunking do its thing unencumbered by what I think should be included or not.
you would normally use rollnot, not webpack, for component distribution. Let it multiple flat-bundles. One esm module, which you reference in the "module" field in your package json, one commonjs bundle which goes into the "main" field, and a umd, which goes into "browser" --- i guess. Here's a typical rollup config: [https://github.com/drcmda/react-three-fiber/blob/master/rollup.config.js](https://github.com/drcmda/react-three-fiber/blob/master/rollup.config.js) it's just missing the umd, because hardly anyone still uses that, script tags are dead. But if you really need it, adding the config is super easy.
I tried crwpifyer with umba yesterday and it just fails to compile
I guess I meant with any babel-added features. I know that vanilla js would return a syntax error... That's kinda why I posed the question. ;P
Cool stuff, thank you for that info! :) 
Nah, but thanks anyway. I'm familiar with the spread operator. But I see why the suggestion. 👍🏻
Yeah I appreciate the code and answer. Too bad, I was hoping for the coffescript/ruby type binary operator rather than a range function. I'll probably go with ramda's `R.range`. 
Thanks. Interesting - maybe I saw coffescript (or ruby) then. Would be cool to get an ecmascript proposal for that binary operator syntax for range though (that you showed). Closest I could find was a babel plugin npm module, but the operator and numbers are wrapped in a string. 
TIL ecmascript pls D:
Yeah, ty anyway. 
That seems kinda lame. W/e. Guess I'll funnel down to more niche subreddits to talk about javascript in the future. 
Yah this is awful.
There is no proposal for that yet. https://github.com/tc39/proposals
I came here to say that.
Oh neat! Thanks for the link. I didn't know it was possible to find all proposals all together like that. :) I wonder if a Joe Schmo like me could submit a proposal for that. Hmmm... 
Angular is a complete framework, React is an UI library. Not sure why people argue with this non sense. People who says a X/Y framework/library is better than the other just based on opinionated thoughts, doesn't deserve a bit of time of anyone's time. It is funny and cringe to read people like you feels elitist just because develops with React and some state libraries, not sure why.
https://github.com/tc39/ecma262/blob/master/CONTRIBUTING.md#new-feature-proposals
Your opinionated thoughts just made me cringe a lot, but the one that put the palm of my hand in the face was the Eric Elliot's medium article on TypeScript. If you concur on what that so-called expert conclusions made, you need to start working on understand things on your own and don't get feed on everything you read.
The only thing I can think of is to examine the request headers, and conditionally responding with whatever content you want. Or if it's just a mobile friendly version of your website, you can use css media queries to change the layout depending on device size. 
Not exactly, just different styles. Andrew's approach gives you more incentive to practice what you're learning. Nearly every video has a challenge where you're asked to follow instructions and implement what you've learned in that video. This part easily takes at least 20% of the course. Max's course, on the other hand, is more of a code-along and he doesn't include any challenges. Here it's up to you to put in some work and decide when, how and what you practice. With that in mind, because Andrew does things as he does, he tends to focus more on drilling each specific concept into your head and makes sure you feel comfortable with it and get some practice in before moving forward. Max gives you exposure to a wider range of topics in the same amount of time, but the explanations tend to be less detailed, you still get a lot of practical experience if you follow along and know how to solve similar problems on your own though. Comes down to your learning style. Picking both courses up solves most of these problems at the cost of time required, since they're pretty long.
I love this, a new major version of a framework gets called archaic while still in RC status. &amp;#x200B; All while accusing others of being cool/alternative.
Hi /u/anxiousDeveloper1, welcome to reddit! Unfortunately, this post was removed because you are a new user. This is a spam-prevention measure, we hope you'll understand. You'll be able to post in a few days, however, you can start commenting now! We'd love to get to know you. In the meantime, please read the site [reddiquette](http://www.reddit.com/wiki/reddiquette) and [/r/javascript's guidelines](http://www.reddit.com/r/javascript/wiki/index). Also, **/r/javascript is not a support channel.** For help with javascript, please post to /r/LearnJavascript instead. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
Trees and sorting and make yourself comfortable with coding without Google/StackOverflow etc Always explain what you're thinking atm. It's more the thought process than the actual coding IMO. Good luck ;)
I know it won't help much, but learn \_everything\_ you can, if you are even a little bit interested in the subject.
There's two issues with those numbers: - You're not measuring all visitors, only desktop visitors. - You're looking at data from up to a year ago. When I change it to include mobile browsers and only look at the current month, it reports Internet Explorer 11 at 2.67%. Not sure why you say you have to click into desktop versions; it shows Internet Explorer 11 without that constraint.
On 2019 your site really should be responsive, but when you need to load anything conditionally based upon device or browser etc upon need to use a library such as this https://www.npmjs.com/package/detectizr You could do it all yourself, but it's a lot of work, why reinvent the wheel?
Sorry, I think you misunderstood. It’s not my website - just a website online, that the mobile version works better instead of the desktop. Which redirects on certain links, unless it detects the user agent as a mobile one. Or does this library do exactly that? Can I use it to for the website to think I’m using a mobile user agent?
There is a chrome plugin that allows user agent switching. It’s source code might be inspirational: https://github.com/ray-lothian/UserAgent-Switcher The plugin seems to have a whitelist, so it might even be enough for your situation!
Would possibly rather make my own plugin that does this only for said site. 
Same with react. Don't want the rendering done by react anymore? Switch to marco, solid, etc. Not exactly drop-in replacements, still pretty similar. But let us stop - it seems we're talking apples and oranges here.
I just read your question again, and I think I misunderstood! There is a window.onunload that you can set, but in this case it might be better to do something like: document.querySelectorAll(“a”).forEach(linkElement =&gt; linkElement.addEventListener(“click”, event =&gt; { if(event.target.href.includes(“your condition”)) window.location = “new location”; return false; // prevent the original event })); Excuse the horrible formatting, I’m on mobile
It's one specific website you want this for? Is there a common format to the links? If so couldn't a simple if condition solve this? (unless I'm also misunderstanding): At the top of your content script: &gt; const locationString = window.location.href; &gt; const locationArray = locationString.split('//')[1].split('.'); &gt;if (locationArray[0] !== 'm') { &gt; locationArray[0] = 'm'; &gt;window.location.replace(locationArray.join('.')); &gt;}
I did misunderstand, have down voted my own comment.
Hahahaha don’t be stupid it’s ok! 
Not going to debate the frameworks usefulness, but I believe he means the framework mentality is archaic, not that the age of the release is archaic.
This looks like what I want to do. I will give this a go tomorrow - needed a fresher mind; you may have just solved this for me! Thanks a heap!!
No problem, you can feel free to message me tomorrow with any follow ups, good luck!
Seems /u/british-out may have solved this with his comment below; will follow up. Thanks for your input! 
Thanks heaps /u/Risc12 - seems /u/british-out may have solved it with his comment below! 
I feel like the word boilerplate is becoming a meme in JS. We strive for zero boilerplate for our hello world, but when you want to do anything useful you end up writing a ton of code just to make it work.
Had too many _cute_ features. Good thing is new language has a cute feature of only allowing imports from a github url!
Basic HTML/CSS and Js basic understanding is enough. Willingness to learn of course.
This week I have open sourced a Block based content editor [https://github.com/divineitlimited/hyper-editor](https://github.com/divineitlimited/hyper-editor)
lol. More like, "In 2019 your site really needs to fuck up the internet for desktop users by making a separate AMP site, which does not provide a redirect or link to the full website when it gets linked to on social media".
You can simply write `const { data } = await axios.get('/');`
I fucking hate sites that do this.
Yes that would one of better ways. Though, would need to consider await-async support.
Not if you're using a transpiler like Babel or TS. 
Looks good! If you want to check the hostname you could also do window.location.hostname, then you don’t have to split on //
Me too - ah well. That’s why we do what we do? 🤷🏻‍♂️
&gt;latest commit 6 months ago
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
No it's not. Don't abuse bitwise operators.
A few good easy concepts to learn, that I’d probably ask. 1) Difference between var, let, const 2) Object destructuring 3) Arrow functions 4) Maybe hoisting, might be slightly advanced. (Probably wouldn’t actually, but it’s good to know) 5) Difference between forEach and map 
And v5 while v8 is around the corner
I'm just here for the cute profile pic
Why wouldn't I reply? Currently I'm not working for a huge corporation, mid size one. Business culture have a lot to do with the hiring process. For internship we are mostly looking for basic job related knowledge, if you could learn easily and adapt but the biggest factor is personality, mostly to see if you would be a good fit for the team and have fun working with us. If you are telling us you have experience and expect more than an entry level job, we expect that you can backup your claim experience/knowledge also if you can add something to the team. being a good fit for the team is still the biggest factor. Bigger company doesn't involve dev as much for hiring and look for keywords. Learn the job posting and what technology they work with. Look for job level you can actually do and work from there, most important thing is to get experience in bigger company to understand how it work.
If you don't know it already, learn git. I'd recommend creating a github account and create something there to showcase what you know with a personal project. learngitbranching.js.org is a nice tutorial for learning git (which can take some time, but is definitely worth it). 
&gt; ust can’t work out URL handling. Wait. What exactly is your problem? I don't think url handling is hard. Irregardless, this is probably controlled by the user agent header. Set that properly and likely your problem will be resolved.
while(true){ That will always be true.
holy crap I feel so stupid for not seeing this. Thank you so much
Never feel stupid, you're learning! &lt;3
\#opinion
Yes agreed.
As a developer and hiring manager there's a few things I'm looking for. 1) Do you currently, or have recently, worked doing something similar to the job I'm hiring for. If so then talking to you is worth my time. 2) Is it clear that you have read my job post and have most of the skills I'm looking for, then I may ask via email about the other skills, and talking to you may be worth my time. When it comes to the actual job interview, I'm trying to get a sense for where you'll be at on day one. We try to get people pushing code to production on day one, but that means that I can't be teaching you an entire language on your first day. Ultimately you have to look at getting hired as a numbers game, apply enough places and you'll find someone willing to give you an interview. Interview in enough places and you'll get a job. The first job is always the hardest (see point 1 above) so I'd recommend falling back on whomever taught you front end development for help. If they won't help you, write them a bad review so other people don't learn from them. If you're self taught you need to find a way to produce something on your own, either a personal project or a contract. You should be ready to talk about this in all your interviews since it's going to be one of the few data points that an interviewer has to judge your skills in the real world.
&gt; since I like college football we'll talk about that. Do you ever exclude candidates based on their lacking knowledge of or interest in this?
why?
ha no, I ask this question, or similar, to see how they respond. It one of those questions that gives me a good idea how "conversational" the candidate is. Like will this person be able to hold a dialog, are our discussions going to question/answer, or a monologue where I talk and they just smile and nod.
When you've reached perfection, why keep going?
Yes, it's bad, but not bad enough to make you "unemployable". There's no need for that kind of thing anymore. If you're going to prefix-name your vars, use a prefix that's actually useful (and terse). Meaning... Phase 1: Stop doing e.g. `bolThing` when the convention worldwide for that is `bThing`, `sThing`, `iThing`, etc. Phase 2: Stop doing systems hungarian at all and, if you must, use apps hungarian instead. 
I found what might have caused all those bugs you described, and pushed an update where it should be fine. Thanks for using your sharp number tuned eyes to catch the problems. I see straight through it apparently ;)
&gt;Phase 1: Stop doing e.g. `bolThing` when the convention worldwide for that is `bThing`, `sThing`, `iThing`, etc. Or `isThing`. Regardless, this is the type of thing a company's style guide should cover. Follow that and you should be fine. 
Idea is how we can scaffold angular and electron.
Variables should help your code be self documenting, which also leads to less commented code. Give the variable names descriptive labels as to what they represent or do, so that anyone reading your code knows what it does.
If you want to be easily employable, just get used to using whatever the linter rule(s) are for your company. In a group setting everyone will have preferences, but a linter is a common rule set everyone must adhere to. It sounds like you prefer [Hungarian Notation](https://en.wikipedia.org/wiki/Hungarian_notation), however your future co-workers probably will not. Just tell interviewers that while Hungarian Notation is your _personal_ preference, in _professional_ settings you use what you are told. That's what I'd love to hear in an interview as someone on the other end of the table. Also with some modern tools like Prettier this issue is mostly moot. Prettier will auto format your code so no one else will ever see your strange names, though I'm not certain off the top of my head if it can actually handle variable names like yours. Finally as a side note I've never seen someone in the industry actually prefer to use Hungarian Notation. You may be a unicorn! Or perhaps languages that have types like TypeScript just eliminate the need as it's redundant information. tl;dr: You are not unemployable with linters these days
The intangible thing about hiring is that who you know still plays a large part into it. Find local professional groups and start going to meetings. Go to local talks and conventions. Make as many inroads as you can in the professional community, even if you’re not one yet. Who you know is just as important as what you know. 
Please look into Prettier. I feel that you're angry about a problem that doesn't exist because of code formatters like Prettier. 
Doesn't `iThing` stand for "iterable ..."?
Warning! This code will do things you probably don't want, including but not limited to: mutating the array you pass in, throwing errors if the elements are not all arrays of length &gt; 2, or if the 1st element of each sub-array is not a number. That said, this does what you want. const sortNestedArray = outerArray =&gt; outerArray.sort( (a, b) =&gt; a[1] - b[1] ); 
Or integer. 
Naming conventions are defined by the software architect, not the programmer. If you're the only programmer and thus also the architect, my experience is that the people paying you don't know or care about variable naming conventions. If you're refusing to follow the code style guidelines for the project, you're not employable all right.
I see... It's pretty ambiguous.
Wow,this is pretty cool. I just did a beginners course in JavaScript but I still don't really understand much your code. To make something similar where should I look into? Where should I go next? I'm kinda confused. 
I would never use type prefixes for variables, creating readable, obvious code should remove the need for that. Whether or not that makes you unemployable? That's a joke. Don't take that person's words to heart - keep practicing/trying.
I mean, booleans, should be called \`isBoolean\` but outside of that, you can kinda call it whatever you want. Buttttt, it is a bad habit, the next developer coming along (even if that's you in a few weeks) should be able to easily identify what is going on with your code, and good naming is a huge part of that. &amp;#x200B; Still, shouldn't make you "not employable" - the company will have naming conventions for you adhere too, and ina code test where you have like an hour, it shouldn't matter what you name things...
suddenly OP's system is not so terrible huh
Exactly. Which is why a Jsdoc comment and a good IDE is probably a better idea. 
those prefixes doesn't help anyone in a loosely typed language like javascript, as a arrThing could be reduced inplace and is then no longer an array but a string or number or an object. Variables should always be named for what they are intended for, e.g. visbility (obviously a boolean value), totalSumOfEmployeeSalaries (a number), firstName (string), lastName (string), user (an object for user information), users (a collection of user objects) etc. Never use generic Names for your variables like a, b, c, thing, stuff, foo, bar as nobody will know on a glance what those variables are when they are in use.
Thank you very much but how would I implement this code in my program if the array I want to sort is called "Team\_list"
just use css media queries to hide/show differently formatted divs based on mobile/desktop. You should really be trying to use a responsive design, though, so you don't have to redirect to a new page
What is "is" supposed to stand for in `isThing`?
If you set up your site through Cloudflare, they have automatic mobile detection and redirect.
Doesn't stand for anything, but represents a bool. Is this a Thing? True/False. isGoodValue, etc.
`sortNestedArray` is a function you can call anywhere after it's loaded like `sortNestedArray(Team_list)`.
Oh wow, never heard of that before as a var name, just as a const/enum to compare to. Can't say I like it.. ;)
Prettier isn't going to help here and it won't obscure variable names in any way. It's just a formatter, why wouldn't it be able to handle this naming convention?
What you're doing here is called [Hungarian notation](https://en.wikipedia.org/wiki/Hungarian_notation). I wouldn't call you unemployable but hungarian notation is pretty old and dumb. See the wiki page for it's disadvantages. My best guess is they either think you're very inexperienced (because no one has told you before how beginner-like hungarian notation makes you look) or that you learn from odd/out-of-date resources which means your learning process is flawed which is one of the worst things in a developer
It doesn’t stand for anything. It’s just ‘is’ as in ‘isVisible: true’, ‘isValid: false’. 
Hungarian notation is only marginally useful in statically/strongly typed languages. Even then, they're still not needed because of modern IDEs and editors. Leave hungarian notation in the 90's where it belongs.
I used to do the same thing. &amp;#x200B; STUFF THING STUFF2 &amp;#x200B; lol &amp;#x200B; Good chance your code sucks too. Just keep practicing.
You was told right, change it
The problem you're trying to solve with naming conventions is better handled with TypeScript or with JSdoc type hinting and by using an editor (VSCode) that can take advantage of those types.
It's a valid convention. In the days of C, it was even one of the most common types of convention: https://en.wikipedia.org/wiki/Hungarian_notation (notice that naming after type is a dialect, not the main Hungarian notation... yet the entire Win32 API follows this dialect, so...). That said, it's not popular in JS and this matters. I wouldn't say it makes you "UNEMPLOYABLE", but when in Rome do as the Romans do - can't you adapt to your environment?
Instead of prefixing with types, which can be a lie anyway, you are better off asserting all your variables at the beginning of functions.
I think OP means they were naming things like: arrUsers, boolConfirmed, strUserName. I think it’s silly and I’m curious where they even came up with that, but I don’t think they were literally calling their variables “thing stuff foo bar a b c”.
I wouldn't say it makes you unemployable (it says little or nothing about your skills), but it's not a good practice either. Its like naming a function "functionToMakeThis" instead of "makeThis".
I believe the origin of Hungarian Notation was not about prefixes telling what type things were, but important info about the content of the variable. You are prefixing strings with ‘str’, but you would most likely already know it’s a string from its declaration or editor hints etc. But in a system, a string might contain the encoded value of string or the bare value of a string, and in that case, it becomes valuable to use agreed upon prefixes suitable in the current app domain. E.g. ‘password’ vs ‘encPassword’ etc. In that kind of scenario prefixing becomes valuable. But non-hireable... sounds like a place you want work anyway...
Hiring manager here. For JavaScript, Hungarian Notation is not common, but using Hungarian Notation does not make you not employable. What would make you not employable is refusal/resistance to following the naming convention set by the company. For future interviews / homework / GitHub examples, I would highly recommend avoiding it in the future. If I interviewed someone that was using Hungarian Notation with JavaScript, I'd question how much knowledge they have about JavaScript and have concerns about their coding style in general, but it wouldn't necessarily be a deal breaker.
If you cannot see the problem then I agree, no one wants to deal with code that lacks basic effort. Your examples are pretty much taken from the blog, “How to Write Unmaintable Code”
Or Apple has one more iThing to show us.
I don't think OP's solution os exclusive of that. My interpretation is that strThing in practice would be something like "strLastName" or "objItemList", and so on. I would agree that having a bunch of strThing's and objThing's around is confusing, but the inclusion of a data type doesn't sound like an "unemployability" offense. More like a "I'm more fluent in a strongly typed language and have habits that may be worth breaking" kind of offense.
I... I don't think they meant they literally call all their variables "thing"...
Notation does not make you not employable, on the other hand if you refuse to change it, that's other thing...
It comes from the convention about _accessors_. So called getters, with their more general form `getProperty`, don't exactly sound good for boolean properties. Say you have an object which can be active or not. Writing `thing.getActive()` -with or without `()`, that's irrelevant- sounds weird. And so, for boolean properties, this was transmuted into the alternative form `isProperty`. It's extremely common in Java (it is in fact part of a specification -JavaBeans-), and fairly common in a number of other languages, including certain styles of JavaScript. Other languages, which support having the question mark character as part of an identifier use the convention `property?` -or more in general `predicate?`-. With time, some variations include `hasProperty` (e.g. `hasChildren`, where `isChildren` wouldn't sound right), and sometimes `canProperty` or `shouldProperty` though these two are less common.
It isn't bad but as some in the thread have said, do not shorten by more than one character, because if you have several, you must remember the abbreviation. &amp;#x200B; Most javascript programmers are using lowerCamelCase and that sucks big time.
Prefixes makes the code more readable. I think you mean readable for those that want to understand what the code does. Not readable for those fixing bugs.
Why are " visbility " a boolean value?
You can max remember 3 or 4 variables fixing bugs developing software + 100 000 lines of code. &amp;#x200B; Prefixed based code where the type is either one character or the complete typename makes the code much more easy to handle.
What's wrong with it? 
Besides using a descriptor like ‘isName’ as shorthand for “is this a name?” its also quite common to name bools (or functions that return bools) that track some relational status like ‘hasBatteriesIncluded’. This leads to naturally literate code like `if(item.hasBatteriesIncluded) { return item } else { return { ...item, batteries }}`
Because something either has or doesn't have visibility.