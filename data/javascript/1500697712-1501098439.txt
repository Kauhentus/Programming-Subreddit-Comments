Another commenter mentioned the codes rubbish - it's not asm.js.... 
Thanks for the research, someone up there mentions that the variables are used incorrectly too.... no 0| things and the likes.
I see, thanks!
I completely forgot about that - thanks for the reminder.
Holy tits this explanation finally clicked for me ty. 
Just started building with Vue recently. Purchased for $10 (no coupon) here it is just in case any is looking for it though. 2JUL202 Search : code promo coupon
Punctuation !== use of semicolons... The latter does not help with readability at all, punctuation does.
Sounds exactly like an RxJS BehaviorSubject. 
Getting? People have been talking about the license for ages. We had to go with Vue since our lawyers said we can't use React (we are a Fortune 150 manufacturing company that doesn't even compete with Facebook!)
To be frank, there are none. Javascript inherits from Scheme, so I personally tend to lean lisp-ward in my library apis, but there is a segment of the population who are trying to induce a Haskell-like approach, which has a different flavor and can introduce some challenging problems, i.e. Ramda's problems with auto-currying and slowness. Ultimately, there's little to no consensus on what the "right way" is. This is how we end up with a trainwreck (dot notation) syntax like underscore and classic lodash, manually composed functions in other libraries, and a blend of uncurried, explicitly curried and auto curried functions all over the place. Short version, nobody is wrong, but nobody is really right either. It's a realization of an xkcd comic. https://xkcd.com/927/
[Image](https://imgs.xkcd.com/comics/standards.png) [Mobile](https://m.xkcd.com/927/) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini\-USB\. Or is it micro\-USB? Shit\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 4684 times, representing 2.8586% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_dkk2bss)
Oh, npm. I thought you were going to say Yarn. 
I used this trick to keep a phone on 24/7 with a prototype at work once. After about two months of forgetting about it, it had a burned in message telling people to pick up the phone any try it out...poor poor phone. 
Reminds me of when facebook played silent audio to keep their ios app from sleeping.
Isn't that exactly what he wrote? 
How can there occur a choice between RxJS and Redux? They are completely different things.
I bought Max's course on Angular 4 and it was so good I jumped on the one he made about angular animation, he is a very good teacher. I might pick this on up because his teaching really clicks with me even though I don't have any plan to learn Vue soon. I agree with the price too, I picked both his Angular courses for 10 euros each, /u/timestartsnow posted a coupon and if someone reads this and the coupon is expired, check Max's youtube channel, there should be coupons in his video descriptions.
You can still use Redux and use an observable library. I'd say just go with Rx or xstream.
I say getting because it is becoming public knowledge. There was a thread the other day where a lawyer publicly reviewed it.
I had to enable a special chrome flag (ignore-gpu-blacklist) for this to work on my browser (running linux). Do most users have to do this as well to be able to use this library? It'd be really great if I could use this library in one of my projects without expecting all my users to mess around with their browser settings first.
It probably just means that they rolled their own system for handling user interaction, data fetching etc using Rx.
I figured that "use asm" covered that in my case, since it was a good bit slower without it, and was essentially just as fast as the emscripten version on subsequent calls (with asmjs as the target). Coupled with the fact that emscripten with webassembly as the target was faster yet, though nowhere near as fast as native gcc. I don't know why your system didn't show a difference though. might be worth trying it with hand rolled asmjs.
is this post just an advert?
awesome article! highly recommend!
Couldn't you fix that by displaying a full screen black picture. Screen looks off, but phone is not asleep. 
[removed]
No.
I'm one of the main contributors to RxJS and I wrote most of the docs site, so I feel it's mandatory to comment on this post. "The documentation could be way better" is actually a good statement, which I agree. But it doesn't mean the documentation is terrible. The arguments weren't that solid. 1) "Choosing an operator": a lot of people really like that tiny web app, I've heard many tell me that it saves their day. Our documentation site is generated with ESDoc, so the side bar is rather useless (ESDoc is hard to customize), but you can still see a normal list of all the operators here: http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html 2) "It is incomplete": this is true and annoys me, but you have to realize RxJS has 100+ operators, and this number grows the more there are operator proposals (people can get pretty aggressive demanding a new operator to be added), so it's a moving target. Of course we prioritized documenting the most important operators first, so the ones not documented are (usually) rarely used. 3) On the documentation of each operator. It could be better, but they aren't bad. Compare RxJS docs with Lodash. Usually in Lodash you have a quite short explanation of the method, and a synthetic code example, e.g. using arrays of numbers. Each RxJS operator is vastly more detailed than Lodash methods, we have: (a) a short technical explanation, (b) an "informal" beginner-friendly explanation, (c) a marble diagram generated from real unit tests that exposes the real runtime behavior of that operator (it's not like we just drew a fancy picture. We took a snapshot of the operator behaving in runtime, you could say. And I went to far lengths to make that script), (d) a thorough explanation, (e) some examples, (f) similar operators. That's a lot of bullet points for one operator, and we have 100+ operators. Try to appreciate how much work that takes. E.g. http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-combineLatest 4) About the Egghead paywall. I made most of those courses so I must comment on this one. First of all, most of those courses replicate quite closely the tutorial in the official docs: http://reactivex.io/rxjs/manual/overview.html I made both the tutorial and the Egghead courses. I'm not locking away content, I'm just providing it in a different format, because a lot of people appreciate a video format more than a textual format. Egghead courses are not official documentation, they are extra learning material, just like books exist, and usually books cost something. I also provide RxJS training, like https://staltz.com/rxjstrainingcph/, and other core contributors do that too, like Ben Lesh, http://rxworkshop.com/. And the feedback from these trainings have been very positive, customers are satisfied. I'd love to do everything for free, but unfortunately, food from my local grocery store isn't for free either. As you noted, there are also plenty of free content from Ben and me, on both YouTube and blog posts. Conclusion: yes, the docs could be better, but please set your expectations realistically. This is an open source project currently maintained by volunteers, it's not the documentation site for some enterprise database with enough (human, capital) resources, so there are different dynamics involved. I would love to spend more time building open source, and specially I'd love to improve RxJS docs, but without funding, that means I need to spend time making a living first. Same for other contributors. There are many types of open source, and some are led by companies and large teams, so it's easy to set our expectations where all open source projects are on the top-notch level. If anyone finds a spot on the RxJS docs which could be improved, we regularly accept pull requests, and we agree that overall things could be better, but our current life situations can't find 5 days of free time to dedicate exclusively to improving one aspect of RxJS.
That's helpful. It's what you need to know right? How to fix your problem and a map reference in case you need to dig further. 
http://www.writethedocs.org may interest you?
That's cool! I'll try this out soon! 
He was talking about [Fantasy land](https://gitter.im/fantasyland/fantasy-land). Not one I know.
Man, pasting it into the twitter console was a ballsy move too, do that, with something that makes you auto-tweet the code and you have a worm.
Seems a little unreadable to be honest. Here's my quick attempt without dependencies using simple recursion: function flatten(node, result = [], depth = 0) { node.forEach(child =&gt; { let flattened = Object.assign({}, child); delete flattened.items; flattened.depth = depth; result.push(flattened); if(child.items &amp;&amp; child.items.length) { flatten(child.items, result, depth + 1); } }); return result; } It's not a purely functional style, but it's pretty readable. Using `Object.assign` might be expensive on a large tree, but it does ensure we only iterate over non-prototype, enumerable properties while also not modifying the original tree. [JSFiddle](https://jsfiddle.net/c4xLs7pm/5/) 
Don't fall into the lodash trap. I see a lot of junior developers fall in love with lodash and overuse it because they're not familiar with the underlying power of the language itself (assuming you're using modern JS). Fast forward a year, and they're almost completely incapable of succeeding without using lodash (we had to revert our "no more lodash" policy on the project I'm on now because of this exact scenario and deadlines that can't wait for homeslice to learn "vanilla" JS). The last thing I want to be as a developer is so coupled to a 3rd party library *as an engineer* that I can't succeed without it. And in cases like this, where you're doing something relatively simple (walking down a tree and keeping track of depth), you really **shouldn't need** lodash, and if you do, then you absolutely should not use it. IMO. You can do everything you do with lodash with **just** reduce and some recursion, and it's much easier to read without binding a lot of functions that are hard(er) to reason around. Anyway, here's a pure-JS reduce-only implementation: const onlyReduce = (childrenProperty) =&gt; (levelProperty) =&gt; (level = 0) =&gt; (item) =&gt; { return item.reduce((builder, object) =&gt; { object[levelProperty] = level; builder.push(object); if (object[childrenProperty]) { builder = builder.concat(onlyReduce(childrenProperty)(levelProperty)(level + 1)(object[childrenProperty])); } return builder; }, []); }; I'd argue that this code is simpler, easier to reason about, easier to read in a year when you stop using lodash, and probably runs faster as well. If you're using babel/modern node (ES6), IMO lodash serves more as a crutch than a useful utility, at least until you get used to relying on the language itself and discover the warts that you come into contact with a lot (deepEquals, merge, etc). As one final note, it's not really FP style to modify data in place :x 
Exactly! If anyone really cares about computation performance, they'll go OpenCL/CUDA. Even for prototypes. It's easier and faster. And if you start doing stuff the right way from the beginning, it will be easier to support in the future. But playing around with WebGL for the sake of hacking and learning is cool.
Would http://yeoman.io/ work for you?
Well said - I couldn't for the life of me work out why someone would need to import four different lodash functions just to do a bit of trivial tree-walking. There's nothing wrong with using libraries like lodash to save a bit of time in a project, but if you're a learner or lazy, shortcuts become ruts become prisons far too easily, and almost always without you realising it.
Sorry, got to where? 61Mbit? Also your algorithm is more then 2x slower then the one in my post and it uses much more memory.
Have you looked at [ngrx](https://github.com/ngrx) at all? It's the redux architecture driven by rxjs. I'm a big fan personally.
&gt; Disclaimer: Application Cache is already marked as a “deprecated” feature, and Firefox advises using Service Workers instead. On the other hand, Service Workers are still marked as an “experimental” feature, and not yet operational in all browsers. Web dev :D
Looks that way.
Joke You
In our team (we also do react native app), we use redux with redux-observable and rxjs. We quite like it! What you can do is using observable only for more complex async cases. So the learning curve won't be that big as you'll limit its use.
From what I know, short of rolling your own, nobody has bothered trying to make an alternate to yeoman.
Why?
Syntax Error! Unexpected token '.' whinyComment.js 01:45
Well I explained why in the second sentence of the article ¯\\\_(ツ)\_/¯
Yeah, I read it, still don't know why, lol
A lot of the time I do stuff just because I want to see if I can. Especially if I learned it in some theoretical way and want to see it in practice 
https://github.com/RemeJuan/progressive-web-app-starter
Isn't the data structure exactly same as [cons](https://en.wikipedia.org/wiki/Cons)? The article doesn't mention about any references at all.
That is AWESOME, I mean, creating a low-level representation of something in such a high-level language, is really amazing! I actually gained quite a bit of knowledge reading this! Thank you!
Hi, blog post author here. Firstly, thanks for getting me into FRP - without the mindshare around RxJS and the excellent redux-observable library it would have passed me by. I'm sorry that my criticisms haven't gone down well - I admit that they could be more constructive and I'm sorry about that. I appreciate the time you've put into the project. The work you have put into this project helped us deliver a project that I don't think we'd have been able to deliver within the constraints without RxJS (or some other js frp library) and I am genuinely grateful for that. Rather than writing a pained blog post, I could have opened some documentation pull requests, though I'm limited by not understanding the things I'm documenting in the first place. &amp;nbsp; &gt; we have: (a) a short technical explanation, (b) an "informal" beginner-friendly explanation, (c) a marble diagram I apologise, I wasn't very clear here. The main issue I have is that as a beginner, I want to understand why the operators exist and what problems they might be useful to solve. Take `bufferWhen` - when I first came across it I wanted to know why I'd ever need it. The "beginner-friendly explanation" says: &gt; Opens a buffer immediately, then closes the buffer when the observable returned by calling closingSelector function emits a value. When it closes the buffer, it immediately opens a new buffer and repeats the process. Which repeats the method signature in plain English - it doesn't say anything about why I'd want to use it or what problems it exists to solve. Then the code example is: &gt; Emit an array of the last clicks every [1-5] random seconds which I don't think is a particularly common use-case. &amp;nbsp; &gt; most of those courses replicate quite closely the tutorial in the official docs... ... I'm not locking away content, I'm just providing it in a different format, because a lot of people appreciate a video format more than a textual format. I disagree. The written docs don't seem to contain anything on higher-order observables or the interaction between switch/merge and errors, both being really fundamental to using RxJS. This is hopefully where you prove me wrong since I don't think I properly understand the error propagation yet and am keen to. &amp;nbsp; &gt; I'd love to do everything for free, but unfortunately, food from my local grocery store isn't for free either I never asked you to do everything for free. I paid the $200 and enjoyed your egghead courses and more broadly I support the idea of paying to watch specially-curated video series that augment existing documentation. Redux is a great example of where the egghead courses mirror the free, written tutorial content very closely so you pay closely so you pay for the privilege of having the author teach you and walk you through the tutorial in real-time. My issue is that for RxJS, some really crucial bits of documentation seem to only exist behind a paywall, in video form.
Cool, didn't know this. Added links.
I partly get what you're saying. And sounds very much as if you're talking about jQuery. It seems to be the same thing. But I do know how JavaScript works. It's just me trying something new because I'm hearing much about lodash and fp in general. And it just sounds right. The advantage I see in Lodash over the built-in functions are that they aren't tied to the data type and I can build flows more freely. Actually I'm looking forward to the pipeline operator (`|&gt;`) but it's not even Stage 0 so there's no Babel plugin yet. And Lodash's `flow()` is the closest thing to pipelines. Which means I'm going to rewrite it in pure JS since performance is also pretty important here. Also allow me some questions: - Are there scenarios where you'd say it's fine to use Lodash? - If no: what's your recommended way of dealing with situations when you need the functions `deepEquals` or `merge` you've mentioned? Anyway, thank you for your feedback and insight*! *) "no more lodash" policy. Didn't expect that to be a thing. If I think about it I'd love to see a "no more jQuery" policy in my company...
You'll have to do experiment on it in that case. Each site service use their own policy to limit their API usage, so the limit varies.
Thanks, I'm glad it was useful to you!
He's said they're not necessarily immutable, but they're 100% immutable. There's absolutely no mutability. I was trying to help people understand but apparently my explanation didn't resonate with you. The value of a const can never change. This is obvious when using primitives but less clear when using data structures (like objects and arrays). When you assign an object (or array) to a variable the computer does two things. It sets aside some memory for the object and then it stores the address in the variable. If you use const when defining your variable, the address can never change. That "variable" is now immutable. Imagine I wrote down the address of a house on a piece of paper. You go visit the house and your best friend lives there. Later, you go back to the same address, but now Emily Blunt lives there. The address never changed, just the occupant. That's why this concept is confusing. People see a change so they they assume immutability hasn't been upheld, but it has. A `const` is 100% immutable. It can never be redefined. 
You're welcome! I'm glad that made sense to you.
The periods are characters 34-36. If you're going to be an ass, at least put some effort in. A lazy ass is the worst kind of ass.
I was on mobile when I wrote that, but that's a valid question that deserves a more detailed answer than I was willing to type on a phone. As I mentioned above, we used an Observable for state management. To simplify, let's say we had a `stateObservable` that was something like: Observable.combineLatest([ userDataObservable, companyDataObservable, formStateObservable ]).map(([ userData, companyData, formState ]) =&gt; ({ userData, companyData, formState })) We used Subjects to handle user interaction, to trigger API calls, etc. - we might, for example, have something like &lt;button onClick={() =&gt; this.props.formDataSubmitSubject.onNext()}&gt; Submit &lt;/button&gt; and then maybe a `formDataSubmitObservable` that looked something like formDataSubmitSubject .withLatestFrom(formDataObservable) .flatMap(([submit, formData]) =&gt; { return Observable.fromPromise( fetch('someEndpoint', { body: JSON.stringify(formData), headers: {}, // whatever method: 'PUT' }).then((res) =&gt; res.json()); ); }) .do(() =&gt; {}); // presumably do something with the response It worked, but as I mentioned before, it was difficult (often impossible) to test, and there wasn't really a great deal of value to treating discrete user inputs as Observable streams - this was a business SaaS product, not a game. If I were doing it all again, as I said, I would use Redux, but since I know Rx pretty well at this point, I might consider redux-observable over redux-saga.
Exactly. I posted a more detailed reply to the parent above.
There's absolutely nothing wrong with using lodash to get stuff done quickly and in a safe cross-browser way. But if you don't know linked list, array, tree and hashmap and the typical operations on these data structures, then you should implement them by hand FIRST. After that you'll be very aware of when to use lodash and how to use it. The people who are telling you not to use lodash are fools. What do you do when you want to implement map that works on objects and arrays? You write your own abstraction. What do you end up with? Your own damn lodash. Which will be less tested and less optimised. So go learn how map filter reduce zip groupBy flatmap and sort work. Then lodash all you like. In other languages all these are implemented as part of the standard library. And yet here we are in JS land telling junior devs to write these common operations by hand because 'it's just a trivial traversal'. Get off your high horses.
Iivhi
The point is: I read this part of the documentation and knew instantly what it's talking about. While on the other hand I also do know RxJS BehaviourSubject but even now I can't say for sure what exactly it is or does. Plus: I do know that RxJS `Subjects` are that kind of Observable that have a `.next()` method to trigger a new event manually. But I don't know what the `Behaviour` part means. And I haven't seen this whole manual `.next()` thing in bacon so far. It also says that `Properties` are one of the differences compared to RxJS. It may be true that those are equivalents but bacon managed it to explain itself in a way that I understand after reading two sentences. While RxJS couldn't do that after letting me read through their documentation, read "[The introduction to Reactive Programming you've been missing](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754)" and watch several video tutorials. Do you know what I mean?
Gybug**nЖивущий вeuf****hd rnuf~~~~
absolutely agree with /u/xwnatnai, using lodash is by no means bad practice, and I can list lots of reasons including no standard lib, ability to map (filter/reduce, etc) over objects. Using `get` and `set ` increase the reliability of getting/setting nested prop. Why would you need to write it by yourself if these are essential operations? And more thing if you are into FP, I'd really recommend you to check out [Ramda](http://ramdajs.com/docs/) library, which is general purpose toolkit *designed specifically for a functional programming style*. Where all functions are auto curried by default. Function `flow`, that you are mentioning is a `pipe` operation, which is a composition (`compose`) with reversed arguments order (ltr). And Ramda, of course, features data-last model, which is not possible with the regular lodash.
Oh, wait. I'm using `lodash/fp`, not regular `lodash`. It's the official functional programming version of `lodash` and works the same way as Ramda. I also do know Ramda. I just prefer `lodash/fp` because `lodash` seems to be more maintained (v4 vs v0.22). Plus: `lodash/fp` is modularized. That means you don't have to import everything just to use a few functions which results in a much smaller bundle size.
What a pity. Why is it so hard to find a large web application that relies on rxjs 
I believe that tree-shaking is available with Ramda as well. And I'd say that version number doesn't mean that much in terms of maintainability. Both of them are complete and self-sufficient, with the difference that lodash has longer history of development. Well, missed that it was `lodash/fp`, my bad.
(Do I really make people feel like I'm a junior dev? I'm new to Lodash and fp, but I know very well how to deal with plain JS (Prototypes, `.apply/call/bind`, how `this` works, the event loop...). Or does it mean something different? Anyway...) I wouldn't go so far to say the others are "fools". It's true that using a library introduces an additional layer that can decrease performance. That's where they are right. But it's also true that otherwise you end up building your own Lodash. ...and guess what? [I DID](https://github.com/alinnert/essenz)! (But it does a little more: DOM stuff, events...) But now I wonder, does it increase performance if I replace `flatMapDeep` with: return [...currentData, ...getNextLevel(...)] Or if it's better to just `.push(newItem)` everything. With "tree" do you mean the "trie"? I've heard about that, yes. But only briefly. I know linked lists only from C. Where do you learn about these kind of data structures? (JS related) FP tutorials only talk about functions most of the time.
Hi /u/timestartsnow, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
I found [this issue](https://github.com/ramda/ramda/issues/2180). It says tree shaking requires the plugin `babel-plugin-ramda` for now. In the issue a dev says they will tackle this right after releasing version 1.0.
That's true. Thank you.
Well, when I was working on the tree-shaking process set up with `lodash`, did essentially the same as `babel-plugin-ramda` and `babel-plugin-lodash` do - cherry picked only used functions. So, not much difference there, but probably I've missed something.
I don't know your level of experience, and I don't think I'm qualified to be the judge of that. As a language Javascript does what it does relatively well, but my experience is that if you only do JS, you run the risk of becoming a programmer with little depth. So, it's good to write programs, whether they be user interfaces or APIs, in other languages. Some will disagree, but I think Java is actually a good language in which there are well tested implementations of many data structures. For a functional flavour, scala helped me a lot, by way of understanding what it is FP is (not just map filter reduce) and also what a full fat functional language should look like. Clojure/Lisp was also beneficial, and trying to follow at least at a superficial level, what SICP teaches. I'd like to learn Haskell some day, but right now it doesn't have enough practical uses for me.
I will send your post over to our guys who abuse ramda pretty much in the same way as you describe :) ..after 3 weeks no one understands the code and debugging or upgrading is a nightmare
Amazing!
This starts to get a topic on its own now. But anyways: I did learn a wide variety of languages back in school (from C over Java to Cobol...) but right now I only need JavaScript. I even saw a video that demonstrated a bunch of very fancy stuff you can do with this language. Even developing an "app" for Google Home (are they called apps?). It's just so extremely versatile. One thing where I'm really looking for an alternative is developing desktop applications. But I couldn't find one that really attracts me. When I look into native UI development (Java, JavaFX, C#/XAML, Python) it looks way more difficult compared to JavaScript, or especially "the react way" (= data changes =&gt; call the `render` function). On the other hand I also don't know why I should learn languages like Haskell or even Rust and Go (which also have drawn my interest). I don't know what I should build using them.
This seems like a hack, no? Is the browser guaranteed to update the DOM within 1 ms or even 100 ms? [edit] also, if i use 2 unique classes for `fadeIn` and `fadeOut` CSS animations why then do I not have to wait for the browser to update the DOM?
You must be from Stack Overflow...
Lol, no, just s reasonable person. Writing a VM yourself seems masochistic.
https://jsperf.com/ramda-vs-lodash/2 I've found some performance tests. Using `.map/filter/reduce` etc. seems to be a terrible idea performance wise. They are **a lot** slower than `for/while` loops. So if I need fast code I need to use plain loops. Moving the loop into a function already has some noticeable performance impacts. And that's what Lodash does. So there's also no point in creating my own loop/map function. That's indeed a reason to avoid the native array functions.
Toy projects are for fun. A simple VM like this can be a lot of fun to write.
Sure yeah, you'll want to use a function to wrap, not an object. There might be a way to transform an object from inside itself, but I've never had any luck with it. That said, functions _are_ first-class objects in js ( https://stackoverflow.com/questions/705173/what-is-meant-by-first-class-object ) http://javascript.crockford.com/private.html https://johnresig.com/blog/javascript-getters-and-setters/ function defaultx(val){ var email = val; this.getValue = function(){ return email; }; this.setValue = function(val){ email = val; }; } console.log(defaultx.setMsg(66666)); console.log(defaultx.email); Hope that helps! _edit:_ here's another good link: https://johnresig.com/blog/javascript-getters-and-setters/
Same. http://littlecomputer3.com
https://github.com/SpencerCDixon/redux-cli provides the ability to use one of 5 built in blueprints (smart, dumb, form, duck, and blueprint). It is very easy to customize the blueprints you want to use or create entirely new ones. I've never used Yeoman, so I can't speak to differences between it and redux-cli. There are similarities to Rails generators though. Hope this helps
This is really cool, designing your own instruction set seems pretty fun. It reminds me of my first year of Compsci degree, where we were designing parts of the hardware for a super simple 8 bit machine using verilog. We had to use a super stripped down ISA, with only one register and ADD, INC and SUB operations! It was great fun!
fwiw: http://www.pcjs.org/ , i.e. running windows 95 in a javascript emulator.
&gt; After all, if you know JavaScript, you’re well down the path toward knowing JavaScript well I mean I hope so
I used redux saga and redux observable, they are nice and all, but in the end I think I prefer "vanilla" redux middleware over those.
Really considering ditching angular for Vue now
I was thinking the same thing.
Very cool project and awesome write up! Found a typo under section 3.0: "My assembly language cannot operate arbitrarily operate on different kinds of data..." It's interesting that you chose to include `CAL` and `RET` as machine level instructions rather than just have an assembler macro that spits out the needed machine instructions. Not a criticism, but my only experience writing low-level code is [nand2tetris](http://www.nand2tetris.org) and that vm design didn't include stack manipulation in the machine instructions.
Thanks! I'll go in and fix that up later. The reason I implemented call is because the language doesn't provide access to the instruction pointer and therefore can't push it onto the stack via a macro. Good point though, it's the second reason I've come across that exposing the instruction pointer might be a good idea. 
Incredible! Nicely done dude. Saving this :)
Angular 2 is the thing that will save typescript. Typescript is the thing that will kill Angular 2.
Check out dirp-tree, it's a fairly simple filetree generator that supports file templates.
The entire code base is so cleanly written. Man Im so jealous.
but dude, do you, like, _realllly_ know javascript?
Micro-benchmarks are almost always absolutely, 100% thoroughly fucking useless. Ignore them. Write code for humans, not machines.
This repo needs a lot more than 200 stars
Er? Typescript is fantastic for 99% of the cases you could imagine. What problems could anyone have with it?
Does anyone ever really -know- JavaScript?
I've had tons of trouble with TSD files not being correct for various libraries and most of the time confused about how I'm actually supposed to import them.
Could you please give a specific example and some code from your attempts?
the biggest problem with javascript and why it's so confusing for most people is it's omnidirectionalism. it inherits best _and_ worst parts of every other technology it has to be in contact with. - DOM nodes (objects, but not really, with an interface different to what will be output as html) - CSS (a string, but acly an object, but not 100%) - supprt for ECMAscript 1/2/3 syntax (with it's bugs quircks and platform/browser specific exeptions for full backwards compatibility) - URLs and RestAPIs ( http methods, http codes, ?param or ?param=yes ) - app cache, localStorage or sessions? what about installing SSL certificates? - AJAX/XHR ( JSON.parse/.stringify response/request body or not? what if JSON parser is already used in my nodejs/express app? ) - how many layers of frameworks can i contain in 1MB download - how long will it take for the market share of older MSIE to become non-relevant? - unicode letters in regular expressions? - should i regularity update `node_modules` to have latest security fixes for potential bugs or not update them to avoid potential security vulnerabilities due to hijacked dependencies? - if any kind of run time error occurs -- should i blame my browser, my proxy, my OS, my modem, my ISP, my server OS, my hosting provider, my country-wide bans on sites and IPs, or myself b/c i forgot that automatic semicolon insertion won't trigger if the line starts with a square bracket and my array of disallowed passwords became an index of document.querySelectorAll(\`input[name="submit\_param\_${Param}"]:not(.hidden)\`)? - ...
The main thing that may help save typescript is that you can opt out of nearly everything that makes it typescript. Long term, it seems all javascript syntax forks die off as they are out-competed by the base language.
Not to mention deprecation of API X, and you should use Y now, but Y isn't fully implemented on every browser or even worse, the specifications aren't even considered final...
&gt; - Are there scenarios where you'd say it's fine to use Lodash? When it increases, rather than decreases, the readability of your code. There are plenty of examples of this. &gt; - If no: what's your recommended way of dealing with situations when you need the functions deepEquals or merge you've mentioned? We're trying to migrate to Ramda, not "do everything yourself" like I may have implied. lol.
If I'm understanding correctly, you could do something simple like convert to/from JSON when interacting with the storage: class StorageManager { constructor(storage) { this.storage = storage; } getItem(key, defaultValue) { return this.storage.getItem(key) || defaultValue; } setItem(key, string) { try { this.storage.setItem(key, string); return true; } catch (e) { console.error(e); return false; } } removeItem(key) { this.storage.removeItem(key); } getJSON(key, defaultValue) { let result = null; try { result = JSON.parse(this.storage.getItem(key)); } catch (e) { console.error(e); } return result !== null ? result : defaultValue; } setJSON(key, object) { return this.setItem(key, JSON.stringify(object)); } } const myStorage = new StorageManager(localStorage); // or const myStorage = new StorageManager(sessionStorage); myStorage.setJSON('myArray', [1, 2, 3]); console.log(myStorage.getJSON('myArray')[2]);
Are you implying that generators aren't "vanilla?" Even Observables are going to be vanilla in ES7.
This drives me nuts.
I've used AngularJS (1.5) for a few years and then VueJs. Highly recommend it! Felt like a simpler but powerful version of Angular.
I’m realy used to angular syntax, will it be easy to to the migration? Like form vaildation, debouce time and js router?
I think I understand what you mean the array with the 2 million intergers takes up 61MBIts of ram. And when you say for every call I understand it as if I run the program twice at the same time it will take up 122 Mbits. 
Nice work.
But wait, as you were writing that, someone forked the library and implemented X, Y and a subset of Z! It's out on NPM right now!
This is what I needed - thank you so much! I have one more question (newbie here). If I wanted to have a function that does 3 operations on a array, how could I correctly pass the key as a parameter? Something like this: function passToArray (myArray, obj, key?) { // gets the array myArray.push(obj); // sets the array } Thank you so much for your help!
I think most concepts translate well. Check out the docs, the guide and API references are really well done. HUGE difference from AngularJS. There's maybe two form validation libraries out there. Debounce, I think was pulled out in Vue 2.0 and requires a 3rd party directive. Router I haven't used but I'm sure is similar to Angular's. Over all the syntax is, in my opinion, more elegant and powerful.
"almost always absolutely, 100%"? I've developed an application that's being used inside our company that loads and displays a simple list of phone numbers. Until it was in production I didn't know how many entries there will be. Now it takes about 3 seconds just to display the list because the list is so big. Now you say a difference in speed of up to 400% is pointless? Under these circumstances I just can't believe you, sorry. And I'm pretty sure I can rearrange my version of the code so it's more readable. `list.map(iter)` and `map(iter, list)` aren't that different after all.
Yep that's the biggest hurdle, it's easy to get type definitions but you're kinda fucked when they are out of date or nonexistant
A speed difference of 400% should nearly always be negligible/imperceptible in real terms when writing client-side JS for things like web pages and web apps. If it’s not then you’ve either hit the 0.1% edge case where you need to optimise or, way more likely you’re solving the problem the wrong way. 
It depends. 400% of 20ms isn't noticable, that's true. 400% of 200ms (because you map, filter and group a list with let's say 100.000 entries) on the other hand *is*.
Sure, but at that point you should probably question why you’re doing that on the client. There is almost certainly no good reason to be processing 100,000 of anything outside of a game engine.
So if the steps you want to accomplish are 1. Get array at `key` as `myArray` 2. Push `obj` to `myArray` 3. Store `myArray` at `key` You could do function pushToArray(key, obj) { const myArray = myStorage.getJSON(key); myArray.push(obj); myStorage.setJSON(key, myArray); } Or if you already have the array loaded function pushToArrayAndSave(array, obj, key) { array.push(obj); myStorage.setJSON(key, array); } 
I mean you can still fall back to just using the library with a type of any. Obviously you lose all typing hints and tooling support but it's still useable as a fallback 
I'm not so sure sometimes...
In this particular case: Pulling data from the original source takes even more time (I have no idea why, I don't have enough insight). This would have been a little more complex. But I do know that I need to split up the view somehow. Maybe grouped by letter. Another thing is an application that works locally only. Using Electron or localStorage or the File API in the browser. You could open a file that's just huge. There you can't really control how much data you want to read. If you open a huge JSON file it's an all or nothing.
Lol I'm doing the opposite. Edit: Angular4
learn how to write modular/reusable js then learn how to test it
Again, there is no good reason to have 100,000 items in a single view that need to be manipulated, that’s just dumb and terrible UX. If the data comes from a remote DB then limit your queries to request a sensible number of items and do the heavy lifting in SQL. If you’re dealing with a local DB, well the same thing applies. This is especially important as all the time spent crunching huge objects locks up the main thread and your page will be completely unresponsive in the meantime (unless you’re doing fancy stuff with web workers but you better have a damn good reason in that case). You need to think a bit more broadly - I believe this may be why you might have come across as more of a junior elsewhere in this thread.
What helped me understand the full cycle of oauth was to build a resource server and then a client that uses it, from scratch. Stephen Grider has a udemy course titled 'Advanced react &amp; redux" that has an entire section on oauth (both server and client, over 60 videos - about 5 minutes each video) that goes into great detail of both sides. Might want to peep it
I do angular 2 at work, it is great for teams with typescript, with for solo project not that great
It sounds to me like you just need some more experience building things. Most of what you say you're having trouble with can be remedied by getting hands-on experience with it, and applying the knowledge you've gained. If you're not sure what to work on, I would recommend checking out [JavaScript 30 by Wes Bos](https://javascript30.com/). It's a 30 day coding challenge (that theoretically you could do in a weekend if you wanted) that explores vanilla JavaScript by literally just building cool stuff. It's super fun, and while I haven't actually finished it yet (distracted by other material), I found that it was really fun and that Wes' teaching style really meshes well with me (and I'm not the only one). Check it out! It's totally free too, so you don't have to worry about shelling out $60-$120. 
I'm not talking about 100,000 items in a view but in memory. There are cases where you just can't read only a part of the data. (Talking about "thinking more broadly") To cut the long story short: I'm displaying too much data because I didn't expect it to be that much. I need to change that, I know. And I have already some ideas. I don't think there's much more to it right now...
To go along with another comment, the only way to actually become confident with any skill like programming is to dive in, butt up against those challenges you mentioned and then overcome them (even if it's painful). I've always had that experience about anything complex. Tutorials will only get you so far! Most straightforward way is to set a goal like "I'm going to build something that does XYZ" where XYZ is something you think you'd enjoy building (even if it exists elsewhere).
I'm using Angular for solo project and it's gone well for me so far.
https://github.com/seanseany/blockchain.js/ Blockchain.js is a gentle introduction to those who want to learn about how blockchains work, and why decentralized networks are useful.
I've been using X for a [team/solo] project and prefer it over Y because of Z.
You can also easily, most of the time, extend it to fix any problems. Also the tsd files are open source so pr's are welcome.
Angular 1 yes but in my opinion ng2 us much more develloped for big project
Yeah I use Aurelia and ES6 for solo projects. Its just Angular without boilerplate and configuration
Is this 'lol' because its using events instead of passing props down like a sane "React" way?
Then why use
It's one of the few marked as deprecated for a good reason. Browser vendors are looking into removing it. AppCache is a very tricky system to do right with numerous edge cases. The removal it's just mumblings afaik. But, if mumbles exist about actually removing a feature from the web it should be thought very careful about before using it. Service workers while more complex to setup, although not that bad, provide much better control to developers. There is no reason to not use them as an enhancement where available when it makes sense to go offline.
I feel like Typescript is way more popular than Angular 2; I know plenty of people that use Typescript with React (myself included).
it must be satire, right?
After using scala pattern matching a lot on the backend, I _really_ miss it on the front-end. I'd love to be able to use it when matching on redux action types.
I agree, but they really shouldn't deprecate and remove stuff before a complete and stable replacement is available.
Because it's likely just a small part of your codebase. Hopefully anyway, since it will also be the most error-prone part.
You might want to take a look at Stack Overflow Trends: (http://sotagtrends.com/?tags=[angular,typescript]). Interest in Angular, Typescript are both soaring but Angular about twice as fast. There are also six times as many Angular jobs as Typescript jobs on Indeed (UK). Of course, many of those Angular jobs are probably for AngularJS, but those teams will most likely migrate to Typescript sooner or later. 
`npm install @types/yourlibrary` for anything remotely popular. For obscure libraries, you may have to write your own (and preferably share by sending a PR to @types).
My point was, you're not alone. It doesn't really matter whether you're on a big project, small project, open or closed source, whatever... we as an industry still haven't figured out how to produce useful documentation.
That was fantastic I didn't even know three.js was capable of such a thing
We include lots of libraries so imagine dealing with outdated typings defs for 80% of your third-party code. If that means omitting types from those libraries, then why use it? Your own APIs plus flow seems to do just fine
The main thing that made me appreciate RxJS was attempting to engineer a very interactive reactive app concept in Java, if anything that experience was my "object lesson in terrible ... software". When I finally discovered RxJS behind the obscuring veil of CycleJS, I knew the API to match the demands of the software I had in mind had arrived. Knowing this beyond a shadow of a doubt, I set out to learn RxJS. I found the documentation on the RxJS site to be damn near useless so I created my own files, including every example I could find, be it from RxJS v4 or v5. Its given me a great overview and plenty to reference. Presently, I'm working out my own larger reactive patterns (certainly not based on Redux, even though there is a lack of useful patterns in the RxJS docs for the most part). I'm under no deadline to complete the task, which I'm glad for because RxJS is still improving on several levels.
I am myself learning Go at the moment. Perhaps I possess slightly different motivations. I like to write programs for the sake of writing them--for the pure sake of discovering different ways of achieving the same goal, to experience different paradigms, different techniques and methods of problem solving. Javascript is my bread and butter because for all its deficiencies, I love the web. But I don't think that should stop anyone from exploring other languages and paradigms. In that sense I could probably build the same thing with 5 different languages and still have a great time doing it. 
https://github.com/americanexpress/jest-image-snapshot For those using jest to test your web applications jest-image-snapshot provides a matcher that behaves EXACTLY like jest snapshots but it diffs actual images. This allows for quick visual regression tests to be written! https://codeburst.io/automatic-visual-regression-testing-23cc06471dd
I'm not sure that if I was presented with the opportunity to spend my time migrating to Typescript or migrating off Angular 1 (which is probably what all the jobs actually are for) I would go with Typescript...
Yeah - I shall give it a go.
80%? More like one or two niche libs in my experience but I suppose YMMV. There's also all your application code...
You know, the biggest complaint I have about typescript is that it seems to think in the "classes as types" paradigm that comes from c# and Java type world. I really love the way Scala and Haskell allow types to be created from type classes or predicate functions, and how languages like Agda and Idris allow for dependent types. These kinds of types actually provide a special kind of freedom by being really expressive. I find typescript to lack that expressitivity. It's also a real shame about the type erasure which means you aren't protected from bad behavior at run time. Otherwise, it's a fine way to introduce types to a community of developers who are used to dynamic languages. 
Thanks for the response. As I said the binding does not change (one could call that immutable). But typically immutability does not refer to the binding, but the object/primitive of the variable. JS has immutable (primitives) and mutable (array, object) types. The value of a mutable variable may change ([2, 3] does not have the same value as [2]). I've never heard of referring to the binding as immutable. Am open to pull requests correcting, but would appreciate a reference that refutes what I wrote. 
Thanks for the suggestions. Feel free to submit PR's for improvements. It is not intended to show examples for every method, but if there are very common ones that should have examples, I'm open to those changes.
Awesome. I hope it is useful for you!
Seems a lot of ES6 folks tend to favor this nowadays.
Author here. Thanks for the feedback. I have already gotten some PR's, which is much appreciated.
Lin Clark is a fantastic person, from what I can tell. I have a great admiration for individuals who strive to clarify complexity. It doesn't have to be "layman's" explanations... engineers / professionals especially benefit from accurate simplifications. 
I really liked her [cartoon intro to React Fiber](https://www.youtube.com/watch?v=ZCuYPiUIONs).
An excellent illustration of pointers, contents and constants. 
i still get confused with OOP part of it....reading old books &amp; new articles confuses more....
[Oh boy it's finally my time to shine as an engineer!](https://www.npmjs.com/package/blodash)
You're welcome to keep it the way it is, I just don't like it because it's misleading and can cause further confusion. The best example I can give is with the following code: const myArr = [2,3]; function logIt( arr ){ console.log( myArr ); console.log( '===' ); arr.pop(); console.log( arr ); console.log( arr === myArr ); } logIt( myArr ); // logs `[2,3]` // logs `===` // logs `[2]` // logs `true` When using the `===` operator, you're comparing "values". Even though the array has been mutated, the "value" of the variables is the same, because both variables contain the same reference pointer to the same (albeit altered) array. We're basically arguing semantics here with regard to what "value" actually means. I would just rather live in a world where a `const` is always immutable and strict equality makes sense.
The house analogy? I like to use it a lot because it's a real world example of what's going on inside computers. It's even analogous to type systems because you have different types of houses. If you're going to put a family in a house, you'd better specify that it's bigger than a 1 bedroom. Etc, etc.
Mm, I guess I'm not sure what you mean specifically. We tried to model the type system after the way JavaScript works at runtime, and in a way that types don't impact emit (which I understand has tradeoffs). I don't think classes are the primary form of declaring types. In the realm of object types, you can use interfaces and aliases to type literals as well. There are also other types such as unions, interesctions, and index type queries. By the way, could you elaborate on the portion about creating types from predicate functions?
Yes, that's it. *But* javascript doesn't have true CPU parallelism (multi-threading). So if you have two function calls they cannot *run* at the same time (not considering web workers here ). They go in the Event loop, which executes functions sequentially, mostly like *for* loop does. The thing is when you have multiple function calls the garbage collector may have not yet freed the resources (2mil integer array) from the function calls before, so the memory will pile up. That's what I've meant.
Something I created to help transition through a lot of beginner to intermediate problems is language forms. My coworkers have used the JS forms to quickly spin up in Javascript and be quite effective. This will introduce everything from the basics you have already covered, through testing, refactoring, writing tests for both simple and complex cases. You will also be exposed to functional concepts, building rich objects, testing async code, mocking and stubbing for tests and more. It has all been tested by real people and I've done a lot of refining, so it should actually provide you a reasonably well-leveled development path. Let me know, if you try it, what you think: https://github.com/cmstead/jsLearnerForms
Definitely! Types, in their purest form, are really propositions. In other words, a value either is, or is not a thing. A way to think about this is, a number is an integer if and only if it is discrete (i.e. It is not infinite) and it is rational, and any fraction representation can be reduced to a number with no fractional component. We could express this as: Const isInt = (value) =&gt; typeof value === 'number' &amp;&amp; Math.floor(value) === value &amp;&amp; !Number.isNaN(value) &amp;&amp; value !== Infinity; That's quite a lot to fiddle with, but it says a lot about the value we are testing. My library Signet actually has some of this stuff built in and you can say things like signet.isTypeOf('int')(value), which is a built in type. It would be really useful if we could say things like `range start &lt; end :: (start:int, end:int, increment = 1:leftBoundedInt&lt;1&gt;): monotoneIncreasingSeq&lt;int&gt;` where we could ask questions like "what is a left bounded int," or "is start less than end, " or even "are our array values actually monotone increasing," right in our type signatures and get a useful error when things go wrong. These kinds of types reach beyond what simple interface and class-based types provide for us. When we can start talking about these kinds of rich types, we are actually less constrained and more informed. I hope this is the example you were looking for. 
Nice work over all but I do have some points you might want to consider: * You are mentioning a lot of features which predate ES6 so perhaps a better title would be "Tiny Modern JavaScript Notebook" * **undefined** is also a falsy value * **Symbol** is not really a constructor (it cannot be used with *new*) * **foreach** doesn't exist on Arrays. The method is called **forEach** * Object spread is not an ES6 feature. It is currently stage 3 (https://github.com/tc39/proposal-object-rest-spread) * "Return float if str can be converted to an integer, else NaN" for parseInt. You probably meant to write integer instead of float here * typeof is an operator not a function. *typeof count === 'object'* instead of *typeof(count) === 'object'* * "template strings" are now called "template literals" * Since you are using ES6 you are probably better off using *includes* instead of *indexOf* to find values in arrays. The return value is more intuitive and works with NaN I hope my comments help you improve your work.
 [tc39/proposal-object-rest-spread](https://github.com/tc39/proposal-object-rest-spread) &gt; *Description*: Rest/Spread Properties for ECMAScript &gt; *Stars*: 792 &gt; *Forks*: 41 &gt; [Issues](https://github.com/tc39/proposal-object-rest-spread/issues) | [Pull Requests](https://github.com/tc39/proposal-object-rest-spread/pulls) *** ^(This is Earth radio, and now here's human music ♫) ^[Source](https://github.com/anaskhan96/github-stats-bot) ^| ^[PMme](https://np.reddit.com/message/compose?to=github-stats-bot)
Redux saga is not just generators. As redux observable is not just observables, they are libraries built around those features, for example, redux saga provides a complete abstraction with commands like put and call. With vanilla middleware I mean no library and writing the store =&gt; next =&gt; action function yourself. In there you can ofcourse use Observables, promises and async await. Observables in Javascript are just a proposal btw. and not even in ES8 (ES2017) which was just released.
TypeScript imports are... weird, especially if you're used to using Babel; `import * as foo from 'foo'` everywhere instead of import interop which allows you to treat a `module.exports` like an `export default`. Installing a type definition can also change how you have to import code as well. Most type definitions I install for npm modules require me to change imports to an even weirder `import foo = require('foo')` (what's *that* a subset of?). I assume it works really well if you're in a TypeScripty part of the ecosystem where everyone and the modules they depend on use it, but I ended up giving up on third-party type definitions for a Node.js project as they were too much hassle in the end, with working, tested code being flagged up as invalid with spurious type errors.
todays state of JS is basically "assembly of the web", and any project more complex than a single 200 LOC file should be written in some higher-order language (like Typescript, Clojure, Kotlin, or Red), and trans-/compiled to WebAssembly, just to avoid dealing with multiparadigm monstrosity it have katamari'ed to become. 
I had this exact opportunity, and I chose to migrate the medium/large angular 1 application I work on to TS first. For the first phase I simply described the existing codebase using namespaces. I also used the Typewriter extension for VS (project uses .NET webApi) to generate both the declarations for our server-side models and actual angularjs services to handle all communication with API endpoints. Having the frontend and backend feel like they all exist in the same universe with no manual maintenance (or opportunity for mistakes) in the glue code between these layers is more useful to me as a developer than being on the absolute bleeding edge of js frameworks
If you're converting a codebase to JS to TS and can't find type declarations for a library, it's usually pretty fast/easy to just implement your own declarations - you only need to declare the parts of the lib your code touches as you come across usages while converting files. And then if someone eventually bothers to write declarations for the whole thing, you can just use those instead
Awesome explantation! Kudos
The vendors thinking to remove it, do have SW in place or will have it complete very soon. So, that's all fine.
I'm not actually sure native Observables are going to be worthwhile. It seems unlikely they'll contain enough functionality to be useful (compared to Rx). 
&gt; the views sometimes needed to update models based on user input Otherwise known as exactly the thing MVC says *not* to do. Remember Flux was advertised as a "replacement" for MVC because MVC couldn't "scale to Facebook's needs". And then it turns out they made elementary mistakes that weren't MVC, then reinvented MVC and called it "Flux". And here we are reading an article about Flux, aka "MVC, but with different names for everything". - Action = Event - Dispatcher = Controller - Store = Model - View = View
Classes create types, but there are also interfaces, unions, intersections and aliases that create types. You don't describe how adding classes to the latter group somehow "limits expressiveness".
This is a hard subject because JavaScript doesn't provide much help in this regard (sub-typing) and you are stuck with a single paradigm approach in a multi-paradigm language. I think TypeScript provides the cleanest approach, via type generics and type classes, considering what it must work from. The challenge for me is that I loathe inheritance in this language. I personally find it unnecessary, slower, and more tedious to maintain. I also believe inheritance models are a feature secondarily added on top of the language's scope model. This said if I can program without inheritance, in this language, my code tends to be dramatically smaller and execute more predictably at cost to some organizational clarity. While there is clear organizational value in sub-types and TypeScript achieves the sub-type concept in possibly the best way for this language the concept still isn't for me. This isn't a criticism of TypeScript but rather a criticism of JavaScript that TypeScript must contend with.
After you complete some tutorials the next step is: **write code**. I recommend creating an ambitious application and simply pushing through the challenges.
You seem to be talking about dependent types, which would require runtime wrapping and checks. That's very different from the problem TypeScript solves, which is allowing IDEs to see the implied static contracts in code that already exist at runtime, and the resulting from this error-checking, refactoring, auto-complete etc. before the script has to run. TypeScript doesn't stop you from putting more exotic features on top if you fancy them. But those exotic features are simply not of interest to the majority of JS users.
I appreciate the civil dialog. === does not really work with arrays. You will find that even an empty array is not === to another empty array. You need to loop over the content of the arrays in parallel to check if they are equal. Perhaps we are getting hung up on the definition of value.
Awesome feedback. I will file a bug with these issues and address them! Thanks
Yeah, I actually don't know the spec in detail. It might be that libraries will then be needed to add functionalities.
Thanks. WebGL is so powerful, three.js just makes it a bit more approachable.
Andre Staltz made a similar claim a while ago, interesting debate btw: https://twitter.com/andrestaltz/status/702177514320486400 From working with MVC and MVVM in the past i agree with Dan. Flux evolved through the functional props-down paradigm. The model doesn't mutate, the view doesn't resemble a traditional controller at all, it merely binds to a slice of data while picking actions to feed back user input, which then result in props again. Apps are structured very differently than what was before Flux, as well as the way they work and handle data-flow.
&gt; The model doesn't mutate, the view doesn't resemble a traditional controller at all, it merely binds to a slice of data while picking actions to feed back user input, which then result in props again. Store = Model. Both mutate. What Stores do is mostly a way to emulate "copy on write" mutations in JavaScript, as it doesn't natively support such value type semantics. And View != Controller, so of course a View wouldn't resemble a Controller... It resembles a View instead... A MVC View also "binds to a slice of data" and it produces events (i.e. actions) from user input. No difference at all. If you disentangle the words you use to describe Flux and focus on the structure, it's the same as classic MVC, for everything but the subtlest details, which always vary depending on the language, requirements and author's stylistic preferences. The largest difference between Flux and MVC is names. Facebook changes some names, and suddenly the average developer loses the ability to compare two things and calls them two completely different things... That's curious to me and I've seen it a lot in conversations about architecture.
This is really well put together, now I wish someone would write an article like this for Redux. I know a lot of the same principles apply, but I'm never going to touch flux whereas I use redux every day at work and would still enjoy having a better understanding of it like this article presents. 
I am talking about both dependent types and types as propositions. These were both reflected in my original comment. Types as propositions can be seen in a language like Scala and can be verified statically. Some dependent types can, theoretically, be statically checked as well. There is a full branch of computer science around verification and correctness. Ultimately, though, what was the goal of typescript if not to provide typing in order to prove correctness while developing? 
A class or interface is only one kind of type and does, in fact, limit the expressiveness of your types since you are not fully able to talk about what the type of your value should be. This means you have to jump through extra hoops to ensure values conform to class types by manually boxing and unboxing which adds noise to your program and reduces the intent per line. 
&gt; Types as propositions can be seen in a language like Scala and can be verified statically. Some dependent types can, theoretically, be statically checked as well. The conversation ended up very theoretical all of a sudden. If you have concrete proposals for improvement, which are statically verifiable, TypeScript is a platform that evolves *very very quickly* and the community is welcoming any useful and implementable ideas that improve the ability of the language to express contracts between pieces of code. The overall impression I get so far is you don't have concrete proposals, just the fuzzy desire for TypeScript to be more like Haskell, Scala, and probably throw in some theoretical things from a paper about Curry–Howard correspondence you've read recently. I personally see very few holes remaining from what I'd like a type system for JavaScript to do. Every library under the sun has a TypeScript definition that is quite spot on, even highly overloaded libraries like jQuery. That's a testament to the flexibility and utility of TypeScript's existing type system.
I never experienced the situation you describe. Can you please be more specific? I've the feeling you are misunderstanding some big aspects of the TypeScript type system. Do you have experience with it?
I don't recall Event being a part of MVC.
Might be a silly question, but is the following code functionally equivalent? From the example: else { obj[item.day_string] = [ ...obj[item.day_string], item ] } My code: else { obj[item.day_string].push(item) }
Of course it is. It doesn't have to reified as a distinct object though, that's a matter of style and particular project needs. We're talking about: ctrl.onClick(x, y) vs. ctrl.on(new ClickEvent(x, y)) I've seen both styles in the same project (the latter for complex events, former for simpler ones). It doesn't change anything about the overall architecture. But in MVC when the view receives interaction from the user, the controller receives back calls with information about the interaction. The controller then modifies the models, which triggers updates back at the views. Flux operates on the same basic principle, just change the names.
AFAICT you're wrong - I think you're confused on how interfaces are used in TypeScript. One of the things that I really enjoy about TypeScript (over, say, Java) is the ability to do something like so: interface Foo { a: Int b: { c: Int } } function doFoo(foo: Foo) { return foo.a + foo.b.c; } // this type checks fine doFoo({ a: 1, b: { c: 2 }, d: 9 }); // =&gt; 3 In Java, I would have to create class that implements the Foo interface, then create a new instance of that class. This is where you now get into having to do "boxing and unboxing" of values that are cumbersome and ridiculously verbose. In JavaScript/TypeScript this doesn't make sense, we have the ability to create objects using a lot of other methods than class construction, and interfaces and aliases support that flexibility. It doesn't require you to jump through those hoops at all. EDIT: It would be awesome if TypeScript had something like higher kinded types and other more advanced type system features. I don't think these are unavailable due to inherent flaws in TypeScript's type system, but rather because other features have been prioritized. E.g. I would like to see TypeScript work on being more sound before working on HKT or dependent types.
People should make it clear when they are linking to a (paid) course.
Yes but I would argue that you're stripping it down to a point where of course it's the same. Every way of designing your program will require input handling (controller), data storage (mode) and UI (view) I've never read about an architecture that doesn't have those three features, so saying Flux and MVC are the same because they share those fundamental features is disingenuous. Flux's core is the dispatcher which enforces unidirectional data flow &amp; explicitly prevents data duplication by restricting things like two way binding (a very common idea in MVC.) You could enforce something like that in MVC but it's not required. That's an example of a difference.
My range example is a concrete example. You can declare all of the types I defined and verify them statically, including the ordinal position of the arguments by value. I say "theoretically some dependent types..." because I don't want to make a sweeping generalization like "all dependent types can be checked statically." that kind of statement, since I can't support it, is aching for a counterexample. These kinds of statements are dangerous and if you want to attack an because I'm trying to be judicious with my claims, this likely won't be a fruitful conversation. The push back in getting from you seems as though you are more interested in arguing than hearing. Accusing me of looking for some "fuzzy idea" seems like you're feeling attacked because I stated a tool you like isn't what I'd hoped. A concrete example was provided to another person as soon as they asked, so I'm not sure how I'm being fuzzy or unclear, but I'll accept that it's not satisfying for you. You seem to have landed on a tool that fits your need. If doesn't fit mine. I bring it up because it's useful to hear differing ideas to broaden understanding, plus it seems as though someone involved with typescript development was listening and questioning, so maybe it will spark an idea and the language will incorporate something new, which could be wonderful. I'm not really interested in fighting with you simply because our use cases are different; you know what they say about fighting on the internet.
Almost. The first creates a new array; the second keeps the same array.
Nice. I like it. I've only ever experienced people explicitly typecasting or boxing values in a type-conformant object, so this is definitely nicer. Thanks for sharing that bit of know-how! 
What is the point of creating a new array? Is that some sort of best practice?
I've never seen defined in an MVC application custom events with project-relevant semantics. On the other hand Flux does that a lot.
Suppose you want to modify an array inside a function, but not modify the original. This is when you would want a copy.
immutability -&gt; predictability also in some cases you'd like to diff arrays if they have different reference (with push you keep the original reference) e.g. with React's setState()
Certainly. Here's some more documentation on how TypeScript's type system works in that regard: https://www.typescriptlang.org/docs/handbook/type-compatibility.html
Just report them. Paid services should be going through https://about.reddit.com/advertise/.
Hi /u/oinsanity, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Small nitpick - the call to `.sort()` mutates the array in place, so if `all_times` was an array passed in by reference the caller would end up with a different looking array at the end. Easily fixed by adding a `.slice(0)` call in the chain before `.sort()` - this would create a copy which would then be sorted in place. Regardless, nice use case! Using functional patterns like reduce + map in javascript is really the way to go vs writing out a long procedural function to achieve the same result.
Whether the events should have "project relevant semantics" is very questionable. Especially at the lower levels. I.e. what is more reusable: a drop-down menu emitting a "select my item 4" action, or a drop-down menu emitting a "change file tag color to red" action? In general, the question of how specific the action/event is should be irrelevant as any project of size would have a hierarchical structure (similar to HMVC, aka PAC) where more generic views emit events toward more project specific controller, which act as views towards top-level controllers etc. If views in Flux always emit domain-specific actions, don't be surprised if Facebook engineers come to the conclusion "hey Flux doesn't scale to our needs, and so we invented Vortex" which is hierarchical, as I describe... The only good thing about this whole story is that good ideas will always get reinvented. They can't stay under for too long.
Your first comment was that TypeScript lacks expressiveness because it copies some aspects of Java and C#. Since you made this assertion, I and others have been asking that you clarify your critique, but the responses seem only increasingly esoteric. I still don't understand what your original complaint refers to, and I doubt others do. I'm sorry you feel attacked, but this kind of unclear elitist ivory-tower complaints that TypeScript is not more like something obscure from Haskell is simply not useful. Critique should be concrete and constructive. Which means probably demonstrate what you feel TypeScript lacks with a short code example, and propose a feature that solves or improves the problem.
Maybe I'm misunderstanding you, but in backbone.marionette we'd do stuff like this all the time: // child-view.js this.trigger('my:custom:event', payload) // parent-view.js this.listenTo(childView, 'my:custom:event', this.handlePayload) handlePayload: (payload) =&gt; // do stuff with payload 
That's the point I was making. Since variables store the pointer to an array (and not the array itself), they're only equal if they're pointing to the same array. It makes sense when you think of them as pointers, but that's not a concept that's immediately evident in Javascript because the language takes care of the referencing and dereferencing for you. const arr1 = []; const arr2 = []; console.log( arr1 === arr2 ); // log `false` This is false because they are two different instances of an Array. `arr1` has a pointer with value 11111 (for example) and `arr2` has a pointer with value 22222, which are obviously not equivalent. When you think of them as pointers, it all makes sense. Yes, if you want to compare the contents of an array, you have to perform a deep equality. Same for an object.
No need for emulation, it reduces the store for every change made. The view isn't tied to a controller at all, logic resides in the stores domain. The view in itself is a function, which blurs the lines further. Flux builds on that principle as functions render when props change, so it passes changes down the tree uni-directionally. Flux applications and MVC applications therefore do not resemble one another in the slightest. Although no one is saying basic MVC isn't used in Flux, but in itself it is a unique way of handling ui state that has virtually nothing in common with traditional MVC (as in .net, angular, etc.), which warranted the moniker.
Conveniently, Lin Clark also did write [A Cartoon Guide to Redux](https://code-cartoons.com/a-cartoon-intro-to-redux-3afb775501a6) :) It's excellent as well. You may also be interested in some of the related sections of my [React/Redux links list](https://github.com/markerikson/react-redux-links), particularly the [Redux Architecture and Best Practices](https://github.com/markerikson/react-redux-links/blob/master/redux-architecture.md) and [Redux Tips and Techniques](https://github.com/markerikson/react-redux-links/blob/master/redux-techniques.md) sections. I'll also put in a plug for a couple of my blog series: the ["Practical Redux"](http://blog.isquaredsoftware.com/series/practical-redux/) series, where I demonstrate a variety of useful Redux techniques and concepts in the context of a sample application, and the ["Idiomatic Redux"](http://blog.isquaredsoftware.com/series/idiomatic-redux/) series, where I discuss a lot of the theory and usage of Redux and give my opinions on good practices to follow.
&gt; It reduces the store for every change made, it doesn't emulate anything. If you have used a language with real copy-on-write value types, like Swift, you'd have a different perspective on what's happening. &gt; The view isn't tied to a controller similar to a .net controller, - In Flux, the view produces an action which is sent to a dispatcher. - In MVC, the view produces an event (or calls an event method/callback) on the controller. These actions are identical in terms of architecture. &gt; mostly the logic is in the stores domain. - In Flux, the logic in the stores. - In MVC, the logic is in the models. And Stores = Models, as I noted above. &gt; What makes Flux different from traditional MVC is prop passing and uni-directional flow, both inherited from the view being a function itself which blurs the lines further. MVC has uni-directional flow. View -&gt; Event -&gt; Controller -&gt; Model -&gt; View &gt; Flux applications and MVC applications do not resemble one another in the slightest. I understand you believe that, but you keep describing MVC in attempt to show me how Flux is different.
Interesting but in this particular case I would keep your original array and create a function that when called applies a .filter("day").sort(). IMHO it is neater than creating a new data structure.
Have used this pattern and I like it. One thing worth noting is that splitting minifying, packing, src copying into separate tasks and then just making a build script that runs them all keeps things a bit more sane. Also worth noting that you can access things like the package name via variables in the scripts, eg: http://ianmcnally.me/blog/2016/2/4/variables-in-npm-scripts
I "use npm as a build tool", but it's not really that much of a build tool. It's really just a shell script put in the package.json. Everyone likes talking about how it killed gulp like gulp killed grunt, but when I do use gulp (which I do on occasion), I call it from npm scripts. They're not really "competitors".
yep, that's very useful 
It looks like you can't report stuff anymore... you get this Facebook like window where you it offers to unsubscribe you from the sub
As was pretty clear from the Twitter exchange above, no one argues against Flux using basic MVC tenents. That is not what people refer to when they mention MVC as in how applications were made in .Net/Angular/etc. With your line of reasoning even the imperative layout-inflater (win32-api, android, jquery, etc.) is MVC, at which point we're not talking about structuring applications any longer but semantics. @connect((state, props) =&gt; ({ item: state.elements[props.id] }), { update }) class DropdownElement extends Component { render() { const { item, style, id, update } = this.props; return ( &lt;Select value={item.value} onChange={value =&gt; update(id, { value })}&gt; {item.items.map(item =&gt; &lt;Select.Option key={item} value={item} /&gt;)} &lt;/Select&gt; ) } } ... &lt;DropdownElement id={4} /&gt; The view and the "controller" are one and the same, only that the controller does not meddle in application logic at all but only in presentational logic. It does dispatch actions, which then bubble down as properties again should the model reduce. In traditional MVC a template would have a controller counterpart that mutates the model, usually its own, the resulting events can go both ways, uni-directional flow is merely optional. 
There are 13 lowercase letters that do not extend vertically above the median or below the baseline. This module serves no practical purpose other than to encode to these 13 letters.
AWESOME! Thanks for all these links :) Gonna be great to read up on when I have some downtime at work tomorrow.
&gt; In traditional MVC a template would have a controller counterpart that mutates the model, usually its own, the resulting events can go both ways, uni-directional flow is merely optional. What does that even mean "events can go both ways". Which events go which both ways?
Marry me.
&gt; Whether the events should have "project relevant semantics" is very questionable. Especially at the lower levels. It's exactly my point. Events are related to the view. Actions are related to the model. They are not the same thing and are not used the same way; ergo, Flux and MVC are not the same.
People take immutability sometimes to extremes just to act like purists for one reason or the other. Yes immutability is a good thing, but doesn't benefit at all in this simple example. So, yes, your code is equivalent and more efficient. 
Can also be used to turn an array into a regular object, with whatever key might make sense for you. E.g. if you had an array of objects with ID properties, and you wanted to be able to access an object by its ID, you could turn the array into a hash by id. objectsById = arrayOfObjects.reduce(function (acc, object) { acc[object.id] = object; return acc; }, {});
Unless I'm missing something, isn't that a bad use of the reduce function? The same behaviour could be done with a simple forEach loop: all_times.sort((a, b) =&gt; a.time_block &gt; b.time_block ? 1 : -1); let new_times = {}; all_times.forEach((item) =&gt; { if (!new_times [item.day_string]) { new_times [item.day_string] = [item] } else { new_times [item.day_string] = [ ...new_times [item.day_string], item ] } }); (I also made the sort action a single statement, to emphasis it is actually modifying the all_times variable) The whole point of a reduce (or foldl) function is to repeatedly create a new result using the previous result and the next value. If the result is always the same it doesn't add any value over a forEach loop, but is more complicated to reason about.
Just use promises.
I do this all the time even with typescript + react, with auto reloaders, a local web server and everything all controlled from the package file. Works great.
Then what about: ``` else { obj[item.day_string] = obj[item.day_string].concat(item); } ```
I don't get why use async iif, when you can just make them regular functions and use promise all. I rather use promise all than iif
What author thinks: "I need _reduce_ function". What author needs: _groupBy_ in standard library. Because it more clearly express his intention. Such code is a reason why I always recommend to use lodash. If you are concerned about file size, you can use either minimal "core" build (4kB) or use individual methods with package `lodash-es` and tree shaking.
its look nice, bit its unreadable for me. I still use Gulp, grunt : and i think its better way, becouse you have elastic JS (not bash, cmd, shell way) project ;)
I think a lot of people (myself included) like to do it in a lot of places, even when unnecessary, so that coworkers looking for examples won't think mutation is acceptable.
What's wrong with libraries maintained by Facebook or Microsoft? As long as they're properly licensed you're fine. Either way just use native promises.
Clean answer. Only time I might not do this is if you have a very large data structure in which calling the function each time might be too expensive. Obviously not a concern for this example but something to consider nonetheless.
Have your models (store) respond to those events (actions) with functional handlers (reducers) that update its attributes (state), and GASP! you've invented marionux?
You could also contact the API publisher with this question. Hopefully they'll add it to the documentation
So what? That's just a fold operation?
That should be the same. It doesn't use new ES6 notation, so it is therefore a strictly inferior way. /s
The very fact that you say things like "elitist ivory tower" is precisely why I feel this conversation is not going to be fruitful. At no point did I claim your use or approach was impure, invalid or otherwise inferior. I actually conceded that we are, likely, starting from different use cases, and if the tool works for you in not one to criticize you. IMHO this is not an elitist or ivory tower superiority argument, so your ad hominem rhetoric is uncalled for. If you go in believing someone is being elitist or, when an example is provided (i.e. the range function signature I provided for another user, which I provided some insight around implementation and result) is esoteric without providing your reasoning for why it isn't a useful case is precisely why this seems like an attack.
I use `npm-run-all`, it looks nicer than `concurrently`. Eg this: "start": "concurrently -k \"npm run dev\" \"npm run watch-css\"" becomes: "start": "npm-run-all -p dev watch-css" You can also use it to run scripts in sequence: "build": "npm-run-all build-js build-css" Or even use the shorthand versions: "start": "run-p dev watch-css" "build": "run-s build-js build-css" 
If you're keen to make it a one-liner: const objectsBtId = arrayOfObjects.reduce((acc, obj) =&gt; ({ ...acc, [obj.id]: obj }), {})
To each their own. One thing that is nice with npm scripts is you can still easily run any arbitrary javascript file or even call up the gulp or grunt CLIs so you can use npm scripts as a wrapper for your existing build scripts. This means you can use npm scripts to run the locally installed gulp or grunt cli binaries in the project's `node_modules`, rather than requiring developers to install them globally on their system. This makes building and running the project as simple as `npm install &amp;&amp; npm run dev`, no matter what underlying tools you use in the build stages.
Awesome! I look forward to your feedback and best of luck on your learning journey! 
Beat me to saying it. I've very rarely found a situation where `reduce` felt like the simplest or most readable solution, compared to either a lodash method or just some other combination of native tools.
Yeah. `reduce` and `fold` are synonyms.
I like this, thank you for sharing.
The article's `sort` callback is invalid: all_times.sort( ( a, b ) =&gt; a.time_block &gt; b.time_block ? 1 : -1 ) A sort callback can't just return `1` or `-1`, or the similar error I've seen of returning `true` or `false` (or `1` or `0`). A sort callback _must_ distinguish between all three cases: greater, less than, or equal, and return a positive, negative, or zero value respectively. This is a common mistake. I recall one lengthy discussion - maybe here on Reddit or else on Stack Overflow - with someone who insisted that the `sort` methods in various browsers were fickle and inconsistent and needed a lot of "wrangling", as he put it. I was puzzled because I've never once had any issue with `sort` in any browser or JavaScript environment, and I've used a lot of different kinds of sort callback functions. Eventually in the discussion it came out that he was in the habit of writing sort functions like this: array.sort( function( a, b ) { return a &gt; b; } ); When I explained that this was an inconsistent compare function and it really needed to handle all three cases and not just two, he said I was just being fussy. I don't know if he ever caught on that these faulty compare functions were the source of his troubles. For non-numeric values, a conditional operator can be handy: array.sort( function( a, b ) { return a &gt; b ? 1 : a &lt; b ? -1 : 0; } ); For numeric values like the `time_block` property in the article, it's easier and faster to just subtract the values: all_times.sort( ( a, b ) =&gt; a.time_block - b.time_block ); Note that the results for greater and less then don't have to be `1` and `-1`; _any_ positive and negative values are valid (along with `0` for equal). I also agree with the other comments that chaining the `.sort()` call the way it's done in the article is misleading, and it should either be broken out as a separate statement to make it clear that it mutates the original array, or `.slice()` should be done first to get a copy of the array.
In this case it doesn't matter at all, because the array in question is created by us inside the reducer. No other code can possibly hold a reference to it. But in many cases your function isn't working with an array that it created; it's working with one passed in as a parameter. In those cases it absolutely is best practice (I'd argue that it's required) to create a new array rather than modify the existing one. This is because when you receive an array (or any other object) as a parameter, you actually receive a reference to the array; any operation that modifies the array will modify the array the caller has too. So it's like this: * Could any other code possibly hold a reference to the object I wish to modify? * Yes: create a new object with the desired modification applied to it * No (i.e. you are modifying an object you just created): you can directly modify the object if you wish 
Sure. I do agree that it is better to be more delcarative but most of those utility functions are probably using reduce under the hood.
Yes, that's also what I do. If you do this it doesn't matter what build tool you're using, the command will always be `npm run build` (or `watch` or whatever).
Why not `(npm run a &amp;); (npm run b &amp;); (npm run c &amp;)`? (brackets might be optional, not 100% sure)
hiya! author of the article here thank you for the explanation of `sort` - All of the points of discussion in this thread have been super helpful. Still trying to get the hang of functional programming!
i'll definitely check it out! Thanks for the recommendation 
I use reduce to sum or multiply every element in a array. Am I using it right.
&gt; No (i.e. you are modifying an object you just created): you can directly modify the object if you wish Super helpful, thank you! Sometimes I am unclear on when I can mutate 
Probably yes. My rule of thumb is "is it one-liner". If it is, I go with _reduce_. If it isn't, I think twice. 
Yea. One guideline I've found useful for when reduce is being used correctly is if the output does not grow when the input array grows. 
I haven't tried that syntax before, but in my experience on Windows `&amp;` won't run things in parallel. Plus the syntax isn't as readable. `npm-run-all` lets you eliminate the redundant `npm run`s and the extra punctuation.
Do you have an idea how to use reduce to find the biggest element in an array of integers I think I once saw reduce being used but can't replicate it, or find where I saw it.
`arr.reduce((a,b)=&gt;Math.max(a,b), -Infinity)` Though, easier: `Math.max(...arr)`.
same for me npm-run-all is much better
&gt; A sort callback _must_ distinguish between all three cases That's a bit too dogmatic. OP's callback is not incorrect, it's just an unstable sort. (Elements that compare equal could be shuffled with respect to each other in their original order.) It rarely matters whether a sorting is stable or not, because one or more of (a) scalar members, can't tell one `42` from another, (b) ties are not possible, (c) relative ordering of ties makes no semantic difference, (d) original orderings are arbitrary, or (e) ties are broken by comparing another facet of the data. EDIT: (f) standard does not guarantee stable sorting under any conditions, so return values for equal elements are meaningless so long as they are consistent. Returning a boolean is a worse case because that limits you to a vocabulary of "same" or "second is higher", which isn't enough to arrive at a sensible ordering except by happy accident. EDIT 2: Ehh, wrong. Sort order is not guaranteed if f(a,a) != 0. Sorry
npm-run-all works on all the platforms 
Yes, you should be able to load them from a CDN as a `&lt;script&gt;` tag in a page. For React, see https://facebook.github.io/react/docs/installation.html#using-a-cdn . Also, my [React/Redux links list](https://github.com/markerikson/react-redux-links) has a section of articles that discuss [React's implementation](https://github.com/markerikson/react-redux-links/blob/master/react-implementation.md), including walkthroughs of the actual source code and many "build-a-mini React" articles.
[In flux a view can't change the model. In MVC the controller does just that.](http://iweave.com/assets/blog/mvc_v_flux.png) Even an action doesn't change the model, it reduces into a new shallow copy. MVC also binds 2 ways, the model affecting the view while the view affects the model. MVC as implemented over the last 10 years was an un-inspectable web of side-effects, which made driving complex application-state hard. Flux allowed views to merely represent state while offloading logic to the store, application-state isn't the problem it once was. Since views are now pure the entire application can be [spooled back and forth](http://i.imgur.com/1M4V7du.gif), precisely because the model never mutates. Each action is inspectable and its effects are always known. 
Check GitHub. Pre-bundles files will be easier to read than huge bunfle
Logging output is usually poorly formatted and ctrl+c leads to zombie processes (in my experience).
Came looking for this. Is it foldl or r? It's interesting that imperative languages are building in all these functional systems now. C++ has basically reimplemented a functional list library in 17
&gt; outdated typings defs for 80% of your third-party code You either choose obscure 3rd party libraries that nobody has ever heard of, or are lying. I maintain a 150kloc Typescript application using ~20 3rd party libs and we have never run into this issue.
should be able to just do this: document.getElementById('wager').value = newWager;
Yeah it’s funny
doesnt make sense more data needed.
&gt;&gt; A sort callback must distinguish between all three cases &gt; That's a bit too dogmatic. OP's callback is not incorrect, it's just an unstable sort. (Elements that compare equal could be shuffled with respect to each other in their original order.) Let's look at what the [ECMAScript 2016 Language Specification (ECMA-262 7th Edition)](http://www.ecma-international.org/ecma-262/7.0/index.html#sec-array.prototype.sort) says about this. First they have a general comment: &gt; The sort is not necessarily stable (that is, elements that compare equal do not necessarily remain in their original order). So you're not guaranteed a stable sort in any case, even if you follow my dogmatic approach. But more importantly: &gt; If _comparefn_ is not **undefined** and is not a consistent comparison function for the elements of this array (see below), the sort order is implementation-defined. What is a "consistent comparison function"? There's a lengthy description at the end of this section that lists seven requirements. The one that affects us here is: &gt; _a_ =CF _a_ (reflexivity) The notation "=CF" is defined just above: &gt; _a_ =CF _b_ means _comparefn( a, b )_ = 0 (of either sign) In other words, when the same value is passed into both parameters of the compare function, the function _must_ return 0. If it doesn't, the consequences were described earlier: "the sort order is implementation-defined." The sort function from the article fails this test, because it returns -1 instead of 0 when the elements compare equal. Note that they didn't just say that you'll merely get an unstable sort for "equal" elements. It says the sort order - and how do we know this couldn't mean the _entire_ sort order? - is implementation-defined. So I honestly don't think I was being "dogmatic" in my recommendation that a sort function must distinguish all three cases. I'm not comfortable with an "implementation-defined" sort order, are you? I'm much more comfortable if I follow the requirements listed in the standard. Edit: Thanks for your Edit 2 above, and no need to apologize! I really appreciate that you challenged me on this; it forced me to double-check and triple-check my dogmatic assumptions. Always question people who tell you they are right! ;-)
&gt; One possible application of this would be to increment "share" links in an aesthetic way. Up to 999 trillion unique links could be incremented. What does this mean? Since this is an encoding not a hash, aren't there infinitely* many results? *of course limited by the allowed length of a URL
I'm using laravel mix and it appears to be webpack-dev-server 2.5.1 installed. Not sure what else to look at. Why I went on here really.
nice! reminded me of https://github.com/danielstjules/swaddle
I should clarify that I'm taking about the integer encoding here, which is limited to 15 digits at the moment. I'm working on an update to remove this limitation though. 
Yeah, good point. I've reached out to them, but nothing yet. Likely I'm the only one requesting it :(
On my own, I would agree. The learning curve for this specific task (given the need to embed it in an MotoCMS site --which is do-able, but means likely setting it up and hosting it on a elsewhere on my server). My hopes were if it were a tad complicated for the newbie, whether there are outsourcing or "pay per project" coders out there for this sort of thing, like 'elance' or something. 
I see!
As long as the supplied function is commutative then the foldl == foldr, in which case it doesn't matter. I'm assuming foldl since most people mathematically read from left to right. A lot of these languages have some functional things stashed on the side, it just seems recent that there's a stronger push to use these tools. Which I'm all about. 
I mean what steps did you take to make sure it was that? For example electron editors (VScode/atom) have had documented issues with battery performance.
Hey! Congratulations on the library you created. I have a few questions. 1. What advantages does your library provide over Promises, which can be chained and are asynchronous? 2. If someone were choosing to use a library to handle a processing pipeline, what should they consider if they were deciding between your library and a [state machine](https://github.com/jakesgordon/javascript-state-machine)? Thanks!
Is it possible to run a Angular or React app from those files?
Thank you so much for the list. I've found a few in the past and read them but I needed more in my reading list. About CDN, I was not able to find Angular 2's CDN. Do you think it would be possible to run an Angular 2 app from the source files?
You should provide an accompanying stylesheet to reduce the line-height, so that the extra whitespace doesn't go to waste. Kids in Africa could eat that whitespace you know.
A link to the code in question could be helpful, is there a git repo?
https://www.pastiebin.com/#&amp;togetherjs=xLOsuy1e3O 
Jesus how do you know so much about a function in JS? Are you a senior developer? Do you know know this stuff at the top of your head?
True. Though it can make a difference for memory and can optimisations (e.g. when folding on (*) folding in a zero allows you to disregard the rest of a non-NaN list.)
Bundling is a resource intensive process
I haven't used pastiebin before, clicked the link signed up, and it asked if I wanted to joint he session, hitting yes just plopped me on an editor with nothing and no one there?
I'm sure it is! Devs seem to either fall in love with it, or hate it with a passion. I don't hate it "with a passion" but I started out that way. I still dislike it; writing in TS feels like writing with condoms on my fingers. There are langs where what TS does would feel right, but they already have types. That said, there are valid use cases. Large teams, teams with high dev turnover, teams with devs that aren't experienced or don't want to spelunk the code.
I never saw the point in grunt or gulp; npm has had a scripting feature forever and it does more than enough for building. If you need anything more, plain old fashion make is still the best way to go.
This isn't about me disliking it. This is about building something on a fork of JS. Eg: coffeescript.
This makes sense, thanks for breaking it down!
No, probably not. React maybe? Angular definitely not. You should be able to utilize sourcemap files to step through the compiled code, though. Maybe some more direction [here](https://www.reddit.com/r/Angular2/comments/5axyws/help_setting_up_source_maps_for_angular/). [This may help](https://webpack.js.org/configuration/devtool/), too. Assuming you're using webpack if you're using either of those two libs.
Why does gmail do this instead of using an iframe?
Perhaps calling .blur() on the input before updating it helps.
Great question! I can only speak from my point of view in building an email application that needed to render external, arbitrary html. Iframes can be difficult to manage. They live in their own document and are almost entirely quarantined from the rest of the application. This is a blessing and a curse. Communicating between parent document and iframe is possible, but it's a tedious process. Something as simple as keeping the height of the iframe the same as the content within it was not straight-forward. Another reason to render the email within the same document was to allow some of the parent CSS to leak into the rendered email. There are some stylistic things we wanted to be represented in the email we rendered. For example, ensuring images are contained within our message container, breaking hyperlinks up into multiple lines, adding styles for pre or block quotes, etc. All of this can be accomplished with iframes, it's just more difficult to work with besides straight html and css.
Hello, thanks for your reply. This library is small, functional and Promise is also very similar, the reason to develop this library is that I hope every step of the process can have a name, so I can jump between the steps in the process. So you can write code step by step and you can jump to other step when you want. The flow is clear I think. Turn it that Promise is not possible. Step-flow can also be asynchronous. The next function will not be called until you call next (). The same as express middleware. Thanks.
Reduce is often a more concise, readable, and performant solution than long map/filter chains. const items = [{val: 1}, {val: 2}, {val: 3}, {val: 4}]; // using filter/map items.filter(k =&gt; k.val &lt; 3).map(k =&gt; k.val); // =&gt; [ 1, 2 ] // using reduce items.reduce((acc, k) =&gt; k.val &lt; 3 ? [...acc, k.val] : acc, []); // =&gt; [ 1, 2 ] this is a bit of a contrived example, but in real world cases the benefit is actually much larger.
&gt; Obviously that's not what the source HTML is But it is. You can verify that by looking at the source (right click page &gt; View Page Source).
Yeah, just to echo what some other people said: 1. If you're unclear on jQuery's underlying tech, go straight to vanilla and spend some time at least getting familiar with the native api via something like Wes Bos' JavaScript 30. 2. For moving beyond code-level understanding of JS and start understanding bigger code bases, check out [Addy Osmani's Learning JS Design Patterns] (https://addyosmani.com/resources/essentialjsdesignpatterns/book/) 3. Get coding! For me, the break was just coding daily at a entry-level job. Forced me to drive home lots of stuff I knew pretty well, but needed to do dozens of times before I didn't have to think about it. You finished all of the FCC front-end projects? Then why don't you come up with some simple app idea or look for other apps and start building it on your own? Before I got my job I created a relatively simple app idea to practice React and Redux. Now I want a personal project outside of work to show off what I can do in Vue, so I'm building a sci-fi ship captain game that will be something like a tic-tac-toe that fights back... The game logic will be relatively simple (I can always keep adding to it), but the interface is relatively complex.
I like this use case // create an inhertance chain from any number of objects (prototypes) function extend () { return [].reduce.call(arguments, Object.create, this); } 
I believe the goal was to validate those form fields with regex, being sure no non-numeric value was passed in. Your regex needs to be called against the string, i.e. 'string'.match(regex); or regex.test('string') for a boolean. 
r/forhire. 
That's not a fork, that's a super set. JavaScript is valid typescript, not necessary vice versa.
What is the logic here? – How is hiding the ID going to increase the odds of link being shared? If anything, this will obfuscate data in a way that various algorithms (such as search spiders) are unable to distinguish meaningful content in the URI from the ID. This is not good.
Thank you @JapanPunk
&gt; .reduce((a,b)=&gt;Math.max(a,b), -Infinity) Why `-Infinity` ? o_O
`npm-run-all` also supports wildcards, so you can do something like this: `"watch:scss": "node-sass --watch src dist"` `"watch:js": "echo asd"` `"all": "run-p watch:*"`
It's Math.max's initial "largest" value. &gt; Math.max() -Infinity If you'd implement max yourself, you should initialize the variable which keeps track of the largest value with -Infinity as well. With min it's the other way around: You start with Infinity.
No way reduce is more concise / readable. Reduce is a function where you can do pretty much everything so it's hard to describe what it is doing. I looked at your reduce example for around 2 seconds, couldn't figure it out, looked at your filter/map, instantly got it. It's not that it was a hard example, I would figure it out in a couple more second, but the point is reduce isn't more 'readable'
Why do you keep doing this. In Flux a view can't change the model. In MVC a view **also** can't change the model. Why do you keep equating Flux view with MVC controller? You said "in Flux the view and the controller are one the same" earlier. **No, it's not**. Disabuse yourself of this mental contortion and see it for what it is: it's just a view, just like in MVC, and it follows the same rules a MVC view follows. There's nothing in this React component up there that makes it a "view and a controller". It's a view. It's even called "a view" so why are you going out of your way to confuse yourself? &gt; Even an action doesn't change the model, it reduces into a new shallow copy. "Reduces a new shallow copy" just means exactly what I said - the model changes in a "copy-on-write" fashion. This doesn't mean the model doesn't change. It just preserves old copies elsewhere in the project. That "new shallow copy" *is the new state in the store*. So the *store has changed*. And that's a fairly simple notion to process. And by the way the word "reduce" is used incorrectly here. Do words mean nothing anymore? Let's just say whatever we fancy? &gt; MVC also binds 2 ways, the model affecting the view while the view affects the model. No, you just failed to describe MVC in a very big way. The fact the view doesn't change the model is very clearly established in MVC going all the way back to SmallTalk days. If you don't understand MVC, I don't think you're qualified to compare MVC with Flux... &gt; MVC as implemented over the last 10 years was an un-inspectable web of side-effects, which made driving complex application-state hard. The fact *some people* don't understand MVC and make a mess isn't an issue with the MVC architecture, and doesn't warrant changing the name to celebrate every time a previously confused soul reinvents it. &gt; Since views are now pure ... as in MVC... Views are stateless (and may at best only hold transient state like, say, mouse rollover state), as they simply reflect the model they're bound to. The model they're given is *their state*... just like in React.
Not really sure what you're asking for, but if you want to use JS to select an option .. document.getElementById('bulkCheck_available_limit').selectedIndex = 2; .. where the first option is selectedIndex 0 .. second option is selectedIndex 1 etc.
Reduce takes two arguments, the reduce function and the initial value for the aggregate (in this case, the 'a' variable). So you start with -Infinity, and then you're comparing with every item of the array, and whatever the first item is, it's going to be bigger than -Infinity. Oh well in this case it was 100% not needed since we are only expecting numbers. But let's say we have an array of objects, and we want to get the biggest value (let's assume there is a value property in each object), so we could do: `arr.reduce((a,b)=&gt;Math.max(a, b.value), -Infinity)` If we don't add the -Infinity as the initial value, the first time would compare `a` (the first object of the array), with `b.value` (a numeric value from the second object of the array) and it would not work well.
Without ES6: `Math.max.apply(null, arr)`
thanks it worked, but when i manually select any option then it got redirected to something like a event is added to it, but when i tried your line of code it just selected but didn't redirect
Gulp pipes are nice though. Pipes are good.
I gotta agree with this. Whenever I use reduce (and not using lodash) I'm probably saving lines, but it isn't exactly easy to pick up what I'm trying to do, since reduce could be pretty much anything.
if you have time can i pm you
No reduce needed bro &gt; `Math.max.apply(null, arr)` 
You might want to try firing the onchange method after you've selected the appropriate option .. document.getElementById('bulkCheck_available_limit').onchange(); Difficult to say without seeing the actual HTML / JS.
i can give the url of that page https://namebright.com/BulkSearchResults.aspx just seach these domains (all at once): 1aajdjdfsjajfdddfjfjfjaf.com 2aajdjdfsjajfdddfjfjfjaf.com 3aajdjdfsjajfdddfjfjfjaf.com 4aajdjdfsjajfdddfjfjfjaf.com 5aajdjdfsjajfdddfjfjfjaf.com 6aajdjdfsjajfdddfjfjfjaf.com 7aajdjdfsjajfdddfjfjfjaf.com 8aajdjdfsjajfdddfjfjfjaf.com 1aajdj1dfsjajfdddfjfjfjaf.com 2aajd1jdfsjajfdddfjfjfjaf.com 3aa1jdjdfsjajfdddfjfjfjaf.com 4a1ajdjdfsjajfdddfjfjfjaf.com 51aajdjdfsjajfdddfjfjfjaf.com 16aajdjdfsjajfdddfjfjfjaf.com 17aajdjdfsjajfdddfjfjfjaf.com 18aajdjdfsjajfdddfjfjfjaf.com 1aajdjdfsjajfdddfjfjf1jaf.com 2aajdjdfsjajfdddfjfjf1jaf.com 3aajdjdfsjajfdddfjfjf1jaf.com 4aajdjdfsjajfdddfjfj1fjaf.com 5aajdjdfsjajfdddfj1fjfjaf.com 6aajdjdfsjajfddd1fjfjfjaf.com 7aajdjdfsjajfdd1dfjfjfjaf.com 8aajdjdfsjajfd1ddfjfjfjaf.com 1aajdj1dfsjajfdddfjfjfjaf.com 2aajd1jdfsja1jfdddfjfjfjaf.com 3aa1jdjdfs1jajfdddfjfjfjaf.com 4a1ajdjd1fsjajfddd1fjfjfjaf.com 51aajdj1dfsjajfdddfjfjfjaf.com 16aajdjdfsjajfdd1dfjfjfjaf.com 17aajdjdfsjajfd1ddfjfjfjaf.com 18aajdjdfsjajf1dddfjfjfjaf.com you will see a select box under available domains
 var x = document.getElementById('bulkCheck_available_pages_select'); x.selectedIndex = 1; x.dispatchEvent(new Event('change', { bubbles: true })); 
Wow, thanks brother it really worked, Thanks
I think if you wanted to say something concrete, you would've said it by now, rather than writing paragraph after paragraph complaining about me, and avoiding the question we all asked of you.
The page is probably generated by the server and sent to you as is without modifying those links using JavaScript (since, as another user pointed out, it's visible in the source). However, you can grab that id yourself like so: `document.querySelector('[title="My channel"]').getAttribute('data-external-id');`
hey, another issue occurred, isn't it possible to avoid spaces in the script, i mean the script i am making doesn't allow space, these should be no space in any of the code. i can remove all the var and remove space but the issue is with the "new Event('change',{ bubbles:true}" how can i remove space between 'new' and 'event' ?
Agree. Some really useful recommendations and good discussion points. Thanks everyone! 
Well, I turned 65 this year, so I guess that does make me a _senior_ developer, eh? ;-) But with regard to this particular function, it's just that I've written a lot of sort callbacks in the past and got curious about the actual requirements. And then in this thread, /u/cheeseburger_dot_mp3 did me a great favor by challenging what I was saying, and that got me to dig in to the ECMA spec to see what the standard actually called for. Fair warning: reading that ECMA spec can be a tough slog. It's not written to be easily understandable, but to be precise. But it can be worthwhile when you really want to understand the standard that the various JS implementations try to implement.
IMO there are controllers in React. They are event handlers. &lt;div&gt; onClick={() =&gt; dispatch({type: 'addTodo', text: 'Foo'})} /&gt; I would say this arrow function in onClick handler is a controller in the MVC sense because its purpose is identical to the Controller role in MVC &gt; The controller interprets the mouse and keyboard inputs from the user, &gt; commanding the model and/or the view to change as appropriate. from "Applications Programming in Smalltalk-80™: How to use Model-View-Controller (MVC)"
I have a rule of thumb called "any design pattern is not fully defined until you can derive a recursive version". This is why when I analyze MVC I always do it from the point of view of HMVC (hierarchical MVC, also PAC). Those little handlers can be thought of as controllers, it's a valid way of seeing it, but only at the lowest level of the application view architecture. They don't really change the view, they don't really change the model. All they do is they take a low-level user input event and transform it into a more high-level user input event. The actual work on changing the model is done at the dispatcher and the stores. The actual work on changing the view is done at the rest of this markup (outside the handler), in what's the engine of the view (React and ReactDOM). In the interest of application architecture, if we have to ignore the hierarchical nature of real-world MVC (which wouldn't be wise, but can be done), all I see up there, markup **and** handlers, is just a view emitting events (action) to the controller (dispatcher), which controller (dispatcher) triggers model changes (store "reduce") and this in return updates the view.
I really doubt these are the reasons... The communication between parent frame and iframe is a trivial problem to solve, esp. if you have control over the contents of the iframe. Regarding leaking CSS into iframe, you don't need to leak anything, just render the iframe with the CSS you want. After all, gmail has full control over the content the iframe would be linking to. So what is the reason? Most likely cross-browser/ cross-platform/ cross-device support, e.g. blocking iframes is not uncommon for various corporate "firewalls". Printing of the page might be another consideration. Accessibility comes to mind. In general, the more flat the page structure, the less likely things are to break. For the record, this just re-invents CSS modules (https://github.com/css-modules/css-modules).
events are just abstractions for calling the method. instead of writing: store.dispatch({type: 'addTodo', text: 'Helllooo!}) we could just write store.addTodo('Helllooo!'); it's conceptually the same. Just sending the message to the object. Actually flux frameworks moved backwards because they demand you to write more code and operate directly on low level "actions" objects instead of just allowing for calling the method. Of course treating events as separate objects HAS value (because you could for example record them end replay in event-sourcing way. Or you could send a serialized action via network) but act of dispatching alone has no value at all. Dispatching actions to the store is the same as "calling method on model". It's event based in the same degree like first MVC apps EDIT: I thought that you mean "custom actions". If you meant events like &lt;FancyComponent onAddTodo={() =&gt; this.handleAddTodo()} /&gt; it's even less useful. They are just usual callbacks. Nothing new. It's like old NodeJS apps where you didn't have promises and you had to pass callbacks all around the application. Custom events in React can easily become identical mess to this. Actually I thought that whole purpose of flux is get rid of these custom events.
I always found it difficult to size iframes. Typically I would want them to be just the right size and fit the child page content, with no scrollbars or fixed size viewports, and just expand in the parent page as required. I never really found a good solution, and coincidentally that is the same use case as what gmail is attempting.
for "hot reload"?!? 15 minutes is crazy though. Oh, it is written in javascript too... I repack with a script, takes a couple seconds.
The story gets a bit trickier if website has 25 different entry points ;)
Consider edge case of `arr.length === 1`
javascript is an interesting choice for big data. Are there people doing big data in javascript? 
You can hit hard limit of function arguments (AFAIR ~30-40k arguments).
[helpful video on reduce](https://www.youtube.com/watch?v=tsIAyUQc8Ig)
JavaScript IS the only choice in the Front end. Its not an "interesting" choice, sometime its "the only Option". But yeah if youre actually iterating oder a few Million objects then youre probably doing to much in the Front end and to little in the backend 
Yeah but for the sake of the poor sap maintaining your software in 20 years, don't use this for anything that matters. 
Oh but damn, its not compatible with NPM 5, remember how to downgrade to 4? 
Just released: https://github.com/mjavascript/practical-modern-javascript
The added benefit of using npm across is it helps people to be more comfortable with command line. Grunt and gulp got popular as abstractions for front-end developers that weren't comfortable with command line. I don't think that's the case these days - command line is a first class citizen. 
Without knowing the exact setup, at a guess the next step would be having the front/backend agree on a data exchange format such that you can communicate the business action needing to be performed which is where most of the work will come in. Eg javascript sends server a json payload to a rest endpoint X which triggers writing some data to excel etc. This is done through ajax like you normally would. You can run the server on localhost, you don't need a hosting provider if its just running on your own machine and no one else needs to use it. All you need the server for is to allow your frontend to call java code via rest calls. Otherwise yeah you'd need to do it in javascript which as you said is a hassle (or create a native javafx app so you have full access to the file system). How much of a hassle? depends on how much time it will take you to create a rest server vs hack excel in js to get to where you are at currently. 
not what i meant, but sure. 
It's gimmicky sure, but that still describes a valid use case. The objective is not to increase the odds of a link being shared but to generate a url with a particular aesthetic (nothing below baseline or above x-height). Say you built a really simple URL shortener that used an integer count incremented with the addition of each new link (0, 1, 2, 3...). The integer is encoded using OP's module before it's inserted into the index and returned to the user. Uses for url shorteners: add link to twitter with minimal effect on character count, generate more aesthetic link esp when you can't control the origin link, ephemeral links, youtube style links etc.
All of this can be done with 'make' and the typical Unix built in tools and I've been doing it with 'make' since 1985.
@jrop thanks for your answer I did what yousaid but it's really strange what happened. All breakpoints outside "page.property('onResourceRequested', function(requestData)" function worked, but no breakpoint raised inside the function even when the cmd kept logging info... So i am at the starting point again
This is just the *roll-your-own-shell-stuff* approach like the way it was before tasks runners like Grunt, except instead of having a folder with the commands in shell script we put the scripts in package.json. 
Doesn't allow spaces? I suppose you could do something clunky like .. eval(decodeURI("var%20x%20=%20document.getElementById('bulkCheck_available_pages_select');x.selectedIndex%20=%201;x.dispatchEvent(new%20Event('change',%20%7B%20bubbles:%20true%20%7D));")); .. or .. eval(atob("dmFyIHggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnVsa0NoZWNrX2F2YWlsYWJsZV9wYWdlc19zZWxlY3QnKTt4LnNlbGVjdGVkSW5kZXggPSAxO3guZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2NoYW5nZScsIHsgYnViYmxlczogdHJ1ZSB9KSk7")); .. but that's nasty.
`Array#reduce` is a left fold in JS. There's [`Array#reduceRight`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight) for right fold, albeit I've rarely seen it actually used in a wild — maybe because it's not that useful in a strict langauge?
The reasons I described are why we don't use iframes. I disagree that communicating between parent and iframe is trivial. You have to inject JavaScript into the iframe and then send messages to and from the parent. With this library we don't have to deal with that at all. Regarding CSS leaking into the document, yes it can be done but somehow you have to inject the CSS into the iframe. With this library it's part of the document so there is no issue. I think many would agree that dealing with an iframe is more difficult than dealing with some scoped CSS and HTML that can be injected into the same document. I agree that these might not be the reasons why Google does it. I looked into using CSS modules and it is where I got the idea from. The primary issue is that CSS modules only scopes classes and keyframes. We needed to scope font faces, ids, and elements as well.
Excellent video. Thanks for sharing.
There are several ways: Your app as a CLI tool using Node, which has system access. Node also has several ready-made [excel packages](https://www.npmjs.com/package/node-excel-export). Or wrapped into a native-like desktop shell through [Electron](https://electron.atom.io/) which combines a portable Chromium with Node. If the amount of files is fixed, a bundler like [Webpack](https://webpack.js.org/) will pull them all in, you can `require` them in your code, no server needed. You could run a small node-based server locally. As a last resort browsers can be run with command flags to allow local fetch requests. 
&gt; The whole point of a reduce (or foldl) function is to **repeatedly create a new result** using the previous result and the next value. I don't think there's anything in the fold itself that requires that: &gt; `fold` (or `reduce`) is a family of higher order functions that process a data structure in some order and build a return value. ^([From Haskell wiki][1]) So from my understanding of it, it's fine to mutate your accumulator while you are folding. And indeed, your `forEach` mutating `new_times` is doing exactly the same as `reduce` in the article (except `new_times` is called `obj` and provided to the `reduce` callback instead of being referenced from scope). &amp;nbsp; I'd argue that `forEach` is a bad choice here, though — `forEach` is inherently about side effects, so I would **have** to: 1. take a note of you creating empty object for whatever reason 1. read through your callback to `forEach`, mentally execute it, and only then be able to tell that all it did was update that empty object you created earlier with data pulled from `all_times` With `reduce` version: 1. I can see that `new_times` is based on doing something to `all_times` straight away 2. while `reduce` does not forcefully prevents side effects, I'd hope that any developer who understands how to use `reduce` also understands that you really shouldn't perform side effects in its callback, so I can be a little more at ease &amp;nbsp; Ultimately, I think /u/Ginden [is right](https://www.reddit.com/r/javascript/comments/6p1hgy/a_quick_practical_example_of_javascripts_reduce/dkm87kc/), and this pattern is common enough to warrant to be abstracted away — `fold` (or any loop) is too low level here. [1]: https://wiki.haskell.org/Fold
Wait so is this about dildos? 
My understanding is that RxJS 5 is a superset of the functionality in the spec.
I might be being presumptuous but if your excel data is in a matrix format database might be a better solution that would be more web friendly
Gulp can be a headache compared to make for ensuring things happen in order. Makefile is going to be 10th of the size, easier to understand, and do the work much more predictably. That said npm is usually more than enough and only the more complicated projects require a makefile
This seems like speculation more than anything else. Has developer productivity changed measurably as a result of this move? For a discussion centering on the merits of developer productivity it doesn't say. The complaints are rather shallow as well: * You need to call super or you'll get a syntax error. Yes, but is that really a big deal? After you forget to do this once, how often are you making the same mistake? * You need to remember to bind member functions. While very unfortunate, this again becomes automatic and only takes a few seconds for each class. * Prop types and such are declared after the class. Well, only if you choose to do so. You can declare prop type objects above the class and set the member later. You can also use Flow or TypeScript and drop prop types altogether (although this would be comparatively difficult for larger code based). `createClass` had this same issue since nothing requires that you put these keys ahead of every other key in the declaration. Really, if this is the biggest issue for developer productivity at Netflix, I'm jealous.
The items defined after the class can be moved into the class by using a static getter function.
The article goes over the basic parsing terminology and jumps into parser generators. All of this information is helpful, but when I first got into parsing I just jumped into it without any research. When writing (or using) a parser here is what I look for: * **Performance** - does it execute fast. The fastest I have seen for JavaScript is Acorn. * **Scale** - Is the parser flexible to allow new syntax rules or language dialects without considerable recursion? This is where most parsers fail. * **Organization** - How immediately simple is the output to reason upon. Most output is in a tree format which is hard to reason upon unless you walk the entire tree. I prefer arrays containing the necessary organization data. * **Description** - Are the tokens that comprise the output well described? How do you know about data types, containment, structures, or inference? * **Isolation** - Can fragments of the code be parsed in isolation apart from the complete code reference? This is a big deal when troubleshooting code or reasoning upon large algorithms. * **Thoroughness and Precision** - How completely are the tokens captured or described? For example, white space has different meaning in different languages and may even constitute a valid independent token. Does the parser properly account for I18n and complex characters? Does the parser manipulate data between the source and output?
The article points that out under "A Slightly Better Future with Proposed Class Fields"
I knew someone must've had a similar idea! thanks for this :)
This one seem to be easier than SW, what is the main idea behind that ?
I am one of the two authors of the article. These are good criterias if you are an expert with a specific project and you need to find the best tool to implement your project. But our article is more geared toward people that are relatively new to parsing or maybe they used lex/flex/yacc/bison a few years ago. People that have not a clear idea of what they need or, if they do, they cannot state their requirementss as well as you just did. We think that it is more useful for these people to know the features and the look and feel of the parsing tool. So that they can pick one and then play with it and study it until they understand better the terms of the problem.
&gt; You need to call super or you'll get a syntax error. Yes, but is that really a big deal? After you forget to do this once, how often are you making the same mistake? &gt; You need to remember to bind member functions. While very unfortunate, this again becomes automatic and only takes a few seconds for each class. They're redundancies in comparison to using createClass. That's the point the article was making. Vue, in comparison, doesn't require this, and it's quite lovely. &gt; Prop types and such are declared after the class. Well, only if you choose to do so. You can declare prop type objects above the class and set the member later. &gt; createClass had this same issue since nothing requires that you put these keys ahead of every other key in the declaration. I believe the more relevant bit was putting it _outside_ the class definition as opposed to putting it _inside_, not before vs. after. However the author does address this as well by mentioning the babel class properties transform. &gt; Really, if this is the biggest issue for developer productivity at Netflix, I'm jealous. It's not (and I bet they wish it was!) but it's still worth a mention, no? It's not like we can't talk about more than one problem at once.
A static function getter is already supported and slightly different from what is mentioned in the article
Ah, I see what you mean. Neat! Haven't seen that being done a lot. For those also unaware: class Test { static get foo() { return 'bar' } } console.log(Test.foo) // bar
&gt; jsbin https://jsbin.com/kuviqebujo/edit?html,output
Oh man I didn't even think of that. I was working on this way too far into the night. That will work nicely, thank you! 
There are some interesting points, but personally I like the extendability, so you can create your own base class (which extends from React.Component) that has any additional routines you would like (such as autobind functionality, or event handling functionality, an autorenderer subroutine, any connect / disconnect oo store facilities etc). I think React thought "classes are the way its going, and while its not there yet, the sooner we get people on board, the easier it will be later when it is the way everyone is going"
* script tag is malformed (&lt;script language = "text/javascript"&gt;). Don't use spaces in attributes. * You're missing an extra ) in your if statement: if (digits.test(plaQty) || digits.test(chiQty)||digits.test(spaQty)) * document.forms doesn't exist. 
No mention of usus? https://github.com/gajus/usus and the accompanying story https://medium.com/@gajus/pre-rendering-spa-for-seo-and-improved-perceived-page-loading-speed-47075aa16d24 It can all be 100% automated. See https://go2cinema.com/movies/baywatch-2017-1198354 as an example.
&gt; There are some interesting points, but personally I like the extendability, so you can create your own base class (which extends from React.Component) that has any additional routines you would like (such as autobind functionality, or event handling functionality, an autorenderer subroutine, any connect / disconnect oo store facilities etc). I agree, the extensibility is nice, but I still feel as though the old API could easily enable the same sort of base class extension that the ES6 class syntax did as well. Maybe through some sort of middleware system. Mixins were a thing, but the ended up getting deprecated for good reasons: name collisions, implicitness, and so on. However, it seems better practice to implement the additional functionality you'd need as another component, right? Since some components (particularly smaller ones, like Buttons, Inputs or Links, which still might have internal state as well) probably won't need the extra functionality. Add it on as you need it; composition over inheritance. &gt; I think React thought "classes are the way its going, and while its not there yet, the sooner we get people on board, the easier it will be later when it is the way everyone is going" Classes are undeniably popular in the dev community, and increasingly so in the JS community ever since ES6. And while going with the rest of the crowd is a decent reason for an API change, were the object literals really that bad to justify it?
&gt; They're redundancies in comparison to using createClass. That's the point the article was making. &gt; Vue, in comparison, doesn't require this, and it's quite lovely. They're basic javascript semantics. If you use anything other than ES5 you know them. As for Vue components, that comes with a dozen disadvantages like the trouble of storing local data without running the risk of having them turned into nested observers. It is to this day the biggest gripe i have with it in that a component isn't "mine," it's an arbitrary object passed into a blackbox. Also it suffers from similar binding issues only in reverse because in many places you can't use the short syntax because functions are already bound internally, causing more black box magic. React just doesn't do any magic, you apply the same methods as in any common javascript situation, like addEventListener. And since drafts already deal with auto-binding now, there's hardly any problem. Even the transpilation overhead is not as big of an issue because transform-runtime uses helpers once.
These issues are insignificant in size. The complaints may as well include that it's also necessary to write both `class` and `extends`. I find whether the prop types are inside or outside irrelevant as well: often you have one class per file and so anything in that file is effectively inside that class.
Will you look at it now? I changed: "var plaQty = document.form("Pla").value;" to "var plaQty = document("Pla").value;" and added the name "document" to my form.
Hi /u/QQquestionsQQ, please use an online service to host your code. Here are a few, but not all, of the ways you can post your code: * [Codepen](http://codepen.io/pen/) * [JSFiddle](http://jsfiddle.net/) Please reply to this comment once you have done that and I will make the post public. Thanks!
Future developers will laugh at us for trying to stay under 1 KiB the same way we laugh about people claiming 512KiB of RAM is enough forever.
Your `reduce` example is actually longer than the `filter/map`, and I really have to argue that the `filter/map` example is more readable, too. There's no manual concatenation or accumulator variables, and the name of the functions tells you what it's doing. You're right that `reduce` might be more performant here. It all depends on optimizations, but you are only doing a single pass over the array, while the `filter/map` does a full pass to get the filtered version, then another partial pass to do the mapping. (But again, how this gets optimized is probably relevant, too) But eleven times out of twelve, I'll take the more readable and maintainable version over the "does everything in one pass for optimization purposes" version. *Especially* when you get into more interesting examples than a single filter and map, it's a lot easier to read if all the logical steps are split out into individual operations, rather than a complex reduce function.
Does resolve get called? I am wondering if there is an error before it gets called. Can you just change that line to resolve(requestData)? It's hard to say :/
Looks like someone is hating me already or my posts and comments on here, but that doesn't matter hope i didn't heart someone here
Thanks, i checked and found the scripting platform allows spaces by putting &lt;sp&gt; between those 2 words, i thought i have some knowledge but there is still a long way to go Thanks for your great help
I agree. It hasn't been a major improvement to my codebase, and it is harder to use. If they were going to change the syntax for performance, I don't understand why they didn't change the system so that all functions were separate and pure (for example, creact a bare render function that takes props and state as an argument), and then simply register the data (plain object reference for state) and functions (such as render) to a React state machine instance to make your "classes".
PSA, that Shadow DOM does CSS scoping natively. There's also a shim that emulates Shadow DOM when you're stamping out elements from `&lt;template&gt;`: https://github.com/webcomponents/shadycss
&gt; These issues are insignificant in size. The complaints may as well include that it's also necessary to write both `class` and `extends`. I think it's subjective in terms of precisely _how_ big the redundancy is. However, the `super()` call and method binding bother me because other frameworks (including React itself) have shown that it's not necessary. The `class extends React.Component` syntax is equivocal to writing `React.createClass`, and doesn't apply here as a redundancy, because it's core to saying "this is a component", where the other points I've listed aren't. The class property syntax does fix both of these issues, though, and [libraries exist](https://github.com/developit/decko) which make method binding a lot prettier as well. A bit of a shame we still end up having to rely on experimental syntax features. Not much of a problem for smaller pet projects, but it's easy to see why a big company like Netflix wouldn't want to go that route. &gt; I find whether the prop types are inside or outside irrelevant as well: often you have one class per file and so anything in that file is effectively inside that class. Whether the propType definition is inside or outside of the component definition is mostly preference, but there are situations in which you'd have multiple classes per file. If you had variants of a component for example, or multiple small components that make up a bigger one.
Looks to me that a lot of your concerns could be fixed with a few snippets...
I only used one part of Vue as an example. Please don't turn this into another framework debate, thank you.
The same applies to createClass to a lesser degree. A class offers more sovereignty and extensibility that mystery objects passed into a parsing machine don't have.
"Seems to be" is where I'd put the emphasis there. While it is easier on the developer to roll out, there are tons of little cases that come up. Like really, it can take 3-4 refresh cycles with waiting for all the downloads for new content to get used by the browser sometimes. That's a huge wait beyond the instant or next-refresh SW allows for. Which means you need to understand how appcache'd content is getting refreshed and served completely in order to know how to build your app to maintain all the possible stuff still cached out there. AppCache is an epitome of "Put a bunch of brilliant people in a room. They try to make a complex task simple. The outcome is something that appears simple but is actually a quite complex thing to understand well enough to deploy and manage in production". This is the way it was described to me by a Chrome team member. I've implemented SW stuff, it's actually quite trivial for most basic tasks. And there are libraries like [SW Toolbox](https://github.com/GoogleChrome/sw-toolbox) to help abstract the simpler cases out for even easier implementation. In the end, we'd all love to just write and maintain a simple manifest file and let the browser handle all the work for us. However, that isn't modular and leads to a lot of, "well, I can't fix that" kind of situations. Developers **need** control over the platform, SW provides that. It is superior in every way even once you get past the writing a little more JS side of it.
I'm struggling to think of an instance where it makes more sense to extend a react component than to just have the "child" component return an instance of the (pure?) parent component. What's a practical example of a problem this solves?
The argument that iFrames are "easy" to work with is bananas to me. Every iFrame I've ever used has ended up with a fixed height in the parent. They're atrocious. 
Unfortunately. My company's architecture division decided to spend 4 years building our Data Lake platform on Node+Mongo. We told them it was 'tarded back then and it'll never scale. And gosh, 4 years later it's a clusterfuck of unmaintainability that doesn't scale and we can't sell it to anyone because it's 10x slower than our "go retire, old man!" C# designs. 
If you’re asking this question, you’re not at a level where the differences would make a substantive difference in your overall application. Pick one that has a community you like and start. 
You have a syntax error in your form, name=documents is not in quotes. &lt;form name="document" method="post" ...
I have corrected that and it is still not working. https://jsbin.com/kuviqebujo/edit?html,output
great to see Chevrotain mentioned
What about parseFloat and parseInt check if NAN for both parse. var int_test = parseInt(quantity); if(NAN(int_test)){ // not a number} On mobile so check syntax 
Why does the argument need to be about performance instead of standards. Developers can be so shortsighted by temporary inconveniences.
I see what you're saying, but it's not strictly true. If it were, you could write pure js, run it through the typescript compiler and get zero errors. To do that you basically need to turn all the typescript features off. That said, maybe it's more "sugar" and less "fork", same as jsx. Thanks for the perspective adjustment. Much appreciated. 
OK - You still have spaces in your &lt;form between method="post". I removed your &lt;html&gt;&lt;head&gt;&lt;body&gt; tags...just keep your html with the &lt;form&gt; and your &lt;script&gt; tags. There was another syntax error in your javascript with "getElementByID" instead of "getElementById" Once I changed all of that, the script is now *working*.
https://github.com/Sly777/ran/releases/tag/0.3.0 Finally, RAN! has authentication module! Production-ready boilerplate with support for GraphQL, SSR, Hot-reload, CSS-in-JS, caching, and more.
No, you actually can do that. I have a project that's hybrid js/ts and all of the js runs through the ts compiler. It's not sugar, it's a superset. Sugar would be like adding a babel plugin. JSX is also not comparable to typescript in that regard, because it is syntactic sugar.
https://jsbin.com/kuviqebujo/edit?html,output I have fixed that now and it still does not work. 
could your title be less vague? no.
Yes, originally we have missed it but later we talked with the author of the tool and added it. It is not easy to have a complete picture of the field and there are always interesting things that can escape, that is why we strive to get as much feedback as we can to improve our articles.
It's not "_the_" JS docs. It's _a_ set of documentation for JS. Mozilla's mission is to push the Web forward, and as part of that, they have done a lot of work to try to maintain their own set of publicly available and community-updated docs on JS, the DOM APIs, and other aspects of web development.
Yes, it could be. Could your response be any more helpful? 
What?
Still, I don't see any problems since we are still expecting numbers only. If `arr.length === 1`, reduce always returns `arr[0]`
"Javascript" is Oracle's property and only Mozilla has rights to use that name "Javascript" and so they are the only one company which was able to make great docs and use the name JavaScript. There is also JScript by [Microsoft](https://msdn.microsoft.com/en-us/library/72bd815a(v=vs.100).aspx) but to good of web there is tc39 community which standardize the language as EcmaScript - ES so all major browser engines can run any js code. But still some browser engines can have different behaviors on each code so you can use polyfills or check your syntax from https://caniuse.com/ for each browser. 
That's pretty interesting, I'll check Signet out, though I don't know how other type systems solve the problem other than using a `newtype` in Haskell as a tag to signal to users that your values have been verified in some way. That's something we've been interested in for a while. We've had requests for range types in TypeScript as well, though we've hesitated because of the guarantees we can make with IEEE floating point numbers being the all-encompassing `number` type in JavaScript. Right now we do provide literal types that you can use in union types (e.g. `1 | 2 | 3 | "four"`), but I definitely get why ranges are useful.
I see. Thank you!
JavaScript is not owned by anyone. Is a public language that is standardizes by Ecmascriptd
Spams alert windows
Thanks, will fix!
i &lt;3 JavaScript, but this is about what I'd expect a big Data project to look like. thanks, gl!
There are a few widely-used libraries that include a whole plethora of such utility functions: - [Lodash](https://lodash.com/) - [Underscore](http://underscorejs.org/) - [Ramda](http://ramdajs.com/0.21.0/index.html#)
X-Post referenced from [/r/webdev](http://np.reddit.com/r/webdev) by /u/J-Kob [Build a Serverless Live Blog System with Flybase, Twilio, and StdLib](http://np.reddit.com/r/webdev/comments/6pa6n0/build_a_serverless_live_blog_system_with_flybase/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Big fan of flow. Its not perfect but its made my life a whole lot easier on recent projects.
Do you use flowtyped too ?
Yup. Apologies for the brief reply but I'm on mobile where code authoring is difficult. 
Angular 
I was hoping to avoid libraries, but if that's the only way to go... Thanks for the tip.
Because Mozilla invented Javascript. ^technically, Netscape invented Javascript, then spun off Mozilla to continue supporting it when Netscape was acquired by AOL.
Javascript was created *at* Mozilla (formerly Netscape) From w3c: &gt; JavaScript, not to be confused with Java, was created in 10 days in May 1995 by Brendan Eich, then working at Netscape and now of Mozilla. JavaScript was not always known as JavaScript: the original name was Mocha, a name chosen by Marc Andreessen, founder of Netscape. https://www.w3.org/community/webed/wiki/A_Short_History_of_JavaScript
You'll find that JS, quite intentionally, does not include a bunch of these utility functions out of the box. You'll very soon become very accustomed to using third party libraries from JS's vast open source ecosystem. :)
not a new idea. keith cirkel wrote about this [back in 2014](https://www.keithcirkel.co.uk/why-we-should-stop-using-grunt/), long before npm even had flat dep trees. if you want a single good reason (even though there are many) for why gulp &amp; grunt were so widely used (and still see love from projects like typescript), it's because documenting npm scripts is hard. you can't leave comments in `package.json` (at least not in any seriously usable format) and rolling your own build scripts is both one step removed from gulp &amp; grunt and fifty steps harder. meanwhile business is breathing down your neck, they want to add five developers to "help" with the work, and the finer details of how the project is built is considered nothing next to how badly they want saleable product _yesterday_. (oh and by the way, did i mention those five developers have next-to-no command line experience, even with git? and if they complain about how hard it is to get set up, regardless of how correct you might be for setting things up this way, it's automatically your fault for "overcomplicating things"? yeah, let's stick with standard/semi-standard tooling &amp; call it a day. no one likes private meetings with management over "job performance".)
You forgot "Install One Dark Pro" theme to get rid of the ugly blue bar
Looks useful. But what if I just want cats to be Array&lt;{ name: string }&gt;?
You're looping over an array not an object. Try using forEach instead of for in.
I like it! My main concern is "lambda all the things" needs some caveats too, mostly in the area of performance. As long as I can drop to WASM (or something that transpiles to wasm) when needed (without a lot of call overhead) it'd be ok.
Because it's an array you are looping through, the `obj` variable will be the key in the array. If all you are trying to do is change the value to null, change the `obj` variable to be `key` for readability and assign `arr[key] = null;`
It already is. You're just inlining the definition of the `Cat` interface.
I kinda like the blue bar 😅, why is it annoying ?
But sometimes I don't want a Cat interface. In that case it's just namespace pollution. An option to disable that would definitely make me use this tool. I've wasted way too much time on doing this by hand!
I feel like the best way to pass a javascript interview is to know javascript.
It's too distracting IMHO
What does Flow offer you that Typescript wouldn't? For the record, Typescript completion and type checking is blazing fast in Webstorm. And I have a dinosaur of a computer.
Spot on. I love Aurelia and use it for all appropriate projects, but IMO it's not getting traction largely due to the boneheaded choice of Gitter as the primary communication method. Gitter has no meaningful search and there's no way to "sticky" topics like you would in a forum to make sure other sources of knowledge are able to be easily linked to. That combined with the so-so documentation leads people elsewhere because they don't want to get stuck 90% of the way through a project.
USE THIS SIMPLE TRICK TO PASS ANY JAVASCRIPT INTERVIEW: "I PREFER NESTING CALLBACKS INSTEAD OF PROMISES AND I DEFINE EVERY VARIABLE IN THE GLOBAL SCOPE" ^^^ FULLPROOF BELIEVE ME
For me there are two things. Typescript is a language and has its own file extension. I don't like that (you remember coffee script?) in Flow you just add annotations that get excluded from the code at the end by babel, and I already have babel in my codebase, even if you don't like that, you can put your annotations as comments. Then your js file remain a valid js file.
The height issue is the biggest problem with iframes. There was a `seamless` attribute being considered at one point that would give them automatic heights, but for some reason has now died.
Ehm, you forgot to add an important rule: never give too long names to those variables. One letter is best, two is descent, three is way over what you might ever need. 
Definitely a shift in thinking!
You can implement by yourself to avoid libraries: Some insights: const array_diff = xs =&gt; ys =&gt; xs.reduce ( (acc, x) =&gt; (ys.some(y =&gt; x === y)) ? acc : acc.concat(x) , [] ) const array_interspect = xs =&gt; ys =&gt; xs.reduce ( (acc, x) =&gt; (ys.every(y =&gt; x !== y)) ? acc : acc.concat(x) , [] )
&gt; I have to write loops from scratch to deal with it really you only have to do it once, put it in a function.
and if your one letter is of the form of an emoji such as `window['😀'] = 5;` then you typically get hired on the spot!
TS actually does offer [checking of JS files](https://github.com/Microsoft/TypeScript/wiki/Type-Checking-JavaScript-Files) without a .ts extension, much the same as Flow. It remains valid JS, and you can sprinkle as little or as much type hinting as you want with JSDoc comments.
Conducting yourself like this isn't going to get you much real help around here. It also creates an audit trail of you having poor communication skills and having other people do your homework.
Ok, but now after I set null to the objects, only the references to the original object in the array is null, how can I make the actual objects null? It seems like the objects are being duplicated like primitive objects such as a number instead of referenced. https://jsfiddle.net/xr3sgg9v/4/
I thought typescript interfaces/types disappeared at runtime, so why would I need to know the interface at runtime? 
This kind of looks more like "generate interfaces / types" from JSON once, then you're done... So let's say you receive some JSON from an API and you don't want to read through the API response just to construct some class to have your autocompletion, then you use this and done. After that, you're free to declare whatever you want but at least if you're sure the API responds with a `cats` object then the IDE can autocomplete the properties for you I might have misunderstood what it's for.
This and /u/scotchanddonuts answers are right. In fact a lot of the original Netscape documentation can still be seen in today's Mozilla documentation. Compare: https://web.archive.org/web/19990908094321/http://developer.netscape.com:80/docs/manuals/js/client/jsguide/fcns.htm and https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions
Flow also uses type annotations. https://flow.org/try/ &gt; function foo(x: ?number): string { That's not valid JavaScript. Its analyzer does understand doc comments, too, but so does TS' analyzer. E.g. when you write JS in VS Code, it uses TS' analyzer for code completion etc and if you feed it some bloaty JSDoc comments, it will happily consume them: https://i.imgur.com/1rp7jLG.png I prefer using type annotations, though. They are terser and less annoying to write. I also think it's wrong to use comments for some weird "type language" with its own syntax which isn't checked since... well, it's a comment. To me, that's not an advantage.
Note that if you use http://styled-components.com, you also get only the CSS in use.
You're genius! I would call this language emoji-script (too bad you can only use it as keys, not as variable names, so this one won't run, but it should have printed fibonacci.): const [😎, 😁, 😂] = [0, 1, 2]; const 😀 = (⚽) =&gt; ⚽ &lt; 😁 : 😎 : ⚽ &lt;= 😂 ? 😁 : 😀(⚽ - 1) + 😀(⚽ - 2); console.log(😀(2));
Foolproof. "So safe even a fool will succeed."
https://github.com/ramda/ramda/blob/master/src/internal/_curryN.js#L37 https://github.com/AvraamMavridis/javascript-decorators/blob/master/src/%40after.js#L30 https://github.com/antivanov/jsAspect/blob/master/src/aspect.js#L169 I could go on. I literally cannot think of any other way of implementing these behaviours without `apply`.
Found the Haskell/Elm user. Teehee.
That is because the values in that array are just a copy of the reference to the object. It's not the actual object value or the original pointer. If you attempt to modify one of the properties, it will use the copied reference to find the object and modify it (which the original reference shares) but the reference won't actually be tied to the original reference. Essentially your`a, b, c` variables will not be changed when dealing with that array because the array just has copies of them, not a reference to the original variables.
&gt; Originally posted on: samueleresca.net Please post the original version. Thank you.
As a huge fan of functional programming I'd mostly solve such a task like this `arr = arr.map(item =&gt; null)` Hope this is helpful somehow
So basically, if I want to assign null to an object, say for the purpose of memory management / garbage collection, I can only do something like this: this._element = document.createElement("div"); this._element = null; //cleans up memory and never something like this: this._element = document.createElement("div"); const element = this._element element = null;//object that took memory is still alive Essentially it's impossible in JavaScript to iterate over a group of objects and assign them as `null`?
Super cool. Seems useful as a first step in refactoring old APIs.
I still can't seem to null the actual objects outside of the array using this method. Can you show me working code?
I feel like you're looking for a `weakMap`. I'm not entirely sure, because I haven't used them, but hopefully this helps. https://ilikekillnerds.com/2015/02/what-are-weakmaps-in-es6/
Impossible or it will big security hole for internet.
Yeah thats what I was thinking also. Just needed some confirmation. Thanks!
You could also put this in your user configuration to override the theme styles. "workbench.colorCustomizations": { "statusBar.background": "#000", "statusBar.debuggingBackground": "#000", "statusBar.noFolderBackground": "#000" } 
I would imagine you could do some stuff using Selenium. 
JoJo reference?
So I'm trying to deliver a site that automates this stuff. The end user is quite non-technical so I was trying to find a way to implement this as simply as possible. Could Selenium run in some sort of container than can be invoked from a client browser?
Of course the Canadian wants to name variables with the smiley face emoji; username checks out.
I ALSO LIKE USING ES19995 WHICH IS MY OWN IMPLEMENTATION OF EMCA SCRIPT WHERE I INCLUDE NOT ONLY THE APPROVED FEATURES BUT ALL OF THE UNAPPROVED FEATURES!
I believe that typescript is a superset of Javascript. Technically they implement things that the Javascript language doesn't have yet. (on top of annotations). So I think it does count as a different language. 
Stop calling these things "serverless". The correct naming is SAAS
I prefer TypeScript, using it with React. I just compile it down to ES5, no need for Babel etc. Tried Flow and like that too but I feel more comfortable not switching as I don’t need to.
&gt; how can I tell which framework will definitely suit my need? Well, what are your needs?
Yes. Given the name of the library, i thought it would be a nice touch to follow in the footsteps of Vue's x.0 release titles.
this was already posted here a few weeks ago
Yes, this tools purpose is not to generate types and use them at run time, but to provide a tool for user to automate interface creation which is long and tedious work when working with large JSON responses, and then use them in a project for autocompletion, enhanced refactoring and so on. Some of examples where this can be useful: 1. generate interfaces for api responses 2. generate interfaces for mongoDb collections, 3. used as a nice addition to documentation generation.
But sometimes you don't know what you need to know. You learn what you need to for the job, and unless you devote yourself to spending more time working on your job outside of your work hours (which is not something you can do), there'll be gaps in your knowledge that aren't a problem in your current job, but a new job won't like
Since I am seeing some interest in this post, I will include my VSCode extension using this library. [JSON-to-TS](https://marketplace.visualstudio.com/items?itemName=MariusAlchimavicius.json-to-ts)
Absolutely this, if you have already solved your problem once there is no need to solve it again. No need for lodash if your own implementation works.
Flow would as well by your definition.
This could maybe help? https://medialab.github.io/artoo/
I'd love to see the project. Is it on github or somewhere else public?
Been looking at that. Still requires some manual interaction. Was hoping to automate it. 
You'll really impress if all your code is made `with(♥️)` !
This method doesn't modify the objects themselves, it creates a new array filled with null.
I need a frontend to create an SPA that can submit a web form to a backend, where some quick calculation will be made, before sending it back to the same page again. I also intend to incorporate a library for an additional step in processing the data before handing it to the backend as well, although it's more of a stretch goal right now as I'm trying to get a minimally viable product in place first (ie. basic data submission).
Not quite. If you strip Flow types then functionally nothing changes at all. If you remove some of the TypeScript constructs, for instance enums, your code no longer works. This makes it more than "annotations".
I started with Angular 1.5 which was cool, not a fan of 2+ though. Now I just use React for everything. 
The original library is cool but a vscode extension sounds amazing.
It gzips better!!!
Thanks! Didn't see that one.
Yes, Google for typescript and you'll find it on GitHub.
i don't get it, this is pointless and it's not impressive... why exactly is this so heavily upvoted, am I missing something?
Or for of
Generally speaking, enums should be avoided unless you actually need to enumerate over the values in the set at runtime. A union type is preferred for most situations, as those are erased at runtime. 
Meteor
&gt;Now I just use React for everything. Based on /u/Vpicone advice, this is what I'm looking toward as well (React's en vogue lately). I also attended a workshop about it last week, so you could say I have some vague idea about it.
Flow type supports annotating functions within comments, allowing you to write valid js. https://flow.org/blog/2015/02/20/Flow-Comments/
You can do that with any library. React, Vue, Angular, Ember, Marko, etc. Since you are a beginner I'd recommend you to try Vue. The docs are nice, and you can create a project from scratch with Vue CLI.
Ok. Well, I'm trying to assign null to the actual objects. The array itself and creating new copies of the objects isn't important. I want to find a way to iterate through a bunch of objects to assign `null` to them, for example, to clean up newly allocated objects in memory. for example, let's say I create a bunch of objects that that should be nullified when i'm done with them. let a = document.createElement("div"); let b = document.createElement("div"); let c = document.createElement("div"); let d = document.createElement("div"); let e = document.createElement("div"); Since I just want to assign `null` to each of them, ideally i'd like to put them in an array and loop through each one to do so. 
came here to say this
I mentioned that.
Nope. Getting an object from a weakmap is read only. This doesn't work: const wMap = new WeakMap(); let el1 = document.createElement("div"); wMap.set(el1, "1"); wMap.get(el1) = null; //error, left-hand assignment
Uses 3 different online backend/cloud providers each powered by 100s of servers in total to build a blog -- "serverless".
I'm impressed. I would have no clue where to start with something like this 
what's stopping you from running a server that does this, and having your client website interface with that?
Garbage collector will clean up memory if there is no reference to the object anywhere. let a = new MyClass("hi"); let b = new MyClass("Hello"); let c = new MyClass("Howdy"); let arr = new Array(a, b, c); b = null; // at this point there is still reference to object b in arr arr = null; // at this point there are no references to b, so garbage collector will clean it up, but a and c won't be You can do this let arr = new Array( new MyClass("hi"), new MyClass("Hello"), new MyClass("Howdy") ); arr = null; From your example this._element = document.createElement("div"); let element = this._element; element = null; //object that took memory is still alive this._element = null; // object can be garbage collected now Check [MDN: Memory Management](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management)
- Async Functions - Object.values() and Object.entries - Trailing Commas in Function Parameter Lists - String Padding - Object.getOwnPropertyDescriptors() - Shared Memory and Atomics
Join the conversation on Hacker News - https://news.ycombinator.com/submitlink?u=https://edgecoders.com/whats-new-in-es2017-or-es8-for-javascript-40352b089780&amp;t=What%E2%80%99s%20New%20in%20ES2017%20(or%20ES8)%20for%20JavaScript
&gt; A union type is preferred for most situations, as those are erased at runtime. TS also has const enums which do not result in additional generated code. https://www.typescriptlang.org/docs/handbook/enums.html
Excited async functions made it to the standard
This is great - I love the way the article/image builds. The lines on the original aren't random, they're a plot of a signal from a pulsar. There's a really great post about it here - https://adamcap.com/2011/05/19/history-of-joy-division-unknown-pleasures-album-art/
Copy pasted from my comment on r/webdev: "I agree it's a misleading term, but it's what Amazon and other co's are pushing now and what people have seen before. It's more "serverless" in the sense that you don't have to think about scaling, configuring, or over/under-provisioning servers and paying for capacity you're not using. It's is a cool concept, but yes, there are still servers running somewhere." I think function as a service (FaaS) is a more accurate description.
I can definitely understand the challenges you would face while working in a static context. Numbers are a bit challenge, and even now I'm still digging up edge cases and providing ways to get runtime guarantees around various types. At work I've been encouraging some of my teammates to use Signet and Typescript together to solve some of the blended static/runtime type problems they have been encountering. I really appreciate your thoughts and time. I'm glad Typescript is getting people thinking about types and what they mean in a "Javascript" environment. 
@oorza Could you explain to me the advantage of using `onlyReduce()` as what is seemingly a curried function rather than just passing the arguments together in this particular case. I do understand currying and closures generally, but I typically find very few use cases for them in my actual run of work.
thank you
In all three of those you are simply using the apply method to informally inject an array into a function. I personally consider that sloppy from a performance perspective. The number of arguments accepted into an array should be a fixed number and the data types of those arguments should be static in order to achieve the most out of JIT compilation. In cases where I need to pass an unknown number (or data types) of arguments into a function I pass in a single object literal as a formal argument on the function. This is kind of old school, but it is performance safe and scales very well at maintenance time. var myArguments = {}; var something = function(myArguments); Inside the function you have a single known data type with a bunch of unpredictable stuff hanging off it. You could even populate that object literal in a loop using array notation like: `myArguments[property[x]] = someValue;`
Ken Wheeler screams in a forest somewhere in New Jersey while shooting a cross-bow into a chrome logo'd target.
I hope you'll eventually agree that it's a *good* shift. One of PHP's biggest problems, in my opinion, is that everything comes standard. If you want to upgrade a library, then your best choice is to install a newer version of the language. This really isn't the way things are done in a modern programming language. This really wasn't a huge problem until the decision to include Libsodium in PHP 7.2. Not having the latest string manipulation functions is one thing, but not being able to fix a vulnerability in the core crypto library without 1) waiting for PHP to release a version with the fix and then 2) upgrading the entire language (or worse - waiting for your Web host to)? I don't keep up with PHP, but I hope they either decide or already have decided to not go forward with such a backwards plan. Enjoy the flexibility of being able to use libraries that suits you, code you like, instead of whatever the language maintainers force upon you.
This is going to save me a bunch of work on a project I'm working on. Thanks for making it and thanks for sharing! I'll make sure to contribute back if and where I can.
Unfortunately seems to be broken now, but someone did a [glsl version](http://glslsandbox.com/e#14007.6) a few years ago.
I meant on top of the annotations. Flow literally just removes annotations, and then it is valid Javascript. Typescript transpiles to Javascript, doing more than just stripping the annotations. One example (from the past) is that in typescript you could use async await, even though Javascript hadn't implemented it at that point in time. Typescript literally gives you features (on top of type checking annotations) that Javascript doesn't have. Flow does not do that. 
It just missed the deadline for ES2016. iirc it was in stage-3 right before the deadline. So close!
This should really be a fairly trivial task in any language. If you're going to do it in JavaScript, it will need to be done in node (browser-side doesn't have access to the file system). You just need to read the JSON, iterate over each item and delete. In node it should take about 5-20 lines of code depending on error checking needs and such. If write something up now if I weren't on mobile. I'm sure in python or go it would be just as easy, but I don't know enough about either to say more about them. You just need to read the JSON, iterate over each item and delete. Take a look at the node js file system module in the docs and read up on array.forEach. That should give you everything you need to know. FYI, however, what you posted there isn't valid JSON. You should have double quotes around both the keys and the string values. Also, you can't use the same key within an object. You probably want to format it as an array. I'd be glad to provide feedback/assistance tomorrow if you need it.
I guess we should all watch this because at the rate JS frameworks move there's a new framework every few months... So we go from senior developer back to junior developer whenever we try and switch jobs. For example, if I've been working in same job for 3 years and only used vanilla JS and jQuery. Since then React has come out, Vue, Angular 2.0 bla bla bla. New job listings now requiring skills in React etc. Now I'm back to "junior" developer because I have no job experience with any of that new stuff. But guess what I'm "senior" enough in vanilla JS to make my own SPA or framework. Also I know for a fact I don't even need a short-lived flavour of the month framework from someone other company to make sites or apps properly.
It's not just annotated JavaScript, you will have to change your imports if you're adding it to an existing codebase which uses Babel, it won't provide interop with ES5 exports and even has its own TypeScript-specific way you'll have to write certain imports: `import foo = require('foo')` Flow is much easier to integrate, but TypeScript's editor support is on another level.
Flow needs the .flow extension in some cases, like if you want to publish to npm and include types. (I don't know of a tool that can generate type declaration-only files.)
If you've been developing all that time, you're certainly not going to revert to jr dev status just because you don't know some framework. But yeah, we're in a profession that requires continuous learning, and experimenting with new technologies as they emerge. It's a PITA to learn new JS frameworks, but being familiar with their core concepts pays off. We're finally emerging from the crazy years of getting a new "ultimate" framework thrown at us every few weeks. The three main players are React, Vue and Angular 2 (now 4...or is it 5?) as far as I can tell. Having to learn Angular 2 for a job last year and React for a job this year has forced me to *really* learn JS (...and node...and npm...and webpack...and...and...). As much as I loved jQuery, I used it as a crutch for far too long. After seeing how much faster and more solidly I can build apps using a framework, I'm never going back. Give those frameworks a shot, yo.
This is absolutely true. I am in a constant state of back-filling gaps in my knowledge, despite working the front ( and back ) end of the web for one and a half decades. I remember looking up "closures" in 2009 and going "I really feel like I should know this". LOL
Great write-up! Very interesting
It adds enums and interfaces, among some other things. Definitely treads the line a bit
&gt;&gt; There's no manual concatenation or accumulator variables, and the name of the functions tells you what it's doing. The code also tells you what it's doing pretty clearly, I don't think your unfamiliarity with an approach can be used as an argument against it. &gt; You're right that reduce might be more performant here. I'd say it's pretty clear, especially when dealing with large data sets. The difference between 10k and 20k iterations can be pretty massive. In real world scenarios where people abuse the ever-loving shit out of lodash's chain method, I'd say it's not unlikely to be talking about an order of magnitude. &gt; I'll take the more readable and maintainable version I'd agree with you here, I guess it's just personal preference here since one is clearly not more readable or maintainable, at least to me. I don't usually write one-liners like that in any case. I much more often would just write something like below const users = [ {score: 10, name: "melissa"}, {score: 12, name: "jake"}, {score: 9, name: "chris"} ]; // Array -&gt; User const get_winner = users =&gt; users.reduce((acc, user) =&gt; { return user.score &gt; acc.score ? user : acc; }, {score: 0}); module.exports.get_winner = get_winner; Where this would be exported with a group of other pure functions. I get that map/filter can look nicer on occasion, but I actually don't even think there's a method using map/filter to achieve the above result. I would argue that *especially* in more complex examples, reduce is often times a much cleaner and elegant solution than iterating over an array dozens of times, but again I think it just comes down to personal preference.
You know Java and JavaScript have no relations right?
&gt; The code also tells you what it's doing pretty clearly, I don't think your unfamiliarity with an approach can be used as an argument against it. I'm plenty familiar with reduce, (particularly in the context of LISPs where it's a lot more necessary) I just don't think it reads very well. And, I gave specific reasons, too: I didn't just give a fuzzy "I don't like this code". It has more variables, and more operations going on in the code. It doesn't seem that opinionated to say that a named filter function is more obviously readable than a hand-written bit of filter logic inside a reduce function. &gt; I'd say it's pretty clear, especially when dealing with large data sets. The difference between 10k and 20k iterations can be pretty massive. 99.9% of my JS coding isn't dealing with "large data sets". And if you want to eke every bit of performance out of those cases: don't use reduce either. I'm pretty sure a standard `for...of` loops is going to be even more performant than `reduce`. (Since function invocation usually carries a bit of a performance penalty with it) Like: const getWinner = users =&gt; { let best = {score: 0}; for(user of users) { if(user.score &gt; best.score) { best = user; } } return best; But, again, given that I'm not dealing with thousands of item data sets, as for how I'd write it? const getWinner = users =&gt; _.maxBy(users, 'score'); Just like the `groupBy` example of the original post, there's a higher abstraction here than `reduce`, and I'd rather write my code in terms of the higher abstraction. Basically, for me it largely falls out into two camps: times when the `reduce` operation can be split into a number of smaller simpler operations (e.g. splitting your original reduce example into `map/filter`), and times when the `reduce` operation can be converted into a higher abstraction like a `groupBy` or a `maxBy`. Most times I've thought ("Should I use `reduce`?) it's fallen into one of those two groups, and so I generally end up not using `reduce`.
JavaScript _is_ a trademark of Oracle.
Interesting library. I'd like to know how it compares to [Immutable.js](https://github.com/facebook/immutable-js) in terms of speed, memory usage, and garbage collection churn.
&gt; tsc --checkJs Sure, but isn't this fairly new? You can't blame people who aren't interested in typescript to know about something MS released a couple of weeks ago. I feel like this should be a standard disclaimer on anything like this. OP is at 1 upvote for no good reason. 
This is correct, although I was surprised to learn it. TIL. 
Hey, you're right!
Oracle does not actively enforce this trademark. It can very well as invalid now.
just say - "Javascript n Java is same"
X-Post referenced from [/r/gamedev](http://np.reddit.com/r/gamedev) by /u/wqking [Jincu -- an open source 2D game engine and framework written in JavaScript ES6](http://np.reddit.com/r/gamedev/comments/6pdw6c/jincu_an_open_source_2d_game_engine_and_framework/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
I agree with what this guy said. I was all vanilla and mixed in some jquery. Took up React. It's amazing 
If you are considering Java, then Play framework is a good choice.
Again, it seems like preference to me. But I see your point. Just as an aside, i think you want `_.maxBy(users, _.property("score"))`.
I'm not blaming OP for not knowing about it, I am simply informing him of it. Don't read too far into what I said.
That's equivalent, lodash allows strings to be used as shorthand for `_.property`, as well as stuff like `_.find(user, {name: 'Joe'})`, as shorthand for `_matches({name: 'Joe'})`. 
I dunno, that's the interface OP started with and I was trying to make just one point, not two :P I originally had a note about what you just said, but I got rid of it to try and make my post cleaner.
For a developer tool, handling some 300 small files node might be okay, but if it needs to go through thousands of files, or large files, I would better use something like Go. Node's strength is handling many requests, filesystem operations are generally speaking faster in other languages.
Well it does already, per my original post text: I'm running scraping operations through AWS Lambda. However, there are a handful of sites that are refusing the connection or straight up throwing 403s at me. Those very same sites work in ancient browser, hence the interest in automating the client browser. 
That `import` mechanism is a generalized way of importing that directly maps to CommonJS and AMD imports. It predates ES modules and you don't necessarily have to use it.
i'm hoping that Browser As A Service becomes a thing, so i can have a live serverless *and* clientless blog. all in the cloud, of course. and powered by big data with ML.
Those objects will be eligible for collection by the garbage collector as soon as those "let" declarations fall out of scope. You don't need to assign null to them unless you want them to be collected quicker than that. 
If you want opinions on your code upload it to githubpages, heroku, now, surge, or some other platform. You’ll get way less feedback if you require people build it themselves. 
After I have spent some time researching, I think I'm going to actually learn React since it opens more door for me in terms of being employable. Thank you for your suggestion, regardless.
It need not. Both the author and I want simplicity of development and maintenance. I am only saying that, if one is already going to be completely changing their modularity API for the sake of performance, why not use THE most performant method? In addition to being fast, I doubt one can do better than pure functions and plain objects when it comes to simplicity. And they are far more standard than any form of a class syntax in JS, be it ES6, prototypes, createClass functions, or closure objects. They're just functions and data to operate on. No implicit state (this). No construction (that you don't do yourself). No inheritance ("favor composition over inheritance"). Performance is not the most important thing, but it's one of the most important things.
Typescript generally only implements features that of stage 2 and above, especially when MS is likely to implement them in IE. The stance is quite safe, as they do not want to split the language.
I love the idea, hate the syntax. I bet we could have two different syntaxes on top of the same ast. I think this concept would more way more popular if the syntax was js like. I'm know you love your lisp, but let's be honest. Most ppl don't know it
Not quite the use case you're thinking of, but you could actually make something useful by running a headless browser like PhantomJS (http://phantomjs.org/) with a function as a service provider. It could crawl various websites and check for whatever you want, store the data in a backend as a service, then use big data techniques and ML as a service like Amazon Machine Learning to get valuable data from the results. It'd be BraaS powered by FaaS that uses MLaaS on data from a BaaS without managing a single server. It could actually be kinda awesome, I might build it.
http://s2.quickmeme.com/img/30/305b65deae0b613b4aff22354f3b16be251601f31d6d84fff844ca9ac7a11a15.jpg
 So I guess we all need to take back our down votes of /u/orenek?
Neat! Thanks a lot for the link.
This is really cool and takes a completely different approach.
Yay a 10 minute Bart ride 
Or just use, you know, regular JavaScript. Follow commonly accepted patterns and OO js. You'll learn soooooo much more from that than using a framework
Are they blocking the connections because: * you are sending bad user agent header * you are sending requests too often/fast * they have extreme rate limiting settings * they know AWS related IPs or know you are using Lambda by some header? Either way you could fix those issues on your part, also you could run headless browsers (e.g. Chrome) in containers which you could automate.
&gt; but isn't this fairly new? Yep, only since TypeScript 2.3 afaik
&gt; That's not valid JavaScript. But you can strip them to get valid JavaScript, and it doesn't overlap with languages features like TypeScript does (e.g. interface, enums). TypeScript is much more than JavaScript+Types.
There is also this great animated version (with music) also in JS using D3 and dancer.js : https://github.com/daliwali/unknown-pleasures
TS takes over the build system and serves the language like no other tool would, leaving Javascript years behind even for widely used or established specs, not to mention Babels eco system which isn't just for specs. Having to keep up with drafts puts a gigantic burden on the tools shoulders and impedes its primary job. Flow was built to integrate like any other tool. It does one job and does it well, detecting cases that TS wouldn't for instance. [A recent reddit-blog article explains this](https://redditblog.com/2017/06/30/why-we-chose-typescript/), Flow excelled in most categories, except 3rd party type support which is a bummer. Type converters already exist and this will hopefully not be an issue one day.
I have ruled out the first three of your call outs and have concluded that it is due to your last one. I've proved this by running he exact same code in my own terminal with successful results. Could you elaborate a bit more about your headless browser in a container? I mean, I understand both of those concepts (it's what I'm doing in Lambda), but I mean in terms of a container inside a client browser. Thanks!
Nice.
I edited my response (moved "(e.g. Chrome)" after browsers instead of containers) since I see it could cause confusion. You can still look into modifying the output headers on Lambda (not sure if you can modify all) or firing up a vps or some EC2 containers for handling the same functionality
Running the same code on EC2 is also blocked. Assuming still it is IP related.
Pretty useful! Thanks.
Great library! One thing bothers me though. Reducing the library size is great, but it shouldn't make the source code difficult to understand. Example: let a = Array.isArray let o = v =&gt; typeof v === 'object' // ... later in the code o(obj) ? k(obj).reduce((newObj, key) This kind of dev minification should be written with real, understandable variable names. Then the minifier will do its job to make the code smaller. Also, unreadable code will discourage developers to contribute to your library :( Keep doing good work!
Next step would be to generate an image like this from as user sound input or a file. I think I've seen that somewhere before – maybe as an old winamp visualiser, perhaps. edit: I see now that something like that was already posted here https://www.reddit.com/r/javascript/comments/6pbf14/reproducing_the_cover_of_unknown_pleasures_with/dkoqbwr/
http://keystonejs.com/
What do u mean bu build it themselves ? The code is on github click o the link
"Angular S" is top framework now a days...
He means you should make your app available online for us to click on and play around with, to give you an overall opinion. Most can't be bothered to download your code and install it on their computer.
Oh no i just want an overall opinion about the code and how i structured it ? How i did webpack config? Im not really asking about how the site looks because thats a simple app. Mainly i want people to look at my code.
Hey- thanks for the feedback and kind words! I totally agree that code should be readable but for the sake of keeping this all under a kilobyte (for fun, I should say) I was forced to break that rule. :'-( For some reason the `babili` minifier wouldn't mangle names at the module scope, hence having to do this myself prematurely in the code. Edit: after a quick search it looks like I can make use of [this babel plugin](https://github.com/babel/babili/tree/master/packages/babel-plugin-minify-mangle-names) and its `topLevel` option. Edit: done in v2.0.1 (https://github.com/sdgluck/mewt/pull/34).
I like your effort, but you should consider adding a chapter with infos about regexes in regards of javascript otherwise IMO the guide doesnt really belong to this subreddit ;).
don't be evil :)
A lot of devs are moving over to VS Code
Oh yes, PHP and its 45,000 built in functions... What you want is lodash, where you can import only the functions you need. Namely, [_.difference](https://lodash.com/docs/4.17.4#difference) and [_.intersection](https://lodash.com/docs/4.17.4#intersection). There are plenty other functions in there. There are many other options too, but lodash is the most widely used and it's not _too_ "weird" if you are not used to / interested in FP
Worth noting that lodash is a "better" version of the older underscore, and ramda is a fully FP so I would avoid unless that's what you are specifically interested in
What is prefixing the setInterval call with "timer " supposed to accomplish? Also, you are declaring some variables "timer", "timerTwo", and "timerThree" but apparently not using them anywhere. The JSfiddle isn't opening for me so I can't test.
"TypeScript is a free and open-source programming language developed and maintained by Microsoft." While Flow tries to be only a pluggable type checker that you can simply add or remove, I don't feel the same about Typescript.
I've been always thinking why projects like Angular Universal didn't implement the browser in the backend to pre-render the page. Are there any advantages/disadvantages when using presite?
&gt; It does not suite large website that heavily depends on async data, use SSR instead. I guess I've answered my question.
It's pretty cool. How are you storing the text/code? I see that's it's using an api, so it's pretty advanced, not reading from text files
What are you most excited about for ES9?
`import()` and the spread operator for object properties.
Thanks :) All data is stored with [contentful](https://www.contentful.com/), a free CMS, and then pulled in via their api into an abstraction API layer I created, accessible at https://ecmasyntax.io/api ([list of all pages](https://ecmasyntax.io/api/pages))
Well, that's still not the reason that MDN is the only major docs site, since Oracle doesn't enforce it. 
Ah, but the iceberg analogy works both ways, which is why I'm more than confident that it's a really good sample, reflective of the state of affairs. Because for every active user there are dozens of "lurkers" that utilize the same tech stack and just silently read and use what has been posted. And the sheer amount of those lurkers would likely drown (statistically speaking) the "deep majority" that you believe exists outside that sphere. Web and mobile are really that big, no way around it. I'm not saying JS all things or anything, I'm just saying that it's probably how things truly, really are in the wild, to the best of our limited knowledge.
Have you heard of usus prior doing this? https://github.com/gajus/usus usus uses Google Chrome to pre-render pages. You can see an example of a pre-rendered page here, https://go2cinema.com/movies/war-for-the-planet-of-the-apes-2017-1000616. There is a full article about it https://medium.com/@gajus/pre-rendering-spa-for-seo-and-improved-perceived-page-loading-speed-47075aa16d24
+1 to those, I can't live without them already.
Nice work! Bug report time: it looks like scrolling doesn't work in Firefox
My favorite theme. I use this both at work and at home. one thing that bugs me is they have italics by default so I override them, but they have updates every single week so I keep having to override manually every time I update.
Here's another approach and write-up from 2013 http://benjaminbenben.com/2013/10/21/unknown-pleasures/
thank you for the response. i'm familiar with array.forEach and map, etc., but i think i've just been a little over analytical with number of lines of code this should take. (off topic - but are double quotes a necessity with json key values? because my eslint rules don't absolutely say quotes are required at all..., again, i'm not an expert) 
thanks! ideally i would have this run as a build process, like a validation tool. good to know there might be performance hits, so that is something to take into consideration. hadn't thought of that before...
Hello mate I haven't see you since that StackOverflow thread 
I think I fixed the JSfiddle issue. Here's the link: https://jsfiddle.net/kyewhsm5/2/#&amp;togetherjs=ezROJEPc0t
Glad I could be of help! You're welcome!
You're welcome!
Here's my updated code: HTML &lt;div id="group1"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="1.html"&gt;&lt;img src="https://upload.wikimedia.org/wikipedia/commons/thumb /f/ff/Solid_blue.svg/2000px-Solid_blue.svg.png" alt=".jpg" title="www..com"&gt;blue&lt;/img&gt; &lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="1.html"&gt;&lt;img src="http://www.solidbackgrounds.com/images/1920x1080 /1920x1080-red-solid-color-background.jpg" alt=".jpg" title="www..com"&gt;red&lt;/img&gt; &lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id="group2"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="1.html"&gt;&lt;img src="https://upload.wikimedia.org/wikipedia/commons/thumb /0/09/Solid_yellow.svg/1024px-Solid_yellow.svg.png" alt=".jpg" title="www..com"&gt;yellow&lt;/img&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="1.html"&gt;&lt;img src="http://www.solidbackgrounds.com/images/2880x1800 /2880x1800-amber-orange-solid-color-background.jpg" alt=".jpg" title="www..com"&gt;orange&lt;/img&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id="group3"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="1.html"&gt;&lt;img src="https://umad.com/img/2015/11/thumb/green-solid-color- wallpaper-986-1057-hd-wallpapers-thumb.jpg" alt=".jpg" title="www..com"&gt;green&lt;/img&gt; &lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="1.html"&gt;&lt;img src="http://www.qygjxz.com/data/out/206/4314753-silver- background.png" alt=".jpg" title="www..com"&gt;silver&lt;/img&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; CSS: #group1{user-select:none; width:100%; padding:0; margin:0;} #group1 ul{height:153px; width:auto; border-radius:10px; border:2px solid rgba(0,0,0,0,0.5); list-style- type:none; background:rgba(0,0,255,0.7); margin:15% 0% 0% 0%; overflow:hidden; padding:2% 0% 10% 0%;} #group1 li a{transition:0.25s; border-radius:5px; border:2px solid rgba(0,0,0,0.0); color:#e5e5e5; background:rgba(0,0,0,0.5); width:24vw; height:11em; display:block; text-decoration:none; font-weight:bold; font-size:3.8vw; margin:6% 6% -2% 0%; overflow:hidden; word-wrap:break-all; padding:1% 0.3% 1% 0%; float:left; position:relative; left:4.7%; text-align:center; line-height:1.2; text-shadow:1px 1px 2px black,1px 1px 2px black,1px 1px 2px black; } #group1 img{width:23vw; height:70px; float:left; margin:-4.5% 100% 4.5% 0%; border-radius:7px; border:2px solid rgba(0,0,0,0.5); position:relative; top:5px; } #group1 li a:hover{border:2px solid rgba(80,80,80,0.9); background:rgba(20,20,20,0.7); transform:scale3d(1.1,1.1,1.1); z-index:2; color:white; } #group1 li a:active{background:rgba(60,60,60,0.9); opacity:0.8;} #group2{user-select:none; width:100%; padding:0; margin:0;} #group2 ul{height:134px; width:auto; border-radius:10px; border:2px solid rgba(0,0,0,0,0.5); list-style-type:none; background:rgba(255,0,0,0.7); margin:0% 0% 0% 0%; overflow:hidden; padding:2% 0% 10% 0%;} #group2 li a{transition:0.25s; border-radius:5px; border:2px solid rgba(0,0,0,0.0); color:#e5e5e5; background:rgba(0,0,0,0.5); width:24vw; height:11em; display:block; text-decoration:none; font-weight:bold; font-size:3.8vw; margin:0.5% 6% 1% 0%; overflow:hidden; word-wrap:break-all; padding:1% 0.3% 1% 0%; float:left; position:relative; left:4.7%; text-align:center; line-height:1.2; text-shadow:1px 1px 2px black,1px 1px 2px black,1px 1px 2px black; } #group2 img{width:23vw; height:70px; float:left; margin:-4.5% 100% 4.5% 0%; border-radius:7px; border:2px solid rgba(0,0,0,0.5); position:relative; top:5px; } #group2 li a:hover{border:2px solid rgba(80,80,80,0.9); background:rgba(20,20,20,0.7); transform:scale3d(1.1,1.1,1.1); z-index:2; color:white; } #group2 li a:active{background:rgba(60,60,60,0.9); opacity:0.8;} #group3{user-select:none; width:100%; padding:0; margin:0;} #group3 ul{height:134px; width:auto; border-radius:10px; border:2px solid rgba(0,0,0,0,0.5); list-style-type:none; background:rgba(0,255,0,0.7); margin:0% 0% -1% 0%; overflow:hidden; padding:2% 0% 10% 0%;} #group3 li a{transition:0.25s; border-radius:5px; border:2px solid rgba(0,0,0,0.0); color:#e5e5e5; background:rgba(0,0,0,0.5); width:24vw; height:11em; display:block; text-decoration:none; font-weight:bold; font-size:3.8vw; margin:0.5% 6% 1% 0%; overflow:hidden; word-wrap:break-all; padding:1% 0.3% 1% 0%; float:left; position:relative; left:4.7%; text-align:center; line-height:1.2; text-shadow:1px 1px 2px black,1px 1px 2px black,1px 1px 2px black; } #group3 img{width:23vw; height:70px; float:left; margin:-4.5% 100% 4.5% 0%; border-radius:7px; border:2px solid rgba(0,0,0,0.5); position:relative; top:5px; } #group3 li a:hover{border:2px solid rgba(80,80,80,0.9); background:rgba(20,20,20,0.7); transform:scale3d(1.1,1.1,1.1); z-index:2; color:white; } #group3 li a:active{background:rgba(60,60,60,0.9); opacity:0.8;} Javascript var ul = document.querySelector('#group1 &gt; ul'); for (var i = ul.children.length; i &gt;= 0; i--) { ul.appendChild(ul.children[Math.random() * i | 0]); } var ul = document.querySelector('#group2 &gt; ul'); for (var i = ul.children.length; i &gt;= 0; i--) { ul.appendChild(ul.children[Math.random() * i | 0]); } var ul = document.querySelector('#group3 &gt; ul'); for (var i = ul.children.length; i &gt;= 0; i--) { ul.appendChild(ul.children[Math.random() * i | 0]); } var timer = document.getElementById("group1"); timer setInterval(function(){ul = document.querySelector('#group1 &gt; ul'); for (var i = ul.children.length; i &gt;= 0; i--) { ul.appendChild(ul.children[Math.random() * i | 0]); }, 500); var timerTwo = document.getElementById("group2"); timer setInterval(function(){ul = document.querySelector('#group1 &gt; ul'); for (var i = ul.children.length; i &gt;= 0; i--) { ul.appendChild(ul.children[Math.random() * i | 0]); }, 5000); var timerThree = document.getElementById("group3"); timer setInterval(function(){ul = document.querySelector('#group1 &gt; ul'); for (var i = ul.children.length; i &gt;= 0; i--) { ul.appendChild(ul.children[Math.random() * i | 0]); }, 1000);
You are confusing me with someone else :-)
Whats the use case? I'd almost like GitHub to make this a mandatory field for every repository.
It seems that there a lot of them, it's interesting to see all the different approaches people used.
looks very cool! two points of feedback regarding the project on Github: * totally understandable that you don't want to put your API keys to your Contentful CMS out there for everyone to use. however, you should at least put a disclaimer in the README that you won't provide those here and users should provide there own as an environment variable. as it stands now the app fails to boot locally because Contentful's`accessToken` parameter isn't defined - you're expecting it to be pulled from `process.env.CONTENTFUL_TOKEN` * is your intention with the project root folder's `public` folder to keep a static, packaged version of the app? because any time the npm scripts are run i'm triggering changes in git because the generated files are different. typically you'd want to exclude this folder from git since it contains your built files and instead you'd want to publish your build artifacts somewhere else that is publicly available
I can confirm that bug report.
1. Somewhat know either React or Angular 2, and have some familiarity with the other. Vue, elm, etc are nice to knows. React or Angular 2 will make you more marketable because more companies are looking for them. 2. Know this keyword, scope, let vs var vs const, object destructuring, arrow functions, es6 modules/classes, fetch (or similar), and the build process for JavaScript (gulp/webpack/yarn). Be able to have a conversation about modern JavaScript. 3. Have someone practice interviews with you. A lot. Questions like "Tell me about yourself" should be automatic. 4. Make an app with 1. and 2. and put it on GitHub. Have it pull information from .json or a API and do something with the data. 5. Be passionate, have excitement for JavaScript and the position. Hard passes for hiring include no interest in the position, no passion/excitement for JavaScript, limited knowledge of JavaScript/programming fundamentals, cockiness, victim complexes, or not able to hold a conversation. Most places don't look for someone who can make speeches, but being able to communicate at work is important. Hard passes on the company include no interest in modern JavaScript, backend technologies (java, php, etc) that are heavily integrated into front end, any probing if you're comfortable working overtime on consistent basis, or low pay/benefits. Midwest you shouldn't go below 60k at a junior level, or 80k at a senior, not sure about West Coast. It may seem like a lot to know, but as a Junior you should be able to add value on day one, even if it's just a small update. If you owned a bakery would you hire a junior if the person didn't know how to turn on an oven, or make bread?
This is awesome! Only comment: it might make sense to have all your ES6 examples use arrow functions and let/const. Especially since you introduce those concepts at the top of the list. It's odd to see destructuring with var - I would be surprised if you ever found yourself in a professional situation using destructuring but not let/const.
Not everything needs to be made to fill some need. In this case it seems it would allow you to save a canvas as any image type regardless if the browser supports the image type in .toDataURL()
Hey there @fs2d! Justin from the [Unbounce Community](https://community.unbounce.com) here. Just wanted to clarify and let you know that the Community is open for all to use (ie. it's not private). I see that you've already created an account and [posted your question there](https://community.unbounce.com/t/tips-scripts-sticky-navigation-bar-for-desktop-the-code-behind-our-call-to-action-conference-page/3288/37), so I'll ping a few devs that I know to see if they can chime in. :) 
Okay, that's fine. I wasn't disagreeing with you, just curious if there was an advantage to the way your wrote it. Always trying to learn. Thanks for replying!
It looks like most of the app is loaded in through a 'bundle.js' file that looks like this import './polyfill.js'; import './buttons.js'; import './input.js'; import './options.js'; import './selection.js'; import './page.js'; import './adverts.js'; import './sw.js'; You may as well use script tags, right? Doesn't this defeat the purpose of using in-browser modules?
I really like this. Honestly it never occurred to me to pass a function through as a child.
as someone who isn't in the React/Redux ecosystem, i figured i'd also mention a different stacked modal implementation in a virtual dom lib: http://leeoniya.github.io/domvm/demos/ModalStack/
Interfaces aren't emitted. There are also const enums which aren't emitted either. Well, one of the things which TS does add are decorators. Personally, I don't mind that it adds a few things on top of types. Enums, for example, are super handy when you have types and almost completely useless when you don't.
Here's what you can do: loop through all of the cars once, then add in a new array for the car's color, but only if it doesn't exist. Then push it into the array. const result = {} cars.forEach(car =&gt; { result[car.color] = result[car.color] || [] result[car.color].push(car) }) A solution using reduce is possible as well, but probably not necessary. If you need to reuse this functionality (which is actually fairly common), throw it in a function somewhere.
I actually solved it! :) Thanks though! 
Another bug report when you select no in the pop up for available online the toggle doesn't get set back to the off position.
&gt; cars.forEach(car =&gt; { I'm not used to arrow functions is that the same as cars.forEach(function(car) {}) ? Also thanks a lot that is super clean compared to the thing I had. 
Yeah, they're the same in this case. Would've written it that way myself, but force of habit ¯\\\_(ツ)\_/¯
We are a fast growing and super friendly Discord community dedicated to talking about technology. Come check us out if you are interested in an a good place to chat with people who specialize in programming, security, Linux, hardware, networking, and other popular subjects.
Lol, hopefully they'd offer to pay for your bart ticket. 
Thank you good sir!
So on small arrays it takes 0.009ms instead of 0.01, on big arrays the absolute difference is likely quite similar so the point kinda defeats me. 
For JSON, yes, they are a required part of the spec. Most browsers handle the spec pretty loosely and will accept JSON without them, but node will throw an error when parsing JSON if there are no double quotes on the keys. For example, `const myObject = JSON.parse('{foo: "bar"}');` will thrown an error while `const myObject = JSON.parse('{"foo": "bar"}');`will parse fine. One thing to note, however, since you are new to javascript, is that JSON objects, though they look very similar, are not the same thing as Javascript objects. `const myObject = {foo: 'bar'}` is perfectly valid and standard javascript, but if you try to parse that object notation as JSON, it will not be valid. If you're creating a hard-coded object for testing purposes, just be aware that it will need to be converted to proper JSON notation if you're going to import it from a JSON file. 
How did you save results of training?
Great work, but performance needs to improve. 27 Requests | 275 KB transferred | Finish 3.50s | DomContentLoaded : 752ms | Load 1.53s For 275 KB (non-cached), it's slow, and all the lazy paints (sidebar, main-content) make it seem even slower. Not sure why the loaders should even show, as everything should be ready on page load. Do you lazily fetch the TOC and the corresponding content? Or maybe its because of 27 requests, which is crazy high.
[You can export the models to JSON](https://github.com/harthur-org/brain.js#json) In this case I had around 1700 matches to process, and the model ended up being a 670kb JSON file.
It's a float/height issue but I'm not sure what's causing it specifically. .box { max-height: 420px; }
Why are fixes always so simple? Hahaha. Thank you so much. I was about to pull my hair out, haha
What was the use case for the first lightbulb by Warren de la Rue in 1840? It was impractical for commercial use. Nobody is calling his work pointless.
I think that's cool. [I'm just thinking aloud, but] Circles are hard to gauge increases in surface area, so as they get bigger the increases look smaller. It wasn't clear if the results are all from the same year. What do the lines represent?
I can't help but feel that this is a bad thing.
I'm not convinced stateless components work well for large scale projects. That's why pretty much every component implementation that follows the React model, has support for stateful components. I've built an entire app with stateless components and it sucked ass. I had to put way more than necessary into a global state store (Redux), and didn't really see much benefit. The point of classes wasn't for performance and if anyone claims that from the React team I have to roll my eyes. Especially as this author mentions that most of the time you're going to transpile them out so tools like UglifyJS can even operate. What is more important to me and many other developers is standardizing on a syntax that works across tooling and implementations. It's short-sighted to call out classes without understanding what a break-through this is for projects like Preact/Inferno/Skate/Dio/etc. Would these projects have existed if everything was still createClass? Probably not, its a custom as hell user-land inheritance model that would be a bitch to recreate. By picking the class standard React cemented its future with web standards and playing nicely with everyone else. They ripped this bandaid off at the right time before more and more of the ecosystem depended on `createClass`. I've spent a lot of time thinking about React implementations (working on my own) and it just seems completely backwards to be wanting the old days of `createClass`.
Can I make an editor which allows nest-able lists using it?
I'd say this sucks. But as someone not doing any mobile dev I feel it might be that I only recognize badly written hybrid apps while for well written ones I think they are native. Anyone wanna chime in?
fabricjs is generally my goto for stuff like this that has a lot of image-editor-esque qualities (editable text, rotations, export as images, etc).
I wrote a comment I thought was pretty good, but then after reformatting the code I accidentally deleted it. :( Point I wanted to make is that this approach works great if you're 100% committed to React. If you want to use Preact or Skate to make Custom Elements with them though... you're not going to find parity with static markup using a children function. Examples... Using HoC: function render() { return ( &lt;ThemeProvider&gt; &lt;MyApp /&gt; &lt;/ThemeProvider&gt; ); } Using Custom Elements: &lt;theme-provider&gt; &lt;my-app&gt;&lt;/my-app&gt; &lt;/theme-provider&gt; Using Function as Child: function render() { return ( &lt;ThemeProvider&gt; {() =&gt; (&lt;MyApp /&gt;)} &lt;/ThemeProvider&gt; ); } Using Custom Elements here...: &lt;theme-provider&gt; &lt;!-- ... what goes here?? --&gt; &lt;/theme-provider&gt;
I think it would be great if we all moved towards a platform where we could write native web standards e.g. JS, HTML, CSS and use the newer HTML5 APIs that are useful on mobile (geolocation, vibrate, notifications, battery, localStorage, IndexedDB etc) and the mobile OS natively had a JS engine built into it and understood a packaged (zipped) app written with those web technologies. Then there's no need for complicated hybrid app approach. Firefox OS almost got there, but now it's dead. Probably better is a JS/web engine built into the core of iOS and Android for running those apps as those platforms aren't going away anytime soon.
What use cases for this typer? For fun?
Thanks! Looks interesting. Might probably work for me!
And how is it going with Vue so far?
No, they are not.
Thank you for the feedback! I had played around with giving each row (subreddit) its own scale so that there is more differentiation of bubble sizes for each subreddit, but got rid of it so I could add just 1 legend to the viz. You arent the first person to ask about the lines, so I will try and think of a way to clear up the labels or something. There is a line for each subrreddit and the line is a time-scale, so each bubble/articles is in chronological order. Thanks again!
odd, where's that type conversion being done? https://github.com/lodash/lodash/blob/master/maxBy.js
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [lodash/lodash/.../**maxBy.js** (master → 527b167)](https://github.com/lodash/lodash/blob/527b167bc5d7ef845fbd7ff48d75f97dcf682470/maxBy.js) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dkpklrx.)^.
Alright I'll do it. His work was pointless.
I agree, but unlikely to happen. Little/no reason for the big players to do this, unfortunately.
Love the design, nice work!
Glad to hear AI is being put to good use.
Preact shouldn't have a problem with it, `children` comes through as a normal prop value which is why it works in the first place. I'm not convinced you'd run into problems with custom components either, when all the code is executed you still end up with normal DOM, this method just let's you expose values from within a wrapping component in a different scope. Instead of abstracting away what's being rendered, like &lt;ComplexComponent row={Row} /&gt; You can use a function child and make it more composable and flexible. &lt;ComplexComponent&gt; {data =&gt; &lt;Row data={data} /&gt;} &lt;/ComplexComponent&gt; In this trivial component that doesn't matter so much, but it's a way to choose where logic happens, and can help keep components single purpose.
It's not in there, because the shorthand stuff is changing in v5. I'm not sure what the details of those changes are. If you look at the current v4 [source code linked from the documentation](https://github.com/lodash/lodash/blob/4.17.4/lodash.js#L16281), it's there. function maxBy(array, iteratee) { return (array &amp;&amp; array.length) ? baseExtremum(array, getIteratee(iteratee, 2), baseGt) : undefined; } `getIteratee` is a function that's used throughout the lodash codebase, which has the logic for converting the string into a `_.property` getter. (You can also just open the dev tools on the lodash documentation and try things with the lodash instance that's loaded on that page; it's how I test most lodash stuff) EDIT: Dug through github issues a bit, apparently the shorthand stuff is being pushed off to a babel plugin in v5. 
This is great. Most companies are not developing games or graphically intensive apps. They need to do a little CRUD with a sprinkle of UX. Hybrid apps leverage existing website-based skills while being able to deploy to most platforms at the same time with minimal development time. As was mentioned in the article, yeah, if you're doing a game, or some kind of photo-manipulation app, native is probably your best bet. For most other purposes, hybrid is far more efficient if your company already has a web development team.
I have made several apps that are made exclusively of stateless components. I enjoyed it.
That could certainly be the case. More companies use this approach then you might think - not many actively mention it. As I say in the article, there are lots of great options now, so it's worth a look at least if you do ever try mobile dev.
Care to expand on that? :)
&gt; For Flash developers this will mean transitioning to HTML, ... There still are flash developers out there? Furthermore ones that aren’t already in the last phases of transitioning? Anyhow, why do we need to wait another 3 years to bury this long-dead horse? I mean it wouldn’t matter if it wasn’t for the flies and diseases it’s attracting.
The heading highlighting is jarring.
This is awesome, bookmarked it. One question though, I haven't had time to look through your source code but how are you handling the loading animation for the loading spinner and the loading bar at the top. Could you give me like a quick top level explanation of it?
Sorry that was overly negative. I only wish that there were a few less layers between the app logic and the hardware, especially since on mobile there are already so many. I can't really blame anyone though, Java is an aging language and it is not very ergonomic. If only the native development kit had not been an afterthought :/ With native API's like that garbage fire, and with the easily hireable​ multitude of web devs, it makes sense. I don't have to like it though.
For a second I thgought I was on /r/gonewild.
Do you know sites like kongrate, armor games newgrounds are making games.Since flash is almost dead.
Hi /u/Risse, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
Hi /u/TwoTimesX, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
I think [Google Fuchsia](https://en.wikipedia.org/wiki/Google_Fuchsia) might be taking this approach albeit with `Dart` instead of `js`.
Have you looked at the output of your two `console.log()`s? `pokemon` is a string containing the URL endpoint for pokemon, and `jasmineFavs` is an array of URL endpoints for the specific pokemon. That would be why `jasmineFavs[1].name is undefined.
 function displayPoke(data){ debugger; ... } put `dubugger` at the top of your `displayPoke` function and have devtools open when it runs and you can inspect `data` and step over your code. It will hopefully help you find your error.
Yes, you're right—we have lots of top-level imports which could be script tags. Inside some of those files though, we depend on further files (e.g. stuff in `src/lib`)—our dependency graph isn't really that complex but it's still easier with Modules.
Yes. Emoji are awesome 👍❗
Nice work! Though I disagree with "Abstract subclasses or mix-ins are templates for classes." An _abstract class_ is a very specific thing, and you can't really replicate them in JS -- the closest you can get is to have the methods all throw `NotImplemented` errors. Also, "[mixin](https://en.wikipedia.org/wiki/Mixin)" is a word itself.
Riding a dead horse doesn’t make it alive again. Now, if Adobe - since buying Macromedia - would have put some serious effort into making it more secure and lean, we wouldn’t have this discussion. But until last, Adobe failed time after time „trying“ to properly sandbox Flash.
True. Though no matter what, native won't exactly die out... it's the official way to create apps after all!
I don't understand. They are not objects? How do I access those properties for each pokemon object then?
Thanks I will try that
Not 100% the same because of how arrow functions bind `this` but nearly the same. 
&gt; I only wish that there were a few less layers between the app logic and the hardwar I know a lot of guys who learned C++, MFC on Windows or QT on *nix who think the same thing about .NET/Mono/the JVM. And a few guys who grew up learning C and using Win32 or X who think the same thing about C++, MFC and QT. I even know at least one guy who grew up on assembly, who thinks C is overly complicated, and people should just learn to code on the bare metal. Abstraction layers don't arise in a vacuum - they arise because they offset any inherent inefficiency they introduce by providing orders of magnitude more utility in other (more important) ways. So we have less-efficient C with its "weird" new metaphors, because learning different assembly and recoding your application for every chip and architecture is ludicrous. And we have C++ and Windowing system APIs because sometimes you need higher-order abstractions to work with to write more complex code that does more complex things in a more complex environment, even if it's inherently less efficient than poking individual memory addresses to read keys and put pixels on a screen. And we have memory-managed code and VMs and automated garbage collection because it's less efficient *again* than before, but it adds portability between architectures and OSs without recompilation, and enables us to write safer code with less cognitive overhead, which means a unit developer can design more complex systems without getting confused and losing productivity or introducing bugs. And finally we have web browsers and JS, which is *ludicrously* inefficient from the point of view of an assembly purist... but which provides powerful abstractions (like the XMLHttpRequest object and DOM), and insane flexibility, and allows us to not only write software that's instantaneously delivered over *and understands and can itself use* a globe-spanning and insanely robust practically omnipresent computer network, *and* runs on every modern browser, OS and hardware architecture, *and* which uses UI technology that (with some fiddling) allows it to run on anything from a watch display to a wall-sized smart-board and all the way across to a braille display or speech-synthesis output... but which *also* provides a pretty bulletproof security sandbox so you *can* run all this code from untrusted third parties without needing so much as a virus killer, *and* (increasingly) which can be written to render on the server, or the client, or a mixture of the two, or (if you really want) can be compiled into a native wrapper to run as a local, native desktop or mobile app on pretty much any OS or device in existence. And the cost of that is just a few orders of magnitude of efficiency that increasingly (with the speed of modern hardware) *we don't even need anyway*. Is it complex? Sure, but look into your own body sometime - evolved solutions are *always* complex and messy. The key is that *every layer was developed because it was more useful than the alternative of not having it*, and that every layer provides a sufficiently bulletproof abstraction that you rarely have to worry about the layer or two underneath it, and almost *never* have to worry about the layers underneath those.
Eugh. 
Similar to react native then
I do find this a good direction. Having only one language is good, because it gives more flexiblity for the devs and a faster development time to get the app done. Natives have the problem that the devs have to learn a whole new API per OS, and there are several one like iOS, Android or Windows Phone. If a developer wants to make his app multi platform, he/she has to learn all the different API's, which will slow down development time and increase headaches. Maintaining or updating those apps is also painful and boring at times. Seeing native apps dieng out is sure not a good thing, but having mobile apps written with HTML etc. is not a bad thing too, if the app looks and feels like native (which alot already do).
This is easier said than done. Security is one thing - something that was a constant struggle to keep up with (and there was an entire team dedicated to it) - but there was also keeping ahead of the curve with innovation in an attempt to stay relevant; trying to maintain compatibility with the ever-changing and evolving browser landscape, not to mention maintaining the other of the many, many distributions of the runtime; attempting to maintain parity with the different forks of the platform (mobile, AIR); trying to be performant despite the ever-restricting (and, again, changing) confines of the plugin architecture; all while trying to keep consistency without breaking backwards compatibility - which had to be abandoned in a few cases, namely for security - and all this within a messy, decades-old codebase. AS3 was a (much debated) change to help with this cause. And [AS4](https://github.com/adobe-research/ActionScript4) was attempt to take this even further. It was meant to accompany an even leaner runtime built from the ground up to address all (well, lets say "most") of the failings of the current day Flash. Only it was too little too late. And that's fine. The writing was on the wall and Adobe, in full support of the maturing, plugin-free web technologies browsers now embraced knew what had to be done. This transition was a long time coming, and instead of pulling the rug out from under people's feet (yes, people are still using Flash, even today), some warning was given to help people make this transition. Frankly, I'm surprised its only until 2020, but I guess with the speed of change nowadays, that can seem like an eternity. Besides, I don't think anyone didn't already see this coming eventually up to this point.
Wonderful, wonderful comment. Thank you. I think people forget that we truly stand on the shoulders of giants - decades of work and millions of man-years to get to where we are today. I'm incredibly grateful that I'm not working with punch cards, for example!
Projects. Come up with projects you want to do - hard projects - projects you couldn't POSSIBLY think of how to build now but you know WHAT you want them to do - and then when you come upon something you'll be triggered to try and apply even a piece of it to your project. For instance, I have long thought I could use JS to create a D&amp;D character generator (hich turns out isn't as easy at it used to be) and it was always in the back of my head, but when i learned functions I could experiment by creating the dieRoll function or the TraitCreation Function. And it's been HELLA motivational in learning VueJS
I'm going to aim to create a simple news posting site, where you literally just have a homepage of content, and users can sign up - click create and post a title, paragraph and image.. just a basic starting idea. Probably have a while to go yet though..
Are you building your own programs? You should if you aren't already. Pick a small project that interests you (there are many ideas in the /r/learnprogramming FAQ).
Gonewild is appropriate for the behavior of computers infected via Flash... so close enough.
The navigation on mobile is terrible, sorry Mozilla :/
Here is a `reduce` version: function groupBy (property, array) { return array.reduce(function (result, entry) { var key = entry[property]; result[key] = (result[key] || []).concat(entry); return result; }, {}); } var foos = [{ color: 'green' }, { color: 'blue' }, { color: 'blue' }]; console.log(groupBy('color', foos)); Here is a *slightly* modified version that allows one to use a function to control the grouping, demonstrated here is grouping items that have a color that starts with "g": function groupBy (accessor, array) { return array.reduce(function (result, entry) { var key; if (typeof accessor === 'function') { key = accessor(entry); } else { key = entry[accessor]; } result[key] = (result[key] || []).concat(entry); return result; }, {}); } var foos = [{ color: 'green' }, { color: 'blue' }, { color: 'blue' }, { color: 'gold' }]; console.log(groupBy(x =&gt; x.color.startsWith('g') ? 'g' : x.color, foos));
I've been thinking lately about this, and whether or not, had Flash been allowed to be a contender on the iPhone, Adobe would've found the motivation to address its short comings. I've been thinking about it because, as a long time windows and Android user, I have been now exploring Apple space as a developer, and I find Safari's lackluster support of current web technology to be be glaringly suspicious. That coupled with OSX's aggressiveness towards anything not installed through the appstore have me very surprised Mac users are not more vocal about it. What did Microsoft ever do to earn that antitrust lawsuit that was so much worse than Apple?
When the breakpoint is hit you can also copy the object path in the menu. Just open up all the props and right click the one you want and select copy path.
Why do your item links open up the next page in a new tab? Is that intentional?
Go get them from the endpoints just like you did the list of endpoints.
I agree for the most part with what you've said. And yet in all those layers, some nessisary, some to fix faults in layers lower down, I can't help but wonder if we've cut a few too many corners when things should have been rebuilt from the ground up. I'm 19, I didn't see the era of extreme​ efficiently where ring 0 and hand tuned ruled. And a lot of it is nessisary, the C compiler is a beautiful piece of technology, Linux has it's flaws but it's got us this far, and it runs the world's network despite the legacy it's accumulated, and overly complex pieces like systemd. The truth is well thought out abstractions are hard to make, and those that grow with the future take genius and luck. I hope that the limits of silicone which we are approaching force us to reconsider the design of a few of our layers, if only for a moment before germanium or whatever else. Our world needs technology -- computers and software of every description -- and it needs now. And It's exciting to be on the bleeding edge. But it's a little sad to see so much genius in the implementations of designs that were starved for patience. I think we may have made our thinking machines a little ugly to save time. It's no one's fault, but I think we all pay for this kind of debt all the same, eventually.
It was so nice and clean before. Now the headings are oversized and the sections blend together with all white background.
Good grief, Google is so all over the place. They act like they have the biggest boner for JavaScript and everything should be done with it and then they pull crap like this. More than anything I wish they could just settle down on one messaging app. Most ADD company ever.
Yeah, but... ~~Achievements~~ Badges! Really, though. A good understanding of basics will take you further than just jumping straight in to more advanced examples. Accept that and keep on truckin.
Open your browser console, paste in `$('#continue').css('display','block');` and hit enter.
http://cubiq.org/add-to-home-screen
This is a cool pattern, but in reality, it is no better (and I will argue worse) than this: &lt;MasterComponent prop1={someValue}&gt; &lt;ChildComponent /&gt; &lt;MasterComponent /&gt; where const ChildComponent = ({ some, api, of, props }) =&gt; { return &lt;div&gt;{JSON.stringify({ some, api, of, props })}&lt;/div&gt;; }; class MasterComponent extends Component { // some code to handle state in here... render() { const { prop1, children } = this.props; const { some, api, of, props } = this.state; // if you care about enforcing 1 child policy: return React.cloneElement( React.Children.only(children), { some, api, of, props }, ); // otherwise do // return (&lt;div&gt; // React.Children.Map(children, child =&gt; React.cloneElement( // child, // { some, api, of, props }, // ) // &lt;/div&gt;); } } Here's why I prefer this: **Reason 1:** Having functions work by order of arguments is hard to understand for future you and future coworkers. All you have to do is document your `PropTypes` API for the `ChildComponent`. Consumers can even `import` those `PropTypes` to spread into their `ChildComponentImpl.propTypes`. If your `ChildComponentImpl` doesn't use all the props, you don't have to deal with const myFnChild = (notUsed1, notUsed2, useful) =&gt; doSomething(useful); vs. const MyComponentChild = ({ useful }) =&gt; doSomething(useful); Yes, you can achieve this by passing your arguments as an object (which is what `props` is after all), but it's not a strongly enforced convention as it is in plain react components. **Reason 2:** What seems more natural to react? &lt;MasterComponent&gt; {[someChildFn, someChildFn2, someChildFn3]} &lt;/MasterComponent&gt; and &lt;MasterComponent numChildren={3}&gt; {someChildFn} &lt;/MasterComponent&gt; OR &lt;MasterComponent&gt; &lt;SomeChild1 /&gt; &lt;SomeChild2 /&gt; &lt;SomeChild3 /&gt; &lt;/MasterComponent&gt; I would easily say the last one. Not to mention the components way of doing this is much more flexible without having to be complicated. Partial application is done for you! Just seed your `SomeChild` component with props; the `MasterComponent` will merge in the "API props". You would have to curry or `bind` your childFn to achieve this same affect. **Reason 3:** You natively get `context` with this method without having to pass it down to your `childFn`. Why would this matter? // MySpecialMasterComponent.jsx import SpecialChild from './SpecialChild'; const MySpecialMasterComponent = ({ ids }) =&gt; { return ( &lt;MasterComponent&gt; {ids.map(id =&gt; &lt;SpecialChild id={id} /&gt;)} &lt;/MasterComponent&gt; ); }; //SpecialChild.jsx import { connect } from 'react-redux'; import { mySelector } from '../reducers'; const injectState = connect( (state, { id }) =&gt; ({ importantValue: mySelector.getImportantValueById(state, id) }) ); const SpecialChild = ({ some, api, of, props, importantValue }) =&gt; { // do something }; export default injectState(SpecialChild); That's pretty easy to understand from a react/redux perspective, but children-as-fn would be much more confusing to understand to achieve the same effect. Anyways, that's just my two cents. I think it's a lot more flexible to deal with a component's "props API" than any generic function. After all, components can really be treated as just a render function, so there's no reason I can think of to discard the benefits of using "components-as-children" when they already are essentially functions.
Ah cool!
What is it about?
Well it's a free dimension some might have a fetish for that ;)
Awful...
THANK YOU! :)
Wow, I had idea those sites still exist or are being updated.
Lmfaooo
I think the header especially needs some work. [Here's my hack job attempt at making it slightly more palatable](http://i.imgur.com/gRautOT.png); nothing can fix their hideous logo of course which is why I removed it.
Interesting. I use ramda on most projects, but still good to know for sure.
That is beautiful, did you save the styles? I'd like to use em as well :D
One word: DRM
Nothing gives me a bigger hard on than legacy software reaching EoL
&gt; And yet in all those layers, some nessisary, some to fix faults in layers lower down This is a *popular* claim, but it's surprisingly hard to come up with examples that withstand real scrutiny. Can you give any examples of "additions to abstraction layers" to "fix problems" in lower layers? &gt; I can't help but wonder if we've cut a few too many corners when things should have been rebuilt from the ground up. That's the thing though - that whole alternative is - and apologies for being harsh here, but it's true - a naive, ridiculous alternative. When you have an entire industry and *billions* of man-hours invested into computer hardware and software systems, do you know how often you get the chance to rewrite any of it? Maybe once a (human) generation, if you're lucky. And when you do, you inevitably throw away all the little quirks and nastinesses and workarounds and hacks for all the problems you know about, and replace them *with a whole new set of systems, which all have their own quirks and oddities and nastinesses*, but that you *don't* already know all the issues with. Probably the closest we've ever got to really "replacing" an entire layer of the stack is when mobile devices really took over, with the advent of iOS and Android. We had the chance to wipe the slate clean and start completely fresh, and what happened? We solved a whole bunch of problems with the most popular desktop OSs, with things like a new abilities-based permissions model, an integrated app-store and revolutionary new window-management systems that eschewed traditional windows and application lifecycles for novel new ones that worked better for the modern world. And what happened? Well, in a lot of ways we fucked it up. iOS was designed to be very battery-efficient and have a fluid and responsive UI, by eliminating subsystems for proper multitasking or background services to ensure the UI never got bogged down. The thing is that those were *extremely temporary* problems with devices when the system first launched, and in many ways a hell of a lot of the development on iOS ever since the first couple of versions was to takew this extremely pretty but fundamentally lobotomised computing platform and turn it into a generally useful one, with a series of shitty hacks like push notifications and selected, hard-wired background execution options. Android was another opportunity to "get everything right", and while its initial developers did a lot very right (Intents, Activities, etc), they also made a choice to prioritise general computing flexibility at the cost of a less efficient VM-based approach, and a UI pipeline that was practically *designed from the ground up* to be janky and hard to optimise, at least until they put an inhuman amount of work into ART and Project Butter. Likewise they failed spectacularly to scale to devices like tablets that could display more than one app per screen, and had to introduce Fragments just to work around problems in their (modal, whole-screen) Activity metaphor. Here's the thing - the idea that we could ever: * Conceptualise what we've learned from decades of computer science and practical, real-world usage * Throw away huge chunks of the old stack * Redesign one or more layers of it *from scratch* and * Get it *even as immediately functional and useful as the old system*, and *then* * Convince the entire world to upgrade their systems to be compatible with it ... is almost always impractically, *hilariously* wrong. Netscape tried that with Navigator, and it pretty much killed the company. Microsoft tried that with Windows (Vista and .NET), and it was late, the first few versions were abominably shitty, and it almost killed the company. What we do is ride old layers of tech almost to death, then eventually someone bets the farm on a rewrite of *one single layer* of it (or just a *piece* of that layer), and then that layer makes a whole bunch of *new and poorly-understood* mistakes (which are the only things worse than old and well-understood mistakes), it's generally shitty and a poor imitation of what came before it (in terms of functionality, efficiency, adoption, general utility, etc) until it hangs around for a few years, people work around its limitations and lacks and fix its mistakes and oversights and deprecate a bunch of things and introduce a tonne of tech-debt, and finally about the time it becomes generally useful and accepted and a decent fraction of the world is using it, some bright spark comes along and says "this is shit - we should rewrite it all from scratch, and *this* time we should try really hard, and make it, you know, *good*", and the whole circus begins again. &gt; I'm 19 With respect - that this is where I regretfully slip over the edge from "curmugeonly old computer scientist" into just "patronising old asshole" - I could have guessed that. ;-p &gt; I didn't see the era of extreme​ efficiently where ring 0 and hand tuned ruled. And a lot of it is nessisary, the C compiler is a beautiful piece of technology, Linux has it's flaws but it's got us this far, and it runs the world's network despite the legacy it's accumulated, and overly complex pieces like systemd. The truth is well thought out abstractions are hard to make, and those that grow with the future take genius and luck. Exactly that, yes. The bit you perhaps haven't realised is that *exactly the same thing* can be said about the web stack or whatever abstraction layer you're looking at and deciding is overcomplicated and messy. And conversely, no - the average non-toy C compiler is a fucking *mess* of vile hacks, shitty workarounds, officially "undefined" behaviour, questionable optimisations, etc. *nix is a fucking mess in places too, and Windows is even worse. Mac OS only solved its own crippling tech-debt problems by throwing away OS 9 and replacing it with a new OS layer... but they didn't build it from scratch - they built it on top of NeXTSTEP and BSD Unix and a few competing (contemporary) OSs. You notice the inefficiencies in your current layer of abstraction because that's what you work in, and that's what you see. It's the same all the way down the stack though - massive problems too complex to be solved well by any one group of individual humans, who instead give it their best shot, invariably fuck up a whole bunch of things, and that's then slowly and messily patched and worked-around into general acceptable usefulness afterwards. You can't trivially throw that away and replace it without replicating the *ungodly* amount of work that went into making it useful in the first place... and you certainly can't possibly hope to get it completely (or even *mostly*) right when you do it. Rather, at the *very, very limit of possibility*, by dint of great effort, sustained application of genius and a truly ludicrous budget (of time and/or money), you might make something that's an *incremental* improvement over what came before, but which also has its own litany of problems and fuck-ups and oversights and incorrect assumptions, and which won't be generally useful or get used by anyone much until *it's also* been hacked and patched and kludged to buggery to fix all those problems. There's a famous maxim by Bjarne Stroustrup about programming languages that's applicabnle here - "There are only two kinds of languages: the ones people complain about and the ones nobody uses". That's not just a statement that applies to languages, though - it's a statement that applies to every layer of any popular computing stack for the last few decades, and it's because you can have a *pretty* system that's so incomplete or tightly constrained that it's useless to nearly everyone, or you can patch and hack and modify it and rework its core assumptions until it's generally useful to most people, by which point it *will* be ugly and inconsistent and hacky and aesthetically gross. The idea you can throw away a gross, old, confusing mess *that works for everyone in the world* and replace it with a clean, small, efficient replacement *that works for everyone in the world* is wrong, because *the messiness is an inevitable result* of it being adapted for popular use by an entire world's-worth of different people with an entire world's-worth of requirements and use-cases. It's like trying to throw away a nasty, oily old machine and replace it with a bright, shiny and completely clean one. Sure it looks great and you'd much rather work on that one, but unless you get in there and cover it in oil, it's not going to be any use to anyone.
True - all these systems that work almost flawlessly for almost all of us almost all of the time, so they become **plumbing**. You don't think about the pipes under your sink from one year to the next. They sit there carrying away all your crap and dirty water, and you only ever think about them exactly once - on the day they break down and stop doing it. Likewise with most "infrastructural" technology, we only notice them when they fail to fulfil our particular use-case perfectly, so we ignore the years of acceptable (or even excellent) functioning in a million sdifferent situations, and we only focus on them in the context of the tiny minority of situations where they break down and we actually notice them. They work perfectly almost all the time, but *100% of the time we're thinking about them* they're broken, and so we systematically undervalue their effectiveness, and we don't appreciate all the things they get *right*. Rather, we only consciously experience the relatively small proportions of times and places where they're lacking, or ugly, or confusing, and declare that they're therefore shit. Anyone who's not a compelte idiot can look at a system that's not working perfectly for your use-case, and it's usually pretty easy to suggest changes or replacements that will solve your one single issue in an unambiguously simpler and more elegant way. The problem is that you've now just *un-solved* millions of other people's problems, and your suggested "improvement" is a *massive, six-orders-of-magnitude net loss* unless you can also solve all their problems too. Not only do we forget we're standing on the shoulders of giants - we also take them for granted so much that when they occasionally shift their weight and throw us off-balance and remind us they're there, we conclude that they're *useless dipshit* giants, and advocate taking everyone's giant away and replacing them with very small, emaciated midgets, just because we've personally found one who happens to have comfortable shoulders.
Yeah, I keep meaning to try ramda, but I'm more functionally leaning than most of my team, I'm not sure I could get the buy-in. (Plus, I wouldn't want to migrate our existing codebase or mix the two)
jest is a testing framework primarily used for react applications. One of its selling features is its snapshots https://facebook.github.io/jest/docs/snapshot-testing.html What jest-image-snapshot does is provide a matcher for jest that allows for image comparison in the same fashion and ease of use as the jest snapshot functionality. This is most useful for visual regression testing as described in https://codeburst.io/automatic-visual-regression-testing-23cc06471dd
I'm not trying to argue with you, I'm sure you know your stuff. I think though, that you may have missed a large part of my sentiment-- I'm not blaming anyone, and I know how the real work interfered with my beautiful ideal. I may be young and looking at this for the first time but I'm more self aware in life and in my comment than you give me credit for. I've use Haskell and Python in equal measure and though I've written useful code for both that maxim you quoted has always run with a certain amount of truth for me. I also think that much of we've written is the same in spirit.
I've had a lot of success with React DnD https://github.com/react-dnd/react-dnd It takes a bit more setup to get it running in your project than most jQuery-like plugins but is very flexible and allows you to do just about anything drag and drop related you can think of.
&gt; stuff I have had to rip fabricjs out of projects before. It seems like overkill if this is a production application. If it's fun personal stuff, then go for it. Do it directly in canvas with Three.js if you are planning on running this live IMO.
deleted ^^^^^^^^^^^^^^^^0.1192 [^^^What ^^^is ^^^this?](https://pastebin.com/FcrFs94k/25574)
This might be the reason increasing numbers of companies are going hybrid!
https://userstyles.org/styles/145702/beautiful-mdn #main-header&gt;div.center { max-width: 100%; background: #333; color: #f8f8f8; border-width: 0 0 10px; } .home-masthead{ margin-top: 1px; } html:not(.no-js) .nav-main-item&gt;a { color: #f8f8f8; } .nav-main-item&gt;a:hover{ background: #333; color: #f8f8f8 !important; } .submenu { border: none; background: #2e2e2e; } .submenu&gt;.submenu-column&gt;ul&gt;li&gt;a { color: #f8f8f8; } .logo { font-size: 1.5em; color: #f8f8f8; line-height: 48px; text-indent: 0px; background-image: none; } .logo:hover { text-decoration: none; color: #ccc; }
I'd change it to something like: modifed.isBetween.bind(modified, startTime, endTime), ... And then call the function in the `some` predicate, that way you preserve the short-circuiting behavior of `if`.
lol, didn't take much
I just updated it. It wasn't working properly when you hovered over an item in the nav bar
it's just for fun, but I'm also gonna host it for the public to use. 
Skip the boring parts, get to the cool projects and review the boring parts if required for the cool project.
hmmm I think React might be more useful for future projects. May as well go with this. Thanks for the suggestion :)
I'd say unless your team is going to go heavy into fp, or fully point-free, lodash is probably better overall. Ramda's got some nice additions to the toolkit though.
Much appreciated, just installed it with stylish! Thanks!
As I've spent quite a few years in my career working with Flash/Flex, this kind of saddens me. What's worse, Flex was really the guide on how to write HTML component frameworks, and everyone just chose to ignore it. MXML and Actionscript all in the same file represent a component, MV*, freaking awesome standard library, static typing, one/two-way binding. Kind of sad really, should have just ported it all to JS/HTML and we would have been light years ahead where we are today...
today is my birthday and this is my favorite present so far
Functions are your friend function shuffleChildren(query) { const el = document.querySelector(query); Array.prototype.slice.call(el.children) .sort(() =&gt; 0.5 - Math.random()) .forEach(child =&gt; el.appendChild(child)); } setInterval(() =&gt; shuffleChildren('#group1 &gt; ul'), 500); setInterval(() =&gt; shuffleChildren('#group2 &gt; ul'), 5000); setInterval(() =&gt; shuffleChildren('#group3 &gt; ul'), 1000);
Yup, the underlying concepts were awesome, but the plugin was buggy, insecure, and unstable on mobile... 
Adobe Connect conferencing software relies heavily on Flash. There will be a rush to convert that huge thing over to HTML5, I suppose.
Seriously?!
You can read right?
Which one would you recommend? Looks like you have several. ionic2-pagination? posys? The game? Ever been to House on the Rock? Neato. Yeh?
You come to a reddit for a specific programming language and ask a general web dev/hosting question, a fucking stupid one at that, and you the fucking nerve to get snarky with me?!? Eat shit, fucko.
Are you hungry? Have a sandwich bro.. If you think it is a dumb questions, just pass it by and don't respond at all... Pardon me for being "snarky" when you got the attitude first... This is the internet sometimes you will read things that you think are dumb, but it takes a real jackass to respond with a "Seriously!?"
Any reason you can't upload them to your website?
Ok so you have png,css and js files. Generally you might want to have a folder called images for pictures, css for css files and js for JavaScript. In your html code you refer to the path of the file.works the same generally for all files. so say you make a folder in the root of your web server called js and put your JavaScript file in it. You'd do: &lt;script src="/js/ somefile.js"&gt;&lt;/script&gt; same with css and images. I hope this make a sense. If not I can try to explain it another way.
Ok.. I am trying to get this to work on my website: https://github.com/cubiq/add-to-homescreen My website is built in squarespace, so I don't think I can upload a JS to the site. The reason I say this is because I tried uploading the file to the site and all I got was an automatic download when I try to go to the place where I put it. Here is the place where I put it in squarespace: http://www.mcat-mvp.com/s/addtohomescreen.js I found a place online where I can upload JS files so I put the file here instead: http://yourjavascript.com/17540126170/addtohomescreen.js This is the code I added to my website: &lt;link rel="stylesheet" type="text/css" href="........."&gt; &lt;script src="http://yourjavascript.com/17540126170/addtohomescreen.js"&gt;&lt;/script&gt; &lt;script&gt; addToHomescreen({ skipFirstVisit: true, maxDisplayCount: 1 }); addtohome.show(); &lt;/script&gt; &lt;meta name="apple-mobile-web-app-capable" content="yes"&gt; &lt;meta name="mobile-web-app-capable" content="yes"&gt; The problem I am having now is that I do not have anything for the CSS and I am not sure what to do with the images. I am new to all of this, which is why this may seem like a simple problem and solution.
As a Mac user, and developer, I like the aggressiveness towards non-App Store apps. It's not like you can't run them anyway; you just have to explicitly sign off that you know what you're doing. Safari's lagging towards embracing new web standards is frustrating though. 
I hate it. Honestly. It looked fine how it was...
On your webspace with your other HTML files.
Put an admin username and password in plaintext and the server of the company's main user permission and management database in plaintext in a publicly accessible Javascript file? Sorry pal, that won't happen.
Put them in teh clowd 
I know a few Flash developers still doing their thing. Mostly working on in-house visualization tools that didn't make sense to do in other technologies than Flash in the late '00s.
I'm always hyped up for new layouts but I didn't like this one much, sorry :/
Isn't markdown-friendly image an oxymoron?
Sad thing for flash games is, that you wont be able to play old flash games after 2020. Killing flash is awesome, but who will transition old games? Nobody... (unless there will be some tool to recompile them somewhat?)
&gt; Squarespace There's your problem. Squarespace isn't a real web hoster. They only offer you to use their WYSIWYG UI to create a simple website. Try GitHub pages instead or host it yourself with https://caddyserver.com.
Yes but on android it will also prompt from within the home screen app because there's no way to discern one from a browser page. 
You also cant scroll all the way to the bottom on ipad.
Please improve the menus, remove that fading. It makes them harder to use. Why make all your users lose time every time they want to go in the menus ? And why is there even a *close* cross button in menus when they close on mouse leave ?
Not sure about you guys, but I love it. 
Of course it wont! That's for the purpose of demonstration. Anyone deploying in production has their secrets passed and loaded in at runtime. This applies to any library.
The usual chaotic mess with giant fonts and too much wasted space that is seen to be "modern" nowadays.
Flex was really nice, although i have trouble seeing how todays technologies aren't light years ahead of Flex, or are everything Flex wanted to be. I mean, what are you comparing it to, jQuery? 
MDN, you have to choose. It can be black over white or white over black but **not** both on the same page. This permanent switch is a disaster for our eyes.
Thanks! I'll try a thread there. :)
Thanks! I'll try that.
Antitrust doesn't apply because one can use other phones, and Apple doesn't have market domination.
Here's Formidables Ken Wheeler on why this is a crazy idea: https://youtu.be/WEQx3wz8QeY?t=53s First of all statistics speak against the claim, it is no where near taking anything over, the web plays the smallest part on mobile. Web-view based "apps" are the slowest/laggiest available and mobile users do hate them. PWA's don't work without polyfills on many devices, they're severely limited in what they can do and each little spec that tries to add more proliferates 5-or-more years until it becomes stable across brand new devices leaving outdated devices in the dirt that will never get it. The web as a common interface for apps has been Googles fever dream for a decade now and it's still in its lamest infancy and riddled with problems without any solution in sight other that catering to the lowest common denominator. Javascript rendering natively (react-native/native-script) makes the browser irrelevant, javascript isn't dependent on it any longer and therefore it is free from its shackles. It doesn't need a web-view and can easily produce a real app on a native canvas without restrictions, ...problem solved.
Reading your comment was the first time I have considered passing in secrets at run time. I've been a darn fool and am joyed to have more secrets to remember now. Gosh, what a brilliant idea. Thanks :)
Puffin, an alternative web browser for Android, [appears to include Flash emulation "in the cloud" (?)](https://android.gadgethacks.com/how-to/use-puffin-browser-play-flash-games-android-without-wasting-data-0177049/) (free for 2 weeks, unlimited in paid version) 
Does anybody have already tested wavelet compression in JS ?
The new logo looks like Jar Jar grew hair only on the back of his head. Sorry. First thing I thought of. 
IMO, the left column is too large on most pages, i'm nearing needing a horizontal scroll-bar when full-screen .. resizing the window down, it's alright except then the menu at the top of the screen is immense. 
also, this. The color selection is .. upsetting. 
webOS is dead - long live webOS! 
I actually like the direction they took for this redesign but the site kinda feels like "beta". I think they released it bit too soon. 
There's always webOS too -- attempted to compete with Android and iOS originally, but without throwing multitasking out the window. And came with some pretty damn neat features too. 2009 using web technology as it's primary interface to the user. And it's underpinnings were frequently written in Node.js. In 2009. And it's still out there, LG has it on their TVs now. A system made in HTML + Javascript, and Node.js. Though it's added Qt, QML, and a bunch of native code as well, since those days with Palm and HP. Definitely a system that was before it's time. I'm working with a lot of cloud services right now, and I can't count the number of times I've said recently "Oh, that's just like a piece of webOS, just running on a massive cloud server instead of on a CELL PHONE." 
so... webOS? :-D 
I imagine there is a way to do it, I'm pretty sure that CarbonPoker (the only thing I've ever done this with) doesn't continuously reprompt me. Perhaps it adds a parameter to the URL or something that tells it not to, though. 
When I set out to learn a new language, it's for one of two reasons: 1- Work requires that I work with something in that language. 2- There's something that I want to modify, that is in that language. Until I started doing this professionally, #2 was the only reason I had picked up (to a minimal degree) a whole lot of programming languages. When I find a project that I like, that I want to either contribute to, or make something work differently, or add features to, or whatever .. that's what keeps me motivated. 
No, resolve is definitely not being called. In fact, any async call is never executed. I tried a fs.writefile before resolve and nothing, I tried the request.get too and nothing... There is something strange in the page.property('onResourceRequested', function(requestData) function that makes async functions inside not working.. I don't understand it. I tried to create a global variable at the top and fill it inside the onResourceRequested function but the global variable is always null, never filled. If I console.log the data, on the other hand, the data is printed. This is driving me crazy...
Why do use use Circle CI instead of Travis CI?
Well, I still have all the ingredients to make a fully loaded XP box so I'll be good. Though maybe I should share my software repo one day so others can do the same.
 Child Component &amp; The Ratio Component are explained very nicely. The childNodes returns a collection of a node's child nodes as a NodeList object. I find nodes collection are sorted as they appear in the source code that can be accessed by index numbers.
Issue resolved!!! page.property executes in the PhantomJS process. PhantomJS does not share any memory or variables with node. So using closures in javascript to share any variables outside of the function is not possible. using page.on('onResourceRequested' fixed the issue! Thanks to all of you.
The white on black headers are really annoying to scan read. It seems worse for this change. Designers and brand guidelines messing things up for developers as per usual. 
&gt; There still are flash developers out there? Yes. We mostly use Flash in conjunction with Scaleform to bring fancy UIs to AAA video games. However, even in that space, Flash is going to go away, with [Autodesk no longer selling Scaleform licenses](https://www.autodesk.com/content/autodesk-game-middleware). The new kid on the block is [Coherent](http://coherent-labs.com/), which uses HTML 5 to render UI.
If runs server-side on a node.js server, why not? We currently have something like that with PHP to get data from AD for our intranet sites - pretty sure username password are just hardcoded somewhere. How else would you run a task that automatically reads data from AD every night into your CMS?
No offence, but Flash was always shit, from day one through to today. I'm glad that shit is out of our lives. Forever.
Each to their own. Women do it for me.
In general, it should work. &gt; simply filling an array with coordinates from where the user clicks in the area You can't use a plain array because you need to distinguish points from different regions selected. It could be a 2D array – array of regions, where each item is array of points. &gt; I plan to do the latter with HTML area and image map attributes. Not sure it's the best solution in case of large amount of points/regions. It's probably better to draw the map (or at least the regions) by canvas and handle them by javascript. But it's mostly about performance, you can make the first version with HTML and see it's it's good enough or not. Also, if it's an option for you, you can check Google Maps API (or maybe other similar, such as Yandex Maps API)
circleci 2.0 is way faster
Thanks for your reply! The idea I currently had is that when the user creates such a region, it will be one region at a time. So no multiple creations possible. Because I need them to put in other information as well. So I would only need a simple 1D array. I might look at the options I have with the canvas indeed. I did check some GIS API's but I found them to either be a bit too complicated for what I want to do or not really usable. 
Do people use a lot of Meteor.js?
Just 11 hours ago! https://github.com/tc39/proposals/commit/daa3ca6f11b36e32582944c8e84c3f86328d25ba
I have to admit that I like the way they redesigned the site. Except for the header on mobile, of course.
Yes, it is faster than other frameworks.
women who reach EoL? why i never!
Neither do I. I just assumed since they have to make money somehow since they still do exist.
Finally!
I just opened a new grounds game. And it ran with unity it seems that is how they continue to exist.
[rolls eyes] .... [upvotes, grudgingly]
i want to talk about your performance last quarter, stop by my office carl.
000webhost.com
Yep, I can't believe they spent so little time polishing what shoild have taken them no more than 10 minutes.
Thanks, I'll probably use this to. Too lazy to have done it twice 
Cheers for these bug reports guys! Would you be able to add these as issues on the github page? https://github.com/alex-saunders/ecmasyntax.io u/Mystrl u/Anoian
You're absolutely right, i'll get that in the README asap. I chose to keep the `public` folder included in the repo incase anyone wants to try running the app without having to build it (proxies restricting npm etc), i'll definitely make it more clear why it's there in the README though.
Good point, most of the examples are taken from MDN and I haven't assessed all of them yet, i'll definitely work through them and update them to use more ES6 features
The spinner and loading bar are both controlled through redux, the spinner shows when I have the `activePage.isLoading` flag enabled &amp; the same for the loading bar, however this also updates on the various stages the `fetch()` request gets to, to allow for a more detailed representation of how much has loaded. Ideally i'd like to only show the loading spinner after content has been loading for a certain amount of time as at the moment it just flashes in as the loading is quick, but that's probably for the next release!
this is a long ad for dynatrace. read [this](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/) instead. it's linked to in the article and provides the info the article does but doesn't try to sell you on services.
I like minimal, somewhat brutal design, but in my opinion it hasn't been executed particularly well here and it really doesn't suit the MDN. The Open Sans looks even more or of place too.
&gt; As I've spent quite a few years in my career working with Flash/Flex, this kind of saddens me. I mean if you have really spent a few years working with Flash/Flex, I wonder why it saddens you. I also have spent a few years (10) with Flash/Flex, and I could see things ending this way from miles away. Adobe didn't manage Flash properly. The player is running on a crappy C codebase full of holes, which they were terrified to touch, because of backwards compatibility (there's no standard to follow and reimplement here - the standard was "it works as previously coded"). They didn't even *see HTML and JS as a threat*. I was there. They thought *Silverlight* was their big competitor, because it's a browser plugin drawing vectors, like Flash is. And that's after they were repeatedly told, long before the iPhone and HTML5 happened. "HTML, pfft, it can't do what we can do!". This kind of complacency and shortsightedness can only result in what happened.
That's a bold statement. Faster in which ways? I used Meteor years ago, and I truly enjoyed the developer experience, but when they started dabbling with Blaze alternatives, the whole ecosystem became way too fragmented and hard to follow. But faster? Not sure how.. 
Your example is the classic example of unnecessary wrapping. The use of deferred here serves no purpose because you get the same results simply by calling (and returning) `userService.get()`. That returns a promise that gets either resolved or rejected just like the deferred - the deferred which is only forwarding on the results of that call anyway. The use of deferred in this case is analogous to doing something like: function getFunction () { return function () { userFunction() // why not just return userFunction? } } Instead you can do: if(userPromise){ return userPromise; } userPromise = userService.get(); return userPromise;
Thanks for the link. I must say though the use of diagrams is really useful in the article. I get what you're saying about the commercial aspect though.
What an embarrasing and wasted oppurtunity from adobe. Now we are going to have to deal with DRM inside the html5 spec and the blobs from google and microsoft. The browsers are the plugins now.
https://www.reddit.com/r/javascript/comments/5xzjpt/my_study_plan_for_fullstack_javascript/
[removed]
faster? 
AFAIK almost no experienced devs use it, but it has an audience in non-developers (think young entrepreneur types), due to its easy learning curve. I'm not putting down Meteor at all, I'm glad non-devs have something easy that lets them turn their ideas into a working product. Disclaimer: I checked it out 2 years ago, idk its current state.
This is _excellent_ news. Great example imo of the ecosystem proving demand and testing solutions for a problem, and then developing from community consensus into a real standard everybody can depend on. Little slower than I'd like, but such is the way of standards processes...
We must thank CoffeeScript, as much as I don't like it, for having kickstarted the standard process... it was stalled for years
You can tack on a `then` to the `get()` call and throw an error in there to reject it. Errors thrown in then callbacks will reject the resulting promise. Anything returned will be what its resolved with. userPromise = userService.get().then(user =&gt; { if(!user.email){ throw new Error("Email does not exist!"); } return user; }); if `get` rejects, the `then` above is skipped, so those errors are still propagated. This adds an additional layer on top of a successful `get` rejecting the `userPromise` promise if `email` doesn't exist. To make sure the `user` gets passed on to `userPromise`, it gets returned.
Seems to be my experience too, I used it in the pass before but after being a Developer for a few more years I struggle to see why you would use it 
Not a mobile dev but I refuse to learn a proprietary API for a closed platform out of principle. If I'm forced to by circumstances (i.e. can't use Qt or React Native or whatever), I'll do what these people are doing, learn the strict minimum (eg just the UX part) and use web for the rest.
very good work. im learning a lot from your react style. havent gotten into redux yet at all though
I agree. I don't mind the design, but the menu on mobile makes it nearly unusable on my phone.
Currently, I am using it with angular and MDB, it's working absolutely fine. Rather than blaze template try it with some other framework
Many people don't want to be a developer, they just want to start a small business and the development is the means to an end. I sympathize entirely, especially since the dev world is a fragmented mess. If I told you you could renovate your house by yourself for a fraction of the time it would normally take, wouldn't you do it? Even if there's a catch/compromise ("your bathroom can only have white tiles"), you probably won't care. If I wasn't a developer, and didn't want to become one, I'd use Meteor.
It depends honestly, if the team is using react and you want to force angular it would be better to fit the team instead of forcing to rewrite the app or have weird workarounds and hacks. I agree on your point for not learning a new API that is closed source. Sure Android is not but when we have HTML CSS and JS which are easy to learn, why not use them ? Simplifies platform development and atm JS is the only language that has different engines competing for performance. That just means something.
I primarily use Meteor. It's great for rapid prototyping an app with it's near instant ready to build CRUD full stack app. It has NPM access to dependencies. Works with Angular, React, &amp; Blaze Frameworks. Super Easy, yet fully secured User Accounts / User Authentification package. Security with Methods Calls to server to prevent injection hacks. It compiles into iOS &amp; Android Apps fairly seamlessly. Deploys to Digital Ocean or their own Galaxy. Also, rather than being a RESTful app, it's got a Publisher / Subscription structure with live push much like AJAX. &gt;Meteor is built from the ground up on the Distributed Data Protocol (DDP) to allow data transfer in both directions. Building a Meteor app doesn’t require you to set up REST endpoints to serialize and send data. Instead, you create publication endpoints that can push data from server to client. This enables Real Time Communications (RTC) that I've seen used as scoreboards for Skeeball games, where the skeeball lanes are physically in 2 different Cities/States. The skeeball lanes had Aduinos &amp; Raspberry Pi's logging the points &amp; relaying the score via Meteor App. Since it's universal platform, the scores were live populated via a Web page, iOS or Android app. I'm still very much a newb to building Apps. Last year, I jumped started a self-taught learn JS by diving into the MEAN stack. I had a project App I wanted to be created, and rather than being an ideas guy, I set off to learn how to make it myself. But I found the learning curve for MEAN to be steep. To make a MEAN app, requires A LOT of pre-configuring before you're able to get to the CRUD. - Node /NPM - Package.json - Express - Server.js - Webpack &amp; Webpack Dev-Server, Webpack.config.js - Babel Loader - Angular - UI-Router - SASS - BootStrap (Finally able to build an APP!) - Angular - Mongo - Begin hooking up the CRUD Meteor compiles a ready to build app with a simple command: meteor create my-app. With that, I get all listed above plus hot-live reloading and a running server. I'm surprised Meteor isn't more popular. In talking with others at Meteor Meetups. The theory goes, build web apps is like building a computer in the 70's. It takes a certain level of fortitude to understand all that necessary to compile like how PC master prefers to nit-pick components for building a computer. People really love being highly selective on their Grunt/Gulp/Package.json. But then there are people who, rather than nitpick on the build of their computer, just want to get to work on the computer. It's like buying a Dell or an HP rather than assembling a PC from scratch. Meteor gives you that Packaged app with nice bells &amp; whistles. And like a Dell Desktop, should you find that the pre-packaged dependency component to suitable for your needs, you can always switch out the component, like switching out a graphics card. That's my 2 cents on meteor. I love it. For the record, I'm not affiliated with them. Just hope it get's more popular &amp; the community gets more crowded. 
We are using it with multiple apps. Never used with blaze. But it works so well with angular (1, 2-4)and reactjs.
faster as it get data from sockets rather then conventional REST.
Oh you meant my hybrid project. Https://GitHub.com/idlelands/idlelands
open the console type in: console.log("Hello World!"); 
just make it remember my language preference, English version is always better and I'm tired of switching it on every time as i'm open mdn from google
What's the throughput you are seeing on your apps? Because my last experience with Meteor was about a year ago, and it was falling apart when faced with rapidly changing data (think realtime status updates of many sports games). Adding nodes was no help, because every single node got overwhelmed by processing the same data to be sent to clientside. All you could do was switch to progressively larger and larger nodes :/ It really, REALLY turned me off from serious Meteor work. That, and having to use mongo.
maybe it'l be more clear with regular columns, with height associated to popularity of post. It not so cool when circles overlapping each other, column would be thinner so overlapping would appear less often. In fact I liked it, in the end of the year when all people trying to remember what they did in this year and what this year gave us, this thing will be just what needed. Especially I can think of reddit place it on the main page in the end of the year. 
I believe map/reduce/filter are slightly slower than their looping equivalent.
I once made an intern code in actionscript for a whole summer. He still hasn't forgiven me.
I'm not experiencing your pain point, yet... not sure if things are different, but I'm not piping "many sports games" level of data atm. It looks like they’re finally breaking up the MongoDB marriage and replacing it with their Apollo system that abstracts away the real-time stuff. Here’s from their [roadmap](https://github.com/meteor/meteor/blob/170de0c11878e965b4a52560840401d103dcaa3a/Roadmap.md) (early Feb 2017) &gt;Apollo is our approach to giving Meteor developers SQL and other database support, the ability to choose between realtime and static data, and improved performance analysis…. The next priority for Apollo and Meteor is enabling Meteor developers to choose to replace MongoDB entirely with GraphQL on top of other storage engines.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [meteor/meteor/.../**Roadmap.md** (devel → 170de0c)](https://github.com/meteor/meteor/blob/170de0c11878e965b4a52560840401d103dcaa3a/Roadmap.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dkqsgre.)^.
There's certainly not many browser-resident Flash developers anymore, but there *are* still lots of developers working with Adobe AIR (basically, Flash outside of the browser) and the Starling Framework to create desktop and mobile games and applications. While Adobe has announced their plans to remove the Flash Player Plugin in 2020, **[they are still committed to Adobe AIR](https://forum.starling-framework.org/topic/air-roadmap-update)**.
&gt; I mean, what are you comparing it to, jQuery? Yea actually, I think they were comparing it to what was used at the time. I didn't use Flex, but I did AS3 in 2008/9? and I recall some people doing Flex at the time. That's right around the time when jQuery was getting serious marketshare. If Flex is what they claim, it would have been 5-7 years ahead of its time.
Awesome, glad to hear it is fixed!
I was referring to this &gt; Kind of sad really, should have just ported it all to JS/HTML and we would have been light years ahead where we are today... I guess Flex could have well been ahead once, and they would have been right saying that it was better than jQuery. I enjoyed to make apps with it while it lasted, but from todays standpoint ... seems to me some people still think jQuery is the state of the art?
I misread the title and was disappointed when the article didn't make fun of Providers and HTTP Responses.
I recommend that you check out Leaflet JS (http://leafletjs.com/). I used it on a very similar project and it was a lifesaver for doing the sorts of things you are talking about. 
Flex was alright as a language if you go for that thing, but my last project was probably millions of lines, had a 5000+ line file that was just "this view binds to this controller, this view binds to this controller, this controller binds to this model, this controller binds to this model..." It was annoying to edit, maintain and look at. It could have been poorly implemented, but dealing with MVC in Flex just leaves me with a very poor feeling of overly verbose programming. On top of that, dealing with proxies, interfaces, and all that just bugged the shit out of me as well. I couldn't understand why I had to edit so many files just to add a dialog.
As someone who has basically just kept using Bluebird, I sometimes forget that native promises don't have stuff like `.finally`. Great to see it make the standard. I hope some of the other "quality of life" utilities (`.map` and ~~`.race`~~ from Bluebird would be great) from various promise libraries make it into the specification as well. 
That sounds about right. The last third is for people who want to dig extra deep into a given topic.
As a developer with over 10 years of experience with javascript I use it for a production level product with real world users. Now why do I use it? A project was started in Meteor and was roughly fleshed out from a front-end standpoint and I wanted to learn a reactive framework. Would I still make the choice today? Two years later? No, but a lot of good has happened with Meteor in those 2 years. Also the ability to use react within Meteor, or Meteor along with Blaze is making the transition from Meteor to React easier (still not close, but trying to move off of it). Truthfully, while the pub/sub system is great for getting something up and running quickly, there are big limitations in actual practice if you have a lot of data in different views on the same screen. I am interested in GraphQL, just haven't had time to look extensively into it, that and I still don't know if implementing GraphQL in Meteor will be worthwhile for helping us move away from it in the future. Anyway, sorry for the rant. But I wanted to chime in and mention that some people do use it for production level products, while recognizing the limitations. :-) Edit: Just actually visited that link, it actually shouldn't be called a "tutorial" in any sense.
Is it different from Promise.race? https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise/race
Does this have any impact on how one would write `async/await` code? 
go to [javascript.info](http://javascript.info/).This is one of the best set of beginner/intermediate tutorials I've seen yet.
Considering you can already use a finally block with async/await syntax, I'm really surprised there isn't already a finally method for promises.
I cleaned up your code a little bit but it works fine: https://jsfiddle.net/mhhk0opd/
Thanks a billion! That's exactly what I wanted! 
Don't forget `flatMap`!
AFAIK async/await is just syntactic sugar on top of promises. With that said, I would imagine it just means that what you're writing now is moving closer to being fully, properly standardized.
I don't think so? Pretty sure you can already use try / finally with async / await. I suppose this would just be a way of doing the same with promises. 
https://github.com/egoist/cac#why-not-commanderjs-yargs-caporaljs-or-meow Those are week arguments against yargs. Instead of spending at least hundred hours thinking of the project name, writing documentation, programming, testing and marketing, you could have raised the issue with Yargs, created a PR and get it approved in 1/4th of that time.
No as you could already write try{} catch(err){} finally{}
What I meant by light years ahead is, we've reinvented the wheel over and over again with Angular/React/etc component libraries, and were still not anywhere close to a **complete** solution that Adobe Flex was... As some background, Flex was released in 2004 (jQuery wasn't released until Jan 2006). Nobody really used Flex at the time because the licensing model was unrealistic. With Flex 2, ~2005/2006, licensing changed to "per developer", it was fairly cheap, and Adobe introduced: - Actionscript 3 - static typing - data services - Complete set of user interface components and utilities (free) - Complete charting library (premium) - Flex Builder - a development suite (based on eclipse) - Contained a layout builder (good for newbies) With Flex you wrote components, which are just as you would see them today, HTML elements. You wrote Flex components in MXML. MXML is markup language which has two sections within a file, the XML (html-like) markup and a `script` section... the markup supported data binding (using `{}` syntax). ---- The point is, if I wanted all these things today, I'd have to bolt together so many different libraries, TypeScript, Angular or React + something, Bootstrap/Material (mind you these don't even have Grids), d3js or some charting library. That's not necessarily a bad thing, but it's all just grasping at straws to make everything work together. And animation is still no where close to being comparable. Obviously there were some things that were just as broken with Flex as there was with JavaScript at the time, but you get my drift.
() =&gt; this.incrementKarma();
nah, create PR for what? nothing goes wrong there, I just want a simple alternative.
 $(document).on('click', function() { $('.open').removeClass('open'); });
Moz is dedicated to fixing* problems no one cares about. Because of reasons. When they eventually fail due to their pathetic browser market share no one should be surprised.
Oops, forgot that one's already standard. Like I said, I haven't done a good job keeping track of what's standard and what's not.
What a great resource, thank you for sharing!
This will be my new resource to recommend to people when they ask for where to start with JS
This looks pretty good. I will definitely recommend this to js beginners. Thanks for sharing.
...
Use this: https://github.com/jantimon/html-webpack-plugin Use it to generate the HTML file, it will include a script tag with whatever name your bundle has.
&gt; var indexTemplate = swig.compileFile('./src/index.html'); &gt; &gt; var indexHtml = indexTemplate( { env: TARGET_ENV } ); &gt; &gt; // write out index.html to dist/ &gt; &gt; writefile( './dist/index.html', indexHtml ); &gt; And I still need to keep this for dependency issue right? Otherwise I am getting error like https://gist.github.com/aruprakshit/901578c5d338fd862e0b1be4dfff26b6 .
I did the same thing a long time ago. I was actually pretty surprised how popular clipboard.js became considering how easy it was to implement.
&gt; incrementKarma is not a function. You forgot to bind(this), buddy. 
Maybe.
The PR would never be accepted.
One assumes the cruft in clipboard.js comes from the requirement to support legacy devices.
command+option+i on mac
You gotta admit the plugin's name is great SEO all by itself. clipboard.js isn't useless. Far from it. It's a competent catch-all solution with far-reaching backwards compatibility. But as a developer, it pays to pay attention to your specific use cases for robust, catch-all plugins, as well as just how much backwards compatibility you need for your target audience. I needed a copy button for 1 textarea in my web app. I had already implemented a banner asking non-[ES6](https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015) users (nowadays, that comes down to... IE11 and below) to upgrade their browser.
I've worked with folks who went to bootcamps. They're good JS/React programmers - maybe not a lot of context with deeper programming concepts, but that's okay. From other comments, I would say the bootcamps themselves won't guarantee you get a job, not everyone comes out fully prepared. You still need to be motivated and determined enough to follow along and learn it all, but if you do then you should be prepared for a junior-level position. I guess it's kinda like an electrician or mechanics trade school - you still need to put in the time and effort, but it can get you into the field. EDIT - Also, make sure you enjoy programming before you plunk down the money. I'm sure that's a big issue is folks who join up but then end up hating it.
You realize webos did not, despite the name, rely on web technology?
You think *this* took a while, CSS now has an actual grid system. Guess how long ***that*** took?
That *can't* be valid JSON. Are you sure the quotes aren't escaped?
Congrats, you don't have to support IE &lt; 11.
You're right. It's not valid JSON. I should rephrase: "how to turn this ~~shit~~ stuff into valid JSON".
That's actually wrong as arrow functions automatically bind this
I wish arrays had that so bad. So much code using .reduce could be simplified.
This is GREAT! Really great job on this. People like you are so wonderful to have in the community. Thank you so much!!
Could do something like searching for the comma or closing bracket which would end the key: value pair. Then, assume the last quotation mark you found was the closing one and escape any other quotation marks between the opening and closing one. Of course, this could cause problems if your strings ALSO contain commas and closing brackets, but unless there's some other reliable regularity to the file you're parsing, there will inevitably be some ambiguity. Maybe just try to whittle down the file into only ambiguous cases, and do the rest by hand?
I'm pretty sure it's impossible, considering all scenarios; that's why quotes need to be escaped in the first place. If the data is standardized in a way where you can make assumptions about where the last quote will be, then you can use regular expressions to attempt to escape the inner quotes. Why would you have this JSON like this in the first place? Can you go back a step and fix how it is produced?
Pretty well written. Only thing I would suggest is to maintain consistency. You are using both functional declaration and expression (particularly in the random number generator and dna translation). Try to stick to one, unless it's absolutely necessary.
Hey thanks man, I just saw it, point well taken 
I am pretty sure the `filter/map` version is much more performant than the `reduce` version. The functions for `filter` and `map` can both be considered constant (a less than check and getting a property is basically constant). `filter` + `map` is thus O(N+N) or simply O(N) (linear) since we have to iterate over each element in the list. The `reduce` version however have to copy the array which is O(N) for each element in the array and thus its running time is O(N^(2)) (quadratic) which is considered a lot slower. This is of course only considering _worst_ running time and this particular example. Doing `push` on the array in the `reduce`instead would probably be the fastest overall but I am sure it would not matter anyway in real life. The `filter/map` is much more readable and easier to understand what it is doing. I would (always) favor that. Often the simpler solution is the best.
Oh but copy works all the way down to IE8