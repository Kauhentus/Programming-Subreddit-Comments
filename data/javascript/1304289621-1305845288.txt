Massive flamefest, so I'm not going to bother responding to most of it, but... &gt; Writing a plugin for jquery is more straightforeward? Seriously? You don't need to write a plugin if you don't want to use this plugin. You just need to implement the same _functionality_. Namely, you need to select the correct link and apply a class to it. This needs to run exactly once. If you are using a framework, this could be implemented in two lines or so. Pretty straightforward if you ask me.
Yeah, they got my hopes up when they said rebuilt from the ground up - when its still just another crappy eclipse based product.
If you've read [the article](http://hacks.mozilla.org/2010/06/beyond-html5-database-apis-and-the-road-to-indexeddb/) posted by BadCRC, you will see that many developers want to use WebDB. The indexedDB goes against the DRY principle and I can understand that it gets troublesome to have to handle yet an other different layer. Most of the time, programmers write code that interacts with RDBM systems on the server side. With WebDB they had a very easy way to port some of the code on the client side and save them a lot of work in order to offer more responsive applications that do not require as much pressure on the server as it does now (and yes, somehow, NoSQL would become irrelevant on trying to solve the "scalability" problem as the "scalability" will be in the browser) Now, if they want to do the same thing, they will have to write YET an other application logic in FF... I can understand that it pisses off programmers and not implementing WebDB is somehow being very Microsoft like ("we know better than you. we do it this way because it rocks."). The API is very wordy, not as powerful as SQL (or if you want to get the same result you will need to write quite a lot of lines and I wonder if you even really can) but indeed integrates better with the javascript language somehow but pragmatism seems a very logical way of thinking a business world. if you look at this comparison between [IndexedDB and WebDB](http://hacks.mozilla.org/2010/06/comparing-indexeddb-and-webdatabase/), you will see with the last example how SQL shines and is straight forward (WebDB:20 lines, IndexedDB:45 lines) What they should do is the opposite: create a layer on top of WebDB that results in IndexedDB and everyone will be happy (-an "ORM" like interface-). If you look at the Sencha API, they have done something very similar to this with the client side code. From RDBM to ORM is a well-known exercise. The opposite is certainly not true. They are saying that using SQL is too dangerous(updates, no real common set of accepted commands available) but well, creating yet an other system is as much,if not, more dangerous (updates=&gt; the same problem or even worse, what will be the API that everyone will agree on? Google may kicks in and say that a is better than b). Creating a group to decide on the subset of SQL to use seems way much easier than reinventing a half-backed squared wheel. I can understand that having bunches of SQL in your code is bad on the eyes but well, you can organize your code to make it clean anyway. For example, I find css transitions and the like very ugly,especially when mixed with other css definitions(I have to say that FF implementations is more CSSish than WebKit one!). Well, I just create an other file that contains everything related to css transitions, animations,etc. A library will certainly pop to bring some OOP interface to interact with it and every one will be happy. FF is a disappointment on this one. 
eh you mom on the web is dumb, I wrote an article about that too.
NoSQL doesn't mean NoInjection, the injection attack risk is the same.
What does he mean when he says jQuery doesn't scale? Edit: I decided to ask this [on programmers.stackexchange.com](http://programmers.stackexchange.com/questions/72928/what-does-douglas-crockford-mean-when-he-says-jquery-doesnt-scale) and post [a link to that on reddit](http://www.reddit.com/r/javascript/comments/h21vr/what_does_douglas_crockford_mean_when_he_says/) in hopes of getting some answers.
 function convertSecToHours(){ //Input var seconds = document.getElementById('inBox').value; //Processing //3600 = 60seconds*60minutes=1hour var hours = Math.floor(seconds / 3600); var newSeconds = (seconds % 3600); //Output document.getElementById('hourBox').value = hours; document.getElementById('inBox').value = newSeconds; } Like this? Also, instead of using the magic number 3600, you might want to make it a variable you can pass into the function, so you can decide later on that you want to convert seconds to days or half-hours instead of hours. Also, magic numbers (numbers that aren't explained) make for badly-maintained code.
Ok, so it seems like you should be able to put in a number of seconds like '86399' and hit the "Get Hours!" button to see the total number of full hours that equates to, and then hit the "Get Minutes" button to see the total minutes left over after removing the number of hours, and hit the Get Seconds box to see the total leftover number of seconds. Like this: function convertSecToHours(){ //Input var seconds = document.getElementById('inBox').value; //Processing var hours = Math.floor(seconds / 3600); document.getElementById('hourBox').value = hours; //Output //reset number of seconds to the number of seconds remaining var newSeconds = seconds % 3600; document.getElementById('inBox').value = newSeconds; } function convertSecToMinutes() { var inBox = document.getElementById('inBox'); var minBox = document.getElementById('minBox'); var seconds = inBox.value; minBox.value = Math.floor(seconds / 60); inBox.value = seconds % 60; } function getSeconds() { var inBox = document.getElementById('inBox'); var secBox = document.getElementById('secBox'); var seconds = inBox.value; secBox.value = seconds; inBox.value = 0; } Remembering, of course, to add the "convertSecToMinutes()" and "getSeconds()" handlers to the elements. Test these out, make sure it's returning save values for your inputs. I don't take responsibility for your grade.
I assume he means that if you have to do a ton of stuff jQuery does it slowly. For instance, if you have thousands of elements on your page and you're using lots of class selectors and/or complex selectors jQuery will have to do a lot of work and will probably execute slow. Its not as if jQuery can't be used on sites with tons of traffic, instead he must mean that pages which are very javascript intensive are better off with other libraries. I've never had this issue though.
Actually, he is talking about the lack of structure (mvc/mvvm) in jquery. In large applications the lack of the defining structure can lead to a mass of call-backs and other code which makes jquery not 'scale' to large applications. jquery itself is one of the 'faster' libs if you are talking raw speed. This idea of jquery not scaling is pronounced when you look at what D. Crockford works on at Yahoo, which is YUI, which happens to be thoroughly built out for 'large' applications with its mvvm structure and verbose namespacing. Edit: I should add that supplemental libs like backbone.js add in this mvvm structure (among other things) which (IMO) makes jquery scale much more nicely to large apps
Interesting. Thanks for the info. I guess its time I finally look at YUI, as I've always been meaning to. Do you have a good link that elaborates on the concept of MVC in javascript?
I personally am not a fan of YUI unless you are truly working on a huge application (otherwise it is just simply too verbose and doing things in it is a pain). As far as a good link, I suppose I would point you to [this video](http://channel9.msdn.com/Events/MIX/MIX11/FRM08) on knockout.js (a library which is similar to backbone as far as what it does and solves in jquery).
If you're doing something large enough to properly require YUI, is it not also large enough to benefit greatly from GWT? GWT is, in my limited experience with both, much easier to scale out to a massive javascript application - so is there some area where YUI is the right choice and GWT isn't? What is it?
I honestly do not have any experience with GWT...maybe someone with some GWT experience can chime in here...
In the end of the talk he says that IE6 was the best browser for 5-6 years. That's pretty decent.
True, I remember those days. Doesn't make up for taking control of the standardsbody and forcing the defects to stay in. Shit, they forced ie6 on us for far too long, that negates "its time at the top." ms also killed early attempts at an open http streaming protocal and they continue to support a subset of the common features that every other browser does. 
This question is answered by [this blog post](http://blog.rebeccamurphey.com/on-jquery-large-applications)
Does injection even matter on a client side db? The user has complete control.
The yo-dawg is precocious. HTML and CSS are different languages describing data that can be manipulated in pure JavaScript. They can also exist as strings in a JavaScript program. SQL + ORM only follows this pattern. PS. see also: webgl shaders 
But then read the comments.
I've always used JSLint for validation and can't understand what all the fuzz is about. He's done (and still do) a tremendous service for beginners and practitioner of javascript with his video lectures.
Unless you build up a query out of strings it is not the same. However fadec makes a good point, injection specifically does not matter anyway.
With GWT you write your code in Java, which then gets compiled to JS.
New global variable: `old_complete` I think this is a very poor method for debugging; the network tab in Firebug/Chrome dev tools (or Fiddler for IE) is all that is needed. I think it's very dangerous to introduce specific functionality/elements into your view that are only for debugging. You've now created another maintenance point, and for what, some prettified AJAX results that have the ability to get munged since they are being rendered in HTML? This is what debugging tools were made for, and you're unnecessarily recreating the wheel. 
Do it, it's on github.
I have been in my free time. I'm also rewriting it so that it doesn't require jQuery. It's really fun to break jQuery down into its basic algorithms. I also discovered a bug in the positioning algorithm for this (although it may because it is using a different position value; I noticed it set position to both absolute and fixed; I just chose one, and I guess it's rendering in the other). It adds scrollLeft to it's CSS left position, presumably for pages with width's &gt; 100%. I tested it on pages with width &gt; 100%, and it was centered by default with no scrollLeft addition. The addition of it pushed it even further left than it was supposed to be. But I doubt you care. Just rambling. In short, I've already coded everything (without jQuery) up to the part where all I have to do is add the buttons. Whenever I do that, I'll release it on Reddit or something. I just gotta come up with a name for it, since I don't want to also call it "apprise."
Oh man this is something I have been waiting for.. just give me the ability to write JS/Canvas games and make them exe's!!!
&gt; Oi, I ~~really want to rewrite~~ am currently rewriting this to support: FTFY :) 
Or that our benchmarks are inadequate. 
http://docs.jquery.com/Sites_Using_jQuery Amazon uses jQuery, not sure how much more he'd like it to scale... 
Amazon.com is somewhat limited in it's complexity as a web application. It doesn't need much more than jQuery to enable someone to purchase a product online. Other web apps are much more demanding and complex, and for those jQuery may not cut it. Personally, I find jQuery's lack of robustness a major flaw, but for people who don't need to write 50,000 lines of javascript code in a complex web app, it will likely work fine. 
jQuery is not one of the faster libs in terms of raw speed. You must be smoking crack if you think so. Year after year, jQuery announces 200%, 300%, 400% speed increases over previous releases, and this could only happen if it were that much slower before they cleaned up their code. I haven't seen those types of jumps in 'performance' recently, so maybe they have done all they can to improve it. The jQuery way of doing things that most people use is hopelessly slower than other ways of manipulating the DOM. People learn jQuery and don't know any better, that using class selectors is a major bottleneck to their code. I've been called in to clean up sites built this way when the performance gets sluggish. jQuery has evolved and is still evolving, but the ways people have learned to use it are inherently bad, and cause these types of performance problems. Using document.getElementById or cached DOM elements is far, far faster than using $(".derp") but this is too often exactly how jQuery is used.
fuck coffeescript
Any library used improperly will be slow, I think its an error to blame the library for this. jQuery is plenty fast, the problem is people use it improperly and that stems from the fact that it is easy to use and convinces people that shouldn't write javascript to write javascript. This is not jQuery's fault...fault the ill-informed user base if anything...
I think the answer in [this thread](http://stackoverflow.com/questions/650764/how-does-proto-differ-from-constructor-prototype) makes things far clearer. Also, \_\_proto\_\_ is deprecated in favor of [getPrototypeOf](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/GetPrototypeOf).
Yeah. I wasn't writing it at the time, but started later that day. It's a sexy script, and I think I'd get a lot of use out of it.
And here's my: Assert(x === 12); which gives this error-message if the assertion fails: Assertion failed: x === 0, function &lt;script&gt;, file tests.js, line 1 [C-style assertions in JavaScript via JSShaper](http://blog.lassus.se/2011/03/c-style-assertions-in-javascript-via.html) 
backbone.js, knockout.js (and others)...have you tried using them? They make jquery work well for apps of the scale you are speaking... Also....I have read a few of your recent comments, why are you so angry?
What he meant by that is that jQuery isn't an application framework. A pile of jQuery snippets does not scale. It quickly becomes unmanageable. You can, however, use some framework (e.g. your own) and use jQuery as base library (browser normalization, ajax, effects, events, etc).
It's the same. In both cases injection attacks can occur if you're 'doing it wrong'. SQL or NoSQL.
I still don't understand the output.
I see someone is at jsconf
I don't go to conferences. I got the link from here: http://functionsource.com/post/zeon-static-analysis-of-javascript-right-in-your-textarea
Yeah .. a legend would have been welcome.
Yep, you can do it with a pre-processor. I'm not quite ready to use a pre-processor yet... but I will definitely check out JSShaper if I can think of some additional uses for one.
why are you trying to change the subject? suggesting that i'm 'angry' isn't going to get you any answers that pertain to the topic at hand. are you trolling me? backbone.js an knockout.js don't provide much towards making jquery scale to complex web apps. there would still be too many utility functions missing for my liking.
Do you have a concrete or even theoretical example? I can see the possibility for a JavaScript injection into a map/reduce or something. I can't argue that if you do it wrong you're vulnerable.
Thread rescue alert: Would a few kind people please upvote [this comment](http://www.reddit.com/r/javascript/comments/h21vr/what_does_douglas_crockford_mean_when_he_says/c1rzw58)? There's an interesting conversation buried beneath it, and it's unfortunate that people will miss those comments just because the parent was downvoted. Thanks!
Just a FYI, I set up a project for the solution at https://github.com/bebraw/jsassert . While at it, I added some extra functionality (nicer between, within + test suite).
That's pretty cool - bookmarked. If you want something less in the users face try [jGrowl](http://stanlemon.net/projects/jgrowl.html).
I never knew about jGrowl. Neat-o indeed, both bookmarked.
Asserter (the JSShaper plugin) degrades beautifully so you actually don't need to run your source code through Shaper until you need more detailed Assertion-messages (when an assertion has failed), if you don't want to for some reason. I recommend to run it with your automated tests. Asserts should be side-effect free and asserter can soon remove the assertions, useful for removing your pre-conditions guards for a release/production version. One example of what an assertion-library can not do. I'm sure you know but to clarify to others: Preprocessors (such as the C one) tend to be mostly textual. JSShaper is a syntax shaping (rewriting/transforming) framework.
Javascript... 32bit Integer... Wow. Just wow.
Or that doing 100k iterations of string += char by char is: 1. really slow unless you optimize for it 2. not something that 99.999% of programs need to do
I fully appreciate the difference. JSSharper creates a complete syntax tree and then allows you to transform it. That is significantly more powerful than a simple regex find/replace style preprocessor. I'm in the middle of implementing an XPath style language for my javascript component model. My xpath expressions will be fully dynamic though, so that you can 'watch' a variable that represents an xpath style expression and get events when it changes in real time. I will definitely be finding a usage for JSShaper in the future. Probably to programmatically strip my test cases from the code base at the very least. They live right in the files that they test, but I will be able to use JSShaper to strip them out during the build process. I'm sure I'll find other uses as well. 
I am not trolling, your recent comments to me seemed offensive and angry, that is why I asked. It sounds like you have never tried using these libs in any serious manner and are dismissing them outright...I have used YUI as well as a couple of these supplementary jquery libs...I certainly did not find them lacking and in many respects I find these combinations superior.
Closed source and terribly UX. Move along, folks. Nothing to see here.
http://stackoverflow.com/questions/307179/what-is-javascripts-max-int-whats-the-highest-integer-value-a-number-can-go-to
Only the binary operators in javascript handle numbers as 32bit integers (as specified in the specs), but the Number object in JavaScript is not comparable to 32bit integers. It is a double which means it can represent numbers far beyond integers 2 billion.
Well-tested...except on mobile. Does not work on iPhone
So this is basically Android Toasts then? 
Is this supposed to play games? I'm using IE at work (probably the problem), and it just downloads the rom when I click on it (which, BTW, is awesome).
That is awesome, well done. What are you working toward?
I don't believe it's closed-source; after all, it's only a bookmarklet, and it's not even obfuscated. Just somewhat minified.
[jnotify](http://www.givainc.com/labs/jnotify_jquery_plugin.htm) is also decent
. offensive and angry? Fuck you. You fucking douchbag, you think you need to psychoanalyze me? What an asshole. You derail this comment thread and try to change the subject by suggesting that I am an angry person based on comments that have nothing to do with you or this thread. Well, fuck off. There. Hows that for angry? You are worse than a troll. I don't quite know what to call you, except an asshole. Actually, trollhole might be more appropriate. I can very easily tell if a library isn't what I need. Your assumption that I haven't checked out these libraries is just further evidence of your douchiness.
lol....confirmation of attitude received...and not once did I try and change the subject....you however, just did it yourself. edit: i should also mention that the only reason i originally asked you if you were angry was because of [this post you made to me](http://www.reddit.com/r/javascript/comments/h21vr/what_does_douglas_crockford_mean_when_he_says/c1s3r6z): &gt; jQuery is not one of the faster libs in terms of raw speed. You must be smoking crack if you think so.
I'm using Chrome. When I drag a rom onto it, it says it's "Running," but nothing else happens.
I'd go further. I've built real world examples which stutter at a single frame or two in Chrome, but are silky smooth in FireFox, IE 8 and 9. Not all speed comes down to JavaScript!
Thank you, John, for all your amazing work over the years. If Reddit Karma were worth anything, and we could donate to admins, I'd give you +100. 
What are you a precious little princess?? You think that statement is angry? You totally are a troll. What a retard.
Actual article: http://joost.zeekat.nl/constructors-considered-mildly-confusing.html
Closed source has nothing to do with whether the source code is obfuscated: &gt; Please note that at least for the time being this software is closed and may not be used in third party software without my explicit consent. i.e. you can only use it as a bookmarklet for the moment. That said, [I wouldn't say this is easily readable at all](http://zeonjs.com/zeon-bookmarklet.js).
Actual article for the lazy: http://joost.zeekat.nl/constructors-considered-mildly-confusing.html
btw, go look at the jQuery 1.6 release post. the benchmark graphs prove that jQuery performance sucks. if they can more than double performance between 1.5 and 1.6, what does that say for the existing sites using (and now stuck with due to incompatability) 1.5. this happens with every jquery release, huge performance boosts. it says to me that jquery isn't the right choice if your web app is anything more complex than a shopping cart.
I see, as in the licensing....I should have payed closer attention to that. I don't think it's hard to read at all, the only thing that makes it any bit challenging is the lack of line breaks, but running this code through a formatter makes it very easy to read.
Yes because performance improvements means it sucked before by default. My point stands, any library used improperly will run like crap. I have worked on large jquery apps and they are not, by definition, slow.
large? how many loc? what problem domain?
doesn't seem like there's anything valid/good. want to point some out that have merit?
Jeebus man I am not going to toss up all of my credentials or work I have done...I am done with this conversation... My point stands, end of story...you have not refuted it and I contend that you are the sole person I have *ever* heard call jQuery slow...
about HTML+CSS: the proper way to create a list is document.createElement("li"), etc.. which can hopefully by optimized. AIUI, the major problem with WebSQL is that we can't prepare for transactions the same way that compiled code can (because people will dynamically create queries out of text). While IndexedDB might suck in the very soon future, long term (i.e. after people learn it) it will do much better for the web.
What is like impact but doesn't cost the $99 ?
I think you don't have much experience with jquery, javascript, or web development.
Yes thats the ticket..hurl insults at me rather than trying to prove your point... You win the internet today, congrats...
Frontend dev here, freelance (former Yahoo)
you are the one who gave up on the conversation. 
Because you insisted on checking my credentials and hurling curse words and insults at me? Yes.
The argument is, "I want to use WebSQL". It's a preference so valid/good is subjective. The point is that there are many of them sharing this preference.
It really depends a lot on what kind of game you are planning to do. Take a look at the Features matrix at the [wiki](https://github.com/bebraw/jswiki/wiki/Game-Engines) to get some idea of the engine capabilities. In any case you'll probably have to try out a few to get a better idea how they work out in practice.
i did not ask for your 'credentials', moron. i asked how many loc and what problem domain, neither one is asking for 'credentials'. i simply wanted to know what you consider a 'large' web application. you call me angry without much reason, i will call you an asshole. simple math, one insult for another - and yes, calling me angry for something as trivial as suggesting you are smoking crack because you think jquery isnt slow, was taken as an insult. oh, and you haven''t proven your point either, that jquery isn't slow. 
People go to conferences on JavaScript? :P
no, because it sold out in less than an hour or something ridiculous like that. Can't even scalp tickets for the damn thing.
Either you have a background in C, Assembly or Perl, or you have a very high tolerance for cryptic variable names.
lolwut?
lol, no, but funny assessment! The variables never bother me much, because it's obvious what they contain....at least when the function names are sane. If the function names had been obfuscated, then that'd be a different story.
I don't think the paycheck was a major factor in making this decision.
Kahn is a badass project.
I've been careful with such assumptions ever since I tried Prolog. Nothing drives the point that the order of sequential arguments is essentially arbitrary home better than trying to figure out how to "intuitively" represent one-way relationships in a declarative programming language.
Make sure you run with chrome. Most, but not all games are supported. Try Zelda, or Super Mario Brothers for example. 
I'll go look it up but Diaspora v0.1 uses mongodb and was found vulnerable to nosql injection attacks. Edit: http://www.kalzumeus.com/2010/09/22/security-lessons-learned-from-the-diaspora-launch/ Scroll down to 'NoSQL Doesn’t Mean No SQL Injection'
I honestly don't understand the implicit conversion of hyphenated data-* attributes to camel-cased Javascript object indexes. It isn't an obvious conversion, and I don't understand either the W3C's or jQuery's decision to go this route.
I found this article deeply informative and very well explained, just like the rest of Peter Michaux articles
It's actually Khan ...OP had a typo...thumbnail clearly speaks.
Chairperson Mitchell Baker of the Mozilla Foundation issued [this statement.](http://www.youtube.com/watch?v=wRnSnfiUI54#t=0m18)
thanks, Captain Obvious! ;)
My bad. I knew it was Khan. Truly was just a typo.
That is good advice, don't inject user input directly into your JavaScript queries. Seems like a no-brainer in this day and age if you pay attention to your craft at all, but good advice nonetheless. &gt; I think MongoDB will let me do all sorts of nastiness here aside from just reading parts of the person object: for example, I strongly suspect that I can execute state-changing Javascript (though I didn’t have any luck making a Lil Bobby Tables to drop the database, but I only spent about two minutes on it) or join the Person document with other documents to read out anything I want from the database, such as User password hashes. That might be a fun project for someone who is not a complete amateur. I'm most familiar with Riak so I can only speak about it in particular. I don't see any opportunity to update, insert, or delete data even if someone was able to inject JavaScript into a map/reduce query. Since you specify the inputs outside of the map and reduce functions themselves it looks like the worst they can do is munge data they can already access in a different way. Am I missing some angle on this? I'm no security expert just a developer.
Riak might be safe from this kind of attack, I don't know. Sorry I'm not really a NoSQL expert.
No worries, I'm just interested.
remind anyone else of [coffeescript](http://jashkenas.github.com/coffee-script/)?
Khannnnnnnnnnnnnn. 
Well, Fuchs.
&gt;Year after year, jQuery announces 200%, 300%, 400% speed increases over previous releases [...] Yes, there were drastic performance improvements for a few specific functions/use-cases with some browsers. Realistically speaking it maybe saves one msec here and another one over there. Nothing drastic. This kind of optimizations are only worth it because it's a widely used library. &gt;The jQuery way of doing things that most people use is hopelessly slower than other ways of manipulating the DOM. Most people either store the result of DOM queries or they use chaining. &gt;using class selectors is a major bottleneck It's not that bad with modern browsers. E.g. using `document.querySelectorAll('.md')` takes less than 1msec here. Classes are also nice for UIX-style (YouTube-ish) event handling.
This is my current project at work (though I've only been on it a short while), and we'd be really interested to hear what Javascripters think about it.
I got a bit sidetracked (ld20 and some other projects), but I'd like to do some more work on this implementation - in particular, there's definitely room to improve the map/apply functions. Right now they just execute the basic search methods and operate on the resulting array, improved versions could perform better if they did the work in place (for instance, the apply functions have no reason to push objects into an array when they could simply run the callback as soon as they get to an item). From there, I might be expanding the idea to multiple spatial partition types (BSP tree, octree, kd-tree, R-tree) with a common interface/structure. I stuck to a quadtree for now because it was useful for several projects I have in mind already and would let me test if my idea would even work in the first place.
Next time, submit a talk. If you get accepted, you're going. If you don't, they usually have some tickets reserved for you. The organizer has written [an article about how he chooses speakers](http://voodootikigod.com/how-i-pick-speakers-for-jsconf).
[Mascara](http://www.mascaraengine.com) (which I am a developer of) is also an implementation of the "JavaScript.next" proposals, so I find this very interesting, and very nice to get a second implementation to compare with. I'm especially interested in "traits" and "dererred functions" which is not implemented in Mascara (yet!). I have definitely noted the need for something like deferred functions, and I have experimented with different ways of supporting this. I wonder if the "await"-syntax is powerful enough, though. In jQuery, promises has "success", "error" and "complete" callbacks. It seems to me "await" only support one type of callback, right? 
I'm here! I gave the talk on batman.js. We should meet up if you're coming to the brunch tomorrow.
FYI, [Mascara](http://www.mascaraengine.com) supports destructuring objects, although not the way you propose: var obj = {x:1,y:2}; var {x:a, y:b} = obj; // equiv. to: var a = obj.x, b = obj.
Keep up the good work! I would love to see a node.js implementation. Ideally, I would like to invoke the compiler step once, on my server, instead of doing it runtime on each invocation.
Here's a small bug for you: function test() { var a = b = true; } &gt; repl(2, 13): b is not defined 
According to [the API docs](https://code.google.com/apis/maps/documentation/javascript/reference.html#MarkerOptions), the position variable should be [latitude and longitude](https://code.google.com/apis/maps/documentation/javascript/reference.html#LatLng), why would you expect a string of "vvv" to work here??
A question: Why include modules? Dependency resolution doesn't seem to be Javascript's forte (although the Eclipse project is doing some nice stuff in integrating OSGi in JS), and wouldn't it make more sense to take a stronger language like Java or C# -- with type safety, for example -- and _compile it_ to Javascript instead? Some of the other features have been missing from JS for a long time, though... variable arguments and iterators, definitely! Nice work!
&gt; It seems to me "await" only support one type of callback, right? I believe that's the case, but I'm not an expert on it. You can always pack different results into a single object that's passed to that one callback. In other words, `await` is just for delaying, and not for control flow. (Another way to look at it is it automatically translates your code into CPS form.)
It's a little rough, but [you can do that now](http://code.google.com/p/traceur-compiler/wiki/CompillingOffline).
That doesn't look like a bug to me. That's parsed as declaring a variable `a` and initializing it to the result of the assignment `b = true`. You never actually declare `b`.
I think larholm's point was that that does work in most browsers now. Are you saying that should be deprecated?
&gt; Why include modules? [Modules](http://wiki.ecmascript.org/doku.php?id=harmony:modules) are one of the proposals that's [expected to go into Harmony](http://wiki.ecmascript.org/doku.php?id=harmony:proposals) (as opposed to say, classes, which are still in the strawman stage), so it makes sense to try implementing them. &gt; Dependency resolution doesn't seem to be Javascript's forte That's exactly why it makes sense to try to fix that. :) Script loading (like inheritance) has a [long](http://www.nczonline.net/blog/2010/12/21/thoughts-on-script-loaders/) [history](http://blog.getify.com/2010/12/on-script-loaders/) of being a pain in the ass, and of having lots of competing libraries to try to solve it. Given that, it makes sense to try to fix it once and for all at the language level. (Which is also why we'd like to solve inheritance at the language level.) It also ties into fixing some of Javascript's scope shenanigans. The modules proposal includes removing the global object from the top-level scope, which means JS will finally be lexically scoped all the way up. Along with explicit module imports, that will give JS a really nice feature: it will be able to *statically* tell you if you're referring to a variable you didn't declare. No more having a typo in a variable name and not finding out about until hours of debugging later. It also solves a pretty obvious hole in Javascript. What language *doesn't* have a way to build a program out of multiple files?
Huh, I didn't realize that works now. Does `b` get declared in the current function's scope, or the global object? My guess is that that would continue to work as it does now, but be an error if you `"use strict"` in your code.
Huh, that's pretty cool. I don't think the current Harmony proposal supports that. [es-discuss](https://mail.mozilla.org/listinfo/es-discuss) is the public mailing list where ECMAScript is discussed. Bring this up there and see what they say.
I'm not positive on anything, but I'd assume it is just as var a; var b; b = true; a = b; Because as you said, if you try the assignments separately, you get an error that b is undefined. 
There's already a perfectly good JS-&gt;JS compiler. It's called cat. ;) Seriously, this looks like a pretty sweet project. I'm a big javascript nerd, so any time someone makes something that will help push new features out, I'm all for it. :) 
There's already a perfectly good JS-&gt;JS compiler. It's called cat. ;) Seriously, this looks like a pretty sweet project. I'm a big javascript nerd, so any time someone makes something that will help push new features out, I'm all for it. :) 
Support for themes was added so growl themes are welcome :)
I'd really love to work at Mozilla or Khan too.
Another crap article from "css.dzone.com", LOL.
Don't act like a shithead You just earned yourself extra downvotes
This is something we've seen a million times. Either write an absolutely amazing new article on the topic, or link to a good one. Don't just spam out your own site. Reported.
Oh knock it off. Talk about delusional. The trend of using Javascript for anything else except neat effects in the browser is BRAND NEW. You act like it's an ancient, revered language that we've been building desktop applications with for decades. Your type only got a boner for Node in the past few years, and still, that use case is infinitesimal compared to in-browser Javascript.
Oh knock it off. Talk about delusional. The trend of using Javascript for anything else except neat effects in the browser is BRAND NEW. You act like it's an ancient, revered language that we've been building desktop applications with for decades. Your type only got a boner for Node in the past few years, and still, that use case is infinitesimal compared to in-browser Javascript.
&gt; The trend of using Javascript for anything else except neat effects in the browser is BRAND NEW. Brand new? Node was created in 2009, which makes it roughly 2 years old. In technology terms, that's _old_. Would you buy a computer or use a browser that is 2 years old (sans updates)? Trend? You really think that all of this non-browser JS stuff is a fad that will die out? &gt; You act like it's an ancient, revered language that we've been building desktop applications with for decades. So, those [HTA](http://en.wikipedia.org/wiki/HTML_Application)'s that I was making in **2000**, aka. desktop apps written in JS, those didn't happen....just a figment of my imagination? I guess I am also dreaming up things like [SpiderMonkey](http://en.wikipedia.org/wiki/SpiderMonkey) and [Rhino](http://en.wikipedia.org/wiki/Rhino_(JavaScript_engine)) from **1997**? And although not pure JS, I guess [JScript .NET](http://msdn.microsoft.com/en-us/library/ms974588.aspx), introduced in **2000** and widely used to build desktop apps, doesn't count either? Brand new, eh? 
I found my required use for JSShaper. I have a javascript framework that absolutely requires get/set property support. Internet Explorer still doesn't really support that feature. Could I use JSShaper to locate all property gets/sets and change them to getX/setX method calls?
Correct, which under strict mode means `b` is undefined and is an error.
This site is genuinely good...
b is not global, b is scoped to test(). It's functionally equivelant to the following, as hacocayb pointed out: function test() { var a; var b; b = true; a = b; } 
Some of these libraries are very immature. And some of them duplicate existing libraries with a proven track record. This list is *twitterific*.
The Mozilla Developer site often comes up in search results (most recently while investigating the History pushState object) A really good resource.
Yes, although it's not a trivial problem to solve statically. JSShaper will greatly simplify finding property accesses, replacing them with method calls as well as for changing the getter/setter definitions. You would create another plugin. But you need to figure out how to determine when o.x is a getter/setter vs a regular property. Another approach would be to trap all property accesses in run-time similar to the watcher plugin, but I don't think that's what you're after.
Does that follow the standard?
Brilliant idea, but sucks that it's only jQuery UI. I'd really love to see a whole list of projects.
Wow, thanks for the resource!!
Wouldn't it be better to just unify the browser APIs for stylesheet manipulation instead of parsing the CSS file on your own?
A surprisingly strong endorsement of coffeescript imo, but I found it to be a good quick overview of how coffeescript fundamentally differs from js. I now understand what the fuss with "this-abusing" libraries and coffeescript being annoying was about.
Progressive Enhancement may be dead, but Graceful Degradation is still alive and kicking, now more than ever.
Because somewhere else I declare var vvv = latitudecode Sorry, should have posted that too.
Thanks! You pointed me in the right direction. I fixed it using this: function meval(titel) { var positie = eval(titel); plaatsMarker(positie); } :D
I agree!
This makes me want to try coffeescript. I thought it was something like haml where it just made the code look different.
I think a telling point of coffeescript is that the working group for javascript is said to be 'taking notes' (source: D Crockford, take it fwiw) from it and attempting to introduce at least some of its advantages into the actual ECMA standard. I personally don't use coffeescript, as I feel it is an added step that confuses things. Everything coffeescript does can be done just with following best practices and understanding js. That said, it does smooth over some of the rough edges (the context of *this*, for instance), and that can be advantageous.. Also, I am not a fan of the syntax personally, but then I am also not a ruby developer (which has similar syntax) so take that fwiw as well...
Seems logic with the progress in both low end CPU speeds and javascript engines. Makes you wonder what would be the role of HTML in the future, if everything is done with objects.
I never actually read enough about coffeescript to understand the problem it is trying to solve. But from reading this article (and similar short ones) I can't help but chuckle, solutions for setTimeout, context? It's kids stuff. Learn real JS. I'm arguing that if you mask away the challenges of client-side programming with a new layer, you'll end up not knowing what the problems were, which will in turn make you a bad developer.
That's why I only program in machine language.
JavaScript is essentially the machine language of the web.
That's my feelings about jQuery, there are so many jQuery programmers out there that have no clue how JavaScript works (TBF there are a tonne of people that use native JavaScript that have no clue either.)
For horrible error reporting? I would miss correct line numbers the most. It is a trivial problem but it requires retooling. Browsers don't yet have a hook for this.
That would be great too! The thing is though, is that Javascript never manipulates stylsheets. Javascript can only manipulate CSS on an element-by-element basis using the style tag. This makes it so you're actually changing the CSS file.
Some of us have gone beyond graceful degradation to cranky aging. 
Get off my lawn!
It seems the author completely misses the point of why PE exists in the first place: it's not due to processing power or download size, it's due to the fact that many UA's, specifically screen readers (used by many who are disabled, not just the blind) do not support JS, and so they act much like the W3C validator, only _seeing_ the content from when the page is initially loaded. If you don't mind losing those users, then by all means, skip PE. That is, unless you're an entity that is legally bound to [section 508](http://www.section508.gov/), in which case you'd be opening yourself up to lawsuits.
It's not the same, JavaScript is insanely popular, people use it for new things every day. HTML5 also adds a lot into the mix. A new specification is forthcoming. If you're a backend developer and need to do one project with JS - go ahead and use whatever you want to hide from the "horrors" of JavaScript ;) If you're a client side developer (especially with clients), don't use an alternative for something so mainstream.
sure but the argument "I want to use x86 assembly" is also subjective.
Coffeescript is a terrible way to learn to write javascript. It will turn debugging into a rube goldberg machine. Your source code is now in coffeescript, not javascript, and as such it will be much more difficult to find other developers who can or even want to work on that code. For personal projects thats fine, but for anything more serious, forget about it. I would not hire a developer if they had any enthusiasm for coffeescript, it just shows bad judgement on where they are spending their time learning if the job they are applying for is javascript/front-end programmer. If I'm interviewing you, I want you to know javascript forwards and back, inside and out, and learning coffeescript isn't going to help get you there. It will divert your attention from being a javascript master. Any company who adopts coffeescript is looking for trouble down the road. It's hard enough to find competent javascript programmers even with javascript's ubiquitousness, and expecting an experienced javascript developer to 'pick up' coffeescript is just an insult and a waste of time. javascript is a common language and coffeescript is not and never will be. The problems coffeescript is trying to solve aren't worth the problems you will introduce by using coffeescript. You do not come out ahead, and anyone who thinks so hasn't thought about all the costs of convoluting their development workflow. Debugging is a major, obvious problem. Lack of tools with utility functions to help code in coffeescript is another - there are tons of editors and dev environments that have many features to enhance the writing of javascript. The ability to copy and paste source and run it in many different places at will is another big problem with coffeescript. I often write javascript directly in the browser as the page is running - it saves me a massive amount of time with page reloads. then i simply copy and paste the javascript back to my source editor and i've saved hours of constant page reloading. you cannot do this with coffeescript. Hanging out in #coffeescript on freenode, you will see a lot of basic, simple questions being asked by people trying to learn coffeescript, like how does a for-next loop work. it's sad really, it's like reinventing the wheel, and there is no good reason for it except for people who just hate javascript syntax and who prefer ruby/python syntax. For those people, there is no problem that can't be solved with ruby/python, as long as they can code the solution in ruby/python. Which is why we end up with coffeescript. But to suggest that coffeescript is somehow 'better' than javascript is just a fallacy. It's an attempt of this tiny cult to hijack the discussions in r/javascript and try to get their ruby/python simulacrum to be more popular. It's a waste of everyone's time. 
I find Javascript to be more abstract and easier to reason about than coffeescript. Because Javascript gives me closures, there's never more than a few functions I have to write to come up with constructs almost as terse as those in coffeescript, but additionally, I never have to tell the difference between "-&gt;" and "=&gt;" to figure out the context.
TL;DR: People don't bother to understand variable scope (especially closure) and abuse ternary operators, so we need another layer on top of js to make it dumb.
The [new twitter](http://engineering.twitter.com/2010/09/tech-behind-new-twittercom.html) handles the DRY concerns here well by using a [language agnostic template system](http://mustache.github.com/). I would say PE is now more important, and easier to implement than ever.
#1. They're totally right. The ease of making a global variable in Javascript is awful and it probably stems from trying to look like Java. The sementics of Javascript are very similar to Scheme, but in Scheme the syntax makes it impossible to make a global by accident. I wish that there was only one to make a global and that it hurt, for every global I'd have to type "I am a god damn idiot and I shouldn't be allowed to program. May I please make a global?" #2. The reactionary in me wants to say if you don't know what "this" is then reconsider what you're doing. This isn't Java. You don't need to make every last thing belong to a class. Just sling a closure and be done. But that's not the whole story. It really is unnecessarily hard to make a class in Javascript and a useful class will likely begin every method with "var self = this;" or the like. Javascript might make it a little hard to make a class for the same reason functional languages don't make it easy to define a global my accident or to mutate a value. Just imagine Brendan Eich sitting beside you saying "dude that could just be a function" every time you stress out about context or prototypes. #2b. I used to love that Perl wasn't afraid of syntax. Then I started really using Perl and I learned why most programming languages are afraid of syntax. It wouldn't be so bad if I just had to remember the difference between -&gt; and =&gt; but the language is full of junk like this and it causes people to write code that assumes that I am fluent in all the idioms that they are, and that I agree that the solution that the syntax allows is the correct one. #3. I will confess, I wish Javascript would just let things be expressions. I hate having to say "return". Coffeescript got that right. But this "a = b ? c : d ? e : f;" is a straw man; there's no reason to put all that on one line with no parenthesis. #4. This is pretty good, but they could have done better. This problem vexed me in Javascript for a long time because I had only had previous experience with closures in functional languages, so I wanted to treat for-loops like they were macros that unfolded into tail recursive functions and 'i' would be a different lexically scoped variable for every iteration. I wish that they had instead of applying this band-aid, had made new control constructs that behaved functionally. I'd prefer to just have tail recursion, but Clojure's solution to this is really nice, let me call "recur" when I wanna end the loop and iterate. #5. I love this. Gimme gimme gimme. This is syntax that no one can be upset about. In writing this longish comment I learned that I don't hate coffeescript as much as I thought, nor love Javascript as much as I thought. Still, I don't think that I'll ever stop having the nightmare where they introduce classes into Javascript and all the sudden I have to write a class inheriting from AbstractClickHandler and implement ten empty methods for every kind of button on my page.
Graceful Degradation for Javascript is a bad joke. Too blunt to be really useful, or only on rare occasions.
Progressive Enhancement is not only about the presence of JavaScript or not. It's not a single, blunt boolean choice between awesome and shit. It can get really fine-grained. Initialize most stuff when the user has javascript, enhance some more if the browser e.g. supports Canvas or the history API etc. Avoid browser bugs by partially using the non-js version for certain buggy browsers etc etc. 
I'm pretty sure I saw an API to change stylesheets somewhere. It was so horrible tho, I didn't want to look further into it. Will look for it now, hold on. Edit: Found something, it's even in the spec of the W3C: http://www.quirksmode.org/dom/changess.html . You'd just have to unify the different rule-output with the same "markup".
Aww, reddit destroyed my formatting :( I'm a such a n00b. Pretend that everything I wrote was awesome and it'll make sense.
Oh, i didn't know about that, but wow, that is horrible. (btw your link has a "." at the end and is thus broken." Even still though, it can only change CSS that is in your &lt;style&gt; tag on your page.
The utility in Coffeescript comes not from masking those problems from developers. It's not "you don't have to learn about 'this' because you can just use Coffeescript!". The utility comes from abstracting away these issues from your CODE, so you don't have to write tons of repetitive boilerplate or use a library which involves a run-time penalty. Coffeescript allows you to strip away the significant gunk involved in most Javascript development, letting you more clearly express your program logic, with less development time, and faster code....it also provides incredibly useful facilities (list comprehensions, destructuring, etc) you simply couldn't use otherwise, or would have to approximate with a library (which again costs you over and over at run-time instead of just once upfront). There are a lot of people who are treating Coffeescript as a "replacement" for JS, and like you that makes me extremely uncomfortable and dubious...however that shouldn't distract from Coffeescript's real potential. 
Keep writing these excellent tutorials please! They're great to look over, especially as backbone is sorely missing good docs. [Check out a new project i am working on which uses backbone](https://github.com/keithcirkel/avalanche/tree/develop). If I ever get the time between this and work I'd love to contribute to your docs. Is it just a case of submitting a pull request?
Which screen readers don't? http://www.brucelawson.co.uk/2011/javascript-and-screenreaders/ "1.6% of screen readers don't have JavaScript enabled" So 98.4% CAN use JavaScript.... "Percentage that use a screen reader? http://www.accessibilityisaright.org/objectives.html about 1% That's one in 500,000. 
My impression was that jQuery UI was the project for May and then next month it would be something else.
Ok, some of the modern ones can, but I'd be very suspect of their "support". This means that the individual screenreader vendors have implemented their own JS interpreter... Have you ever used a screenreader? I have. It's like using Lynx, but you have GLADoS narrating, and she reads EVERYTHING. "T&amp;A" is "t ampersand a". I wonder how they react when it's in the middle of narrating, and suddenly some JS fires off something that alters the content of the page....how would the user be informed in this situation? I also wonder what the new adopter rate is among hospitals and institutions where screen readers are found? The only 100% full-proof way to be compliant with 508 is either through a non-trivial amount of extra development required to test with JS, or you can simply employ PE -- a much simpler task -- and be done with it.
This is not the right argument against Coffeescript. Coffeescript can use any JS libraries, and is itself compiled to purebred, JSLint-happy javascript - any js-coder would be able to understand what you did when they examine the outcome.
Class I wonder why there is ':' and 'extends' in the class section. I would opt for ':' (fewer bytes). Why do we have to rewrite the name of the method for custom methods: super.attack(character); instead of super(character) like within the constructor 'new' context. Traits what about calling them Roles? (smalltalk80,perl6) it seems easier than 'Traits' with 'mixin'... class Item extends Base does Iterator or if we go the symbol way: class Item : Base &lt;Iterator&gt; or class Item is Base does Iterator Iterators for (let element : [1, 2, 3]) this seems weird... why not for(let element in [1,2,3]) ? What about type casting? 
This is how I feel everytime I read one of these comments. http://i.imgur.com/At2WI.png Thank you very much! To contribute just do a pull request, you can add snippets, fix errors or submit your own tutorial with full credit always given on the site. Hopefully I will get the time to test your your new project, are there any setup instructions?
Commting to download later. To what end, I'm not exactly sure.
The first notation is called "Module pattern". You can simulate private members, hide some implementations, and in the end you can also expose only some of them as public members. While it's a nice system for hiding members, as your code grow, you will find it very very difficult to debug. In firebug, as instance, you won't be able to see your hided members and you will not be able to locate your error. You can acheive the same complexity using convention instead of using module pattern. But look at your code, you are actually creating an object with static methods. * references: http://www.yuiblog.com/blog/2007/06/12/module-pattern/
I like the way the hits are handled. This library seems quite similar to sprite.js in a lot of way ways: https://github.com/batiste/sprite.js/
This. The abstractions and syntax changes Coffeescript introduces lets me focus on architecture and algorithms, while still working really close to the JS metal. Together with the Asynchronous Module Pattern, Coffeescript has fundamentally changed how I build JS applications.
A lot of this is of course subjective, but I would like to comment on some of your criticism, because my experience is quite different. ** "Coffeescript is a terrible way to learn to write javascript." ** Yes, I absolutely agree. ** On debugging ** Before I used Coffeescript, a lot of the things Coffeescript does I had libraries do for me. Basic things, like properly prototyped classes (which is an orgy in DRY violation if you want to do it in pure JS). Even a simple breakpoint in a modern library-heavy JS app rapidly leads down rabbitholes of poorly written code in libraries with thousands of lines of code per file. Coffeescript generates proper prototype-based classes for me, written almost exactly as they would be by a decent JS developer not using a library. Thanks to the close mapping of Coffeescript to JS and the easily-readable JS generated, I have never experienced any problems debugging it. ** On development pipelines ** This might sting, but the JS space for IDEs and similar tools is a joke. Lack of tooling has not stopped Javascript, and it will not stop Coffeescript either. As far as other build-pipeline related things go, I've yet to meet a javascript test framework or any other JS tool that was not easier to use with coffeescript. ** On prototyping code ** The ability to rapidly prototype code can indeed be empowering. Coffeescript comes with a REPL for precisely this purpose. For doing the kind of in-browser prototyping you mention, where I'm assuming you want to do things that use the browser UI, I use a BDD approach. Write a BDD test for the behaviour you want, write some code, run the test, and iterate until success. You'll find that the iteration cycle for this is faster and more structured than in-browser hacking, and leads to a code base with proper test coverage. ** On finding developers ** The main reasons for moving to Coffeescript is precisely because it is *really* hard to find good JS developers. Many JS devs come from a designer and/or a self-taught webby background. Take away their jQuery, and you'll find they lack even basic programming skills. Coffeescript can be understood by Rubyists, Pythoninstas as well as good JS devs. It broadens the field *significantly* for hiring developers with CVs longer than "HTML, CSS and JS". This becomes really important as client-side JS grows in complexity and server-side JS becomes a serious contender in the backend. 
You can find the code repository at Google Code: [jLang repos](https://code.google.com/p/jlang/source/browse/) :-).
Any comments on performance for mobile platforms? I'm going to get this running and mess around with it. Friend and I have some unique ideas a framework would help out with a ton.
&gt; I wonder why there is ':' and 'extends' in the class section. I would opt for ':' (fewer bytes). We've gone back and forth on that. I don't think we have a strong preference one way or the other, but I lean towards `extends`: 1. The keyword is already reserved for exactly that purpose. 2. Unlike C# and C++, `:` is used *heavily* in JS thanks to object literals, so I prefer not to overload it with another meaning. 3. Adding an optional type system has been on the table for JS for a long time. If that ever happens, it will likely use `:` so it's good to try to keep it available. &gt; Why do we have to rewrite the name of the method for custom methods: `super.attack(character);` Good question. I'm not exactly sure, but I believe it's so that you can call methods on the superclass other than the one you happen to be overriding. &gt; Traits. what about calling them Roles? (smalltalk80,perl6) I like that, actually. We didn't come up with traits or even put in on the table for JS. We just prototyped an implementation. The semantics of traits in JS have strayed away from the original use of the term, so I'd personally be OK with using another name. Another option is to simply not use any term for them at all and just allow any class to be used as a trait/role. &gt; class Item : Base &lt;Iterator&gt; Traits/roles really need to be specified in the body of the class. When you mix one in, you may need to rename or exclude members and you need a place to specify that: class Item { uses Iterator { excludes forEach; renames all = iteratorAll; } } &gt; this seems weird... why not for(let element in [1,2,3]) ? I would love that. The problem is that `for in` already has well-defined semantics for reflecting on an object, so repurposing it for user-defined iteration would be a breaking change. &gt; What about type casting? What about it?
it was not designed for mobiles, however you could try. Mibbu mobile will be out in beta version in couple of weeks.
I'll wait on that. Project looks exciting
&lt;input type="text" dir="RTL"&gt; should do it. More info: http://www.i18nguy.com/markup/right-to-left.html
Are you wanting to do this from a browser? You'll need to have your javascript call a server, and that server will have to read/write the file.
It's possible to do with a simple get. Unless of course I'm confusing your verbiage. When you say "write contents" I'm assuming you mean "display" contents from a file. You don't actually want to write something to the file? If so you can easily do this with jQuery: &lt;div id="fillme"&gt; &lt;/div&gt; &lt;input type="button" value="Click Me" onclick="getData()" /&gt; &lt;script type="text/javascript"&gt; function getData(){ var d = new Date(); var file = (d.getMonth()+1) + "-" + d.getDate() + ".txt"; $("#fillme").load( file ); } &lt;/script&gt; If you want your file name to have the leading zeros you'll have to put a check in there somewhere to see if it's less than 10 and prepend the '0' to it. To use jQuery you'll just have to include the script in your page somewhere, there are instructions for it many places. 
No live demo? Way to waste people's time.
Your formatCurrency function returns a string. The + sign acts as a concat in this case. I'm assuming what you really want to do is: totalField.value = formatCurrency(totalPrice*1.21);
that's totally what I want to do. Thanks a lot Sebmaster
Please, fire me an orange envelope when that happens :-)
Look for "Games created using Mibbu: OpenOdyssey, Janpu." on the first page linked - both of the 2nd links are to live games using this (I presume). Yeah - it was disappointing that the "demo" link didn't go to a live demo, but oh well. 
[JavaScript: The Good Parts](http://www.youtube.com/watch?v=hQVTIJBZook)
How'd [your post](http://i.imgur.com/SUSZs.png) end up in the [Robert Paulson thread](http://www.reddit.com/r/WTF/comments/7ntr7/who_is_this_man/c1spcnn?context=3)?! 0_o
This is my talk. Please forgive the mumbling. My heart was in this talk, but my body wasn't — it was 9am on the last day of the conference and I'm just not the dude you want in that time slot.
The PDF http://docs.examville.s3.amazonaws.com/JVXt2javascript-best-practices.pdf
[JavaScript Garden](http://bonsaiden.github.com/JavaScript-Garden/)
[jQuery Fundamentals](http://jqfundamentals.com/)
actually my comment regarding the wrong usage of the name and id attributes was dead on correct. fixed the problem. moreover, my points about iframe are completely valid unless you truly want no seo and/or linked data/sem web goodness going on in your site(s). as for unpleasant, that's quite relative, to me, my tone was extremely reserved. it's relative, like you would call the markup in that example markup or HTML, whereas i would call it bullocks. cheers
[MDN Javascript](https://developer.mozilla.org/en/JavaScript/Guide)
Good stuff. Where was this at?
[Eloquent JavaScript](http://eloquentjavascript.net/)
&gt; Some at the conference tweeted against “classes” thinking this was another turn-JS-into-Java thing, but counter-tweeting made it clear that it’s purely prototypal. What’s in a name? It is hard to beat “class”, IMHO.
Is that face "Forever backbone"? I'll definitely send some pull requests your way, when I get more familiar with backbone - I am using that Avalanche project to learn it, so far I am loving it. But Avalanche is still heavily in development (and so setup instructions are very low priority). But so far it would go something like (off the top of my head)... git clone github.com/keithcirkel/avalanche cd avalanche/javascripts/lib/jQuery &amp;&amp; make cd ../../../ # You'll need SASS and compass to build the css, so do this if you dont have them sudo gem install compass # Now compile the CSS compass compile 
So, Microsoft still hasn't figured out yet how video on the web works. Kinda embarrassing, really. 
Take a look at requestAnimationFrame(). It's a callback a browser calls, if he wants to render your site. You can change your positions and everything there. A second alternative would be CSS3 transformations since they're hardware accelerated (if you use the 3d variants with z=0).
very nice.
Right I'll have a look at that, thanks! I don't really know javascript though, I just sort of manipulated existing code. Could you possibly help me with implementing that within my existing code or is that too much of a job to ask?
The second parameter in the animate() function is the duration for the animation. Right now you have it set to "fast" but you can use a numerical value. It is milliseconds so I would try something like 1500 and change from there until you find something that suits your taste.
its whats in the divs that making the animation choppy. if you remove the contents you notice the animation is smoother
- extends yeah,sure. I like it too. it's just that in the browser the less, the better but it's not going to be that much of a problem^^ your second point is very true. then perhaps, you should merge the examples so that they both use extends? &gt; I believe it's so that you can call methods on the superclass other than the one you happen to be overriding. hum? is this a need one would have? and have often? super(character) would be the default and if such needs would happen, allow for super.methodX inside methodY would allow more dwimery? - Traits. I think, the term Role could be easier to grasp than the Trait/mixin terminology (it's not that much but for non native English speaker it might be easier?) As a matter of fact, there would be a need to explain what is a Trait or a Role. This might be of interest in such a cases even if the language succeed in abstracting away the raw terminology. Being able to rename the roles method names to avoid clashes is neat! - for in then again, using : would not it be a problem as of the point 2&amp;3 you mentioned for the class extends terminology? the harmony iterators uses for in, in the doc it seems by the way. If the object as an __iterator__ method implemented, then use it else use usual iteration logic used foreach standard objects (Array,Object-hash),is it possible? - type casting my bad. no need for the casting lol... just types (well and casting behavior it would imply though^^). is there any plan to add some types? was the question... but you already answered that in your point 3! Having some types could be very useful to enforce data integrity at the language level(let aside performance). Below in your example,the data validation would not be necessary: set health { if (value &lt; 0) throw new Error('Health must be non-negative.'); this.health_ = value; } if we could write: var health_:uint; for example. Thank you for answering! 
Everytime I try clone the repo I get the gh-pages branch and no option to switch
Just to make sure I understand what this means, `let` would allow you to declare a property within an if statement (or loop) that would only be available within that if statement (or loop) and would vanish once execution leaves that statement. Is that right? Am I understanding the concept of block scope correctly? If so, I'm not sure I like the idea of changing `function` to work that way. Sounds like it could break a lot of code.
Also I'd just like to voice my opinion that CoffeeScript is not Javascript and I am disturbed that it is now influencing javascript.
Can you post the slides? :)
Can people just learn javascript properly instead of morphing it into this bastardized shit they call coffee script?
When I loaded this on my Mac it played as an HTML5 video element. If you click on one of the download links it'll play in that format instead of trying to use Sliverlight.
totally agree with you. It sounds like eich is very cozy with jashkenas, and this is disturbing because jashkenas is trying to turn javascript into ruby/python. coffeescripters often say it is more 'beautiful' than the widely accepted C style syntax of javascript, but these are people who are comfortable with the significant whitespace or ruby/python and not so comfortable with javascripts more concise way of doing things. I think Eich sounds bored, or he is just tired of people (wrongly) putting down javascript, so he looks to coffeescript as a new way to dress up javascript and make the haters go away. he's catering to his new friends (jashkenas) and gives them too much credit. Coffeescript isn't the big sensation he or others make it out to be, but it is shouted about by some very obnoxious and vocal rubyists as the death of javascript. I hear that firefox may soon support coffeescript, but that is the result of Eich being CTO at Mozilla, and Eich being friends with jashkenas, it has nothing to do with coffeescript being popular (which it is not). If they expect other browsers to follow suit, they are dreaming. It is a good thing Eich does not have any real control over javascript anymore, I am happy there is a standards group deciding the path forward and that we arent subjected to the whims of Eich and his new friends. 
couldn't agree with you more. the uninformed might think coffeescript is somehow going to save front end coding from the evil javascript, but those people are misinformed as to the nature of the evil. DOM is the evil, not javascript. In the end, coffeescript is a layer on top of javascript that still has to deal with the problems of the DOM, while adding an extra layer of complexity on top of it. There is nothing fundamentally wrong with javascript that learning the language can't fix. but, people are ignorant, and 'syntactic sugar' sounds nice, so now we are stuck with a small but obnoxious group claiming that their way is better than ours (javascript). 
yeah, if you post the slides that would be great
TIL Andrew Dupont is savetheclocktower. +friends In the beginning of the talk you mention the presence of 'ugly code' in Prototype and Scripty2. I love Prototype and Scriptaculous and they are my go-to choice for a JS framework, but recently the two seem to have stagnated. Prototype's 1.7 update was much appreciated, but when you look at the progress being made on jQuery it seems like Prototype isn't receiving much attention any more. There was talk at one time about a Prototype 2 being a complete rewrite to get away from polluting the namespace. Has that project been abandoned? Scripty2 looked very promising, but it too seems to be receiving very little attention and still lacks many of the features from 1.8 that I love (Sortables, for example). With the recent community push to micro-frameworks, have the Protaculous teams given up on the projects, or is everybody just too busy with their day jobs?
Many of the things that I keep hearing people complain about javascript are things that I actually enjoy about the language. I **like** function level scope. I **like** C notation. I hope you're right that the coffeescripters are just a very vocal minority.
This was at MIX, Microsoft's web developer conference.
Doesn't directly answer your question but, put: body { overflow-y: scroll; } in your CSS so that when the div slides down and forces a scrollbar it doesn't seem jumpy. 
Are slideDown() and slideUp() part of jQuery by default, or is that just some extension I am remembering? If so, they may execute slightly vaster than animate does. It is only the hide animation that is laggy for me. Slowing it down a bit should make it unnoticeable. As someone said, replace fast with a millisecond value, and tweak it until it no longer lags.
1500 is way too slow. I think fast is something like 250 to 500. He should aim for something between fast, whatever it may be, and medium. Anything over 1000 is too slow to bother even animating, as it would be unpleasant for the user.
It seems as if the author completely missed the point of libraries like three.js. Instead of using to maximum benefit (taking advantage of webgl when available), he locked it in to canvas based rendering. I can't deny Microsft has done a good job of accelerating 2d rendering, but they seem completely oblivious to the fact that developers want real, standards based 3d rendering. No amount of native 2d acceleration will let IE keep up with real world 3d applications.
I have watched videos on YouTube, Blip.tv, Vid.ly, and all over the web. I've also seen many WebM videos on YouTube, Mozilla, and Opera. I clicked on the play button thingy with Firefox (on Windows) and also with Chromium on Linux. In both cases nothing happened. Yes, I can download the video, but that's something I would have done 15 years ago, not today. It's their fault that everyone has to provide their videos as WebM/VP8/Vorbis and MP4/H264/AAC. But they chose MP4 and WMV. Very funny, really.
&gt; With the recent community push to micro-frameworks, have the Protaculous teams given up on the projects, or is everybody just too busy with their day jobs? Mostly the latter. We're starved for development resources right now. I am the most active, but I try to rotate between Prototype, scripty2, and other things every few weeks. Prototype 1.7.0.1 is nearly out the door (take a look at the "dom-rewrite" branch on GitHub). I'm also planning to add some polish to the scripty2 UI stuff to get it up to a beta release. Drag and drop were added in a while back, but haven't been given much love since, and I want to address that as well (hopefully adding in sortables as well). &gt; There was talk at one time about a Prototype 2 being a complete rewrite to get away from polluting the namespace. Has that project been abandoned? It hasn't been abandoned, but it was always a far-future kind of thing, and it's never gotten past the idea phase. I know there's still stuff I want to do on the 1.X branch before I start to think about what Prototype 2 will look like.
They may be a vocal minority but they are influential. These are the guys that go to conferences and buy each others books. It's an echo chamber that they think is representative of all JavaScript programmers.
[Here you are](http://www.slideshare.net/savetheclocktower/writing-maintainable-javascript).
I like those things too. Coding javascript for so many years has made me a more disciplined coder. I never have problems with dynamic types, because I know how to deal with them. I've learned, it's really quite simple when you learn it. The more I learn javascript, the more I like it for it's simplicity, and yes, elegance. I've done quite a bit of coding in ECMA4 in .NET and Actionscript 3, and that was the right way forward for JavaScript, as far as I'm concerned. The fact that Brendan Eich is focusing on removing parentheses from for next statements and other things, means that he's lost the plot. There are so many things that could be added to javascript, but taking away something like parentheses is not a great idea. I really don't want to end up with some bastardized half-javascript-half-ruby mutant language, which seems to be the way Eich wants it to go now. The syntax doesn't need to be fundamentally changed. Adding more useful, and less invasive changes to the language would be better for everyone than turning javascript into a significant whitespace language. Programming becomes easy when you know how to read the code. Turning javascript into Ruby isn't going to make it easier for most javascript programmers to read code. Quite the opposite. I'm tuned to javascript, and to a few other languages (some varieties of asm, c#, java, html, css, etc), and I can work with other languages I like less if I have to, but I'd really rather not have to. I'm pretty sure that is how it works for almost everyone in this field. I can see why ruby/python coders want to code ruby/python in the browser instead of javascript. good for them that they have coffeescript, but to change javascript fundamentally for this small group of people seems strange. why not PHP, perl, why not haskell, scala, etc. Those groups have been around far longer than and are much larger than the coffeescripters. There are even cross-compilers (transpilers?? wtf?) for some of those languages into javascript, including Ruby. So why all this attention about turning javascript into a significant whitespace language? It seems it comes down to who knows who in this field sometimes, and who they are trying to impress, and not what's good for the javascript community. 
I found jQuery in your source code, so I assume you use it for the animations. If you do, upgrade to jQuery 1.6. requestAnimationFrame got added in this version. Edit: Since you're pulling jQuery from google code, you already got this one. To use 3d transforms: There's a library which tries to figure out, if the client supports these and if it does, it uses them, no code need to be changed. You can find it here: http://playground.benbarnett.net/jquery-animate-enhanced/ . On a side note: I don't notice any lags at all with FF 4, IE 9 and Chrome 11.
I have to agree with you. I think another problem with it is that JavaScript is evolving in the shadows, there are very few things that don't use JavaScript 1.5 and to a lesser extent ES4. It will be cool if modern browsers actually all adopt a new version of javascript across all browsers and platforms, but it's been so many revisions of javascript since they agreed upon what to implement for their javascript engines. This, and *nothing matters until IE6 is gone **for good** *, are some other reasons why javascript may seem to be going off-course, all the way to significant whitespace, before it's evolved to even ES4 inside the browser (not counting Actionscript). 
I tried adding that but it stopped the hide button working, fiddled around with the code but no cigar. Thanks anyway.
thanks dude, you rock!
Thanks for the reply. Let me just say I personally have a huge appreciation for the work that you, Thomas Fuchs, and everyone else involved have put into both projects. It's made my life easier for over a decade.
I have used screenreaders, heavily a couple years ago, for months at a time. Was developing and testing software used by many banks (ex: anybody but Wells Fargo) in my role as their Principal UI engineer. There are a couple decent comments in this post as to how the blind use JavaScript: http://stackoverflow.com/questions/1984493/how-does-javascript-use-effect-508-compliance I would like to avoid developing code twice, that is all. (getting off my soapbox now) 
If you have the div open up above the content instead of pushing everything down there would be less for the browser to animate.
Sorry to be a pain, how would I do that? Thanks.
Well, to go into a bit more detail: because the hidden DIV is statically positioned, when it gets bigger it affects the layout of the content below it, so all element positions must be recalculated with every frame of the animation. If you make the DIV in question `position: absolute` or `position: fixed`, it'll be taken out of the ordinary document flow, meaning that changes to its dimensions won't affect any other elements. And thus it should animate faster. The downside to this is that it's going to look different — the element will appear "atop" the rest of the content, rather than pushing it down.
That's exceedingly kind of you. You're welcome.
Ah cool, thanks! Does this mean that the button stays visible when you scroll down?
For `position: fixed`, yes. For `position: absolute`, no.
Not programming advice, but the opening sentence should be "Your belongings feeling a bit....plain?" The comma is not used to indicate a pause, the ellipsis is.
&gt; He says that at almost every place he's worked, people are pigeon-holed into specific roles: front-end developer, backed-end devloper, etc. I think there's a reason for this division. Sure you can make Javascript the lingua franca for both front-end and backend developers but the things that either developer has to be obsessed with are completely different. A frontend dev would probably have a hard time designing a massively concurrent highly scalable backend service, it's just something that they're not used to thinking about and probably don't want to think about.
Functions already have their own scope; that wouldn't change. `let` would allow you to have an arbitrary block scope wherever you like. Existing code doesn't use `let` and wouldn't be affected at all.
Guys, this is a disheartening thread of discussion. It's filled with speculation about others' motives and actions rather than any sort of verifiable evidence. Now that we're post-ES5, this is our first opportunity in years to add syntax to JavaScript. Obviously, people are asking for things that would address pain points we've had to deal with for years. CoffeeScript is a good data point because it's trying to solve some of those same problems, but it's not the only data point. And there's an entire committee to get through before anything becomes part of the language. One of Brendan's annoying habits is to present strawman proposals and give the impression that they've already been decided. But a constructive response to that isn't to grouse about it on reddit; it's to follow [es-discuss](https://mail.mozilla.org/listinfo/es-discuss) and weigh in with arguments for and against.
Nobody is proposing that JavaScript have significant whitespace.
Can you describe what "pain points" you are experiencing?
 &gt; This, and nothing matters until IE6 is gone for good Or Ie7 or Ie8. Basically all of this sweet JS shit is useless until the majority of internet users abandon these browsers.
 git checkout develop I use git flow to manage the development branching model. Sorry should have pointed that out.
something on the lines of http://jsbin.com/owesi5/2 ?
&gt; I’ve been talking about better function syntax for a while. function is too long (I wish I’d used fn in 1995 and preempted this issue). WTF!?! Brendan must be suffering from Early Onset Alzheimer's Syndrome. This crap makes sense if writing in binary or assembly where instruction sets must fit into known dedicated memory spaces. Surely Brendan of all people understands where in the application stack JavaScript rests or perhaps he simply has no concept of semantics or structured learning.
&gt; Facebook prioritizes performance, as illustrated by HipHop. Even 1% improvement matters. php is pretty slow to start with and hiphop speeds it up a bit. v8 is blazingly fast, and i bet it's faster than hiphop anyway. the frontend/backend sharing? i'm in agreement with [ericmoritz](http://www.reddit.com/r/javascript/comments/h69iz/nodejs_at_facebook_why_its_needed_and_whats/c1sxglk) there.
No continuations or coroutines. I wish they would focus on that instead of this syntax stuff, though block scope and destructuring bind are nice.
&gt; Coding in regular JS is going to be like not using a framework. I sure as hell hope not, I hate CoffeeScript.
Actually [this](http://javascriptweblog.wordpress.com/2010/08/30/understanding-javascripts-this/) is why JavaScript is the world's most misunderstood programming language.
I don't know. The first search result is only marginally better, even if it is a lot more relevant.
I don't like it, but my real concern with that kind of talk is that JS will end up being hopelessly fractured, and for no real reason.
Well, front end developers have to worry about presentation, structure of content, flow, and not locking the browser with some retarded loop that take .5s to run. Back end developers have to worry about data, server response time, and SQL. Both need to worry about not making their code look like spaghetti. When you start to blur the lines between the two, you end up having people playing with the front end code that don't even understand proper html semantics, when they should just be handling the low level handlers for the db. While I like on language to write them all, wanting that for the sole purpose of blurring the lines between front end and back end developers is going to 
oh, you again. nice story. why dont you go rtfa and then tell me again that jashkenas doesnt have an influence on the cto of mozilla, creator of javascript, who is now considering changes to javascript to make it more like ruby and less like javascript. fucking troll.
are you fucking dense? oh, i think i've asked that question to you before. yes, you are. rtfa. I am not the only one coming to these conclusions here. fucking troll.
My point is that there's very little chance of having your grievances _addressed_ on reddit. Whereas posting them to the list makes it possible to change some of the things you don't like.
There seems to be a rule in programming languages that the longer they evolve, particularly with input from multiple parties, the more they lose their original beauty and simplicity becoming a tangled mess. See Scheme, Python, C++ ... I'm sure there's a lesson here in how to do it properly .. or maybe it's just how not to do it.
"you just make insulting personal attacks and wishy-washy complaints...there's no real meat." take a look in the mirror, dipshit.
es-discuss can be a little intimidating. Personally, I'd be happier having a discussion on reddit before heading off there to say something. :) BTW, I'm not against the suggested syntactic changes. And I don't use CoffeeScript but it does seem kinda neat.
What about in-language support for syntactic abstraction, like Javascript's cousin Scheme? JS has a quite simple AST; if this could be exposed via a module, then things like Coffeescript's sugar could become modules distributed for developers to experiment with and improve upon, without forcing the design of a surface language and compilation upon people who aren't necessarily skilled or interested in such, and thus likely to make crippling mistakes.
I saw the original code that this came from on John Resig's twitter account: javascript:alert(eval(prompt())) I love that there are programs that can fit in a tweet.
"Coding in regular JS is going to be like not using a framework." :( I don't hate CoffeeScript, but I am filled with sadness imagining a future full of API's I'll have to use, written with the premise that the class is the only allowable programming abstraction.
&gt;&gt;with javascripts more concise way of doing things &gt;This is just wrong. &gt;"Beauty" is a subjective term, and I'm willing to accept it varies from person to person. That's fine. &gt; Your beauty is not my beauty. If you're intellectually honest, you'll accept that too. By "concise" I mean javascript breaks down blocks of code using parens, curly brackets, brackets, periods, etc, where coffeescript eliminates them, and if you've ever read through source code for 'significant whitespace' languages, they tend to look like run-on sentences of blocks of text, without delimiters to make it easily apparent where to focus your eye to see specific pieces of the statements. I and others have developed an affinity towards this design pattern. To someone attuned to programming javascript, significant whitespace is a loss of the concise phrasing of javascript's syntax. Clear delimitation is a discipline, and significant whitespace languages may work better on some types of minds, but I very much like the way javascript is these days, and so do a lot of other people. fundamentally changing that is not something I like to hear the creator of javascript discussing. It bothers me and many others. I'm sorry if you don't understand any of this, but I wouldn't expect a dimwit such as yourself to understand the basic principles of programming syntax. I chatted with Jeremey Ashkenas and one of the few things we agreed upon was "beauty is in the eye of the beholder". I brought this up in response to all the coffeescript articles that proclaim it's a better way to code javascript, etc. If I recall correctly, his response when I said that was "now that is something I can get behind". Unfortunately though, what some people think is beautiful is now seeming to affect the course of javascript, and that's something I'm not ok with. I spend most of my life coding, so it effects me, and fuck you for unleashing a tirade of verbal diarrhea against me for voicing my opinion about the content of the article. Who the fuck do you think you are that I have to prove anything to you.
Doesn't work at in Opera. I click it but nothing happens.
Thanks for those spot-on comments. \#3 jumped out at me too. Nobody ever said you have to format your JavaScript code like this: closestEdge = x &gt; width / 2 ? 'right' : x &lt; width / 2 ? 'left' : 'center'; But I wouldn't add parentheses. Instead, I'd take the CoffeeScript formatting: closestEdge = if x &gt; width / 2 'right' else if x &lt; width / 2 'left' else 'center' and translate it directly to JavaScript: closestEdge = x &gt; width / 2 ? 'right' : x &lt; width / 2 ? 'left' : 'center'; Or for simple expressions like this one, perhaps a more terse format: closestEdge = x &gt; width / 2 ? 'right' : x &lt; width / 2 ? 'left' : 'center'; Either way removes any confusion about which part of the expression goes with what. BTW, years ago I got to program in a language called [BLISS](http://en.wikipedia.org/wiki/BLISS) where there were no statements, only expressions - everything returned a value. It sure made things convenient; I was sad to go back to languages where statements aren't expressions.
I don't like coffeescript either, in fact, I hate it as well. Why do we need a scripting language that just gets converted to another scripting language? If people would spend as much time as they do learning CoffeeScript, they might actually learn some JavaScript.
This is the javascript reddit, not java. There's no relationship between the two languages and you won't get any Java help here.
Could try asking on [Stack Overflow](http://stackoverflow.com/questions/tagged/java).
&gt; I've slept with over [1..100] * was quite fun
&gt; "Takeaway of #jsconf: JS compilers/transpilers are the future. Coding in regular JS is going to be like not using a framework." I was at JSConf and I'm calling bullshit on this. I can think of two transpilers, CoffeeScript and Traceur; one of them is gaining in popularity and the other was _just announced_. So let's put away the anointing oil. Conferences are _too much_ about zeitgeist and, as a result, are poor predictors of the future. They reflect the slope of the line at that point in time, not where the line is going to end up. This is why it's a good idea to take off the Pundit Hat and shelve your predictions of what "the future" will look like. Just wait a little while and you'll be _in_ the future, at which point you'll know for sure.
Nice one, added.
Ah this is really great stuff. I haven't found anything to interesting in particular, but I will be studying the source code. Awesome stuff
&gt;google says: Quota Exceeded. Please see http://code.google.com/apis/websearch Sorry pal.
Yes, unfortunately google limits the query rate. I set it at 700ms, with 100ms it was going light-speed.
The this keyword is the execution context. There are several different ways to execute a function, so there are several different types of execution contexts.
I've always wondered if it would be possible some day to program with only a pen tablet
in all fairness, there actually is a relationship.. they both use the word "java" in their name. But yeah, that's about the extent of it :)
Ha ha ha ha :D You sir are an epic troll.
*{citation needed}*
Actually, concern over keyword length makes complete sense in an environment where every byte has to be sent over the network (and really not much sense at all in ASM – it's not like they stick the keywords into the registers). Not to mention it's the longest way to possibly convey the idea: Ruby: def (or proc for lambdas) Python: def Scala: def Perl: sub You get the point. "function" is almost three times as long as the keywords conveying the same idea in these other languages, and keywords can't get minified. 
Thank you for being the voice of sanity in this thread.
&gt; Actually, concern over keyword length makes complete sense in an environment where every byte has to be sent over the network Not really, at least not anymore. Execution speed is of far more important consideration. Additionally, if we really want to talk about limitations due to network transfers then stop whining about the function keyword being 8 characters and instead focus your attention on somewhere else more deserving, like XHR and http headers. Shortening code length by 6 characters at each instance of that keyword would take approximately 150 instances compared to savings of eliminating a single http request even if no payload is returned and the response is not lagged. Honestly, I don't care if a similar keyword is shorter in a different language. *.....What's the price of tea in China?*
Perhaps find some proxies to work with.
I actually love python but time spent on stylistic changes to the language seems time wasted. I would not mind except that is more to understand for me and tools I use and less time spent on real problems, both which affect me everyday. I think a smaller language is better for these reasons. I do not get more power with yet another way to make a function, I can already do that at the same level of abstraction. The parenless style is even worse. Power is list comprehensions. I see that is coming in eventually why are we wasting time on these other things that will just slow adoption and cause drama? I am not that excited about that.
&gt; ...stop whining about the function keyword being 8 characters and instead focus your attention on somewhere else more deserving, like XHR and http headers. XHR and number of HTTP requests can be optimized. Keywords cannot. &gt; Execution speed is of far more important consideration. Agreed, but we are talking about keyword length, which has no impact on execution speed. (To be precise, a shorter function keyword would increase, albeit imperceptibly, execution speed because the interpreter wouldn't be required to read as much). To use your own phrase, "What's the price of tea in China?" What I was really replying to, and why I brought in examples from other languages, was your implication that reducing "function" to "fn" would be a semantic mismatch, and that the longer word would be better for "structured learning". I was using counter-examples to point out that there are languages that use short keywords for the same semantic meaning as "function". If Eich, as he wanted, used "fn" instead of "function" in 1995, this conversation wouldn't be happening because we'd have been used to it. If JS.next implements "fn", it would be an alternate to "function" – they are not going to remove the keyword, they are going to allow an alternate keyword. I really don't see the controversy here, you can continue to use "function" and I get to type six less characters. You can argue that they have better things to spend time on, but I'd say that A) language syntax is important and B) this is not a huge, hard-to-implement change.
I keep hearing this complaint in the echo chamber of /r/javascript. If you don't understand JavaScript, you're probably not going to understand CoffeeScript. CoffeeScript doesn't add anything that JavaScript doesn't already have -- it just removes some of the syntactic mess and makes it easier to type and read. If you don't like it, fine. But insinuating that that those who do like it don't know real JavaScript shows that you don't really understand the point of the language. I'm pretty sure Brendan Eich (who pretty unabashedly likes CoffeeScript) understands a little JavaScript.
This looks very useful. I wonder what else is out there that does this. Not because I feel like this is lacking anything. I'm just curious what other attempts to do this look like. Does anyone know other similar projects?
Here's a question.. if this code ("str"==true) resolves to false, why does if("str") resolve to true? What kind of check is the IF doing here?
You keep bringing up your concerns about coffeescript (significant whitespace, for instance) and applying them to the article that says that Brendan Eich is looking at adopting some of the function syntax for Ecma.next. If you take time and look at what's proposed, he _won't_ be suggesting that the significant whitespace make it into javascript, and instead opting for curly braces. You also don't seem to recognize that the only thing that has happened at this point is that he has said "I will be discussing the possibility of this at the next TC39 meeting" - which means that he still has to convince a roomful of other very bright people that this proposal is best. Currently there is a competing Octothorp syntax for functions that was proposed/championed by Alex Russell, and I know he currently has some misgivings about the fat arrow portion of the coffee-script style arrow function syntax (not to put words in his mouth, but it's what I took away from a brief conversation with him). The entire point of nearly _everything_ that is going into ecma.next/harmony is _good_ for JavaScript. They are by _no means_ turning JavaScript into CoffeeScript. It's simply not even close. Nearly every specification is either adding something that was impossible and desperately desired by developers (binary apis/large numbers/weak maps, for instance) or it's some way of taking away boilerplate code that we're used to writing. ( `[].slice.apply(arguments)` for instance - while you may feel super smart for knowing it, and it may make you feel superior to everyone else and hold some emotional attachment to the thing that _you_ had to learn, is ridiculous. The new splat operator is great for this. Same thing for destructuring and multiple variable syntax of ol' ) I'd go so far as to say that perhaps you'd have every right to complain if JavaScript was taking the path of CoffeeScript as a JS.next. The simple fact is that Brendan liked a single feature in CoffeeScript and he modified to not require significant whitespace. It has some great benefits for code readability and typability, actually. The `fn` keyword as mentioned in a previous comment could not occur because of it's frequent use as a variable name in current code. Currently `#` is winning as a function shorthand, but no one said coffeescript in the same sentence as that, so none of the coffeescript-birthers cried foul. There's way too much emotion and entitlement in these arguments to be about the ideal function syntax for a future and opt-in version of a programming language.
It never leaves 0% for me. Tried using the link in your post ("will become extinct by"). Simply doesn't do anything.
if("str") is checking that "str" is not null, undefined, NaN or 0. This is basically checking if something exists (unless it's 0 or NaN). Whereas: if("str"==true) attempts to parse "str" as a number, then checks it against true (true == 1 is true, but true===1 is false). "str" parses to NaN and NaN != true. 
~~If everything is parsed as a number, why does "a" (when converted to number is NaN, I assume) == "a"?~~ Meh, bad example because of the same type, but still, this article suggets that. In my opinion, the [MDC](https://developer.mozilla.org/en/JavaScript/Reference/Operators/Comparison_Operators) decribes the operator way better.
Thanks, I figured it was some kind of exists check.
&gt; It’s common mistake that many js developers don’t assign null value to variables of reference types (object or Array) when there use is finished. Oh, _come on_. If they're no longer being used, then there are no references to them, and they'll be GC'd anyway. You'd only need to null out the variables if they're referenced inside closures _and_ the closure doesn't need to use them _and_ you're **really** anal about memory usage. Even leaky engines like IE6's will reclaim that tiny amount of memory once you navigate to a new page.
Agreed, this isn't the best article, I even noticed a few typos in the code. My description wasn't that good either, I've gotta stop commenting while in the middle of other things.
All the implementations of Javascript I'm familiar with, will sometimes choose to close over a whole scope, and not just the variables in it that it references. This is a big savings in cases where the "module pattern" makes a big scope full of closures that point to things in it. Each closure can either keep dozens of pointers so that unused things can be collected, or they can each have one pointer for the whole scope and risk some waste. So yeah, it makes code ugly, and you probably never need to do it, but you can benefit from clearing references.
it's funny how these things are mostly more complicated than just writing code
VIDEO/AUDIO ADS ON YOUR SITE? *closed that tab faster than the flash makes babies*
It seems so insane that two people with the same goals would happen upon similar results (not exactly the same)? TC39 has a proposal for shorter function syntax that is currently being debated. If you listened to _anything_ brendan has said, you'll know that he says "Coffeescript has shown that the arrow syntax can work" - and then he goes on to encourage people to come up with their own implementations. The fact of the matter is that developers _want_ shorter function syntax. Unless you can think of a better one, I don't think you can complain about people considering (part of) Coffeescript's implementation. To your opponent's credit, you actually do sound crazily emotionally attached and paranoid about a two character change to a language that was influenced by a language that is almost entirely the same as JavaScript with a more terse syntax.
It seems so insane that two people with the same goals would happen upon similar results (not exactly the same)? TC39 has a proposal for shorter function syntax that is currently being debated. If you listened to _anything_ brendan has said, you'll know that he says "Coffeescript has shown that the arrow syntax can work" - and then he goes on to encourage people to come up with their own implementations. The fact of the matter is that developers _want_ shorter function syntax. Unless you can think of a better one, I don't think you can complain about people considering (part of) Coffeescript's implementation. To your opponent's credit, you actually do sound crazily emotionally attached and paranoid about a two character change to a language that was influenced by a language that is almost entirely the same as JavaScript with a more terse syntax.
I cannot upvote enough. I have no idea where anyone got that idea.
Hey! I actually am the maintainer of Faker.js, awesome to see it linked here. There are other similar libraries available for Ruby and Perl, both called "Faker". I provide links for these in the ReadME file. 
what is the point of this?
&gt; Agreed, but we are talking about keyword length, which has no impact on execution speed. Exactly! Conversation over.
Interesting mix of camel-casing and underscoring, any reason either one or the other couldn't be used? &gt;Faker.definitions.**first\_name** &gt;Faker.Name.**firstName**
I can see it being used for unit testing.
JavaScript is to Java as Carton is to Car
Wouldn't *delete* be more appropriate?
I really like programming in JS minus the rough edges, most of which are easily avoided. I really hope the trend goes more to cross compatible micro-frameworks which focus on a small aspect of the language and make it better without making it alien.
Hmm.. this is an outright port of the ruby and perl Fakers. I'd like to see more credit given to the original authors than a sentence in the footnotes.
Ah damn, I was at the brunch too! Next time maybe. I'll take a look at your video when it's posted :)
It took me about three seconds to work out that definitions and random-data-generators are two different types of things and the spelling style as well as the namespacing distinguishes them. did you even try?
I wasn't suggesting that clearing references has no value whatsoever, only that it has a negligible value, and that it's probably not worth it considering the developer overhead of keeping track of what the closure needs and what it doesn't. 
They're focusing on both. Committees can work on more than one thing at a time. Generators enable coroutines and will most certainly be part of some future version of ECMAScript.
It's good for mocking up data for testing. If you need to generate like 10,000 unique user objects for your application its pretty much impossible to get good custom test data unless you build it yourself. With Faker, you can extend on the built in API methods or card creation methods to generate your test data.
Significant whitespace destroys readability. Your claims that coffeescript improves readability are false. The overall difference between javascript and coffeescript isn't great enough to even start writing the code in coffeescript to begin with unless you just prefer ruby/python syntax (and if you do there are better resources than coffeescript). If coffeescript were significantly different than javascript it would be easy to say, go ahead and write all the coffeescript you want and never care. But to start front-end projects off in this bastardized language, for no good reason other than less typing of ( ) { }, is asinine. It removes the ability to share source code with non-coffeescript projects. It removes the ability to use tools developed for coding javascript. It gives you a whole new set of problems to solve that have nothing to do with javascript or the DOM. If you want to cut yourself off from the javascript ecosystem, fine, but this is not a good thing for javascript programmers. It is a fucking tower of babel, and people who don't think so haven't spent enough time programming computers to know that this is not a good way to move 'forward' by forking an entire language, and that is exactly what we are talking about here. &gt;The fact of the matter is that developers want shorter function syntax. No, lazy, brain-dead programmers think they want shorter function syntax, as if they think that is the solution to what they don't like about programming. As if it is so labor intensive to type ( ) { } which only adds structure to the code, and more structure is a good thing. Without it, coffeescript just looks like a run-on sentence, harder to read, less structured. How this is a good thing I'll never know, but apparently some people have convinced themselves that less structure and less typing is a good thing. The fact that you and others are ignoring is that Brendan Eich **IS** talking about making javascript more like coffeescript, and my position is that it is a good thing that he is not the only one making these decisions, that there is a 'roomfull of people' that he has to convince. The haters gonna hate what I say no matter what I say, but the reality is that there are articles written about Eich's new direction with javascript, and his association with coffeescripters, and this is troubling to people interested in javascript maintaining it's position in the browser world. To introduce significant whitespace into javascript (even if it is optional) will dither the usefulness of the language when you have to deal with not one but two dialects of the same language. Having more than one dialect of a language has never proven to be a good thing for a programming language (or the usefulness of any language). It means that less source will be compatible with existing and legacy browsers which aren't going away as fast as people would like them to. Converting coffeescript source back into javascript is a chore (and I don't mean compiling it). It sucks if people choose to cut themselves off from the javascript ecosystem for the sake of 'less typing', it's just a bad decision. The fact that the people posting here can't see the benefit of more people coding javascript (and not in coffeescript) means that they aren't interested in a strong javascript ecosystem. Yes, I am a javascript fanyboy, which is why I am reading and posting in r/javascript. Fuck off for suggesting it's a bad thing to be passionate about this topic, and for suggesting that i'm "crazy" or any other such nonsense. 
Your "syntactic mess" is others structure and delimitation. If you don't like it, fine. But insinuating that those who do like structure and delimitation don't know how much better coffeescript is shows that you don't really understand the point of having structure and delimitation. I'm pretty sure Brendan Eich has lost his way with Javascript. 
here is a similar lib: http://clubajax.org/mock-data-randomizer/ very nice but has less features compared to Faker.js
finish learning js before using jQuery or ExtJs. Stay away from making a bunch of global variables. Get a good consistant naming system for your variables. I like to draw out an abstract of my app/obj before hitting textmate. backbone &amp; spine are good for giving structure as long as you understand how JS works. when getting into jQuery, understand CSS selection first so you don't make selections that are expensive to the browser. don't make god objects. I like to separate my js during development into separate js files for the views, models, and controllers. I also like this pattern: var objectName = function(){ var privateVar = 'hi'; return { privateVarValue: function(newValue){ if(newValue){ privateVar = newValue; } return privateVar; } } } // objectName.privateVar = undefined // objectName.privateVarValue() = 'hi' // objectName.privateVarValue('bye) = 'bye'
Thanks for the tips, but I think I will go with JavaScript objects because I just found [a tutorial](http://net.tutsplus.com/tutorials/javascript-ajax/the-basics-of-object-oriented-javascript/) that finally properly explains objects so now I can do some basic OOP.
&gt; finish learning js before using jQuery or ExtJs I can't emphasize that enough. There is no other language like JavaScript. Kick back and watch [this video](http://www.livestream.com/etsy/video?clipId=pla_1463e546-47ed-4a93-b59a-bd52b236e8b8&amp;utm_source=lslibrary&amp;utm_medium=ui-thumb), read JavaScript: The Good Parts, Eloquent JavaScript, etc. Trying to force JavaScript to act like your current favorite language is a bad recipe.
Now all you need to do, is to combine all of those into 1 unified API, which would leverage shared code between the modules to greater enhance the efficiency and to avoid having to add a new dependency each time that you want to add a new feature!
I know that tutorial well, just keep in mind the scope of 'this' is easy to get lost. The other pattern is just a little simpler to keep track of for newer coders, and ends up being pretty efficient in the long run. But find a coding style that feels right for you.
great books. get familiar with douglas crockford and make him your new god.
I do like JavaScript. Very much, in fact. In general, I like Javascript's syntax, even though I find some parts a bit overwrought. But I also like CoffeeScript. Imagine that! I'm actually on neither side of this religious war. My point was that this religious war itself is stupid. It's just another language. Learn it or don't. But don't disparage people for their preferences. There are plenty of valid arguments against Coffescript that don't require you to imply that CS-advocates don't understand JS. Attack the ideas, not the people.
Bah. Writing "javascript" in lowercase? Assigning to `window.onload`? Not using the term DocumentFragment correctly? Using innerHTML to write a small number of nodes?
Nice. They both contain things...
Thanks, I will check it out. I'm new and I was sort of aware that java and javascript would be different, but I just thought I'd ask here for some direction.. 
Generators are not coroutines. They have n^2 time complexity for yielding from n nested calls. There are other differences. http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators One-shot coroutines (as in lua) give most of the benefits of call/cc, though they are still not call/cc. I find it strange that a language based on scheme would leave out one of its most pleasing features.
See /r/shittingadvice.
Must have removed them, I don't see them.
That comment belongs in [/r/shittyadvice](http://www.reddit.com/r/shittyadvice)!
Or perhaps r/shittyshittingadvice?
I never said that 'CS advocates don't understand JS'. If you didn't notice, I was mocking your earlier reply. I recognize that it would be difficult to pick up coffeescript without first knowing javascript. Which makes it all the stranger to spend time learning javascript so you can then learn coffeescript. While coffeescript doesn't throw the baby out with the bathwater, it does throw away the sink (the clear delineation/ structure of javascript). What does it replace it with? Significant whitespace and arrows. That's awesome? That's what javascript is missing? Oh, it adds splats, something can be done in a simple library. Your statement that the syntax of javascript is somehow 'a mess', tells how little you actually like the language even though you say you like it very much. I honestly don't see how you (or anyone) could think coffeescript is any 'easier to read'. Anyway, about this article, and all the talk recently about the possibility that javascript could support a more coffeescript-like syntax; it's not a good thing to fork a language, and it should be obvious that it wouldn't be a good thing for any language, and that is what coffeescript and 'js.next' represent as it's being discussed by some of the people who have some kind of say about the direction javascript might take. That's just my opinion, which counts for practically nothing. 
Meta.
Should this really be there and not in /r/wtf or /r/funny ?
Sure, but why are they different? I've never come across that in a project before, usually a project uses one or the other. I wasn't questioning how to differentiate the parts of the project, rather for what reason two different coding styles are used in the same project. Come to think of it It's very rare to come across underscoring in a JavaScript project.
It's not super similar, but my [mockJSON jQuery plugin](https://github.com/mennovanslooten/mockJSON) can generate randomized JSON data (and intercept jQuery JSON requests) based on templates.
I've been using [Sammy](http://sammyjs.org/) this week for something similar. Great little system with a nice plugin-architecture for rendering of templates etc.
I accept pull requests. 
and I'd like 10 million dollars... Are you an author or contributor to any the projects in this discussion? Which open-source projects do you maintain? What I'm really trying to say is that here is some free software, if you don't want it, fuck off. :-)
Just like most of what is in *funny*...
Check out the revealing module pattern - http://www.wait-till-i.com/2007/08/22/again-with-the-module-pattern-reveal-something-to-the-world/ It's my default pattern for writing new chunks of JS. It's great because it separates your internal config and state variables etc from the outward-facing parts of the code. It also ensures that other scripts can't interfere with your script.
Yep, it is called specialisation. It is a good thing because it makes things more efficient. If you need more backend developers, hire backend developers. If find that your hirees aren't going to be good enough, what makes you think a front-end developer will be able to do the job? The misapprehension here is that the language is a barrier. However, you can fully learn js in a few days. The body of knowledge that you'll really work to obtain is the ins and outs of browser development and the ability to construct high-load backend services. Having a single language doesn't really help with either of these.
Where does this idea come from that v8 is fast? It gets trounced by most other languages and is only middling when it comes to dynamic languages- Lisp, Racket, and LuaJIT are all just as fast or faster. http://shootout.alioth.debian.org/u64/which-programming-languages-are-fastest.php
* Use arrays and limit use of object literals. Object literals are significantly slower to access multiple indexes in any single request. * Multidimensional arrays can sometimes become complicated to manage. When this is the case limit nesting and instead try using parallel arrays. * When loops become complicated or their conditions extremely diverse it may be safer to encapsulate such loops in a function so that the loop can retain its own function scope. * Limit the number of function references as each one takes a minor performance hit due to name look ups. This is important to keep in mind within loops. * If you believe you need a JavaScript framework to make yourself organized or supply necessary structure guidance then code will likely never be organized. * Document your structure like a blue print. 
Crockford is a great resource but also realize that he is still just an opinion to be evaluated based on what a given project needs. A lot of his suggestions are valid and backed up by technical reasoning but others are just his suggested programming style. JavaScript: The Good Parts was the most influential resource I have found to learn JS. As a friend of mine told me about it "... it is a very dense book." It packs a lot of information into a short period of time. I have gone back to it over and over again to review the examples contained within.
I think you misunderstand me, because you answered your own question: &gt; *why are they different?* .. *to differentiate the parts of the project*
Yes. Differences of language and syntax are less important than differences between problem domains.
Looks pretty neat, but I prefer [PathJS](https://github.com/mtrpcic/pathjs). Extremely simple, stupid fast, and easy to use. I also think that Crossroads.js is lacking in examples/documentation.
The haters will hate, but coffeescript is worth learning to help structure your code, otherwise prototypical inheritance. Backbone is absolutely worth using, but if your app doesn't map well to the backbone problem domain - find a nice bind / unbind / trigger mixin that you can apply to your models.
One suggestion that might be useful for this project is to include a [fuzzer](http://en.wikipedia.org/wiki/Fuzz_testing)
good question. i think the idea comes from the speed improvement most javascript runtimes experienced over the last few years (AOT, tracing, ...). still, it's pretty fast [in comparison to php](http://shootout.alioth.debian.org/u32/benchmark.php?test=all&amp;lang=v8&amp;lang2=php)
I actually meant him, personally. He's got a great mix of snark and wisdom.
Crossroads also requires another library to function. :\
That is what I was originally doing, but I decided I want to learn JS the way real men do.
http://www.addyosmani.com/resources/essentialjsdesignpatterns/book/ elevated me from n00b to meh
Been coding JS for a couple of years now. Cannot upvote this object pattern enough. Works wonders for making simple maintainable code.
One of the founders here. The service is put together on Amazon infrastructure (S3, CloudFront and Route53). We've serving over 1,000,000 scripts a month now http://ajax-cdnjs-com.s3.amazonaws.com/cfstats/ Github is here: https://github.com/cdnjs/cdnjs if you want to add your favorite script. As a side note, we're getting quite a bit of interest on Twitter right now: http://twitter.com/#!/search/cdnjs **Edit:** Load times are snappy and uptime is rock solid http://stats.pingdom.com/4jg86a2wqei0/291776
Thanks, I will give it a read when I get home.
Out of curiosity, what's your uptime like?
Uptime link is in comment above. Here it is again. http://stats.pingdom.com/4jg86a2wqei0/291776 Pingdom is a current sponsor of cdnjs!
I fully unofficially endorse backbone.js. It is very intuitive and makes javascript development fun. I write basic tutorials on http://backbonetutorials.com and also have some beginner tutorials on http://thomasdavis.github.com. 
Awesome project. The code is simple. I can see how I could replace the lists if I had a need to do so. I wouldn't use something like this very often, but when you need something like this, it's about perfect. Thanks.
more details from [webkit.org](http://www.webkit.org/blog/1620/webkit-remote-debugging/).
If I've understood you correctly, you could just do onkeyup="displayTotal(); function2();". But, please, don't do it. Learn how to use [event listeners](https://developer.mozilla.org/en/DOM/element.addEventListener).
I know first hand that minification not only decreases page loading time but also speeds up rendering time, and from a server standpoint it helps to reduce memory, cpu, hard disk and network consumption. When you multiply all of these factors by the number of users/clients on my last project we would of easily needed another server to gain the resources of simple JavaScript minification. I would say that minification is necessary and that obfuscating code ultimately speeds up the entire internet. The second reason for it is to make code that cannot be compiled really really hard to read. This defers people from wanting to try to figure out what var k = b(c ^ d / 5, [f, m, l], z); does. First you would need to find the function ref of b, and decipher through all the variables c, d, f, m, l and z to see what it needs to even work. Then, you might start understanding what the function does, but it wouldn't be as clear as var pos = getPlayerPosition(playerRadius ^ 2/5, [playerX, playerY, playerZ], objectDistance); or something. A single function could take anywhere from hours to days to reverse engineer. I dunno, I see a reason for it. *Also, for the argument of learning:* Company don't (generally) spend months and months and months writing code for others (outside the company) to use it as a learning tool. Ask Google for their Gmail source, they'll laugh at you. If it were up to them I'm sure they wouldn't even give out the obfuscated JS your browser needs to render the page but instead would insist on encrypting/compiling the code. I bet there are terms against reading that too. A great place to learn JavaScript is by studying public projects like JQuery. They offer un-obfuscated copies of their work complete with comments and everything.
Officially I don't know enough JavaScript
I'm trying to call a function which contains calls to the two functions I need, but It seems to only use displayTotal() anyways
Thanks, this looks neat - am going to test in the project I'm just starting. --- Here's a quick link to the script on github: [https://github.com/greim/reglib/blob/master/reglib.js](https://github.com/greim/reglib/blob/master/reglib.js)
This project actually evolved as proprietary code starting in 05 or 06 (it's fuzzy) but I released it to the world in '08 because I didn't want to lose it if I ever switched companies. It made a bit of a splash back then and got a mention or two in [Ajaxian](http://ajaxian.com/archives/reglib), but I really haven't pimped it hard since then. Partly because jQuery came out with its .live() method right after I released this. Although I've stripped it down to its bare essentials, I like this library just enough over jQuery's .live() method to keep it alive. * It doesn't fetch a matched set of elements as a side effect. * Callback params correspond to selector elements (the thing mentioned in the GIF) * It has mouseenter/leave and focusenter/leave functionality that's actually useful. * It has convenience methods like handling escape, enter and arrow keys. Anyway I'd like to get more eyeballs on this to hopefully catch any bugs and make it more robust. It's been evolving rapidly lately. https://github.com/greim/reglib
For businesses, minification is critical: http://www.websiteoptimization.com/speed/tweak/psychology-web-performance/ * Google found that moving from a 10-result page loading in 0.4 seconds to a 30-result page loading in 0.9 seconds decreased traffic and ad revenues by 20% (Linden 2006). * When the home page of Google Maps was reduced from 100KB to 70-80KB, traffic went up 10% in the first week, and an additional 25% in the following three weeks (Farber 2006). * Tests at Amazon revealed similar results: **every 100 ms increase in load time of Amazon.com decreased sales by 1%** (Kohavi and Longbotham 2007). * Experiments at Microsoft on Live Search showed that when search results pages were slowed by 1 second: (Kohavi 2007) If you really support this, just open source your project and/or put the source on github (be sure to comment code thoroughly).
That's seems unusual to me, I could be wrong. Is this a known or common technique?
Thanks! Let me know if you run into any issues / need more data sets / create new datasets. Would love to get more patches.
I'd be interested in doing this. I'm familiar with data fuzzing and fuzz testing, but I'm not entirely sure how I'd implement that functionality into Faker. Do you have any suggestions how to do this? If you provide a high-level approach I'm sure I could implement it.
Event handlers should not be put into your markup. The best course would be to move this into a separate JS file and use event listeners as noted eariler. For example: // A helper function for easily binding events function addEvent(obj, evt, func) { if (obj.addEventListener){ obj.addEventListener(evt, func, false); } else if (obj.attachEvent){ obj.attachEvent('on' + evt, func); } } // Get your elements var start0 = document.getElementById('start0'); var end0 = document.getElementById('end0'); // Add your events addEvent(start0, 'keyup', displayTotal); addEvent(start0, 'keyup', function2); addEvent(end0, 'keyup', displayTotal); addEvent(end0, 'keyup', function2); 
 http://ajax.cdnjs.com/ajax/libs/underscore.js/1.1.6/underscore-min.js Returns: &lt;Error&gt; &lt;Code&gt;AccessDenied&lt;/Code&gt; &lt;Message&gt;Access Denied&lt;/Message&gt; &lt;RequestId&gt;A8E1110D56AF3E79&lt;/RequestId&gt; &lt;HostId&gt; /lrVUoFXI94h48laeaRhpp7vJpoqPsQkJCrEb1nHNWZoNCO/51stCo7tInmiYj29 &lt;/HostId&gt; &lt;/Error&gt; 
There are valid arguments both ways, I think. Maybe a happy medium would be to minify but don't obfuscate variable names. In case anyone's interested, I have a node.js [open-source web debugging proxy](https://github.com/greim/hoxy) that, among other things, can un-minify JavaScript on the fly for you. (Obviously it won't un-obfuscate your var names.) This video demo shows how it's done: http://www.youtube.com/watch?v=2YLfBTrVgZU
I love the idea of this service, but it's durability and viability need to be rock solid in order to use it in production. So the one question I have is this: This is could cost a LOT of money in AWS bandwidth/requests, how is it going to be paid for? Will it come to the point whereby the founders can no longer afford it? If as a community we know there is a rock solid plan to pay for the inevitable scaling that'll be necessary than there's absolutely no reason not to use it.
these elements are created by javascript though, and for some reason, it's not retrieving the ones called "end" + i; which is kind of a problem
This strikes me as completely useless, which means that it's probably bloody useful and I just haven't had the epiphany yet.
Hmm... that's not exactly the open source spirit, now is it? If you're not open to criticism and change, you'll get nowhere.
I love these array functions! I was also thrilled to learn that jQuery has built-in map() and fliter() functions, which can be used on both sets of matched elements or on regular arrays. jQuery([0,1,2,3,4,5]).filter(function(){...}); They may not reduce the amount of code I write, but they somehow make my programs easier to think about, if that makes sense.
If you can get it down to under 5k this would make a great submission to microjs.com
Haha, well, that may be non-trivial at this point. Currently it weighs in at 10k minified. I may be able to get it down to 7 or 8k minified but that would probably be a stretch. (just remembering how many evil things I had to do for my js1k project)
How about you get rid of the selector part of this and let us have the bit that's really innovative/useful --- the event delegation code. As Chiper said, this would make a great microframework, and I can actually see some really useful things I could do with it --- but as I said, I just want to be able to essentially do this: add/removeListener(elem, {event description in some format}, function(e){}); With normalized events, and cross-browser compatible I would use this lib in a second. IF I want fancy selectors later, I'll get Sizzle and work the two together.
Hmm good question. I would suspect that what you could do is something like you provide Faker with a set of parameters and then it provides values that are outside those parameters. Eg. fixedCharTextInput.value = Faker.fuzz({ type: 'string', min: 5, max: 10, validation: 'alpha' }); Faker.fuzz then will return random invalid values such as 'foo' (too few chars), 'asdf12' (not alpha only), 'foobarbazzfizzbuzz' (too many chars), `true` (wrong type), etc.
Use event delegation then - this will also help with cleaning up the markup by removing explicit `onkeyup` attributes.
I've just been checking with my current development build of [OpenSAGA](http://opensaga.org) with a real-life soon-to-be deployed application. all js files 1383224 bytes 100% js-compressed 503497 bytes 36.4% only gzip compression 341956 bytes 24.7% js compression + gzip 150701 bytes 10.9% just gzip compression just isn't enough. js compression plus gzip compression still comes in at only 10.9% of the original script size and even 44.1% of the gzip-only size. In our case, openess and accessibility to developers isn't an argument because we're under GPL or other free software licenses and everything is just available and downloadable uncompressed. I can kind of understand that people see the trend for application minification negatively because it undermines the open nature of Javascript. On the other hand, if the developer wants openess for his programs, it can just as well be made available uncompressed. Disapproving of compressed javascript is like looking down on compiled C code. It's just the delivery form.
Wait, wait, wait. You wrote a library in javascript. Then you presented it in....GIF format? You couldn't have used any of the many JS-based presentation libraries? For someone who has (presumably) studied how web browsers work, you have to realize the folly in presenting text in image format (or really, any non-image content in image format).
Is that still the case? I think I might have updated it since.
How is this different then jQuery.live? 
cheers, I just removed it all together
To elaborate a bit: * It doesn't fetch a matched set of elements as a side effect. In other words, one of the reasons to use event delegation is to avoid processor/memory consumption spikes at load time. If you have lots of calls to .live() at load time, you're grabbing and immediately discarding lots of sets of matched elements. This is an unnecessary performance hit. * Callback params correspond to selector elements (the thing mentioned in the GIF) * It has mouseenter/leave and focusenter/leave functionality that's actually useful. You virtually never want mouseenter/leave events to fire except when first entering and finally leaving the element declared in the selector (i.e. not children elements). This is how reglib works with both mouseenter/leave and focus/blur. * It has convenience methods to handle escape, enter and arrow keys.
AN AWESOME WHAT? YOU CAN'T LEAVE US HANGING LIKE
and they haven't updated the information too much since then
Haha, yes. *hangs head in shame* In my defense though, I just wanted to illustrate a couple features graphically, and an animated GIF seemed a quick and dirty (and reliable) way to get the point across. If you like, there's more documentation on the [github page](https://github.com/greim/reglib).
OK then. No need to feel ashamed, just wanted to make sure you never did it again. **ever**.
Except some points that W3Fools pointed out. Sometimes.
Okay, so toward the idea of an event delegation micro-framework... &gt; add/removeListener(elem, {event description in some format}, function(e){}); ...there's nothing about this signature that expedites event delegation, this is just a cross-browser event adder, right? At a minimum, I think what needs to distinguish an event delegation micro-framework would be some sort of filtering capability that determines which events need handling. Ideally, the filtering mechanism wouldn't be so big as to make the library too big, but useful enough to save you from having to write a lot of code. If you hypothetically stripped out reglib's selectors and just relied on a user-supplied filtering function: REGLIB.click(function(target){/*return a boolean*/},function(){/*do stuff*/}); Reglib's size would shrink, however the amount of code you'd have to write would increase, plus you'd lose the programming idiom described in the OP, which IMO is one of the things that makes reglib interesting.
Any hope of SSL support? Currently using a cloudfront wildcard cert that doesn't validate against you domain.
I just assumed everything on microjs supported all browsers, otherwise what would be the point of using it. Seems like if it doesn't work in all browsers, Microjs should indicate that. This just massively turned me off to Ender.
Thanks for these links. Angular looks pretty good i think. I like the integration of batman.js with node.js. Unfortunatly no code yet so I guess we'll have to wait for this one, but it looks really promising.
I click "Shop", "Order" and nothing happens. 
Right I'll try to fix that :/ I downloaded opera on my mac and it worked but the positioning is wrong. Thanks 
Looks pretty cool so far! I'm using it for Modernizr. Anything developers can do to help?
What about SSL support? How long cdn will be guaranteed to work? Do you serve files pregzipped (or defalted) from disk or compress them on the fly? I would suggest serving them pregzipped preferebly with gzip -9 or with 7z -tgzip -mx=9, and then use deflopt for further optimization. Other option is kzip, but it is closed source. I assume everything should cache perfectly in RAM (even in multiple version, like clean, minimized, pregzipped), as this all scripts are probably only about 20MB in total. BTW. Can you please not auto-select content of the input type=text fields when I select them? It is SO annoying. Please just a href=url. Thanks. PS. "Everyone loves the Google CDN right? Even Microsoft runs their own CDN." No not everyone loves Google CDN. First example will be Microsoft. Second will be me. Thrid will be authors of cdnjs.com... 
LOL. Look just how Opera's Dragonfly have solved this about 2 years ago. It just works. I wish Dragonfly could be used in other browers, it is nice open-source piece of software with well behaving protocol beetwen debuger and browser. 
I've been thinking about angular for a while. At first it seemed pretty compelling, but I really don't want to have to put specialized attributes pretty much everywhere in an app. Even on `&lt;html&gt;`. I guess it could work for a particular one-page app or something but it jsut feels to me like it would complicate handling markup too much.
Of course it can be because I have some newer snapshot or because I have highly customized opera config, but most other things works. I think i have similar problem on other webpage few days ago. 
LOL. Look just how Opera's Dragonfly have solved this about 2 years ago. It just works. I wish Dragonfly could be used in other browers, it is nice open-source piece of software with well behaving protocol beetwen debuger and browser. 
Using a naming convention to distinguish different types? I'd hardly call it a technique - maybe a practice. And no, probably not a common one .. although perhaps it should be more so? It's a bit redundant here as the parent object effectively namespaces the different types, but consider it as a precaution against using apples when you mean oranges. In a language that can't do static checks for this kind of error, I think *anything* that makes it more obvious to the programmer is a good idea. Generally descriptive names will do it, but sometimes no obvious name occurs to you, or one does but it is incredibly cumbersome. Compare [hungarian notation](en.wikipedia.org/wiki/Hungarian_notation). I find it somewhat amusing that this was a common practice in compiled languages back in the day, but now that dynamic typing is the flavour of the day, it's completely out of fashion. Despite the horrific ugliness of such names, I think there are applications for a similar practice in modern python/js/ruby/...
Indeed, and there were better sites around even then.
Way late to the game here, but ZingChart will do it - http://zingchart.com
Nice!
Cool! Do feel free to report issues/submit patches/etc on the github page.
...and here comes Don Quixote along! How's the windmills affaire going, by the way?
It is fine for hosting scripts that are not on the Google CDN, but for the ones that are, defiantly go with Google. Anyone can get a fast CDN, but what makes using the Google CDN to host scripts effective is caching. If a user visits one site that uses, say jQuery from the Google CDN, then it will not have to be re-downloaded on any other website.
Looked at angular.js briefly. Few random observations: * Code in markup (like &lt;button ng:click="generate()"&gt;). Not a fan of this, as it usually makes sense to separate content and behavior. Other parts of the example are more declarative, though. * The use of non-standard "ng:..." attributes. It's defined via `xmlns:ng="http://angularjs.org"` (and with HTML5 doctype) so that means the document has to be served as XML? HTML5 says *"In the HTML syntax, namespace prefixes and namespace declarations do not have the same effect as in XML. For instance, the colon has no special meaning in HTML element names."* * Looking at the code, one of the first lines is a host object augmentation. `if (typeof document.getAttribute == $undefined) document.getAttribute = function() {};` :/ * unnecessary browser sniffing in few places :/ if (msie) { node.innerText = html; } else { node.textContent = html; } * relies on (non-standard) function decompilation to extract arguments * standard low-level pitfalls: `isArray` in terms of `instanceof` (so will fail w. iframes), `isFunction` in terms of `typeof` (so might fail w. regex'es in certain webkit's and/or nodelists) * there's more code; no time to look through all of it now, but maybe someone else will.
Great point indeed, cdnjs does not host any libraries already hosted by Google or Microsoft.
Hello! I am the author of batman.js at Shopify. The code will be released under MIT very soon, but I'll be happy to answer any questions you have in the meantime. There are a few ways it's different from Backbone. First, the scope is larger while keeping the codebase almost as small. batman.js provides a binding-based runtime, routing, models with validation and persistence, and a robust view layer. It also works really well with CoffeeScript for beautiful code and follows strong conventions so you write less code and know how things work when you sit down at a new application. Finally, it's (optionally) a full stack framework that integrates with Node for servers, persistence, and tooling that all work on the same batman.js library and follow the same conventions. We're using batman.js at Shopify for Real Work (TM) so it should be really stable, lightning fast, and ready for other production use. Can't wait to get it out there ASAP.
It's good not just for unit testing, but also for ui developing/testing. Let me explain with a real world example: right now I'm developing an ipad webapp for some client using sencha touch. It's going to be a banking-related app, so it has long forms with lots of fields. While developing the frontend I don't have access to any backend whatsoever, yet; so no ajax calls, no data transfer, etc. Here Faker turned out very handy: i can test the form quickly with all the mock data I want and simulate a record load. Moreover, it's completely extensible giving me the option to generate custom data formats and complex objects, so i can populate my client-side Models and test, for example, massive record inserts once we have the backend hooked up. Another section of the app has charts. Managers DO LOVE charts ;) Once again Faker does an elegant job: I can generate random datasets on the fly and test how the various charts look and behave, have new random data at every reload thus simulating some "update data from server" behaviour and so on. In the end I think it is a very useful tool :)
&gt;presented by animated GIF &gt;closes window &gt;downvotes
&gt;Then you presented it in....GIF format? Text submissions don't get you karma.
What's wrong with creating an HTML page that contains images?
Taken from the comments on site "Cloudfront doesn't support https and CNAMEs when using S3 as an origin. You can still do it though. Access scripts like this: https://d3eee1nukb5wg.cloudfront.net/ajax/libs/backbone.js/0.3.3/backbone-min.js" You just have to reference the cloudfront bucket by it's ID rather than using ajax.cdnjs.com (this is discussed in a comment thread above)"
the doodles are nice, though
At the moment we are looking for sponsoring from companies such as Amazon and Cloudflare which would minimize the complications of community donations. Though you can at anytime fork the cdn repo and update libraries or help out on the public facing website. We already have a few dedicated users who have their own forks and do pull requests.
that's very informative, thanks!
so, you says reglib is greate for javascript events, and dom scripting, and present it in gif, and not actually cool webpage? WTF?
who the fuck cares
I always crack a smile when I remove a *.min* from a JavaScript file URL and see that the uncompressed version is also available, almost want to send a thank you note to the developer. I had a problem recently while trying to implement a drag and drop feature like imgur.com. I couldn't get the *dragleave* event to stop bubbling to its children, which pretty much broke the functionality. I tried to see how they achieved it, but their code is *packed*.. which is even worst than minified in term of readability. So I've red all the drag&amp;drop specs and help forums about it without any luck. In fact I almost lost my sanity trying to make sense of the fucking drag&amp;drop implementation. The only solution I could think of was to use a timer, but I couldn't resign myself to do it like this, HTML5 drag&amp;drop implementation couldn't possibly be [that shitty](http://www.quirksmode.org/blog/archives/2009/09/the_html5_drag.html) ? Then my intern spent an hour "depacking" their script, function by function, using online tools. When he sent me the file I eagerly opened it to see how they've done it .. only to find out that they too are using a god damn timer... So yes the implementation is a big fucking mess.
&gt; quick The same information presented in text on one page, will be readble in 3 seconds by any competent developer. I needed to wait whole minute to see what this library do! 
I never learned anything usefull or anything i didn't know already on w3schoold. They have horrible page layout, paging, examples, and indeed hide many important details from readers. I only go there because they rank high in search results on most www or xml releated topics :( 
&gt; LC_ALL=C wget http://ajax.cdnjs.com/ajax/libs/underscore.js/1.1.6/underscore-min.js --2011-05-11 04:56:19-- http://ajax.cdnjs.com/ajax/libs/underscore.js/1.1.6/underscore-min.js Resolving localhost... ::1, 127.0.0.1 Connecting to localhost|::1|:8118... connected. Proxy request sent, awaiting response... 403 Forbidden 2011-05-11 04:56:19 ERROR 403: Forbidden. However http://ajax.cdnjs.com/ajax/libs/underscore.js/1.1.5/underscore-min.js works. 
I like the variation on that pattern where the module is a constructor. You can write something like... const exports = this; Then you use *new* to build the library. You can also inject dependencies with constructor stealing, which is something you cannot do as cleanly when the module creates the "exports" object.
This cannot be true. If it were the arguments variable would really throw a wrench in the works.
I love open source - love it. I contribute to a couple of very large, very popular open source projects and regularly release open source code of my own. When you're serving a javascript file to the user, the primary concern isn't the programmer who's going to want to look at and modify it. It's the user who needs to be able to perform whatever action the javascript file facilitates. As a developer, you should be focused on making the user experience as efficient and pleasant as possible. If that means compressing your javascript so it gets there faster, so be it. There is nothing to stop the developer from also providing an uncompressed copy of the code for those who want it. 
You usually have a 'cat | minify' build step for JavaScript anyway. Just add compilation to that pipeline.
Let us know when it's out there!
Good point, but an HTML/JavaScript page would.
This is one of our primary concerns. We are in discussions with several entities in regards to permanently taking care of hosting costs.
Apologies for that. That was a new version I added today that got messed up. It's all good now.
tl;dr
You miss my point .. I'm calling for syntactic extension capabilities //within the language//, rather than an external tool. That would allow multiple extensions to coexist, rather than [a plethora of source languages that you can use one at a time, which will interoperate only on the core javascript level](https://github.com/jashkenas/coffee-script/wiki/List-of-languages-that-compile-to-JS). If this sounds strange and terrible, that's because you've never delved into lisp/scheme, factor or tcl which all have strong support for creating new syntax within the language.
As thomasdavis said above, we already have an SSL URL (https://d3eee1nukb5wg.cloudfront.net). Considering we use cdnjs for both our business and personal ventures, there is little question of cdnjs's longevity. At the moment, we serve pre-gzipped files. This is is only to get around the limitations of using Amazon S3 as a cache origin. We don't need to worry about whether the scripts fit into RAM or not. This is all taken care of by Amazon and its related services. NB: cdnjs is a distinct set of scripts to both Google and Microsoft CDNs,
yes thanks, looking forward to trying it out!
I always add "mdn" (Mozilla Developer Network) to my search to avoid w3shcools ►
You might want to check out [this post](http://www.mrspeaker.net/2011/04/27/reducing-map/) by Mr. Speaker. Some good info on jQuery map.
You seem to be in the wrong reddit. How about [/r/apathy](http://www.reddit.com/r/apathy/)?
 &lt;style&gt; .menuitem { cursor:pointer; font-weight:bold; } .submenuitem { cursor:pointer; } &lt;/style&gt; &lt;li style='border:1px solid black; height:auto;overflow:hidden' id='menu'&gt; &lt;span class='menuitem'&gt;Header&lt;/span&gt; &lt;div id="m3" style='height:0px;'&gt; &lt;span class='submenuitem'&gt;Sub 1&lt;/span&gt; &lt;span class='submenuitem'&gt;Sub 2&lt;/span&gt; &lt;span class='submenuitem'&gt;Sub 3&lt;/span&gt; &lt;/div&gt; &lt;/li&gt; &lt;script&gt; document.getElementById("menu").addEventListener("mouseover", function(e){ var rt = (e.relatedTarget) ? e.relatedTarget : e.toElement; if(!dieIfMenu(rt)) return false; return openMenuEffect('m3');}, true); document.getElementById("menu").addEventListener("mouseout", function(e){ var rt = (e.relatedTarget) ? e.relatedTarget : e.toElement; if(!dieIfMenu(rt)) return false; return closeMenuEffect('m3');}, true); function dieIfMenu(rt) { do{ if(!rt) break; if(rt.id=="menu") return false; } while(rt=rt.parentNode); return true; } function openMenuEffect(m) { var list = document.getElementById(m); var i = parseInt(list.style.height) for(;i&lt;=100;i=i+10) { setTimeout("document.getElementById(\""+m+"\").style.height="+i+"+'px'",10+i); } return false; } function closeMenuEffect(m) { var list = document.getElementById(m); list.style.height = 0 + "px"; return false; } &lt;/script&gt; So there's an improved version. I'll try to be comprehensible about what i changed. 1: Firstly, the reason it was opening more slowly than you'd expect was because you were asking javascript to redraw the div "m3" and therefore its parent "menu" once per millisecond, which was just too much for a lowly browser to handle. Changing it to 10 pixels every 10 milliseconds gives you the same theoretical speed, a much improved actual speed, and nobody's eyes could notice a difference. 2: The other easy fix: your menu wasn't able to open up the first time you rolled over it because openMenuEffect() is looking for "menu"'s style.height... but there was no such attribute set. Height is not automatically filled in, so you need to provide the starting value. I've done that with an inline style attribute. 3: a couple other changes; I turned your anchor tags into &lt;spans&gt;, not because the anchors are actually wrong or causing bugs, but just as a general thing to do when your items aren't actual links. if the submenu items do turn out to be links, then by all means re-&lt;a&gt; them, but if all you want is for it to be clear that the elements are interactive, changing the cursor and the style of the text is a better option. I've also removed the inline "onmouseover" and "onmouseout" attributes from "menu," as attaching the event via javascript allows you more flexibility, which I made use of as follows. 4: Your main issue was with the "spazziness," and this is due, as you suspected, to the mouseout/mouseover events being called every time you moused over a new element within the larger element. This is awfully annoying, and there are various ways to deal with it, but the shortest one I could think of was what I put up there. Basically, the events that I attach to "menu" are anonymous functions (they're defined right there instead of referring to a named function elsewhere in the document). Within these functions, I grab the "relatedTarget" attribute of the event object that gets passed to all event functions. (when an event is detected and found to have a handler, in this case the functions attached to "mouseover" and "mouseout", it runs that function with an event object as the automatic argument. The event object has a bunch of information related to the event, like what element was the target, whether shift was being pressed at the time, etc. In this case, "relatedTarget" tells me where the mouse was before it moused over "menu") Then I send the relatedTarget to a new function i wrote called "dieIfMenu()". This function takes that element, makes sure it exists, and then tests whether its id is "menu". Finally, it tries to find a parent element and repeats the whole thing until there are no more parent elements. if any of the hierarchy is "menu," then the function returns false, and the overall event handler function dies right there instead of triggering the menu functions. This detects the situation where the mouse goes from "menu" into "m3"; "m3" is a child of "menu", so the loop will find that one of the elements in the hierarchy is indeed "menu" itself, and cancel the closeMenuEffect/openMenuEffect spazziness before it gets started. 5: Last little things. I refactored your method of setting the timeouts into a loop that I think is a bit more efficient than your original. Instead of calling a separate function that finds the element, finds its height, sets its height, and then sets a timeout to start all over again, this way figures out the height and then sets all the timeouts it'll need to get to the target height. The interval starts at 10 and goes up by 10 each time because they're all getting set at once rather than waiting 10, setting a new one to wait 10, setting a new one to wait 10, etc. Don't take this to mean your way was wrong or silly. I'm no expert myself, but it felt like the way I wrote it was more efficient. Hope this helps!
So they reverted the API-changes to .attr(). Nice of them to do that, but how did they miss it during the 1.6 beta cycle?
Great article, thanks - I've pretty used to w3schools, but after reading this, I think I'll give some of these other resources a try.
I don't think they 'missed' it per-se, so much as they thought the change wouldn't have been as big of a deal to the community. TL;DR They got pie in their face...
&gt;W3Schools.com is not affiliated with the W3C in any way. Members of the W3C have asked W3Schools to explicitly disavow any connection in the past, and they have refused to do so. This surprised me, I always assumed they were connected. With that being said no-one really has any right to tell them what content they should have or how they should structure it. It seems to me that the real solution is not to have W3Schools change their content or structure. What is needed is a site which actually is what I (and no doubt many others) always assumed W3Schools was, an information source made by (or at least endorsed by) the people who decide on the standards. edit It also seems as if the guys that built this site are getting standards and best practice confused in places.
cite?
The biggest problem I find with the other resources is that they are not highly rated on Google. I use Google if I need to know something and normally w3schools is the first result back with the information I need.
http://classic-web.archive.org/web/19961219033314/http://htmlhelp.com/
Slightly problematic when we are talking about JavaScript, given that the 'standards' are dictated by ECMAScript but what you actually use in the browser is the browser vendor's own implementation. Of course you can always read the vendor's documentation, but they differ greatly in terms of quality (MDN is great, MSDN and Safari's, not so much, and Chrome... doesn't have one). As for the W3C, well they do have good information - just that most people don't go looking for them. Example: [HTML5 Specifications for Web Developers](http://developers.whatwg.org/)
&gt;the browser vendor's own implementation If only it was just javascript, gotta love 'standards'.
findSequence(goal) defines inside it another function called find(start, history). This function either returns history - if start equals goal, returns null - if start is greater than goal, or else makes recursive calls into itself. It's the recursion that does the looping.
 function find(start, history) { ... else return find(start + 5, "(" + history + " + 5)") || find(start * 3, "(" + history + " * 3)"); } Notice the recursive call. Not only that, but the recursion branches, in that for every call to find, you end up with two recursive calls: find(start + 5...) and find(start * 3...). The recursion stops when start &gt;= goal.
Oh I see now, thanks. For some reason I didn't realize it was calling itself as the "else" condition. I haven't dealt with recursion very much.
In order to understand recursion, you must first understand recursion.
It's also important to note that find(...) has complete access to it's definition scope (a.k.a findSequence(...)). This is why you can refer to the goal var in find(...) without explicitly passing it in.
I wonder if [Janky.POST](https://github.com/pyronicide/janky.post) might help with how to get the response back? 
In order to understand recursion, you must first check to see if you understand the base case, if not then you must first understand recursion.
Wait, input tags aren't allowed directly inside form tags? Does he mean they aren't allowed outside of form tags? I remember a day when the latter didn't work, but they've worked directly inside them since I started doing web programming in 1998. Maybe it's a case where the spec is more strict than the browsers? I've never heard of fieldset being required, and no browser has ever enforced it, but it could be written that way in the spec, I guess.
I hadn't seen (dunna-nunna-nunna-nunna) batman yet, but I have written a comparison of [backbone](http://www.decipherinc.com/n/blog/development-and-engineering-team/2011/04/backbone-api-and-events-models) and [angular](http://www.decipherinc.com/n/blog/development-and-engineering-team/2011/04/angular-model-single-source-truth)
I did wonder about the use of XML namespace, since HTML5 seems to have put a stake in that. But XML namespace behaviour is one of the last things I want to think about (at least, within the domain of web browsers), so I decided that someone had probably already thought about that for me. It'd be good to see evidence of what that someone thought, but I haven't run across it in the angular documentation so far.
My only problem with w3fools is that while w3*schools* is written mostly for beginners, the corrections on w3*fools* aren't at all. While I was reading through their corrections, I realized that I have indeed picked up a bad piece of information or two, but the corrections gave me absolutely nothing. It seems to be written for those that already know HTML/CSS/JS inside and out.
I am in a simpler situation as you. I have learned some python and am now trying to teach myself some javascript. Recursion was really confusing me so I picked up The Little Schemer and it has really helped 
[See here for more details](http://www.reddit.com/r/javascript/comments/h8x2j/im_sorry_if_this_isnt_the_place_but_im_trying_to/c1tjbk2)
that doesn't mean it's the "best" resource, just that it managed to get up in SEO.
That's why I use Personal Blacklist extension for Chrome - I effectively removed w3schools from my search results. Also - adding "mdc" to your queries will always get you stuff from Moz Dev docs
So this bundles old versions of jQuery in it and is less-capable than the native Web Inspector tools.
You don't even need to copy the contents of the form to the iframe, just set the form target attribute to the iframe's name/ID.
Nice.
How great would it be if Photoshop or GIMP could pump out this type of code. Or if there was an image format that could replicate this kind of moving viewable area. I cannot wait for animated GIFs to become extinct.
Made some good points. Tis a shame I must downvote for a false title and headline.
The actual tutorial: http://dojotoolkit.org/documentation/tutorials/1.6/declare/
Agreed. I don't understand why (s)he felt compelled to make such a misleading title.
Sigh... I understand the proposed position and on some points to some depth I can empathize. However, many of the proposed arguments, at least as they are written, are either lacking in accuracy or fail to understand the subjects being argued. That is disappointing in itself and devastating given the intention of this group. &gt; No employers recognize or respect W3Schools certificates. Unlike Microsoft’s MCP or Cisco’s CCC, W3Schools has absolutely no authority over the technologies for which they claim to provide certification. 1) A certification carries value not because of authority or ownership of any technology, but because of the quality of its process and the commercial recognition of that quality. &gt; Unlike CompTIA’s ANSI/ISO accredited certifications, W3Schools has no support from governing standards bodies. 2) CompTIA has no technology authority. CompTIA is technology and vendor neutral just like ISC2 and a few other organizations. This completely contradicts the argument regarding certifications and authority. CompTIA certifications have value because of their test process and the breadth of material their tests cover. I discovered this when I earned my CompTIA and ISC2 certs. &gt; W3Schools.com is not affiliated with the W3C in any way. 3) If W3Schools ever makes such a claim then the W3C can sue, and will likely win. However, this is not the case. Such claims are dubious ignorance proposed by individuals either attempting to spread malicious claims or who are simply too lazy or stupid to know better. &gt; W3Schools frequently publishes inaccurate or misleading content. 4) They are a private organization generating revenue by publishing advertisements and selling worthless certifications. They can publish blatant lies if they were so willing. While any malicious information is certainly worth shedding a tear over they are one source in a massive internet ocean of crappy incomplete sources. This argument is itself misleading if it calls out W3Schools as a crappy source, no matter how valid and accurate this claim is, if not calling out similar low quality and high traffic sources. &gt; Professional web developers do not recommend the use of WYSIWYG editors. 5) Late versions of Frontpage and Dreamweaver are completely expressive and powerful code editors far removed from the limitations and harm of older WYSIWYG editors. By late versions I mean any version released in the past 7 years. &gt; Again, frames are considered among the very worst of practices in modern Web development. In fact, they are considered so bad, they are no longer valid in HTML5. 6) Irrelevant argument to the various doctypes for HTML4.01 and XHTML. I could go on and on and on... Clearly people just need something to bitch about or want to feel special about something. Here, have a gold star and some hot cocoa. If that doesn't make you feel special go cry in a corner.
There's [APNG](http://en.wikipedia.org/wiki/APNG), you could also use [SVG+SMIL](https://developer.mozilla.org/en/SVG/SVG_animation_with_SMIL) or [CSS Animations](https://developer.mozilla.org/en/CSS/animation). Of course, the above won't work in all browsers.
&gt; Maybe it's a case where the spec is more strict than the browsers? I've never heard of fieldset being required, and no browser has ever enforced it, but it could be written that way in the spec, I guess. Pretty much. The HTML4 spec says that block-level elements and SCRIPT tags are the only things allowed as direct descendants of FORM tags. So before HTML5 it would make your HTML invalid. Of course, most of the HTML on the web is invalid and browsers render it fine. But I still think that reference sites should encourage developers to care about writing valid HTML because it helps avoid many of the common WTFs.
I don't think they meant for it to be a "patch" to sit atop w3schools's information; I think they're just trying to demonstrate that it's not a reliable source.
I think that's his point. It's annoying to have to go two or three pages deep to get to the best stuff.
Yeah, fair enough. Considering that though, the number of examples seems like a bit of overkill.
I couldn't read it. Not only was it a prototypically bad set of powerpoint slides (repeat everything the speaker intends to say, verbatim, with a funny picture or two injected) Reading it in that form is incredibly painful And the second sentence is factually incorrect, which doesn't bode well. 
something must have gone awry at [Google](http://www.google.com) as the PNG animation is gone. RIP Martha Graham animated Google doodle
APNG already exists, I don't know what the browser support is like however
[Not good.](http://en.wikipedia.org/wiki/APNG#Application_support)
Still there for me
My co-worker came up with this a couple days ago, and I thought it was pretty impressive, be sure to check out the [demo](http://codeincomplete.com/posts/2011/5/7/bin_packing/example/)
Challenge Accepted.
Thanks! :-)
Good book, though you have be careful applying it to JS as JS doesn't have tail call optimization so you can blow the stack with too much recursion.
Suppose you use jQuery, it's something like: var itemId; $("#buttonup").click(function(ev) { itemId = $(this).attr("class"); }); But it's not really recommended to rely on the fact that there's only one class on your target. you can also use some kind of class-prefix function like function classval(elem, name, separator) { separator = separator || ":"; var match = new RegExp("\\b" + name + separator + "([^ ]*)($| )").exec(elem.className); if (match) { return match[1]; } return null; } with that you could use &lt;a class="itemid:5"&gt;link&lt;/a&gt; and then something like var itemId = classval(this, "itemid"); Note that the first argument has to be a naked DOM element in this case, so when you have a jQuery-selection you want to access the element inside. $myJqueryObj[0] edit: in the function you also see the non-jQuery way of accessing the classes which is "elem.className".
mhh, I think you should better use the data attribute instead a class. See here: http://blog.seankoole.com/digging-into-jquery-143s-data-method http://ejohn.org/blog/html-5-data-attributes/ jqurey support this since version 1.4.3 
I believe you want `this.className`. This is populated with content in `class="..."`
Just as a note. I know the guys from the company quite well and I'd say they have a very interesting idea on their hand. And looks experienced and very into it. If I didn't have my own startup I would apply, but check it out.
Looks pretty interesting. If I was ready to head to the EU I'd be applying.
On Mac? Check out [Radi](http://radiapp.com/).
"A free mobile app tracks exactly where you are, 24/7, with almost zero battery consumption. And it automatically uploads everything related to what you do." Yeah, this sounds like a great idea.
So is this the beginning of [Final Cut](http://www.imdb.com/title/tt0364343/)?
This. While the other advice is solid, the question is wrong. You don't want to store IDs in the class attribute for later retrieval.
Haha, I remember the first time I heard of Evertale, and that movie came straight to my mind.
I can't tell you how much I would've liked to have known where I had been the day before. Mostly in a drunk state.
Eh, where the spec is stupid, and no browsers care about it, it should be a casual mention, IMO. FORM is a block-level tag, for all intents and purposes, it should allow inline tags as direct descendants. Not that I'm excusing the other w3schools issues, but I think this one is extremely pedantic.
I still don't understand why they didn't just use an animated gif. It seems like a waste of developer resources to reinvent it.
You can't wait for animated GIFs to be extinct, but you want something exactly like them, only more complicated and driven by a scripting language?
why do u assume the OP asking how to do this with jquery? 
I agree with the framework agnosticism, but jQuery is just one example. The data attributes exist outside of jQuery and can be accessed in other frameworks just like any other attribute. The notion of whether jQuery supports this may be helpful to someone inexperienced (who will probably rely on jQuery as a first framework), though.
None of that negates the fact that w3schools is a problem for the web. But yeah, bitching at them won't help. As you say, they're within their legal rights to sit back and collect a paycheck for sub-par content. The solution is to beat them at their own game: search rankings. This will either force them out of business, or else force them to improve.
If done well this will be a very, very powerful idea.
Thanks for the thorough reply! I will have a look and see if I can get it to work for me. I will let you know how it goes.
Thanks for the suggestions. I will have a look at my site and let you know what I work out.
very cool stuff.. lets see if these guys can make it happen!
This can be easily done with jquery and css. I don't remember if jquery natively supports easing but I bet you can find a pluggin for it.
My guess is GIFs are copyrighted, PNGs are open-source... maybee?
Just to follow up on this- i found that- because I was pulling in an li array of a list of fields from a data base- that I couldn't really use the id- buttonup for all of the list items. I set the class as 'buttonup' and then created an attribute called value. In my script I can get the 'value' by itemID = $(this).attr('value'); The issue that I'm having now (might be very basic) is how to allow multiple li items buttons to be clicked more than once while refreshing this list div content after each click. There's something strange going on with the command placement return false in the javascript and the on-click-return false statement in the a href. Any thoughts (if that made any sense to you). Here's the test page for reference: [link](http://waterbees.com/ptest.php) 
I think you mean patented, but [the patent has long since expired.](http://en.wikipedia.org/wiki/Graphics_Interchange_Format#Unisys_and_LZW_patent_enforcement)
bosey.soup.io Edit: sites at soup.io already implement infinite scroll
Something creative? What does the company do? Maybe they have an unsolved challenge or something you can improve upon (at least as a proof of concept)
Choose samples that show off that: 1. You know Javascript, not just jQuery 2. You have a firm understanding of OOP and how it works within a prototypical language. 3. You have unique ideas or approaches to solving problems. 4. You can produce maintainable and legible code. If you don't have code that demonstrates those things, start writing. If you aren't capable of those four things, start learning.
try googling for recursion .. did you mean recursion ? you can think of it as a delayed return value , meaning it could call itself 1000 times before it gets the value it needs to stop
They explained how these work during the Pac Man talk yesterday at I/O. They compress Flash animations into highly-compacted CSS Sprites with a JavaScript library deemed the Crushinator.
This is quite possibly the best analogy for the misuse of hashbangs that I've ever read. His url changes are obviously the better solution over hashbangs, it'll be nice when we can rely on that sort of thing in 5 years when IE8 drops low enough to stop supporting it.
throw in an example with some design patterns. For javascript I think singleton is easy to demonstrate, and factory and observer are useful too. Try and show some code where you made it modular or easy to maintain. An easy way is to not reference html directly in your js: $('#someid').hide(); //bad //good MY_APP.prototype.config = function() { this.nodeToHide = $('#someid'); } ... var My_app_obj = new MY_APP(); ... My_app_obj.nodeToHide.hide(); 
1. Good code.
Pick whatever you are most excited about having made. You will likely talk about it during your interview, and I find that enthusiasm goes a long way.
I'm a little confused why this was needed, onComplete is already called after the element is updated. [Ajax.Updater](http://api.prototypejs.org/ajax/Ajax/Updater/): &gt; Ajax.Updater supports all the callbacks listed in the Ajax. Note that the onComplete callback will be invoked after the element is updated. Are you saying it's not behaving in the way it's supposed to?
This is probably a good idea. Thanks.
I think the maintainable and legible code bit is key. Showing something that is/can be integrated in to a larger code base or even showing a large code base, if you have one, to demonstrate your ability to consistently apply patterns in a comprehensible way is very important for JS candidates.
80K is unheard of for a front-end gig in The Netherlands, even for a senior/lead. I wonder what the salaries are in other Western European countries.
i got asked once to create recursive code to convert numbers including commas into legible english text, like what you see on a bank cheque. $10,654 = Ten thousand dollars, six hundred and fifty four cents. That was a tricky one. Something tricky, that shows you got the analytical skills to achieve a real world problem. Another one i submitted once was a Timer object class. $time = new Timer(); $time-&gt;add("descript"); nice quick easy PHP, but real world practical. So i say, practical, real world and not easy code, something that takes a brain to write. AND dont copy and paste of the intarwebs, employers of that calibre are smarter than that.
Very nice application indeed, but I'm wondering if using XSLT is still a valid option. I mean: I really dislike xml-related stuff, especially in the browser, and probably this job would be better accomplished using CSS3. But, as the article suggests, the only option I could find it useful is to style legacy xml webservices and data sources still lying around.
you're welcome! I found this lib so useful that I had to share my toughts on it. Also, I have few ideas about nice extensions to it, but maybe I could group them in some "Faker-extras" sort of library, instead of adding them to Faker.js, what do you think?
Not a Dojo fan.. Besides doing this library independent is a better idea and Sarissa already does a good job.. Id release my library style code for this but its a mess and: Did this about 8 years ago.. It was nice then at the height of the XML web! The main problem is the size of the XML data transport and the amount of CPU required to process anything big. He's also not using the best methods performance wise, but its not bad.. You can cycle thru various IE activeX object using the most recent document object: each one is faster than the other but not available on previous version of IE unless certain Microsoft products are installed.. Youd use JSON now so its a bit redundant.
http://xkcd.com/244/
+1 for studying "Eloquent Javascript": it's an awesome text!
I'd say just do a pull request and we can sort it out from there. :-)
okay, but first I have to get used to git...it's really new to me! Just installed it few weeks ago, but only used it to checkout cloud9 ide :P
hahahaha oh my...this is fantastic! :D
 Signup for Github. Click the "FORK" button on the Faker.js Project Clone your new PRIVATE git url Make commits git push origin master Click "PULL REQUEST" button on Github
haha thanks alot for this crash-course! :) I'll let you know as soon as I code my ideas. Cheers!
Don't forget to watch http://github.com/marak Now you have no excuse to not commit :-D
THIS! We were interviewing a bunch of candidates, some with experience, and some coming straight from school. I asked them if they worked on an Open Source projects, or have a piece of work that's online somewhere which I can look at. That helps me differentiate their talk to their actual talent. Since it was web development, and they handled the JavaScript, you might get an idea of how they write their code in something else. If you're not sure if you're interviewing with someone in the tech field, or someone who is not, make sure your code accomplishes something - because non-tech managers I've worked with get wowed with the final product. **update** Surprisingly no one had any code!!! So if you do, and it's good, you go ahead of the pack.
&gt; in 15 years when IE8, IE9 and IE10 drops low enough to stop supporting it. FTFY
Do something with the konami code. People want to work with good coders, but being fun never hurts. 
voted^up for humor and the analogy
Even more points with a legit web development job if you can explain the limitations of jQuery and why you would not use it as the core framework to build a web application like gMail.
For this example, this is horrible overkill.
Just watched the tooltip and smooth rotating menu tutorials and visited the website, and then I realised again, what made me dislike JavaScript a few years ago: Not the language, but how it was used. For example: Annoy the visitor with animation and effects (A moving menu? User-friendly design is overrated!), break the expected behaviour of website elements (A menu which isn't build out of links and a website where you can't link to a specific page? Fuck the idea of hyperlinked documents on the internet!) and pollute the HTML with non-semantic code just for presentation and effect purposes. /rant ... sorry 
&gt; $10,654 = Ten thousand dollars, six hundred and fifty four cents. That was a tricky one. LOL
Wow this blew my mind, but yea it looks like even in 10 pushState isn't supported :-(
What exactly is wonderful about teaching how to make visual effects with DOM-centric spaghetti?
Thanks, that's a great point! I took a closer look through the jquery form.js plugin and that is indeed what it's doing. I've updated the article to illustrate this method.
You can do this very easily with this plugin: http://jquery.malsup.com/cycle/ Other than that, I'd call it "broken". At least in chrome it won't stop scrolling once you come to the end at the right. When the box is empty, you can keep clicking the right arrow, and then click just as many times to the left to get back.
No problem, thanks for mentioning me in the article :). Just a suggestion, maybe you should make it more obvious that you need to give your iframe a name and ID and then set the form target attribute to that (in the article you just say target={New hidden iFrame}).
umm... inline SVG anyone?
I found it entertaining
I agree with you there, but I think it has a time and a place.. but the reason I posted it was because I found it entertaining
yeah, but it's used for the signals (pubsub) mechanism, it's not a full-fledged library. I think js-signals it's very well tought, and Crossroads being built on top of it a good thing. Many libs are built on top of other libs, and if the lower-level ones are well written it's a great example of code reuse! Microlibs are nice, but in the end I don't think each one should reinvent the wheel every time :)
here are some examples: https://github.com/millermedeiros/crossroads.js/wiki/Examples yes, it's not much but I think they pretty much show everything you need to get started.
Sure, that's always an option, though if you wanted to add content inside a variety of different elements you don't need to embed multiple documents. If nothing else, it's an example of how you can use the css3 `transform` and `transform-origin`.
I have a serious question -- do you save work you have done for your previous companies? Isn't it a violation of most standard employment agreements to take code with you?
It really depends on the company and what kind of work you're doing. Obviously if you signed a contract saying that everything you write belongs to the company, then no, you aren't allowed to keep/share the work. That's why it's important to make your own code outside of work and have your own projects (if you signed a contract that says even that belongs to the company, you're fucked). I'm lucky enough to work for a company that doesn't care. Naturally I'm not going to just publish the internal code for everything we build, but I'm allowed to use code I write on the job in open source projects. The majority of the code on my github account was written during work hours.
Even after reading the page comparing the three event systems, I'm a little lost at just what 'problem' this library is attempting to solve. It just seems to make event management more complicated...
Protect the global namespace. Comment your code (to show you're thinking about the poor son of a bitch who has to inherit your code). 
Thanks, I wasn't sure if I was ignorant or if it was just a conditional situation. I always just erred on the safe side and provided code from my OS contributions, personal projects or freelancing. Which always bummed me out, because my best code is usually for my primary gig / day jobs.
This looks handy.
looks pretty solid. Couple of things: line 22: if (x &gt;= ($(window).width()/48)-2) { you should move the ($(window).width()/48)-2) out of the loop. No reason to get the window width every time you go through the loop as it should stay unchanged. small nitpick, I'd put these on separate lines var x = -1; var y = 1;
Out of curiosity, why do you feel jQuery is not suited for apps like gMail? Personally, I find the GWT approach to be less effective than a well-written cross-browser library. Additionally, GWT introduces a bootloader and bloated code customized to browsers. I'm not a fan of the bootloader and still don't understand how "aggressively pruned strongly typed code" can inflate a one-liner like function add(x,y){ return x+y;} to 20kb. However, I'm not that experienced, so I'd like to hear what the reasons are.
[This post sums up the reasons perfectly](http://blog.rebeccamurphey.com/on-jquery-large-applications) Basically, jQuery is targeted to be solely a DOM library. Other JS frameworks like Dojo and EXT provide a core library that does everything jQuery does, and a full widget framework with a ton of helper methods to help you create more OO-based code. These frameworks help with event management, memory cleanup, dependency management. The real benefit shows when you are working with a team on a browser-based application (e.g. gMail) and you need to write maintainable, modular code that many people will be touching. For example, dojo's widget framework (dijit) provides an MVC approach to writing front end widgets. This has worked wonderfully for my team. There are a few other reasons, but the post I linked to hits the nail on the head for why you would want to use something beyond code jQuery for large applications. Now, don't get me wrong, i think jQuery is GREAT for normal websites, and it totally can be used in larger applications when you combine it with other libraries like RequireJS and backbone.js. I personally just go straight to dojo in this situation because everything is already there has been used extensively for years, but there are ways to get jQuery to work more as a "framework".
Thanks, I've bookmarked the post and will definitely be checking that out later.
&gt;it'll be nice when we can rely on that sort of thing in 5 years when IE8 drops low enough to stop supporting it. That's missing the point that you don't *have* to use hashbangs. The kind of functionality he's implementing is nice, but not necessary, to browse the content; it doesn't matter when IE drops low enough, because they just get the degraded, but still usable, experience.
Just my 2c, 1) I've developed an almost maniac habit to avoid closures if possible. It makes my code much more readable/maintainable (for me at least). So every something(function(){ ... }) would be better (IMHO) as something(functionName) or even something(myMainObj.functionName); AFAIK it helps to avoid memleaks and also helps to have better completion on some IDEs (I think) 2) try caching as much as possible, instead of using $(window).width() two times, why not at the top: var win = $(window), winDimensions = { w: win.width(), h: win.height() }; and use winDimensions wherever you want 3) I like to have all the "var" declarations on top of the functions, like: var x, y]; for(x=0; .... .) { y + x; //or whatever } 4) In for statements I like to do: for (counter=0; counter &lt; arraylength &amp;&amp; (holder = array[counter)); counter++) { use(holder) } Well, thats just for me :) If anyone has some suggestions for me as well, I'd be very grateful :D PS: I use closure if its better for my code, like when I need to use values from outer scope, or something like that (maybe in event handlers)
Nothing wrong with closures. Your objection seems to be aimed more toward anonymous functions, which is a valid gripe. It's not always immediately obvious what an anonymous function does. On the other hand, separating out a function that you only use once can seem like a waste. Solution? Name your function. Instead of: foo.something(function() { /* Who knows what this does? */ }); You can do: foo.something(function calculateBar() { /* Clearly calculates bar */ }); That way, you can easily see what the function is supposed to do. Also, if you use Firebug to profile the code, the function is far easier to locate in the stack trace. More info: [JavaScript Kata](http://www.javascriptkata.com/2010/05/19/how-to-de-anonymize-your-anonymous-functions/)
My favorite thing about people who "throw in some design patterns" is being able to weed them out as cargo cult programmers early on.
&gt; I have a serious question -- do you save work you have done for your previous companies? Isn't it a violation of most standard employment agreements to take code with you? Just ask your employer during your exit interview. The answer you usually get is "probably, but we have to check with legal first." Generally, employers are okay with letting you take out specific stretches of code, under the onus that they are only used in interviews. Not like you can't just do it again, so why wouldn't they?
On line 6, not sure why you're invoking the jQuery DOM ready function again. .attr(), .css(), and .appendTo() all execute synchronously, so there's really no need to put the rest of your code in a callback to the ready function. Also, I'd just like to echo what Pyro979 and ricardoe said above -- you should cache values you use in a loop if the value isn't going to change.
Yeah, I guess I was always worried that prospective employers would ask me like "So how did you get a hold of this proprietary code from your last job". Sounds like it's a lot less cut and dry than that.
Oh hell yes.
I wrote [something similar](http://code.google.com/p/congee/) for my projects a while ago, except that it checks the path name rather than the hash.
In your for loops, put the array lengths in a variable so it doesn't get computed every iteration. For example: for(var i=0, len=fonts.length; i&lt;len; i++)
True :) Thanks for the tip.
The one benefit I see to this is objects are self documenting. All it takes is a little introspection during runtime to see which events a object has. 
While jQuery probably parses it exactly the same, &lt;div/&gt; bugs the shit out of me (not valid HTML/XHTML). Use &lt;div&gt;&lt;/div&gt;, please. Also, you can do $('&lt;div id="whatever"&gt;&lt;/div&gt;') instead of using the second parameter. I don't know if jQuery handles that differently. Assuming it uses the second parameter to apply the attributes via DOM instead of innerHTML, keep doing using the second parameter then. Just mentioning. Don't bother doing .split('') for the array variable, array.length works the same for strings, and you can just use array.charAt(x) to get the character at a certain point in the string.
Just so long as you keep in mind that MDN is a wiki and as such some articles may also be outdated or misinformed.
jquery is not a framework.
Odd. I get "bar" as expected in IE8 on XP. I think having named function expression is fine -- I believe the problem occurs when you try to use a conditional function declaration like so: if (true) { function foo() { return 'first'; } } else { function foo() { return 'second'; } } foo(); In this case, IE (incorrectly) parses the declarations sequentially and returns 'second'. Of course, using a conditional function declaration is lame no matter which browser you're targeting.
Yeah, I was trying to keep it more conceptual, but I can see how it'd be confusing. I updated the image to say target={iFrame's name or id}.
&gt;All the script does is create an amalgamate typeface from all the fonts on your system, by drawing them on top of each other. That's something you should put into comments. Break it into tiny functions which do *one* thing and than add comments which explain what each function does. Currently your code's nesting level is far higher than required. A lower nesting level makes the code easier to read and also a lot easier to write. More nitpicking: * Your indentation is inconsistent. * Your usage of spaces is inconsistent. * `$(window).width()` is inside the loop. * Splitting the text into an array wasn't necessary. `'foobar'[4]` works in modern browsers which support Canvas. Try JSLint. It helps to write code which is formatted consistently.
Pretty slick. Bookmarked, I'll definitely consider using it in a future project.
yes i see my speed typing mistake, my bad. that would have lost me the job for sure. I can assure you my half asleep ass, didnt make that mistake in the interview. hehehehe.
No problem, feel free to pm me or continue tue discussion here if have any more questions.
Wow thanks a lot that really helped. Keep up the good work, without the contributions of kind people like you I'm not sure what the internet would be. Hopefully you can make someone elses night too. You're a national treasure.
Just use jQuery to make an ajax request with success and failure listeners. There are a million tutorials on how to do this.
Also, make the vars like: var x = -1, y = 1;
Just started playing with this last night! I looked at a few different client side routers and liked the syntax of PathJS the best. The way parameters are defined and accessed were also convenient compared to the others. Sugarskull ( linked below ) required writing regex with capture groups. In case anyone is interested, here's a few others I looked at: [leviroutes](https://github.com/PaulKinlan/leviroutes) [sugarskull](https://github.com/hij1nx/SugarSkull)
This may not work cross domain. You could get old fashioned and do it with the DOM like this: var tester = document.createElement("iframe"); tester.addEventListener('load', function(e) { alert("All good"); }); tester.addEventListener('error', function(e) { alert("Danger"); }); tester.setAttribute("src","http://google.com"); tester.setAttribute("style","display:none"); document.getElementsByTagName("body")[0].appendChild(tester);
IE isn't incorrect here, just different from other browsers. This is invalid ECMAScript, but the standard allows browsers to add their own syntax extensions. And different browsers added *different* extensions to support this syntax. *"The nice thing about standards is there are so many to choose from."* 
&gt;[...] and the class in this case is 5. Classes and ids can't start with a number. Use a data attribute for this. And basically it works like this: You attach the handler and if the handler runs, it checks where that event came from. It can then retrieve some value which was stored in a data attribute or whatever.
Don't use `a` elements if all you want is `cursor:pointer`. Don't use `document.write`. Your code is a copypasta train wreck.
Use a jsonp call in the head of the document using a script-tag &lt;script&gt; var timeout = setTimeout(function() { console.log('something bad happened'); }, 5000); // put your preferred timeout here var onsuccess = function() { clearTimout(timeout); console.log('great success'); }; &lt;/script&gt; &lt;script src="http://yourservice.com/status?callback=onsuccess"&gt;&lt;/script&gt; Script-tags are crossdomain so it should work everywhere. They are also blocking so the rest of the page wont load until this check has been run
I think it's a nice pattern, the fact that the signal is an object seems appealing to me. Handling event emitters and such as an object instead of a magic string seems a bit less error prone than... `$('something').bind('cluck', function(ev){...})` drat I meant `click`, but instead of an error, my binding just never fires. Anyways, it's an interesting alternative.
Well, they're right to ask that, and you're right to worry about that. And as long as you explicitly acquired permission first, you have a tidy answer.
Wouldn't your unit testing catch such an obvious error?
Awesome thanks!
Thank you =)
Thanks. This helped a lot,
Lol
Yet again another perfectly good library that has no reason for using jQuery. It looks super handy, but the less dependencies, the better (in my humble opinion).
You're right it doesn't need to be, but I wouldn't mind if this was included in jQuery (in my humble opinion). Update: Actually, it looks like the only jQuery specific feature used is $.error and $.isFunction
Great work! Very impressive.
I mean... Personally, chances are that I will be using jQuery on a webpage that I'm developing if there's a big JS component to it, so it's not a big deal for me. However, there are a lot of other JS libraries out there that developers use, and I think it's a shame to tie down a perfectly good library to a single library as a plugin, especially when it doesn't really need it.
It appears to have a few bugs... it got stuck to my mouse and no amount of clicking would make it stop scrolling.
This would be _very_ easy to make non-jquery specific. In fact I think I may fork it and do that on monday.
How about using it on a selector and having the context of the function be the element(s) that are selected.
hmmm, isn't a bit problematic that "$.after" already exists inside jQuery? They simply changed the [$.after](http://api.jquery.com/after/) to be setTimeout? That would brake sites in a spectacular way!
sure it would, but being it an object it will throw some excepion or pop up an undefined error as soon as the code gets executed, instead of just failing silently. +1 for object signals in place of strings!
- "Please only ever use strict-equality comparison operators" When I use typeof operator, I don't need a strict-equality test since I know that the result will always be a string : using == is fine. 99% of time, you know what type you're testing... - "Doing too much in a loop or recursive function" Bad example : just a premature optimization (see a lot of tests on jsperf) - "Not understanding and therefore not appreciating the benefits in abstracting repeatedly utilized code versus having a wall of unreadable code" Adding 70-80 KB of code is not the solution... By the way the "bad code" example is readable (see "Choosing terseness over readability") - "Creating DOM elements within a loop" It's fine if the DOM elements are not attached to the document in the loop. BTW, use innerHTML only when you cannot use DOM because innerHTML is really not faster (see tests on jsperf again) - "Using inline event handlers" Again, you can save a lot of KB if you write : element.onclick = doSomething; - "Having long HTML strings in your JavaScript" Maybe a bad use of innerHTML ? 
Only "$.fn.after" already exists. It could still be a bit confusing though.
I don't really see much advantage to this, mainly because of the huge gotcha where if your passed function makes any external function calls then they too will have the extended methods available (this could be confusing to debug).
I'm not sure I understand. Isn't the entire point of this to add jQuery sytax to existing JS functions? If it shouldn't use jQuery, then it really shouldn't exist.
Yay, another mapping tool that doesn't follow open standards! Where is the WMS support? WFS? Use OpenLayers and ignore the rest.
how accurate are these functions, to the millisecond?
They have no accuracy. The only guarantee is that your callback won't trigger *before* the stated time. There is no promise as to how far after the time you set the callback may be triggered (delay may range between a few milliseconds to a few seconds).
Couldn't agree more. JQuery is good at DOM, it should stay that way. Building apps around jQuery as the end-all library is a really, really bad habit that we've picked up. Got big hopes for Asynchronous Modules catching on - dependency management in the browser makes it *so* much easier to build big applications. If we could only get a central repo for JS packages (not sure it NPM is it..), we'd be set :)
What about asynchronous programming ?
Give it a bit of time to mature. It's much snappier than openlayers an has a much better presentation. Competition is good.
Oh hah this article is nearly a year old now and my thoughts weren't especially collected yet when I wrote it. The [Roll your own PubSub with DNode](http://substack.net/posts/9bac3e/Roll-your-own-PubSub-with-DNode) and the readme text are probably better places to start now.
Javascript is brilliant, but it can be a pain in the ass while debugging...
&gt; &gt; Yet again another perfectly good library that has no reason for using jQuery. &gt; If it shouldn't use jQuery, then it really shouldn't exist. I'd say you are both right.
good to know!
oh good! I stumbled upon that article too, but I tought the older one gave a more introductory explanation of DNode, but maybe I'm wrong.
&gt; at least be able to write a singleton in every language, minimum achieved! :) If you think that's an adequate minimum for employability, then we would have very different reactions to many interviewees.
great investigation!
Sorry. I should have said "library". I ignored the specific implications of the term there for a second.
I agree. All that's being proved by the parent is that he knows how to overcomplicate code.
ouch.
I don't see anything really new here, other then it looking a bit jQuery-ish. Is that really a feature? I have my own time library and the most used method is one designed for chaining functions for CPU heavy JS. Shouldn't require a timeout value, and that is something this library needs.
Yeah, I think it's important to note that he's not actually talking about creating elements that causes the delay. It's inserting lots of them into the main document that causes the unresponsiveness he's trying to avoid. Probably repeatedly redrawing the layout is the cause. But, he is right to say that should be done with a document fragment; one redraw is much better than potentially hundreds.
&gt; Couldn't agree more. JQuery is good at DOM, it should stay that way. For the record, this is the stance taken by Resig (creator of jQuery for anyone not aware) himself - and his justification/reasoning for not adding certain things to jQuery that are often requested.
That's a whole lot of anger for someone who admits they don't even understand the thing they're being angry at. Self employed? Huge surprise.
Cool, drop url here afterwards... This could be usefull for my js gameprojs that doesnt use jquery 
Ugh, talk about edge case...
I'd say this is a mistake in JSON's specs. Happens.
This. The article is sensationalist in tone. "Aha! I found an edge case! EVERYTHING YOU KNEW ABOUT JSON WAS WRONG OMG"
The grammar on this article is terrible -- Lots of confused they're/there/their's, poor sentence structure... I kept on having to backup and reread things to figure out what the author meant.
Your advice is good, but you could have put it more kindly. He's new, not an idiot.
-Non-constructor identifiers beginning with a capital letter -Choosing terseness over readability -Not knowing DRY These are great points for any language -Prefixing every new variable in a given scope with var I don't really see the problem with this. While it may be redundant, it doesn't really cause any problems, except for perhaps minimal bloat, which can all be fixed by using any number of minifiers. -Creating DOM elements within a loop This section might be mistitled. The real sin here is appending multiple new elements to the main DOM document in a loop -Using inline event handlers Amen. Perhaps my favorite point and biggest peeve. Other good points to mention may be to: - avoid eval - avoid AJAX multiple calls that return static responses - lack of modularity/namespacing
Why is this not on the front page?
Congrats on finding a mistake in the JSON specs, but the holier than thou tone is annoying.
Meh I'd rather something fail as I'm writing code rather than when running tests or worse if no one notices and it gets to production like that where it's essentially a dead piece of code that never gets fired. To each their own I guess.
Am I the only developer who finds argument overloading kinda stupid because it can easily lead to confusion? I think it is "different/acceptable" if the language natively supports methods/functions with the same name and varying arguments, but those tend to be strongly typed and the compiler can easily make sense of which to use. 
Odd, it seems more like a mistake in the JS specs to me. I'd actually support browsers allowing those unicode characters.
^ This.
^ This.
^ This. Troll assumes that by not using design programs, he's some sort of hot-shot and an intelligent programmer. Doesn't realize the stupidity of using blanket statements.
Depends, if JSON's spec was "copy the JS spec" and they missed this, then it's a mistake on JSON's part.
Oh, I thought it was just line break characters, not all unicode characters.
All done. https://github.com/ChiperSoft/Timed
I'd say the point of this is to create a more human readable wrapper for setTimeout and setInterval. `after(5, "seconds", callback)` is pretty easy to read and doesn't require knowing what after() does. `setTimeout(callback, 5000)` requires knowing how setTimeout works. It's easily possible to reach that goal without relying on the presence of jQuery. I just forked this lib and did it myself: https://github.com/ChiperSoft/Timed
&gt;When I use typeof operator, I don't need a strict-equality test since I know that the result will always be a string : using == is fine. 99% of time, you know what type you're testing... While I agree, it just makes it easier to get in the habit of testing equality every time, it costs you nothing but a keystroke and if you refactor later down the line it provides you with a layer of protection. One of my favourite quote by Crockford is &gt;'It hardly ever happens' is just another way of saying 'It happens' It's just easier to write assuming that it will happen.
Why is that? Modern debuggers are pretty good coupled with syntax linters such as [jslint](http://jslint.com) or [jshint](http://jshint.com). Even the Microsoft Script Debugger for IE6/7 is serviceable.
I have a problem with how he describes arrays as associate... they are not var asdf = [1,2,3]; console.log(asdf.length); //--&gt; 3 asdf['someKey'] = 4; for (var i = 0; i &lt; asdf.length; i++) { console.log(asdf[i]); } // --&gt; 1, 2, 3 console.log(asdf[i].length); //--&gt; 3 console.log(asdf['someKey']); //--&gt; 4 All you've done here is added a property to the `asdf` array object, but not added a new index. Sure `for in` will work but it's a misuse of the object and may produce even more unexpected results.
It happens when you release the mouse over the facebook like button iframe - the document doesn't fire mouseup in this case... I'll think what I can do about this. Please report any other bugs here: https://github.com/CloudMade/Leaflet/issues
Leaflet works much faster than OpenLayers in general, weights ten times less, it's very usable and fast on mobile browsers unlike OL, it concentrates only on the most widely used features instead of doing everything for everyone, and it has a much cleaner and easier to use API. Oh, and WMS support just landed, check it out. :) Without doubt, OpenLayers is a great library, but there are a lot of cases when using a lighter and faster library such as Leaflet is much more preferable.
It's amazing that you fall for that sock puppet.
Thanks for posting this! I'm the author and maintainer of the library, AMA.
This is pretty awesome, it looks like it's still under some serious development, but you can play or watch others play DCSS which is an excellent roguelike.
Thank you for your kind support. :) You're right, lets give it some time, it'll become much more competitive soon.
Yeah this is really amazing. I love being able to watch others play, particularly for roguelikes which can have some nuanced strategy. Also being able to play on a public server but with full tiles support is a big improvement from when I last played DCSS on develz.
Any idea why it's not working in Firefox 4? websocket security block in about:config is false, and websocket is enabled (true). Is anyone else experiencing this problem?
um...what? how is that any better than myApp.utils.justFuckingCallRandomNowAndGetItOverWith([1,2,3]) or if (typeof Array.prototype.random != "undefined") { Array.prototype.random = function(){ //define random here } } I mean the whole point of extending the builtin is so you get succinctness, but if you have to do all that wrapping anyway, you lose that. 
what do you expect from "coffeescripter.com"
No clue, seems to work fine in chrome :)
Thanks, what is tail call optimization?
Fuck.
Holy crap, this is an uber hack. But where is JSLinux stored? In cpux86.js as well?
Thats crazy. I could see this a good teaching tool.
It's referenced in the code (yeah, cpux86.js): [vmlinux26.bin](http://bellard.org/jslinux/vmlinux26.bin) (1.6Mb), [root.bin](http://bellard.org/jslinux/root.bin) (2.0Mb) and [linuxstart.bin](http://bellard.org/jslinux/linuxstart.bin) (14,5Kb).
No, it is loaded later by javascript. You could check that in Firebug or in Chrome developer tools.
Stops at Freeing unused kernel memory: 124k freed for me (Chrome Beta)
 # vi /tmp/foo iWHAT. THE. FUCK. SERIOUSLY, WHAT THE FUCK.[esc]wq # cat /tmp/foo WHAT. THE. FUCK. SERIOUSLY, WHAT THE FUCK. 
It's not open source.
I meant it could be good for teaching Linux. It is a lot more simple than setting up a vm or installing to a machine.
Evidently Opera 11.10 and Safari 5 are too old...I can't stand this kind of mentality when it comes to coding.
Amazing. Coming soon, javascript N64 emulator?
[http://bellard.org/jslinux/tech.html](http://bellard.org/jslinux/tech.html) "(it does not work with Chrome 12 beta. As far as I know, it is a bug in the browser" Also, [the author of that thing](http://en.wikipedia.org/wiki/Fabrice_Bellard) is so awesome... I want to be him.
As a long-time Opera user, I have to agree with you. As an avid JS programmer, I kind of understand him.. "too old" in this case seem to be the fact that Opera and Safari hasn't implemented typed arrays. They are crucial for the performance in this case, and, well, at least he's doing feature detection and not browser detection.. function Gf() { return (window.Uint8Array &amp;&amp; window.Uint16Array &amp;&amp; window.Int32Array &amp;&amp; window.ArrayBuffer); }
 # rm /bin/ls # ls sh: ls: not found
 ~ # rm -rf / ... sh: getcwd: No such file or directory (unknown) # ls sh: ls: not found sh: getcwd: No such file or directory
Great idea, but there's a flaw .... no networking. I love this idea, but linux without a network = pointless imo. But I'm a network technician, soooooo..... that *MIGHT* have something to do with why I think like that.
Thanks! You just ruined it for everyone else.
There is no pleasing some people.
btw. the author of this emulator is also the author of * FFmpeg * Qemu * Tiny C Compiler (tcc) * a ton of other cool stuff http://bellard.org/ http://en.wikipedia.org/wiki/Fabrice_Bellard
"old" isnt the right word to use. More like "feature lacking"
You do realise client-side javascript isn't allowed to access data on other domains right?
Yeah, I mean, without X11 it's worthless.
Needs moar Canvas
Technically speaking the network stack is all there, there's just no emulated NIC driver.
It has a working C compiler (tcc, written by the same author).
you can view the .js files?
Wow. I thought this was some kind of joke, but then I changed the c program and recompiled it, and it worked. That's nuts. Kudos! edit: OMFG it runs emacs
I want to assume you are being sarcastic.
beautified js is 7868 lines...!
Maybe with node.js or XPCom privileges? Or just websockets and a proxy.
Not even kind of the same thing. That's an *enormous* leap to make.
I was thinking of a js n64 emu as well (kinda started it, but then I felt there was too much remaining (there's a fuckload of shit to do when making one)). I myself did a GameBoy Color emulator in JS and am currently doing a GBA emulator in JS. I was also thinking of an x86 emu in JS, but this guy apparently got to it first. lol Still, I got to hand it to this guy for making an x86 emu in js, since it's a complex CISC processor. I'm just wondering if he's got clock cycle accuracy in it. **Edit: for those links or it didn't happen people run http://www.grantgalitz.org/PokemonCrystal/ in Firefox 4.**
vmlinux should just be the linux kernel, root.bin is probably the filesystem, and linuxstart.bin is probably another filesystem. The javascript is plaintext so that isn't an issue.
Maybe not N64 but command line games should be a possibility. If he has the instruction set emulated properly anything that can be compiled for Pentium MMX should work (even if it is incredibly slow). A GUI would probably be the difficult part since it is actually outputting text and not a fully simulated screen. It MIGHT be possible to get SSH and X forwarding to work though. Of course compiling everything natively on this emulator would take forever but, again, assuming that the instruction set is emulated properly you could theoretically just tell another compiler to compile for Pentium MMX and then stick the software on the emulator's file system.
It could be done but it would not exactly be easy and performance would probably be abysmal. Send everything via AJAX to the web server and then have the web server forward the request along.
yeah, they need to get Internet, X11 and chromium working on that puppy so I can visit the site with itself.
The javascript is obfuscated (minified).
Come on, this isn't exactly an every day tool. It's pushing the boundaries of what is possible, I don't think it should be held back for browser compatibility reasons.
Ha. But the disk is not shared. 
This is beautiful, but is there a practical use for it yet? I think this is an amazing way for Windows and Mac users to get used to shell without actually having to have Linux first. But the fact that there is only a "hello.c" file is disappointing. Anybody think it will be extended to a full-as-possible run of Linux? Perhaps with a mix of PHP, it can have a fully functional file read/write system.
When Jesus needs help programming the universe he goes to Fabrice Bellard. P.S. im an atheist, dont hate me bro
[I've seen much worse](http://pastebin.com/Efem3r6Z).
It's not really obfuscated... Use http://jsbeautifier.org/ to make it more readable [In fact here it is done for you.](http://pastebin.com/0tZfAkYG)
Then it wouldn't be javascript, it would be javascript + ruby/python.
Don't act surprised when you see Windows 95 booting up in chrome or firefox in the near future.
Interesting, so Typed Arrays are sort of like unions in c, except the types are not specified in advance. 
&gt; Modernizr uses JavaScript to add those classes to the html element; one for each of the features detected in the current browser. If we examine the generated source we see the following: &gt; &gt; &lt;html lang="en" dir="ltr" id="modernizr-com" class=" js flexbox canvas &gt; canvastext webgl no-touch geolocation postmessage websqldatabase indexeddb &gt; hashchange history draganddrop websockets rgba hsla multiplebgs backgroundsize &gt; borderimage borderradius boxshadow textshadow opacity cssanimations csscolumns &gt; cssgradients cssreflections csstransforms csstransforms3d csstransitions &gt; fontface video audio localstorage sessionstorage webworkers applicationcache &gt; svg inlinesvg smil svgclippaths"&gt; I can imagine some of those class names clashing with your own. An "mzr-" prefix might be better.
Node.js server?
I addressed that. The debug tools come up short in this area. I did submit a patch to webkit inspector (which covers chrome dev tools) to fix the issue, which I also mentioned in the post.
How is this different from Selenium? What does it have to do with XHR? I couldn't figure it out...
Yeah, having wget in there was first a huge surprise, then resigned disappointment. I mean, how pointless is it to include it in the distro?
If you can make sense of it with no comments and two letter variable names, more power to you.
I was skeptical at first that it included a working c compiler [Oh how wrong I was.](http://imgur.com/Cmec1)
FWIW I didn't downvote you.. heck, I'll probably upvote you since this is oftentimes an actual issue.
Last time I checked, the readability of the code doesn't have anything to do with the licensing..?
Most of the function names are based off of x86 instruction set codes but I get your point
**~** #
Must we go deeper? 
&gt; This is beautiful, but is there a practical use for it yet? The author [lists](http://bellard.org/jslinux/tech.html) some on their website (at the bottom). &gt; I think this is an amazing way for Windows and Mac users to get used to SSH without actually having to have Linux first. I think you’re confusing SSH with a sh-like terminal. OS X has much of the software available to it that Linux has, including OpenSSH, “out of the box”. Windows can get much of that *nix awesomeness through software packages like [cygwin](http://www.cygwin.com/) or, if you just want SSH, [PuTTY](http://www.chiark.greenend.org.uk/~sgtatham/putty/). &gt; But the fact that there is only a "hello.c" file is disappointing. Anybody think it will be extended to a full-as-possible run of Linux? Give the author a break. A Linux kernel with a full GNU world amounts to hundreds of megabytes. Yeah it would still work but the bandwidth would be through the roof (not to mention “booting” the system would be drastically slower). The fact that you can compile `hello.c` at all shows how versatile this system already is. &gt; Perhaps with a mix of PHP, it can have a fully functional file read/write system. The filesystem is already fully read/write but it won’t save if you navigate away from the page and come back.
Orrr maybe it's using functionality not available in those browsers??
Open source does not mean free to use for any purpose or freely distributable. zip's argument was it wasn't open source. It is open source but parts have licensing restrictions.
&gt; is there a practical use for it yet To be fair, this is only the first version, and it was released just today.
&gt;I think you’re confusing SSH with a sh-like terminal. Yeah, I was using them synonymously. My mistake. &gt;OS X has much of the software available to it that Linux has, including OpenSSH, “out of the box”. I haven't used a Mac so I was just assuming it didn't have shell, as I know Windows doesn't. I figured it was something Linux-specific. &gt;Windows can get much of that *nix awesomeness through software packages like cygwin or, if you just want SSH, PuTTY. I've used PuTTY, which is how I'm - however minutely - familiar with SSH. I'll definitely look up cygwin, which lets me expand upon my initial comment: Will this JavaScript interface be expanded [as close as possible] to the level/ability of cygwin?
Understandable. I was also wondering if there would be a use for it in the future, or if it was just a random project someone felt like making for the fun of it.
&gt; Will this JavaScript interface be expanded [as close as possible] to the level/ability of cygwin? It can emulate an x86-based computer. I’d say it’s already there.
Probably a bit of both. For example, running old DOS games in an emulated PC could become just as convenient as flash games. 
Double WTF.
That's ok, my name is Jesus and if I ever need an operating system from scratch, I'll go to Fabrice Bellard.
~ # mount rootfs on / type rootfs (rw) /dev/root on / type ext2 (rw) proc on /proc type proc (rw) tmpfs on /tmp type tmpfs (rw) devpts on /dev/pts type devpts (rw) ~ # ls -a . .. .ash_history hello.c Just one file? I think not.
To me, the most natural way to add persistence would be the Local Storage capability of javascript, not some server backend.
O_O
when I saw "Fabrice Ballard" I knew it was legit. One of the many significantly talented programmers out there that aren't widely known.
That would be _great_ for new files. I was talking about editing files already on Windows, though - like PHP through a localhost, not an online server.
It won't let me type spaces. All I can do is ls, which just returns hello.c
ew. I would advocate to avoid having anyone run a server who can possibly avoid it. The security issues are far outside the scope of what the average person can understand.
Ah, that sounds like some kind of a bug, most likely a browser compatibility issue. I know I ran into a lot of problems with certain keys being hard to remap when I was writing a game in JS. I think I used Space without problems, but I was only targeting a very small set of browser versions.
Well, it's the latest version of Chrome. I'm guessing it's more of a keyboard issue than a browser issue, as I think it didn't work in Firefox either (not the first time I've had the problem with web software not acknowledging the spacebar). Maybe laptops have different key codes for space than desktops do.
It appears down ATM. I'm getting an error loading root.bin. Getting access forbidden :(
That would be a very strange laptop. ASCII 32 has been the space character for as long as ASCII has existed.
Yeah, the key code is 32. I don't understand why other web apps don't recognize it, then. :(
Yo dawg...
I understand. Still kinda lame.
you, my friend, have ideas. I like it.
Good job.
no demo, no 'what the heck is this' text, and no way to use without creating an account. Guess I won't be interested then.
 Array.prototype.slice.call( document.querySelectorAll('a.title') ).forEach( function (a) { window.open(a.href); } );
Obviously this is still in beta, and I was hoping some people would try it out. Obviously my decision of making the instructions page come after the registration was a mistake. In the near future I hope to make a working demo with onscreen event triggered instructions, which then leads to the 10 second registration.
&gt;developers are [...] building JavaScript dependent websites because, it's just two percent they can afford to lose. 2% is about 3 times as much as IE6's market share in Germany. Or about half of what it got worldwide. If you want to cut something, cut IE6 first. (And then IE7.)
part of the busybox suite
Actually you can even just do `Array.forEach(document.querySelectorAll('a.title'), function(a) {window.open(a.href)});` at least in Firefox. I don't know if it's standard or if it works in other browsers.
[relevant](http://xkcd.com/224/)
`Array.forEach` is `undefined` in Chrome (Edit: same with Opera). This works though: Array.prototype.forEach.call( document.querySelectorAll('a.title'), function (a) { window.open(link.href); } ); Edit2: Doesn't seem to work in Opera though. Weird. E.g. this: Array.prototype.forEach.call([1,2,3], function(a) {console.log(a)}); Doesn't print 1 2 3. It prints 1 2 3 1 2 3. o_O Edit3: My first version also doesn't work correctly in Opera. :/ Edit4: `javascript:s='';Array.prototype.forEach.call([1,2],function(a){s+=a});alert(s);void(0)` works in Opera. It appears to be a bug in Dragonfly.
First step, run it through a beautifier so you can see the structure more easily.
jQuery saves the day? javascript:$('a.title').each(function(){open(this.href)}) // or javascript:$('a.title').each(function(a,b){open(b.href)}) If you have any optimizations for e-peen purposes, be my guest.
My intention was to show how to write it with modern JavaScript (QSA + ES5's `forEach`), not how to do it with some library which happens to be loaded here.
Cache DOM queries, i.e. var $loading = $('#loading');
If I'm reading this correctly, you're using document ready twice. Remember that $(function() { /* stuff */ }); is just a shortcut for $(document).ready(function() { /* stuff */ }); There's no need to use both. [More info](http://api.jquery.com/ready/). Also, object properties are easier to read when they're not all on one line.
Do we need to go deeper? 
I see that; I also thought this was an e-peen war. Guess not. =[
**jQuery is not JavaScript.** If you want to learn JS, learn JS. Starting with jQuery is not going to make sense to you. You need to learn basic JS syntax first. There is too much here to start pointing things out to you.
I think what you're looking for is something like this: &lt;script type="text/javascript"&gt; $(function() { var tmp = $('ul[class*="droptrue"]'); for (var i=0; i&lt;tmp.length; i++) { tmp[i].sortable({ opacity: 0.9, cursor: 'move', distance: 0, axis: 'y', helper: 'original', forcePlaceholderSize: true, tolerance: 'pointer', zIndex: 5, //edit 2 containment: '#contentLeft'+i, placeholder: "listplaceholder", update : function (event, ui) { //edit 2-5 $("#loading").show(); var fullstartitem = ui.item.context.id; var startitem = (fullstartitem.substr(7)); var startitemvalue = ui.item.context.value; // edit 3 var order = $(this).sortable("serialize") + '&amp;listitem=' + startitem +'&amp;order=' + startitemvalue +'&amp;action=updateRecordsListings'+i; $.post("vote.php", order, function(theResponse) { $theresponse = (theResponse); // edit 4 $("ul.droptrue"+i).load(location.href+" ul.droptrue"+i+"&gt;*",""); //edit 5 $("#loading").hide(); }); } }); } }); &lt;/script&gt;
Learning by example works for some people. He's getting a lesson on how to write code that is readable, which is important for any language.
It's tough to analyze it without seing the context but let's see what we can do with what we have. * There is likely no reason to have 2 script tags. You can put all of your code in a single tag * $(document).ready(function(){/*code*/) is the same as $(function(){/*code*/}), so you definitely do not need to put one inside the other, and you can combine the contents of both instances into a single one ($(fn()) vs $(document).ready(fn()) is your choice) * spread the options like opacity, distance, etc.. on to different lines. It is much more readable, * You could cache the $ calls made over and over again by doing $loading = $('#loading') at the top and using $loading. This will reduce the time of looking up '#loading'. In this example I wouldn't expect to see a noticeable performance difference, but in other cases, it will yield better perf, so learn good habits. * I don't know what your format for fullstartitem is, but when I see data being scraped using substr, it sets off alarms for me. Why 7? could it change. It could be what you need to do, but there may be a better way to get the data you want than these string manipulations. * `$theresponse = (theresponse);` could just be `$theresponse = theresponsel` The parens here are superfluous * Why is $theresponse set? It's not read in your code, so it leads me to believe you are setting a global variable called $theresponse. That's another red flag. If you are using $theresponse somewhere else in your code, the callback to the $.post doesn't notify any code that $theresponse has changed, which means at any point $theresponse is the response of whatever callback happened to complete most recently. It's unlikely that's what you are intending, and if it is, there are better ways to handle the response data. * Finally there is a lot of duplication in the code. There are different strategies you could use to try to reduce it. For instance you could create a function that takes in the parts that change ('#contentLeft1/2', etc..) and calls the main sortable call, putting the variables in place of the literals that are different between both calls. Those are the main things I noticed. There are really 2 important things when programming (anything) * Does it work? * Is it maintainable? (assuming it's not one-time-use code) Restructuring without knowing why you are doing it can be really hard and ineffective. Try to live with your code and see where it becomes hardest to maintain, and try to solve those problems.
To clarify: jQuery is JavaScript, in so far that jQuery is written in JavaScript. jQuery is not all of JavaScript. There is much more to JavaScript than just jQuery. You need to know JavaScript in order to write JavaScript code using jQuery. It's ok to have started out with some jQuery first. It's pretty much unavoidable these days. In fact it may be a good thing since it demonstrates what can be done using JavaScript. However the next step is to learn JavaScript and DOM to see what jQuery is really doing, so you can leverage jQuery and JavaScript more effectively. zezek, If you take polyrhytmic's content in a hostile tone, don't. It can be frustrating to people who know JavaScript well when people conflate jQuery and JavaScript, but you are new to all of this. You are trying to code better, and my advice is to learn about the JavaScript language, and learn a bit about the DOM (Document Object Model) jQuery makes interacting with the DOM easier, but you will be able to use jQuery much better if you have an idea of what is going on behind the scenes.
offtopic, the cursor effects in the sidebars of that blog are awesome.
Agreed, something like nfs support would be cool. But it would need a network driver first.
The community should not be encouraging beginners to place curly braces on newlines. [The automatic insertion of semicolon is considered to be one of biggest design flaws in the language, as it can change the behavior of code.](http://bonsaiden.github.com/JavaScript-Garden/#core.semicolon) Edit: didn't mean to sound like a prick =]
Because w3schools is not a wiki and is so up-to-date you mean? And because wikipedia is a wiki and is so outdated you mean?
and PHP
We could use it to run old versions of IE that will fail miserably at rendering anything! 
Yeah- this is a pretty nice example. Thanks for taking a second to put it together. I tried to implement this and after tweaking a little while I found that the var tmp = $('ul[class*="droptrue"]'); needed to be adjusted somehow. 
**AMA Request!** Make it happen :D Never heard of this guy but I thank you for pointing out that there are super-intelligent aliens among us.
Those lines that start with "//" don't actually do anything and can be safely removed or shortened to "//code". All that dead space at the beginning of lines is also just wasted and should probably be trimmed up. Finally, few people know that the "var" keyword is actually a relic from the early days of JScript and when left off your code will not only still work, it will be faster. Plus, remove the optional ";" at the end of lines. After that this code should be pretty top notch.
Maybe a little basic JS first, but really that is just silly. It isn't like jQuery magically writes your javascript for you, you still have to fill in all your functions with actual code. That's another thing, jQuery very clearly teaches concepts that are probably new to a lot of programmers like the idea of defining callbacks inline, closures, etc. 
Thx for posting, just what I needed!
Thanks again for all your comments. They were very helpful. I ended up with something like this in the end: $(function () { $loading = $('#loading') $('ul.droptrue1').sortable({ opacity: 0.9, cursor: 'move', distance: 0, axis: 'y', helper: 'original', forcePlaceholderSize: true, tolerance: 'pointer', zIndex: 5, containment: '#contentLeft1', placeholder: "listplaceholder", update: function (event, ui) { $loading.show(); var fullstartitem = ui.item.context.id; var startitem = (fullstartitem.substr(7)); var startitemvalue = ui.item.context.value; var order = $(this).sortable("serialize") + '&amp;listitem=' + startitem + '&amp;order=' + startitemvalue + '&amp;action=updateRecordsListings1'; $.post("vote.php", order, function (theresponse1) { $theresponse = theresponse1; $("ul.droptrue1").load(location.href + " ul.droptrue1&gt;*", ""); $loading.hide(); }); } }); }); $(function () { $('ul.droptrue2').sortable({ opacity: 0.9, cursor: 'move', distance: 0, axis: 'y', helper: 'original', forcePlaceholderSize: true, tolerance: 'pointer', zIndex: 5, containment: '#contentLeft2', placeholder: "listplaceholder", update: function (event, ui) { $loading.show(); var fullstartitem = ui.item.context.id; var startitem = (fullstartitem.substr(7)); var startitemvalue = ui.item.context.value; var order = $(this).sortable("serialize") + '&amp;listitem=' + startitem + '&amp;order=' + startitemvalue + '&amp;action=updateRecordsListings2'; $.post("vote.php", order, function (theresponse2) { $theresponse = theresponse2; $("ul.droptrue2").load(location.href + " ul.droptrue2&gt;*", ""); $loading.hide(); }); } }); }); You can see it all in action here: http://waterbees.com/piano.php 
&gt; "As you probably know, generating files is not possible with JavaScript alone" It's false, at least with chrome 9+, you can use [FileWriter API](http://www.w3.org/TR/2011/WD-file-writer-api-20110419) or [createObjectURL](http://www.w3.org/TR/FileAPI/#dfn-createObjectURL) method from File API.
Some remarks : *2 will never improve JavaScript performance since it introduces one more function call *4 will help to save RAM. I doubt that code speed will be improved too... (JavaScript performance =/= Network performance) *5 generally, removing all non-required code is a good advice... *9 jQuery helps to abtract from browser differences, it does not help to improve performances (e.g. http://jsperf.com/dojo-vs-jquery-getelementbyid/13) *10 will not improve JavaScript performance *24 &amp; 3 are identical
 javascript:$('.arrow.up').click(); I shall be there to counter your dastardly plan! You will NEVER succeed!
[object Object]
I'm so tired of the word "native"
Don't use need to use the mod_hash in some way? I tried to write something like this a while back to do my part to nuke pun threads but failed miserably. Granted, I'm basically trying to relearn javascript every time I use it so there's that...
or rather: javascript:var x=$(".md p:nth-child(2)", $("form.usertext")).html("javascript:$('.arrow.up').click();");
No... I never said either of those things. You just have to be *aware* that it is a wiki. As someone who makes regular contributions to MDN I know first hand how it can sometimes be largely out of date.
Anyone who's seen this care to summarise the salient points? It's excruciatingly slow...
Why? I understand some companies \*cough\**Microsoft*\*cough\* are using it as marketing jargon but in the context of this video it's a perfectly technical term used in the proper place.
Reddit has algorithms to handle mass down/upvote scripts, usually it provides the opposite vote automatically.
void() captures returns. javascript:void(...)
have you tried looking at the dev console (chrome dev tools or firebug) to see if any script errors are being reported?
Yes, I have the Web Developer Toolbar and Firebug and it doesn't report any errors, in both situations. :(
IE's been able to do this since forever now (since IE 6, at minimum), albeit leveraging ActiveX to invoke the [FSO API](http://msdn.microsoft.com/en-us/library/2z9ffy99(v=vs.85\).aspx#Y700). Perhaps the author should have qualified that statement more.
Nothing to see here, all it does is submit the data to the server, which then constructs the file to be downloaded and sends the appropriate headers. You don't need jQuery or even JavaScript to accomplish this.
Without watching (it's &gt;1 hr.), how does this relate to JavaScript? I can't see how it could be anything but tangentially related...
I'm really excited about the new features in the upcoming version of Dev Tools.
Here's a different rule that I think is better: don't put "return" on a line by itself. Religious ideas about the correct way to format code are probably more dangerous to the development of a programmer than the frustration of learning the quirks of Javascript's grammar. 
&gt;JavaScript running on the server - imagine that! ?? Did this for years as "JScript" under ASP, even without runat.
&gt;As you probably know, generating files is not possible with JavaScript alone. *Different solutions exist (some of them even relying on Flash) but using a generic PHP script on the backend provides better control and ease of use (not to mention that it works in every major browser out there).* 
Cross browser support was the gist of the paragraph you're quoting from.
That's like when I was looking for a solution of converting simple html to a doc file 99% of the "solutions" out there suggested serving the header mime-type as a word doc and changing the extension to doc. That's not a word doc, it's just abusing the fact that Word will try and render standard HTML (poorly)
Seems a bit dependency heavy vs choosing an appropriately kerned font. Kern.js depends on Lettering.js which in turn depends on JQuery.
But actually I don't know any with full interactivity (hover, clicks, color change). That's why I created this one:).
The Dev Tools cheatsheet revealed some great features, even for a very seasoned user. https://github.com/borismus/DevTools-Lab/raw/master/cheatsheet/chromedev-cheatsheet.png * New Style Rules (selector[s]) from the Styles gear-menu. * Free form CSS / JS editing. * Breakpoint variable inspection (via hover).
I'm pretty well versed in JavaScript but not in JQuery.. looking at this gave me a moment of WTF until I saw the $(). This certainly looks terribly confusing for something that's coming from a second week JS programmer.. lots of syntax in this sample that seems kind of complicated to keep straight. I'd second the suggestion to pick up some basic non-JQuery JS too, it would make this much easier to grok. 
&gt;Congrats &gt;And welcome to Reddit! Thank you!
heh, just got Node.js running in Drupal 6. Pretty cool, replies to your comments pop right up as soon as they're posted. I would think Reddit is working on rewriting their site using it right now, it'd be perfect for them.
http://raphaeljs.com/
When a site becomes unusable because it takes 250 milleseconds to scroll a few lines of text, you'll know which library to blame.
Seems like it's working now? 
It's bytecode for x86, just like the other binaries, just that this bytecode causes the interpreter to generate moar bytecode. :P
Eh, personally Iike pure JavaScript better, since it can be run in a browser's URL bar or JS console. It doesn't need jQuery, which makes it portable and adaptable for any other site I decide (or you decide) use it for. That only works because jQuery is included here.
It's specifically meant for Reddit, right? And Reddit includes jQuery, and it's there as a global object. What I posted works fine in the URL bar or in the console.
I've strived to make it as adaptable as possible, so jQuery is not an option, especially for forum sites which have no use for jQuery and will not include it. For example, if you changed it to select all new posts (ex: ... class.indexOf("new") ... for a forum) then you could do that. The point is that jQuery isn't a universal thing because not everywhere needs JavaScript or jQuery. Edit: grammar.
&gt;Another phenomenon that Node.js will enable is peer-to-peer systems. Opera Unite already does that already, and server side JS too (though it does server side JS in a somewhat different way) &gt;JavaScript running on the server - imagine that! Also, not new. Not that Node.js isn't good...it is. But the author of this peice seems to think that these are innovations by Node.js, which they are not, and have been done before.
Fair enough. Might I suggest something like `.className.split(/\s+/).indexOf('new')` to check for a class name? It's certainly more robust than searching in a string. (Using `\b` won't cut it, sadly.) Of course, using QSA (and Array#forEach) is the better approach.
Suggest anything you want, I'll be glad to take any suggestions. When I get on my computer (mobile right now) I'll take all the suggestions in, run some benchmarks, research, all that fun stuff. I might even compare jQuery as well.
&gt;Python already does everything that Node.js does &gt;Ruby already does everything that Node.js does &gt; Other languages have been doing what Node.js is doing for centuries &gt;Node.js is a fad and will never catch on &gt;You can do way more with other languages, more efficiently and with better results &gt;The developers are just front end developers that moved to server side and don't really know what they're doing. There, the same bullshit in every Node.js thread is out of the way, hopefully you fuckers talk about something else for once.
Yes, Reddit *should* completely rewrite their site around a relatively untested technology. That sounds like a wonderful idea.
&gt; I think one of these will be a rich GUI library to rival the offerings from Adobe. It will be possible to build extremely flexible and lightweight client apps with rich user interfaces very soon. Web forms will soon seem clunky, because we can soon have web applications without web forms. Can anyone explain what he means? My only exposure to Node.js has been a couple of videos, but my understanding was it was a server side technology. Is he trying to make the distinction between standard web forms and AJAX? If so, his excitement over the death of web forms is a couple of years late.
Your code was the fastest by about 33% more than my original method. +1
A powerful event model, strong encapsulation, true composability, a simple, standardised and well-defined grammar and semantics with few edge cases that can be compiled with relative ease. Python has none of these. Ruby has none of these. You have absolutely no idea what you're talking about. Except the fad thing. Node.js is a fad, much like Ruby and Python were not all that long ago (and if you ask anyone over 30, they still are).
What exactly do you mean by "got Node.js running in (a PHP CMS)"?
Yeah this was a bizarre, nonsensical departure in an otherwise good post. Maybe he's thinking some kind of rival to Flex or Silverlight will happen based on node which will rival *web apps* in general? Or maybe he's talking about form submissions going away and being replaced by lots of Ajax calls to node-based servers? I dunno, man.
I think you forgot to read the last line before you replied.
Egg on face.
Going by my knee-jerk response below (if it's not downvoted into oblivion yet), your post just back-fired.
I'm using it to instantly show private messages, etc from the CMS.
actually using it to serve messages and comment replies would probably solve their server problems.
Serving content is not a problem for Reddit - the majority of their server bandwidth is hogged by comment voting and updating things that can't be cached like mail.
I've been looking for something like this for a while actually, and yours seems to be the best of the lot so far (other than the US map missing the state of Michigan). 
I remember them saying it's caused by the comments pages, but maybe that's changed.
It may well be, but it won't be the web application layer that'll be causing problems, it'll be the DB storage. Node isn't going to help much with that.
&gt; Lets assume that the developer is competent enough to know not to instantiate multiple objects of our singleton class. So what's the point? Singletons are enough of an abomination as it is, yet here's one with even less purpose.
Yeah, raphael.js is a great tool, but it misses one important feature: groups (g tag in SVG and group tag in VML). Also my code for vector painting is really small, less then 200 strings, because I need only limited set of features. And another one reason is that it's hardly possible to make optimizations in external library, especially if you want to be up to date with it. 
Nice code! I was hoping that they'd use the vectors to animate zooming though. I can appreciate the tech but from a user's perspective what I see here isn't better than bitmaps.
I went to this thinking it was some kind of jQuery plugin. I think you should make this into a userscript that works like [launchy](http://www.launchy.net/). That would be useful!
Sorry for Michigan. It's on its place now.
&gt;my understanding was [node] was a server side technology Basically, Node is used to write stand-alone applications. You can write an HTTP server with it, but you also can write a chat server (or any kind of server) or command line applications with it. If there were some nice GUI library, you could also write some "regular" applications with it. Like say... an email client, a drawing application, a text editor, or whatever. Appcelerator and the like are kinda like that. You can use HTML/CSS for the UI and JS for the logic (it's Webkit, basically).
[Check out this](http://acko.net/blog/on-termkit)
The real winner with node is that you can finally write in modern javascript, for a single interpreter, without having to worry about accommodating 10 year old browser engines or going way out of your way for people that really ought to stop using there old busted software
I've thought about creating a git based snippet library which has: - version ccontrol - search by tag - select, minify and download as a single "utilities.js", with simple documentation included as comments you could take out in production.. Any interest?
Aw yeah! Copied this from some website: function computeTotalDistance(result) { var total = 0; var myroute = result.routes[0]; for (i = 0; i &lt; myroute.legs.length; i++) { total += myroute.legs[i].distance.value; } And it works!
Maybe add to your search queries: intitle:"Javascript"
And add: -noscript
As I can't post comments in your blog, here's my response: This is pretty cool, but I'm not really getting it: Why do you use the @-symbol in the condition (in the get function) on the `instance` variable, but not in the rest of the function? 
True, but if you already use jQuery, Lettering.js isn't exactly heavy, just splits strings into spans.
Really this is obviously just for use on headers, nobody is going to fine tune pages of text. Saying that, I did a project which split thousands of words into individual character spans, there was no slowdown, even on a relatively low powered smartphone.
After seeing Paul's function, I made a small object called Anim to control the animations in my 3D engine. I've now added the cancelRequestAnimationFrame. The Anim object can be found [In my SVN repository](http://svn.mariusgundersen.net/Origami3D/trunk/util/Anim.js). Here is an example of how to use it: doAnimate = function(deltaTime){ console.log("miliseconds since last frame: "+deltaTime); //deltaTime can be used to move objects with constant speed independently of the framerate }; document.body.addEventListener("click", function(){ if(Anim.running){ Anim.stopAnimation(); }else{ //The fps is only used by setTimeout Anim.startAnimation(doAnimate, 30); } }, false);
What platform do you work on? Supposing windows, probably [fiddler2](http://www.fiddler2.com/) is your simplest choice. Ask for a url such as http://www.example.com/your_file.js and use fiddler to replace what the legitimate site would respond with your own script. Or, if you're more comfortable, just install a web server. On Debian or Ubuntu it's just one line away: sudo apt-get install apache2 "local resource" are files on your disk. Files served from your local machine are regular web resources. 
I maintain a [JavaScript related wiki](https://github.com/bebraw/jswiki/wiki) that works more like an index for libs and such. Ideally someone would implement a proper package index containing that info... That probably won't help you to find snippets or anything. It should help with the idea department. :) If you want, feel free to start a snippet page or something.
On windows - try XAMPP, WAMP or if you just want apache - install apache2!
[The homepage of XAMPP](http://www.apachefriends.org/en/xampp-windows.html) states "XAMPP is configured is to be as open as possible and to allow the web developer anything he/she wants. For development environments this is great but in a production environment it could be fatal". I am not sure what is the difference between development environment and production environment. I suppose production environment is where some special network setup is done to make some files accessible to the world, and development environment is where no special setup is done? If a Apache-newbie just installs XAMPP on his Windows laptop and serve js files, would there be any gotcha related to security, like some other stuff getting world access that he did not expect?
http://smallsrv.com/ http://www.ritlabs.com/en/products/tinyweb/ even smaller
Since I am already using Dropbox, I figured I should test if Dropbox's Public folder feature can be used to solve this problem. Turns out it works. 1. I moved the javascript file into my Dropbox Public folder, and copied its public link. (To copy its public link, right click on the file, click on "Dropbox" &gt; "Copy Public Link" item.) 2. The bookmarklet code should be javascript:(function(){document.body.appendChild(document.createElement('script')).src='blahblah.js'})() except blahblah.js is replaced with the public link. 3. When I edit and save my javascript file, the copy on the Dropbox server changes, and the bookmarklet above loads the new version.
I feel your pain ... I try to stay away from google when snippet searching. I have this bookmarked: http://www.appsheriff.com/web-apps/script/15-unforgettable-websites-to-find-code-snippets-with-ease/ or http://tinyurl.com/yh6ymd8 and haven't tried many of them in ages as StackOverflow seems to work best for my purposes.
I use to set up XAMPP, for learning HTML/JS because it is great, and works well. I think it means that you don't want that facing "live", because that means that there could be exploits etc - tldr: great for development, don't use it for production.
As an argument for CoffeeScript versus Javascript this is a straw man. If we have to speak in patterns then I would suggest one google for "module pattern in javascript" if one thinks one wants a singleton. There is no reason to think you need all of that ugly "I wish this Java" cruft. The reason we have these things called patterns is because not every programming language solves every problem with a language feature. Javascript is a tiny language with the right set of features and semantics to make most "patterns" trivial. Yes, you can do this thing that acts like a class, but you don't have to and you shouldn't unless a class is really the best solution to the problem. First class functions and lexical scope are very powerful and just as clear and shouldn't be eschewed for the sake of making Javascript behave like other "object oriented" languages.
stumbled upon this intresting thread on stackoverflow while looking for a solution to the problem of calling a constructor function with an arguments array. The best answer is Matthew Crumley's. The key concept here (as already explained by Stoyan Stefanov in his "Object-Oriented JavaScript" book) is to keep in mind that whenever you call a constructor function (new F()) a new blank Object is created, and used as 'this' inside the function body; eventually the newly created object gets all the constructor's (F) prototype properties, referenced in the "secret" __proto__ property, which in turn is just another Object instance. It's always objects in the end, baby! ;) The code in this "newApply" pattern just mimicks this behaviour. A blog post based on the SO thread,which extends it further: http://tobyho.com/Javascript_Constructors_and_Prototypes (jump to section "The new method") An older blog post discussing the same argument: http://www.dhtmlkitchen.com/?tq=Design%20Patterns
uber-cool!
please explain better what you mean about the use of "var"... omitting the var keyword will of course make your code still work (to some extent), but it will create a global variable, not a locally scoped one, thus causing some problems. About not using it and having faster code , I disagree: you are creating global variables, so everytime you're going to use them the lookup chain is longer, compared to local ones. You can avoid using multiple vars and group them in a single statement like this: var one, // declaration, value is undefined two = 2, // declaration and initialization three = '3'; // end of declarations Also, your advice of removing semicolons is not a good one about code shortening (compared to DRY and refactoring), and in some cases can introduce bugs due to the language's Automatic Semicolon Insertion: http://inimino.org/~inimino/blog/javascript_semicolons
http://docs.python.org/library/simplehttpserver.html#module-SimpleHTTPServer If you got Python installed you can run it from any directory: `python -m SimpleHTTPServer 8000` That directory will be then used as base directory. That's it. Can't get any easier than that.
I was surprised to see nobody mentioned Object.create() so I added a response to the thread. Basically, you can create an instance using `Object.create(Constructor.prototype)` (which doesn't run the constructor) and then you can just `Constructor.apply(instance, argsArray)`.
Seeing as how Object.create() is in 1.8.5, it's not a realistic solution.
It's plenty useful if you're using node or es5-shim.
I don't think i'll have an understanding of javascript like I do java or Perl. Just when I start getting the hang of something new, I see something that completely confuses me :( BRAIN, Y U NO UNDERSTAND JS
I agree - haven't heard of XSLT in some time, especially on the client side! When I worked at HotBot (OMFG I'm OLD!) some 12 years ago, I implented a feature that served XML results to IE 5 and 6 with a referenced (and presumably, cached) XSLT to transform results into XML. All of that seem ancient now. JSON is the way to go. 
True. Although that question is 2 years old =P
what benchmarking tests are you using?
Javascript is not harder to maintain than other languages, it just doesn't come with the arbitrary delineations that some other platforms do. I'd prefer no help at all to awful rules like 1 file = 1 public class. I feel this way about virtually every missing feature in Javascript, "at least they didn't do something awful."