Why surprising? YUI is really good. I don't know if it's better, but I've been working with ExtJS for about a year and it's got a nice grid control: http://extjs.com/deploy/dev/examples/grid/paging.html
That actually looks real nice if you don't mind paying for it. With all the jQuery love on Reddit, it's been a while since I looked at what the other frameworks are doing.
jQuery is a great library for adding little ajax-y touches to something but I'd never want to develop an entire application with it. I'm sure the YUI thing has something similar but the grid you're seeing in that example is actually attached to a Store, which is a really simple database rather than a "dumb" array of objects as you might expect. Because of this you can listen to events on the store- and in fact if you update a record in the store or load entirely new data into it, the grid will update itself automatically. Stores also know how to update themselves so you can have a dozen grids, comboboxes, etc that all reflect the state of a certain store and then update them all by firing a single store.reload(); or store.sort({field: 'username' direction: 'DESC'}); or whatever. (Sorting can either be done locally or on the server) Tip of the iceberg...
I haven't played with Ext recently but the last time I did (about a year ago) their collection performance on large data sets wasn't that great. Others will know better than I.
As most of the comments say - this guy would like MooTools
I disagree. To me the article makes very few clear arguments on why prototype is better. Also the scope issue with 'this' is due to the way javascript handles closures. If you don't understand the underlying ideas of closures than jQuery's design may seem poorly thought through.
Agreed. Also the author imply that Prototype often seem inferior because people don't know how to use it efficiently. I could use the very same argument against the author of this post and jQuery. I used both extensively and there's nothing he mentioned which made my say "oh he's right, I miss that Prototype feature". I also find working with events *a lot* more easier and concise with jQuery. **Edit:** That's exactly what I was saying: &gt; If jQuery’s each were properly designed, one could write the basic iteration idiom this way: &gt; &gt; // jQuery (with hypothetical fixed 'each' method) $.each(collection, function(it) { it.whatever(); }); It actually **does** works like this.. $.each({a:'A', b:'B'}, function(key, val) { console.log('%s =&gt; %s', key, val); }); 
Riiiiight. So I'm going to let some Javascript do my SQL queries, completely exposing my table schemas, my database platform of choice, and not expect to not get hacked overnight. Sorry, count me out. 
How can it deal with XML namespaces?
Being from Thomas Fuchs, I can only assume that it's somewhat useful, but I haven't experienced the need to do this yet.. Can someone explain me in which situations exactly this is useful ? 
I think this is more useful for server side javascript.
I far as I know, jQuery doesn't support namespaces. If two elements have different namespaces (e.g. xm:Tutorial and xm2:Tutorial), the selector for "Tutorial" will return both. [Here's](http://dev.jquery.com/ticket/155) the most recent ticket I found on jQuery's site about the feature.
Yeah, the drawback there is that there's no Apache module for server side Javascript yet that I'm aware of. There's Whitebeam, but it does everything in XML, which is rather bizarre. Mozilla has made a fascinating Javascript runtime called SpiderMonkey, but so far no one has gotten this rewritten into an Apache module, so one ends up having to run it in FastCGI mode, which is slower than running inside an Apache module once your connection count gets high.
[NAPOLEON] Sweet.
Thanks, the ticket mention this kind of API: &gt; $(xml).find('ns:elementName').text() which isn't that reliable. It's actually how you deal with namespaces using MSIE.
Don't mean to be rude, but Firebug exists for quite a while now..
There is also Jaxer http://www.aptana.com/jaxer.
However, this is a nice trick. Since I haven't read firebug docs, I didn't know about it. Try to RTFA next time.
I did read the article. But I presumed that anyone using Firebug and debugging JavaScript with it would already know about those features (not tricks), since they exist for a long time. And are mentioned in the [docs](http://getfirebug.com/docs.html).
Like I mentioned, I didn't read its' docs, but I appreciated the info.
This is not a very good post.
Decent solution to the problem, but flash is unfortunately the only good solution if you want them to be able to upload multiple files at the same time. Well, Java applets, too, but Flash is the lesser of two evils there.
Well now that Firebug offers *Firebug Lite*, a debugger usable in IE Opera etc... with support of most of the basics FB functions MooBugger isn't really that helpful.
Great release, I've already made much use out of live().
Very cute site, I'm looking for a good way to replace simple Flash sequences with JS and this might be an interesting option for that, I'll take it for a spin later :)
It looks very cool - I believe it would be of use for very lightweight animation... I've been reading thru the features and I'm pretty sure jQuery and Mootools (possibly prototype too, but I cant say) all include matching features - but like I said, this would be perfect for a very lightweight frontpage/404/coming soon page.
Very cool, 3.7KB
what is this, a browser extension? Doesn't that make it something other than javascript?
No, it's just a collection of javascript files to make using javascript 3D easier. edit: nevermind, I don't know. Their downloads seem to be JS-only with a few shader fragments, but their demos reference some FF3.x RC addon. Seriously, developers - if people are going to install something for web 3D besides Flash, it's going to be Unity. It's certainly not going to be some Javascript nonsense.
It looks like a JS library to interact with a browser 3d extension that is proprietary to firefox. what is this 1993?
No. Browsers like [opera](http://my.opera.com/timjoh/blog/2007/11/13/taking-the-canvas-to-another-dimension) and [firefox](http://ajaxian.com/archives/firefox-canvas-3d-extension-available) are like implementing this 3D Canvas, but I think they have it in some experimental phase. That's why you need a Firefox extension for using 3D canvas (and you need a special build for opera). I think that firefox canvas 3D makes use of OpenGL whereas opera's 3D canvas makes use of OpenGL OR direct3D. Anyway I'm not sure, but I think the links I sent might me enough to be well informed. I think this library is a good idea. They're kind of *thinking ahead*
1.2.6? psssssh.
Am I the only one having gag reflexes while looking at *Microsoft ASP.NET Ajax 3.5*'s global namespaces ?
If you only use one JS library then this is not an issue. If you are a lazy web developer who includes any old script library so long as it reduces your workload then you should read it.
this is the power of the Open Software.
Any word of a standalone package?
Didn't anyone tell them about the [jquery's easter eggs](http://github.com/nakajima/jquery-easter-eggs/tree/master)? 8o 
[You're 3 days late](http://www.reddit.com/r/javascript/comments/7r6hl/the_white_house_is_using_jquery/).. 
ohh, thats great! we dont want .gov showing up in the search results, problem solved.
I don't get it.
Well written explanation. To my limited knowledge of NN, there was an aura of awesomeness surrounding the effectiveness of the script (despite the CAPTCHAs being weak).
Crap, if this gets the deserved attention, megaupload is going to change their captcha system. To upvote or not to upvote?
it's John Resig... too late :( upvoted for amazingness
2.5 times faster in many cases! 6x faster HTML injection is fantastic. This makes Jquery near tolerable for the poor old IE6 users.
I had been thinking about something like this for a while. I finally started to look around for something like it, and someone else had already written it. The Internet is highly convenient. :-) I may try to just add this code to the wiki software I use too.
via: http://www.blueskyonmars.com/2009/01/27/wsgi-goodness-spreading-to-other-languages/
via: http://www.jroller.com/shareme/entry/javadoc_for_javascript
I did the same thing with Mootools. I used layered transparent pngs of each of the provinces. Then I put a in image map over the div and had the pngs fade in when the corresponding image map area were mouseovered. This smoked the client computer an since I've been looking for a way to make it more efficient. Any ideas?
We tried switching, but selector behavior seems to be slightly different. Under some circumstances we have yet to determine, the selector selects N components (as it used to do, as revealed with length), but applies a change to only the first component. So, moving to 1.3.1 was not a simple operation for us. I'm also skeptical of perf measurements -- if selectors operate on fewer items, of course they'll be faster. YMMV. 
Can you narrow down the bug at all? It would really help us to fix it. "I'm also skeptical of perf measurements -- if selectors operate on fewer items, of course they'll be faster." Heh, that's not true at all. All of the performance tests verified integrity as well - it sounds like you may have a very specific bug here.
Great to hear from you. We're trying to narrow it down. It's hard to characterize. 
You know, it's funny, I can read an article with an interesting title, realize there's nothing for content in it, and think "Hm, I'll bet this was a gst submission." I haven't been wrong yet.
I'd like to see what the average number of comments or upvotes on his submissions are. I'm guessing it's a bit low...
Yes, but mostly because it's default in the current version of Rails. I'm not a huge Javascript guy and the time I can save on Ajax stuff especially by using the built-in Rails prototype helpers means a great deal to me. Apparently Rails 3.0 is going to be Javascript-framework agnostic, and I definitely like what I've seen in Mootools and jQuery specifically, but up until now Prototype has more than been adequate.
Yes, alot of systems i work on use scriptaculous which uses prototype. Is there a reason not to?
Not really, it just seems like there is a critical mass moving toward adopting jQuery as a "standard" framework. I'm curious to see who's still using Prototype and why.
Does anyone actually vote up vote-up-ifs any more? Unfortunately yes. If this gets to the front page will you really get a sense of self-satisfaction? Knowing you used an easy way to game the system which is slowly destroying Reddit? Fuck off back to Digg and stop trying to force the rest of us to join you there by destroying anything better. Please don't forget to downvote this article to help save Reddit.
Please don't reply to vote-up-ifs unless it is to point out the rediquette rules or the lameness of vote-up-ifs. Also I'd recommend you add a request at the end of your comment (if you must comment) to downvote the article. Thanks
Please don't reply to vote-up-ifs unless it is to point out the rediquette rules or the lameness of vote-up-ifs. Also I'd recommend you add a request at the end of your comment (if you must comment) to downvote the article. Thanks
Sometimes I just try to distract by posting a lolcat or equivalent bollocks, sometimes I go on a rant about the lameness of vote-up-ifs, pointing out the rules in www.reddit.com/help/voting and www.reddit.com/help/reddiquette. But, what you really shouldn't do is feed the vote-up-iffers by responding to their question as if it is worthy of a response while those 3 little words are in the title. If the subject really grabs your attention maybe post it yourself without the VUI?
Dude, calm down. I'm just curious about how strong the Prototype community is these days. I don't care if this makes the front page and find it unlikely that it will.
Also, if I was just trying to get upvotes I would have said "Vote up if you think jQuery is awesome!!!" since 95% of the posts are about jQuery.
Damn, doesn't work in FF3...
BTW it is a &lt;canvas&gt; drawing of HAL-9000. sorry it doesn't work in ff3, but I couldn't test it and don't know much canvas stuff yet. EDIT: sorry no opera either...
whoa.
Writing tetris in JS seems like a huge waste of time (if you cannot play the music, it ain't tetris). And the Ruby folks seem to be doing nothing but learning lessons these days (hint: last lesson was "rails does not scale"). Wake me up when they've learned the lesson that Python is where the action is. 
OMG, we cannot map our class-based thinking to JS using jQuery! Sometimes I wonder, is the prototype based OO in JS that bad or are people just too used to class based OO that they absolutely need to port it to JS?
I don't really think of this as a reason not to use jQuery, but it is a reason not to solely rely on jQuery. http://ejohn.org/blog/simple-javascript-inheritance/ works well for inheritance. I have successfully used it in an XML viewer at http://jsgui.com/xml-viewer/. It is also worth looking at Douglas Crockford's work on JS inheritance.
LOL, brilliant. Although I think you forgot the obligatory link to the language shootout...
JQuery is very fast if you are familiar with it and can slow you down if you are not compare to pure JavaScript programing. I prefer to use normal javascript programing for small projects and even for big ones like my Diploma work, because one more think about JQuery is that they don't have good documentation. So if you want to use it you have to get use to lack of help. Anyway, when I have time I will start using it, because I know people that make great stuff with it:)
&gt; * When you add or remove a DOM node. &gt; * When you apply a style dynamically (such as element.style.color="red"). &gt; * When you retrieve a measurement that must be calculated, such as accessing offsetWidth, clientHeight, or any computed CSS value (via getComputedStyle()... Opera will not cause a reflow in the 2nd and 3rd cases. Also, Opera will also not cause a reflow when changing any background properties; not sure about other browsers on this.
I make the same remarks in the comments to the original article.
I hate it because the cool concepts in JS were invented by other languages?! I mean, really? What is the problem that Self has invented prototyping and the syntax is copied from C? I bet the language this guy likes is alos borrowing a lot of concepts invented elsewhere like e.g. lexical scoping. And the libs itself have little to do with JS, true, but at least in the case of jQuery they make working with the DOM a lot easier and since most JS-code is just for manipulating the DOM, that's a huge win. Finally performance and static typing: the performance is usually enough, even before TraceMonkey, SquirrelFish etc. for what JS is used for. Number crunching in the browser is not neccessary. It's good to see faster JS now, but it is not such a problem. And static typing doesn't help you at all if you don't do testing before pushing your software to clients. Blaming dynamic typing misses the point.
I used to not like it that much and it was a real struggle to get things to work. Now I have a pretty good understanding of the language and I like it a lot more. It is worth reading Douglas Crockford's JavaScript: The Good Parts that has details of the serious flaws in the language and the bits that work really well. For many jobs JS is the only tool available and I have not only learned to put up with the language but I now like it too.
hovers are best done as [sprites](http://www.alistapart.com/articles/sprites/) Merging images helps reduce total download times. each file requested by the browser needs to establish a connection, hence grouping images into one file removes the client-server handshake delay. Most of these hovers are small anyway.
Oh for the love of god why? Use CSS with background images so I can experience the effect without JavaScript. Browsers (at least Opera) are optimised to send images set by ':hover' pseudoclasses to the end of the load stack.
i really like the idea of this and i can see how it can be applied, but the syntax is a major setback. anyone knows an alternative with a better syntax? jquery has the most intuitive syntax i've ever come across
John Resig - the creator of JQuery explain some issues about DOM in different web browsers.
Yeah, my dorm is a mess too. I'm sorry, what was that? You said "DOM" and I graduated from college almost 20 years ago? No, I don't see how that's relevant.
What he's talking about is great, but he's such a nervous speaker...
He is a developer:) I suppose most of the developers do not have so good presentation skills. I think the great thing is that he creates, such an useful library, which can speed up and make our sites much more better. Don't you agree? 
I downloaded it, but I think "Web developer" is much more better than Firebug. And offers more stuff. try it. 
apparently the new version conflicts with Foxmarks add-on: http://code.google.com/p/fbug/issues/detail?id=1460
I use both, Web Developer works best for global and persistent changes but to analyze specific parts of the page Firebug suits me better.
Actually I don't have much experience with FireBug, but if I have an error in my JavaScript Web developer shows me where exactly is it. Anyway I am still learning, so I can not say, which is better. For now for me this is Web Developer.
50? this must be crap (unless these are "50 tools created using Javascript" instead of "50 Javascript tools")
I thought the whole point was to separate your javascript from the markup. I throw it all in the &lt;head&gt; when I use jquery. I didn't know people were surprised by this.
Again, I thought that was pretty obvious. 
No to rain on their parade, but honestly - the articles mentioned to be published sound like stuff we see posted publicly on the web every day of the week... *Articles for the first issue include:* *Unit testing your Javascript* *What’s new in jQuery 1.3* *The “object literal” pattern* *Functional programming with Javascript* 
No Rhino book (i.e. Flanagan's "JavaScript: The Definitive Guide")? Claims Crockford's book is "difficult to get through"? I wouldn't trust this list.
&gt; //As images are loaded ul width increases, //so we recalculate it each time var ulWidth = lastLi[0].offsetLeft + lastLi.outerWidth() + ulPadding; When will people realise they should set the width/height attribute of img elements? It makes the loading page move around less, and allows scripts to get to work right away without hacks like these. The resulting code with that fixed is simply as follows, and I fail to see why a JavaScript library is necessary for it: $(function(){ //Get our elements for faster access and set overlay width var div = $('div.sc_menu'), ul = $('ul.sc_menu'), // unordered list's left margin ulPadding = 15; //Get menu width var divWidth = div.width(); //Remove scrollbars div.css({overflow: 'hidden'}); //When user move mouse over menu div.mousemove(function(e){ var left = (e.pageX - div.offset().left) * (ulWidth-divWidth) / divWidth; div.scrollLeft(left); }); });
This is awesome, my users have been BEGGING me for a menu that's ugly and difficult to use, and this fits the bill perfectly!
Yeah, no kidding. I would actually enjoy a print magazine that covers these things, but as a PDF, why would you pay for it when sites like Ajaxian and other developer blogs write quality articles on the same subjects every day? I'll reserve final judgment until I see it, but right now I can't see the appeal.
I'm afraid I agree. I feel kind of guilty because I think it's nice that they're trying to earn an honest buck. But let's face it, PDFs suck. And a PDF about programming? Please. You can't even cut and paste correctly from a PDF half the time. I dunno, I'll take a look at the first issue, but...
Interesting article for those who are not familar with the functional programming style. Renaming *functions* as *subroutines* is unnecessary and potentially confusing, IMHO.
Umm... these performance numbers are horribly out of date (over 2 months, at this point). In fact, Sizzle is now over [two times](http://docs.jquery.com/Release:jQuery_1.3#Sizzle_Selector_Engine) faster than MooTools (as of jQuery 1.3). In fact, it looks like Sizzle is going to become another 15-25% faster in the release corresponding with jQuery 1.3.2. There's a [full thread](http://news.ycombinator.com/item?id=475205) discussing this over on Hacker News, where I address this point and more (concerning the integration).
So I forget everything I knew about functions. And it was a load off my mind. Then this article is trying to talk to me about functions but I don't know what the hell they are! 
The first link you provide doesn't work.
Misappropriate the term subroutine is unnecessary. Skimming the article, it seems like someone unfamiliar with functional programming and closures might find this useful. A summary for language geeks though: javascript has first class functions, closures (with lexical scope naturally), and runtime access to a String of the original text of a function's definition.
Fixed.
Finally. Bookmarked.
Could also use the [WTFramework bookmarklet](http://blog.olicio.us/2008/11/08/wtframework-bookmarklet/). Or save this &gt;javascript:(function(){el=document.getElementById("__wtframework");if(el){document.body.removeChild(el);return%20}var%20c=document.createElement("a");c.id="__wtframework";c.style.opacity="0.7";c.style.filter="alpha(opacity=70)";c.style.position="fixed";c.style.zIndex="9000";c.style.top="15px";c.style.right="20px";c.style.background="#000";c.style.styleFloat="right";c.style.padding="7px%2010px";c.style.color="#fff";c.style.border="solid%202px%20#fff";c.style.textDecoration="none";c.style.textAlign="left";c.style.font="12px%20Lucida%20Grande,Helvetica,Tahoma";c.style.MozBorderRadius="5px";c.style.WebkitBorderRadius="5px";c.style.WebkitBoxShadow="0px%200px%2020px%20#000";c.style.MozBoxShadow="0px%200px%2020px%20#000";c.href="javascript:void(0)";document.body.appendChild(c);c.onclick=function(){document.body.removeChild(c)};var%20fm="Bummer...%20Try%20checking%20the%20source%20code";try{fm=(MooTools?"MooTools%20("+MooTools.version+")":false)}catch(d){}try{fm=(YAHOO?"YUI%20("+YAHOO.util.Dom.VERSION+")":false)}catch(d){}try{fm="Prototype%20("+Prototype.Version+")"}catch(d){}try{fm+="%3Cbr/%3E%20Script.aculo.us%20("+Scriptaculous.Version+")"}catch(d){}try{fm=(jQuery?"jQuery%20("+jQuery.fn.jquery+")":false)}catch(d){}try{fm=(dojo?"Dojo%20Toolkit%20("+dojo.version+")":false)}catch(d){}try{fm=(MochiKit?"MochiKit%20("+MochiKit.MochiKit.VERSION+")":false)}catch(d){}try{fm=(base2?"Base2%20("+base2.version+")":false)}catch(d){}c.innerHTML=unescape(fm.toString())})();
&gt;I have become a firm believer that as a non-software company, it is your interest to leverage Microsoft-based development technologies as much as possible. The ability to quickly get things done in .NET and its surrounding technologies is unparalleled. That's debatable, to put it lightly...
That is a long ass article for something that also revolves around ColdFusion to boot. Form validation is simple. Add an onsubmit attribute to your &lt;form&gt; tag and have the value for it be something like "return validate();" where validate checks the fields in your form. Have the validate function return true if all fields are valid and false if any of the fields are invalid. Show messages, bold and red text...etc. to make emphasis on what the user did wrong. And always validate on the server side. Users can bypass client-side validation by simply turning javascript off and hitting submit.
" (Adobe is pretty good at breaking builds of older code with newer versions of Flex)" I'm aware that Redditors fucking hate Flash/Flex/etc. But let's get something straight: I know for absolute certain that I can publish Flash 6 content right now, and it'll work in the Flash 10 player. I'm also 99% certain I can do the same with Flash 2. No porting, no modifications -- publish it, and it'll play. I can't name a single platform that is that careful not to "break the build". ( Perhaps the poster was thinking of their beta releases? Does anyone hold a company accountable for changing their API between beta and release? ) 
You beat me to it...I prefer the bookmarklet.
duplicate of: http://www.reddit.com/r/programming/comments/7x1o2/mozilla_labs_launches_webbased_code_editor_named/
I think this is really really cool stuff. That said, I want to point out that the same things that Jakob Neilsen said in his "Flash: 99% Bad" post applies to this. I'm a Flash dev, so I'm not picking on Bespin -- I just hope that people will be a little more open-minded when it comes to Flash content... * "The "Back" button does not work." Which actually can and should be fixed. After opening a file from the Dashboard, navigating back to the Dashboard will present you with the initial screen -- not the last state you navigated from * "Link colors don't work." Which makes sense. This is an app. The Dashboard view has "links" to files for one to open, but in traditional apps, buttons don't change colors simply because the user clicked on one. * "The "Make text bigger/smaller" button does not work." Because the app uses Canvas, which doesn't treat the text therein the same as HTML text does. * "Flash reduces accessibility for users with disabilities." As does this, because it's built on Canvas. * "The "Find in page" feature does not work." And it doesn't work here, either. Again, Canvas. * "Third, many Flash designers introduce their own nonstandard GUI controls. How many scrollbar designs do we need?" The devs built the scrollbar they needed and wanted. It matches the design of the rest of the app. It has a new feature that may prove useful ( autohide/show ). EDIT: I didn't realize it was a dup -- sorry for the double-post. 
Ugh... so much work put into something that's not going to be used.
[YUI Get](http://developer.yahoo.com/yui/get/) It's really well documented and the comments discuss possible solutions for various browsers. 
So?
It seems very sluggish and I have a good rig.
I started writing a lengthy explanation as to why this is stupid, and ill just cut it to say : this is plain stupid. 
Hold on ... why don't you just transmit the data as XML? Isn't that the bloody freaking point of XML? Or (UH OH!) use JSON?
WHAT?!
I and others have been using this as a templating structure for FlyDOM and [SuperFlyDOM](http://plugins.jquery.com/project/SuperFlyDOM) jQuery plugins since at least early 2007. Talk about old news. JSONML has been way overthought, we have already created a much simpler way to approach this, and are using it. There seems to be a .NET &amp; ASP *(blech)* focus to JSONML, maybe that's where the problem started...
This makes no sense as presented by the blog author, it fact he seems to reverse the intention of the project. &gt;Now the JsonML project is letting developers write their JSON data packets using XML. As per the JsonML website: &gt; &gt;“The purpose of JsonML is to provide a compact format for transporting XML-based data via JSON”. Looking at that quote from the project website and reading it directly, the point is to losslessly move xml based data in to json so it can be easily worked with in javascript and then converted back out to xml.
Can you say circle without a jerk? 
That's what javascript frameworks are for. Encapsulating browser differences, until the manufacturers make up their mind and follow some standard. Use jQuery or something.
I remember running into this issue years ago, is it still one for IE7/8?
doesn't work in chrome :/ works in firefox though! http://pastebin.me/4998bef0c249b 
Yay my blog is there ! :)
Am I the only one annoyed that they misused the term "[lazy loading](http://en.wikipedia.org/wiki/Lazy_loading)"?
Looks great but I would need it to be localized. 
What a waste of time. As much as I love all these new emerging WEB 3.0 type shit, it really is a pointless effort. Who in their right mind would even think about coding online? Can't do Ctrl+Backspace, Ctrl+F, and I'm sure there are other missing functionalities Im comfortale using on my own box at home
Interesting, but I find it amusing that this got submitted to the javascript reddit when the article explicitly states this: &gt; This viral Twitter prank uses a pretty standard trick to get you to post something to Twitter, using no JavaScript and only a very little bit of CSS.
That's because gst is supposedly a bot. It probably submitted it based on a keyword or topical RSS feed.
The ctrl+f and ctrl+backspace are possible with javascript, but I agree, this seems more like a proof of concept than anything with actual benefit to the end user. There are some desktop applications that you shouldn't convert into web apps and text editors are one of them.
Oh wow, that explains a lot; thanks.
Another vote for the Good Parts.
No, I won't code "in the cloud" until they give me vi bindings, and performance matching my native applications... and bash... so yeah, I'm good for the moment... But as a proof of concept (like you were saying) it's pretty nifty. It really showcases how slow cairo can be though. (I'm a fan of cairo, but it needs some turbocharging...)
so you can now go to that other post and read 123 comments regarding what redditers thought about this article. relevant?
Fair enough.
Be sure to check out the embedded video of Crockford's presentation at Yahoo, even if you aren't interested in the book. It's interesting.
The use case in the article is not really convincing. Instead you can take the tag list, go through it, and create functions with those names. That'd be both more clear and compatible across browsers. It really has to be a case where you don't know the function name until call time. I am sure this is possible, but I cannot think of an example right now.
This is useful when you need to define lots of similar methods with similar names, or want to create "proxy" objects that sit between the caller and the real object. Apparently, I've heard it can also lead to some interesting security problems (via spoofing methods, exploiting side-effects, etc.), which is why browsers have been slow to adopt more dynamic features like these. --- Example 1: var handler = { __noSuchMethod__: function(name, args) { verb, object = name.split("_"); if (verb == "handle") { alert("Handling " + object); } else if (verb == "inspect") { alert("Inspecting " + object + ": " + uneval(this)); } } } (Note: as seen, another neat feature of Mozilla JavaScript is array unpacking) This is handy because you can set specific actions by simply implementing the functions in prototype children. Example: `&lt;a onclick="handler.handle_mylink()" /&gt;` --- Example 2: function Spy(target) { return { __noSuchMethod__: function(name, args) { alert("Hi, I'm calling " + name + " on " + target + " with args " + uneval(args)); target[name].call(target, args); } }; }
All good points, but as a commenter on the posting points out, what we really need is a clever, generic way to create an interface between JavaScript and system shared libraries. It's absurdly easy to call C code from most JavaScript engines and vice-versa. With a little automation, JavaScript could be a universal glue language.
It would be very nice if `__noSuchMethod__`, `__defineGetter__` &amp; `__defineSetter__` worked cross-browser. Even better would be if `Array[index]` translated to a getter/setter when defined (`.length` would need to be usefully maintained). Expected outcomes: * Bi-directional collection data-binding * lazy-loading "invisible" areas of large containers * Ability to create *safe* drop in replacements for built-ins like Array, Object, Date, etc - but with extra capabilities. Also, `.hasOwnProperty` could be complemented by `.hasOwnImplementation` to allow toolkit authors to check whether the function associated with a particular property is native or overridden (where allowed). 
I wouldn't call that polymorphism. What if you need access to the original method?
When Jaxxer came out, I jumped on the bandwagon and used it for a little while. Then I started to thinking, why the heck am I using javascript on the server side? For those who have a good grasp of server-side languages (python, ruby, ASP, PHP), why should we use server-side javascript? Is there any advantage when other server side languages are faster and more robust?
I think if you use a lot of javascript on the client side, js presents a lot of advantages to being used on the server side, such as being able to use the same validation code . Also, javascript can be very elegant as a language, and some people like programming in it. All things being the same, I'd like to use Javascript as a server side language if (like twoodfin says) it can be used to easily access C/C++/.NET libraries. Unfortunately, it seems that currently both SpiderMonkey and Rhino Javascript lags way behind even PHP in the [code shootout benchmarks](http://shootout.alioth.debian.org/).
Good question. If you need the original method, that is easy enough, you simply store the original method in a variable and then call it in the overload. var originalFunc = module.getImportantField; module.getImportantField = function(){ //access the field via the html text originalFunc(); }
&gt; The use case in the article is not really convincing. It's also not terribly convincing even without \_\_noSuchMethod\_\_. The whole point of a builder is to avoid having to handle [closing tags](http://pastie.org/392770). As he declares all the methods statically, the [maligned](http://yuiblog.com/blog/2006/04/11/with-statement-considered-harmful) *with* statement can be used to [sugar](http://pastie.org/392773) the code. This is probably the only use case for *with* (there's a discussion [here](http://hackety.org/2008/10/06/mixingOurWayOutOfInstanceEval.html) (and [here](http://redmine.ruby-lang.org/issues/show/615)) of the _whys and wherefores).
It just seems a lot easier (and less ugly) to use inheritance. It supports overloading so why not use that?
I was hoping for tips on living in libraries and under canvas
it is kind to animals and looks after bears.
Fuck me, does that recipe demo really have to show that black overlay with the loading gif every time i click something? And is this really a good example of what Ajax can do? It seems really unnecessary in this case.
I think I'll refuse your offer, but I definitely agree. Pretty lame.
Worst example ever..... /Comic Book Guy
a good material for people who haven't had a close look at jquery's functionality.
Wrap the whole thing up in Adobe AIR or [Titanium](http://titaniumapp.com/) and you've got a perfectly good offline editor too.
Downmodded for this: &gt; Dynamic programming languages execute at runtime; they are not compiled. LOL WUT?
Actually, this isn't about AJAX. There's no use of XMLHTTPRequest and there's no use of XML. The point of the demo is to show how the data driven app was written using only HTML and JavaScript -- no server side development, which was entirely generated and managed by X2O. Check out docs.x2oframework.com to get an idea of the details. Oh and obviously, I'm no designer. Hence the shitty web demo -- but again, it wasn't the point. 
The point I was trying to make is that when you think of JavaScript as functional and dynamic, you have a lot more options in your style of programming. Coming from a static language as I have, it is sometimes difficult to embrace the dynamic features of a language. This is an interesting discussion. I would love to move them to the blog comments.
Do as you wish with my comments, I don't mind.
A *long* time ago someone asked me how (in general) to do asynchronous work in JavaScript over an "iterated" source of data. These functions represent my JavaScript skills circa 2002, so please be nice. ;) function mkRecLoop(_work, _cont) { var work = _work; // work to be done; returns true when all work is done. var cont = _cont; // do this when all work is done. return function () { if (work()) return cont(); arguments.callee(); }; } function mkRecAsyncLoop(_work, _cb, _cont) { var work = _work; // ASYNCHRONOUS work to be done. var cb = _cb; // SYNCHRONOUS callback for async work function; returns true when all work is done. var cont = _cont; // do this when all work is done. return function () { var me = arguments.callee; work(function(){ if (cb.apply(null,arguments)) return cont(); me(); }); }; } function mkArrayRec(_work, _data, _cont) { var work = _work; // work to be done on single element of the data array. var data = _data; // the data array. var cont = _cont; // do this when all elements have been processed. var idx = 0; return function () { if (idx == data.length) return cont(); work(data[idx], idx); idx++; arguments.callee(); }; } function mkAsyncArrayRec(_work, _cb, _data, _cont) { var work = _work; // ASYNCHRONOUS work to be done on single element of the data array. var cb = _cb; // SYNCHRONOUS callback for async work function. var data = _data; // the data array. var cont = _cont; // do this when all elements have been processed. var idx = 0; return function () { if (idx == data.length) return cont(); var me = arguments.callee; work(data[idx], idx, function(e,i){ cb(e,i); idx++; me(); }); }; } For the "constructors" taking multiple functions as arguments, the calling syntax can look a bit too verbose. (I don't think much can be done about that without cross-browser support for lambdas from ES4.) 
The real revolutional thing is that Elisp could be implemented on top of Guile making it possible to transplant Emacs on Guile and then slowly phase out Elisp. Awesome!
[Guile?](http://mixonitup.files.wordpress.com/2008/03/553171085_cd32b12c46_o.jpg) SONIC ... BOOM!
w00t.. not bad.
*uggh*... while I agree you should separate your code, I prefer closures much more: // init_global_object should take a string of the // form 'lib.util', create a global object // named lib.util which is an empty dict, // and return that object function module(name, f) { var obj = init_global_object(name); f.call(obj) } module('foo', function() { function foo(a) { return a+5; } function bar(b) { return foo(b)+1; } this.bar = bar; });
I'll add to your *uggh* by saying that I dislike the com.programmish.lib.foo approach of namespacing taken from Java. Javascript is no more Java than a carpet is a car.
Voted down - there is no sound! :D
Made me want to pick up my javascript book again.
Obviously, if they are equal invocations the one that doesn't require string processing is going to be faster.
Wel, no, not exactly - it depends on the selector engine. Although I much prefer $("#foo").find("p") to $("p", $("#foo")) - no reason to call it twice.
This is unfortunate - the syntax of $('#foo p') is *so* much more pleasant than $('p', $('#foo')).
Damn you were faster than me :p But being there, I have a question for you. I've wrote a handful of jQuery plugins (jQuery.timepickr among others) and I've always asked myself a trivial question. I often see people do the following: &gt; var myDiv = $('div.mydiv'); &gt; &gt; $(myDiv).find('p'); While I recognize the advantage of storing selector's results in a variable, I never understood the need to pass it back again to jQuery in later use. Why not simply "myDiv.find('p');" ? Does it matter at all ?
Obviously, you don't know how jQuery works. jQuery has to run a regex on all of the strings in the example, the only objects you can pass into jQuery() besides strings are DOM elements and functions. The difference has to do with the scope of the search for 'p' elements. Actually, this may be the most useful post by **gst** I've ever read!
*Your* example myDiv.find('p'); is correct, there is no need to call jQuery again. This is why I (and others) use a $ prefix as the naming convention for jQuery objects, i.e. var $self = $(this); $self.find('p'); It differentiates them from plain elements (and helps me remember not to call jQuery again).
The page linked is a blog post by the originator of the thread that the gst bot presumably picked up. [Here's a direct link to the thread in question](http://groups.google.com/group/jquery-en/browse_thread/thread/d7fc42d532c23e80).
I agree with you - which is why I just filed a ticket to try and look in to this: http://dev.jquery.com/ticket/4236 And yes, this is a consequence of the new bottom-up design. I have some ideas for tweaks that I can make to get some of that performance back.
I agree - and it's one reason why I generally don't like posts that tell people "the fastest way" to do a selector or operation - it's not always guaranteed to be that way - in fact, if I fix my ticket, it probably won't even be that way tomorrow: http://dev.jquery.com/ticket/4236
Just so you know, you're awesome.
A small tutorial about how to copy Google
python is that you? :S
&gt;JavaScript is probably the most widely-used programming language on the planet I'm gonna have to stop you right there.
Depends on your definition, sure, there's more object code that started as C/C++, but I bet as far as the ability to start with code and execute it on a 'computer' javascript wins. There's an interpreter for it on every modern mac/win/linux system, and more and more modern cell phones.
Every machine that renders javascript has oodles more code written in C, Python, Perl, Assembly etc on it. Javascript is probably the most widely used "scripting language" on the planet however.
No.
When did I say that? His statement of Javascript being the most widely used programming language is patently false. C/C++ is far more widespread, and that's just on personal computers.
Hopefully not.
...most widely-**ab**used programming language... Fixed it for you.
&gt; His statement of Javascript being the most widely used programming language is patently false. C/C++ is far more widespread, and that's just on personal computers. C/C++ might be the language the most programs are written in. The actual amount of people currently programming in javascript could very well be larger then the current amount of C programmers.
So how do you measure the metric? Based on number of idiots who can write "document.getElementById()"? That's not programming, that's copy/pasting. 
It may not be real programming, but I'd say it's "using the language".
If "using" is running the code, then without a doubt, javascript is not the most widely used language.
no. I meant it's "running code that you have at least partly changed or copied from multiple sources" -- setting the barrier higher than just using the binary but lower than writing "real programs", something which javascript (at least within a browser) wasn't really meant to do. Also having the actual development environment nescessary to do so (C tool chain vs. teh Browser) The low entry barrier is surely one of the reasons why javascript is so successful. 
does firebug show any errors? FF 3.0.6 and Safari on mac are all I have to test on.
I want that server rack.
Definitely helpful, thanks. Still not sure what it is, but thanks for the report.
I'll upvote this both for love of Moo and because this is a great tip that might not seem apparent right off the bat. Walsh has been doing more jQuery stuff recently, but I learned a lot about MooTools from their once-awesome documentation (the new one sucks, guys) and reading his site.
Fascinating! Can't wait for future articles in the series.
I'll try some things out when I'm home from work, thanks.
You said "rack".
Works for me on FF 3.0.6 on Vista. I wonder if anyone else has any issues or if it's just tofocsend.
"Javascript is probably the most cut-and-pasted programming language on the planet" There, fixed it for you. Phillip.
via: http://ajaxian.com/archives/aurora-class-types-and-invariants-in-javascript
One more reason web apps are kind of crap for a lot of things.
Is there any reason you sign your comments? You realize that they put the username on automatically, right?
Fuck that. Throw an exception.
...except that you need an OS to run your stupid browser...
I could have read this anywhere, It did not even explain any of the things it was doing or the reason for them. BOOOOOO.
So... browsing to Reddit is as intrinsic to the OS as browsing C:\? And therefore looking at websites is kind of like executing arbitrary network code directly within your OS? No glaring security problems there, I guess.
I personally like class-less objects and the whole myObject.prototype dealio.
When Mozilla people have a problem with their own browser, it will actually get a fix!
Why does http://bespin.mozila.com/ redirect to http://www.iphones.com/ ?
Check the URL. You've only got one 'z' in "mozila".
I think you mean only 1 l in mozila when it should be mozilla but the link I provided is the link from the article. The author is the one who forgot the extra l. 
Yes, that's what I meant. I wasn't sure from your comment whether you knew that was the problem with the URL (in both your comment and the article).
I actually didn't catch it until I read your comment and then I noticed that mozilla was spelled wrong. I knew it wasn't mozzila but that made me notice that it should be mozilla not mozila.
When you're not in a convoluted programming environment, "previewing content" is just a fancy name for "displaying content", which isn't that groundbreaking at all. FWIW, all of the possibilities the author describes can be implemented in a conventional environment with much better performance. With Bespin, you do get the advantage of HTML rendering for free -- and that's about all you get -- yet even this is plagued by style behavior bleeding out of the "preview element", since HTML really was never designed for this sort of thing. Yes, Bespin is just an experimental proof of concept, and yes, I do believe that the purpose of pushing the boundaries will improve the platform so that it *is* "designed for this sort of thing". I think that JavaScript-based applications can work, and that XUL is a neat idea. Firefox proved that it works in the real world. However, you can't motivate this approach by putting down "traditional editors" and "monster IDEs". The features people are building into Bespin aren't crazy dreams to conventional desktop programmers. They're just crazy dreams to JavaScript programmers (myself speaking as one) because **it's so ridiculously tedious** to do using current web technologies.
I've been learning JavaScript recently (being proficient in Python, C, C++), and I am pleasantly surprised by the elegance of jQuery. I've been reading Crockford's writings too and am as amazed as he is that JavaScript, while initially looking like a cheap knockoff of Java, turns out to be expressive enough to implement something like jQuery. Anyone have any good links to explain where these ideas came from? (EDIT: Ideas of jQuery, not the ideas of JavaScript!) From reading jquery/src/core.js, it looks like there it's a stack of "element sets". It's one of those ideas that is more expressive than it should be (being so simple). I think earlier JavaScript frameworks used some of the same ideas, but I have no familiarity with them. 
I'm not really convinced that jQuery is "a completely different programming model than what JavaScript seems to offer at first." It seems to me that programmers have spent a lot of time in the past trying to hammer JavaScript into an OO paradigm when it is, in fact, functional. jQuery, to me, seems more in line with JavaScript's functional foundation than do MooTools or Prototype. (Disclaimer: I'm very new to functional languages.)
That's why I said "at first". In 1998 people weren't writing javascript with closures. They were writing it like Java/BASIC. It's not "programmers" that are doing this on purpose -- it's all the examples from books, and documentation from Microsoft and Netscape. Another reason is that JavaScript superficially looks like Java and C, not Scheme or Haskell, and you can translate Java code into JavaScript roughly line by line, if that's your inclination. But this is besides the point of my question. Even if you accept that JavaScript is a functional language, jQuery's programming style is still not obvious. 
Brendan Eich wanted to use Scheme as the language for the browser. His bosses vetoed the idea, so he implemented Scheme with C-like syntax. It also happened that he incorporated a few other somewhat novel ideas (prototypal inheritance)...but generally, JavaScript is pretty close to what you'd get if you set out to make Scheme look non-scary to C, Java, C++, etc. programmers.
Answer: monads. 
I think the main influence on the design on jQuery was [progressive enhancement](http://en.wikipedia.org/wiki/Progressive_Enhancement). Once you consequently use that, all your javascript problems basically become: 1. Find Elements 2. do something with them 
Javascript = C + Lisp
Neat, I had no idea about that. A little bit of Googling found this link which shows how the code from the book "The Little Schemer" can be rewritten in JS: http://www.crockford.com/javascript/little.html 
Interesting supposition. But in what ways is it C-like? In that it has curly braces, or ... ?
Well, there's all the pointers, manual memory allocation, compiled code ... :) Actually, I'd say JavaScript = a person familiar with Java and Scheme saying, "Uh-oh, I need to write a new scripting language, stat!"
jQuery uses Javascript like it intended to be used.
The major thing is that it fixes things that are fundamentally broken in the DOM, an API for JavaScript, which people confuse with JavaScript. The DOM was created by the W3C, JavaScript is maintained by ECMA. And the two don't really communicate.
Can you elaborate on this? 
Thanks for the only comment that actually addresses my question! (not where JavaScript came from, which I know, but where jQuery comes from) 
&gt; It also happened that he incorporated a few other somewhat novel ideas (prototypal inheritance) That's not unrelated to the choice of Scheme as a source of inspiration, since prototype-based objects are a natural way to implement objects in Scheme, or in any language with closures and without some other kind of object mechanism built in. 
Sure: [jQuery is a monad](http://importantshock.wordpress.com/2009/01/18/jquery-is-a-monad/)
The jQuery core implements a ton of features in a crossbrowser manner: [Utilities](http://docs.jquery.com/Utilities) like trim(), map(), grep(), isArray(), isFunction(), which are useful to all scripters; advanced CSS features (opacity, selectors, :hover fixes) and JSON and Object manipulation methods that browsers are just beginning to implement... **it's like going to the future of the browser and porting it back all the way to IE6.** I converted to jQuery as soon as I read the source and realized that so many of the utilities I built for myself were all packaged into jQuery, and done much better. The community has come to the point where reinventing the wheel was becoming expensive and stupid -- browsers can't agree on a standard, users won't upgrade, and there's always bugs! -- it's best if we can continue building on the excellent work that has done, and concentrate on innovation rather than bugfixes and standards fights. You're right, there are many frameworks and libraries which have grown up around the same time -- this has an undeniable effect on jQuery and we have all learned from one another. I believe the popularity and success of the framework are due Resig and the jQuery developers staying so accessible and open. The features are well documented and the community is great, nearly self-sustaining at this point.
That's amazing... I can't really think of any applications for it, but it's amazing just the same.
Video chat with no need for plug-ins, Photobooth-like apps, gestural interfaces for websites? I don't quite understand though: Canvas can playback video now?
True, of course. But, I wasn't aware it was the common way objects were implemented in Scheme at the time...but I am not a Scheme historian. Anyway, I didn't mean to imply that Eich invented anything new with prototypal inheritance, which is why I said "somewhat novel" rather than "novel". I hoped to imply that it was novel for a mainstream programming language intended for non-programmers to be able to use it (and I think it was; I can't think of any others). Anyway, yes, we agree that JavaScript very clearly came from Scheme, and is about as Scheme-like as the constraints allowed.
The &lt;video&gt; tag from HTML 5 can play back video natively. The &lt;canvas&gt; tag grabs a frame from that video tag with its drawImage method. The &lt;canvas&gt; getImageData method then grabs the raw 32 bit image data from that frame. Manipulate with some basic bit operators, then output the altered image data with the &lt;canvas&gt; putImageData method. 
That's essentially what happened. Brenden Eich wanted to put Scheme in the browser but his bosses wouldn't let him. So he made it look a bit like Java or C.
&gt; when it is, in fact, functional JavaScript is multi-paradigm. You can write procedural, object-oriented or functional code. The best JavaScript uses the right paradigm for the right problem.
Summary of his lecture: http://www.catonmat.net/blog/javascript-the-good-parts/
&gt; var textToInsert = []; &gt; var i = 0; &gt; var length = arr.length; &gt; for (var a = 0; a &lt;length; a += 1) { &gt; textToInsert[i++] = '&lt;tr&gt;&lt;td name="pieTD"&gt;'; &gt; textToInsert[i++] = arr[a]; &gt; textToInsert[i++] = '&lt;/td&gt; &lt;/tr&gt;' ; &gt; } &gt; $('table').append(textToInsert.join('')); THE GOGGLES! THEY DO NOTHING!
Reducing the number of function calls inside of a loop is good practice in any language.
I was just wondering when will somebody really take distributed computation on browsers serious. I think this is it. I am either installing NoScript or write a greasemonkey script to send garbage, if I come accros any site that attempts something like this.
I wonder if the performance gain of rather using Flash will compensate for the lower amount of browsers that will be able to participate.
Posted 3 months ago: [Writing Desktop Applications in Javascript with GNOME - Seed 0.1](http://www.reddit.com/r/programming/comments/7c4p3/writing_desktop_applications_in_javascript_with/)
Anyone else think http://www.ecmascript.org/ looks like one of those domain placeholder websites?
hell yeah it does.
yield can be implemented by transforming the whole function into a state machine. This is somewhat tricky but certainly doable. C# does something like this behind the scenes, when compiling generators. The main drawback is that the generated code will look quite convoluted, and I prefer to generate pretty and readable code as output. Thanks for the heads-up about the editor. Can I ask you what version of Opera you are using?
When JS is disabled (NoScript), the page gets arbitrary styles applied. FF3 gets a red bg and yellow fg for example.
It's dead, Jim.
It sure is, Paul.
Sorry about that - we're getting some intense traffic. It should be up for the time being.
Is it just me, or does this seem miles behind ExtJS?
There is a jQuery pause plugin created [here](http://blog.mythin.net/projects/jquery.php) -- Which I have updated for jQuery 1.2, [here](http://code.doublerebel.com/jQuery/jquery.pause.dblrbl.js). It uses native animation queues and offers a queue-clearing function, features missing from the linked file. Yes I know this really should be available with proper docs from the jQuery site, once my site update completes there will be many updates...
Polypage now includes the [changes](http://github.com/andykent/polypage/commit/d1bd7d1361d6da2345680b877706713ee99f6dbd) mentionned in this article.
is it just me or do the opera guys seem kinda anal?
Would you care to elaborate?
Nothing in that article is unreasonable.
What kind of information are you looking for that isn't found from even just the first page of a [simple search](http://www.google.com/search?q=ECMAScript+3.1)?
Was anyone else hoping for an article about building a AI using greasemonkey that would automatically vote hotter girls.
Good stuff and best of luck.
I know it's not jquery, but SWFupload is much better than this. This jquery script was the first one I used for multiple file uploads, but swfupload is soooo much better because you don't have to add each file one by one. You can highlight them all, or use ctrl+click/shift+click. It requires a little more effort to set up, but the end result is leaps-and-bounds better for your user. http://swfupload.org/
Ajax isn't an effect, but a method to send and retrieve data from an outside source. So the Flash could be using Ajax to communicate with the server...
Believe me, I know that [ajax is just a buzzword for xmlhttp](http://xkr.us/js/ajax). However, conferences such as this one extend the meaning of ajax to cover all related JS development. With that in mind, I find it hilarious that they can't even take any random off-the-shelf JS UI framework and do those Blinds..
Flash can easily use Javascript functions/methods
Heilmann's a Yahoo guy, just happens to be writing for Opera.
Oh yeah you are right....things never evolve from their original definition especially in a technology setting......./sarcasm Come on, everyone knows now that ajax is just a buzzword for a technique as emehrkay pointed out. Go ahead and look to see how many 'ajax' methods are using xml or have ever used xml.....but its in your buzzword......
Contrast this to the JavaScript conference actually worth going to: http://www.jsconf2009.com/
It's a generic web site that hosts multiple events. It would be completely stupid for them to create a new web site for each conference using that particular technology especially when one of them is about ROI. Oh &amp; stop using FAIL it's so last year.
But...but what will we use now? &gt;The Website For The "Ajax Experience" Conference Has All Its Effects Made In Flash.. [REPUBLICAN] Hey, it kind of works!
You have taken the buzzword ajax and decided to pick and choose which parts of this buzzword is mandatory. Ajax now simply means making requests to the webserver without full refresh of the page. Javascript is no more required than xml. Yes JS is far and away the current standard, but this does not mean that you cant use some other technology to do the same thing. In fact the only required part is that it remains asynchronous. As far as your sarcasm comment, I was replying sarcastically because you replied in kind to the original comment....who in fact is 100% correct(unintentional as it may have been). 
Yeah once again you show limited scope of reasoning. Since the idea of ajax requires it to behave a certain way, behaving synchronously would then change the behavior. So even though it was part of the original buzz term, it would still remain mandatory. But go ahead and campaign for anything to be considered ajax must also use JS and XML. We can then have hundreds of other combination's to come up with. In fact ajax itself would be a huge minority in the scheme of things, since the use of XML is so scarce(in this type of useage). 
I am not refusing to, nor have I refused to acknowledge this at all. You are refusing to acknowledge that js is only the defacto technology because it is the only kid in town right now. If tomorrow it is replaced by XXX, does that mean that XXX cannot be used in the technology of 'ajax'. Sure it could, or we could just come up with another buzzword. 
Damn, all this hype about AJAX replacing flash, and not one browser supports any kind of server events. It's the only reason many choose flash to create games or chat rooms. Well, to get technical, the other limitation is browser's connection limits to any server, 2 in IE, making a connection affect you browsing speed on that website.
[Context](http://blog.nihilogic.dk/2009/03/music-visualization-with-canvas-and.html)
whoa.
mootools is a bloated piece of crap. jquery does the same thing, but better, with less kb's.
some nice tips and some painful css.
I'm probably wasting my time on just another full of shit fanboy spouting off useless unsupported assertions, but the current jQuery download is 120KB uncompressed and 19KB compressed and zipped and the current MooTools download is 95K uncompresseed and about 18KB compressed and zipped.
I'm sure you meant: "I differ with MooTools' philosophy. I believe extending the object prototypes is needless pollution of the global namespace." Personally, I like MooTool's depth of features.
Wow, a lot of useful plugins and extensions here. I probably wont use many of them but the URI and element.position look very interesting. 
it'd be interesting to bench mark RAM usage
What he really meant was: "I don't know enough about the philosophies behind each individual library, but I do know that jQuery is very popular and touted as great by many educated and experienced people. Therefore, I will use it. I have discovered it is very easy to use, and with all of this information combined, I have decided that jQuery is awesome and everything else sucks donkey balls."
I was sorting HTML tables with JavaScript 8 years ago. I can't see AJAX doing much besides complicating this. 
*Someone* sounds like a cranky Dojo user. (I kid! I kid! Dojo is awesome as well. Most of the major JS libraries kick ass.)
In regard to #3: Someone should develop a -C-C-C-C-C-COMBO BREAKing extension for Firefox that detects jQuery on a page and randomly halts execution in the middle of a chain.
&gt; Considering the added security benefit of not using eval() directly, there's little reason not to use a parsing library. speed. recoding eval in javascript is just slow. add to that that it's totally unescessary when you can validate the JSON with some regexes like e.g. json2.js from Douglas Crockford does. These days you totally should use json2.js as it is about to get the nice additional speedboost of being natively implemented in some browsers. 
I also don't see why using JSON / AJAX should make a difference in terms of security. You run into the exact same kind of problems without https and can solve them with https and other approaches (data signing etc).
Actually a happy jQuery user :P
It was actually one of my new year's resolutions to write more object-oriented Javascript this year. I'll have to check this book out.
The working drafts can be found [here](http://wiki.ecmascript.org/doku.php?id=es3.1:es3.1_proposal_working_draft)
meh not really, parseInt *-as the name says-* is parsing not casting, it's a subtle detail worth noticing but nothing to expect. upvoted anyways.
I usually use the following algorithm to ensure a value is a number: x = parseFloat(x); if (x*0!=0) { // not a number } This has the added benefit of catching +-Infinity as 'not a number', since that is usually invalid input to my apps.
Last time I checked, `isNaN` is supposed to return `true` when you pass in `NaN`, not when you pass in some random value that is *not* `NaN`. How the fuck is that a gotcha? "this function behaves sanely and is coherent with its naming" is abnormal now?
i think gst works for a PR company. I agree, this is pure bullshit.
&gt; i think gst works for a PR company gst is an automated bot, it doesn't work for anybody and doesn't judge the quality of its links.
I quite often have to write code like this: if (!isNaN(x) &amp;&amp; x != "" &amp;&amp; x != null) { // It's a number! } Most people would assume that the first test is sufficient.
You can just write `(x &gt;= -Infinity)` unless you're worried about coercion to string, which your tests don't catch anyway. `null`, `''`, and `undefined` all come out `false`. You don't want to use `!=` in your tests, either -- you want `!==`, which won't coerce.
If you leave off the parsing phase you get what most of us want-- a test that excludes strings, too. `(x*0 == 0) ? numericalOperation(x) : default` is short enough to be useful. I like your method. `EDIT:` I was wrong about exclusion; `*` coerces strings to numbers. One test I sometimes use when I need that -- `(x === +x)` only allows numbers through. It allows the Infinities but not NaN.
&gt; You can just write (x &gt;= -Infinity) That's pretty cool. But the fact you need to write it proves that isNaN is broken. &gt; You don't want to use != in your tests, either -- you want !==, which won't coerce. Can you give me an example which would fail my test because of coercion?
I observe in another comment that `(x===+x)` works very nicely, too. I hadn't thought about it when replying to yours. In your test, you're accepting strings that look like numbers. That's often ok, but if you have any addition inside that block you'll be concatenating instead: *caveat coder*. In my code, I often want to distinguish strings that look like numbers from numbers; both of my tests do that. I have to reach pretty far to break your test. This will do: x=({toString:function (){return '3';}}); It's pretty evil, though. My `x &gt;= -Infinity` will fail, too. Only (x===+x) really does the trick. My complaint about coercion has more to do with the time spent figuring out whether the coercion is meaningful. If it isn't, the non-coercive comparisons should be used. Non-coercive comparisons are faster, but it won't matter in any realistic circumstance. I could make a pathological object like this: x=({toString:function (){var d=+new Date(); while ((+new Date()) - d &lt; 1000); return 'slow';}}) Which will wait a second every time you coerce it to anything. Yours will take two seconds. My tests will take time, too. There's something to be said for checking the `typeof` first. The other thing is that your `x != "" &amp;&amp; x != null` is exactly equivalent to `x !== 0` in its context (you don't need to check for `false` because your `isNaN` will catch that). `isNaN` just shouldn't be used for validating input.
&gt; In your test, you're accepting strings that look like numbers. That's the primary use of isNaN.
No it isn't. `isNaN` is part of the floating point specification, because by definition `NaN !== NaN`. There's no other way to test for `NaN` than to invoke `isNaN`. Other operations that produce `NaN`: `Math.sqrt(-1)`, `Infinity-Infinity`, `0/0`, `0*Infinity`. The whole point of `NaN` is that it lets a program run through a whole sequence and check at the end for failure, because `NaN` is toxic. The javascript parsing functions are defined to return `NaN` when they can't make sense of input. This makes it clear what our difficulty is here. The problem isn't that `isNaN` is broken -- it's that javascript has no defined function to do what you supposed `isNaN` is meant to do.
If your value is already of type 'Number' then it probably doesn't need checking (input from users or xml-data etc is where this sort of thing is more likely and that is always a string before becoming a number).
Sometimes you're willing to deal with `null` and `undefined` and don't want to lose `0`. Sometimes you even have different behaviors depending on whether you're passed a number or a string -- unwise to do, but I've seen it, and seen it done wrong. 
Translation: We're republishing most of a list from 2006, except we changed all the Prototype scripts to jQuery plugins.
Thank you, I don't know why more people don't see that they are just a traffic-whoring list-factory.
The difference between this (basically monkey patching) and AOP is that AOP allows you to specify your cross cuts in some generic way.. in this package do that etc.. if you have to find all cutting points manually like in this case, it's not really AOP -- or only a bad simulation.
All solid advice. Far from anal.
Quick, someone put googley eyes in the header of the reddit page like they did with Spider-Pig!
Look! I wrote a loop!!!1 
truly simple yes but may be useful since js do not has any builtin facility for that.
Seemed really verbose without the use of a library. A naive first try ... var records = []; jQuery.each($('#txt').val().split(/\n|\r\n/),function(){ records.push(this.split(',')); });
The problem here is that the newline character does not necessarily define a new recordset, and just using a comma as the delimiter is not sufficient either. Your code only handles the most basic case possible. Things you need to account for: * Individual fields can be surrounded by double quotes, and *should* be so enclosed if they include any whitespace characters. You can include newline and carriage return characters between the quotes. * If you want to use double quotes in a field, you need to enclose the whole field with double quotes and escape any embedded double quotes with *another double quote*. So, for instance, if I wanted to have `This contains a "quote"`, this would look like `"This contains a ""quote"""` in a properly formatted CSV. It's not as trivial as you think.
Thus my disclaimer of it being a naive first try.
No massive regexp and can pass the wikipedia csv test. How do you tell reddit this is code? var loadCSV = function(all) { var row = 1; var col = 0; var currentPos = 0; var start = currentPos; var end = currentPos; while (currentPos &lt;= all.length - 1) { var seperator = all.indexOf(',', currentPos); var newLine = all.indexOf('\n', currentPos); var q = all.indexOf('"', currentPos); if (q &lt; seperator &amp;&amp; q &lt; newLine &amp;&amp; q != -1) { currentPos = all.indexOf('"', q + 1) + 1; continue; } if (newLine == -1 &amp;&amp; seperator == -1) { newLine = all.length; } var value; var nextRow; var nextCol; if ((seperator &lt; newLine &amp;&amp; seperator != -1) || (seperator &gt; 0 &amp;&amp; newLine == -1)) { end = seperator; value = all.substring(start, end); nextRow = row; nextCol = col; ++col; } else if ((newLine &lt; seperator &amp;&amp; newLine != -1) || (newLine &gt; 0 &amp;&amp; seperator == -1)) { end = newLine; value = all.substring(start, end); nextRow = row; nextCol = col; ++row; col = 0; } value = value.replace(/^\"/, ""); value = value.replace(/\"$/, ""); value = value.replace(/\"\"/, "\""); sheet.setCellText(nextCol, nextRow, value); currentPos = end + 1; start = currentPos; } return all; } 
Wow, it's like somebody made a nice documentation for a dhtmlcentral.com script from 1997.
String parsing is hard, let's go regexing!
&gt; How do you tell reddit this is code? Indent everything four more spaces.
Thanks
may i be the first to say: **TETSUOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO!**
Using jQuery on the iPhone is a bad idea. It is too large to cache so will be downloaded every time.
If using jQuery is wrong, I don't want to be right. ;-) --- On a more serious note, is there a smaller library for DOM manipulation and AJAX that you would recommend for web apps intended for the iPhone? 
The DOM API is sufficient when it is implemented properly, as it is in Webkit. You have querySelector/querySelectorAll, an event system that works, CSS transitions and transforms, SVG, canvas. A library will mostly fix IE and provide a selectors engine. You already have those things. :-)
I don't think this is a good idea. Google is attempting to address the same issue by hosting various libraries on its servers, allowing for caching, which would work and wouldn't require a bunch of various libraries and versions to be distributed with a browser. A better long term solution is for browsers to continue doing what they are doing - providing native function calls for common tasks, like FF 3.1's querySelectAll. Once most browsers are providing native function calls for a certain task, the library code can be pared back to a bunch of native calls with special case code to handle IEs inherent shittiness, assuming it's not dead by then.
I agree that it wouldn't be such a great idea. I can picture myself explaining to my clients how to clear their god damn cache every once in a while because they don't see the changes I've just committed. It's like Flash's caching problem ported to JavaScript libraries, no thanks. 
&gt; Then your library using decision would not be influenced by the size of the library but by which libraries were supported by browsers. Of course, one already begins to see issues forming where different browsers support different libraries, and update them at different intervals. Fixed.
JavaScript being compiled is not the bottleneck for canvas, if you test the amount of time spent calling drawing functions from JavaScript compared to the overhead in drawing the stuff you will see what I mean. The problem with Canvas is that information about paths is destroyed as soon as it is drawn, there is no way to manipulate existing paths in an animation without redrawing the whole scene, this means the browser is not able to make many efficient optimisations.
weak article, but let me nitpick anyway: 1. Yes, use external JS files for static and highly-cacheable code. But if you generate script data dynamically on your server, don't make the browser do an extra request to get to it. Inline the darn thing. 2. Sure, libraries are nice. If all you're doing is a little bit of ajax, and hooking a few event handlers, and the download size is important (it happens), you can write your own tiny library. 3. I still like alert(), damnit. All you console.error() weenies can go to hell. Anyway, if you're going to impress people with your JS up-to-dateness, at least make a stand on something a tiny bit controversial. How about "People adding prototype methods to builtin objects should be shot"? Or maybe "Why is it valid to have labels: before any statement if you can only use the ones placed before a loop construct? Add goto to the EcmaScript spec now!" If you're going to troll, at least do it right. 
Sometimes I like to mix javascript and markup. If there's a bit of code that's only used on a particular page, then why not stick it in that page. I also do something like this for event handlers: &lt;input id="name_field" onclick="UserPageController.nameWasClicked()" /&gt; To me, this makes it really easy to track down the code for the event. 
 alert = console.error; I've actually been involved projects where all debug code has been disabled with alert = function(){} at the top of released files. Initially started as a make-doubly-sure measurement, but then leaving alerts in became the standard out of laziness. 
ouch. that's about as healthy as `window.onerror=function(){return true};` For all my willingness to defy politically-correct coding rules, my alert() statements never stay in one file for more than 15 minutes. 
I wondered why so many JavaScript sites were so damned slow. Now I know: idiots using a bloated library to replicate the functionality you can get with built-in DOM features. If I just want to get an element by ID I'm going to use document.getElementById. That's what it's there for and it's what the library will be using after a couple of layers of indirection and bloat. Not that there isn't a place for jQuery and the like, but using them for stuff the DOM can already do is just silly.
anti-article about anti-patterns
I understand it better. I still don't understand why on Earth JS was designed that way.
i remember when this concept eluded me but how completely understand this.
This could become an internet smash...
So uh.. who didn't think when seeing that "Hey, that looks like Flash!"? Not a bad thing, really. Just observing.. I see some neat 3d, but still a far cry from http://www.papervision3d.org/ 
i like how the most useful information like practical management is presented by the YUI people and john basically shows profiling.
Without looking into this further, it's hard to take the guy's advice when he is incorrectly "colorizing" his html code for the &lt;script&gt; tags. Also, his technique to "append" to the onload event is terrible. Edit: finally, if you look at the page's source code and how he actually includes the scripts you'll see a bunch of 'onerror="alert(..."' attributes, I wouldn't want to be using his site with IE on a bad internet connection, you'll get 10 consecutive uninformative alert boxes indicating that a feature has failed (one that normally degrades gracefully).
javascript colorizing solutions are unusable; tremendously slow, impractical and a total waste of resources on the client for something that is static and should already come colorized from the server.
A little background on these subjects (yes, I'm the developer). I agree that the onerror-alert tags are pretty stupid, but I copied the code directly from the prettify website without modification. I will change that alert stuff later and possibly look into reducing the amount of includes. The reason I did not want to change it was because I feel it's best to implement it the way the original developers intended, then do your own modifications afterward. If I told you how I made it work for my specific setup, how I modified each source file to make it work for me, then you might not find the utility useful for your purposes. I'm just trying to keep it general purpose for now. For appending the window.onload method, this is a hack, but it works. I should use this code, but I didn't find it at 1am last night: if (window.attachEvent){window.attachEvent(’onload’, your_function);} else if (window.addEventListener) {window.addEventListener(’load’, your_function, false);} else {document.addEventListener(’load’, your_function, false);} [Find it here.](http://ckon.wordpress.com/2008/07/25/stop-using-windowonload-in-javascript/) Thanks for the advice, or hints for that matter.
How would you do it then?
Ya minus the fact that server coloured syntax dirties HTML. Things like table of contents and syntax hilighting should be done on the client.
Syntax highlighting is styling. It should be done in the client.
The problem that I see with Pygments is it's only written in Python. [There's a PHP hack](http://lucumr.pocoo.org/2007/5/30/pygments-in-wordpress) that's been thrown together which does the job, but it again is a hack and the developer only made it work for his specific use case. The issue with this one comes down to defining where code is and what type it is. This one uses a &lt;pre lang="somelang"&gt; tag, while prettify uses &lt;code class="prettyprint"&gt; tags. The difference is I would have to create custom styles in my fckEditor in order to handle each individual language for Pygments, whereas Prettify can make pretty good guesses, if the code is clean enough. Another issue that I thought about was where should the processing happen? I didn't want my web server handling code which should really be taken care of in the user's environment. It's much better for JavaScript to lazily process the code tags after the page loads, rather than increasing the amount of time it takes for the page to load from the server. One last side note. While I used Drupal and Wordpress as stylistic guides, my code is home-grown. You might also notice a little bit of Reddit influences.
To this I bow and say all sides are equal. Good day sir.
Why not just build some of these essential functions *into the language*.
bullshit, it's a style like any other and done properly do not dirties anything unless you consider CSS to be "dirty". the point here is that javascript at the moment is not efficient as to manipulate such large amounts of DOM and even if you're paranoid you could serve a plain version and swap it dynamically with the highlighted one *-from the server, of course-* on the fly for js-enabled agents. being fancy and altering all that style on the fly is pointless and I'm very serious about the performance, that SyntaxHighlighter he mentions literally crashed my FF at work and so we decided to remove it (it was being used in an internal pastebin). again no one here can claim anything about "style on the client" as long as they serve CSS from the server, as everyone else.
[read](http://www.reddit.com/r/javascript/comments/86dbp/colorizing_code_using_googles_prettify/c08e986)
This looks super cool...
Interesting but needlessly verbose ----- &gt;var results = JSQL('SELECT * FROM #ft WHERE nodeName = "LI"); Shouldn't this be &gt;SELECT * FROM 'LI' WHERE id = #ft
There really is no denying that SQL query syntax, a syntax designed to pull datasets out of an RDBMS, is wildly inferior to CSS selectors, with a syntax designed for exactly this purpose. So I think the question becomes "Why"? The only POSSIBLE answer I have is the people doing backend programming are already familiar with SQL so they will be more comfortable doing front end programming. This gets marks for being fun and interesting, but gets a zero for practicality and applicability in real world situations. IMO. And not that there's anything wrong with that at all.
&gt; That is, what is the equivalent of a column list in a DOM tree? Attribute values? But then again, in that case `*` would mean "select all attributes" instead of "select the DOM note", which would be... stupid.
&gt; I also doubt it's realistic for any real-world websites (other libraries handle those jobs quite well), but I thought it would be fun to play with. He is not proposing a replacement, he just wanted to have fun.
xpath &gt; sql
 mysql&gt; /blog[id=1]/comments; ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '/blog[id=1]/comments' at line 1 Hmmm...
Ok, that was a huge waste of time wrapped around a 5-line obvious fix to a simple problem. If this is the kind of stuff this guy finds newsworthy, I don't want to read anything else in this blog. Oh, and here is a simple debouncer: function debounce(flag, func) { if(!flag) { flag=true; func(); flag=false;} } 
I wont bother to remark on the verbosity issue. I think the author knows that. But the idea is pretty cool. Kudos for the effort on this.
More generally, trees are one of the canonical examples of structures that are a pain in the ass to work with in SQL. Still looks like a fun side project. He's probably learned more doing this than I have in the past three years with my habit of avoiding non-trivial javascript problems.
hint: the states on the map mostly have a different color. write a program that scans the pic line by line and you can skip teh stupid mouse tracing..
I didn't even get that far, this is the paragraph I reached. &gt; This presented a major problem if the user was keyboard-oriented and preferred to use the Tab key to move from field to field. There could be hundreds of fields on the screen, and a user could simply lean on the Tab key to navigate from one end of the form to the other. If the user were lucky enough to be on a fast network connection and had a fast enough browser, this would go fairly smoothly. However, the server would get absolutely hammered by all of the XHR requests necessary to populate the side-bar! Has this person never heard of the onChange event? You know, the event that gets triggered when a field Changes?????? Amateur hour Lets give them a lil credit though, maybe not everyone has heard of onChange, but then I would have to excuse the fact that they haven't heard of caching. Let's see, Http Caching (don't need to actually even contact the server every time in most cases), client side caching of data in javascript. Then I can forgive them again, but god damn it, they kick me in the teeth again, have you ever heard of pre-conditions? You know testing to make sure that you should make a request? I can think of about 500 ways to do this. FAIL At least they have the basic concept of a lock down. Kinda neat how they implement it, but still unnecessary had they coded properly to begin with. There app will still make stupid, needless requests when the user tabs slowly through the form. Also, debouncing isn't a software term, it's a hardware term. If I hadn't programmed an alert box that literally bounces when you trigger it I would have probably not made the connection. This might be a good addition to some libraries, but easy to live without, and it's a crutch, not a solution. 
It was supposed to show the sidebar whenever the input received focus, not when it changed. Caching doesn't eliminate the fact that each input has to hit the server at least once to grab the information. You could pre-load all the data, but that would make the initial page size rather huge. Amazing reading comprehension the two of you have. I've run into similar situations in javascript before and have always just coded them individually to check for a flag before proceeding. His solution is more generic and far more elegant, IMO.
If it needs to fetch data on focus it's probably a design error. Can you give a example of a legitimate reason to fetch data onfocus instead of onchange for a input? Also what would happen if the user hit tab 3 times quickly for example, the last input would never refresh the sidebar and the context would be off, hence you'd have a bug.
nifty, although since you have a dependency on flash for playing the sounds as well as getting FFT snapshots from it, one may wonder why you'd choose to add more technical dependencies rather than do the visualization through flash as well. Still, this is glimpse of what will one day be possible without plugins, just as soon as html 5 or 6 come around to defining a way to play mp3s and do FFTs on them. 
Again, you fail at reading comprehension. It was to show the user relevant information about the input they were focused on because of some inane regulatory government oversight requirements. Hitting tab 3 times quickly is precisely what this is meant to catch. It would only refresh the sidebar on the last one because there was a long enough pause for the setTimeout to fire. Each time tab was hit any previous setTimeout that was still active is cancelled, so the first 2 tabs would be negated and only the 3rd one would actually fire. This code could also be used to handle onchange events to handle waiting for a pause in the typing before doing any ajax request (like for auto-complete). Yes, you can manually set a flag and check for it, but this method is more generic.
Well I stopped reading early on so I guess I didn't see that it executed at the end of the callback. That said, I still think a throttling pattern would be more appropriate for this purpose. It still sounds fishy as hell to me that something would need 100kb of data when a input form gets feedback. That is a shitload of data for any html/json/text request. That is approximately 200 pages of plain text, if that can't be reduced there are some fucked requirements. 
For native browser support, I'd settle for the same thing I'd settle for in flash. A single looping sample buffer with the timing, pre-emption, and processing power to fill it myself. That's simple and hard to screw up. From there I can do the rest myself. Processing power doesn't need to be excessive. When I used such a system on a 386 I needed some assembly, but I hear computers have gained in speed since then. 
&lt;audio&gt; is inching closer, Flash is just what we have now. Jacob is great, I don't know where he gets the time to do all this :)
Weird. Either I'm out of it from the cold medicine, or they edited my comment to make it sound less like me.
Or you can put your JS at the bottom of the page (right before the closing BODY tag)... a long known technique. **EDIT:** You put the script *include* before the end of the body tag, as [Google recommends with Analytics](http://code.google.com/apis/analytics/docs/gaTrackingOverview.html#trackingCodePlacement).
Right, but then it isn't cached by the browser (at least for dynamic pages that aren't cached).
Don't think we even need a jquery subreddit. Why separate topics so much.
The important thing is not the raw JavaScript power. Rather, how much faster is DHTML animation? If we can achieve the smooth animation of native iPhone apps then I'm sold.
what about flash?
Seems to be broken in webkit and firefox. I click but get nothin. Cloud tag is awesome though.
Impressive, well done.
I tried Safari (for windows), Firefox, IE7, chrome and Opera and nothing happened, maybe we don't understand how to use the "try it now" feature. :-) I also thought the cloud tag was annoying in practice, but interesting as a concept. 
Hi, it's actually a comment has a javascript in it which load up another version of jQuery as mess up the code. I fixed it already. Sorry for the inconvenient :)
Why, in the year 2009, do people not preload their images?
Hi, thought I replied here earlier, but apparently it didn't post. Yes, jQuery in its current form does not cache well on the iPhone, and yes, there is some extra weight in jQuery for accommodating less sufficient browsers. However, I should note that jQuery has a wide variety of DOM manipulation and traversal methods, as well as Ajax methods, that make iPhone development very easy and accessible. I built a dynamic mobile site with jQTouch from a Flash site's XML file in under two days, fully customized. Also, I use selectors and jQuery's plugin architecture to create CSS transitions on the fly. Thanks-
People have gone from ascii art, to real images, to drawing images using HTML tables, to drawing them with CSS. The internet has grown up so fast. *tear*
Those are very cool visualizations. I think the API could be a lot better, though :(
That is really slick. It's really nice to (finally) start seeing JavaScript apps that are as good as Flash, without the baggage of Flash. Sound is still ornery, but at least things are improving.
I can program stuff like this but I can never get the sweet graphics. Any suggestions?
Holy shit! I didn't think I liked Blackjack, but I just killed an hour and 10 minutes playing with that. Very adroit.
I made a Blackjack app back in 98 when it was called DHTML. Just saying.
I like to use [Inkscape](http://inkscape.org/) for icon stuff etc. 
Team up with a graphics guy.
From first glance it looks like a lot of this is from the free ThemeRoller from [jQuery UI](http://jqueryui.com).
What's the opposite of "earth shattering" again? I suppose I should be grateful they're even touching the source at this point.
Please note: JScript IS NOT Javascript - sabruda. http://www.reddit.com/r/web_design/comments/88z9t/hey_reddit_your_site_is_not_gracefully_degradable/c08lhux
Well, at least they decided to fix some of the inconsistencies in their javascript implementation. It's their DOM and CSS implementations that are way jacked, anyway, not their pure javascript stuff (if you read the linked pdf, most of the errors were obscure).
It works!
Sorry everyone, I'm just testing reddit api.
testing api2
testing api3
?????????????
API TEST 4 (-----------)
MIT license instead of their existing not-really-a-license situation. Good news!
This is great. I like Ext more than jquery et al but it really wasn't an option for lightweight sites. Can't wait to sink my teeth into this.
This is great news - made my weekend! I always thought an Ext Lite would be a great idea. I already started migrating to Ext "Core". Oh, how sweet it is!
Is it faster then Jquery? I hear the Jquery selection engine (They called it that) is very fast.
I have been using Ext for the last two years and I only can say: It's amazing... for an Intranet. Forget to use it on common webs.
Love all things jQuery. What an amazing library. Browsers should have this built in these days.
I was hoping they would be releasing V8 for GAE, but I suppose Rhino is the next best thing.
No "they" here. Google is releasing a Java version of their app engine, and a lucky early tester got Rhino to run on it. V8 is not written in Java so it's not relevant here, and won't be until Google decides to explicitely add support for server-side javascript in their App Engine offering (which isn't terribly likely as there isn't really a defined set of standard server-side APIs for server-side JS to use. At least Rhino code has access to the standard Java API.) 
I, for one, am majorly bummed. But whatever, that's what booze is for. 
it's fascinating to pear into the future. now to get back to supporting ie6 in fallback mode... X_X
I don't have a judgment on whether it's a good thing or not, but hasn't the history of the ECMAScript standardization process over the past year been one of the Mozilla-based leadership knuckling under to Microsoft (and to a lesser extent, Google and Adobe)? What we're now calling "ES5" was originally supposed to be merely ES3.1: Fix a few annoyances and provide a smoother migration to the feature-rich ES4. Most of the posts to the es4-discuss list were about the typing, classes, etc. that were going into ES4, with a few protests from the corporate types about their need for practical changes now. But then ES4 became "Harmony", pushed off to the indefinite future, es4-discuss became es-discuss, and now the "patch" release is version 5! The turning point seems to have been the 2008 [Oslo meeting](https://mail.mozilla.org/pipermail/es-discuss/2008-August/003400.html), but there aren't any [minutes of substance](http://wiki.ecmascript.org/doku.php?id=meetings:minutes_jul_23_2008) for the meeting that I can find.
kind of a noob question, but how could i do the same thing with jquery? my site uses that for every javascript thingie and i'd prefer not adding a whole second framework.
I think something like this could work (haven't tested it, but the premise holds - you're dynamically loading the script at a later time, rather than inline using a document.write). var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www."); jQuery.getScript(gaJsHost + "google-analytics.com/ga.js", function(){ _gat._getTracker("UA-8245545-1")._trackPageview(); }); 
I like google analytics because it is easy not to suffer it just by not allowing that one domain in NoScript.
It could definitely use some polish: http://tlrobinson.net/snapshots/Untitled.png Here's a nicely done JavaScript solitaire: http://worldofsolitaire.com/
I'm thinking about trying to support myself by teaching a course on javascript programming this summer. It would be an introduction to programming course aimed at web authors and designers who don't know how to program yet. Do you think there is sufficient demand for a course like this? How much should I charge?
Great stuff, this is going right to the arsenal :) Thanks...
Reddit moves fast, I would have missed this. Thanks.
WHOAPUREDOM IS SO FAST (* The 'PureDom' tests are written as a minimal abstract utility API to accomplish these tasks, and are included as a baseline measurement of the compared libraries. It currently is not a library available for download or use.) 
it's amazing how much firebug slows these tests down
Man they should totally release PureDOM, it would make the web so much faster. I think they keep it for themselves so only they can have fast pages!!!1 
i know i totally googled it and shit, couldn't find anything~oneoneone! @johnresig clearly should abandon the sizzle css selection engine, and take some lessons from these PureDOM* guys
well, all kidding aside, here's the super-seekrit library: http://dante.dojotoolkit.org/taskspeed/frameworks/webreflection.js pretty much what you'd expect, although the getSimple function is small and nifty enough I might just steal it someday. 
&gt; exitFrame(me) { Grmf. This is one of those things that claim to be javascript, but is really a bastardized ecmascript implementation. Also, generally I'm not convinced a JPG is the best way to share a code snippet. 
via: http://mattsnider.com/languages/javascript/tools-taskspeed/
It's not so secret. I posted it to reddit a while back: http://www.reddit.com/r/javascript/comments/89io9/javascript_libraries_not_always_the_best_solution/ It got modded down. Reddit knows best!
Method chaining sucks. Why doesn't anyone but Smalltalk have method/message cascading?
&gt; By and large, TaskSpeed may be more of a distraction than a source of information useful to the consumer. My greatest concern is that people will make a decision to choose one library over another based on which one can add a ridiculous number of event subscribers in 25 milliseconds
Care to elaborate? I.e. what sucks about method chaining and what is better about method/message cascading?
Message cascading gives you the ability to return meaningful values from methods (or no value if there is no value to return), and chain based on these meaningful values if need be. With method chaining returning this/self, you have to choose between returning meaningful values or returning this/self; with cascading you can have your cake and eat it too. Basically, this-returning method chaining is a hacky re-implementation of message cascading. Let's consider TFA's last example for instance, from the `removeArgument` method you might want to return the popped argument (because you want to reuse it somewhere else for instance). With self-chaining, you have to choose between the ability to chain your calls and returning that value you might want to use (or you have to create a second method). With message cascading, you have both. And you don't have to do that stupid `this`/`self` explicit return (that's one of the few areas where I think Smalltalk miserably dropped the ball though: if a method has no explicit return `^`, it implicitly returns `self` instead of returning the last evaluated expression of the method) edit: here's how it looks BTW (in smalltalk): Chaining no-arg messages myObject message1 message2 message3. `message2` is sent to the return value of `message1` and `message3` to that of `message2`. Chaining 1-arg messages ((myObject message1:arg1) message2:arg2) message3:arg3. Cascading no-arg messages myObject message1; message2; message3. Here, all of `message1`, `message2` and `message3` are sent to `myObject`, the return values of the first two messages are simply dropped and ignored. Cascading 1-arg messages myObject message1:arg1; message2:arg2; message3:arg3. Cascades are usually indented for clarity: myObject message1:arg1; message2:arg2; message3:arg3. There is of course the question of what such a cascade returns. In Smalltalk, it's the return value of the last message (`message3:` in this case), and if you need `myObject` (pretty common when you're initializing an object you just created for instance) there is a `yourself` method which simply returns `self`: item := (Document select:'#boo') addClass:'funny'; css:'color' value:'red'; show; yourself. "at this point, item contains the element obtained through (Document select:)" I find this approach eminently sensible and highly flexible. PS: message cascades are evaluated sequentially.
What does this have to do with prototypal inheritance?
The battle was over last year. I do wish there was a document available that'd list clearly what the exact delta is between the 3d and 5th editions. It should be short. 
Because only people like you who overuse the caps lock key like XML.
I don't get stuff like this. If it isn't supported in all browsers, why would I make use of this in a real world example?
Yeah, I agree with you, but they are still driving innovation in this arena. What's the alternative? Submitting a standards request that will sit and linger for a while until it is approved/denied? If these features gain some steam, they have a better case for turning them into standards. EDIT: Never speak in absolutes.
I agree it is innovative, but so is tesla building an affordable electric car...it just isn't going to affect me until about 10-15 years from now.
Some times homebrew extensions get adopted by other parties over time, as was the case with original XMLHttpRequest. 
Agreed, kinda. I don't really care what the final implementation is, but I do hope people can be adult about it and agree on how servers should tell web content cross-domain requests are okay. Flash was the first one to come up with something, and Silverlight just reused it, which was fine. If Mozilla has a better way of doing the same thing, that's fine, but I hope they're collaborating with the other folks about it. I just pray it's not a case of NIH/"Only the open web exists, anything else is irrelevant". 
LOL
Welcome improvements, but I wish they'd focus on making the browser not suck resources from the system like crazy. I finally gave up and switched to Safari 4 and so far find it so much more pleasant.
Pretty cool, [and yet](http://screamingduck.fileburst.com/Cruft/ButtonSplat.jpg)... 
Here's a great lightbox alternative: *don't fucking lightbox.* It wastes time, it's distracting, and in an era where every user worth serving has a tabbed browser, you're wasting your time and bandwidth. If you really must treat your users to in-page thumbnail enlarging, try replacing the thumbnail with the full image on click - none of this dimming and waiting nonsense.
Nice, but I didn't know a beer in Latvia costs 10 fucking euros.
To bad Screw.Unit suckkkks :P
The nice thing about lightboxes is, there are [so many to choose from](http://planetozh.com/projects/lightbox-clones/).
via: http://damienkatz.net/2009/04/couchdb_in_the_browser.html Damien Katz: CouchDB in the Browser
WRONG! I WOULD HAE AE OU LIKE HIS: WH DOES HE ROSS_DOAIN HR NO USE HE ROSSDOAINL FILE? (keyboards do not like it when you hold down both shifts)
Yes, let’s load full sized versions of ALL thumbnails on the page, *with* the page! It’ll be quicker! We’ll save bandwidth! Who wants to wait?
What are you on about now? Only the thumbnails would load. The full-size replacements wouldn't come into play until asked for, just like here. The behavior has been used accidentally for years by every Geocities page where mousing over a site navigation button replaced it 'lit' version.
You can still optionally check for it - if it exists, use it, if not, don't. I think its a fear of javascript that keeps most people from writing code that can adapt to the platform.
This is pretty cool. I was just bitching the other day that I had to have Java installed on my box to run the offline compressor. 
It's true, I use this for all of my js. Much more reliable then any other compressor.
The minimised javascript file will ultimately be compressed with gz when sent to users so when changing variable names from fooBarBaz to 'a' it shouldn't just blindly pick each letter in the alphabet in order, but should instead use letters found in the code first such as forwhilels first. This will lead to better compression and smaller files sent to the user. If possible doing a quick analysis of the code and sorting the available short variable names based upon frequency and using them in that order will result in smaller gz'd files.
Four tabbed boxes and six demonstrations of background-position.
Or just skip to the final product here: http://kjeldahlnilsson.net/projects/quicktetris/
I think it's quite a new way to list tutorials. With all the demo in one page, you know what to look for.
Don't really know what you're on about. Lightbox is one of the best web new method. Can't seem to understand why it's waste bandwidth and time when it take the same amount to load :|.
Good point there. 
This is an interesting thought. Question is, would this produce noticeable improvements?
that site kinda looks like deviantart :D
Hmmm.. "High Performance" and "Javascript" are mutually exclusive terms..
I don't understand the author's second point - that jQuery uses the same selectors as CSS. Mootools $$ function uses a CSS selector engine, aren't they the same? I don't get it :/
What are you basing that on? I was under the impression that dojo was just as fast, and oftentimes faster than comparable libraries. [A dojo benchmark](http://www.nofluffjuststuff.com/blog/alex_russell/2009/03/dojo_1_3_is_out_.html).
I love JSON, and this + Persevere has actually got me quite intrigued. I wish it wasn't written in Java though, as I'm worried about memory consumption.
I've been working with Persevere for a few months now. The combination of cross platform, high (architecturally optimal?) performance, scripting (Javascript), common interconnect glue (JSON) and billions of lines of rock solid Java library available make for a fun experience.
I'm from a PHP background, so I'm used to hearing how awful a particular language is over another. I just can't get over how tightly coupled Persevere makes the JSON data connection between client and server... removing all those hoops to query/parse/serialize the data from the server-side is simply fantastic for me who wants to push as much of the App onto the client-side.. Performance and Time-to-Market benchmarks far outweigh system resource requirements from my experience. What alternatives would you suggest?
Have you ran into any cons with this? From an outsider, it has a silver-bullet type appeal, so I'm curious what the catch is.
Why the heck is the topic a question? It is a fact that this is true.
I hadn't investigated it much when I wrote the original comment, I was just voicing concerns over the use of Java because I'm looking to deploy applications across cheap VPSes to keep hosting costs low (I think cheap VPS deployment is going to be increasingly attractive over traditional shared hosting). My comment wasn't meant to disparage Java, it just has a reputation for being memory hungry. I hopped on the Persevere IRC and talked to a gentleman who said he had been running a fairly intense testing server, and the memory usage never got above 100mb, which, while not lightweight, is perfectly acceptable and usable on a 512mb VPS. I've only used the traditional RDBMS model in the past, so this is new territory for me, and I can't suggest an alternative. I am very interested in it, and will be setting up my own tests tomorrow. The biggest downside I see right now is the newness of the software. Being on the bleeding edge is exciting, but it can end up being painful.
I have a hard time thinking or a less useful "wow, cool!" application than this.
As am I. What a bunch of babies. I was very hopeful that the functional extensions would get implemented... but it looks like only the most boring OOP stuff will be entertained. Sigh.
it's totally useful. being able to produce simple pdfs client-side saves a bunch of traffic and server-side crunching.
Just saw that there - sweet -- I'd like to see it take my bank account and quick pdf it. Anyone care to do a bigger real world example? 
Demo's not working for me. I'm getting "Error On Page" message in IE7 and it just freezes up in Firefox 2. Any suggestions?
Works well in Google Chrome...
That's cool. I'll give it a try from home. Unfortunately only 00.3% of my traffic is on Chrome. Any other browsers working? 
Works well in Firefox 3
It was once possible to do something very similar with the nowadays rarely used, and apparently now backward-incompatibly broken document.open() method. Replace the last two lines in http://jspdf.googlecode.com/svn/trunk/examples/basic.htm with: &gt; document.open("application/pdf"); &gt; document.write(out); &gt; document.close(); And tada, your PDF generation code is ready to go on Netscape 2,3 and 4! 
You could try reading the documentation: &gt; Client-side demo works best in Safari or iPhone Safari. Also works Firefox 3 on Windows and Opera. IE support on the way.
Of course. Forgive my newbie error.
I find "for(var x in y){ alert(y[x]); }" to be easiest to remember. It follows some other language syntax (VBScript maybe?). It seems when I learned the "for in" syntax there might not have been a "for each" available, so I either used "for" loops or "for in" when I didn't know the keys. The beauty of "for in" is that it works the same for associative arrays, objects, and standard arrays. for(var i in j){ alert(j[i]); } //works for objects, assoc arrays, and standard arrays for(var i=0; i&lt;j.length; i++){ alert(j[i]); } //only works for standard arrays
You really need `if (y.hasOwnProperty(x))` or inheritance and especially prototype patching can break it. (Then again, I prefer to forbid prototype patching, so that's not always such a bad thing.) `for (var i in a)` will give different results from a loop, too, if not all elements in the range have been defined. It depends on which behavior you want. Also: You should probably use better names than `x/y` and `i/j` -- especially in an example. `array` and `i` or `object` and `key`, for instance. Incidentally, if you're sure an array is dense (as for any of the `.getElementsBy` methods), you can use: var i, element; for (i=0; element = elements[i]; i++) { ... } Which can be nice in some contexts.
I like the .forEach function the most from the list, even though I never use it. Reason being is that you could easily overload it on your own objects if you wanted. I'm sure I have objects that could use specialized iterators.
Um. Who cares? Is anyone writing core JS these days? I was under the impression that just about everything is written using a library.
Very cool idea: [Keyboardr](http://keyboardr.com/) Perhaps it could be made to play nicer with Firefox's Window-opening behaviour. Is there some 'target' or related attribute one can place on a link that suggests it open in the background? 
For x in does not work for arrays. 
What's up jsconfers.
We hope everyone had a great time at JSConf 2009.
Resig's haircut. Discuss. 
Anybody have real world app experience with server side javascript (couchdb or persevere)? Kris has an interesting blog post here: http://www.sitepen.com/blog/2009/04/20/javascriptdb-perseveres-new-high-performance-storage-engine/
Nice. Now hopefully, someone can donate a nice design for jquery.com...
If you only write JavaScript for Mozilla products, sure. If you want your code to be reasonably portable, though, then you have to stick to the standard, and that means only `for (index in array)` should be used.
They had a really cool one and replaced it with the current one
**H4XX0RZ** *- FTFY*
Nice article. See also [Jemplate](http://jemplate.net/) by ingy dot net. I'm not so keen on the idea of transmitting templates as HTML and compiling them in the client browser. Jemplate avoids this by pre-compiling templates to Javascript code server-side. You then transmit them as a regular .js library. 
Resig, he's so hot right now. Resig.
Make the image and the container scale at the same speed for a more solid feel.
Fancy indeed. I likes.
This popcorn rocks. Every flavor you can imagine and you can order online.
I feel like this article would make more sense if I was already intimately familiar with Monads. Any chance for a practical use case of Monads in Javascript?
Well, dojo.Deferred is used throughout a lot of the dojo framework, there's also a Deferred implementation in MochiKit too. So any code using those is effectively using monads. http://ajaxian.com/archives/dojos-deferred-api Might be a good start on why Deferred is interesting of itself. Realise the article's a bit thin on background though - really I was just drawing a parallel which may prove enlightening to those familiar with either Deferred, or monads, or both...
Nice code and all, but I cringe every time I see 'new java.' in JS code. Netscape has haunted me.. 
Fine, so dojo uses Monads by using Deferred. How can I use Monads in JS for something practical? 
Really cool article. I've always more or less assumed there were no characters worth thinking about outside of the BMP, but I've never actually stopped to think about how JS would handle them, and what the implications would be. I now wonder if any of those high-numbered characters can have interesting meaning in unexpected places, as I can pretty much guarantee most blacklisting sanitizing filters aren't looking for them yet. 
Fair enough, fair enough - I feel your pain! In this case I'd like to point out though that the "new java" lines are actually executed in a Rhino/Java context as opposed to the Netscape/LiveConnect example you mentioned. I'm sure you're already aware of this, just pointing it out for others who come check out the comment stream. Thanks for reading!
That new java. stuff still works in current Gecko engines. If Rhino could run within an untrusted browser context, you could apply this directly to get worker threads in Firefox. 
This looks like an abuse of the term "Ajax". Though most effects are very nice, they miss the core property of Ajax: behind the scenes interaction with a webserver.
I think of monads as an abstraction that gets computer scientists excited, but also happens to be a convenient pattern for us codemonkeys. FWIW, [jQuery is a monad](http://importantshock.wordpress.com/2009/01/18/jquery-is-a-monad/) too...
And here I thought the breakout I'm working on in Javascript was cool.
Great, apparently I suck at this version too. I hope they also have cheat codes, so I can pretend I know how to play this game. 
Convenient pattern, highly overrated.
I think this is just a little trend in the javascript world.. Bloggers everywhere are suddenly realizing that javascript can behave a lot like a functional language, and that pretty much everything they've seen in Lisp, Scheme or Haskell can be done in JavaScript, if you're willing to excuse the awkward syntax. If you're lucky, they'll talk about monads. If not, they'll show you how to implement a y-combinator in JS, even though it's an entirely useless construct in that language. 
Well it is Scheme in Java clothes.. :-) It's not all bad, my recent favorite was [debounce](http://unscriptable.com/index.php/2009/03/20/debouncing-javascript-methods/)
yea, but - why?
Kudos, sir. Kudos.
a bit defensive, are we?
$(".myclass") is much slower on MSIE6/7 that's why you should use $("div.myclass"). Blog posts like this really annoy me. You should verify your findings on the most popular browser instead of extrapolating from Firefox.
Good question. Can someone who voted for this article please explain?
Looks cool!
Any way to increase the size of the screen for those of us on a browser more powerful then a cell phone?
anyone that gets discouraged of trying event bubbling due to this article needs to read this one by the YUI guys who perfected this years ago. http://developer.yahoo.com/yui/examples/event/event-delegation.html 
Now do SimCity 2000!
Things like free food and snacks are difficult to do with any substantial number of people. 130 participants isn't exactly a huge crowd. DefCon in Las Vegas brings in thousands, for example.
I guess since the flood of libraries for JS, people have forgotten a lot of the core concepts. **call** and **apply** are not new, folks. Neither is object-oriented javascript or functional javascript.
Nice. I didn't go into all the details, but essentially what they are saying is attach the event to a parent 1 time and detect where it came from instead of attaching hundreds of event listeners to every item you want it on. This is done because each event listener you add supposedly slows things down more and more. Did I get it right, or do I need to read in more detail? :) I wanted to ask to make sure.
Good point. But even if the food was crap, this still would remain the best conference I've been too for the reasons mentioned by the author here. And for many other reasons.
deapleap.com exploit: enter || or ^^ to reset the letter timer and drop another usable letter. (how i spent my lunch at JSConf)
I don't think anyone is claiming that these are new concepts. I would say that with the "flood of libraries for JS", people may be more apt to experiment with the language and figure out how things work. I think that people are finding these articles interesting is indicative that maybe JS is losing some of its reputation as a toy language.
I hate how people try to fight this private/public pattern so much. Although I understand the need for privacy, and you don't want people tampering with your objects, but you can just document whats public and whats private and just expect implementers to stay out of the private space unless they know what they are doing. Since the source is freely available with JS and that is implied, and there are no good auto-completing js editors really, so there is little point in syntactically implementing public/private.
I generally compromise. I write everything using closures, because it's so much more convenient as the complexity of the program ramps up, but I'll generally expose an object named `context` or `local` via the interface I return. It's not about visibility paranoia in my case.
I'm not disagreeing with you, whatever makes for maintainable code. Just saying a lot of people yearn for public/private operators like java or c++.
I use the module pattern quite a bit. The bigger the codebase, the more useful it becomes. There's something neat in having encapsulated logic hidden behind a small interface, it frees space in your brain for better things than worrying about interactions with cluttered objects lying around. All this fluff about how cleanly compartmentalized code makes it hard to debug or extend is a matter of trade-offs, trade-offs that a number of languages have made without anyone clamoring about how much harder it makes things. If you're writing a quick script, don't bother with the module pattern. But if you're writing a few thousand lines of code or more, you better have a darn good way to keep your code manageable, and the module pattern is one such way. 
&gt; Although I understand the need for privacy, and you don't want people tampering with your objects, but you can just document whats public and whats private and just expect implementers to stay out of the private space unless they know what they are doing. Or you do it the python way, prefix "internal" methods with `_`, and just say in your docs that those methods are unspecified, undocumented and should not be used, and that future breakage because you made direct call to them will result in you being told to fuck off.
good article, but I prefer working without libraries and PPK fits my bill in that department as he explains the browser differences…
Couldn't have put it better. When you're writing thousands of lines of code that will be maintained in the future by you or someone else, it really helps to have hard guarantees that certain internals are only accessed within a certain scope. The same way you can reason about local variables in a function without reading any of the other code.
What is the problem here? I can hide what I want to hide and I can make public what I want to make public. No problem.
I think your assertion that "maybe JS is losing some of its reputation as a toy language" is spot on. As others have said before, most people who hate JavaScript in truth hate the DOM (or browser differences therein). The language itself is powerful and elegant, deserving of serious study if not outright evangelism.
Except in the most time-critical of applications, I can't imagine any reason to use a solution besides #3. #3 is simple, easily understandable to someone reading the code, and much faster than simple concatenation. The examples beyond that make things more complex for minimal gains in speed.
Thanks neimado - I agree that benchmarks are necessary. It's my plan to provide a follow-up article with benchmarks to demonstrate the real gains in major browsers - just didn't have the time to fit it into the original article :/ 
That's my gut feeling as well. As neimado said, I'd like to see some benchmarks to see how much doing an extra loop before the main loop speeds things up, if at all. 
I've done a bit of JS speed tests before, one thing I recommend is to run the JS through a minifier before executing it on IE6. I ran some tests a while back and found out that on IE6, the length of the variable name actually matters... I look forward to your results. (And don't take my other post as criticism - I understand that you're not saying everyone ought to use the super-optimized method.)
Keep in mind that the "concatenation is slow" conclusion is dependent upon implementation. It may be the case that all current JavaScript engines copy strings to perform concatenation, but that doesn't need to be the case. ActionScript has an efficient string concatenation method that doesn't do any copying, so it seems reasonable that at least Firefox will have this optimization. The point is, that the article starts from a generally accepted conclusion that may not be accurate and probably won't be accurate in the future.
&gt; I agree that benchmarks are necessary. Sorry to be negative but when you blog about speed improvements, you really need to back up your findings.
I'm not sure I understand your point. As I see it, in any language... 1. Strings are implemented as char arrays (not appendable). 2. Strings are implemented as char lists (appendable). If your language does #1, there's simply no way that simple string concatenation can be faster than building up a string. Each simple concatenation will result in a new string, because the new string will be a new array. I honestly can't think of any language that uses #2, because a language can use #1 for general speed (like Java) and still allow for #2-esque implementations (StringBuffer).
I might write a simple site with this for the fuk of it. I'm on this new kick where I pretty much learn a language (not so much in this case bc it is JS) just to see how it works
I'm really happy JavaScript has come so far. Other newer cooler languages have had conferences from year 2 or 3. Took 13 1/2 years! 
I suppose my point is that one should take caution when making blanket statements about performance. &gt; As I see it, in any language... &gt; 1. Strings are implemented as char arrays (not appendable). &gt; 2. Strings are implemented as char lists (appendable). Don't confuse strings as a collection of characters with String as a type. A String class needs to have access to the array of characters, but that doesn't mean that it can't have any other information. In the case of ActionScript, the String was re-implemented to use what is called compound strings. This is a traditional String class that also maintains a pointer to the "prefix" string. (sort of a reversed list) ActionScript had added a StringBuffer class, but it was removed because it provided little to no performance advantage over compound strings. Additionally, the performance for traditional plus operator string concatenation easily outpaces the array push/join approach. I don't see why these couldn't be the implementation for strings in JavaScript. Its possible some implementations already do or are planning to. (Adobe did hand over Tamarin for use in Firefox) So the point is that the initial assumption that string concatenation is inherently slow is somewhat questionable. It was definitely slow in the past, and it may be slow right now, but it shouldn't be just taken as a given to be slow.
Hmm, interesting. Thanks for building the benchmarks. I realize now that I didn't fully understand solutions #4 and #5 yesterday. They're good for building repetitive things, but aren't dynamic enough for building a large, highly varying string. So I'll stick with #3 for now.
I absolutely love the CSS sprites and lava lamp menu effects.
another week without jquery 1.3.3 :(
Cool, but it sounds like yahoo vendor lock in to me. It might be able to do some cool stuff, but it's best to not require yahoo servers for your application to run.
How would you compare that to a facebook app or a google engine app? 
This isn't that great if Yahoo! won't even consider adding an `Access-Control-Allow-Origin: *` header to their XML or JSON output. It's either give Yahoo! full control of your website or do it server-side, making secure standalone webapps impossible.
I use both at work, I like jQuery. jQuery isn't a full solution though. 
Any idea about how it compeets with others, like Jaxer?
What do you mean by "not a full solution"? Are you saying that YUI offers more functionality? Thx!
I built couple of projects with both of them and I like YUI. Main reason: Projects with fine-designed and implemented components by YUI works much faster, has more reliable, maintable code than with jQuery. YUI has been built with and force you to write more readable and reliable code. 
Good proof of concept I guess. Also learned I really suck at poker.
Video Poker is Poker like Guitar Hero is being a rock star.
As an aside, ActionScript 3 also supports those fancy namespaces. Technically, the difference between a class package, a property namespace (including making that property public or private) and an XML namespace is very very tiny in AS3. It's neat, in a slightly under-documented kind of way. 
The main problem being that not all events bubble... in particular, submit.
Maybe it's because I'm one two guys in the company that really value JavaScript. Maybe it's because I give presentations on basic (yet somehow still labeled advanced) JavaScript techniques such as closures. Maybe it's because I'm just a front-end developer at heart. Whatever the case, this article rocks. Thanks for sharing!
How would "submit" bubble? If you have a form inside another form? I don't know if that is valid HTML. Thanks in advance for clarifying this interesting observation.
i just used taffydb for the first time, to do an autocomplete type of thing for sending messages (it would autocomplete the to: field) and it was great! this seems good too! anyone have an idea of the benchmark / speed differences, for example, taffydb said something along the lines of after 5K records, searching starts to get really slow
thats right. this solution really makes you loath seeing server side code where you're looping over a list of items that all invoke the same onclick function. 
This sounds safe.
he explains the differences in the way browsers attach events to elements (attachEvent vs addEventListener) but he just finishes up saying that he would never use this method because IE doesn't support the currentTarget property. My point was that the YUI (and other libraries) fix this functionality and it can be a very useful way to attach event handlers to a lot of elements. 
If you're being sarcastic, you might be making the wrong guess about the scope of those queries. 
I think this could be put to great use for auto-complete search forms but is the example really grabbing from a javascript user database? 
I don't see anything about building or using indexes for you, so expect complex queries on large datasets to suck accordingly. In short, break your frequently ran queries into chunks and reverse map the crap out of the pieces that will matter the most. Nobody will notice their browsers eating up a few extra MBs. 
actually those results would make sense for something like a forum, that publicly displays logged in users, vague biographical information ,last logins, and if they're an admin, but the permissions is silly
I did some testing with taffy some time ago for finding something in your data. It took something like 0.28s for approx 140 entries. I posted a function at SO that has similar results (sometimes a bit faster) and the syntax is simpler: http://stackoverflow.com/questions/561702/in-javascript-how-would-you-build-a-method-that-compares-value-a-with-value-b
I prefer attaching to submit instead of onclick (say I have tons of delete buttons that I want to ajax-ify. I'd rather it be a real POST form so that it degrades in a reasonable manner)
Uh, I suppose it would fire on every element along the way, since thats the way it currently behaves for other events? The currentTarget would still point to the correct form...
&gt; Is it legal, I think so. Isn't this the Yoo memo?
Just wait until someone relies on complete strangers to process mission critical data.
Congratulations g_ford, this is officially the most useless article ever posted to /r/javascript. Hooray for you!
If you are looking for prebuilt scaffolding UI, then go with YUI. If you're looking to make javascript the language easier to play with, go with jQuery. I tend to code all my own interfaces from scratch, so jQuery is very useful to me.
My guess is anyone wanting this sort of resource would not use it for mission critical information. That said, if it were cheap enough, you could process it multiple times in order to filter errors or intentionally munged data.
Seems like a nice alternative to the Cycle plug-in. Minified it's only 12KB, Cycle is 20-28KB depending on whether you get all the transitions.
nope, we're all jquery evangelists
$('person#you').val('Correct');
MooTooler here. Oh, and I prefer to call you jQueers.
Ext is a big hairy complicated house of cards waiting to fall. That's why i stopped using it. One js error and the whole thing comes crumbling down.
Sure.
I tried it... they've got a lot of really powerful stuff, but unless you're a paying member, getting information or help out of people in the forums is like pulling teeth. I've moved onto a community and framework that has a more supportive and helpful user base.
WHO!!?!?
Me too, I was just curious as to its reception. I was told that it can be powered by the jquery core, but they are trying to switch to their own core now.
I see what you did there.
I had the same problem, specifically dependencies with other library objects located on other js files; since core js files are minified it's tough to decifer where the error is coming from. Once I got the hang of it it was pretty straight forward though.
I have used extjs, and then dropped it in favour of [gxt](http://extjs.com/products/gxt/) (the [google gwt](http://code.google.com/webtoolkit/overview.html) flavour of the ext library). I moved to java mainly for the ["One js error and the whole thing comes crumbling down"](http://www.reddit.com/r/javascript/comments/8iyba/i_saw_a_cool_demonstration_of_this_framework_last/c09fjcl), and because of eclipse. The library is worth learning: very flexible and feature rich. Once I figured out the proxy--&gt;loader--&gt;Store--&gt;widget relationships things like the grid widget were very handy and customizable.
I swear by Dojo, although sometimes I think I'm the only one.
That is the pejorative term I've been looking for.
I attempted to use it for several months, to AJAX-ify an existing large (very large; think hundreds of thousands of lines of code spanning 11 years of development) web application. The project failed pretty miserably, and I've moved on to gradually AJAX-ifying the app in small pieces with JQuery. ExtJS has beautiful widgets, has a very fast core selector and DOM library, and is constantly getting better. However, it is hostile to from-markup conversions. It is practically impossible to build apps that degrade gracefully. And, if you aren't building from scratch to use the very specific interaction model of ExtJS, you are in for a world of hurt. It is consistent to a fault, in that regard: it's their way or no way at all. If you have an app that you'd like to gradually convert, you first have the hurdle (possibly a major one) of converting your app from loading a new page on POST and GET requests to replacing the page via AJAX. Loading the ExtJS library (even a relatively small custom version with just a few widgets) on every page load is a serious performance drain. Adds a couple of seconds, at least. So, it's pretty much impossible to use ExtJS in a traditional web application until it has been converted to a completely AJAX application (one that *never* loads a whole page after the first load).
I think the word you're looking for is "fanboys"
This makes me feel old. I remember the days before jQuery...
dude! figure out what you want to tell people before you get up there. 9:30 minutes in and he hasn't really said a thing. 
wow. 3 minutes trying to find a network, then he tries to look at code at CNN.com, gives up and spends a minute going to Twitter. this is really bad. 
How can this not have John Resig or someone represnting jQuery?
He was going to make an appearance but could not exit his home. He was smugged in.
No, not more functionality, more documented, formal UI scaffolding. Mature - years old. Updated frequently, building from what was before. When someone says "YUI menu" to me, I know exactly what they mean, how it's defined, and there are many many people using the same thing. jQuery menu? As least from what I see, there's dozens, if not hundreds of implementations. This is great for variety and innovation, but for other environments, like a large business, they are not keen at rolling the dice to find out which one is best, or which one will die and which will be around in 3 years. Or finding someone who can pick it up when their developer(s) leave. All that said, I would personally rather be using jQuery, and have the flexibility. jQuery + pugins can do everything YUI can and more. Hell, the base jQuery selector engine + code is wonderful! It's small, fast, and coding with it seems sleek compared to the clunky statements like: YAHOO.util.Event.addListener('elemID', 'click', fn) and jQuery: $('elemID').bind('click', fn); It's very late, hope that made sense! [edit - it's a new morning/afternoon and i reorganized]
Oh man, the ability to keep all `on...` handlers is one of the selling reasons for jQuery. As is the chaining which - wow, man - can be broken into multiple lines. And the third worst practice is partly true, but adding a comment that explains obvious things is just.. dumb.
fuckenfuck .wait() is not a thing
I've used it on various projects to various degrees and it's impressive. Lots of functionality and great to get things up and running from scratch. Documentation is so-so. Sure the API is there but there's no examples and things can be confusing. As others here have said, trying to get things to work with existing markup can be difficult (setting up a date widget to appear off an input should've been straightforward but any examples I found were outdated. Did finally manage to get it going...) Lots of great functionality and well thought out. If you need to get a web app up and running fast (especially with that Microsoft/enterprisey feel) then ExtJS is a direction to go. 
cause jquery isn't javascript I guess. I looked at /r/jquery, only 4 or 5 links posted, in spite of 190 subscribers. Hmmm.
I use it. I'd say that if you are thinking of making a web app that is supposed to function like a desktop app, and you're doing it from the ground up, then Ext is great. Otherwise, it might be a bit too much, some very nice touches in there, and a LOT of good code to work around some really heinous browser bugs.
And of course the framework posting the test wins by a landslide. I guess I'll have to check it out.
The article is ridiculous; the guy misses the point completely. 1)separating code from html is a big coding advantage and maks maintenance easier (1 place to change instead of many). Since the setup cost is trivial, why complicate the code?!? 2) chaining is much more elegant and less verbose than std coding. Since typing is coding, less typing means being more efficient. (duh!) 3) chaining does *not* have to be in the same line. duh. 4) comments: wtf does this have to do with jQuery specifically?
Yes. Nothing to see here...
jquery kicked everythings ass in chrome
I predict we will still see the exact same headline 20 years from now. I did get a kick out of this line from a [previous submission](http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html) though: &gt; 1995 - Brendan Eich reads up on every mistake ever made in designing a programming language, invents a few more, and creates LiveScript. Later, in an effort to cash in on the popularity of Java the language is renamed JavaScript. Later still, in an effort to cash in on the popularity of skin diseases the language is renamed ECMAScript.
this is pretty fun stuff. is there a way to do i/o in spidermonkey?
Just in? Javascript has been getting massive hype for the last few years. Good article, but the author is a bit late to the party.
it's much easier in rhino, since you get access to all the standard java apis. spidermonkey is mostly just a bare-bone js interpreter. You can echo things to stdout, and there might still be a file object lying around, but if you want serious i/o, you'll have to recompile a shell with your own custom jsobjects added to do it. 
Extending Object is baaad.
...and then Microsoft will patch IE just to make that pattern work.
You would think so, but I went to interview with a company you would expect to be on top of these sorts of trends, and the javascript questions all involved DOM interface stuff. When I expressed concern, the interviewer asked rhetorically, "What is javascript other than DOM stuff?" Sad day.
Anyone who actually has learnt Javascript should know this. It's just script kiddies who read a W3 school tutorial and think their pro javascript programmers who would find this article interesting. 'Oh there's more to javascript then copying and pasting basic example code from other websites, i didn't know that!' - is what those script kiddies would say.
Agreed. Object prototypes should be immutable. Having said that, JavaScript would have been a much better language if you can redefine the object prototype in a limited scope, thus not affecting other code outside that scope. 
Heh, nice, except this appends every key you press while on the page to an increasingly long array, then scans the entire thing on *each keypress*. That's not exactly great for sites where users are going to type any significant amount of text. Here's what I use on my sites: if ( window.addEventListener ) { var state = 0, konami = [38,38,40,40,37,39,37,39,66,65]; window.addEventListener("keydown", function(e) { if ( e.keyCode == konami[state] ) state++; else state = 0; if ( state == 10 ) window.location = "http://53cr.com/secret"; }, true); }
That's vastly more efficient and concise, although it misses cases like "UpUpUpDnDnLtRtLtRtBA" since the state will reset to 0 at the third Up instead of going back to 2 and going from there. /and yes, IE users don't deserve cheat codes. 
JavaScript has been the superior choice (just considering JS and VBScript, as those are the only ones guaranteed to be in every WSH install) for scripting in Windows Script Host for a long time. Despite the fact that all of MS's examples are written in VBScript.
Or it could use shift() to remove the first element of the array so the buffer is always less than or equal to the size of the code buffer. var code = [38,38,40,40,37,39,37,39,66,65], buffer = []; window.addEventListener("keydown",function(e){ while( buffer.length &gt;= code.length ) buffer.shift(); } buffer.push(e.keyCode); if(buffer === code){ //do secret suff } });
That's just a quick prototype, I've only tried it on Firefox and it's far from perfect. I just wanted to know if you think that's an idea worth researching or not. (of course the effect could also be applied at the top of the page)
Interesting, I didn't know I could invoke the debugger programatically. :)
Downvote anything about IE6. Stop supporting, hacking and developing for that hunk of ass.
It must be a wonderful world you live in, where the corporate customers who pay your salary aren't forcing you to support IE6. In the meantime, I'll take whatever help I can get. Edit: To clarify, comments along your lines really bother me because it implies that developers are being stupid for supporting IE6, where that's just not the case. I don't think I know a single developer who doesn't say "IE6" without malice; but the fact of the matter is, a lot of us have customers who forces companies who force us to support IE6. Corporations are afraid of change, so they stick with whatever browser everything was developed in. In other words, it's typically not the developer's choice to support IE6 or not, it's the customer's.
Grow up.
Just smoked one and this made my brain hurt.
firefox on a 1.5ghz celeron, rendered so slowly I was dead before I could see the map.
This person's initial problem is that they are wrongly assuming `document.body.appendChild(element)` is the same as `Element.prototype.appendChild.call(document.body, element)`. You must use `HTMLBodyElement.prototype.appendChild.call(document.body, element)` instead. This is because document.body.appendChild and Element.prototype.appendChild **not** the same functions.
It's all nice and good, but why can't people use some other word for function-like objects? It's especially confusing because FP and especially Haskell people normally use the word "functor" in its original mathematical sense: a function between types.
As your comment is about IE6...
Firstly pick a video about javascript, the one from yahoo, you don't know javascript or something like that. Than find video about Firebug and finally learn jQuery
Doug Crockford?
Yeah the Crockford vids are great. But as far as "finally learn jQuery" that is left up to what you want to do with JS, that is the whole point of the article.
Jquery is a great way to get a project out rapidly. It is light weight too, I love it.
Mootools and jQuery are not the same thing, I wish people could get their head around this. jQuery is a framework for doing common tasks easily. It includes a lot of helpers for referring to DOM nodes etc. It' major power is as a plugin framework. There is a huge community out there making awesome plugins. Mootools is a base set of classes for javascript that adds features that should have been there in the first place. The main Mootools library actually has features removed more often than added when new releases come out. It's more of a library to make it easier for programmers to write one off plugins themselves.
Yeah they arent the same thing in that jQuery cannot do what MooTools can, but MooTools can do what jQuery does. 
[Do**u**g**las** Crockford][1], please learn how to Google stuff. [1]: http://lmgtfy.com/?q=crockford
Dojo is the best for making modular applications.
here's a link to get started: http://pastebin.me/4a149db8314c7 pretty interesting, takes all the fun out of it, making html that's search engine indexable, that is
You don't need `&lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt;`, the IE team figured out that was a terrible idea so IE8 defaults to the latest rendering engine as long as a page includes a `&lt;!DOCTYPE html&gt;`
1. It's not tiny. 2. It's not valid JavaScript so there is an overhead in parsing your code. 3. It's a neat gimmick.
John didn't implement main function being talked about (`Object.defineProperty`) so none of the examples that use it can be tested normally (except for on IE8, which _does_ natively support `Object.defineProperty`). If you would like to try out his examples, I have a partial (doesn't support `false` for `writable`, `enumerable`, or `configurable`) implementation of `Object.defineProperty` in my public domain [Xccessors][1] JavaScript library. [1]: http://code.eligrey.com/xccessors/standard/latest/xccessors-standard.js
"doesn't support false for writable, enumerable, or configurable" Isn't that the whole point though? Also, the fact that you can't actually get the descriptor values back out again, you just have to guess. I didn't see a reason to provide a sample implementation that would be intentionally broken.
It's so you can code using `Object.defineProperty` __today__ and not have to wait until it is implemented in a browser that currently doesn't support it. For getting the descriptor properties, at least you can still get the important ones (`get`, `set`, and `value`). My library is only meant for transitioning code legacy code or making new code that doesn't need to take advantage of writable, enumerable, or configurable.
&gt; I'm still not quite sure how it process these though .. &gt;&gt;&gt; b * a 1.544930730887957e+24 &gt;&gt;&gt; b / a 1.000000048751666 Simple. When Dates are coerced to numbers you get the Unix timestamp values (seconds since 1/1/1970. actually they're milliseconds, so 1000x a unix timestamp) I bet the square root of that "b * a" is approximately the time you tried it: js&gt; Date(Math.sqrt(1.544930730887957e+24)) Thu May 21 2009 17:33:45 GMT-0700 (PDT) 
Correct! Thanks for the explanation.
What about JSON? That's the de facto standard for information interchange with JavaScript. PHP (which is used in the first example) even has native JSON encoding and decoding functionality.
Cheers, I use JGrowl and server side assigned session objects to automatically inform users of results actions taken in aspx pages. But I never thought of the URL path...
yeah, I thought for a second the page would be "JSON" in giant black letters. I use ASP.NET MVC and that's how I transfer all my data back and forth; through JSON.
&gt; Man, JavaScript is turning into a messy pile of hacks. How can we fix this? ` ` &gt; I know! Let's define some magic string literal that, when found in the code, will fundamentally change the behavior of the language! ` ` &gt; Great Idea! This will make the language so much better! More seriously, a bunch of those "strict" changes impact significantly the amount of work required to sandbox untrusted scripts running within a web page. It seems odd that the way to enable that is a directive that will silently fail and go on as if nothing. 
Extending `Object` is a good solution to many problems imo as it doesn't introduce any new globals or prototypes. I'm assuming you mean `Object.prototype` instead.
JavaScript already supports this. It's called making your own constructors. function foo() {}; foo.prototype.a = 0; var bar = new foo; typeof bar === "object"; bar.a === 0; bar.hasOwnProperty("a") === false;
Learn Javascript first, then use libraries depending on the situation.
The corresponding blog post: http://eligrey.com/2009/05/23/edit-page-jetpack-feature/
These results are very biased due to the fact that the person tested Chromium's latest nightly but only tested outdated betas (not the nightlies) for Firefox and WebKit.
especially if you drink it over some shredded wheat or grape nuts.
cool!
Dood old days &amp; games. Looks cool!
Nice, but the timing could use some love. In the beginning they're practically stationary, and by the end, the last one was crossing the screen in a fraction of a second.
Playing games really makes you notice the performance of the supporting system. Firefox 3 seemed as choppy as ever.
1. Go to stackoverflow.com 2. Post question. 3. Profit.
yea - saw this in my feedreader, wanted to post the same. Maybe #3 = learn javascript
Actually, I was talking about redefining object prototypes like Number, Object, and Array in a limited scope so you can safely monkey patch without affecting other code.
You can just as well reuse jQuery selections by storing them in a variable. var $container = $(".container"); ... $container.show(); 
I know that this may not be the place to say this but I've been working on a similar script that does url dispatching and also templating and data handling (finding/filtering, add/remove, etc). I've been working on it for a few months (on/off) now and even tho it works (mostly) I didnt release out yet as it seems that not many people would find it useful. The framework linked here does a fraction of what I'm working on and it seems that not many people are into these stuff (8 up/7 down votes). So I'm curious and have to ask, is having so much functionality on client side (with js) such a bad thing? Why is it that there are not so many people into these kind of stuff? I would think that with the increasing use of a window's hash location as a starting point (e.g. see facebook) there would be a ton of libraries trying to tackle the problems raised with this kind of ajax interaction. What do redditors think of this? 
It really depends on the application. Like you've mentioned, there is definitely precedence for it (Facebook, Gmail). If your application requires Javascript anyway, I don't see a problem with it it in most cases. I wouldn't use it for any pages that need to show up in a search engine. In fact, I think the reason you don't see this more is that many feel they have to code things twice (javascript/non-javascript version) to be compatible with mobile and search engines. 
yeah the obvious reason is search engines, I would never use such a method on a public facing production setting. I mostly use it either for prototyping/proof of concept stuff and, most importantly, for admin stuff where you are allowed (sort of) to say 'this needs js, and you better not be a search engine'. btw has anyone looked at the source of gmail, reader, facebok etc to see how things get done? I tried once but got too bored to really figure it out.
I haven't looked at Facebook, but Google compresses their public facing js (and I wouldn't doubt FB does the same thing), so it's not the best place to read. I also haven't coded a site using the system, but my understanding is that you use a timeout to check if window.location has changed, and if it has, you parse the new arguments (the stuff after the hash) and perform the corresponding action in your Javascript application. It's almost exactly like routing/dispatch in a typical MVC setup, which makes Sinatra a good API to base a library off of.
Great article. Simple implementation, but very powerful
That appears to use data: urls with &lt;img&gt; tags. I'm pretty code that'd target a &lt;canvas&gt; tag would be smaller and simpler, although it might not have the same browser reach just yet.
This is so unbelievably awesome. I know there are similar things out there already, but for a number of reasons none of them were exactly what I needed- this however is perfect, and its use of json for making the graphs is going to make it ridiculously easy to put together some PHP classes to wrap around this. 
Yes, but it's using canvas tag to generate data:... urls, ie. everthing gets draw on canvas tag, then data gets "exported" to img tag as PNG image, not sure why?
For letting you save the images I guess.
Fall-throughs in switch statements are perfectly valid and are one of the major reasons for the existence of the statement in the first place (it isn't exactly unique to javascript). Though Crockford never really explains it online, but apparently he explains his reasoning in his book, and the main reason is that it can lead to unclear code; if anything, the alternative is worse. I suggested that he require something like /* jslint: fall-through */ as an acceptable alternative to break in jslist awhile ago, and I know others have too. 
The built in debugger, in my experience, works much better than Companion.JS
There's a lot of things Crockford states you shouldn't use because it has the potential to cause harm. His rules are great for newbie programmers, but once you're experienced I would take them more as guidelines than rules.
Until a good chunk of those guidelines are implemented as part of the language itself, that is :'( "use strict"; 
Didn't know about === and !== - thanks. &gt; Use of tabs should be avoided because (as of this writing in the 21st Century) there still is not a standard for the placement of tabstops This could change in the next 90 years.
These are extensions not plugins. 
Somebody ought to write a book named "Javascript: The Naughty Bits", with all the awesomest and dirtiest hacks javascript has ever seen. And dedicate at least one chapter to the subtle art of writing obfuscated javascript that stays incomprehensible, even after your cut through the few layers of eval(). 
You can also check to see if the meta key is down. This works as command on a mac and control in windows and linux. http://www.w3schools.com/HTMLDOM/event_metakey.asp Also, quit ripping off other people's work, and indent correctly if you do. http://www.scottklarr.com/topic/126/how-to-create-ctrl-key-shortcuts-in-javascript/
This method can always lead to shortcut collisions. IMO, the best solution (which is also much easier) is to just make a hidden `a` element with `accesskey` and `onclick` attributes.
Blog spammer. Here is the unstolen link: http://ajaxian.com/index.php?s=demystified&amp;searchbutton=Go
I never pretend to be the author of the video. RIATube is a *directory* of videos on rich interface applications development, trying to find, classify and promote good things done by others ;o) If it is possible I embed the video, otherwise there is a link to the original url.
I must say, this is fairly impressive. Look forward to using this at work.
It's not mentioned in the tutorial, but when you are doing equality tests with the double equal sign, JavaScript will do a type coercion __before__ checking for equality. While a triple equal sign will not. So: false == '0' // True false === '0' // False
How do you make games on Palm Pre with Javascript? :)
Guess 1: You write a script that behaves like a game Guess 2: You just snivel marvelously at yourself that there's no C++ programming involved
This is bad code. Firstly, you're using inline javascript when you should be attaching your event handlers unobtrusively without adding cruft to your markup. See this link for more on unobtrusive JS - http://ajaxian.com/archives/unobtrusive-javascript-rules-to-work-by Second, your CSS rule of display: none; prevents this content from being accessible to any devices other than modern desktop browsers with Javascript enabled. This cuts out screen readers, many mobile phone browsers and possibly many other user agents. All content hiding should be accomplished with javascript, so that user agents without it never hide the content in the first place.
How does this article manage to get 7 up votes? It's basically *the* simplest DOM manipulation possible, and it's done badly.
thanks a lot I am gonna use this ....
Should be noted that Safari 4 and IE8 (and probably Opera) all have debugging tools that can do _most_ of these things too :) There's also a non-plugin version of Firebug that you can use in any browser simply by calling in the JS file: http://getfirebug.com/lite.html
All I see is 11 reasons why you should use PNG instead of JPEG for screenshots.
The artifacts, they burn!
 11. You weren't using that extra gig of ram anyway.
I use the inspector in Safari/WebKit.
This is the best new feature of Safari 4. Luckily I didn't do the update and still have the sweet tabs too. 
Does it bother anybody else that you have to use Firefox to use Smushit? Their standalone service was nice. I primarily use Safari 4 so that's the only thing I don't have out of firebug.(yslow is not useful if you already know the rules of thumb)
Nicely done. :) Edit: data urls don't work in IE iirc.
Well they do in IE8 as long as you're using them as background images.
Haha, I just 'uploaded' a 10MB movie. That took forever :P But for real hosting, i wonder if a url shortening service will accept this as a 'long url' and give me a short one :)
aw, I can't link them in comments :(
You made a more reliable filehost than the one that I've never heard of having problems, and it only works in one browser? Sheesh.
It doesn't work out of the box http://tinyurl.com/l37jbd just takes me to a blank page Firebug isn't giving me anything so I don't know what information is being sent back and forth
14th most hideous website ever made.
The inspector was introduced in safari 3.1
&gt;Advanced Instajax™ technology developed by Elijah Grey hacks your browser and pre-uploads files that are determined to be most likely to be uploaded by you. It determines this based on your most recently modified files. WTF?
it crashed before i could even select the 100MB mp3 filebrowser opens. i click on the file. i click "select". firefox stops reacting. thank you very much
Does the inspector let you edit and create CSS styles on the fly?
That's your OS's file selector's fault. If you tried to select it while uploading to any other site, the same would happen.
Testing that out. **Edit:** Yep, you're right.
To all the downvoters: This is just the file-uploading part of the [data: URI kitchen][1] implemented on the client-side using `&lt;input type="file"/&gt;`'s `FileList.File.getAsDataURL()` method. I guess people can't take a joke. [1]: http://software.hixie.ch/utilities/cgi/data/data
Well you can't create them for new classes, but you can edit any CSS for any tag, class, id. 
faster, easier to use, and still years behind jQuery. YUI sucks.
Its e-garbage like this ...
I can't help but be wary of any article that refers to jQuery as JQuery.
nice approach with minor flaws. what if i want to go back 1 month and 13 days from the current date? Can i chain .advanceMonths and .advanceDays together in this case? IMHO it would be more consistent to implement a Timedelta class here, that can hold time differences from microseconds to years (cf. Python's datetime.timedelta). it would also be nice to have rule-based date calculation (which date is the second sunday in august?) AFAIK these features aren't yet offered by Javascript date libraries.
Urgh, ugly.
I can't help but be wary of any poster that submits the same article under 2 different titles
wow. I would hate to be tech support for all the people that follow this and can't figure out why none of their websites work anymore.. 
...by creating hundreds and hundreds of DIVs, instead of using an image or using a modern solution such as CANVAS.
True, but using an image might cause the site to take an SEO hit, because the text wouldn't be crawlable by search engines. I thought that was the main reason for all these text-styling plugins?
I was trying to figure that out myself. It seems like a poor example. It hard for me to find out which object.function they were using in the documentation. They say that they are using selectors, but it seems that their example is using a shortcut to the [node class](http://developer.yahoo.com/yui/3/api/Node.html). It appears that the node class is specifically designed to work on only one element. The [selector class](http://developer.yahoo.com/yui/3/api/Selector.html), which is in the dom module, is the one that should be used here. The filter method does what you are referring to. edit: I agree with you though. It doesn't help that the YUI library is very poorly documented. That's why I stopped using it.
Oh, dear, please no.
Not necessarily. You can use a background-image with CSS. HTML: `&lt;h1&gt;Foo&lt;/h1&gt;` CSS: `h1 { text-indent:-9999em; background:url('dataurl'); height: Xpx; width: Ypx; }`
Isn't that what the alt attribute is for?
I saw a snail ... crawling along the edge of a straight razor. The horror. The ... horror.
&gt; jQuery's each function takes over 10 times as long as JS native "for" loop. This will certainly increase when dealing with more complicated stuff, like setting CSS attributes or other DOM manipulation operations. Um, no. The higher the cost of the operation in the loop, the less the looping overhead will matter.
Or try this: CSS: text-shadow: #999999 2px 2px 2px;
I almost feel bad for the person that wrote the plugin.
This is horrible advice, especially the first tip. It encourages you to link to the latest version of jQuery on Google Code, which is asking for trouble. jQuery changes fundamental behavior between releases that will break websites which automatically include the latest version. For example: http://illuminatikarate.com/blog/relative-offsets-are-handled-differently-between-versions-of-jquery/
Actually, it is linked by version with Google, and Google promises to keep older versions. However, what I found is that Google's own website can't keep up with the load and so I end up finding my site runs faster when I load jQuery from my own dedicated server than from Google. Seems Google isn't allocating enough resources here, oddly enough.
1 Potentially breaks a site 2 Speeds up downloads but not script execution speed 3 Native JS will always be faster than library calls. In practice this is negligible. 4 and 5 are actually good tips 6 &amp; 7 are true for all JS not just jQuery and any JS developer should be doing these 8 is true in nearly all languages. 9 WTF? This has no impact on jQuery performance 10 Obviously the author ran out of steam here. So 2 decent tips. Nettuts, IMHO has a very low standard of articles, and I find it hilarious when all the comments praise the author about how smat - i mean smart - they are. 
Look again. In the start of the first tip they include a specific version of jQuery on google.com. However, at the end of that tip, they suggest including the latest version instead, and provide code to do so. I left a comment on their blog as well. Hopefully they'll take that bit down before anyone else follows this bad piece of advice.
The parent company of that site and a few others they run seems to have a policy right now (I've noticed) of moderating the comments such that only the good ones come through. I guess if they don't get criticism, then they become more popular, and their ad revenues increase. But that only lasts so long until there's a public backlash.
I remember how way back one of the sister sites posted an article asking for readers to submit articles. It was almost hilarious when several commenters replied with something like "Great post! Will get submitting!" Still, they hadn't started censoring bad comments yet back then since some did mention the above.
Thanks for the linkage. If you find any bugs or have any suggestions for the library, please let me know.
This doesn't work in Safari, at least partially due to Worker being called as a function, not a constructor. eg. the code does "wkr=Worker('pureWorker.js')" and similar in multiple places when it should be doing new Worker
Whoops, thanks olliej, I'll get that fixed.
Fixed now in the blog post and the live code. I don't have Safari here and have not tested it, but I'm thrilled to hear Safari also has Workers support already!
The plans for YUI 3 actually kind of disappoint me. I always thought of YUI as the more complete library widget-wise, whereas jQuery was a better performer for creating your own widgets. YUI 3 seems to be embracing a lot of the things that jQuery (and similar) frameworks add, but if they release with few widgets then there's no compelling reason to switch. (In particular, I've made extensive use of their Menu component, and that's not even on their roadmap...)
Have you seen [bubbling library](http://www.bubbling-library.com/)? I'm not sure if it works with YUI 3, but it extends YUI's already large widget library.
So you basically move the text off the edge of the screen and use the image instead? Pretty cool idea! Do you have any examples of pages that do this?
According to their site, it's "comming soon" for YUI 3.
Sure. Unfortunately none of my recent stuff is up (I'm not really a regular web guy), but here's an old example: http://flashcubestudios.com In this case, the image is the entire banner. It should be a clickable link, but i think i forgot to make it display:block. Anyways, hope this helps.
This is now fixed and tested it does seem to work great in Safari 4 with Workers support.
I find the optimization at the bottom pretty questionable. Javascript function calls are kind of expensive, and I'm pretty doubtful its faster than an if call. But I'm just arm-chair hypothesizing.
Why would you want to reinvent the wheel? Use jQuery...
-&gt; http://www.raleigh4u.com/section/corporate-headquarters1 Menu popup disappears after you hover over it and then try to hover over one of the items... tested in Safari 4
I've been using this since a few weeks now for a simple library that I am replicating to learn JavaScript. TDD is obviously a great way to make sure that the code I am writing does the same things that the original library does. JsTestDriver is potentially a good framework. But one nagging thing that keeps coming back at me again and again is that it often fails to identify and load the library and test source files on first attempt. It only manages to do so after I edit the configuration file to an invalid path and running the test invocation command (which fails in a null-pointer error in Java), then restoring the configuration file to its original state and running it again.
Warning: The masked input plugin is broken in IE, I've notified the author but haven't received a response or update. I fixed the code in mine however. Basically, if your masked input ends with a mask character instead of a user input criteria it will always fail in IE. This is because strings aren't treated like character arrays and there is a condition that checks the test to see if "filter"[1] == test or whatever, the fix is to change it to "filer".charAt(1)
putting your scripts at the bottom might make them load faster, but if you use progressive enhancements it might also cause a noticeably flash of unenhanced content.
=== absolutely equal to == similar to This is lesson 1 in Javascript. 
And don't forget !== , the more exacting cousin of != .
=== : strict equal -- objects are compared (essentially) by pointer, no type conversions happen, although 0 === -0 == : non-strict equal -- primitive values (string, number, bool) are compared by value if both types are the same, otherwise if either argument is a string then [[ToString]] conversion occurs on the other. If either argument is an object then [[ToPrimitive]] conversion is performed on them, and comparison is performed on the results.
I recently had to learn Javascript for work, and I mainly used two books: * http://oreilly.com/catalog/9780596101992/ - to learn the core language * http://oreilly.com/catalog/9780596517748/ - to learn ... the good parts :P Excellent mini-reference on the 'gotcha's of the language. Also, the author works for the company I'm at! That said, I'm not sure how well they'd serve as a 'textbook'. Neither, despite being good reads, were very instructive. More like references.
Those are good books. Depending on who you are teaching this to, I would recommend having them learn jQuery first. It cleans up many of the problems with JavaScript, making it easier to learn, without hiding the good features of the language.
I really like the articles at [developer.mozilla.org/En/JavaScript](https://developer.mozilla.org/En/JavaScript) see [Core JavaScript 1.5 Guide](https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide) and [A re-introduction to JavaScript](https://developer.mozilla.org/en/A_re-introduction_to_JavaScript) is nice 
Q. "How do I do that in Javascript" A. "You dont. You use JQuery" [book](http://www.manning.com/bibeault/) 
Teaching them a framework instead of JS is very dangerous!
I will add these to the student resources site. Thanks!
I ended up recommending O'Reilly's [*Learning JavaScript*](http://oreilly.com/catalog/9780596521875/), as the others are aimed more at people who already know some JavaScript.
Javascript itself is a beautiful language that needs no hiding, just wrapping head around. It's Javascript's interaction with the DOM that's really messy. Either way, it's probably not a good idea to hide either behind a framework for a novice.
I came to post the same links :)
javascript the good parts, hands down.
This is a good book, as well as Douglas Crockford's online content. I would also recommend Professional Javascript by Nicholas Zakas.
YMCAScript
Teach them assembly instead and ask them to code JS in that. Much less dangerous.
javascript.
JavaScript
JavaScript to be proper, Javascript to be lazy. *Damn, Firefox thinks Javascript isn't a word, but JavaScript is.*
In most places, just JS. Otherwise Javascript.
I'm kind of amazed that two people have suggested learning jQuery instead of native JavaScript. As an aside: document.getElementById("foo"); *31 bytes* $("#foo"); *19 kilobytes* While I have no intention of letting my students anywhere near a framework (they're allowed to use them at higher levels in the course), even if I did, I would probably pick MooTools over JQuery as it adheres more closely to standard JS (and OO) syntax and conventions.
I accidentally called it [ESCM](http://en.wikipedia.org/wiki/ESCM) Script once.
&gt; I would probably pick MooTools over JQuery as it adheres more closely to standard JS (and OO) syntax and conventions. I learned JS and basic OO principles by writing MooTools classes and working backwards. I think I actually would recommend *JS: The Good Parts* for new learners, but you would be best to introduce it partway into the unit once you've gone over the basics of structure and such.
I love that book -- it might be my favorite JS-related book ever -- but for learning? I don't think that it's a good book at all, for someone who's never written any JavaScript before. It's a great book for people familiar with the language, who want to learn more. But not an intro text.
Be careful when you extend native types in JavaScript. You can't be sure that other libraries (let alone future versions of the browser) haven't already taken up String.prototype.format, and your implementation simply blows them away. If you want to be safe, just name a function formatString (or better yet, create a namespace for your code, and stuff it in there).
I am partial to Crockford's remedial javascript's supplant method: String.prototype.supplant = function (o) { return this.replace(/{([^{}]*)}/g, function (a, b) { var r = o[b]; return typeof r === 'string' || typeof r === 'number' ? r : a; } ); }; Which you'd use as `"{welcome}, my favorite number is {number}".supplant({welcome:bar,number:foo});` It feels slightly more javascripty, and the string template are better self-documenting, which can help with the localization process. Usual caveats on extending builtin prototypes apply..
JavadabadooScript... or js... or JavaScript.
It uses feature detection to test the current browser against new features, providing an easy way to fallback in browsers that don’t yet support them.
I'd worry less about libraries that define `String.prototype.format` and more about libraries that define _new globals_ (like `$`) without checking if it's already defined.
First to say, nicely done (if it works in all cases) :D
Link might be helpful http://www.modernizr.com/
Wouldn't it be easier to handle this function in a new Javascript thread? You can use AJAX to call a webpage and when the XMLHttpRequest object's onreadystatechange property fires the first time you can perform your function. Now you've officially forced your function into a new thread and let the page load. xmlhttp.onreadystatechange=function() { if(xmlhttp.readyState==1) //we just care that it's initialized { dowork(); } } Edit: I forgot that when the AJAX onreadystatechange function fires off it does block the webpage (thanks fforw), but what I wanted to get at was you could do the Javascript loop on another webpage. Webpage 1: build a &lt;ul&gt;, call AJAX to the other supporting webpage Webpage 2: build all &lt;li&gt; tags while Webpage 1 is still loading Webpage 1: when Webpage 2 is finished (readyState == 4) load the &lt;ul&gt; with the content from Webpage 2
I dabble in JS and afaik JS doesn't support threads. At least the current versions do not. The only way to simulate it (a la multi-tasking in the old Macs) is to use timeout to introduce some sort of timeshare code execution. Read the comments here: http://ajaxian.com/archives/javascript-threading-and-continuations
and it break the for in loops
It doesn't. `"{{0}}{1}".format('1','foo')` will give `"foofoo"` instead of `"{0}foo"` (like C#) or `"{1}foo"`.
except for the newly introduced WebWorkers, javascript is strictly single threaded. the AJAX callback will just block everything else, too.
More of the internet need to start thinking like this, it's so frustrating when you're trying to do something and the website chugs.
Asynchronous JavaScript And XML (AJAX) is multi-threaded, hence the Asynchronous part. I'm not sure about the true implementation, but it sure does act like a new thread when you create a new AJAX query. [This article](http://www.devx.com/asp/Article/29617) explains a similar situation to the one provided in the OP's link. The author describes a webpage that could take a minute to return a page. He discusses the different types of fixes and finally goes into the AJAX method. He uses C# for his example, but the method is the same.
the asynchronous in AJAX refers to the fact that the call does not wait until the request is finished. The response event will be executed single-threaded, just like every other js operation. Look at [this example](http://fforw.de/static/test/nothreads.html) created with jQuery for convenience. it shows show content being changed in a short interval. The button requests the document per ajax and then creates 10000 divs. During the time the divs are created, the animation stops on the page.
&gt; Asynchronous JavaScript And XML (AJAX) is multi-threaded, hence the Asynchronous part. Wrong and wrong. &gt; it sure does act like a new thread when you create a new AJAX query. and wrong. 
&gt; Edit: I forgot that when the AJAX onreadystatechange function fires off it does block the webpage (thanks fforw), but what I wanted to get at was you could do the Javascript loop on another webpage. &gt; Webpage 1: build a &lt;ul&gt;, call AJAX to the other supporting webpage &gt; Webpage 2: build all &lt;li&gt; tags while Webpage 1 is still loading &gt; Webpage 1: when Webpage 2 is finished (readyState == 4) load the &lt;ul&gt; with the content from Webpage 2 Scripts on a page loaded via Ajax run in the page that made the call. There is no way for scripts on another webpage to affect the current page. There is only 1 JavaScript thread. Ever*. Which is great, because you never have to worry about synchronizing, or that your function might get interrupted, or anything like that. The only way you could save UI processing is by having the server fully render the LIs and use that text to fill in the UL. \* [Web Workers](http://www.whatwg.org/specs/web-workers/current-work/) allow background threads, but they are not allowed to access the page content. They can pass a message back to a callback, but the callback runs in the single JavaScript thread on the page.
http://bifgis.com/ Just coded this last night and remembered your question. This is a better example of the technique :P Probably long off your mind now, but just in case you were still interested.
brake -&gt; break.
Is Flash awesome or what? BTW, how come html 5 doesn't have its own cross-domain XHR yet? 
It does. Also, instead of using proprietary Flash technology, you can use HTML5 postMessage XDR XHR: [pmxdr][1]. [1]: http://eligrey.com/blog/projects/pmxdr
That's a hack, though. having to create an iframe on every domain you need to talk with is expensive, and in some case, inpractical. Plus the fallback methods for browsers that don't have html 5, while creative, are definitely on the gross hack side of things. What actually needs to happen is an XMLHttpRequest object that accepts external domains, looks up for some kind of standard authorization (header, crossdomain.xml or whatever the Open Web Gods desire) and just fetches the darn stuff. Anything else is just sub-optimal stuff to get by until then. 
True. The one downside here is that you give up some security. Normally, in a cross-domain request, the originator chooses what to do with the response, and doesn't need to fully trust the site it fetches data from. With the script approach, the external site suddenly has full control over your own, before you even have access to the data. It's nothing you're not already doing when you load a google analytics script, but not every site ought to be given quite as much access to your own. *edit: It's not the same level of security you get when you eval(xhr(someJSONAPI)), because most reasonable implementations will actually use eval(validate(xhr(jsonAPI))) so the data returned will only get eval'd if it strictly matches a JSON data structure with no code execution.
There is still a big market share of IE6 and IE7 (Errrrrr I hate them) So plus some evolving market of mobile with browsers not sophisticated yet so we just can abort them. 
There are already JSON libs for every major library. JSON will continue to become more and more rampant as JavaScript on the Server grows. JSONP is incredibly easy for cross-domain data. It is a necessary piece of a web dev's toolbox. Also my friend Jason likes to think a data format is named after him. Don't ask about JSONP.
Appreciate it all the same. Thanks! 
Is there a nifty interface for JSON, like E4X is for XML?
Yet another article which muddies the waters between JSON (a data interchange format) and JavaScript Literals (syntax for defining JavaScript objects in a convenient manner). This is *not* JSON, this is JavaScript: var jason = { "age" : "24", "hometown" : "Missoula, MT", "gender" : "male" }; It doesn't even bother to explain how you go from a JSON text to its JavaScript representation, it's all hidden behind jQuery.
Ugh, yes. This article is terrible. The author apparently doesn't understand the difference between a data structure in memory and a data serialization format.
This might be an easy way to make a Chrome extension to support mouse gestures, since Chrome extensions are written in javascript.
Any hints or community to do this?
I'm not sure what his point is. Is he saying that JavaScript framework development is essentially finished and that everyone should use one of the existing frameworks (i.e. jQuery)? A web site as large as the BBC is perfectly entitled to develop its own framework. They have millions of users and support a multitude of platforms. jQuery, Prototype and the rest are hobbyist frameworks built before JavaScript was taken seriously. John cannot complain that the big boys are now playing.
No - that's not what I'm saying. The BBC, by their own admission, is building something primarily designed for the BBC (and their developers). I absolutely have no problem with this and even mentioned as much in the discussion - that is their prerogative. However, their original impetus for creating the library is flawed: They wanted support for two specific browsers (IE 5.5 and Safari 1.3) that jQuery no longer supported. Instead of filing bugs, providing patches, or even contacting us to begin with they decided to go off and spend (at least) two years constructing a completely separate library. I'd probably be more receptive if Glow was truly bringing something new to the table - but it's not. The BBC wanted to implement a library that they could control through-and-through rather than participate in any Open Source process. If I feel anything it's not anger or concern about the new library is more of a sadness. I just feel bad that they're putting so much effort into something that doesn't need to exist.
&gt; If I feel anything it's not anger or concern about the new library is more of a sadness. I just feel bad that they're putting so much effort into something that doesn't need to exist. So you lost a customer. Big deal. ;-)
&gt;jQuery, Prototype and the rest are hobbyist frameworks built before JavaScript was taken seriously. John cannot complain that the big boys are now playing. That's the funniest thing I've read all day. 
The thing is writing frameworks is kind of fun. It's more fun to write your own framework than it is to use JQuery. It's also nice to work with code you wrote, or was written is house, you know it back to front and that makes working with it less painful (actually painful probably isn't the right word here but I'm struggling to write what I mean). So just because it doesn't make sense from a productivity point of view it's far from surprising. That said, when I was working for the discovery channel I dropped my custom JS library when I discovered JQuery; your approach was infinitely better than mine.
What an ego battle. :(
Sure, using flash is a "hack"... but the way flXHR does it, with the same API as the regular native XHR object, makes it a pretty decent option for now. The goal for flXHR is to standardize on the already known XHR API for cross-domain requests, and then hopefully become unnecessary someday when the browsers converge on a better cross-domain Ajax solution instead of diverging into different policy models and APIs.
[Chrome extensions community](http://www.chromeextensions.org/) [Google's chrome extension docs](http://dev.chromium.org/developers/design-documents/extensions/howto)
It's not an ego battle, BBC decided to create a library which does exactly the same thing as the one which already exists, but for a browser with &lt;1% market share. Looking at the code, it does exactly the same thing, but it does so in a less-efficient way which is compatible with less browsers overall. It's not really ego, it's making fun of the company which is trying to reinvent the wheel, and doing so poorly and for no real reason.
&gt; A web site as large as the BBC is perfectly entitled to develop its own framework. A corporation funded by tax-payers money is *not* entitled to piss money up the wall. &gt; jQuery, Prototype and the rest are hobbyist frameworks Get back under the bridge, troll.
Dean, even if when I read his rant I think at the same thing, I now understand what he means... And, honestly I can't say he is wrong. Is not writing a new library that's wrong (despite the fact that there is already a plethora of actually **working** frameworks and libs http://ntt.cc/2008/02/13/the-most-complete-ajax-framework-and-javascript-libraries-list.html ) but the motivation behind the decision of not improve something already existent (throught bug submission and patches) instead of writing something new from scratch. 
Actually the *troll* is one of the most known javascript contributor and web standard promoter. And don't take as offense jquery, moo* started as hobbist frameworks ;)
Why would you want to do this? The point of showing ******** is so people walking behind can't read your bloody password!
So the first person who comes across this in the wild is going to think what exactly? Without explicitly explaining why the behaviour is how it is this just looks strange. And we know that to a non-tech person strange + password = hacking.
Neat, but it seems entirely unusable through keyboard navigation.
Frankly, it is an ego battle. All open source frameworks implicitly compete for their share of limited, open source contributing developer community to be able to survive and evolve. If one stands out and tells them continuously "everyone should use the A framework because it is better in many areas so we should concentrate our efforts on A to make it better faster." it is the resentment for diversity and competition between frameworks. jQuery, in this regard, is increasingly competes on the basis of marketing efforts instead of its technical merits. I won't dwell further on why "fracturing of community" is not bad at all regarding open source since most of us know the rules of survival for a project and convergence of great minds.
Good idea, never thought about it :). I could make it though
Exactly. On the iPhone it's slightly different as the on-screen keyboard shows what you are typing anyway. It's also much easier to conceal your typing using a handheld device.
I know it's hard for the little people to understand, but try: - Flash sucks. - Jakob Nielsen once said Flash was 99% bad. - Therefore, Jakob Nielsen is awesome. - Iphones are awesome. - Therefore, Iphone-like UIs that vaguely implement something Jakob Nielsen mentioned are doubleplus awesome. There. Now... More kool-aid? 
Not mine but I believe it's relevant: var b = new Boolean(false); b; // false !b; // ALSO false !b == b; // But this is true! !!b == !b // Negate both sides and it's false again. FUCK. if (b) { // Better fucking believe this will get executed. FUCKING FUCK. } 
I downmodded you just so I could click the up button twice.
As pointed out by commenters, this has nothing to do with JQuery and has poor browser support.
I didn't really learn anything new from this article, but I *did* appreciate the comparison between event handlers and COMEFROM. :-D
You're not going to get away from doing asynchronous calls if you're coding an ajax app (it's what the first a stands for). You *could* do a synchronous XHR call, but that means that all of your running code would lock up any time you had to communicate with the server. So, you really don't want to do that. I find that the best solution is to use something like prototype's [bind](http://www.prototypejs.org/api/function) (All libraries will have something similar). Then rather than your code, you could do something like: MyWebservice.prototype.method1 = function(result, params){ var callback = this.method3.bind(this, params) this.method2(result,callback); }); MyWebservice.prototype.method3 = function(params) { ... } 
Thanks for the suggestion! "Synchronous fashion" doesn't mean that I want to do XHR calls, I'm looking for a pattern that minimizes/hides those ugly, nested callbacks and makes the program flow more structured.
If you are not doing XHR or any operation that requires a period of time to pass before delivering a payload then why not just return an object containing whatever data and let the flow continue as usual?
I'm sure it was a lot easier to take a screen shot of the results rather than just have an example.
the screenshots - why?
"Single line of code" - I do not think it means what you think it means.
You've stumbled onto the reason that the 'event' concept exists. Event-based programming is well-supported in other languages, but I think in Javascript you'll have to roll your own event-system like this guy: http://www.josh-davis.org/2007/04/10/custom-event-listeners/ . Essentially you'd get to write: MyWebservice.prototype.method1 = function(result, params){ this.result_method1 = result; this.dispatchEvent('onMethod1Result'); }; MyWebservice.prototype.method3 = function(params) { alert(this.result_method1); } function MyWebservice(){ this.addEventListener('onMethod1Result', this.method3); } 
What about hallaback spaghetti?
As suggested already, `bind()` in its various forms make it simple to avoid crazily embedded closures. You might also look at seeing if any of your requests can run in parallel - e.g. if there are no data dependencies that require starting the next task from the callback of the previous, then you can simplify a chain of callbacks by breaking them up into request/response function pairs. Obviously this won't help if your app inherently needs to proxy data between different network services. In an application I'm working on, I rely on an events scheme, where one object will subscribe to an event of another, that will fire when that object changes state in some way. Often these events fire in response to a completed data refresh (that happens via XmlHttp), however the dependent operations (which in one case results in more network IO) are decoupled from this original IO, in fact appearing in a completely different object, which makes all the code a lot more clear. I made a small example here: http://pastie.org/544416
I've gotten very used to that coding style. Honestly, the only way I can tell this isn't pretty is because co-workers nag me about it. You can fight the "some methods return a value, and some take a callback instead. guess which!" anti-pattern somewhat within your own code by picking some consistent, and sometimes maybe elegant conventions. The observer pattern is the obvious thing (Aka all those event listeners and dispatchers), but there are other variants, such as a the pattern implemented by Entourage's MQ (whose name escapes me, but it's handy to do mostly informal synchronization of asynchronous code fragments.) If you really can't cope, then you need to hide the underlying javascript behind yet another layer of abstraction. The obvious one here is [narrative javascript](http://www.neilmix.com/narrativejs/doc/), but one could make up his own specialized dialect fairly easily. I wrote a little micro-language on top of JS to allow to write simple test scripts linearly without having to deal with the callbacks explicitely in just a few lines of code. while(regexp){eval or do some magic}.. 
What!? 45 minutes and only 2 points? That's purely criminal.
to make us lose sleep
eh, I'm not in it for the points.
This is essentially what Actionscript 3 does, so I imagine Javascript will eventually look like this as they're based on the same spec right? Mootools [makes this pretty easy](http://mootools.net/docs/core/Class/Class.Extras#Events) by letting you do something very similar for each class, e.g. ``myClass.fireEvent('complete')`` and then ``myClass.addEvent('complete',doThisFunction)``.
Several js frameworks have similar mechanisms, including my own, Cappuccino. (CPNotificationCenter)
I suppose the question is, if you need to feed the result of one webservice into another, why isn't there a method that does that remotely and returns the result? Having to chain calls together like that is a symptom of a bad API. If consolidation on the server isn't an option, other people have suggested events. I prefer jQuery's event system myself. 
so nobody can steal his precious code... nevermind
There is jwacs - http://chumsley.org/jwacs/ ... &gt; Asynchronous operations written in a synchronous style: Traditional Ajax applications require the programmer to either write a maze of event handlers, or to provide only extremely simple and idempotent operations. Jwacs provides library functions that make asynchronous operations such as an XMLHttpRequest appear synchronous. Instead of scattering your logic across several fragmented event handlers, you can just write a step-by-step description of what the application should do. ... it works by adding some new operators to Javascript then having a "compiler" in Lisp which turns the operators into native Javascript that's simulates continuations. All very cool but you're in the alpha territory - probably not something you can use seriously.
You can use currying and binding to prevent the nested functions: var contextualStuff = "foo"; // normally in scope via closure MyWebservice.method1(params, receiveMethod1.curry(contextualStuff)); // curry it in instead function receiveMethod1(context, gotten) { // you have made the closed-over variables explicit //do stuff var context2 = "bar"; MyWebservice.method2(gotten, context, receiveMethod2.curry(context2)); } function receiveMethod2(context2, result) { //more stuff } Definitions for curry() and bind() can be dropped into the beginning of your code.
It's great that we finally get a consistent audio API for JavaScript without the need for flash, and it supports an open audio format. I just don't see why support for other more popular formats (mp3?) isn't even being considered! I know this has something to do with patented or proprietary codecs but surely the browser developers can just hook the plugins (such as quicktime) into the audio tag somehow. hopefully someone here has more insight to this issue than myself.
If your code base is large, use a finite state machine (FSM) that explicitly models the state transitions in your program.
It is the same issue as the video codec issue. Not all operating systems provide support for audio codec's that people want to use - especially those codecs requiring patent licensing. MP3 requires licensing. If I as a web page author put an MP3 file in an audio element then anyone on an OS that does not provide an MP3 codec will not be able to play the file. This means that content authors will not know which audio format to target for their work.
Thanks for all the suggestions here! Although they don't meet my needs completely, they are valuable input. Maybe the best is to state my requirements more clear - I'm sure that other people are fighting with similar problems: - My project has both AJAX requests that can run in parallel (i.e. are independent from each other) and such that must be run sequential (because Webservice Method B depends on the input of method A). It would be nice to have a logic construct for those sequential requests (e.g. a Queue). - I want to treat the sequential requests as an atomic unit. E.g. if 3 requests are dependent on each other, they should be cancelled with one command. - The "callback coupling" of thewebservice methods changes in different stages of the app. During initialisation stage, I first retrieve some project settings via an AJAX call and then make a second AJAX call to generate a map based on these settings. Later the map solely changes by user interaction (e.g. dragging, zooming). So I don't want to couple the getProjectSettings method with the getMap method permanently. 
1. [Flapjax](http://www.flapjax-lang.org/): functional reactive programming in Javascript ! No more callbacks... 2. [Narrative Javascript](http://www.neilmix.com/narrativejs/): write asynchronous code in sequential fashion. 3. [Arrowlets](http://www.cs.umd.edu/projects/PL/arrowlets/): composable callbacks
breaks badly, if you try to select some of the text in menu and then mouseover. The highlighted menu item will no longer resize.
you should list your browser when you say things like that