We shall see. I remain sceptical. For Angular 2 to be successful, it must - achieve cultural penetration sufficient that an NG2 project can hire developers quickly and cheaply; - obtain the critical mass of developers needed to expand its ecosystem to suit the general case of web projects; - sufficiently impress thought leaders and technical evangelists to create community interests; - do all of these things before another, more compelling alternative has already done so. That's quite a tall order.
Hey thanks for the feedback. I've already changed the blog post once based on feedback in the comments so I appreciate it. If I were to make that section more accurate, what do you suggest I do? Also I have a few questions: 1. If a value is assigned to a variable, is that value synonymous with that variable? I mean isn't the whole point of variables to be referentially transparent such that they're interchangable with a value? 2. Why is `str(x)` not a cast to a different type? From what I know, 5 is an int, but if you call `str(x)` it'll call the `toString()`, and get the equivalent string value. I know it doesn't change the type of the variable, which is why I worded it as `cast it to another type temporarily`, but perhaps that's not a good way to phrase it? 3. Why is x not being redeclared? Perhaps I'm wrong because in python it's hard to distinguish declaration from assignment. Would it be more accurate to say it's been reassigned to a different type because x has already been declared; the proof of it already being declared is that it is defined in the current scope? 4. How would you differentiate variables from values other than the permanence of variables in the current scope? I don't really claim to be an expert. It can't be more than a year since I've learned this all so I'm hoping you help me out haha.
&gt; But it is not a mischaracterization of why 'enterprise' types are interested in it. I don't see the relevance of why one specific type of engineer is interested in TypeScript. But ok. :) &gt; Of course, but why the need? Everyone knows NG powers Google's Adwords products. I don't think everyone knows that FWIW. I've seen people saying "Google doesn't use Angular" which is false. The comment I responded to said something similar. I just thought it was worth clarifying. Adwords and Greentea (internal CRM) are built on Angular 2. I think more apps are built on Angular 1 at this point (GCP Developer's Console, DoubleClick, YouTube for PS3). **begin edit** Google is huge. They have a lot of apps and they are built with a variety of frameworks/tools because Google engineers aren't all the same. ;) Google uses GWT, Closure, Angular 1 + Closure, Angular 2 + TypeScript, Dart, Angular 2 Dart, etc. Google Maps for example is built with vanilla JS annotated with Closure types. It's too big to rewrite at this point and Closure works fine. This doesn't mean that Google doesn't believe in the other frameworks listed above. They're just being pragmatic. And they give individual teams freedom in choosing which framework/tools to use. (For example, I just spoke with a friend at Google who's on a new project team that's evaluating using React.) **end edit** You seem to be arguing that Angular isn't written for common web apps. That wasn't my experience with Angular 1 FWIW although I have very limited exposure with Angular 2. Regardless, the web has a wide variety of apps so it's good that we have a variety of frameworks. I can see how Vue or React might be a better fit than Angular 2 for certain types of projects. In many cases it probably depends on what the engineers building a given app have more experience with. :)
Do you mean R as in the data-science language? If so, why is it "Evil"? 
Edit: [Fixed :)](https://github.com/AriaFallah/blog/commit/902ff034c855e169dc08fadae6ce8ec94996ed1c) Wow...weird. I'm sure that I ran them in the node REPL, but perhaps I changed the examples and forgot to fix the comments. Nice catch!
Angular2 isn't targeted at the "cutting edge devs". It is designed for the every day dev. That is a big difference.
Router crisis? Jesus people on this sub are so dramatic. I mean seriously... It was in development. Anything can change.
Those breaking changes were specifically because Angular2 wasn't done. Google is moving to semver now, so that shouldn't be an issue going forward. It definitely isn't a "reason not to use it".
Dependency injection? Not a feature...
Angular2 itself is actually pretty simple to understand. The build/setup process was a bit more convoluted than v1, but that is why Google built the CLI tool.
As a big fan of Angular 2, Angular 1 is fucking complete garbage. A large scale enterprise framework shouldn't be picked because it's "easy." Writing vanilla PHP is easy, but that doesn't mean I'll choose it for a high scale application. Angular 1 has awful design and it is insanely slow. The only real reason it's popular is because it allows for much easier and dirtier code than other frameworks. This makes it insanely popular with beginners and people in developing countries who don't know any better.
Gitlab is now owned by github?
Looks like Shopify provides support for Digital Downloads: https://help.shopify.com/manual/apps/apps-by-shopify/digital-downloads
I think Inferno is cool but if React works well for you, I don’t see why you’d want to drop it. You just said you are “suffering from the fatigue”. Isn’t rewriting your project to every new library pretty much its definition? ;-) (Disclosure: I work on React)
&gt; impossibility to turn off VSync, thus capping app at 60 fps With a 60 Hz display, you can either display up to 60 complete frames or 60 broken ones. By the way, if you use rAF, Chrome renders at whatever refresh rate the hardware provides. With a 144 Hz monitor, you could run at 144 FPS. &gt; Also I am not sure if using static HTML divs as UI + canvas under them do display rest of game will be performant, wont flicker or have graphic glitches. It won't flicker and it won't have a noticeable impact on performance (if your HTML/CSS animations are done properly). Most games don't have that much UI, though. If it's just some buttons, I wouldn't bother with HTML/CSS. Anyhow, since Pixi can use WebGL if available, it's actually pretty fast. Just try it with some placeholder graphics and see if it's fast enough for your needs.
I like Reacts gradual approach for that very reason but might be just me. With React it's not about a ton of technology you have to swallow come what will, it's more about understanding concepts first. Functional design, immutable data, what is state and how it flows. Once understood there's nothing to learn, no API to browse. You naturally write your app using the additions you need. 
I'm not going to rewrite anything but there are future projects too. 
Our company managed to convert our internal React app to Inferno by simply changing some webpack aliases and using the inferno compatibility module. It was much harder for us to convert from KO -&gt; Angular -&gt; React before. Also: good work on React. It's awesome.
Yeah that's kinda what I thought. But I asked just to be sure.
Logically speaking as angular team has said that they will follow semver, you are definitely correct. But practically speaking: **once bitten, twice shy.** 
To be honest I dont mind if its 60 fps or 144 as I never really see difference. But players tend to say that 60 fps is too low and even if it does not make sense, I have to think about it. It is good to know that mixing HTML/CSS ui with webgl/canvas context from Pixi will work properly :)
I for one can't wait to convert my app that i just finished converting from jquery &gt;angular1 &gt; meteor &gt; react to angular 2
&gt; TypeScript I kind of hate how they force TypeScript on you when learning Angular 2 there are no JS docs only TS. I'm sure TS is great and everything and I am glad to be learning it but the steep learning curve of Angular 2 PLUS TypeScript makes for some slow learning. It took me three days to really get to a point where I could creating my project.
Haven't you moved to Inferno yet?
Okay so to summarize, and check if I got this right: 1. Values by themselves have types. In a dynamic language, the variable will never have a type, and every type error is due to the mismatching of the values during run time. There's nothing like static type inference going on for a variable; it's just a container. 2. While some people consider `str(x)` a cast, it's not an actual cast because it's equivalent to calling a function that returns a new value. A real cast just tells the compiler to interpret the same data in memory differently. 3. X is being redeclared/reassigned, but that's not changing the type of x. x has no type, but rather the value x holds has a type. 4. Values are values. Variables are variables. :p
If you want a design that's good for coders, just go for clean and spacey. As long as one can easily find information, the design is good.
I agree. As someone who never used 1.x in anger I found 2.x much more intuitive on those occasions I had to pore through some 1.x code. 2.x does have its oddities though.
I haven't run into anything like that yet, but I keep most of my state in Vuex so that might help
if you think angular 1.x is simpler try out vue.js
FYI they haven't embraced rxjs except for using it in the HTTP module. Their components have almost no support for observables. The only thing available is a pipe so you can write `someObservable | async` in a template and it will subscribe for you. But getting a stream of events from your template is all boilerplate. Getting a stream from your pops is all boilerplate.
Those are things you will have to deal with regardless of the framework or library you use. If you want modern Javascript, you have to use babel and you probably want to use webpack. It only takes a couple days to get a deep enough understanding to solve 90% of issues you run into in a timely manner. 
I'm the author of the starter project list you linked. I update it every 1-2 weeks. I suspect I will always be missing a few, since new ones come out all the time. I just added Phenomic to the list. 
It certainly is a feature.
That worked. Thanks!
I'd like to second this. I attempted to migrate a small project to TypeScript and encountered so many issues I gave up. Some examples: * difficulty finding or writing up-to-date declarations for all my dependencies * annoyed by renaming all .js to .ts (required by TypeScript compiler) * may need to add extra comments to the top of your files specifying the location of declarations Generally I am hugely in favor of adopting useful new tools and taking the time to learn. But TypeScript was not worth it. I decided all that time managing TypeScript would be better spent writing unit tests. Flow has its own issues and I didn't use that either. It seemed buggy - the line number and file name would be incorrect on many of the type errors. 
What is this? It's not JSPerf.com. It's ... spam for books?
fixed.. it was .net not .com
I thought the newest versions of node allowed you to use the Chrome debugger directly? 
Isn't this also what Ember does?
Seeing how Google is also backing Polymer and how that has improved and gained traction, i wonder if Angular 2 is able to compete with that. And if Angular 1 is going to split/fork from the current project to keep being maintained by people that are willing to do that for the people that keep using Angular 1.
They both have their purpose and they both have certain use cases where they excel. Personally i feel that React is better when you want to do more than whats possible with jQuery mainly for improving a single page, and Angular suits best if you build it as a multi-page webapp that should remain client-side. But thats my personal opinion. I'd still go for Polymer instead of React btw.
Shouldn't use of PureRenderMixin allow React to catch up where possible? I was thinking it was just a more efficient vdom implementation. 
We rebuilt 2 websites with angular2. Started 10 and 5 months ago. Both already in production. It was surprisingly easy to get a clean codebase with 10 developers. It is just so much easier to understand what the software does than in angular1. The downside was, in those 10 months angular2 got through a TON of breaking changes. Keeping the projects on the latest version required big changes across the codebase. Because of these breaking changes it's hard to search for help, as every blog or stackoverflow might be obsolete if it is older than a couple of weeks. I'm glad they are final now, as they promised to don't do big breaking changes constantly. The biggest point for angular2 IMO are unit tests. The library is fucking amazing to unit test. As angular2 abstracts away the browser (it comes with its own html and css parser), everything runs headless in node. Thanks to zone.js you can test asyncronous tasks like they were synchronous. The second biggest point about angular2 is not the library itself, but the ecosystem around it. The angular team really pushed rxjs, typescript and es6 modules. The PhpStorm plugin is awesome and in active development. They contribute in so many projects, it is amazing. I'm exited about real typescript support in the templates https://github.com/microsoft/typescript/issues/6508 ... I hope they work this out :)
Idk, I liked the quickstart. It's not great if you just want a really simple example of how to use it, but it does a great job of showing off how many different features angular2 supports and how easy it is to use them.
Dont u think hybrid app development isunder an existential threat from react native and future javascript tools that will compile directly to native, providing better performance and device api access? Dont u think this will make cordova phonegap etc obsolete?
Angular 2 focuses on improving the scale and maintenance of Angular applications, so it makes sense they have had to sacrifice some of the simplicity for a more rigid structure. React does the same thing, but with far more abstract means. 
They retracted the whole "React is the V in MVC" thing. It wasn't really true. It is a different paradigm to an MVC framework. When you pick React you don't need to go hunting for an "M" and a "C".
Here, I fixed that for you (Angular 2 quickstart without Angular 2): http://output.jsbin.com/wifufal
ES6 modules or CommonJS modules are a form of dependency injection already. You don't need another.
Btw, this is from the Angular quickstart: https://angular.io/docs/ts/latest/quickstart.html Building a simple "hello world" without anything fancy resolves to this: "@angular/common": "2.0.0", "@angular/compiler": "2.0.0", "@angular/core": "2.0.0", "@angular/forms": "2.0.0", "@angular/http": "2.0.0", "@angular/platform-browser": "2.0.0", "@angular/platform-browser-dynamic": "2.0.0", "@angular/router": "3.0.0", "@angular/upgrade": "2.0.0", "core-js": "^2.4.1", "reflect-metadata": "^0.1.3", "rxjs": "5.0.0-beta.12", "systemjs": "0.19.27", "zone.js": "^0.6.23", "angular2-in-memory-web-api": "0.0.20", "concurrently": "^2.2.0", "lite-server": "^2.2.2", "typescript": "^2.0.2", "typings":"^1.3.2" &lt;!-- 1. Load libraries --&gt; &lt;!-- Polyfill(s) for older browsers --&gt; &lt;script src="node_modules/core-js/client/shim.min.js"&gt;&lt;/script&gt; &lt;script src="node_modules/zone.js/dist/zone.js"&gt;&lt;/script&gt; &lt;script src="node_modules/reflect-metadata/Reflect.js"&gt;&lt;/script&gt; &lt;script src="node_modules/systemjs/dist/system.src.js"&gt;&lt;/script&gt; &lt;!-- 2. Configure SystemJS --&gt; &lt;script src="systemjs.config.js"&gt;&lt;/script&gt; &lt;script&gt; System.import('app').catch(function(err){ console.error(err); }); &lt;/script&gt; Even if you can pick and choose, it's still a myriad of moving parts. 
Alright. I haven't dived much into these big front end frameworks but they usually have an example of HTML in JS or JS in HTML and it just looks like a huge backwards mess.
Why **cloneNode**? I always wondered if I could do something like clone a node or change a node by passing in changes like {className: "Something"}
&gt; I think that using observables to manage state, if done right, is better than the Redux paradigm. https://mobxjs.github.io/mobx/
Shouldn't not having a **this.state** in the constructor tell React it's stateless? 
As of now I'm not implement any Js frameworks (other than what is required or jquery) until there is some settling down. However, right now I'm looking to Vue. 
Right now I use this, which I found somewhere on the internet(except I changed it from ES5 to es6 ) let originalCreateElement = Document.prototype.createElement; Document.prototype.createElement = createElement(name, attrs) =&gt; { // create the element let element = originalCreateElement.call(this, String(name)); // for each attribute for (var attr in attrs) { // assign the attribute, prefixing capital letters with dashes element.setAttribute(attr.replace(/[A-Z]/g, '-$&amp;'), attrs[attr]); } return element; }; let theStuff = document.getElementById("stuff"); let adiv = document.createElement("div", {class: 'aClass aborder'}); theStuff.appendChild(adiv)
The "copy this into there" seems weird, why not include it in the/some CLI to do it automatically. Its not even that hard. But yeah, i also struggled a while ago. Especially integrating typescript with my existing Gulp stuff was a mess (also had to include a custom existing plugin that was created for jquery but worked fine in angular1. However my main issue with this is that everything has to start from scratch. Many modules need to be ported (and completely refactored as well) and you will run into many issues that aren't easily found in Google or whatever. Plus editors can't really understand everything. And so on.
He's not talking about polyfills, he's talking about actual features and additional libraries. Like routing and managing data and stuff you require if you build a heavy app. Things that can easily be done with Angular1. Grunt/Gulp also is fine, there is enough to say why one wouldn't use webpack. And why cant you use gulp with babel? Gulp is task running, doesn't matter if the project is ES6 or not. And knowing Router and Redux is fine but what if you need more than that? Especially if you aren't really into it, you need to do a lot of research for even getting the same as you get out of the box with Angular
Angular 1 and 2 work side by side. A few tweaks to your routes and you're good to go. Leave old code as is, move new code forward.
Angular who?
Thanks for the explanation and I'd definitely be interested in a more in-depth article. I've enjoyed using/learning React--mostly for my ability to wrap my head around its inner workings. Virtual DOM diffing/optimizations are the biggest pieces of magic for me still, so I'd love to get a better understanding to how those problems are approached. And thank you for all the work you've put into Inferno. The aggregation of these various engineering improvements is how our industry continues to evolve. I appreciate getting to observe people much smarter than me continue to innovate and push us forward. 
A new version is coming very soon. Its will be completely automated without any more Pull Requests and manual labor.
On my side a PR containing two files it's not really a pain. Good job!
NG 1 and 2 run side by side very happily. A few changes to your routes and you're good to go. People are still stuck on that first intro video where Google said it wasn't backwards compatible. That doesn't matter, both run. Leave old code alone, move new code forward. The track record is actually really good, and well thought out.
There's bizarre "React is better" echo chamber going on in the Javascript community these days. In my experience, the "React is better" likes to cite the same 3 or 4 reasons they like React, while ignoring that Angular often has a sensible solution that is sufficiently React-like that a developer with feet in both worlds wouldn't care about the difference.
what were you bitten by? An open dev process? Would you rather they did everything behind closed doors and only presented the final result?
If you want to swap out a component you will need to rewrite everything that used that previous component. React doesn't change that.
That was pretty enlightening, thanks!
Babel, transpiling alternate syntaxes and powerful frameworks/libraries (ie React and Angular) are pretty standard now I think.
You can add state at anytime in the hooks but the stateless hooks provided by inferno does not have a set state
&gt; Can you go into detail on why React is apparently a replacement of Angular? It isn't. React is a view library you can compose together with any number of different M/C/VM/etc libraries, whereas Angular is a monolithic and highly opinionated MVC all-in-one framework. They're fundamentally different things - React can be composed together with libraries (and people are building libraries like react-router and reflux that are specially designed to work well with react), but that doesn't make *React* comparable to Angular. The only reasons people compare the two are one or both of: 1. The JS ecosystem is *highly* fashion-lead, so people tend to speak in terms of fashionable, trendy *tools* rather than *architectures* or *philosophies*. Angular was trendy, now React is the new hotness, so people are comparing them because each is/was the thing all the excitable cool kids are going "squeeee!" over, not because they're directly comparable. 2. Along with React (a view library) Facebook and others also started promoting a [different architecture](https://facebook.github.io/flux/docs/overview.html) to build web apps in that's a lot more modular and "functional" in flavour, and a lot of people have released libraries designed to work well with React. This new architecture breaks from the traditional MCV approach of systems like Angular, but rather than talk about "Flux" applications or "Flux+React" or "Flux+React+React-Router+Etc+Etc+Etc" people are using the term "React" to encompass the whole architecture and toolchain, because it's snappier, better known and... well... more trendy (see point one). It is, however, an inaccurate and misleading [synecdoche](https://en.wikipedia.org/wiki/Synecdoche). &gt; And that can seem like overkill when Angular is complete and ready to go. Angular is a golden hammer. It's great when you want to bang in nails, and sure beats rummaging around in your enormous toolkit for the right tool when something needs hammering, but in reality sometimes you need screws or glue. If you're only any good with hammers, you're going to end up hammering in screws, either because you can't be bothered to find (or learn!) the right tool for the job, or because you've been using your favourite hammer for so long that you simply *automatically conceptualise* every problem in terms of which bits you can hit with a hammer to solve it.
You could do: let content; if (this.state.showComponent) { content = .... } and then just {content} in the return. Or: {this.getComponent()} in the return and getComponent on your class. I would keep the ternary and usually write it like this: {condition ? ( &lt;Whatever /&gt; ) : null} 
Crap I have had [disco inferno](https://www.youtube.com/watch?v=A_sY2rjxq6M) stuck in my head all day 
WeakMap is not a drop in replacement for Map. Weakmap is designed for caches which can tolerate random removal of entries. You don't want your subscription to be randomly deleted by the GC. 
Are you nuts? Unless you're hitting performance roadblocks with React there's no need to move to a newer, less supported, less stable framework. 
Bashing Angular 2 seems to be a popular stance, but I would be hard pressed to find a competitor that offers the same feature set and industry support for an enterprise environment. Sure, there are plenty of other frameworks and libraries that you can mash together, but that's a total pain when you're talking about giant enterprise applications with a constantly evolving team. Having one framework as your main front-end technology makes your life a lot easier.
From what I remember, latest SimCity was in JavaScript.
I have made some progress with it, but I realized there are probably some more things about JS I should learn to make this simpler, since the solution I came up with was ridiculously complicated. I am currently learning as much as I can about raw JS before going back to this, and a few other problems. Thanks! 
Why not just { this.state.showComponent &amp;&amp; &lt;NewComponent /&gt; } ?
&gt; industry support for an enterprise environment Have fun with Java and .NET, I hear they're enterprise too. "Enterprise"... The great buzzword you get when you're not getting a great framework.
You don't understand DI
I've built 4 apps now using Redux, and I am loving the observable pattern NG2 offers.
why do you keep converting?
I am proud of that fact
&gt; What exactly are the issues that Angular 2 can solve, but not Vue.js, Meteor, Mithril, Riot, a React boilerplate or Aurelia?
If the release candidate is not a release candidate, do not call it a release candidate. If you are unwilling to do that, then I would prefer you work privately, yes.
Not to mention the JS docs for most of it aren't even there yet. At this point you can't move to Angular 2 without learning Typescript and embracing some toolchain.
Have you considered Phaser? http://phaser.io/ 
It looks nice. Are those components accessible. In the demo, tab navigation didn't work (maybe it wasn't showing which element was focused on).
Who have they acquired?
&gt; I use .NET all day every day lol how did I guess ;-) Some of us evaluate our frameworks in reality rather than in terms of "support contracts". Frankly, Google being behind Angular is meaningless, they've already messed it up multiple times if that is any indication, while the design of the structure itself is poorly conceived. No matter how much repetition of "enterprise".
It seems to produce this error: node_modules/tapable/lib/Tapable.js:164 arguments[i].apply(this);
Been using it since it was announced about 16 months ago and it is amazing. Intuitive, clean and after the first 3 or so days, you rarely need to consult the documentation to do most common tasks. Definitely underrated.
That's a fair criticism. Personally I'm a fan of gitlab, but that's more based on my ability to keep things private for no cost. Github has the best barrier to entry in part due to reliability, speed, and familiarity... imo - to your point
Indeed. private and free is tough to find for a lot of things, even if it's just enough to hold you over as your learning. I built a docker container registry service with a lot if free/unlimited ($5/mo) private repos as that was severely missing from the available tools. Just started the public beta for it.
I'm not sure what you mean by taking object relationships and DOM into account. Js revolves around the DOM and you should already know how your methods interact when you make them. There are lots of patterns out there you can use for larger projects. There's the mediator pattern, where you essentially have a control tower that all of your objects talk through, but this isn't worth it for smaller projects. Redux is popular now, isn't tied to React like many people think and scales well. If you want to build a proper web app, with a back end and all, start by rolling a node backend, a Mongo db and whatever front end framework/library you want on the client. Stick with MVC until you know what you want, there is no need to add unnecessary complexity while you're learning. A CS course would probably help too. An academic computing background *really* helps when it comes to these sorts of things and will make you a more complete developer, rather than one who just knows a few patterns. You should bear in mind runtime complexity (big O notation), which is essentially how many comparisons your functions/blocks will perform based on a given input. This becomes pretty essential when dealing with larger data sets. Learning about computer networks is also very helpful, you will learn when it's better/possible to use a socket over ajax, serverside rendering vs clientside, app security. Basic HTTP knowledge will take you a long way with something like Express and is all you really need to know for most ajax programming. State management is very important in large apps. Be considerate of what your app will be doing at any given time, in a large app you will need to be conscious of things like the event loop and call stack, it's easy to lock it up because javascript is single-threaded. Asynchronous programming is your bread and butter here. TL;DR: Just try something, put it out there, and you will learn very fast as you go along. A computing background is very helpful.
You're stuck with it now. Sucks to be you.
White space is SIGNIFICANT!!! Holy cow that's some racist shit right there!!! /s
node-sdl likely *won't* be as fast as something that uses WebGL. I don't believe node-sdl gives you access to the OpenGL API through Javascript. Plus you won't benefit from all the useful high and low-level features of Pixi.
The whole library is kinda a fun "fake" project, similar to https://github.com/gfredericks/quinedb
&gt; The JS ecosystem is highly fashion-lead, so people tend to speak in terms of fashionable, trendy tools rather than architectures or philosophies. Angular was trendy, now React is the new hotness, so people are comparing them because each is/was the thing all the excitable cool kids are going "squeeee!" over, not because they're directly comparable. This so much. I wonder if it'll ever change. 
Related http://en.arguman.org/react-is-mostly-hype
&gt; would start a new application in Angular 1 either. Not having to learn anything? Certainly why I chose it for adding functionality to a HTML only PoC
Are there other React game libs? Does this build on top of any existing JS game frameworks like Pixi/Phaser/CreateJS? Edit: The demo is awesome.. It is a platformer with documention built-in. Will definitely give this a shot.
[removed]
Which minor is their official LTS release?
For V6? Whichever one we have on [2016-10-01](https://github.com/nodejs/LTS), I suppose.
But I thought React was the new jQuery?
That is not true at all.
The last ember app I worked on was acquired a few months ago for $1b.
&gt; Virtual DOM diffing/optimizations are the biggest pieces of magic for me still, so I'd love to get a better understanding to how those problems are approached. Here is an explanation of an algo that is used in Inferno to find minimum number of DOM operations with keyed children: https://github.com/localvoid/kivi/blob/064818f04f110cf664de707a00fcad18e0f2d3d4/lib/vnode.ts#L1283-L1519
You would be wrong there, at least, from the stated goals of the team building Angular2.
The place you want to review is the mouseClicked function. Specifically the while loop. You define looper as true, with no code that changes that. While looper is true it will continue to run the page21st function over and over, forever. You've created an infinite loop.
Actually found one reference (it was from 2014, but I'm guessing it was repeated when I heard it at ngConf2016) https://youtu.be/odY7fUjI1ZU?t=3m8s Rob Eisenberg giving a talk about Angular 2.0 mentioned that Google is heavily invested in Angular and have over 1,600 apps at Google using Angular. No specific number here, but "a lot of v1 and even v2 apps": https://youtu.be/bSssb9AmiJU?t=1h 
tl;dr No one here knows how to fucking plan.
In other news, water is wet.
Devs mistook angular 2's horror story as a manual?
Seems nice, but wouldn't work in my project
I know but they talked about dropping it when Angular 2 gains traction. Now unless it gets picked up, i have big doubts if either will be sustained
I really like the new style but for me it should be a new project as it's a paradigm shift. I think the problem is they "took" such a great name at the start that people assume this is an official project. As this new style matches React so well I guess it makes sense to be in the de facto router, just a shame new users will find contradictory information from people writing about older versions. 
So how long do we want to be annoyed by old code as there isn't a replacement yet for that?
&gt;Grunt/Gulp do not know your project, they don't fetch and manage your dependencies. I have had no problem over the last 2 years getting my dependencies in order. Mainly because including angular modules is fairly easy and they are already minified. Whether you include them in HTML or you reference them as an import statement doesn't really matter to me. Also i don't need polyfills with Angular 1 because everything is pretty much supported for the majority of browsers (like 99%) and i don't need more than that. &gt;What do you mean with needing "more" ? If you read my response correctly you would know that i'm talking about other 3rd party modules. For Angular 1 i have a lot of interesting stuff that works flawlessly as it has been in development for many years. Stuff like UI Bootstrap, UI Router and others. React also has them, but they are harder to find and you need to do lots of work comparing and seeing what fits your use case. Angular 2 doesn't have most, which makes it even harder and they also have a "go make it yourself" mentality now which isn't helping. Another project that lets people extend it themselves so heavily is Polymer/webcomponents. But that is managed better, plus has better sites to not do so much work before you get started. But Angular 1 is still the easiest to get going, which is why it got so popular. React also has that in some way but whenever you need more than a hello-world app, you will notice it isn't so easy as other frameworks have it. 
best git clone ever
I've been using PIXI along with Electron (for the standalone) for a few months now and I can definitely recommend both. I've been building a browser mmo/roguelike which uses quite a few of pixi's more advanced features and I've fallen in love with it. For reference: [ISLEWARD](https://bigbadwaffle.itch.io/isleward)
ELI 15: I thought React is designed to streamline updating DOM from JS objects. But games don't really use the DOM. So what's the purpose of React here?
Yes, it includes Onsen UI provides page management. There is a documentation about this: [Multiple Page Navigation](https://onsen.io/v2/docs/guide/js/#multiple-page-navigation) and [ons-backbutton component](https://onsen.io/v2/docs/js/ons-back-button.html). Android's hardware backbutton does the same behavior as ons-backbutton.
Oops. I didn't saw this, sorry. Indeed React Native is awesome, and I'm a big fan of their idea and how they implemented that. I think there is no reason for JS developers to try out React Native and see if that fits their needs. However, I think the process of creating a real native app in JavaScript will be continuing by different approaches. Titanium is the one. Xamarin is not JS but having a similar concept using C#. I think there will be more frameworks that provides native app development using popular programming languages. What I think Cordova/PhoneGap different is it is using Web technology, which is the most popular platform currently. And, Cordova/PhoneGap has a philosophy to "cease to exist". It will be eventually meaningless if browsers have full power to control native devices. It's somewhat in progress by names of Progressive Web Apps by Google, but it's still a beginning. I am wishing the future where the Web ecosystem grows and be integrated into native platform.
Sadly I doubt it - I think it's caused by [a number of factors](https://www.reddit.com/r/node/comments/4yj58w/the_open_source_nodejs_community_is_completely/d6o8s4m?context=1) currently inherent to Javascript - specifically its position as the scripting language of the web, and hence the lowest-barrier-to-entry programming language in the world. For that to change either the web world have to shift en-masse to another language (pretty unlikely) or computing would have to change to the point some other language was easier to start playing with than "press F12 in your browser". At best as the web matures and (if!) the frantic pace of change ever slows then we have more time to educate each new generation of devs in basic software engineering theory and practice before some new exciting development occurs that people can get over-excited by and start misapplying because they don't know any better. However it hasn't slowed much for the last 22 years that I've been involved in it, and by its very nature (distributed, device-agnostic, progressively-enhanced open platform) I can't really see that happening any time soon.
This is a really exciting paradigm shift
#Books that helped me to get the hang of JS John Resig's [Secrets of the JavaScript Ninja](https://www.amazon.com/Secrets-JavaScript-Ninja-John-Resig/dp/193398869X) and Douglas Crockford's [JavaScript: The Good Parts](https://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742) are pretty much the only ones worth reading in my opinion. # Projects The best thing would be to build something you want to use yourself. Maybe you try [cordova](https://cordova.apache.org/) and build a small app with the browser platform so that you can create a simple App that you can bring to your Smartphone. # More advise Read a lot of code: [TODO MVC](http://todomvc.com) is a good place to start, people try to write good code for this one because they want you to use their framework :-). The problem with the source code of many projects is that the JS ecosystem is in a constant flux and ES6 modules are skyrocketing right now. You may want to check out the [jQuery](http://jquery.com/) source code - you can pretty much watch the evolution by looking at older versions of the source code and how it evolved. If you feel really adventurous the [NodeJS](https://nodejs.org/en/) source code is a fun read - although it's a very big project that also got some C/C++ code sprinkled in - but that shouldn't be a problem for you :-). I would advise you not to bother reading the Angular1 code for the time being, Angular2 maybe interesting but its written in [Microsoft's TypeScript](http://www.typescriptlang.org/) - which is a nice language on top of JS that is worth learning about. 
Aside from tree-shaking, it seems like you want this; [babili - An ES6+ aware minifier](https://github.com/babel/babili)
Just came across this thread, I know it's quite an old thread, but it seems like it didn't go all that well for you. In any case, you never did get an answer to this question. Realistically, the reason for browser support being dropped is based on usage. When usage drops below a certain point (that will vary from project to project probably) for a target demographic, support will naturally be dropped. A big part of it is down to target audience, and intended feature-set. So, things like React, and Angular are really quite modern software. They're using new features of JS to accomplish their goals, and without those features from newer browsers they wouldn't be able to do so. The thing with it is, they have to make a tradeoff too. They want to support as many browsers as they can, but again; it will get to a point where trying to make things work on so many browsers will just not be worth the effort. Realistically, if you actually need to support IE6/IE7-level browsers, you will need to be looking at things like jQuery, aiming for basic front-end functionality. Not a single-page application. This means you'll probably need a backend that renders your pages too. This is the only way I can recommend approaching this. So, with all that in mind: 1) Browser Support (what happens when my userbase uses mostly ie7?): I think this has been covered already pretty much. You won't be able to use Angular or React, and are more than likely going to have to use something like jQuery, and some backend (Node, PHP, Java, Go, etc.). 2) Performance with support in mind (sure react is faster, but what if I want to write a everything-friendly SaaS with massive functionality?): Just of note here, I think ng2 has actually surpassed React in some benchmarks now. It is more modern though, so that doesn't really surprise me. They will have been able to learn from React. That aside; if you were planning on using React or Angular anyway, you have to remember that the performance that a user experiences with those frameworks will largely depend on _their composer_, and _their internet connection_. Those are things that are out of your control at that point, and so they could be waiting around a lot if they have a slow computer or internet connection. So again, maybe you should be considering a backend, something that has great performance (Java, and Go are extremely fast for example). Then you can send the pre-rendered page to them, and their computer and internet just has to load that. [KISS!](https://en.wikipedia.org/wiki/KISS_principle) 3) User-experience with performance in mind (what if my users are people that will throw the switch if they have to wait longer than 3 seconds?): As I've mentioned above, if you can get this happening in the backend mostly, then that will really help all of your problems here. Set up a system with enough power to achieve your performance goals on the backend, and it will provide a more consistent experience to the user. --- Final note; when you're considering stuff like this (I'm genuinely wanting to be sarky or anything by saying this), just make sure you're doing research into your target audience, what browsers you're likely to need to support, and then start making decisions based off of that. Right now I'm going to be frank, it seems like you picked the frameworks first, and then tried to force your project to fit into them. Think about it, and choose what makes the most sense to accomplish your goals, and fulfil your requirements - that may not be the hottest new JS frameworks.
I can't really disagree with this. Should Angular2 just have been renamed completely as well? I think yes. It's so strange trying to look up how to use a tool or API or framework and finding advice that absolutely doesn't apply anymore.
Have you worked with it yourself? With a modern buildflow? These issues you have do not exist. [It's set up in no time](https://egghead.io/courses/react-fundamentals). The lesson there is four minutes long. At the end of it he has React, ES7, hot reload, dev server, SPA history fallback, auto polyfills, auto npm/node_module awareness. Now he's showing you how and explaining, if you do this yourself its usually done in *seconds*. This is a standard these days - it doesn't even matter if Angular1, 2, React or Polymer. This step is always the same. Now things like routing, bootstrap UI, redux are simple npm installs away. You don't have to do Gulp-era research because all is on npm. You're not doing this by hand, copying files and whatnot. It just means no worries about dependence order, no concats (yuck), no html injects, just take what you need. Now you say you had no problems for 2 years, yet you're scared of something tame and simple like React, because your tools aren't flexible. I'd call that a problem.
Maybe they should use TypeScript instead. Non-nullable types really help with this kind of thing. That screen is supposed to show a list of the upcoming departures. It's kinda important that it works correctly. If you aren't familiar with the dozen tram lines which depart from there, you really need this kind of overview. The alternative is to walk to each of the six or so platforms and check all the timetables over there. 
Weird high pitched voice but a very lucid and helpful talk.
This is the correct answer if you don't want to reinvent the wheel.
How is this related to reactjs/react-router
Write it. ^The ^more ^effort ^you ^put ^into ^the ^question, ^the ^more ^effort ^will ^be ^put ^into ^the ^answer.
They mention a "Route Config" example and I found [this](https://github.com/ReactTraining/react-router/blob/master/docs/guides/RouteConfiguration.md) but that doesn't look any different than how it is now..? Are they referencing something else? Edit: Missed the [docs link](https://react-router-website-xvufzcovng.now.sh/route-config) at the top.
I think that's what I want, but I'm not sure. If it doesn't keep looping, the game won't run right, right?
Why is routing so difficult? Angular and React are constantly rewriting them and seem to keep getting it wrong. 
I don't care that it is all on NPM. You are simply talking about something totally different. I'm talking about how i would know to get module x or y for feature z. Or even knowing x and y exist. Not whether or not i can easily install them. And i'm not scared of React or anything, but i simply wont use it as i already have a fine system in place that doesn't seem to be needing replacement, which would take me time to build with no true gains (nothing that i can explain the business people). I don't even need to worry about dependencies or manual injects with Angular 1. I simply have a gulptask that takes everything from a certain directory, orders it the way it needs to (by regex so i don't need to specify) and builds that into a single thing i can use with my app. Now sure i might not use lazy loading or only loading what i need, but my usecases simply don't benefit from that. Mostly because downloading a single image already takes up more time then loading my scripts, whether that is in parts or not. Plus i also have customized various parts of livereloading and building the app, that i simply cannot do with the standard webpack or stuff that i would need to customize that as well, rendering the gains irrelevant. Stuff that goes into our entire build pipeline for other parts of the company. When somebody is using my app, it will only need a connection for data, not resources (and being able to run offline is also a requirement most of the time, try webpacking that by default). Not to mention that the gains in performance are neglectable for 99% of my use cases, so why the hell would i switch? Hell, if jQuery would be enough, i would still use that. Now you can call me oldfashioned or not flexible but that simply isn't the case. It really depends on what you are making, who you are making it for and what you already have made to reuse that i'm not really looking forward to Angular 2. And i'll probably turn to Polymer before i go for React. But something you guys also seem to forget is that when i'm done with a project and i'm not around for that after, i still need to be able to let others build on that too. Change documentation, that i've been able to copy/paste for most of the stuff and implement stuff so our testers and other people can get started quickly. Oh wait, fuck documentation, lemme just use React lol Now i know Angular 1 developers are easy to come by, but try finding React developers or developers that are experienced with the other react-family modules as well. Businesses also aren't eager to switch their entire programmer-pool to different frameworks every year. It might be fun for a startup or two, but some people are simply involved in bigger stuff than that. 
dude these guys cannot HELP but to rewrite this thing like all the time. Every couple of months I'm forced to update because no one in those channels will even consider helping me with my questions unless I'm on the new stuff: "Well I don't know how to do it on the old react router but... here's how you do it on the new one we just came out with 10 days ago". Very frustrating.
I just looked through the examples in the docs for react router, and it's a complete mess. `MatchWithFade` is one of the most unintelligible messes of code I've ever seen: https://react-router-website-xvufzcovng.now.sh/animated-transitions JavaScript is actually a clean, simple language. HTML is also a fairly clean, simple markup language. But that is just an unreadable mashup of markup syntax and JavaScript syntax. There's no separation of concerns here. Literally everything - the markup, the presentation logic, and the routing logic - is mashed together. To make matters worse, the routing "logic" takes the form of pseudo-markup language instead just of just plain JavaScript like you'd expect it would. I hope to god I never get so desperate for work that I find myself needing to work on a codebase that is written like this just to put food on my table :(
Hi /u/ckgrafico, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Hi /u/ergo14, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
so just don't upgrade, it's a major version, it breaks things, that's how semver works.
&gt; It ended with removing the idea of routes completely (surprised us too) and a completely component based API, **which actually means no API at all.** ### **which actually means no API at all.** # **no API at all.** https://media.giphy.com/media/kKdgdeuO2M08M/giphy.gif 
It was moved out of the reactjs org on GitHub partly for this reason. That is supposed to be a collection of community projects, but reads more like an official set of repos. I think they should change it to ReactCommunity personally. But it now lives under ReactTraining, so the distinction is a little more clear that way.
I don't get why people do this, imagine if the story had been more along the lines of - "From the makers of React Router an exciting, simplified way to route, take a look at our new project React Router Reboot. Still in beta but we're so enthusiastic we think everyone should look at moving over." Spin it as a new project and they'd have created such a positive buzz rather than all the abuse they are getting. The problem with maintaining an old semver version is that it puts people off contributing, you're far more likely to find people to pick up even innovative on the old one if it's not marked as defunct, even if there's a newer shinier version elsewhere.
Having that available by launch should soothe a lot of the butthurt. You might even want to have it launch with it compatibility baked in and have it fire depreciation warnings, similar to when React split ReactDOM into its own package/API.
That sounds very reasonable. Don't let the haters get you down.
My first impression is that it seems a bit odd to want to declare your routing inside components like this. Why should a component have any concept of a route embedded inside it? It probably makes certain things easier and faster to do, but I just don't think of the routing hierarchy and the UI hierarchy as being so concretely linked. This project does seem interesting and it's clearly had a lot of thought put into it, but it would be interesting to read about how they decided on this approach. I'll give it a try in any case.
This is a super minor release... I don't even know why this post has 50 upvotes. There's really nothing of note here for 99% of node users, and certainly no BC breaks.
Put console.log('test1'); at various points within your code and see if the functions you think should be called are even getting called. Also, check out jsfiddle.net for a place to test, run and share code. 
Your oppstart function is never being called, because this line is backwards: var oppstart = window.onload; There are a few problems with this: * oppstart is already defined as a function; creating a variable with the same name overwrites your function with the new value, hiding your actual function implementation * you need to assign your function as the onload handler, rather than assigning the current onload handler over your function So, this line should be: window.onload = oppstart; You also have a problem with the **scope** of your tall1 and tall2 variables. In Javascript, a variable can only be accessed inside the function that declares it, which means that your addNumbers/etc functions cannot see these variables. To solve this, you need to declare the variables in the outer scope, and then update their value inside oppstart as you are currently doing. So, rather than: function oppstart(){ var tall1 = document.getElementById("tall1").value; var tall2 = document.getElementById('tall2').value; ... } try this: var tall1; var tall2; function oppstart(){ tall1 = document.getElementById("tall1").value; tall2 = document.getElementById('tall2').value; ... } Because the variables are created in the scope which contains both oppstart and addNumbers, they can be accessed by both of those functions. [PasteBin link](http://pastebin.com/DTiKKAqr)
&gt; The demo is awesome.. No. It isn't.
What should or should not be a concern to me is up to me. By the way, your metric is totally fucked-up. If you ignore the node_modules folder, you have just 34 lines of requires/imports that do absolutely nothing.
It's much better than what CreateJS gave me, the last JS game lib I tried out. Not sure why I care about your opinion anyway. 
On the other hand it was kind of weird that it wasn't a straight React component in the first place. I bumped into things like needing to use props and couldn't figure why it just wouldn't work as it does with anything else in the JSX scope. 
SWEET - I Love Learning! 
Having written and/or modifying them a few times, they really are hard to get right. Making a router flexible enough for developers to do everything they could possibly want often flies against making the interface DRY and easy to use.
Why is everyone one complaining? They said that would continue to work on the previous version, feel free to stay with that one. How dare these open source devs who literally teach conferences so they can write open source code with the rest of their time make an upgrade to a product. Oh yeah....and that upgrade makes a ton more sense in terms of fitting in with react. 
Not that I'm aware of, this is fairly trivial to implement however as custom events and/or dimensions.
I'd be really interested to see what happens with data fetching and server rendering. The new version seems to kill the [old static fetchData trick](https://www.codementor.io/reactjs/tutorial/redux-server-rendering-react-router-universal-web-app), but that was really just a hack that didn't represent how you actually wanted to fetch data. It'll be good to see what alternatives come as a result of this!
So? Stay with the older version if it suits you better. Full rewrites are usually necessary to make big improvements. Complaining about that is incredibly egoistical and short-sighted.
And Ember now has an LTS branch for long term support and an upgrade path for major point releases. Worth checking out.
as /u/fooey says, to an extent it does mean that. It means breaking changes were introduced. But have you never looked up documentation for a project, and the documentation *didn't specify which version it was talking about*, and you followed the advice on a new version and it was just completely inapplicable? I feel like this is an important enough issue for it to affect how we name our projects.
You have an infinite loop, which halts the program. Instead hook into the callback provided to process frames, one frame at a time.
Haha I giggled when I first read this but now I feel bad for you.
That didn't work out. Giving me trouble with adding the `size` property to datGUI. `datGUI.add(guiControls, 'size', 20, 50);`
Good comment. Feel better.
Indeed, 4 spaces &gt; 2 spaces almost everywhere, except in HTML/JS where there are lots of indentation levels, so 2 spaces &gt; 4 spaces
Keep up the good work. Hopefully you nailed the API this time for good. I know it's a b*ch to get right. 4.0 does look sweet and I will try it as soon as I can.
We only need to set up something to allow you to define a top-level route structure. You can then use that to statically analyze your route config based on the URL, which you can use to extract those `fetchData`-like statics, or set up a code split point, or just proceed to rendering like before. That's the point of a prerelease here. We need time to experiment and figure these things out. I don't think anyone wants to define the One True Way™ incorrectly and then have to go through *another* round of painful API changes.
I agree with you there. This makes me happy.
Found the answer in [onChange](https://davidwalsh.name/dat-gui) method. 
Maybe just delete the comment?
On the one hand, I sympathize with what you're saying. It's hard to keep up with things changing all the time if you're not right there in the thick of it. But on the other hand...you are complaining that the devs won't help you (for free, out of kindness) unless you use the latest version of the thing they built and gave away (for free).
Just finished converting one of my apps over to v4, the new style is all very clever but it's more verbose and probably too clever for me - I don't think I'll stick with it (unless I've missed something, which is very possible without proper docs)
You might try searching npm for existing wrappers to save yourself the trouble. Here's one I found https://www.npmjs.com/package/wikipedia-js
What? Did you not see the tweet in the OP? I already rm -rf'ed all my React projects.
For those who don't know, Brendan Eich was the creator of JavaScript and the co-founder of Mozilla.
Just curious, what do you not love about it? It's obviously opinionated software but everyone can voice their opinion about its pain points. 
try doing it without an anonymous method before I say anything. :P
I think OP is new to the JS framework race. It's clear frameworks exist to ease the understanding of a certain set of individuals in carrying out their goals. Although there's distinct advantages to each framework, I'd venture to guess the majority of the JS community pick frameworks that have 'Hello World' examples which are efficiently groked at first glance. I'd bet if we studied the matter, we'd find the first impression of a framework lasts much, much longer than anything reasonably astute about it. I'm sure peer pressue comes into play in large organizations, but at the microcosm, first impressions probably win.
Thanks! It's not too hard to create an iterative, so easy to work around. Do you know why they consider it dangerous?
Hmm I gotta check this when i get home One problem I see off the bat is you're using this inside a D3 function inside of react, thats a lot of overhead. A true benchmark should be pure try taking them out and running them isolated and use performance.now to measure , then put the output into d3
Agreed. That's a huge win for avoiding some accidentally swallowed errors. ... Assuming that process warnings are logged by default, anyways. If they aren't, then it's sort of a swing and a miss, in my opinion. 
It won't happen, especially not for SPAs, unless you want to experience pain that the people who wrote the frameworks experienced in the first place. The reason frameworks change at such pace is it's an iterative process, they make API changes not because they want a new feature but because that feature solves a problem. Most times it's because it clears up the API to make it more compatible, easier to use, etc Your only option really for 'true' stability is to roll your own, if you do, good luck :) 
Not sure why I got downvoted for respectfully expressing a difference of opinion. Oh well. :) &gt; Every couple of months I'm forced to update because no one in those channels will even consider helping me with my questions unless I'm on the new stuff If you've been getting enough use out of the library that you'd leave this kind of comment- then I'd say the pros clearly out-weight the cons. (Anyone that's been using a library and getting free support from the maintainer over a period of months is benefiting above and beyond, no?) Almost all of these OSS libraries are MIT-or-similar license- meaning anyone can fork them at any time if they don't like the direction the library's headed. In the case of RR4, the maintainers have explicitly stated that they plan to support RR3 "indefinitely" anyway. It's okay for us to disagree on this by the way. I don't think you're a horrible person or anything. I was just sharing an opinion. In case you're curious where I'm coming from- I'm an OSS maintainer myself. _Every morning_ I wake up and check Github, Gitter, and StackOverflow. I usually spend 30-90 minutes responding to issues and answering questions. Then at least once more during the day (usually after work) I do another round. And people are almost _always_ appreciative- which is awesome. But if I got the level of push-back I've seen some folks leave about RR4 I'd be pretty discouraged. After all, I've been giving a huge chunk of my life to helping people out here. And yes- I do it in part because I enjoy the challenge and it makes me feel good (eg the guts and glory) but there are _many times_ when I don't want to respond to a particular question or issue and I have to force myself to trudge through it. (It's "work", just unpaid.)
&gt; Except that there are no scenarios where it makes sense to start a new project with Backbone in 2016. Came here just to say this. Backbone is dead, stop trying to resurrect it from the dead, let it RIP.
I've never worked with CORS, after just reading up on it, it would take me some time to learn what I was doing. Do you think it'd be easier to achieve as a chrome extension?
For fun.
Ah I gotcha. Things have changed a lot probably since you last dabbled with it. I think the ember composable helpers add on helps with slapping in logic into the template if you fancy that. They have also followed suite with one way data binding as a default which is around the corner. Controllers are going away in favor of routeable components too. Seems like you would write lots of components no matter what. I know there are a few Redux store addons now for handling immutable state if that's your thing. But I feel you on having flexibility in shifting things around with the backend. I'm not trying to persuade you or anything. Just pointing out that Ember borrows a lot of React concepts. I've been liking what I'm seeing with React so I've been studying and working on both so I'm using the right tool for the job. 
Does it make a fresh, default install of firefox not stop loading youtube videos after 3 seconds?
Write it in MVC-that pattern is long tested. For View, use any VDOM library. I'd pick React, because that is one I am sure will be here in 10 years still actively developed. For Model and Controller use [MobX](https://github.com/mobxjs/mobx) or Redux. I would go for MobX becasue it allows you to work with your state very naively as you are probably used to from any other OOP language. If you choose Redux you will probably need to get accustomed to functional way of transforming state. Feel free to write me a PM in 10 years and demand a large pizza delivered to your doorstep If I've given you bad advice. I promise that if anything seems like a bad advice in 10 years, I will deliver.
Some counter-points to their problems: &gt; **Problem 1**: Like Object.freeze, the collections are only shallowly immutable This could really be called an advantage; it's not that ImmutableJS only supports shallowly immutable data structures; it's that it leaves the depth of immutability up to the user. If you want everything to be immutable, just use ImmutableJS objects "all the way down". Their example is easily "fixed" by using `Immutable.fromJS` instead: var obj = {foo: "original"}; var notFullyImmutable = Immutable.List.of(obj); //from their example var fullyImmutable = Immutable.fromJS([obj]); //fully immutable equivalent obj.foo = "mutated!"; notFullyImmutable.get(0) // { foo: 'mutated!' } fullyImmutable.get(0).get("foo") // "original" It's easy to do full immutability when you want it, but the key is you *don't* always want it. You'll note that they had to make a special exception in their library to allow for mutable React components (also functions and Dates) to be in their immutable lists, despite not being immutable. That's a bit concerning: if you stumble across your own usage where you need shallow immutability like React Components do, I don't think they expose any ability to add to that whitelist, and their need for a whitelist is a good argument to why this "problem" is a feature not a problem. &gt; **Problem 2:** We had to do a lot of converting back and forth to go from immutable.js collections to vanilla JS collections." This is a problem if you're migrating an existing codebase piecemeal, or if you're inconsistent about what you make immutable; but less so if you use Immutable consistently throughout the codebase. In a lot of cases (arguably, most) it's better to just avoid converting back and forth between immutable in the first place. Once again, their example is a bit flawed: var hobbits = Immutable.fromJS([{name: "Frodo"}, {name: "Samwise"}, {name: "Meriadoc"}]) //Rather than doing this as their example _.pluck(hobbits.toJS(), "name") // ["Frodo", "Samwise", "Meriadoc"] //It's better to do this: hobbits.map((hobbit) =&gt; hobbit.get("name")); A tiny bit more verbose, due to the absence of the lodash/underscore shorthand, (it'd be cool if ImmutableJS supported `hobbits.map("name")`), but not terrible. Of course, lodash has utilities that ImmutableJS doesn't support and in that case, you either have to reimplement them or go back converting back and forth from ImmutableJS objects to mutable ones, so I'm not saying this isn't a problem; but I don't think it's a serious one. (Plus, I'd be surprised if someone hasn't made a lodash-styled utility library that works on ImmutableJS objects, at this point) &gt; **Problem 3**: The API had unorthodox, changing opinions on functional programming fundamentals This is a bit of an odd "problem" given: &gt; ...the fact that the design was eventually reversed was not enough to restore confidence in a library that would necessarily pervade our code base. As the saying goes: “Fool me twice, shame on me.” ImmutableJS made a specific choice with their API which a number of people didn't like, so they fixed it in the next major release. It seems like ImmutableJS handled that as well as possible: they listened to feedback and implemented it in a pretty timely fashion. I'm not sure what the author was expecting here, except, perhaps, an unreasonable expectation that they not make such mistakes in the first place. It's an odd thing to list as a reason for parting with a library. --- So, yeah. `seamless-immutable` might be an easier migration path for a mutable codebase... but personally, I'd recommend ImmutableJS instead in most cases.
Separate processes aren't congesting sync of memory between the concurrent control flows.
Yeah to be fair I was last using Ember over a year ago, I think around version 1.13 or so. At this point I just don't have any strong desire to go back, it seems like React has won the hearts and minds of most of the JavaScript world. 
Yeah, the benchmark measures only an isolated part of the code for precisely that reason.
Oh boy, First of all: thanks for posting this, I really think, that the modern frontend dev should know how to make architecture decisions and apply patterns. But applying classic OOP design patterns from statically typed languages to Javascript by copying the classes does not utilize the full power of Javascript. One example where this is easily noticeable is the observer pattern. Why would I want to create an object with the notify method on it, around the function that I want to get called, when I can just push a function in an array of functions? Another point is, that you cannot talk about Javascript without talking about asyncronous operations. Javascript has many patterns that are wildly used: callbacks, promises, generators. 
Http://Gumroad.com It's pretty simple to use. 
An extension would be easier, check out https://userstyles.org for some inspiration.
I think this is a great question - one more devs should ask... I recently pulled out a game I had made in javascript in 2005 and was amazed that I could double-click on index.html and the game was running fine. It was a shoot 'em up that was fairly simple, but with attack-waves and some other "advanced" features. I opened up the code and although it was pretty old-school, I had written it in a reasonably readable way and was able to plop in some sounds (there was no Audio tag in 2005!) in a couple of minutes. It was very satisfying. If I look at many of my other projects from 2010-era and beyond... I don't even know how I could get them to run anymore - so much transpiling and build cruft!
I'm a developer at FastSpring, and recommend checking us out as this is exactly what we do: https://fastspring.com You can integrate us on your site through our API or use a hosted order page on our side. In addition to the commerce and payments functionality we provide, we handle all VAT coompliance, fraud screening and chargeback management.
But you're reinventing the wheel. All those frameworks started out as custom architectures (usually at big companies), and the company just open sourced it. You're just going to be going through all those growing pains on your own, without a community behind you. Instead of building a product for your business, you'll be building a product to create products for you business. It makes sense for larger companies since they have the resources to burn on that, and it pays off in the long run. Smaller businesses don't have that luxury. And even in the worst case scenario where the framework is killed, there's no reason your company couldn't fork the project and maintain it on its own. 
Do you believe Obama was born in Kenya too?
It's ok, in a few months they won't stick with it either :) 
There are major differences between all of those frameworks, as well as the other ones you didn't mention. Every one has some advantage to it, and the only way to really understand those advantages, and how they compare, is to use each framework in a project and see for yourself. But let's be honest: you're not going to do that. So here's another answer: every one of those frameworks (yes, even Backbone) are absolutely capable of producing powerful, modern, and maintainable SPAs (single page applications). You can't pick wrong. ... but that's also kind of a worthless answer, if you're trying to decide which one to learn (unless you have tons of time to play around with all of them). So let me try and answer what I think you're really asking: which one should you learn? Angular 2 or React. There's a decent case for Angular 1, but as a no-longer-supported framework it's days are numbered, and why invest in a dead-end technology? All the rest don't have nearly the mindshare that Angular/React have (if you don't believe me go look at which frameworks employers are looking for on job sites like Stack Overflow's, or at developer surveys such as the one Stack Overflow conducts annually). As for whether you should learn Angular or React, you can either think ... Do you like Google or Facebook more? Google = Angular, Facebook = React. Do you want HTML in your JS logic, or JS-like logic in your HTML? React's JSX puts little snippets of HTML in to JS, and then converts them in to functions (conceptually it translates &lt;div&gt; in to buildElement('div')). Angular puts special "ng-" attributes on elements in its HTML, and those attributes do things like iterate or spit out values. But probably the best question is this: are you looking for an overarching framework/ecosystem, that tries to do lots for you, and has clear answers (eg. Typescript) for most everything else? If so go Angular. If on the other hand you want a core structure, with a wildly inventive but not exactly cohesive ecosystem that has fifty solutions for anything, but you'll have to look through all (or at least some) of them to find the one that's right for you (well, unless you just pick whatever the most popular option is, which plenty of people do)? Then you want React. 
I just worry about the memory usage. I don't want Firefox to turn into Chrome. Even with 16G of RAM, I have to shutdown/restart Chrome all the time to make my system usable again.
Hot reloading did nothing of what you claim when we tried to implement it. React Hot Loader is not finished, takes a shit load of work to get right with third party libraries, and honestly saved us no time over LiveReload.
Welp. Time to check out Inferno.
I've used ImmutableJs extensively and been curious of seamless but never had time to bring it in a project when I already know how to do it with ImmutableJs. What I would like to know is why you would recommend it over seamless? 
If you are embedded and want something that doesnt change much in ten years then maybe you like C. If you like C then maybe you will want to look at emscripten. But anyway they dont even call it ES6 anymore. Its ES2017 or something now. In ten years it may be ES2027, or maybe everyone will be using Nim or Go compiled to web assembly. You could look at Vue.js or web components/Polymer. Those are sort of newish although I would assume they would not be popular in 10 years. But if you are lucky then in 10 or 15 years maybe we will have artificial general intelligence and you will be able to run an AI junior dev on a small computer in the closet, and it wont care how old fashioned the code is.
Um, how many tabs do you have open? I get to 50 tabs all the time without problems.
Your WeakMap example is using `[...]` instead of `.set` and `.get` so it definitely won't work as-is. It is a good solution to this problem though, assuming you don't mind the verbosity.
Huh, interesting insight. You should probably let the author know
That post is old as fuck in JavaScript years. NoRedInk has moved entirely to elm-lang for their UI. The creator of the language even works there now.
Chrome actually does group some tabs into the same process when the number of tabs is large, and it also groups tabs together if they have references to each other, like if one was opened from another by clicking on a link with `target="_blank"` but without `rel="noopener"`: https://jakearchibald.com/2016/performance-benefits-of-rel-noopener/
They're not "strictly better", they're slower and require the escaping of more controls (`, \, $). They're more like a function invocation that returns a string, than a string literal. It'd be silly to do that when the invocation just returns the argument.
That's what I said.
if FF has proven one thing its that they CANT learn from their "competition" and by competition i guess they mean chrome - who beats FF by MASSIVE margins (because FF has been a slow POS for years) FF is only around because people throw money at it so they can feel like good hippies 
In 2006? 10 years ago was not that long ago. jquery was a year old by then. And yeah - modern JS would look wildly bizarre to a web dev at the time. But the current standard project pattern (loosely) is what was used by everything I have worked on since the 90s in java and C. These are all old ideas that were ported to Javascript - thankfully. I remember writing ANT scripts to do all the stuff gulp and grunt do now for Flex and Flash. Gosh-- that was around the time I was writing Director scripts. Jeez I am freaking old. wtf. 
There is also a little trendiness at play. I think over the past few years the rise of Lodash and Underscore introduced the idea of FP to tons of new people. I think FP and languages that focus on it will be the preferred flavors of JS in the future. [Elm](http://elm-lang.org/) - for instance - it my absolute favorite framework right now. 
- Escaping: You always need to escape ' or ", vs needing to escape ` which is hardly ever used and having to escape one of ${ in the off-chance you need the two side-by-side, which you never ever do. - Compilers are smart. They will understand simple template literals with no interpolations well enough that no performance penalty is perceived
Well, I suppose this would have been good news 5 years ago. It's a bit late, Firefox, Chrome has most of us in their grasp..
I personally use ff &amp; chrome both to separate a bunch of browsing stuff and because of tree-style tabs in FF.
Why on earth would you be using one hash to store information for all instances? That 'memory leak' you describe is not inherent to using private scoped variables... but certainly your solution is leaky. Consider using a factory instead of a new'ed constructor. And look into Object.defineProperty to expose the values publicly, instead of a function.
Except the myth and misunderstanding of Firefox being slow is so incredibly wrong and pretty damn ignorant. Realistically, Firefox and Chrome are similar in terms of speed. It's when you start piling on unoptimised and bad extensions and external scripts that performance will begin to deteriorate. Chrome is just as susceptible to this issue as Firefox. The difference is that Chrome will use significantly more memory over other browsers.
Everyone comparing Firefox to Chrome etc needs to think about it, Google is monitoring you through so many other things why give them something else to do it with? Plus Chromes not faster then Firefox, have been using Firefox dev edition with multi proccess for ages, would never go back.
Have you opened a large JS driven project on FF? If you do, then open it with Chrome and you'll see the big difference. Chrome is much faster. Our Front-end team hates to open FF as well.
Can't say I have, just don't like putting all my eggs in one basket and I also like to promote competition haha
Babel turns template literals with no templated values into double-quoted strings.
You are right about then and catch always returning a promise. However, if I understand it correctly, it is always a Promise.resolve(). If you want to report an error from a .then() you do have to return a Promise.reject().
If you return an Error, it will resolve to the Error (which is ... odd, but if you need to create Errors asynchronously, then I guess it would make sense), but if you throw an Error it will reject.
Strictly better is a pretty common term outside the magic community as well. Something can be objectively better if its benefits outweigh the costs, but for it to be strictly better it needs to have benefits *without* costs. 
Not, it's not. I'm not a lawyer, but as I understand the [license](https://github.com/facebook/react/blob/master/PATENTS), If you are using React then you are giving facebook a loophole into your patents: &gt; The license granted hereunder will terminate, automatically and without notice, if you ... initiate directly or indirectly, or take a direct financial interest in, any Patent Assertion: (i) against Facebook ... So they can just make use of all of your patents not having to fear you sue them if your business is built on React. Thanks for the link though.
It's true that hot reloading is more helpful for junior programmers or designers. Senior programmer can usually implement new feature even without trying it out in the browser if the codebase has decent code coverage. But it's crucial for those who need to learn in the process.
I don't know if this is the case here, but some libs will 'cheat' on their implementations, resulting in less than 100% spec-compliance. It's usually some edge or corner cases, that perhaps remain for historical reasons, but which the native implementations _must_ honor. However, userland libs are free to break the spec, which can greatly simplify the implementation (and thus increase speed).
Using weak maps has actually become a [standard solution](http://exploringjs.com/es6/ch_classes.html#_private-data-via-weakmaps) now with ES6, and it's the basis for the proposed [private field syntax](https://github.com/tc39/proposal-private-fields).
That's a good choice, because it essentially gaurentees that later down the road they will need your services again. That's why I am currently writing an API for a client in COBOL, because when they want to add some new features or changes. . . Only I and a few 70 year olds will know how it do it.
&gt; What tech stack, and what guidelines, would you use for a project that you would have to maintain and support for the next 10 years? I don't mean "OK, 10 years on it still runs", I think that's a given for any standards-compliant project. I mean being able to have a junior dev join the project and add a new feature even though it was initially written when they were still in middle school. **Please don't do this.** I was hired into a job a few years back using a [tech stack from the 90s](https://en.wikipedia.org/wiki/PowerBuilder). The original code was written in 1996, some mild maintenance was performed in 2003 and again in 2008 due to regulation changes but the core was basically unchanged. My job was to create a 'modern' version of it (basically just a re-skin) using the same old technology. The only training materials available were the original manuals, some old video training cds and an old mailing list. Neither Google nor Stack Overflow helped with answers, it was simply too obscure. The programmers who originally created the application were planning to retire and they needed fresh blood to take over the maintenance. They had been trying to hire people for several years but few were willing to learn an obsolete technology from scratch, and the ones who did soon left. The owners resisted upgrading the stack or changing the languages used throughout the years because 'it still works'. They misjudged their expertise, and expertise it was, to be equivalent to current day technologies because 'it still works'. And now, they're stuck with never retiring or leaving their current customers hanging out to dry.
Afaik chrome's js engine is the slowest...
The only thing that is needed is react-hot in the loaders section, before babel. Starting the dev server through webpack-dev-server --inline --hot The code shouldn't need any changes or decorators.
It used CC-annotated JS for the UI. Nowadays, they'd properly use TypeScript instead. It also gives you type checking and documentation, but the tooling is much better. Additionally, it supports async/await, which is really handy for game scripting. In a multithreaded game, not everything is done right away or during the same frame.
I think you're best of hand-picking best of breed libraries yourself. That means quite a bit more research initially (and you're already doing the first step), but it means you'll get the freedom to move at your own pace and replace pieces as necessary. I don't think it's realistic to expect your stack in 10 years time to look the same as the one you will pick now. And pretty much any framework you could choose today is likely to be obsolete by then. So go for flexibility with (micro-)libraries instead, so you'll be able to call the shots. It'll be some more maintenance work than picking an off-the-shelf framework, but you'll be running a marathon rather than a sprint. There are a few specific libraries I could recommend for your stack: * **React**. Facebook has a very pragmatic upgrade policy, which is a necessity given they've built pretty much their entire product on top of it. But it means they never remove an API until the *previous* version offered a good replacement. This allows for smooth, gradual upgrades and I think React can probably satisfy your needs for at least 5 more years. After that is anyone's guess, but there'll probably be a reasonable migration strategy to whatever might take its place. * **babel**. It'll probably stick around for a while, though its last major version update was quite bumpy. But the most important value it provides is that it allows you to set your own pace for which EcmaScript version you want to work in, so that you can keep up with the times and hopefully don't still have an ES5 codebase in 10 years time (I cannot imagine any junior dev by then being happy about that). Given your long-term situation however, I'd stay clear of the experimental language features as you'd never know how long they'll remain supported. * **js-cookie**. One of the most stable cookie libraries. It survived from back when it was a jQuery plugin, and probably be around a while longer. But as you'll see that leaves quite some gaps in your stack wide open. I won't pretend to know all the right answers, just my general advice (besides the good characteristics you already mentioned): Look for widely adopted libraries with a stable track record. And keep the door open for any of them to move on if there's a clear, significant benefit to doing so.
I've been using Ember and love it but React is the crazy kool-aid right now. I think Ember loses out to React because you can't incrementally adopt it and for most of us, we aren't often doing greenfield development. React does a small thing very well and it's a thing you can add to an app pretty easily, once you take that first step it's hard not to try out Redux/Flux, React-Router, etc. Personally I find all of them rather poorly thought out compared to Ember but I think people just suck it up initially and to be honest, once you know the quirks you don't actually think too much about them.
TL;DR; 
I agree that the question is _terribly_ explained. Your _tale_ is too large and filled with details of little relevance, and the question itself is, instead, not that well explained. The real problem is that the two options you want to compare are not clear. They are _probably_ not the only two options you should consider, too. As I understand it, the current situation is this: - The company has a number of independent, separate databases. - People access _some_ of those databases (depending on their permissions or something). - People run queries to generate _reports_. - Right now, those "reports" end up being "just static images" made from the queries, and some text they write up. They write these "reports" as HTML and they publish them somewhere... Things that are not really too clear: - They run the query, generate a CSV file and... how do they actually generate the images? Do they, say, use Excel? Do they have any specific software? - Do they _really_ need the CSV files? Do they run the same CSV through [whatever] to get different images, say two weeks later? Or do they just generate the image/report and discard the CSV? - Where do they actually put those "reports"? Is there a centralized place where they publish them or do they just sort of leave a static HTML in some shared folder or do they run their own little local web-servers or what? - What is the _final purpose_? What are those "reports" for? Are they for their own consumption? Do they share/show/discuss the "reports" with other people? Are they presented at meetings or get compiled and used over time? What? And you want to propose a "better" solution. It _seems_ that from your POV, "better" means that it could be _fancier_ than having people throw static HTML and static images, and that... What? This is the point you **really** need to explain: What do you want to achieve with the new system? Centralization? Making the reports _real time_? Being able to catalogue the reports? Being able to automate report generation? Easier report sharing? More control over who sees what? Less control over who sees what? These are the important questions. Given all that, your current question ("Should this be done in a centralized manner (server side) or in a distributed manner (client side)?") seems rather difficult to answer in any meaningful way. Sorry. I can, however, offer you some ideas, based on a close (but different) experience: - People will have, probably without knowing it, a lot of reports very similar to other reports other people have. This is a waste. And this cannot be avoided if your system is "client side" and/or there's no way to _discover_ reports (a catalogue). A catalogue, generally means running at least some part in a centralized way. - People do generally reuse reports a lot. So automation should be a priority. Automation to the point of _not_ having to "run the report". This usually means generating reports on the fly, in real time, when you want to read it. - If people are already sharing the reports in any way, then your access system better take that into account or it is just useless. i.e. If data is sensitive, you need access management when _reading_ the reports, so that means centralization. - It's generally a _good idea_ to use standardized visualizations. Some people will use really bad visualizations which really hinders communication. If the reports are meant to be shared a catalogue of visualizations, with standard ways to apply them, is usually a benefit for everybody. If the reports are for personal usage... maybe you don't need a "better" system. _I_, personally, would tend towards a centralized system, where people can create, store, automate and share reports. Such a system may take one person about 9 months to a year. Depending on some other factors you haven't specified, it could take double that time or a little less than that time. Also, mmm, did you get the memo about the new covers on the reports?
Pretty much my only gripe with backticks is that it's a dead key on Finnish keyboards, even though accents aren't even used in Finnish. At least on OSX you can use [Ukulele](http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&amp;id=ukelele) to disable the dead key behavior on backticks. But I guess that's not a great solution for languages where it's actually needed.
&gt; framework-agnostic minimal date picker. &gt; DPicker depends on moment and the hyperscript library of your choice. Is this what's called '*-agnostic' nowadays?
TL;DR - Op thinks **static JPG files** are overloading the system and wants to replace it with a system where users can query for any data they want at any time. No, Op. This is insane, and they're absolutely correct to tell you *No*. It would not be secure, it would not be optimizable, and and constant dynamics queries are much, much, much worse on the system that generating JPGs now and then and serving them statically.
You're right, you can reject with anything, or even no value at all. The problem here is that if anything throws then the promise will end up rejected with the error from the exception. So for consistency I like to always reject with an error. It makes things much simpler when you start passing promises around. Make sure *every* promise chain ends with (at least): .catch((err) =&gt; console.error(err)) otherwise your promise chains will silently swallow exceptions and you'll chase mystery bugs for weeks!
For which JS engine and version in combination with which compiler (if any) and version? The author could have done some tests but the results are likely to be very specific to the test configuration used and thus limited in usefulness. Not to mention the fact that the information will age quickly as new browsers and JS engines appear. 
I think you'd want the opposite of something like Angular - a more modular approach with specific libraries for each part. Then you can swap out the obsolete ones over time without rewriting the whole app. 
V8 is one if the fastest engines around. Node is build on it.
Well, as far as I see it, **the only way to handle such a long term project is by, updating the code and docs every year to stay current.** So on top of version-specific docs, you should also be looking out at tech which had good migration paths in past. On top of my head, I remember: - ember has the best reputation in terms of migration path in js land. Ember 2.0 was simply ember 1.9 without the deprecated modules, and 2.x releases are backward compatible to 2.0 . - Another js framework which I would recommend is aurelia. While it is quite new.(It hit 1. barely few months ago). Its developer originally created durandal and provided direct migration path from durandal to aurelia. This is very impressive in my opinion. OR, if you want prefer libraries to js framework to avoid vender lock in. - React is good choice. while react has seen quite a lot of churn in early days, React has matured well and fb uses react way too much to introduce painful breaking changes. - if you don't like react, then maybe Vue will be more to your taste . Vue has a very good migration record in 0.12 to 1.0 migration by providing a migration build. With vue2, which is complete rewrite but still has largely the same API of 1.x and will have a migration helper cli tool(currently in beta) when Vue2 is released. 
My bullet-time firework simulator! http://codepen.io/SarahC/pen/vXNjAb
&gt; I can almost certainly say that you're not writing code that needs to be performance tweaked to the level where it matters if you use backticks or not. Without first checking on what those performance differences are, how do you know? Some people care about efficiency differences in different techniques for iterating over arrays - why would creating strings (eg in a tight loop) be any different? My point is not that it's *necessarily* significant to everyone who ever writes JS. My point is that the author completely ignored all runtime considerations, not even checking if there was a significant difference for *anyone* before advocating a particular approach for *everyone, all the time*.
To be fair, working with dates is made much easier with moment.
Really well done. Nice work. I understand you probably want to keep it minimal, but one thing I would consider adding would be some type of arrows to go forward/back months. That's a common use-case that is currently a little cumbersome using the drop-down.
those are not frameworks, are they?
And hyperscript is used in most of your frameworks, so in theory it's not adding a dependency, just re-using one you already have (at least that's the point). Hyperscript-like libraries are helping to keep the code simple (for example events handling, dom rendering). 
It was the fastest by far when it launched. That's when node was built with it. I recently read somewhere that all the other engines have made improvements that boosted their speed above v8. I tried to find the article, but had no luck so it may not be true.
whoa that's really damn cool!
&gt; And if you're already using a framework, looking for a framework-agnostic third-party component doesn't make much sense, because hurr-durr-ecosystem. I'm not sure about this, having components that works with angular, react but also any other is, imo, a great deal in keeping this separated. &gt; The point is that instead of one framework dependency (which is often in the place already) it requires two libs (which are often not). react-dom can be used instead of maquettejs for example. Hmm, if you're playing with Dates you often use moment. Anyway, with a date picker you've to do a lot of tests on dates. Implementing those tests would add a lot of code, and moment really helps through that (+ localization!).
ImmutableJS is really nice, but be careful of performance issues when dealing with large data structures. It can be significantly slower than raw js in many circumstances.
Hey - Can you explain the logic here? I think it's where your problem is. while (looper === true) { page21st(); } 
Angular 1 to 2 migration might as well be called a rewrite. Besides with angular 3 coming in 6 months, angular can not be considered stable for sure. 
&gt; What tech stack, and what guidelines, would you use for a project that you would have to maintain and support for the next 10 years? Whatever your solution, make sure it offers the following: * Encapsulation * Abstraction * Immutability * Static type checking I personally would **not even consider** using anything trendy like React, Vue, Angular, babel etc. I would use only proven libraries with a long track record (really only jQuery, and only if necessary). I would use lodash. Functional programming may be trendy, but it's also been a proven software engineering paradigm for many decades. Same with static type checking, so use Typescript (not Flow... Flow is not bad but at this point Typescript is far more mature, more highly adopted and has better pedigree behind it).
This is cool but is there a reason for not having your loop on requestAnimationFrame?? It might give better performance.
The joke is really on Google for thinking that my browsing habits actually have the consistency to predict purchases...
No. 
Important steps toward a healthy standard library 
Thank you guys for responding, finally I get some answers. I'l check out some tutorials, and see what I can find.
In my limited experience, rolling your own solution can result in an unmaintainable mess just as bad as having lots of dependencies, due to isolation of knowledge of the system. 
Ohh I noticed it was old but didn't know this was the case. I'm intrigued by ELM since I have been working with redux. Thanks for sharing.
That is too much cognitive load. Get someone to help you.
Isn't vue the favorite of Laravel now 
If there is one truism about javascript its that there will be yet another framework coming down the line in a month. I love the vibrancy of that - though to newcomers it can be a little daunting. 
finished my [HTML quine](http://kirjava.xyz/quine3.html) 
I am a PHP developer who's diving into Laravel. I have worked with React and Vue. If PHP is your primary focus, I'd recommend taking a look at Vue. It is easy to dig into and Laracasts has some great videos on it. I'm using Vuex (their flavor of Flux/Redux) with single page components and it feels a lot like React, but I feel more productive with Vue. Vue-CLI is a big reason for that because I was able to avoid all of the tooling setup that I dealt with when using React. My long term plan is to move to React/Redux and Vue/Vuex is a really nice stepping stone to get there. Give it a shot!
&gt; And hyperscript is used in most of your frameworks Can you give an example? This is the first time I'm hearing about it and none of the frameworks/libraries I've used depend on it (as far as I know).
This is what I termed "Private by scope with method duplication". The objection I have to it is every instance of your object gets a new copy of the methods, rather than referencing a shared prototype's methods. So there are (potential) performance issues, which I admit are not likely if in most cases you aren't making `n` objects but you should be aware of. Also I think it does not feel correct because of this duplication, but feelings are obviously not a strong argument.
This is one of the reasons I dislike the modern reliance on NPM and grunt. How many of these projects are going to be buildable in 10 years?
Nice. I built a very limited but very lightweight date picker awhile ago. Might be all someone needs. https://cadejscroggins.github.io/multi-date-picker/
IIRC, V8 is in the midst of a big "rewrite" for their JIT related tech. The current pipeline seems to have spiraled out of control in terms of complexity and they'll be moving to simplify it, which should make continuing to make it faster easier.
Mmm... I don't really think I can grasp to what extent your people want to customize the data, but I'll describe a bit what we have in development where I work now. We're still in development so some of this is not _yet_ working. But the goal is this: There's a "reports application". You log in with your company credentials. You create a report by writing your own custom SQL query/queries. You then select a number of visualizations (a simple data table you can export, a number of graphs). You _save_ your report. It is stored and you can modify it in the future if you need to. Reports are then _read_. For reasons irrelevant to your situation, anyone can _read_ everyone else's reports (our data is not that sensitive and we have other concerns). Most people just use the reports made by a handful of people who are specifically dedicated to creating reports. At first, a lot of people where requesting custom reports with this or that query. In time, a number of general reports end up making sense and the rest is just very specific situations which arise from time to time. The system allows anyone to create those specific reports. It's just that most people don't need that. _Our_ goals were: 1. automation and reuse 2. sharing reports easily 3. still allow for very specific reports to be built when needed The hardest part is the visualizations. If you need such customized data massaging as you mention, you will probably find a similar situation. Some people will still want exporting the data and generating the visualizations on their own. In our case this was true, but only for a small number of occurrences. And it is precisely this type of details what you should be thinking about. Will people still need that level of customization? If they will, you'll find it _extremely_ hard to make a general tool that works for all of them better than what they each already have. On the other hand it _may_ be that they _think_ they need it, but could work fine with simpler reports. Just do some analysis of what they actually need and what can and cannot be improved. You may find that improving just some parts (say, the _publication_ of the reports) while leaving the rest open, is enough.
I agree with what you said, but neither you nor OP really covered a good example for using Promise.resolve(). One use case I have for it is when you have a function that will return data from an API, but you also want to have a local cache of the previous call. You still want that function to return a promise, so you use a Promise.resolve() on the cache. e.g. function getIdentity() { if (localcache) { return Promise.resolve(localccache); } return api.getIdentity(); } Disclaimer: On mobile, don't know how to format code.
By hyperscript, I mean virtual dom librairies react has react-dom library which should work the same. For cycle.js they have @cycle/dom with a [hyperscript substract](https://github.com/cyclejs/cyclejs/tree/master/dom#-h). I'll think about documenting more of those.
Hopefully they don't! You made your point, I'll try to seek for a better description! With moment you can offer a nice api for customization, [this for example](https://github.com/soyuka/dpicker/issues/19#issuecomment-237256008) adds previous/next months buttons. Btw you should've kept the `npm install command`, I'll take a look at this!
My [Fretboard](http://BlossomAssociates.net/Music/Fretboard.html)
In the section on building sequences, you should use `reduce` rather than `forEach`: const sequence = dataFiles.reduce((promise, url) =&gt; { return promise .then(() =&gt; get(url)) .then((response) =&gt; displayImage(JSON.parse(response).image)); }, Promise.resolve());
I just published a Chrome extension for overriding sites with your own CSS rules. Here it is in the [Chrome store](https://chrome.google.com/webstore/detail/turnstyle/mcclmlgcklibbacamgggjlllfcpodaij) and on [Github](https://github.com/danfriedman0/turnStyle).
I didn't build it this weekend, but my JS interactive art framework is on display at SPARKcon this weekend. Pics and videos: https://goo.gl/photos/bmxoATx5K7Dor52F9 Project page: http://kimotion.xyz
https://cx.codaxy.com/starter/dashboards/sales
`then` waits for a promise to resolve and then passes the resolved value to the callback. That's the core of it. The problem in your code is that your `resolve` call in your second block is not passed any arguments. Look at your first block - you're passing a string to `resolve` and you're not surprised to receive it in the 2nd handler. If you change your second block's `resolve` call to `resolve(42)` you will receive `42` in the 3rd block. BTW, avoid the pattern you're using with the `Promise` constructor. This should be used primarily as a bridge between callback-based APIs and Promises. For synchronous values, use `Promise.resolve` or `Promise.reject` to start the promise chain. For example, your sample code might look like, Promise.resolve('1st resolve') .then(result =&gt; { console.log(result); return Promise.resolve(42) }) .then(result2 =&gt; { // 42 console.log(result2); }) .catch(console.error); Edit: One thing to add - you should consider non-promises returned from a `then` block to be wrapped in an implicit `Promise.resolve` after return. 
The parameter passed to the (first) callback of `then` is always the value that the previous promise resolved to. In your second example you're resolving the promise with `undefined` by writing `resolve()`, so that's why you get `undefined` in the callback. If you resolve it with an actual value then you'll see that value in the callback. By the way, if you want a resolved promise, there's a specific constructor for that: `Promise.resolve(value)`. Where I think you're getting confused is that if you don't return a promise from the callback, then the value is automatically wrapped in a resolved promise. That's what's happening in the first example. So it's not the case that whatever you return is what gets passed to the next thing. It's the resolved value, either from the wrapped promise or from the returned promise. 
Thanks! I get it now. Also thanks for mentioning Promise.resolve(). 
It should've been more obvious to me that it was logging `undefined` because I didn't pass anything to `resolve()`. Anyways, I got it now. Also thanks for mentioning `Promise.resolve` and `Promise.reject`. Didn't know about those.
I appreciate the snark, but not everyone wants to spend half of everyday explaining "Flux/redux/reflux architecture".
You used the new operator which creates an object inheriting from the prototype of the given function. Check out [new operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new).
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String
Look at the 'Date' class and parse method. You could also look at regular expressions to validate the format of the date before parsing it to check that the date is real. E.g. Not 31/02/2016
You can use [.substring](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/substring) method: var year = inputString.substring(inputString.length - 4); or [.slice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/slice) var year = inputString.slice(-4);
To me the last pattern seems most natural. This isn't only the pattern that jQuery follows, but all DOM-event handling as well (addEventListener(ev, cb), removeEventListener(ev, cb)). As for the name, I'd say "register"/"unregister" seems appropriate.
Umm, why are we arbitrarily restricted to Haskell or Lisp? Erlang has been powering telecom switches for several decades now with some insane level of availability, like nine nines or similar. Just to drive the point home: this is the software that lets people around the world make phone calls. Oh, and not to mention WhatsApp, which handles a similar volume of message traffic to the entire level of SMS traffic across all carriers worldwide, with an Erlang codebase and something like 50 engineers.
Would you suggest register / unregister for reducers, middleware, or update callbacks? I have three different things being bound and need to somehow intuitively give them different endpoints That or unintuitively have one endpoint that determines the expected behavior based on the paramters
assuming `inputSting` is the input you get from the user var birthYear = new Date(inputString).getFullYear(); var now = new Date().getFullYear(); var age = Math.abs(now - birthYear); The key here is passing the input date string into the `Date` construction (`new Date`) that will handle a string like that when `Date.parse` might fail. calling `new Date` like that creates a new date from the date string which then gives you access to all the date functions like `getFullYear`
I was referring to the reducers, for me the whole list would be: * add or remove update cbs: listen/unlisten * add or remove reducers: register/unregister * add middlewares: use * action emission: dispatch EDIT: formatting is garbage, its a bullet list alright
I can think of some situations where unbinding middleware may be useful -- imagine if you have a game and someone uses an ability that makes "the next attack miss", you could bind one-time middleware to interrupt the action and then unbind it Would you say unuse for that?
You could use `String.prototype.split`: '03/11/1975'.split('/') would return an array with the day, month and year ['03', '11', '1975'] Or `.substring` '03/11/1975'.substring(6); would return `'1975'` 
I only use them if I need to include a variable in a string. Otherwise I use single quote strings. 
A valid point. Guess I shouldn't let people remove middleware :) Thanks for the advice.
See also: `Promise.reject()`. Returning a rejected promise from any `then` callback is a good way to skip to your `catch`, or to just fail out of whatever promise chain you are running.
this is pretty naive approach, but just load the file into memory, split by new line then commas - and create an object indexed by the two types. I'm going to use node as I'm not sure the syntax around phonegap, just google `phonegap read file` I suppose. Once you have the contents as a string [and es6 :)] the following should work: const indexedErrors = fs.readFileSync('./errors.txt') .toString() .split('\n') .map(line =&gt; line.split(',')) .reduce((memo, item) =&gt; { const key = `${item[0]}-${item[1]}`; memo[key] = item[2] return memo }, {}) after that, indexedErrors should look something like this: { '12-4': 'Data Failure', '13-9': 'No data', '14-5': 'File encrypted', '17-2': 'No file present' } If you have access to the two codes the user searched for, you can return the string by accessing the right key in the object, const errorCodeA = 14 const errorCodeB = 5 const key = `${errorCodeA}-${errorCodeB}` const message = indexedErrors[key] // file encrypted
We've found simple things like iterations and maps to be quite slow with ImmutableJS.
You can do fingerprinting with Flash and to limited degree CSS (fonts/canvas). So it is not a "capability of JavaScript" but "capability of the browser". 
These are DOM APIs and inherent to the browsers the user uses. They also vary by browser. This is not provided by JavaScript nor is it on JavaScript to lock down. Also, it really bothers me that getting the dimensions of a rendered element is on this privacy list... that's a basic requirement for the browser to render box elements. Developers use this every day in order to render the websites you browse, yet it's considered a security concern because a dev now knows the pixel dimensions of an element on screen? If that's the level of privacy you're worried about, you should just avoid the internet completely. 
Oh I see. Originally I was looping through my arrays and comparing values but I had some issues with that so I thought that I could simplify my problems and do some trouble shooting by comparing the arrays themselves. Thanks for the feedback, I'll probably end up making another post asking for some help with looping the arrays and comparing the values later.
I feel the same way you do. I have a production codebase (as in, makes money every day) that I change maybe once every six months. It's over four years old and still going strong. Here are the key ideas I use: 1) Create a reproducible build. Make sure that `git checkout` (or equivalent) gives you *everything* you need to build your app, completely disconnected from the Internet. That means that you can use npm, but you need to check in your `node_modules` directory. I wrote about this [here](http://www.letscodejavascript.com/v3/blog/2014/12/the_reliable_build). 2) Ignore the fads. The JS community is incredibly fad-driven. There's a very good chance that the tools people love today will be discarded in two years. I have a list of my preferred, battle-tested tools [here](http://www.letscodejavascript.com/v3/blog/2015/02/javascript_tooling). 3) Build for the browser. This means ignoring the cutting-edge ES6 features that don't work in the browsers you're targeting. A bit of a pain, but it means you get to skip Babel, Webpack, and other tools that go out of date quickly. When the features you ignored are finally supported, you can incrementally upgrade at your convenience. 4) Architect for the long-term. Build your code to carefully isolate third-party code. Prefer libraries to framework (they're easier to isolate). Pay careful attention to design. Good luck!
OK, I am doing this line by line to get it to work. However, I am a little lost. This is what I have thus far: &lt;script&gt; var request = new XMLHttpRequest(); request.open("GET", "test.txt"); request.onreadystatechange = function() {//Call a function when the state changes. if (request.readyState == 4) { const inErrors = request.responseText; console.log(inErrors); inErrors.toString(); inErrors.split('\n'); inErrors.map(line =&gt; line.split(',')); } } console.log("Contents of 'Error File'!"); request.send(); &lt;/script&gt; However, I receive an error on inErrors.map(line =&gt; line.split(',')); I am sure it is the way I formatted it. What am I doing wrong?
By default, process warnings are output to stderr, so everyone will see them unless they're manually catching the event and doing something different with it. 
String.prototype.split
Browser fingerprinting techniques come from taking many reasonable APIs (for example, rendering a 3D object in a canvas element) and exploiting how different browsers, operating systems, and hardware may act slightly differently when running the same code. Sometimes, browsers can do things to mitigate these issues (like how browsers prompt you before allowing websites to use your camera, or geolocation, or WebRTC), but other times the only solution would be to remove that particular API entirely. Many fingerprinting techniques don't rely on JavaScript, and instead look at things like the particular types of headers your browser sends. Any bit of data that can differ from one browser to another can be exploited to add to the accuracy of a fingerprint.
&gt; each time I make a change with the controller I redraw it Just alter the relevant properties inline on the SVG. SVG was meant to be altered in place. if you want to redraw the entire thing every frame, just use canvas.
[removed]
It is! It's right down there at the bottom. I wrapped it in a setTimeout as it's one of the accepted design patterns for specifying a lower frames-per-second in a variable. Up at the top you can see the FPS variable. My animation loop's a bit off - if you set it to 40FPS and there's lots on the screen it wont quite make 40, even though it's supposed to remove the time delta of frame construction between frame renders. If I've missed something though, please let me know - I'm *hoping* requestAnimationFrames still there... I might have deleted it while editing or something.?
What is really killing performance isn't the rendering of an arc for the particles (surprising)....... It's the ONE COMMAND that copies the smoke billboard image from the backbuffer canvas to the visual canvas.... I'm at a loss of a workaround.
 function isEqual(array1, array2){ if (array1.length != array2.length){ return false; } for (var i=0;i&lt;array1.length;i++){ if (array1[i] !== array2[i]){ return false; } } return true; }
Others have already explained your issue, but here's an alternative solution to your problem. To compare two arrays of primitive values, you could simply convert them to strings with join() So in your case xLocation.join() === wins[0].join() Each will be converted to a short string of the values and you can certainly compare those. 
As a follow up that would also work with more complex objects, you could stringify both objects and compare. JSON.stringify(anObject) === JSON.stringify(anotherObject) I wouldn't promise anything on the efficiency of either of these, but it won't matter in the context of tic tac toe.
What were you really trying to do? (Maybe we can help you!) Or were you simply experimenting with syntax? 
Note: will only work for an array of primitives. Objects compare the same way that arrays do. 
I seem to be out of the loop. What the hell happened? 
Cool!
[removed]
Hasn't seem to change anything, I also get the error placeOrder is not defined when I click the form button.
Try isNaN(document.getElementById("pickupminutets").value) Also, check your parenthesis where you said the error is happening. 
[Read this](https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html)
`this` will refer to f object if v is assigned to f f = {} v = function (e) {} // this is window f.v = v // this is f c = new v() // this is c 
Hey, any chance we can chat offline. Would like to ask you more about how you rebuilt your stuff in A2. Specifically the unit testing with inject and testbed and all the new stuff. 
Yeah drop the parenthesis just before || to get them balanced
 function placeOrder(form){ if (document.getElementById("name").value === "") { alert("You must place a name"); } else if (document.getElementById("pickupminutes").value === "" || isNaN(document.getElementById("pickupminutes").value)) { alert("You must enter in a time"); } else { alert("Thank You"); } } I'm assuming this is because JS expects the conditional after "if" to be encapsulated with parenthesis, not just a bare statement like you had it. By removing the parenthesis nearest the `OR` it makes it a single parenthetical. Also I changed some other things. isNaN is the biggest, and as other posters mentioned, use ===. 
Thanks + congrats. This is precisely the sort of thing I intend to do in a very near future so I bookmarked it. Honestly I am a bit afraid of its duration of 1h 13min. I haven't yet attempted to watch it, but I usually get quickly confused and bored by videos about coding. If I may, I would like to suggest the following : * break it apart in 15min episodes. This way I, or any viewer, can watch an episode, do their homework, arrive to a partial yet stable and working stage, then come back for the next step right away or later. * for each episode, post related code chunks on [github](https://github.com). I don't mind typing, and here typing my own code would certainly have pedagogic value, however I'm certainly not going to type code *while watching a video and trying to figure what's going on*. Even if I play-pause-type etc, typos and other errors are likely to creep in and having the reference code at hand would do great in overcoming those inevitable hurdles. A wild idea just appeared about posting on github : readers could fork it, amend or develop it and boast about what they've arrived to. A lively conversation and a healthy emulation would ensue.
Hey Neker, thanks for the insightful comment and taking the time to write it. Sorry about the duration, tried to go for functionality over modularization and turning it into a 4 hour series. I wanted to find a good balance between explaining what I was doing and not taking forever. I did make a few shorter parts of building a mean stack application but I finally just made this because I had been itching to do put it out there for a while, but I try to keep most of my videos under 10 minutes. I post a lot of my code on github if that's what you mean: https://github.com/andersontr15 Thanks again, and let me know if I can help out or if you want to see any other videos. Cheers
I wrote a dead simple javascript plugin to show non blocking notifications on site. No jQuery required. Demo: http://carlosroso.com/notyf/ Source code: https://github.com/caroso1222/notyf 
this is the best answer 😀 Some more explanation: `this` is a context in which function is run. Generally `this` is set to the object on which function is set as a property. However there are some other cases: - anonymous function, not part of any object, `this` is set to a global object, in browser it is `Window` - using `new` sets `this` to newly created object - you can also set context permanently with `bind` or temporarily with `call` or `apply` - using fat arrow (`=&gt;`) binds context to the surrounding scope `bind` is usefull when you attach some function to the object, but want to remain it's context. For example: var o = { name: 'Joe', getName: function() { return this.name;} }; var b = { getName: o.getName.bind(o) } b.getName(); // "Joe"
[removed]
If your array is all primitives you could also simply use JSON.stringify on both and then compare with ===
Thank you very much for all your help so far everyone. In case I haven't made myself clear enough in various replies this is the methodology of utilising the package. var f = require("faker"); //first I declare this var Commerce = function (faker) { var self = this; self.productName = function() { return faker.commerce.productAdjective() + " " + faker.commerce.productMaterial() + " " + faker.commerce.product(); }; // this is an example of code included within the package f.commerce.productName() //this is what I do to call the above self.productName function.
This. Missing parens around the whole else condition.
Weird seeing my name in a post, thanks! And yes, this is still badass. 
I'm on mobile, but look at this line: https://github.com/Marak/faker.js/blob/master/lib/index.js#L83 Basically, Commerce is a constructor in Javascript terms. When doing new Commerce, you create a new object (this), assign methods to it, then that object is assigned to commerce. 
There is a whole library within the package, what I have provided is just a snapshot of the code I experimented with. As u/thysultan replied above, I suspect there is a bit in the code where a constructor is created like this: f.commerce = new Commerce(faker) and Commerce(faker) creates a new object with productName function in it. I haven't looked and found that bit but I suspect that is the case :)
Let's examine the operations: var f = require("faker"); We create variable `f` which will reference what is exported in https://github.com/Marak/faker.js/blob/master/index.js In this file you have: var Faker = require('./lib'); var faker = new Faker({ locales: require('./lib/locales') }); module['exports'] = faker; So we export object created with `new Faker()`. And what is `Faker`? `Faker` references what is exported in https://github.com/Marak/faker.js/blob/master/lib/index.js. And what is exported in `lib/index.js`? module['exports'] = Faker; So it exports `function Faker (opts) {...}`. And in that function you have: var Commerce = require('./commerce'); self.commerce = new Commerce(self); If you put this operations in one file you will have: function Faker (opts) { var self = this; var Commerce = require('./commerce'); self.commerce = new Commerce(self); } var faker = new Faker({ locales: require('./lib/locales') }); var f = faker; And what is `self` here? Functions have access to outer scope when they are defined. So in this case we save a reference to the outer scope which is `Window` in this case. And we attach things to Window object because `this` could change. Probably better would be to attach to function object like: var self = Faker;
That missing line of code is the key which pulls it all together, yes. 
Good stuff!
Very impressive, especially the smoke illumination!
&gt; So with your open source project, sure it's perfectly good to use that as a learning experience. But for a business, you need a better reason than just "I want to learn". The better business reason is that you either want to be exactly like everybody else or you want to take a chance and do something better. I suspect most developers, especially corporate developers, are so incredibly far removed from business decisions that they would rather just play it safe and do extremely noncompetitive things for minor gains in perceived safety. &gt; You shouldn't expect to write one program which works in every environment without any code changes. Why not? This is what APIs are for. Its what makes things like Electron awesome. Personally I would rather write my application once than rewrite it from scratch uniquely for every different environment just so I could justify use of a framework that I don't even need.
I was using jslint to help me.
OP could just use react for it, or something similar which also uses a virtual DOM for speedups
Flowtype finds different errors, I think. I find the output easier to read than JShint, but both are useful. Your code returned this: https://www.flowtype.org/try/#0PQKgBAAgZgNg9gdzCYAoVUCuA7AxgFwEs5swAHGAQ1wFMB5AJwBMaGAKKOBgWwEoBvVIShg2TOLkzca2fADoA5jXwBRGDWmyAQgE8AkkzYAibJWlHecgG6UYmGmAC8joxbCDbrfKKMBNOJhg3JgAzt4U1A6UYKbmvADcqAC+qDQwIQ7CouKSmvJKqup5ugbGZIS4ANaYZNyE2Jj4NCEW1rb2To5grrxgAD592RJSMvnKahqjJYZG5VU1dQ1NLZY2dg7OYIQhAHKU2Gy8vfxgwMAqDAxcYAAWrA4AeqieDN7G-oHBYWCjrFuk0SIcUSSR+6QcHnUr2MABUbvtKmAPhYQckgA Don't know if you can see it there, it takes a while to load. 
Can I ask why you would not just use env variables or CLI arguments to set these values and then you don't need a bunch of config files that are tightly coupled to an environment?
Hi, good question. ENV variables still listed in some file, e.g. *init_aws.sh, init_development.sh, etc.* so they do act as config files, correct? The difference is that they are detached from code base and (most likely) maintained by a separate dev-ops, not a software developer. So using env variables for me is almost the same as using `config` module, ENV variables have **same problems**: * resource init code is completely separate from data * data (most likely) grouped by environment on high level, and by resource on a low level (instead of grouping it by resource in the first place) Problems I address in no-config
But you might not know when you first type it whether you'll end up needing to include a variable or not. If you do, then you'd have to refactor quotes and its escapes to backticks and its escapes. It could be easier to just stay with backticks, which babel will compile into painstaking anyhow
I'm kinda into the idea of grouping configurations by flavor instead of by environment. So that's nice. I see though that no-config returns a promise. It's more convenient from a programmers perspective to have configurations load synchronously. In fact, in the example provided in the documentation, not a single operation is async so it's kinda funny to be returning a promise. The co-wrapped generator in index.js yields just once to a non-yieldable type that causes it to throw!
Atomic css?
You can't have a good particle effect without "lighten" composite operation... it's the only good one! ;) Actually, I made a simple [particle effect thing](http://www.mrspeaker.net/dev/parcycle/) years ago - and it all started after learning about `globalCompositeOperation = "lighten"`.
Good catch, thank you, fixed. Will be testing it more these next days. Yeah, alkali.js is quite interesting!
I believe it's similar to the svg path syntax. Read up
I'd imagine that it seemed like a decent representation in the mid 90s before JSON. Back then nobody was interested in the brackets -- only the data. I once saw someone who used `toString()` for conversion to CSV. I've also seen `.toString().split(',')` used to unnest arrays of strings/numbers.
I think this is what I am looking for. I created a canvas element however, couldn't convert my SVG variable to HTML5 canvas object. I create the SVG from a library and have it as a variable. var c = document.getElementById("canvasContent"); var ctx = c.getContext("2d"); ctx.drawImage(shape, 0, 0); where `shape` contains the SVG. But that didn't work 
Ah, so if the returned value has the correct prototype it is not ignored?
Hey! Your little thing led me to build my little thing several years ago, http://jarrodoverson.com/static/demos/particleSystem/ Thanks for the inspiration!
This is an entertaining callback (pun intended) that reads like a video love letter to /u/mpjme. Are you sure you want to stick with that YouTube name?? 
Oh ok, I misread your pseudo code. Thanks.
It's the reddit way.
You should really add jquery. Jquery will solve all problems JavaScript related /s
what about rxjs so there's no side-effects? Using systemjs to load files would help too. Im pretty sure if he wrote it in typescript and compiled it in browser, would make it super easy.
sure. anything that’s easier than manually updating DOM subtrees. that’s too error prone
I think error prone is a bit of a fallacy. Using React is just as error prone as using vanilla js. The source of errors is not usually in the tools used, but in the methodology of the programmer. If the error comes from your tools, put in a ticket. If the error comes from you being a doofus, `$git gud`. 
Is shape an image tag, or an SVG tag? Trying to draw SVG on a canvas element seems to me like you might be taking the wrong approach. If you post a gist or live example somewhere I can have a look and might be able to help out a bit more.
Huh. Currying and 'this' sounds like a combination that deviates quite a bit from how currying is normally done. It would also add unnecessary complexity IMHO. It has helped me a lot in getting code to always behave as expected when I stick to functional programming patterns that are relevant in all functional languages, such as proper currying and pure functions. Even avoiding objects unless they are clean immutable data records. Many people have heard about Douglas Crockford's take on The Good Parts of Javascript. I found this more recent talk on The Better Parts interesting: http://www.youtube.com/watch?v=PSGEjv3Tqo0&amp;t=5m58s . The timestamp is for when he starts talking about things he is avoiding in Javascript, and why. What do you think about those ideas?
Reasoning about which parts exactly to update in which way, including shortcuts and performance constructions every step along the way has definitely more potential for “being a doofus” than using VDOM implementations
Orrr just use a VDOM to have one-directional data flow and debug less often.
I can show [this](https://jsfiddle.net/sdpfffcd/4/) example. I am also creating the SVG with this specific library called makerJS. So here `svg` is the SVG content that I want to convert to canvas
Same hadn't heard of it. It's...interesting? The syntax is a mixture of what you'd expect and odd references to some constants for declaring things. I find it far more awkward than jQuery for creating elements. But to each their own or however the saying goes. 
It's against best practices because the built dependencies can vary based on node environment and OS
 let j = Math.random(); let i = j &amp; 255; If you want efficiency, also drop the allocation of the { number: ..., index: ...} object In general, if you want the first n bits from the right, you need to logical and the number with (1&lt;&lt;n)-1. 1&lt;&lt;n is a 1 bit shifted n steps to the right, subtracting one gives you the number just before that, wenn all 1s being set collapse into the single bit on addition. 
&gt; We want to be able to do partial updates, meaning you don’t need to send the entire Pet object with its changes, you can just send the changes. To accomplish this, we’re calling a `get` first in the `update()` function, then merging our changes into the result of that operation. That doesn't seem safe. You should just use the [DocumentClient's update method](http://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB/DocumentClient.html#update-property.)
That's not even a valid way of getting the rightmost 8 bits, because `toString()` omits trailing zeros. Suppose your random number ends in ....010010010000. Your method is going to extract "01001001", but the last 8 bits are actually "10010000". In fact by your method the last bit will always be 1, so it's not even close to random. 
That was my first thought. But j &amp; 255 returns 0. I'm doing this on Node btw.
You realize that electron is a framework, right? &gt;If you can build a website, you can build a desktop app. Electron is a framework for creating native applications with web technologies like JavaScript, HTML, and CSS. It takes care of the hard parts so you can focus on the core of your application.
Gotcha. That's not an issue I have to worry about in my particular application, I guess. A user only ever updates their own resources, so the likelihood that we run into this situation is so small, it doesn't bother engineering for. And honestly, that's a situation you're going to run into with a classic update if multiple users can edit the same resource, unless you're using websockets. If someone else comes in and changes a resource after they have loaded it, you end up with the same issue.
 exports.update = function(event, context) { const payload = _.reduce(event.body, (memo, value, key) =&gt; { memo.ExpressionAttributeNames[`#${key}`] = key memo.ExpressionAttributeValues[`:${key}`] = value memo.UpdateExpression.push(`#${key} = :${key}`) return memo }, { TableName: 'Pets', Key: { petId: event.params.path.petId }, UpdateExpression: [], ExpressionAttributeNames: {}, ExpressionAttributeValues: {} }) payload.UpdateExpression = 'SET ' + payload.UpdateExpression.join(', ') dynamo.update(payload, context.done) } &gt; If someone else comes in and changes a resource after they have loaded it, you end up with the same issue. Consider this situation where the initial item in the DB looks like this: `{ foo: 'bar' }`. Now request A comes in to update that item with the following body: `{ hello: 'world', foo: 'baz' }`. And at the same time request B comes in with this body: `{ abc: 123, foo: 'qux' }`. Using your original method, the end result of the item would either have the body from request A or B depending on timing. However if you're using the DocumentClient's update method like shown above you would end up with an item that looked like: { abc: 123, hello: 'world', foo: 'baz' // or 'qux' depending on timing }
Thanks. I did not know that toString() omits trailing zeros.
this advice seems to violate part 3 of the twelve factor app, configs: &gt;Apps sometimes store config as constants in the code. This is a violation of twelve-factor, which requires **strict separation of config from code.** Config varies substantially across deploys, code does not. &gt;A litmus test for whether an app has all config correctly factored out of the code is whether the codebase could be made open source at any moment, without compromising any credentials. https://12factor.net/config apparently the author has gotten a lot of links to 12fa already (probably an indication of something), this is more for readers here who may not be aware of it.
toString doesn't omit trailing zeros... Try it yourself But it treats the number in bits if it starts with zero... weird stuff javascript, lol
&gt; toString doesn't omit trailing zeros Of course it does. Suppose `Math.random()` returns 0.03125, which is 0.00001000000000000000000000000000000000000000000000000 (with 53 bits of mantissa, since it's an IEEE double and that's how many bits of mantissa it has) in binary. (Never mind how uncommon the chances are, that's not relevant here.) &gt; (0.03125).toString(2) "0.00001" The lowest 8 bits of this number are without a doubt all zeros, but they've all been cut off. 
You need to understand how JSFiddle actually works. Click on the gear icon in the JS pane and look at the "load type" setting. The default is "onLoad", which means that JSFiddle wraps everything you type in the JS pane in a function and registers that function to run on the "load" event. Consequently, the functions like `run()` and `clearFunc()` are not global variables, and when you try to refer to them in your button handlers you get an error. Open the console and you'll see "ReferenceError: run is not defined". Always check the console. If you want JSFiddle to not wrap your code, choose a different setting. "No wrap - in &lt;body&gt;" is probably what you want. As to the other problem, every time you call `run()` you are installing event handlers for the next and prev buttons. If you install a second handler, the first one does not go away. So after pressing start twice, you now have two click handlers installed on those buttons which is why they increment and decrement by 2. [Here's how I'd write it](https://jsfiddle.net/t06s7bd2/7/). You only need to install the handlers once. Also, don't do stuff like `onclick="foo()"`. Keep your JS out of your markup. Install your handlers from JS. Notice how this version also works when wrapped in a function since it doesn't rely in defining names at global scope. Also there's no reason to keep looking up elements over and over. 
try this https://jsfiddle.net/t06s7bd2/11/ also as /u/salazar342 said, everytime you press start, it adds the event listener all over again. On clear.. you should remove the listeners. 
The constants are the same as the HTML names, Div shortened from HTMLDivElement and UL shortened from HTMLUListElement. I've been using it for some days now and it feels great. The reactive variables concept are really nice. 
"Vanilla Javascript" doesn't mean anything, please stop using that word. Javascript is a language, its API can or cannot be the DOM window.history.pushState It's not part of ECMA script spec (there is no window.history object in Node for instance), therefore it is not "vanilla javascript", it's a DOM API. Please stop embarrassing yourself.
I do have all of the external resources required on my page, I decided not to include that in my JSFiddle. I get no errors in Firebug (Using firefox). &lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.0/jquery-ui.min.js"&gt;&lt;/script&gt; Thanks for your reply!
Sublime! I learned about constructors in Java but without the whole complete picture of how the various bits of code came together in faker package, the function wrapper thing was confusing me as in Java you wouldn't make a constructor of a method but then I also learned today that function is an object in javascript. Your help has been monumental for me, thank you very much :)
Hey guys, I'd like to express my gratitude to everyone in this thread. Without your help, I wouldn't have learned what I learned today. I made a similar thread on stackoverflow, someone came in, scoffed at me for asking a "trivial question" and marked it as a duplicate. Reddit always comes to the rescue.
How does this work? The first statement returns false and the block exits? Is this a React syntax?
or use css like a man
Why are you suggesting to run npm install with the `--save-dev` parameter? I thought dev-dependencies are tools like babel or sass. Wouldn't `--save` make more sense? Otherwise looks like a really solid project!
Don't forget to ```gitignore``` your node modules ;)
You may have to use a [WebWorker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers), I believe that when tabs aren't active in some browsers, Javascript will pause execution.
But is that specific to Javascript? Any "useful" client-side language is probably going to expose fingerprint-able data.
&gt; Please stop embarrassing yourself. Oh shut the fuck up. This is a petty semantics argument. Nobody is embarassing themselves here except for you. 
"ECMA script"
The .delegate method is deprecated. You should use the .on method instead. You can use body for event delegation. $('body').on('click', '.some-class', function() {}); should work fine. Add the complete code to your jsfiddle so we can see what's going on.
I'll save going through the whole article and the linked part 2 for tomorrow, but so far this seems very well written. We need more articles on Webpack that don't skip over essential bits of information and take half of what they should be teaching for granted. I hope this is one. Looks promising so far.
Thanks!
What people have said about web workers is correct but I'll just add... Even `setTimeout` in a WebWorker won't reliably run every 16ms if the browser is busy doing other stuff in that thread. It might be delayed by tens of milliseconds. So another approach is to change your algorithm so that your count of stars doesn't depend on being regularly called to increment. E.g. record the start time of your app, and then in setTimeout compare `Date.now() - startTimeMilliseconds`, and use that to determine how many stars there should be. That way it doesn't even matter if your setTimeout doesn't get called for seconds while the other tab is active.
I made this presumption because almost all implementations to popular design patterns are made the same way with a very few differences. So to make it possible to answer my question properly, I only want to know what's the differences of in each implementation in these design patterns: **Module and Module reveal**, **Constructor**, **Singleton**, **Observer**, **Facade**, and **Mediator** patterns.
Ah I see, my understanding was deprecated methods would show an error in firebug - thanks for the clarification! Everything works as intended, thanks for your time :)
&gt; Except the myth and misunderstanding of Firefox being slow is so incredibly wrong and pretty damn ignorant. in my real world usage FF is painfully slow. using the same (very small number) of extensions i use in chrome.
Hey those are pretty awesome! Nice job.
I'd try to see if all of the extensions used are decently optimized. I run Firefox with ~30 extensions and some greasemonkey scripts. It does have some slowdown in specific circumstances that I'm fully aware of the cause (a couple badly written extensions). Other than that, it's just as fast as my 2 extension chrome install (ublock and stylish). I do hope you find a solution if you want to continue using Firefox.
What's "SNES style" about these? They're neat, but I don't get the connection.
Very cool! Thanks so much!
How come if I want to add a third thing to it, such as: { !!this.state.showComponent &amp;&amp; this.otherFunctionIdLikeToExecute &amp;&amp; &lt;NewComponent /&gt; } it doesn't work? Even if this.otherFunctionIdLikeToExecute returns true at the end. EDIT: It does work! It was a typo!
Completely non-working on iphone.
&gt; I've followed a few routers in the past and they tend to try and avoid running regex on every single route. Can you list some examples of good js routers?
Looks very nice! If you want to take it to the next level of authenticity, you can always divide the canvas up into the SNES resolution of 256x224. That'd really sell the retro animation aspect. 
This is built into a self-contained library, so the files in dist already have their dependencies bundled. Most people only use the files in dist, so the build dependencies are in devDependencies so they aren't installed when you npm install the package.
In this case, I would recommend using [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter) instead as it's much more concise and doesn't mutate the array it operates on. deleted: function(id) { this.setState({ elements: this.state.elements.filter(element =&gt; element.id === id) }); } 
not sure I understand correctly but a "loop" doesn't sound like the right answer. My solution would be to instead of using a loop, give each "child" object a reference to the parent object and have the parent object be able to "listen" to updates from child objects, like so: function childObject(parentObject, x, y){ this.parentObject = parentObject; this.x = x; this.y = y; this.updateX = updateX; this.updateY = updateY; function updateX(x){ this.x = x; parentObject.updateChildPostions(); } function updateY(y){ this.y = y; parentObject.updateChildPostions(); } } This way you will not need "loops" to update child objects relative to the parent, instead the parent updates based on an "event" system whenever the child updates. However if the parent knows who all of its children are then there is no need for this, since the parent will know the positions anyway by checking the child objects reference. Can you paste come code for example if this solution doesn't make sense? 
A little after posting, I had the realisation that I was trying to be too concise in my code. The method you describe above is pretty much what I'm implementing currently. My main concern was, as you suggested above, keeping positions relative so that I could track clicks on the objects. No longer a problem. Thanks!
I only ever used toString for debugging output. The contract of "toString" isn't to represent the data structure perfectly but to present something that can be printed to the console. JavaScript doesn't know what data structure you're trying to display, so it does what is can do best. Consider a 3 dimensional array, how can javascript infer how you want to display it: var nByN3dArray = (n)=&gt; Array(n).fill().map( (v,idx)=&gt;Array(n).fill().map( (v,idx)=&gt;Array(n).fill().map( (v,idx)=&gt;idx) ) ); nByN3dArray(4).toString(); produces: '0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3' Basically from what I can tell the language assumes that whatever data structure you're trying to display isn't necessarily inferable so it just flattens the whole things. Could also just be a quirk of the language specification. Who knows.
The [MDN Guide](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide) seems to cover the new ES6 stuff without segregating it from the ES5 stuff. It's all JavaScript now, and that's how they present it.
It's obvious. Its written in typescript, which does not run on the SNES. ;-)
Similar to JSFiddle, but [open source](https://github.com/mozilla/thimble.mozilla.org) and ad free.
I've got links to a number of [ES6 feature descriptions and tutorials](https://github.com/markerikson/react-redux-links/blob/master/es6-features.md) as part of my [React/Redux links list](https://github.com/markerikson/react-redux-links).
As /u/leapyquacky said, you'd want to use `Array.filter()` to produce a new array without the item(s) you want removed, then call `setState` and pass in the new array. Also, I've got links to a number of [articles on immutable data operations](https://github.com/markerikson/react-redux-links/blob/master/immutable-data.md) as part of my [React/Redux links list](https://github.com/markerikson/react-redux-links). Those articles will help explain why and how to make immutable data updates.
I mean ES6 is just ES5 with some added features, methods, shortcuts, etc. It's all Javascript, so just start learning but make sure you know if your using an ES6 feature, because they are not supported every where yet so you would have to transpile your code with Babel. Start with code academy and then just do whatever tutorials you like. If the tutorial uses ES6 features and they are worth their salt they will tell you. If you can learn vanilla javascript well, then learning and adding the new es6 features to your code will be easy. After your done with code academy, check this guy out. His videos are entertaining and informative. https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q Especially his series on functional programming. Also what is your programming experience, javascript experience and what are you looking to get out of learning JS? 
It's almost definitely easier to learn ES5 first. Much of ES6 is shorter ways to do things that you could already do in ES5, but they make more sense once you know that things work a certain way in ES5. I also have links to a number of [JavaScript learning resources](https://github.com/markerikson/react-redux-links/blob/master/javascript-resources.md) as part of my list. That said, ES6 *is* the language standard now, and is being used widely. So, the sooner you can learn it, the more you'll understand when reading articles and looking at examples.
Maybe use regex to filter out the results that match that length? Something like `/\d{7}/` or `/\d{15}/`.
I agree overall but that particular function is not meant to be called _very_ frequently -- like, more than once a second. So I guess it's not going to hurt performance by much, unlike some `render()` methods. 
&gt; Plus since most of the frontend developers already use emmet so you have some nice social bubble here. For example, i have never heard of anybody using emmet.
awesome! :)
While Promises catch thrown errors, I cannot recommend that they are used over almost anything else.
&gt; Promises are being added to everything. Browser API’s, the latest cool frameworks and libraries, browsers, and soon, maybe even node core. Bad news for you, they aren't just being added to browser APIs and libraries, and they won't be added to node core because there's no need to make a module for something that is built into the language.
Can you elaborate on your problem and what your trying to do? Markercluster.js is a really simple library for clustering markers when they are taking over your map.
This makes it no different than any other error you would have to handle in synchronous code. You do get the error object in the catch, you can check what it is and throw it further, of exit the process if you wish to. You know, the _handling_ part of _error handling_. Also a counter point is that you might want to handle a regular error thrown in the Promise _without_ crashing the program, even if all it does is show a more informative error than "trying to call foo of undefined" to your user before exiting.
Tricky, writing your code all in one line between the post title and description :) And technically speaking a function is an object in Javascript.
Promises are not actually async, or special in any other way. They are fundamental. An async event may call resolve/reject so promises merely have the ability to be async by design. In principle resolve/reject are as async as console.log and document.write. Promises are really just an extensible version of try/catch. About the only thing we need "throw" for in promise code is to throw inside onFullfilled since there is no exposed reject()... throw is *how* reject is exposed inside onFulfilled. Promises are one in the same with try/catch and async/await. They **are** that powerful.
They are in v8, which node runs on, but I'm referring to Nodes core API, things like fs.readFile(). 
&gt; as you have to try and detect ‘good’ errors, like 404s to external services, or DB lookup misses, from ‘bad’ errors like “TypeError: 555t5tt55555555 is not a function” This is more of an issue with the code employing promises. The fetch API, for instance, doesn't throw on a "fail" status code. From what I remember PouchDB doesn't throw on a "lookup miss."
&gt; This makes it no different than any other error you would have to handle in synchronous code. Sure, but there is a significant difference between catching errors you expect, say, JSON.parse(), and caching *literally any error that could ever happen*, and just responding with a 500. In my opinion, and many others, if you can't handle the error, don't. Logging an error is not handling it. An uncaught error will already crash with the message so there is no advantage. I'ts possible to catch thrown errors when wanted without Promises, but it is not possible to *not* catch errors, which is a pattern that many people are quite a fan of, myself included. &gt; "trying to call foo of undefined" to your user before exiting. This is the standard mentality of clientside programming. If your server has a code error like that, you dont want to leak ANY information, just kill the server and let the load balancer do it's thing. You will see the error and stack trace in your logs. This is pretty par-for-the-course when criticising Promises though, defending the downsides rather than considering better options. 
Great analysis. Yea, I like that async/await is implemented over promises, and that throw inside onFulfilled triggers reject. It means I can extend async/await and throw via promises. Here we have a syntax that is extensible via user code without using macros. I think the problem people have with promises IS their power. The purpose of the syntax extensions is to reign some of that in.
reject('tomato'); throw 'tomaaato'.
throw 'borked', callback('failed'). VERY different things. One is *'Your server is totally broken'* the other is 'this thing rejected'. You don't get to know which with promises.
What kind of homework is this? What academic school teaches differences between ES2015 vs ES2016?
 if (err !== 'failed') process.exit(1); You can subtype Error with ES6, using strings for errors is typically a bad practice in any language.
&gt; I am the author or msngr.js so I typically break my route apart and compose it into messages that I then handle instead of strictly URL paths. It's not as fully featured but I like it simple and small 🙂 Sounds fascinating, can you give me some examples?
Yes, you should always wrap your errors in a minimum amount a bureaucracy. Otherwise they wont be taken seriously.
What do refer to "boxed" applications? While you say..learning React..it means I need to learn few more things with it..like Flux etc...which is going to consume time. Since I am a bit short on time with my job and need to do a project urgently...do you think Vue can also be good? I am hearing a lot about it. Is it quicker to learn? Thanks.
It makes me sad that Angular is the punching bag in so many talks currently. Structure: - Let's talk about this topic. - This is what Angular does. (or did in 2014, but nvm) - This is why it's wrong and what I do instead.
So messages consist of a topic, category and subcategory along with an arbitrary payload. So depending on my use case a lot of times I'll set it so a URL is simply broken down into /topic/category/subcategory and any query strings or post parameters are popped into the payload. So say I have a path of /user/BinaryIdiot. The message will come across as { topic: "user", category: "BinaryIdiot" } Then my handler just listens to the "user" topic and loads whatever username is sent into the category. msngr("user").on(function (payload, msg) { console.log(msg.category); }); I'm on my tablet but roughly speaking something like that 🙂
Why use `context` when you can use `cb` instead? IIRC using `context` is deprecated, could be wrong 
&gt; throw 'borked', callback('failed'). VERY different things. One is 'Your server is totally broken' the other is 'this thing rejected'. You don't get to know which with promises. It seems as though you are looking for semantic differences that do not exist, and then complaining when the implementation does not reflect them. A rejection is nothing but a throw on an asynchronous process.
&gt; You can check the error type But that's the point. How about checking only for the things you expect and *that your code can actually handle*? Let it crash for anything else. You don't know what to expect, you can't check for it, except in the most generic way, and it's unsafe to continue to run the code in those cases. For example, I want to hand the case where a function gets the wrong parameter whose value originated "outside", for example user input or from a web service or a database. I want to let it crash if a function gets an object where a boolean is supposed to be - that's something that should be caught in development by testing, and I would neither know how to write code that handles something this unforeseen nor do I want to: Code I add to take care of exceptions has an "always there" cost, in runtime execution as well as in size of code base and complexity. Example in support of OP: I have an API where "nothing found" (in a database) is perfectly normal. I have other cases where "nothing found" is something that should never happen in production, if it does it's a development problem. Difference between "user objects" (like, didn't specify an address for their account) vs. "internal objects", for example (I'm making this up just now) some data used by your app that you put into the database but that is purely internal and possibly even static. In the first case while you *do* indeed have a different "track" [0] from the normal flow where a value is obtained from the database, but it is a completely different one from the "unexpected exception, can't go in with the program because it is in an unexpected state" where you want to let it crash. But now you have both of them in the catch handler, even though those are two entirely different things. So *my* issue with promises, which I nevertheless use quite heavily even though I never had a "callback hell" due to structured code (always a named top-level function, never inlining them), is that it is a mess of a mix of functional programming (monads) and good old conditionals, "if" statements. With promises JS incorporates a concept from the functional world - but adapts it to being used in a non-functional context, how almost everyone has always programmed in JS. [0] "Railway Oriented Programming" - https://fsharpforfunandprofit.com/rop/ - An introduction to monads without ever mentioning them.
I spent last year working on an Angular 1.x project at work, and honestly I think it's earned this reputation. It was good for its time, but it feels really dated when you compare it to more modern frameworks.
Doesn't work on iOS safari. 
&gt; You don't know what to expect Except you _do_. You are using a library, that library has documentation, should you have a function that returns a promise, the type returned in rejection should be documented, be it some specific `IoError` type or even just a string with a specific value if the library author didn't know any better. So you can expect that reject type and handle it, and throw anything else down the call stack. Granted JavaScript doesn't have a nice semantic for it (even PHP allows you to catch specific error types only), but it is absolutely doable.
Yes, you should always wrap your errors in a minimum amount of **consistency**. Otherwise they wont be taken seriously. 
There is already a [related discussion on this sub](https://www.reddit.com/r/javascript/comments/4zukyt/is_your_javascript_function_actually_pure/). I believe submitting it again will make it possible to reach those who might have missed it. It's not necessary to cover all the corner cases as the OP say, good abstractions allow efficiently duck typing for the set of possible inputs given the context that abstraction is inserted in. If it's a third party code, it should state clearly the signature in the documentation. To prevent mistakes such as overriding `valueOf`, we created the term anti-pattern, and overriding `valueOf` can be considered an anti-pattern. [Verifying the correctness of software is hard](http://blog.paralleluniverse.co/2016/07/23/correctness-and-complexity/), even functional languages can't ensure 100% correctness, [so we use techniques, including human-based ones](https://medium.com/@fagnerbrack/the-trick-to-write-better-software-lies-on-the-technique-944015f84ce4) to workaround this limitation. Naming anti-patterns and documenting inputs are two of the many techniques out there (and using TypeScript is an additional benefit for certain attributes of the input, as stated in the OP).
&gt; There is a huge difference between getting no results from a service call and accidentally executing incorrect code. They are both exceptions. The distinction is only in whether you can catch the issue or let it bubble upstream. Promises allow you to do both: you can use Promise.catch when you expect a call to fail (or an inline try-catch instead, if you prefer), or you can leave the rejection unhandled, at which point the runtime will raise an error event you can listen to globally. (Or you can just stick a catch at the eventual end of your promise chain, if you prefer). I've read everything you've written here several times over and still can't see why this isn't sufficient for your use-case. 
Just a bonus tip - `babel-polyfill` is huge by default. You might want to use [babel-plugin-transform-runtime](https://babeljs.io/docs/plugins/transform-runtime/)
If you can't see a difference between ENOENT and 'undefined is not a function' then we are at an impasse. One is recoverable, maybe even desired. One is "YOUR CODE IS LITERALLY FUCKED"
I've heard it come up on here at least a dozen times and I think half the frontend devs I know are probably at least aware of it.
I use it by default. But it requires additional tooling. Wouldn't work without Webpack or Browserify.
You can do it manually if you prefer that, just go here: https://buble.surge.sh or there: http://babeljs.io/repl and copy paste your code. The npm tools would automate that but if you don't need it ...
Pretty sure you only need babel for it to work since it's just a babel transformer plugin.
No, Electron is a runtime shell with an API exactly like Node. Providing an API does not make for a framework.
Just to clarify which part do you need help with? Can you submit a form? Can you get a reply? Can you show the reply anywhere? Do you just need to know how to get the reply into a specific div or do you need help with the entire process?
If there are programs teaching JS, and I assume there are since it's so prevalent... I would be shocked if this wasn't *exactly* the kind of discussions they had.
I currently have it as an html form with a submit button, and the cgi output is an html page that is sent to an iframe. http://server.arktraders.online/~arkserver/ Use any of the 2 forms and you'll see output in the "command output" iframe. As for javascript I have 2 pages being constantly refreshed loaded into the monitoring divs every 1 second. What I want to do is have a javascript submit button, send the data, return &lt;cgi info&gt; and put &lt;cgi info&gt; into &lt;display div&gt; 
Unpopular opinion: it's way too early to use es6 for the web (unless you're willing to stick to a babel-like transpiling to es5 build step). Old browsers stick around for a long time, so an es6-only future is quite a ways off, IMO.
You are aware you have an error, correct? If Promise is generic, then on line 16 you have to specify the type of the promise.
That quote is a direct copy from the opening description of the electron docs. You're free to believe whatever you want to. Framework doesn't just mean "website mv* or Flux applciation". 
Hi /u/guysbryant, I think /r/redditmobile would be a much better place to ask this question.
I see. I always thought it turns static helpers and polyfills into external require commands but i could be mistaken.
I'm going to invent a character that is lowercase, uppercase, and a number all at the same time... I'm going to be famous!
&gt; Please help. Edit your post into a readable form first.
ES2016 only includes `Array.prototype.includes` and new exponentiation operator. Maybe you wanted to compare ES5 and ES2015?
Thanks for the option. Now I am seriously thinking about Vue too.
I totally read the title as "Dickpicker"
Wait a second ... `System.out.print` ... Is that Java? Better ask in /r/Javahelp then.
First, that looks like Java, not JavaScript. Second, this seems like a bad idea. It's modifying the program for the sake of modifying the program. It'd make much more sense to just do something like this instead of trying to modify the source code itself: //Make an array of the numbers you want to test in your conditions var conditions = [2]; //Loop the numbers for(var i = 19; i &lt; 1*10E300; i = i + 2) { //Loop the conditions and test one by one for(var j = 0; j &lt; conditions.length; j++) { //If the condition is true if(i % conditions[j]) { //add this to conditions conditions.push(i); //write it to the screen Console.log(i); //leave the loop break; } } } I mean, if you are just using this as a demonstration for the sake of discussion, below is a more generalized way to handle it where the array of conditions is actually holding functions. This way, they can test for very complex and unique things. //Make an array of the functions that test for each condition you want to test var conditions = [function(x){return x%2;}]; //Loop the numbers for(var i = 19; i &lt; 1*10E300; i = i + 2) { //Loop the conditions and test one by one for(var j = 0; j &lt; conditions.length; j++) { //Since each condition is a function, pass i to each function to test if(conditions[j](i)) { //Make the function that will test for "i" conditions.push((function(a){ return function(x){return x%a;} })(i)); //write it to the screen Console.log(i); //leave the loop break; } } } I would keep it all in neat data structures like that instead of trying to manage eval() or something.
That's not an unpopular opinion.. Pretty much everyone using es6 is doing it with babel at this point.
setTimeout shouldn't have a performance overhead, and it is probably the most performant way to make this happen. I would do the following to update child objects: function AnimationObject(x,y,children){ this.x = x; this.y = y; this.children = children || []; this.animate = animate; this.update = update; function animate(x,y){ this.update(x,y); children.forEach(child=&gt;animate(x,y)); } function update(x,y){ setTimeout(()=&gt;{ this.x += x; this.y += y; }); } } var animations = new AnimationObject(0,0,[ new AnimationObject(0,0), new AnimationObject(1,1) ]); animations.animate(2,2); This will queue up the update the parent, and then each descendent. The parent will be updated before the children. Your animation object will look like this: AnimationObject{ x: 2, y: 2, children: [ AnimationObject { x:2, y:2 }, AnimationObject { x:3, y:3 } ] } this should update everything in order and make them update their relative position as well. 
ES2015 came with whole new set of features that make it different when we compare it to ES5, so there must be some changes to the way we implement design patterns.
It uses a separate package react-history for maintaining the URL.
Here's the link to the Laracasts, if you need it: https://laracasts.com/series/learning-vue-step-by-step
What you mean by "SNES Style"? Pixelated?
ruiner of dreams!
There was nothing wrong with manual DI and passing around current user in all methods. It was simple and dumb code. It was not worth complicating with a DI framework
It could be any impure function instead of Math.random and the point would still stand.
Can anyone actually identify a time where this was a real issue for you? I've never run into it myself.
Simple and dumb code for simple projects. I agree that bringing in a DI *framework* sucks, because you have to sprinkle it all over userland code. However part 3 presents a solution that lets you write your actual meat of your app in a way that is completely agnostic of whether or not you're using a DI container.
holy shit that's beautiful. the simplicity. the elegance.
And if your vendor never resolves/rejects its promise(s)?
"Prudent developers know not to trust 3rd party code, especially code they haven’t paid for" I stopped reading after this
If you're interested more in how it nests components than the URL itself, read up about [the children prop](https://facebook.github.io/react/tips/children-props-type.html) in react.
You can use any normal function without messing with anything. function pure(x, callback) { return callback(x); } if you call a pure function with an impure function as parameter: var y = 0; function impure(x) { return x + y++; } pure(1, impure); pure(1, impure); You get different output even though the arguments are the same. The pure function will no longer be pure.
I don't believe babeljs will include many polyfills for actual browser features aside from Class; it mainly does syntax transpiling. I use core-js to polyfill promise, Array.from/find/includes, and Object.assign in my apps.
Why not just use `join` and tack on the brackets yourself: function prettyNestedArray(arr) { return "[" + arr.map((v) =&gt; Array.isArray(v) ? prettyNestedArray(v) : v).join(", ") + "]"; } const a = [1,2,3,[4,5,[6],7,8],[9,10,11], [12, [13]], 14]; const s = prettyNestedArray(a); console.log(s); // outputs: [1, 2, 3, [4, 5, [6], 7, 8], [9, 10, 11], [12, [13]], 14] Maybe I'm misunderstanding your issue.
I think the effect is really nice, but I was wondering about the motivation to use `_` as the parameter for nearly all the methods in the the [effect classes](https://github.com/BrianDGLS/snes-style-canvas-effects/blob/master/app/effects/fire.ts#L41-L49)? Generally, I use the underscore for throw away variable names, but here they are not used for throwaways. Is this a convention in graphics programming or something unique to your style of coding? I would prefer the parameters (and variables) to have semantically meaningful names for readability and can't imagine this being easier for anyone.
If your vendor doesn't resolve a promise, then you'll get a `TypeError: Cannot read property 'then' of null` exception thrown when you try to chain anything onto the returned promise. 
That entirely depends on the scope of the code we're talking about here. For anything trivial, I'm relying on free code that works NOW. I don't care whether it's "supported" a minute or a year from now. It already does what I want, no additional support is needed
"For anything trivial" - In some cases, nothing is. I mean really, if I'm connecting to a database at all in the project, it's not trivial. It's easy, for me, but it's not something to take trivially. Further, if you were to tell a *client* their project they're paying you for is "trivial", you'll lose a client. Because no it isn't, not to them. I understand your stance, but you gotta realize that that's a situation that's pretty rare. Most developers have to work with libraries, teams, source controls, regular update schedules, etc. Cowboy coding still works, sure, but you're doomed to never work on something with real scope. You'll only ever work on trivial things, as you say. And either way: The author was still correct. If you're not *caring* about the code a year from now, that's not "being prudent" either. It's still the opposite of prudence, regardless of how you justify it to yourself.
 const vendor = () =&gt; new Promise((resolve, reject) =&gt; {});
This is really cool. Thanks for sharing!
though it only takes one...
Yes, that makes sense. It's just that the article went for a convoluted proof.
Does this help http://blog.leidegren.se/2016/03/24/redux-react-router.html ?
Happy to answer any questions about the project or internals!
What parts of it are you wondering about? Just how it modifies the URL? Look up the HTML5 history API.
It's unwise to extend the Array.prototype or any native prototype.
This colour palette is far greater than the 8-bit of the SNES.
I have been looking for a "nice" way to start using es6 features in a library I am developing. I tried the normal Webpack+Babel route, but it really sucked. The compile times were bad (10 seconds+), and the resulting bundle was a mess to read and debug. On top of that, these tools require lots of polyfills to actually run. I had never heard of Bublé before this, but it looks like the perfect lightweight solution! I already knew that rollup.js was awesome, but it's kinda useless without an es6 transpiler to go with it. Having an all-in-one tool that combines both the transpiler and bundler into one step seems like the way to go, so I'm glad bubleup is here to make this easy.
People reinvent the wheel when the old wheel sucks. If Babel is like an SUV, Bublé is more like a bicycle. It's not right for everyone, but sometimes a more light-weight solution really is better. I'm glad there are diverse options available for people with diverse needs. I wouldn't want to live in a world with only SUV's.
 var minBy = fn =&gt; arr =&gt; { for(var i = 1, l = arr.length, minVal = arr[0], min = fn(minVal), cur, curVal; i &lt; l; i++) if((cur = fn(arr[i])) &lt; min) min = cur, minVal = arr[i]; return minVal; }; var maxBy = fn =&gt; arr =&gt; { for(var i = 1, l = arr.length, maxVal = arr[0], max = fn(maxVal), cur, curVal; i &lt; l; i++) if((cur = fn(arr[i])) &gt; max) max = cur, maxVal = arr[i]; return maxVal; }; Fast, but elegant? 
It's a lot easier to write a timeout with promises than with callbacks: function timeout(orig, ms, err) { const stp = new Promise((resolve, reject) =&gt; setTimeout(reject, ms, err) ); return Promise.race([orig, stp]); } Edit: not saying this completely solves the issue, but it certainly is easier to deal with when using promises than when using callbacks.
It's not used much anymore, but [YUI](http://yuilibrary.com/yui/docs/guides/) had a great architecture. And [UI widgets](http://yuilibrary.com/yui/docs/widget/) in particular are well suited for inheritance.
I quite like the approach of making every injectable thing a different module, storing all module references in variables (at the bottom to allow circular dependencies) and then using https://github.com/jhnns/rewire to a) validate the imports are resolved b) replace them with mocks.
I prefer to say, "const is not variable" as opposed to "mutable".
That's a good point regarding the uselessness of only the status text. Maybe it should reject with the response object as the second parameter? And throw a different error type on HTTP error? 
I haven't seen anything that says context is deprecated, but your comment basically sums up why I wrote this article. There seems to be many different ways of doing the same thing in Lambda, and the documentation/examples aren't always consistent or up to date. The code I posted works for now, and if things change in the future, or better ways of doing it become apparent, I'll update it.
X-Post referenced from /r/reactjs by /u/acemarke [Redux or MobX: An attempt to dissolve the confusion](https://www.reddit.com/r/reactjs/comments/53k64w/redux_or_mobx_an_attempt_to_dissolve_the_confusion/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
But that's the problem. A status of 500 is not an error to the code handling the response, it's only an error to the code that generated it. To the code handling it, it's just a message saying that the other end goofed up.
Oh I figured it out! Code below: NodeMap.prototype.node = (type, props, [...nested]) =&gt; { nested = [].concat.apply([], nested) return { type, props, nested }; }
First thing I would question is; why are you wrapping your own app in an iframe? Second, you probably have some blocking infinite-loop that is killing your process (e.g. something like while (true) {}; where the while never breaks correctly, etc). As far as how to fix it, pretty tough without seeing you code - but in general, comment out your code and go through block by block until you find where your app. doesn't run anymore. Good luck.
I think manual DI scales well beyond micro services. I would tackle those problems head on and consider DI frameworks as one of many solutions. I just doubt DI frameworks would ever be worth it. They just add so much cognitive load and abstraction distractions 
Thanks mate, just wasn't sure about stacking multiple timeouts and the potential detriments. Back to work!
Sorry, I'm not sure what you mean. To the handling code, it is just a message saying that the other end goofed up, but that would mean that the request failed to work the way it was intended and should be handled as an error, albeit a different kind then what is normally thrown.
The structured clone algorithm is meant to work with live data which may possibly reference itself. It is not a serialization format. Moving data between the server and the browser requires a serialization format, like JSON.
This was almost a month ago but I came across this post in google search and just in case you haven't checked out bluebird... I just got done using it's reflect API (settle all) and it works perfectly. I would definitely recommend checking it out.
Yes, using external libraries or simply loading modules yourself from a trusted source. One benefit of NOT using the ES2015 module loading pattern is for Lazy Loading modules, which I don't believe is natively supported by ES2015. 
Cheers, happy scripting!
No one needs Redux. In fact, we not only don't use it, we have zero interest in it. EDIT: In typical reddit fashion, some people think the whole world uses Redux. They'd be shocked at how few do. EDIT2: In typical reddit fashion, someone else says the same thing below, but they got upvoted as many times as I was downvoted, giving further proof to what a joke reddit is.
Like any tool, Redux isn't universally the appropriate choice for all cases. The thing I found most useful about Redux as a React beginner is that it lends itself well to single-direction data flow, immutable data, pure programming. All four of those things (React included) makes it unbelievably easy for me to reason about the effects and side effects of mutation of a single state object. I had one place to look to understand the state of my application, which was easier to debug and develop. I probably won't always use it, and as I become a stronger programmer, I'll probably find less use for it, not more.
I will add though that it all came at a cost of writing extra code. But I liked that too. I liked how Redux doesn't have magic behaviours that I would have to study and understand and get burned on. It's pretty simple under the hood, at the cost of having to write boilerplate that other libraries may try to do for you.
And we do. We're programmers. We know how to code. It's not hard. My 12-year old nephew knows how to do it.
Perhaps deprecated might be the wrong word, but they seem to prefer usage of `cb` in the AWS documentation, at least: http://docs.aws.amazon.com/lambda/latest/dg/nodejs-prog-model-context.html
I'd want to handle a 500 as an error because that's exactly what the status code means: "500 Internal Server *Error*". Yes, it's a valid response in network terms, but, on a higher level, it still represents that there was an error. At least, that's how I think of it, and why I'd use this. It's more about my preference of the separation of concerns (is that the right word in this case?) for success vs error handling than it is about what is technically classified as an error by the Fetch spec.
Right, it was an error on the *Server*. But the server already handled it by creating a valid response and telling me. Now it's just a response that says the server encountered an error. It seems strange that you would choose to take a perfectly valid response and manufacture an extra, completely unnecessary, run time error.
You're probably being downvoted because your comment is a lazy and completely uninspired attempt at trolling. Nobody particularly cares if you don't use it. Nobody thinks everyone in the world uses it. I mean if the article was about how Redux is indispensable and everyone who doesn't use it is an idiot, your comment would be relevant. But the article is actually the complete opposite of that. Although I doubt if you even bothered to read it in the first place.
shrink**pack** !== shrink**wrap** shrinkpack lets you save the actual source code in your source control, so you don't need to download anything from anywhere.
Oh right. As I recall, the callback method didn't actually do anything for me. I couldn't get the functions to work until I used the context.succeed() and context.fail() methods.
It's funny, I didn't try out react until flux came about. I wasn't sure how it was supposed to tie in with the rest of one's application, given I was looking at things like backbone and ember at the time, which had the concepts of models as well. Flux though showed me how one could pull data from a server and display it on a page. It came to make sense. I think learning react only is smart for beginners, but in my case I wanted something with a bit more substance to dive in :)
You're right that the response is valid, but, as I said, this is less about the technical validity of the response than what the response actually means. In addition, throwing an error lets you more cleanly catch it as opposed to checking in every `.then` for errors. `.then` isn't where, at least I think, error checking should have to be done. 
Ah I see. Good for avoiding registry outages. But I don't have that concern - I really just want to avoid the whole shrinkwrap process. 
You might have forgotten to return the `cb` parameter, possibly? I did the same thing :)
&gt; single-direction data flow, immutable data, pure programming. All true of course, but for small apps having a top-level React component `&lt;AppRoot&gt;` with all the state, and ensuring changes are done on that component's `setState`, gets most of the benefits. Redux is good when you need chaining, middleware, and abstraction from React (e.g. for testing)
Wes is a great teacher. I second this.
`class Growy extends HTMLTextAreaElement` nice.
callbacks aren't that much harder to deal with function timeout (cb, ms, err) { var _cb = (...arg) =&gt; [cb &amp;&amp; cb(...arg), cb=void(0)][0]; setTimeout(_cb, ms, err); return _cb; } :D
faster, safer, easier. no reason?
Studying redux prompted me to think about some new approaches to maintining state which have been very helpful, even though I didn't ever use it. The epiphany I had was that the big problem was the state existing in intermediate variables that can easily go stale and are hard to keep track of. Now I just set the function that defines whatever behavior to the new rule/value so there isn't any state apart from how the functions are defined. I use d3-style functors that accept a function to redefine the behavior of something or call the function on a value and it works really well. 
Love it ! 
Interesting. Why `void(0)` instead of `null`? Also, couldn't you just do `cb &amp;&amp; (cb(...arg) || true) &amp;&amp; cb=void(0)` instead of allocating an entire array?
Stupid easy. You'll have an amazingly large dataset, but each and every action can be recorded and replayed in sequence if you so desire. 
I may need Redux :P
Hi /u/Jharkendar, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
Literally all of them, but that's not going to give you much of an answer for how you'd properly architect an OO application. You'll have to research that outside the context of JavaScript, then apply what JavaScript is capable of to those same concepts.
Yes :) [Here's an example of a service that has a lot of dependencies.](http://i.imgur.com/PduApKq.png) I know, I know, *"that looks too big, microservices microservices..."*, well in this case I need a lot of things for a single endpoint. :) Not only does this make my services extremely testable (I can just invoke the function with mock objects), but it's actually _shorter to write as well_ - I don't have to know the path of the services in order to `import` / `require` them. It's like using this DI container lets me write _less code_, not more. :D The reason this Just Works™ is because I am using [Awilix auto-loading](https://github.com/jeffijoe/awilix#auto-loading-modules). My DI setup is [pretty short as well.](http://i.imgur.com/Sgv9TO1.png) Of course there's a bit more to it, but it's a one-time setup and after that you just add more services and it all glues together with no additional setup. At the moment I am using Azure Blob Storage for my app, but that'll probably change soon, and all I gotta do is swap the implementation in a single place. A lot of people say _"DI framework isn't worth it"_ and I was thinking the same because the ones that were available at the time would tie your app structure to suit it's needs with no escape hatch if you decided to do it manually or switch frameworks or whatever. Awilix only asumes DI best practices (constructor injection).
I'm doing this right now, does it have to come at the cost of a massive AppRoot class that holds a whole bunch of methods and then a load of functional components beneath it? Seems like most of my logic is tied in the root component.
Yes, I would suspect runaway recursion. 
`obj` doesn't have a `length` property, if it isn't an array or string. Use `ray.length` instead.
welcome to JS.
Thanks for the tip, I'll keep that in mind and am changing the flair to solved. 
While that's true, DI isn't _only_ needed for tests. E.g. I'll be using different storage providers (Amazon S3, Azure Blob Storage, etc) and I write a small wrapper for each that conform to the same interface. The consuming code does not care what provider they are using. :)
Presets make it incredibly simple, though. Set Es2015, call Babel, done. Isn't it way more frustrating to use a tool that supposedly does the right thing but then you're constantly running against it because it can't parse for-of loops and dozens of other things. This has been my gripe with Rollup as well. So simple, so lean, but actually working with it meant more work and frustration than I ever knew because it has a billion no can do's and edge cases.
Do you really??? Omg I've never heard of anyone that wasn't interested in redux!!!!! You deserve a medal! /s just in case 
that's actually a really good point, hadn't thought of it that way, could even relocate it to a pseudo-reducers import. 
its github repo was updated 4 days ago. That doesn't look dead. 
Works wonderfully with React Native. Biggest plus is ease of testing logic without needing to bother with components.
You Might Not Need Another Post That Starts With "You Might Not Need"
Nothing got "solved" by Flux. I like Flux but it is pretty weird to state that it has solved the problems we have. It is a solution among many and reactive programming is another (one pattern that Angular 2 devs has chosen as well). 
I don't take "solved" to mean "a perfect solution for all cases and it should always be used". It's saying Redux is the way it is for certain reasons, to avoid running into certain problems. So MobX isn't an evolution of this approach - it's just a fundamentally different way of doing things. Which is the important thing to consider when deciding which one to use.
I've a slight problem with tradional "require" + rewire/sinon etc approach when testing. Lets say my module consist of some exported functions like addElement, removeElement. Also, lets say that this module internally (without exporting!) stores an array of those elements and now I want to unit test it. I am testing first method and everything is ok. But now, I'd want to test second method but that array from my module is already modified. How could I "reset" a module to original state before starting second test? Of course I could export this array away or export some "clear" functions, but if I want this array to be pure internal so no other module may access it? Thats why I prefer using DI framework instead of require/rewire. InversifyJS for example allows me to quickly swap dependencies for unit testing and also it allows me to save a snapshot of kernel (service container) with all mocks and initial state, and then reuse it in several unit tests by restoring snapshot every test.
The user of the library is supposed to be able to load plugins at runtime. The library itself does not know the exact structure of it and they may not be available from the start of the app. A plugin on the other hand knows the structure of the library and can operate on parts of it. 
Its for the return value. It allows for the calling of cb, with the setting it to `undefined` (`void(0)`) in one line while still getting back the return value of the original call. [&lt;call = return value&gt;, &lt;delete&gt;][&lt;index of return value&gt;] after deleted, cb doesn't get called, and instead is returned (`&amp;&amp;` short circuit to its value of `undefined`), which as `undefined` is the same value returned from a function that didn't return anything.
I understand that. But why wouldn't my code do the same thing? And why not use `null`? Edit: nvm I understand the return value part now. 
Totally agree - I personally find it more elegant to construct the Subject Under Test with its dependencies rather than monkey-patching require. InversifyJS looks nice - I like TypeScript but I don't use it all the time, will Inversify work for plain JS? Also, Inversify prescribes the use of ES7 decorators (which I also like), but it looks like you're coupling all your code to the DI system. [Awilix](https://github.com/jeffijoe/awilix) is as transparent as possible in that there's no trace of it in your services.
I am thinking about rewriting Awilix in TypeScript (so I don't have to maintain type defs). Awilix is also compatible with TypeScript, although not built _for_ TypeScript - but it should definitely work. Glad to know that I am not the only one doing DI in Node :)
Yeah it's definitely optional. The reason it's a bit of a gripe for me is that we are using TypeScript so anywhere that integrates well with the ES class model is a helpful because it improves code completion. There are plenty of ways to get it working but none is ideal. *Edit: Didn't realise there was a converted project but I have [just found it](https://github.com/typhonjs-backbone/backbone-es6), thanks. Unfortunately cant find an equivalent for Marionette.
For high effort condescension you should check out HackerNews
[Classes, yes.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes) This library, no.
I'm using JWT, so would you say on load, check if JWT exists, if it does send it to server to find user. If user exists update their username with the socket id, if they don't remove the JWT stored locally. 
Thank you! Is this Jquery or something? Never seen this `$` in pure JS.
I learnt react/redux on my current project with one other lead front end dev, and it was fairly simple to pick up. 
Yes, I can write it in pure javascript if you can't understand it.
Lmao reading the article is a waste of your time but expending an equivalent effort complaining about it and Reddit is not. gg m8
[removed]
It seems unlikely that it will go away anytime soon, given this statement on their docs page: "Falcor is the innovative data platform that powers the Netflix UIs."
Would really appreciate it, if you have time.
I would never claim everyone needs it. But I wouldn't say no one does either. Abstractions are built for a reason, to make people more productive. It's why we've gone up from assembly to more human friendly programming languages.
Also, you can implement redux style Flux without actually importing redux (as stated in the article), but there's no reason to because redux is basically just some helper methods to make it easier for you.
[removed]
That sounds correct to me, just call an authenticate API method on the server passing a token if you have one, that either returns back the token you sent, or sends back a new one. Not sure what you mean about updating a user's socket id, if you're using a room to pool connections based on the token, then it is expected that once a token holder closes all tabs you will be left with an empty room until the hour has passed. All perfectly expected.
Carmack didn't say that one should avoid OOP/inheritance, though. He suggested to use FP stuff where it's convenient. He's very pragmatic. 
Thanks a lot! Much appreciated.
Simply add the autofocus property to the button element: &lt;button autofocus&gt;enter&lt;/button&gt;
While it isn't the recommended use case, and it does have limitations, using multiple stores is supported in redux. In fact, the redux FAQ specifically [mentions](http://redux.js.org/docs/FAQ.html#can-or-should-i-create-multiple-stores-can-i-import-my-store-directly-and-use-it-in-components-myself) isolating redux apps within a broader application as a reason for using multiple stores. We're exploring options for rebuilding the core of [Kibana](https://github.com/elastic/kibana), and we're giving serious consideration to redux. In our case, Kibana ships with multiple independent applications that load within it, and the plugin system allows people to add any number of additional applications that they desire. Applications can be built with anything - redux, angular, ember, whatever custom hackery you want to throw together, etc, so strict isolation of the core state and how individual applications handle state is an imperative. If it's helpful to you, I've built a proof of concept app that has a core redux application as well as 3 discrete and isolated redux applications within it: https://github.com/epixa/nk-sandbox You can navigate between the sub apps with the left nav, which will also log the current core state to console. You can click on the application-specific text to log that application's current state to console. Disclaimer: This is just a POC and I'm still actively banging on it. I'm in no way saying that this is how you should build a redux application. We're not even sure if this is something we'll adopt on our end, but it does work.
Yes, because the article was nuanced and interesting and your comment wasn't. The article said "you might not need redux" and justified that with paragraphs of exposition; you said "you *don't* need Redux" and didn't justify it at all except to tell us that you personally don't care about it. If you honestly can't see why one of those things might get upvoted and the other downvoted, then, yeah, maybe Reddit isn't the place for you to hang out.
"You Might Not Need X" considered harmful
Last change to the repo was made 2012 ... where do you guys always find such outdated shit? Oh, and as of ES6 (June 2015) this library is fully obsolete.
Being more friendly is not always the reason for not using assembly. C was created cause assembly wasn't portable, not because it was more friendly though that was a side effect.
So?
In a talk at a conference (don't remember which one as I watched it online) he was more specific. He mentioned if he had the chance to write his games over he would absolutely avoid OOP entirely with one exception. He found that passing globally scoped objects was necessary for transmitting game data in multiplayer scenarios where information needed to shared almost universally and quickly.
Sorry, did you come into the field of programming with the assumption that it was going to be easy?
Wonderfully elegant! I'd like to see the ability to emit more than one result, as that is fantastically useful in many pipeline uses.
Was it intentional to make the minutes single-digit rather than 0 pad? For example, the time now says 9:7 as opposed to 9:07.
I would consider JS an OLOO language (objects linking other objects). While it has some functional aspects and native methods, the use of object delegation (prototypal inheritance) makes it somewhat more unique.
No, thanks. A simple RegExp is better.
Gotta move away from QT for several reasons. Need something that can run in the browser.
TL;DR: shitty function composition with special support for making promises hard to use. Can someone open a PR where `index.js` becomes an empty file?
Their right hand select box navigation does not work without JS and it still visible when JS is disabled....very progressive. That is the only place to navigate. I'm not normally so picky but I don't like that whole evangelised style of writing. Progressive enhancement, like many things, has it's own use case and may or may not be needed but don't write about it like you've just invented the coolest thing ever that everyone should be using. 
Interesting... I'll have to play around to see what you mean. You mean something like the .map() method is slow? Have you compared it to vanilla JS? That makes sense though, running map in many cases requires Immutable to create an entirely new List/Map/etc. if all the values have changed.
&gt; I have a good understanding of Javascript and jquery. Do you think I should learn ajax next? The way you phrase that makes it clear that you **do not** have a good understanding of JS in general. 
Just listened about this 2 hrs back on talk Python to me. Sound awesome and signed up.
When you work in a big team and someone pays for your time spent on writing Flux/Redux boilerplate, sure. But otherwise, I feel like there should be a better way than creating reducers for every little thing. You can fallback to this.setState() but it becomes confusing when you have multiple conventions for working with data.
Get fucking real. Seriously?
It's slightly odd that navigation isn't progressive either - it's probably the easiest example of progressive enhancement to implement. All they need is to put a form tag and submit button in, then hide the button ¯\\\_(ツ)\_/¯ I love what gov.uk does, but I have to agree - this came across as preachy and holier than thou, rather than helpful.
FYI, the popular https://github.com/zeit/hyperterm application uses a plugin approach, where plugins can provide their own Redux middlewares and reducers. There's also a number of experiments and discussions going on in regards to self-contained / reusable components, over at https://github.com/slorber/scalable-frontend-with-elm-or-redux , and I know of at least one more interesting approach that's not public yet. Randy Coulman is also doing some blogging on ways to encapsulate state with his last couple posts, such as http://randycoulman.com/blog/2016/09/20/redux-reducer-selector-asymmetry/ .
It's definitely Redux. References the UMD build on a CDN in the `&lt;head&gt;` setup, and uses `createStore`.
To be fair, he's talking about the entire UK central government online ecosystem - [gov.uk](https://www.gov.uk), not just the GDS blog. The work they do to keep the many thousand of pages accessible and functional for the highest possible numbers of users - whether they be those with poor connection, outdated equipment, assisstive technology or simply with JS turned off - is pretty incredible. Of course, they have to work in that way, they have a legal responsibility to deliver a product that's accessible to as close to the entire population of the country as possible. But nonetheless, why shouldn't they be evangelical about it, they're one of the best at it in the world.
It wasn't intentional. Now it's fixed :)
Some people just aren't happy until the world burns.
What about for .splice(), something like: this.state.elements.splice(index,0,element); this.setState({elements: this.state.elements}); it's the same issue for adding an element.
Well you really only have two conventions right? Keeping application state in your redux store and any superfluous UI state in your local react state.
His usage of modern js syntax doesn't account for much of the difference you're seeing, the bigger point is the libraries, his coding style, and the logic behind his solution. 
I see. I still need to take some time to learn some libraries rather than trying to do everything myself. I'm a little nervous about becoming dependant on a library to do something without actually understanding how to do it myself though. I'm sure that even with the benefits of using libraries I still need some more experience to develop an efficient coding style.
I work with a guy who insists that for us to use React and Redux and Babel and Webpack and so on ad infinitum that we have to understand all the deepest parts of those things. It's a noble goal but also an impossible one. At some point you just have to trust that the package you use does what it says it'll do and to learn its intricacies as you need them. There are too many dependencies in a project to actually understand all of them at full depth.
I'd be more than a little worried if your team's ability to adopt a technology is based more on the qualities of the team than the utility and value of the tech. Sounds like it worked out fine here but I'd be looking to get rid of any developer that was against change. A good developer is always open to justified change.
If I were making a turn based game, knowing little of the existing JS game libs currently out there, I can definitely see the advantage of using Redux or some other implementation of the Flux pattern to manage that. I'd highly recommend doing a quick proof of concept to see if you like it.
From my experience redux simplifies javascript applications. 
Speaking for myself; the arrow syntax made function composition a blast for me. 
A good example here are the optimizations: you could try to learn about them or just trust that a famous and widespread project like react has few enough bugs that you won't need to know how it optimizes.
To add an element to an array, look into the ES6 [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator): addElement(element) { this.setState({ elements: [...this.state.elements, element] }); } You can also do this the non-ES6 way with [Array.concat()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat): addElement(element) { this.setState({ elements: this.state.elements.concat(element) }); } To add an element to a given index in an array: addElement(element, index) { const { elements } = this.state; const newState = [ ...elements.slice(0, index), element, ...elements.slice(index) ]; this.setState({ elements: newState }); } Or, the ES5 way: addElement(element, index) { const newState = this.state.elements .slice(0, index) .concat(element) .concat(this.state.elements.slice(index)); this.setState({ elements: newState }); } All of the above methods will create a new array.
You did indeed. Thanks, I'll get this sorted as soon as I get off work. :)
You might look up minimax algorithm before you start implementing ai
Try out MobX. It is not very opinionated when it comes to the structure of your program and in the simplest structure it is pretty much the same as setState() but moved out to a store.
Redux is not very Flux-ish if you actually look at it. No dispatcher, single store and reducers. It has unidirectional data flow but that is all (and some similar ideas) The core of Flux of actions going through a dispatcher that dispatch those to multiple stores that can depend on each other does not exist.
THANK YOU THANK YOU!
Not starting it either! :D
It's safe to assume that anything sent unsolicited should not be run. I don't even need to look at it to tell you that. (And I can't even if I wanted to, because the code has been mangled by Reddit's Markdown code.) 
Ah, no problem at all and don't sweat reading over each and every little detail of documentation - as you practice you'll learn more and more - it's a never ending thing for any developer :D. If your goal is to get a job in development, then you'll find that the two biggest things are writing reusable/semantic/readable code that is structured in a logical/easy-to-navigate setting. As far as components/etc go, once you start writing an actual app/project that you want to push to a repo and/or use modern technologies/tools/frameworks with, then this will become more and more apparent to you regarding its advantages. If you're just writing your own project, then writing it in the most logical way for yourself is always the best way to go about it (again, unless you're aiming to land a job/build a portfolio, then hitting on those first two points I brought up is important). Oh I forgot to mention, one major benefit of structuring your code with some logic like I was mentioning before is you can easily build out logic for your entire app and execute it from the get-go as you develop. Let's say for example you have the following and you aren't ready to build some state checking feature yet (maybe you're a front-end dev waiting for a back-end API to be built). You can easily modify your components to where you can have those in a pending state, but still work on your portion of code, e.g.: var app = { init: function() { if (app.someAjaxCall()) { app.render(); } else { // some listener for an event to finish/append HTML/etc } }, someAjaxCall: function() { // TODO pending Joe to finish back-end API state check // update once done return true; }, render: function() { // some render function that you're working on for the front-end } }
i know it wasn't safe.. was just curious on what his guys intent was.
The question of a comparison between Redux and MobX came up more often. I have written a dedicated blog post to solve some of the confusion: http://www.robinwieruch.de/redux-mobx-confusion/ 
Redux has a dispatcher, stores and unidirectional data flow achieved by dispatching actions to stores. That's flux. Redux's only extra constraints are that it insists on a single store (and thus a single dispatcher), and that each write to the store produces a new object.
I must say it makes still sense to have a store with all your entities (e.g. users) in addition to id lists of different kinds (e.g. followers, followings). I often abuse the system to have a proper API cache for different request, which still return the same entities. Imagine you are going to follow one of your followings, but he is already a follower of you. You would have that user at two places without having one single source of truth user entity. The data would get stale, because one user would get followed by you, while the other stays unfollowed. I think normalizr isn't strictly bound to anything. But you are right, one could still manage to have a single source of truth in MobX without the need of normalizr.
wonder if that means this demo was coded in less than 50 minutes, from xx:10 to xx:59
it should be setItem('nameScore', nameScore) instead of the square brackets
Thanks!
Angular is MVC... got it.
What is this for? It seems to be too specific and complicated to be an interview/homework question. That solution is pretty hairy and will produce errors in strict mode (undeclared variables `temp`, `p1`, and `p2`), and outside of strict mode, I don't think it will work (`[temp[0]] == 'p1'` will always return `false` because it's comparing an array to a string).
Username checks out.
How do you figure that? I have a clear understanding, maybe could have phrased it better though. 
React is popular, but perhaps pretty big to wrap your head around. Few people are happy with angular ATM. I'd first checkout some smaller frameworks like MithrilJS or infernojs.
I have zeptojs it's small and I can learn from it.
What is "copy of a reference" there are no copies passed. It is the same reference in memory.
How does this have nearly 40 upvotes and hardly any comments? I read it and found it very hard to read as the syntax has no indentation, the style changes several times like different authors wrote it, terrible practices since the dawn of JS (new Array???) Sorry not sure why this is so popular, maybe someone can clue me in.
Code stolen from a StackOverflow [answer](http://stackoverflow.com/questions/13104494/does-javascript-pass-by-reference) function replace(ref) { ref = {}; // this code does _not_ affect the object passed } function update(ref) { ref.key = 'newvalue'; // this code _does_ affect the _contents_ of the object } var a = { key: 'value' }; replace(a); // a still has its original value - it's unmodfied update(a); // the _contents_ of 'a' are changed Don't be confused with a reference (which is not an object) and an object (which you can access by means of a reference). Javascript makes a *copy* of references. These references refer to the same object, after being copied. If Javascript was pass by reference, then in the above example, reassigning `ref` inside `replace` would affect the outside scope. Indeed, you can do this with the `&amp;` symbol in C++.
No, I can't have anything with HTML either, here is screenshot: http://imgur.com/a/K6BJA
I think I also found a bug: https://imgur.com/a/F1q1D (I should see the "draw" overlay). Really cool work though! I don't know javascript/html/css very well (or at all really), but I'm gonna read through and see if I can understand. ~~Do you think there is a better way to check for wins than explicitly listing them out?~~ Just realized there is already a comment to that effect.
Ah this is nodejs. Look into node modules to "require" your scripts. https://nodejs.org/api/modules.html
confuzzled, where do I look? *sigh*
Yeah that page is a tad overwhelming. This is the gist of it taken from [here](http://stackoverflow.com/questions/5797852/in-node-js-how-do-i-include-functions-from-my-other-files): // tools.js // ======== module.exports = { foo: function () { // whatever }, bar: function () { // whatever } }; var zemba = function () { } // app.js // ====== var tools = require('./tools'); console.log(typeof tools.foo); // =&gt; 'function' console.log(typeof tools.bar); // =&gt; 'function' console.log(typeof tools.zemba); // =&gt; undefined The important bit is that whatever is in module.exports is made available when you require it. the "zemba" function is outside of it so it's undefined. Note that the "zemba" function is available to the foo and bar functions.
The time skyrockets because the number of combinations is exponential. For n six-sided dice, there are 6^(n) combinations to check. It doesn't matter whether your solution is recursive or not, the amount of work is going to completely blow up as n increases. If you want to do better, don't use brute force. [There are closed-form solutions to computing the probabilities](http://mathworld.wolfram.com/Dice.html). Edit: here's an example: function binomial(n, k) { if(k == 0) return 1; if(k &gt; n / 2) return binomial(n, n - k); return n * binomial(n - 1, k - 1) / k; } function dice_prob(dice, sides = 6) { let results = [0]; const p_max = dice * sides; for(let p = 1; p &lt;= p_max; p++) { let sum = 0; const k_max = Math.floor((p - dice) / sides); for(let k = 0; k &lt;= k_max; k++) { let term = binomial(dice, k) * binomial(p - sides * k - 1, dice - 1); if(k &amp; 1) term = -term; sum += term; } results.push(sum); } return results; } let results = dice_prob(14); for(let i = 1; i &lt; results.length; i++) { console.log('%d: %d', i, results[i]); } This calculates the probability of 14 dice in about a tenth of a second. I believe 14 is the highest it can handle before you run out of precision of JS's number type. You'd need to use a bignum package after that. The point is that it's much more efficient than brute force. 
We need to see code. That said... A) It seems kind of wonky to me to be handling the level of indentation this way in the first place when you could accomplish the same thing with less class names via nth child selectors B) If a component is changing quickly after its first render and that's not what your intention is, I've found 9 times out of 10 you simply need to be returning a falsey value should whatever your criteria not be met
how'd you deduce that? 
Should be as easy as - var script = document.createElement('script'); script.type = 'text/javascript'; script.src = 'https://mysite/my.js'; script.async = true; document.getElementsByTagName('head').item(0).appendChild(script); 
Woah! seems like someone put their foot on your f**king tail. Instead of portraiting your true self here, why not provide the reasoning for why it is "shitty" and how does it make dealing with promises hard so that it may help me and all those people who upvoted/starred this?
Interested 
Gotcha, I'll check out mithriljs
I knew the problem was due to the increasing number of outcomes, and I knew must be a smarter way to do this. I just had no idea what to search for. Thanks a lot for the help.
I found this NPM module https://www.npmjs.com/package/google-trends-api
 My first thought on reading the title : *we do?* My second thought: *angular 1 or 2?*
Take a look at the fetch api. Not supported in all browsers, but you can get a polyfill.
Link is out-of-date (and won't be maintained) correct link is - https://react-router.now.sh/ 
How else would you create a new array from the one passed?
Fellow Tall Python to Me listener. Just wanted to say hi. Hi! 👋🏻
It's a text field from like in a forum when u post threat and click on a smiley and choose a emoticon. I best would be to prevent that the option to choose could be prevented 
[slice()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)
Whew I thought I was the only one who thought that article was trash
Coding interface not good. Puzzles much better. Thanks.
These are all little coding challenges, not large programs with much room for things to go wrong. You can definitely learn a lot from these challenges and the top few responses in the different categories, also seeing how you can have different solutions to the same problem. 
&gt; You would have that user at two places without having one single source of truth user entity. The data would get stale, because one user would get followed by you, while the other stays unfollowed. I think you are missing one of the core principles in that referential integrity is guaranteed in Mobx. You would have a real reference between you and your follower. Your state would form a data graph rather than a normalized tree. https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254 I really like your app since it's complex enough that it touches most subjects you would run into but not so huge that you can't comprehend it. I just wished the Mobx version showcased more of what Mobx can do with regards to stores and how to handle state. I should stop whining now, keep up the good job :)
Thanks for feedback. What you don't like in coding interface? PS: You can use our web-plugin for Chrome and FireFox that allows you to use your local editor instead.
Just ran it. Except for the line, `fa7b7(a072c);`, which is pretty much just `eval(a072c);`.
It says to click on the right, even has an arrow, then it tells me to click. I click, nothing happens, so I click on the left again. This is going to skew results to be on the right side of the left section as people try to figure out which side to click, traveling the shortest distance between the two. Just my observation. Cheers!
Nice observation. I wanted to prevent clicking at the start mainly so users get the information that you can only click once.
I agree with everything you are saying. During the whole history of CheckiO I was trying to fight with this issue all the time and here are steps we have done in this direction - High level users can give more votes if they want. Level 14 user can give 5 votes for a solution - We have categories for solutions. When user share a solution, he should choose which category (Clear/Creative/Speedy) fits better for his solution. In such a way weird coding-tricks will never get a lot of upvotes in Clear category. - We have a random-review feature that makes users to review solutions not from random review. During some period of time this is actually the only way how user can see solution of other users - We have Editors Choice solution - a good solution without a lot of votes can still become an Editor's Choice. What do you think about those ideas? If you have any ideas how to improve it - please let me know. Thanks a lot for your feedback
Hey thanks for your reply. It's been awhile since I used the site so maybe some of these features are new, I will give it another shot. I think giving more votes to expert users is a good thing to try on a site like this. I remember the categories for solutions and thought that was a good idea. I thought that the "Clear" category wasn't always the clearest but maybe that has changed some. Maybe I would like a "most boring" or "most enterprise friendly" category. (sort of kidding. sort of). Forcing users to review a random one or two is an excellent idea. I also liked that you had to leave a comment with a negative review (I think this was a feature if I remember right). -------------------- When I used the site for the first time there was a lot of lag issues on the front page, but I think that's probably been fixed by now.
Java is for server-side, JavaScript is for client-side (in the browser) or for NodeJS it is for server-side. Hope this helps you :-)
Java and Javascript are completely utterly unrelated. Java is a compiled bytecode run inside a JVM. Javascript is an interpreted language run within a browser (or nodeJS etc lately)
Have you tried redux-act? It's a small collection of helpers that reduce boilerplate signifinactly. Instead of action-types and action-creators spread over several files you get self-describing actions. Instead of verbose reducers you get small function-collections, referencing your actions. This, normally spread over three files const TOGGLE_FLAG = 'TOGGLE_FLAG'; const SET_MESSAGE = 'SET_MESSAGE'; function toggleFlag() { return { type: TOGGLE_FLAG } } function setMessage(message) { return { type: SET_MESSAGE, message } } function settings(state = {}, action) { switch (action.type) { case TOGGLE_FLAG: return { ...state, flag: !state.flag } case SET_MESSAGE: return { ...state, message: action.message } default: return state } } const store = createStore({ settings }); store.dispatch(setMessage("hello")) becomes this, usually in a single file const toggleFlag = createAction('TOGGLE_FLAG'); const setMessage = createAction('SET_MESSAGE'); const settings = createReducer({ [toggleFlag]: (state) =&gt; ({ ...state, flag: !state.flag }), [setMessage]: (state, message) =&gt; ({ ...state, message }), }, {}); const store = createStore({ settings }); store.dispatch(setMessage("hello")) 
Small font size (major), poor code highlighting (minor), not understabdable difference between "try it" and "run" (can't watch videos at work, so didn't saw tutorials), manual console clearing is annoying (see errror in red, when error isn't there anymore). I'd suggest you to look at www.codewars.com coding interface. By the way, dark theme would be great.
Ya, that's unfortunate but I can see how policing banal comments would get old fast.
&gt; When I used the site for the first time there was a lot of lag issues on the front page, but I think that's probably been fixed by now. I think some of them are fixed. But there are still a lot of things to improve. This is actually a video I was watching when I get a notification about your message https://www.youtube.com/watch?v=cmGr0RszHc8
Those are make sense for me. Thank a lot for the feedback. I'll see how we can fix those.
You run into these problems in any language and system. It doesn't matter if C# and XAML, Android and layoutinflaters, ReactiveCocoa, etc. They all will turn to spaghetti mess if app structure and state aren't throught through very well. In fact, considering the tools Javascript has, due to the size of its community, it's considerably easier, especially with React and Redux. 
People still write these kind of articles in 2016? Have we learned nothing?
That's an interesting idea for a game. Kind of reminds me of when people play a single player game on Twitch (I think Pokemon?), except built into the game design.
Hey, I got it; but I am requesting an external file: (link: https://github.com/basicBot/source) &gt;javascript:(function(){$.getScript('https://rawgit.com/basicBot/source/master/basicBot.js');})(); I will try the above.
And also for var tools = require(... does it need to be var *tools*?
Considering things like SharePoint or MySQL, you can have a certification issued by the corp that owns them (Microsoft and Oracle). JavaScript is an implementation of an open standard, so there's no central authority to issue certificates. So Mozilla implements it as part of their SpiderMonkey engine, then Google implements it as part of V8, and so on. Not having a central authority, many knowledgeable dudes have decided to offer their own personal courses. Among these we've got Eric Elliott, the egghead.io guys, or Todd Motto. The guys at free code camp issue certifications as defined by them. They are aiming to gain enough reputation so employers will know what they are and care about them. But it's not a mature project yet. They call it certifications, but in my opinion they're closer to a knowledgeable dude's course in terms of recognition by employers. Currently, the common criterion to be considered good at JavaScript is to have contributed to open source projects. As a rule of thumb, if you get a few pull requests accepted, then you're good.
X-Post referenced from /r/node by /u/keithwhor ["f" - A JavaScript / Node.js Functional Microservice Request Library](https://www.reddit.com/r/node/comments/53sor3/f_a_javascript_nodejs_functional_microservice/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Don't use default export for components. With named exports, you both enforce consistent naming across the code base and allow your IDE to autocomplete the name for you.
Yup, a whole new genre evolved from that. Twitch plays Pokemon was the first big one, and after its success several other games were tried, most notably Dark Souls. The plebs actually finished it!
Tried that. Not a good idea. That place is under strict rule of the mod team. You know why there are not so many posts? It's not because people are not posting, it's because the mods cherry-pick the posts that THEY like. Whatever mods approve of, everyone consumes. On a sub with high traffic and low post count, that happens inevitably They said that it is not unique, because it is similar to www.donottouch.org. One of the rules says something like only content that is not very common should be posted. Based on (distant) similarity with one (1) site, they basically marked my post as something everyone knows and is bored of. I just don't wanna argue with them anymore. I am not sure whether I wanna sub that sub anymore. /rant
Certificates are great! They make cert companies a lot of money! Unfortunately, they probably will do nothing for you. [The "elite" software companies -- Microsoft, Google, Amazon, etc -- are generally not neutral about certifications for software engineers; they're actually negative.](https://www.quora.com/Are-certifications-for-software-engineers-worth-it)
Yeah the lower part of the 'x' lines up with the radius my thumb could reach comfortably on mobile. Right handed so I naturally choose lower left.
Ok, this comment was the last drop. My curiosity finally won over my fear of breaking it in production and I implemented Android detection. It was broken for a few minutes there, but it should be fine. I won't probably make any use of it for the users, but after I have a big enough data set and make big analysis and conclusion, it will be there.
Waiting for HTTP requests instead of simple function calls. What a time to be alive. Microservices have its place, but IMHO this is not it. You are building an online repository of simple functions that should be manually added to the code. I do not agree with the philosophy of "requiring()" minor functions and ending up with 100s of dependencies. Putting it behind HTTP makes it even worse. Seriously though, who is going to wait for a HTTP request for the great circle distance between two points and then handle the response in a callback?
In my experience this isn't true for the higher end brand-agnostic certifications. When certifications become more aligned to something like a medical review boards or legal bar certifications (continuing education requirements, large multi-domain tests with a high fail rate, and open to audits) they are generally respected in much the same way.
Can you please elaborate a bit?
So you want to bring in medical and legal certifications to justify software certifications as if they were the same thing? Answer this. Who provides medical certifications and legal ones? Compare them to software certs. Then come back.
I'm similarly not sure about both the latency AND remote hosting of functions. However, the `f` library is set up to provide a seamless way to interact with your own microservices AS IF they are simple functions, which CAN be hosted on your same system. This greatly reduces the friction of using a microservice architecture where helpful.
lol what?
k. !RemindMe 2 weeks
I will be messaging you on [**2016-10-05 12:58:27 UTC**](http://www.wolframalpha.com/input/?i=2016-10-05 12:58:27 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/javascript/comments/53ruix/multiclick_click_inside_a_square_and_see_where/d7vxhek) [**6 OTHERS CLICKED THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/javascript/comments/53ruix/multiclick_click_inside_a_square_and_see_where/d7vxhek]%0A%0ARemindMe! 2 weeks) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! d7vxiiz) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
I've looked at their site extensively, they have some very good UX, I'm aware they have a lot of guidelines they have to follow. That said, I took issue with the preachy tone of the article mainly because despite the site being very informative, it has no flair, it's basic. It's easy to be progressive if you have a basic site and despite what I've said I have no issue with building a site like this. It's pure function over form and it works and this is the point I'm coming to: always build a project to the requirements needed. They did a very good job and they're talented but what they did fits what they needed and their requirements. Trying to push this agenda to a wider audience 'EVERYONE SHOULD BE PROGRESSIVE' no, everyone should not be progressive, everyone should way up the pros and cons. I know it seems overly critical but this trend is endemic in the JS community. Everyone should be using / doing everything. People then go off and get into a total mess blindly implementing something they don't even need. If the article had been written with a different tone that would have made all the difference. Edit: The blog site is part of the gov.uk site, if you're going to announce you're progressive you should at least make sure your house is in order.
linkception!
You call that a rant? That's sweet
We could draw something
Do you have jQuery or are you using vanilla JavaScript?
This project gave me an idea for another thing. It would be very similar to this, but you would see everything everybody has drawn, and you would have like 1 pixel per 30 seconds, but you could choose a color. If there were enough people, there would be rooms with different names of the things to be drawn. The best part is the players would have no way of communication except for the one pixel per 30 seconds. It would be epic, because one picture would take like several days to be drawn and tens of people would take part in it. Maybe one day.
&gt; I don't really find much use of version control when making small (&lt;500 loc) projects. I've been in development since roughly 1998. Trust me: Version control *always* makes sense! Nowadays, with tools like git, you don't even need a server. Just `git init` and off you go. If you later want/need to grow, you have everything in place. If you decide to publish, the history is already there. If not planning to publish or grow, the ability to branch/merge, compare history, long-term undos are just too valuable to pass up!
There are numerous similarities between professional certifications across various industries. &gt; Who provides medical certifications and legal ones? Independent private organizations or governmental organizations in conformance to applicable law. Here they are for where I live: * https://en.wikipedia.org/wiki/State_Bar_of_Texas (private organization acting at the behest of the Texas State Supreme Court) * https://en.wikipedia.org/wiki/Texas_Medical_Board (government agency acting at the behest of the state governor) * https://en.wikipedia.org/wiki/Texas_Real_Estate_Commission (government agency acting at the behest of the state governor) &gt; Compare them to software certs. You mean like the PMP, CISSP, Lean Six Sigma? Those certifications are also managed by private organizations not affiliated with revenue generating companies: * https://en.wikipedia.org/wiki/Project_Management_Institute * https://en.wikipedia.org/wiki/%28ISC%29%C2%B2 * Lean Six Sigma doesn't even have a governing body
Just plain ol' Javascript. And threejs. 
What do you expect to happen? Setting a variable just sets the variable's value. If you want that the application reacts to this change, you have to provide additional code. The easy way is to define a [setter](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/set).
Essentially, my variable of 'activate' should be false. Then, when I click the button, I want the variable changed to 'true' so that it triggers whatever function it's related to. 
It works here https://jsfiddle.net/dkuzvxh5/ when using *document.activate* instead of *activate*. 
array.sort in javascript does not work
i think the text itself influences where to click, especially since it's not static. i wanted to click in an empty space and clicked after the text which depends on how many lines there were at the time... move the text outside the box and see?
I'm just lazy haha ;-) 
This is a very generic way to ask such a specific question. I'd check firewall setup, could be that the firewall blocks scripts on some domains, or check how the server serves JS files. Or idk what your mechanism is to load JS. Do you load using require? do you just load file contents and insert a new &lt;script&gt; node? 
Programming involves lots of reading the magic 8 ball says your future isn't bright. 
oh man you don't know the half of it ;-) Naaah, I have to power up my brain again after having done DBA stuff on auto pilot the past 5 years (I've been a DBA about 10 years but the first 5 years, I was studying Oracle stuff all the time)... 
Ah some good threads here! Haha "most boring" would be great 
RemindMe! 2 Weeks ...there's a bot for that. gtk.
Put it on JSFiddle, CodePen, or whatever. Without seeing the markup and without being able to debug it, I can't really tell what's going on. Also, format your code properly. VS Code can do that for you (right click -&gt; format code or Ctrl + Shift + I). JSFiddle can also do that via the "Tidy" button at the top.
Awesome timing! I actually [made one myself](http://codepen.io/HAMMERjah/full/NRNLLV/) not too long ago using vanilla and HTML5 canvas. If anyone's willing to take a look and provide some feedback I'd love it. My next step, like you, is to make an AI so I'm curious how you end up proceeding! 
&gt; I want the variable changed to 'true' so that it triggers whatever function it's related to. Changing the primitive value of some variable doesn't (and cannot) trigger anything. You'd need some loop (e.g. requestAnimationFrame) where you observe the value of that variable. If you want to do something, call a function which does something. document.querySelector('#button').addEventListener(function() { alert('ohai'); });
Firefox has the same behavior, and if you copy the polyfill from MDN (and rename it), [you get the same results](https://jsfiddle.net/vgwev4ax/). Hrmm... edit: The issue is with your usage of `String.prototype.startsWith` ([MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith)). Consider its method signature: &gt; str.startsWith(searchString[, position]) Now consider the parameters passed to the callback for `Array.prototype.some` (summarized from MDN): &gt; callback(currentValue, index, array) For the first iteration, `index` is 0, but then on the 2nd iteration, it's 1, so instead of seeing if it starts with "ab", it's checking to see if it starts with "b". The problem wasn't exposed in your first examples because you're explicitly not passing in the additional arguments to the callback, whereas `Array.prototype.some` _will_ pass them in.
I think this might be an issue with scope binding and the usage of `String.prototype.startsWith` vs. `some`. If we're more specific, there's no issue. ['ab', 'cd'].some(a =&gt; 'abc'.startsWith(a)); // true ['cd', 'ab'].some(a =&gt; 'abc'.startsWith(a)); // true ['cd', 'ef'].some(a =&gt; 'abc'.startsWith(a)); // false EDIT: [arcanin](https://www.reddit.com/r/javascript/comments/53tvbo/is_this_a_bug_in_the_js_standard/d7w6ivt) answered it better.
The same thing happens when you try to do `const min = arr.reduce(Math.min)`. It's unfortunate when the obvious way to do something happens to be wrong.
Ahh. Makes sense! Thanks for the explanation!
If you really don't want to use a literal function in an array method, make sure your variable/named function is constructed properly to limit or handle any extra arguments: var predicate = value =&gt; 'abc'.startsWith(value); // Or: function predicate(value) { return 'abc'.startsWith(value); }
You're right that "ref" behaves like a pointer, but the word "pointer" doesn't much exist in the JavaScript lexicon, so we say "reference" instead, even though the word "reference" means something different in other languages such as C++. Even MDN will use the word "reference" to describe passing an object parameter. I think this whole discussion will make a lot more sense so long as we all understand that "by reference" in JavaScript translates to "by pointer" in C++.
voiping brings up a good point, but I'd also like to mention that for a modern web app the expectation already exists trust a large number of over-the-wire requests to third-party services. Anything from the AWS SDK to Stripe to Google Analytics. The distance microservice is an example (quick to implement but not the best use case), but realistically the two major use cases are for A) portability of functionality across multiple applications spanning different languages and B) where computational resources represent a larger performance bottleneck than network latency. Ultimately YMMV based on how you set up microservices, whether you use a fPaaS like [stdlib](https://stdlib.com), go directly to AWS Lambda, or run your own containers. "f" does what it needs to do - it's a light wrapper around HTTP requests that standardizes some common practices for executing microservices.
The only ignorant person is the one who uses the obscure to justify their own in an amateur setting.
Yes, it's somewhat confusing and there's some re-use of terms.
Huh? You can get sued for using the beans? 
Just to add to that, these days Javascript is also secretly JIT complied, which is why it's faster than other interpreted languages like Python and Ruby
Everyone is clicking literally where the two arrows are pointing together.
Angular2
TLDR; http://slides.com/joelkanzelmeyer/taming-large-redux-apps#/12
Nice just what I was looking for. is Array.isArray generally supported in browsers (as in newish). **edit:** Nice solution, it works great!
Forget the marks, put little ghost cursors on the page. Like, every time a user clicks store a log of the last second of their mouse mouse movement. Then overlay that action on the UI for other users to see. 
Glad to see I wasn't alone clicking inside the "O" of "Ok"
Expectations from many employers extend beyond just an understanding of Javascript and that is probably why there is no reliable certification. There are Javascript libraries and frameworks that modern Front-End developers are expected to know, but here's the thing: they're constantly changing. The flavor of the week now with SPA (Single Page Application) development is Angular 2.0 or ReactJS with Flux/Redux/Reflux, but that could change with the next release of Backbone or Ember for example. What counts more than certificates is actual work. If you can develop some cool projects demonstrating your understanding of Javascript and a popular framework as part of a portfolio, ideally uploaded to a public Git repo, then you should be golden in the eyes of a prospective employer. But, keep in mind that you're going to have to constantly prove your ability to learn new frameworks and even new Javascript features (See ES6 features as an example). TL;DR: JS and its frameworks change too often to have a reliable cert demonstrating expertise
What does Axios return? Are you listening on IPV6 by doing the following? http://stackoverflow.com/questions/30082641/how-to-use-node-js-with-ipv6
Yes.
Check each word against the text var foul = words.some(function(word) { return this.indexOf(world) &gt; -1; }, text);
You need to use BadWords.indexOf(webResult) !== -1 The array has an indexOf function which returns -1 if the given value is not in it. Probably also smart to use this to handle cases where there is no string or it has leading/trailing spaces: if (webResult === undefined || BadWords.indexOf(webResult.trim()) !== -1) { // string was undefined or a bad word } else { // string was ok }
This is a fairly advanced concept to build from scratch that would require a lot of considerations around cross-browser &amp; device issues and also fairly strong knowledge of how to handle animations in JS. Since I don't have the time to build out a fully animated example for you, this may at least help you get a basic understanding of how to structure your code and listen for the appropriate events/etc. Good luck: https://jsfiddle.net/byuser9m/ (this example just shows how to take a collection of values, and render/update those dates in a container based on a listener, you'll still need to research animating/etc).
Hi /u/mvg210, this post has been removed. Please do not offer bounties, etc. If/when you remove the reward, please reply here and your post will be reinstated.
Does it do something? I just see a 503 page.
I've removed the bounty text from the post, but I am unable to edit the title, can you help me out please?
Not sure if its less crazy, but this is a recursive approach: var flatten = function(array) { var length = array.length; if (length === 0) return array; var first = array[0]; var rest = array.slice(1); var flattenedRest = flatten(rest); var flattenedFirst = Array.isArray(first) ? flatten(first) : [ first ]; return flattenedFirst.concat(flattenedRest); };
I've made a screencast to show what I'm looking for which might explain it better than I have in text. Can I send you a dropbox link? 
This will not work, because `webResult` is the haystack and `BadWords` is a collection of needles. Your solution checks every needle to see if it contains a haystack.
This is what you need! https://www.npmjs.com/package/eslint-plugin-import. Static analysis can be done with any AST not just when you use a type checker. ESLint is making big progress on this kind of thing.
Usually when one stumbles across a "bug" in a well-used language, it is user error ;)
Yup, they are there, here is the response I get from axios: { [Error: connect EHOSTUNREACH 2604:a880:1:20::ec5:1:3000 - Local (:::55208)] code: 'EHOSTUNREACH', errno: 'EHOSTUNREACH', syscall: 'connect', address: '2604:a880:1:20::ec5:1', port: 3000, config: { transformRequest: { '0': [Function: transformRequest] }, transformResponse: { '0': [Function: transformResponse] }, headers: { Accept: 'application/json, text/plain, */*', 'User-Agent': 'axios/0.14.0' }, timeout: 0, xsrfCookieName: 'XSRF-TOKEN', xsrfHeaderName: 'X-XSRF-TOKEN', maxContentLength: -1, validateStatus: [Function: validateStatus], method: 'get', url: 'http://[2604:a880:1:20::ec5:1]:3000/api/loginStatus?userID=123', data: undefined }, response: undefined }
Thanks for the ideas, here's the solution (copied from my edit) in case this bites you some day too: After rolling back to commits made as far back as 5 months ago, I finally fixed the problem. It had nothing to do with my code; I'm on OSX, and removing Chrome in addition to the the files in ~/Library/Google and then installing Version 54.0.2840.34 beta (64-bit) was the solution. I had tried reinstalling before but the same version (53 I think? ) and without clearing ~/Library/Google.
Thanks for the ideas, I did narrow the issue down to a component with nested components inside of it but I still couldn't make sense of what was causing the CPU spike / subsequent browser freezing. Here's the solution (copied from my edit) in case this bites you some day too: After rolling back to commits made as far back as 5 months ago, I finally fixed the problem. It had nothing to do with my code; I'm on OSX, and removing Chrome in addition to the the files in ~/Library/Google and then installing Version 54.0.2840.34 beta (64-bit) was the solution. I had tried reinstalling before but the same version (53 I think? ) and without clearing ~/Library/Google.
I had no idea spambots still existed for reddit either, go figure!
It's good, good AI. Good job. One thing though, it doesn't seem to support castling. https://en.m.wikipedia.org/wiki/Castling
Can't take credit for that really, it's using [Stockfish](https://stockfishchess.org/). The API is really just a bridge between the UI and the Stockfish engine. But thank you! Yeah, castling, resigning, and undoing moves are all things I should add. Also I think getting a move suggestion would be cool too. Thanks for your feedback!
My guess on left corners is that people know, for sure, that that is all the way left since that is where their mouse stops. Right, not so much since the canvas doesnt take up the whole screen. Interesting project! EDIT: though looking at the heatmap again, I see I am wrong :)
I can't speak for /u/Veuxdo, but this article appears to be another load of bullshit touting microservices. It starts by painting this scary picture of the Monolith boogie-man and then claims that microservices act like some kind of complexity reducing fairy dust. Basically put, if your organisation can't handle the complexity of a more traditional and centralised application architecture then there is zero hope that turning it into a distributed application is going to make life easier. 
&gt; Setting the items to null instead of an empty array creates even more problems so that won’t help either. I wish the author hadn't swept this under the rug so quickly. Using `null` to mean "the array hasn't loaded yet" has worked well for me in the past. What problems is he referring to?
Yeah, I was expecting some Mode 7 stuff.
Dang, sorry to hear that. You'd think a heatmap is visualizing data...
Great explanation, thank you. I really think I should dive deep into learning regex sometime soon, it's so powerful. Using your example works perfectly for what I'm trying to do.
A huge part of the design of es6 modules is that they can be statically analysed for checking and dead code removal. Why would you need typescript or flow?
The problem with that approach is that an empty array is ambiguous by itself: it could mean that the array is loading, or that the user just doesn't have any records to show. To disambiguate, you would need an additional flag, which the author and I agree are inconvenient
Well it is reachable, because I can ping it (and connect to port 3000). Do you have working v6 on your client machine? Can you reach the API from a browser on your client using the v6 address? Although as somebody else said above, use a dual stack hostname (i.e. "tryskip.com") there rather than a literal IP. That way the client will pick the appropriate address family based on its available connectivity (plus you can change the IP without needing to release a new version).
Ok cool, I can get my API call working on a IPV4 network, with this call: http://tryskip.com:3000/api/loginStatus?userID=test I'm going to set up a local IPV6 network to see if it works on that, thanks for your help hopefully it'll work on the IPV6 network
I just updated the A and AAAA name records for tryskip.com, so I'm in the process of setting up a local IPV6 network to test out the API on that, will update the post with my results. If you have access to an IPV6 network, can you run try this URL and let me know what you get? http://tryskip.com:3000/api/loginStatus?userID=test 
So I went to ipv6test.google.com and it says I'm on an IPV6 network, then I tried out this url: http://tryskip.com:3000/api/loginStatus?userID=test And it worked! So that means my API works on all IPV6 networks right? Please PM me your phone number/venmo username or bitcoin address to get your prize :)
CrossCode http://www.cross-code.com/en/home http://store.steampowered.com/app/368340/ It was made with the ImpactJS game engine http://impactjs.com/forums/games/crosscode-demo
Google was
I think it points to the fact that humans are all wired pretty similarly. Even when we try to be random we are wired up the same and predictable. OP should get demographic info for this and cut the data points by demographics. I would not be surprised if the grouping was by gender and other demographics too. 
When it's put that way, it sounds worse than it is. They use an algorithm to block all cheaters anyway. Honestly I am just using this as a fun little way to boast while improving my extremely basic js skills in the process. Whether you believe me or not that's the truth. There is a 99.999999% chance I will be taken off the leaderboard by the end of the contest period. If you'd like me to take the post down I don't have a problem with doing that just let me know.
Did you try closing the quote after onkeydown?
I've been meaning to check this out, didn't know it was also made with/in JS.
Game Dev Tycoon 
I've spotted the usage of NW.js in Game Dev Tycoon and Fingered. Greenheart Games, the creators of GDT, actually made a node-webkit plugin, which essentially wraps Steam API calls for things like achievements and other steamworks features
According to this [stackoverflow](http://stackoverflow.com/questions/19788188/get-html-from-webpage-using-ipv6-address-and-javascript) post, IPV6 calls need to be wrapped in brackets to distinguish it from the port.
Not sure, but I think you need to tell Express to listen on both the IPv4 and IPv6 addresses: var ipList = [ '100.100.100.100', '2001:db8:1111:2222:3333::44' ]; ipList.forEach(ip =&gt; { app.listen(PORT, ip, function () { console.log("listening on", ip, ":", PORT); }); }); 
Webpack2 finds my new files in watch mode....
Depends on what its watching for. Something like babel will only catch the new file if its actually being used somewhere.
Try to do a 'Hello World' for both Java and NodeJS It will help you see the difference
Love your work! I also noticed the lack of castling. But an even bigger improvement would be to animate the pieces moving. Sometimes the computer would make a move and it would take me a while to figure out which piece moved where (I'm not a chess pro by any means! :) But yeah, awesome work!
OP, you should look for a way to convert ruby objects directly into json. I'm not familiar with the Ruby standard lib but I bet you can find something there to help you.
[Montaro](http://store.steampowered.com/app/495890/?snr=1_5_9__205) is a silly little game I learned was written in JavaScript. I think it's powered by Node.js.
CoffeeScript compiles to JS, and the syntax is practically identical, especially if you include ES6 syntax.
To answer your question outside of the context if you take a string from object.keys(object) at an index such as array[x] you could use bracket notation object[string] or object[array[x]] 
You wouldn't happen to be building something like FF Tactics/Tactics Ogre SRPG, would you? The remake of Tactics Ogre actually had exactly what you were describing: the ability to go back in time up to some number of turns and try new strategies.
Thank you very much! Yeah I agree about animating them. That same thing would happen to me. Castling and an undo button would be great additions too, and definitely 2-player. So many things lol.
This kills the SVG.
let me try again: i have 2 functions that do some calculations. how would i return the 2nd function and pass an argument from _fn1?
As far as `_fn2` goes, you're not exactly _passing_ anything to it. Well, you are with `(b)`, but its not getting used because its not defined in the parameter list. But `b` is still accessible because its getting inherited from the parent scope. But because `_fn2` is defined in `_fn1` its only accessible there. And because you're calling it directly within `_fn1`, there's really no point of it being a function in the first place. Might as well be: var a = 1; (function _fn1(a) { var b = a + 100; console.log('b:' + b); var c = b + 500; console.log('c:' + c); return c; }(a)); If you want to keep the functions separate, that's also an option. You can call them separately and pass in the return value of one into the other as an argument. You just need to fix `_fn2` to have the `b` parameter in its parameter list: var a = 1; function _fn1(a) { var b = a + 100; console.log('b:' + b); return b; } function _fn2(b) { var c = b + 500; console.log('c:' + c); return c; } var b = _fn1(a); _fn2(b); // or _fn2(_fn1(a));
Thank you! :)
That's like asking what is the difference between any two random programming languages. The differences between the two are far greater than any perceived similarities. 
we dont do these kind of things in JS
As a fairly senior software engineer who has been at Google for 5 years and conducted interviews myself, I can confirm that certifications are utterly useless among the top tech companies (although I can't speak for the low-end of the industry, where hiring might be done by non-engineers). Honestly, seeing them on a resume might even bias me (unconsciously) *against* a candidate slightly, since they A) test only the most basic college-student-level concepts, B) demonstrate nothing about a person's ability to solve real-world problems, and C) probably evidence a lack of actual experience if they're being used to fill space on a resume. I would rather hire someone who has contributed significantly to an open source project than someone who has perfect scores on every single certification out there. Save your money.
It sort of looks like a bot post gone wrong. 
&gt; https://en.wikipedia.org/wiki/Project_Management_Institute &gt; https://en.wikipedia.org/wiki/%28ISC%29%C2%B2 &gt; Lean Six Sigma doesn't even have a governing body what do these have to do with software dev certs?
Thanks! Inversify still requires you to annotate each parameter with `@inject()`, right? Trying to understand how I could possibly make it better by reducing boilerplate and vendor-lock code (the main enemy of using a DI framework). In TypeScript with Awilix, it might look like this: import { ITodosRepository, IUserSession, IStorage } from './my/interfaces' interface IDependencies { todosRepository: ITodosRepository session: IUserSession storage: IStorage } export default function makeTodosService({ todosRepository, session, storage }: IDependencies): ITodosService { return { // Todos Service API create: (data: any) =&gt; todosRepository.create(/* you get it */) } } // Meanwhile, in other files.... // You might swap storage provider: export class AzureStorage implements IStorage { upload(file: Stream): Promise&lt;string&gt; { // do stuff } } export class S3Storage implements IStorage { upload(file: Stream): Promise&lt;string&gt; { // do stuff } } // In the composition root.. container .registerClass({ storage: AzureStorage // Swap this for S3Storage when ready... }) .registerFunction({ // Use auto-loading of modules to avoid registering everything manually! todosService: makeTodosService })
[removed]
They are IT management certifications. The PMP is generally carried by project managers and the CISSP is generally carried by security analysts, but I have observed both regularly associated with software development.... at least development not associated with web technologies. If you are hoping for certifications that identify you know how to write code you aren't going to find it, because knowing how to write the respective code is a minimal prerequisite often not worth certifying.
best solution in here. 
Looks like you've got it confirmed as working from other posts, but it seems to be working here too, over both v4 and v6: &gt; { "loginStatus":false,"loginURL":"https://login.uber.com [...] 
Hello, beginner developer here (1y+) :) I have to point out a few problems in your video, not because I'm a mean person, but because you are promoting bad content and way of coding in my opinion and it will confuse beginners. So here goes : * IE is bad up to IE 11 concerning ES6 but Edge is one of the most ES 6 compliant browser with the ChakraCore engine (unfortunately, only available on W10). Microsoft is trying to go the "ever green browser" way now :) * You used x as a function name and a param' name, bad practice 'cause it's confusing (try foo, bar) * You shouldn't use alert, it's also a bad practice (blocking the JS, and the other 99 reasons you can find online). It's usually better to use console.log, especially in your video, the output is right under your function call (and we don't have to move our eyes to the top of the page) * You said multiple times "not sure if I said that right", "stuff like that". If you are not sure about what you are talking about, don't promote your video. Doing a video is alright even if you are not a JS master, it may help yourself, but don't promote it or share it expecting to teach others, it's harmful for the community. * Relevant to prior bullet, you should make a script beforehand so you don't stutter and you are 100% sure you know what you are talking about and the way you say it is right. * This point is subjective : you talked about React and Redux (even though it was brief), which are frameworks, in a video about Advanced Vanilla JS. In my opinion, you shouldn't mix both especially if the title is not something like : "understanding JS before diving into React". * You said Closures were related to parameters but really, you can access any variable from an inner scope. * You talked about Arrow functions without talking about Transpilers like Babel and I'm not sure what you said about "this" and arrow functions is right ( [here is the complete answer](https://web.archive.org/web/20160625172303/https://blog.getify.com/arrow-this/) ) I advise you to read a bit more about JS with those pretty good books : [YDKJS](https://github.com/getify/You-Dont-Know-JS#you-dont-know-js-book-series) :) 
You can't, the comment from /u/kiarokiarokiaro misses the problem. http://www.ecma-international.org/ecma-262/6.0/#sec-object-type &gt; Properties are identified using key values. A property key value is either an ECMAScript String value or a Symbol value. All String and Symbol values, including the empty string, are valid as property keys. A property name is a property key that is a String value. Object keys cannot be anything but strings (or symbols in ES 2015). You are free to use anything else - but then it is implicitly converted using that object's `.toString()` method. If you feel like doing some horrible hacking you could write a custom `toString()` method that converts your object to JSON, and this way store an actual object in the key, and parse the JSON when you read it.
Actually working on a game now that uses webtech, so hopefully we can add it to the list if it gets greenlit ;)
The "oink" SVG uses `shape-rendering:crispEdges` to disable antialiasing and the canvas is resized to 300% using nearest neighbor sampling (`image-rendering: pixelated`). It's meant to look like that. The original purpose of this demo was to figure out if it was possible to do aliased low-res vector stuff (à la Another World) in browsers. Evidentially, you can do it, but it only works if you use SVG. You can't use canvas' vector drawing methods (lineTo, arc, etc) for this.
http://jsbin.com/tozivezile/edit?html,js,console,output This is my code. Adding my function with yours doesn't solve it for me 
*Anonymous
Also, `this` is a keyword, not a variable. Pedantic I know, but I think anyone who is attempting to teach a programming language should be aware of such a difference.
Works with any nested level array function flatten(a){ return JSON.parse("["+JSON.stringify(a).replace(/[\[\]]/g,'')+"]"); } let crazyArray = [1,2,3, [4,5,[6,8], 10], 99]; flatten(crazyArray) &gt;&gt; [1, 2, 3, 4, 5, 6, 8, 10, 99] 
No Inversify does not require you to use @inject. If you use class-based injection, it is resolved automatically with help of reflect-metada.
You can't. If you need a reliable fullscreen mode you have to use the standalone mode (and invite your users to "Add to Home" the web application). As an added bonus, when in standalone mode the "swipe from border" gestures do nothing by default (instead of controlling the browser's history).
The problem: myInput.onkeydown = function x(...) {...} works (i.e. calls the function x correctly onkeydown) but having the function declared as function x(...) {...} and calling it through &lt;input id="myInput" ... onkeydown="x(event)" ...&gt; does not.
I understand. I think I have enough info now to solve it. I just need to find a replacement for event then. Cheers
Found this today :) https://hacks.mozilla.org/2016/09/introducing-debugger-html/?utm_content=buffer1900a&amp;utm_medium=social&amp;utm_source=twitter.com&amp;utm_campaign=buffer
Ah, sorry - the example in the README makes use of classes _and_ @inject so that's why I asked. :)
How do you like it?
"apply" and "call" call the function with some parameters and return the result of that call. "bind" fixes the context (this) and the given parameters and returns a new function that can be called later supplying the rest of the parameters. "bind" is like [partial application.](https://en.wikipedia.org/wiki/Partial_application)
Pretty good, the author is very responsive and we're using the postcss branch.
ITT: What happens when you link to an article in the form of a question
IIRC the old one was also using JS, but rendered using XUL instead of HTML and wasn't based on commonly used tools like react.
X-Post referenced from /r/programming by /u/musically_ut [Did you thank your node dependencies today?](https://www.reddit.com/r/programming/comments/53z6vp/did_you_thank_your_node_dependencies_today/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Note that this is the same kind of thing as what causes the unexpected behavior of `['10', '10', '10', '10'].map(parseInt)` (run it and see for yourself).
I still use FF more than Chrome for JS development. Always wonder why Chrome has an edge with this. Possibly others are doing more complicated stuff than I am. And FYI their (alpha?) Developer Edition has many of Chrome's features. Still a little buggy &amp; there are some questionable design decisions, but promising. Agree w/ bair-disc that Chrome's debugging is a lot more performant with complicated pages.
I was just updating our codebase to 2.0.2-rc :) Looks like I can bump it up a bit more. When will we see the Nuget packages get published? Edit: Annnd it's published.
Certainly their best contribution to the web.
Great news! Finally!
Well, Visual Studio is by far the best IDE as well in my opinion. I might be biased because I'm a .Net programmer, but they're quite good to devs. 
I don't know. XHR was pretty monumental.
And Visual Studio Code is one of the best editors right now. The new Microsoft is doing lots of things right these days.
Sorry to be a bit of a dick about it, but this has been covered by an endless amount of articles already, so why do we need another one?
Thanks I added it as an alternative incase I hit any bottlenecks. 
I do not trust. :-)
I used Sublime for years before I switched to Code last year. Sublime was awesome but I have no regrets. By the way, I use React exclusively with TypeScript and have no experience with Angular. (Just saying, because I have seen many people have the "Flow is to React as TypeScript is to Angular" notion. In fact TypeScript only made my love for React more intense :)
\#4 is an incomplete example at best, regarding closures. The code you have is an example only of lexical scoping. To better convey closures, you should be returning the inner function and using it after the wrapper function. The whole idea is that in "normal" execution, the outer function's scope would cease to exist after execution. If you instead return that inner function, you're bundling up the function and it's environment, create a closure. So when you call that returned function afterwards, that parent functions scope is still accessible, even though it would otherwise no longer exist. 
VS is faster than IntelliJ though
Haha, learned it 😂
`appreciate` will not automatically star projects on your behalf; it'll just let you know which ones you have and have not starred. Moreover, I've found that I occasionally removed packages from my `package.json` after running `appreciate` since I don't depend on them anymore just because they were painful to use. :)
I highly recommend freecodecamp. Their curriculum is based on hands on projects that teach you very useful things. There is also a big community to ask for help etc. 
What's your point of view on coroutines/concurrency in JS coming from other languages? This problem drives me mad, and I haven't found any solution to it.
Well. I'm not sure that this is a fair question. They do different things. All Babel does is compile ES6 to ES5 and while Typescript does do a bit of that as well, its main focus is making JavaScript statically typed which allows for *great* tooling (and some other good things). You can use Typescript with Babel actually, in fact a lot of people do this to support Async/Await. Both are great tools, but personally I think Typescript is more 'cannot live without'.
So totally noob question here, I'm working with Vue and es6 and I like it so far... if I decided to use TypeScript, would I have to get a vue version in typescript to write my components? can I write some code in typescript and some in es6? :)(:
Use the Google Maps API: https://developers.google.com/maps/
By assigning values, you are dynamically adding things in an array. Each element has an internal index, which you can access using its index (arr[n]). An array, in memory, is a fixed length, although this is invisible to you. By default, in JS, an initialized array has 0 length. In other languages where the data structures are more apparent, it is very common to initialize arrays with a predefined number of items, and length, to optimize performance. In some languages, that resizing isn't automatic, and extending space in the array would require redefining the array. What you are seeing here is exactly or very similar to this, except arrays in JS are all dynamic in size. By setting the length to zero, you are essentially doing the same thing as doing a = [] again. I haven't seen it used a lot in JS, but it is there if necessary, I guess. Eg: var a = []; // initializes at 0 length console.log(a.length); // &gt; 0 a.length = 100; // prepares for you 100 'slots' to insert things in memory console.log(a.length); // &gt; 100
Not exactly true. With Babel you can implement Flow which is Facebook's type check system and I prefer it to Typescript :) 
Currently using jss here. Looks similar, can you talk about the differences you've seen?
lmao, okay bud.
Actually after looking at this more, this is the best answer IMO, vlad's is great too though
Yeah, what you made looks great, but I don't think it warrants us rewriting our app to use. I'll consider it for future projects!
As a pure code editor, Sublime is amazing, but I have dropped it as my main Javascript editor for VSCode, primarily for 2 reasons: 1. out-of-the-box NodeJS debugging 2. intellisense That said, both are open at all times, so I get the best of both worlds :P
just `npm install @types/vue` and you have typings for vue.
If anyone is curious about the spec language here (who am I kidding, I'm the only one), array instances are called [Array Exotic Objects](https://tc39.github.io/ecma262/#sec-array-exotic-objects). An exotic object is an object that has one or more non-"standard" essential internal methods (also known as the meta-object protocol or MOP). Arrays and have an overridden [[DefineOwnProperty]] method which is used when creating and setting properties. It handles the special cases of setting length and updating length when setting array indexes.
You would think, right? This is where Javascript is "special". Arrays in Javascript aren't backed by an array-like memory structure. Arrays in Javascript are just objects where the keys are indices. So when you do `new Array(100)` it literally just makes an Array object with length property equal to 100. That's it. I bet when you set length to 0, it doesn't actually remove anything. It's just that when it prints the array, it only iterates up to the length property value. Not at a computer right now, so I can't test this. EDIT: Nope, looks like when you set the length property, it wipes out any indices greater than or equal to the new length.
nice.
I wouldn't say the first 99 slots are empty, because that would suggest the first 99 slots exist. Array assignment is always O(1), it literally just sets the key "99" equal to 1 (because Arrays in Javascript are just glorified objects). 
Even though its not as popular as AWS, their Azure platform is good. It used to be more expensive than other options out there, but even on price its now competitive.
Year is a string, parse it to a number
Why express disappointment that X has fallen behind Y? Always use the better tool and try not to get attached to software.
This is so clearly EEE. Sad to see the JavaScript community is not even putting up a fight against it.
Is it in a &lt;form&gt;? If so it will try to submit which could explain what you're seeing. If you add the attribute `type="button"` to your &lt;button&gt;, it won't try to submit.
Embrace, Extend, Extinguish 
It works fine https://jsfiddle.net/7hq317mx/5/ you where trying to assign tdNumber.appendChild(document.createTextNode(year)) You just need to replace the comma on line 8 with a semi colon. 
Absolutely. I use Visual Studio a whole lot, but there's no full-featured IDE that fits what I want more than WebStorm. I find myself frustrated writing code in anything else at times.
What will they extinguish?
Hi /u/Mooooose97, if you have a specific question and have already attempted to answer it, then we're more than glad to help, but we're not going to do your homework for you.
Is there any practical way of using this in an enterprise environment? We don't have a public git account, but we use a lot of NPM packages.
Not entirely sure it's EEE but the argument is that as time goes on TypeScript and Microsoft's dev tools will become more and more inseparable. So once the world has been won over on TypeScript the tooling will suddenly only work properly with Windows and/or Microsoft's ecosystem. If this is the case we're just at the start of the EE part of that strategy and we can expect the following: * Announcements from big vendors that they support TypeScript as a development target then later, *only* TypeScript and not regular JavaScript. This type of thing usually happens in conjunction with the MS sales force so if MS sales folks start touting TypeScript as an important feature then we can string up the alarm bells. * Announcements of "partnerships" with all manner of companies to add TypeScript support for all manner of things. I'm imagining TypeScript development boards that run Windows 10 IoT. Probably before that we'd see Microsoft announce that they've got NodeJS (or their own equivalent) running TypeScript natively without transpiling and that they have a special build of Windows 10 IoT for using it on a Raspberry Pi. This is when we attach drumsticks to the alarm bells on a chain along with a sign... * "Ring in case of native TypeScript support in IE" 
Except everything is open source. So I don't see how they could ever pull that off.
Hi /u/throwawayharharharha, if you have a specific question and have already attempted to answer it, then we're more than glad to help, but we're not going to do your homework for you.
Well, it is off-topic but actually OK in my view. This is the German Comma-Disease. I don't even need the comma between &gt;fact that ? I have thought this is a relative pronoun and I could use a comma there.
That worked!! Thank you very much for the help and the good advice!
Thanks for the advice!
This new type acquisition in TS2 is awesome!
meh, web browsers aren't owned by vendors, they're owned by users. If the browser doesn't do what the user expects, the user can switch. There's no ideology forcing going on here, it's feature enabling. I simply don't want you turning off my pinch to zoom. I don't want you controlling other parts of my browser either. It's great that typography has progressed, but I simply don't trust you and I shouldn't have to.
Because that is what the angular team said and assuming anything else would be really pessimistic and baseless. Google has a couple hundred angular apps and just hired additional people for their team. There needs to be a major event for them to abandon it in the next 6 months and in my mind early adoption is too high for that.
.replace does not modify the original variable, it just returns the result. so you need to do random_text = random_text.replace(...)
Thank you so much! I followed your advice and it's working like a charm. 
Your should try Xcode and CLion then.
You need to pass the exact same object to `removeEventListener()` as the one you used with `addEventListener()`. 
You've inadvertently added pupper to the global scope. Add "use strict"; as the first line in this function to get an error when you do this.
It's because every time you add/remove an event using mouseHandler, you're calling mouseHandlerBinded() which creates a *new* event object which may be identical to the old one but isn't *the same one*. So the event referenced in window.removeEventListener is at a different memory address than the one you added. To fix, assign this.mouseHandlerBinded() to a variable *once* and when access that object where needed. If I may say so, you've set up the "this" context in a peculiar way -- if you instead assign mouseHandler to VeryUsefullClass.prototype.mouseHandler, then you don't need to create a "bound" function with .bind().
I hope you're right :-)
Tabs not spaces for me
It is generally recognized that freedom of speech carries with it "special duties and responsibilities" with regards to "respect of the rights or reputation of others" and various other things like truth in advertising and national security. Hateful speech is not generally protected, though of course many upsetting communications are. https://en.wikipedia.org/wiki/Freedom_of_speech
&gt; Hateful speech is not generally protected In those cases speech is less free or not free at all. Freedoms of speech are generally expanded, in the US, due to collisions of offensive communications with standing laws or enforcement. In the converse there is not a supposed *freedom of offense* where your sadness is sufficient (or just) cause for censorship. From your link: &gt; In the US, the standing landmark opinion on political speech is Brandenburg v. Ohio (1969),[33] expressly overruling Whitney v. California.[34] In Brandenburg, the US Supreme Court referred to the right even to speak openly of violent action and revolution in broad terms: &gt;&gt; [Our] decisions have fashioned the principle that the constitutional guarantees of free speech and free press do not allow a State to forbid or proscribe advocacy of the use of force or law violation except where such advocacy is directed to inciting or producing imminent lawless action and is likely to incite or cause such action.[35] &gt; The opinion in Brandenburg discarded the previous test of "clear and present danger" and made the US citizen's right to freedom of (political) speech almost absolute.[36][37] I suggest rereading your Wikipedia link, because if you believe hateful speech is either not generally protected or is not in collision with freedom you do not seem to understand or appreciate such freedom.
Take your ads and GTFO.
As a general note: string in Javascript are immutable. You can't change them in-place like you can in C (by changing characters using array-like indexing), old VB (using mid/mid$ as a statement). Normally we don't deal with literal strings directly, we use the string object that wraps one, so the string object could make it look like the string value is mutable - but this isn't done by any of the standard methods the instead all return a new string object that wraps the modified value which you can then assign to the previous variable name as the_humans showed. This returning of a new string object allows chaining, you can write: testString = testString.replace('nice', 'fucking nice'); testString = testString.repeate(2); testString = testString.toUpperCase(); testString = testString.replace('FUCKING', 'FREAKING'); as the more concise: testString = testString.replace('nice', 'fucking nice') .repeate(2) .toUpperCase() .replace('FUCKING', 'FREAKING') ; and of course use the eventual return value to populate a new variable without changing the original: testString2 = testString.replace('nice', 'fucking nice').repeate(2).toUpperCase().replace('FUCKING', 'FREAKING'); (here mashed into one line which is perfectly valid code but, as you can see, the multiline example above is much easier to read) You'll see this pattern used in many libraries that manipulate objects and data: arbitrary precision math, DOM manipulation method (jQuery and friends, or the built-ins in non-legacy browsers ([ala thus](http://youmightnotneedjquery.com/)), array searching/filtering/merging/joining utilities, and so on.
While the getter of the length property simply returns the number of elements that are contained in the array, the setter can be used to truncate the array. var arr = [1, 2, 3, 4, 5, 6]; arr.length = 3; arr; // [1, 2, 3] arr.length = 6; arr.push(4); arr; // [1, 2, 3, undefined, undefined, undefined, 4] Assigning a smaller length truncates the array. Increasing it creates a sparse array. src: https://bonsaiden.github.io/JavaScript-Garden/#array.general
You don't. It is a new "accessibility feature" that, once again, breaks a lot of working content, where zooming is not a desiderable feature, because a lot of stupid developers and designers used to prevent zooming where zooming was a desiderable feature. The only sane way to have a full-screen experience without writing a native application is to use the standalone mode, and invite the users to add your webapp to their home screen. I wonder what is the interaction of this new feature with their recent introduction of the "Fast-Tap" in [safari 9.1](https://developer.apple.com/library/content/releasenotes/General/WhatsNewInSafari/Articles/Safari_9_1.html).
What you attach, can only be detached using the exact same combination of event name, event handler function, and the capture flag.
Well, Visual Studio is mainly for .NET. And if you're comparing VS to Raider..... Visual Studio all the way.
I am using an older version of Firefox (43) for compatibility with Selenium and I don't see the results or the benchmark button. Could you also make the color swatches (the little squares) in the results key larger? At the current size the dark colors look nearly identical to me.
Do you also use Github Enterprise internally, then?
For me Visual Studio Code is already extremely fast: projects open instantly and there's no slow downs while editing (and I have quite a few extensions installed). What puzzles me is Atom: I used it before VS Code a few months ago and it was just slow. I don't know why people associate Electron with slow. Of you optimize correctly your app will be just as fast as a native one. 
&gt; because a lot of stupid developers and designers Don't agree with you. It is also sad that you think that way about people who differ from your definition of "accessibility" and its corresponding solution. &gt; he only sane way to have a full-screen experience ~~Throw "full-screen experience" into the mix and scream TFW? Quite telling about how much is valid in this discussion at all~~. &gt; You don't. I just did. Implemented and deployed. Edit: I agree it is a consequence of misuse but am glad there is still a work around. Will share it on SO soon.
seems like the same thing that you get from css-modules and extracttext plugin? Why would I use this over that? with css modules i get to keep css in another file as well which is nice.
Heh, so they will extinguish TypeScript... their own product.
I just like the way Polymer and [Vue](https://vuejs.org/images/vue-component.png) do it. I keep most of my components small and contained so there's often no need for additional files. Css modules are otherwise nice. Another thing i'm not sure about, by requiring css, aren't you binding your users to a specific buildsystem and specific loaders? Meaning they have to scramble to make the component work, ...or get served a fat bundle with all the overhead and doubled dependencies. The above example would be self-contained, just needs a babel pass to /dist to apply postcss.
Ask dev to send JavaScript event so you can listen to it. E.g. if there is jQuery: from Angular app $(window).trigger('h1fromAngularIsLoaded'); Then, you can listen to that event like that: $(window).on('h1fromAngularIsLoaded', function() { console.log('h1 is loaded!'); }) If he's smart he will add auto triggering events when angular route changes (if there's one) so you can use it in many scenarios. 
You should not attach events like that, use the ng-click directive instead. 
You can use delegation. $(document.body).on("click", "h1", something); `h1` doesn't have to exist for this to be set, but the event only triggers when `h1` is clicked, and it must exist for that to happen.
Yes, in a distributed context. I want to use component xyz but it require css. I have to change my webpack configs and add loaders because the component isn't self contained. I'd find another, so would most people i guess. In the case above the end user just makes a regular import and it works. import Section from 'repo' const Component = () =&gt; &lt;Section&gt;hi there&lt;/Section&gt; The babel pass which transforms the css is on the distributors end. babel index.js -d /dist npm publish There is no hashed css file to be loaded. The babel pass transforms the source itself on the spot. On the end-users side csjs takes in prefixed, compressed css, generates a scope and the component refers to it.
Not happening. There's bugs on the site I've asked them to fix. I don't think they have an angularJS dev anymore so no one is able to alter what's there. Wonder if they added triggers like that already though.
I'll need to do it .off("click", "h1", something).on("click","h1", something) but I can combo it with mutation observers or onpopstate to unbind and bind as necessary. Wow. That approach is so much better. I was right to feel dumb.
You might want to read through [Learning Observable by Building Observable](https://medium.com/@benlesh/learning-observable-by-building-observable-d5da57405d87) and the [ReactiveX documentation](http://reactivex.io/), including their [Intro to Functional Programming in Javascript](http://reactivex.io/learnrx/).
You can probably get to component scope like that http://stackoverflow.com/a/17656616/1616437 or http://stackoverflow.com/a/15425015/1616437 But you sill need to know when and know angular a bit
And why? Babel is objectively better at transpiling, Flow is arguably better at solving types. Both are incredible products. And you are limited severly at least without Babel. Babel has had async/await for a long time, i couldn't imagine going without it. It is also already commonplace to use spread operators for immutable types among other living drafts. When you see this, and you probably have because it's everywhere, aren't you feeling the urge to use actual Ecmascript as it lives instead of waiting for a few people to hack it into Typescript next year? Same goes for ES7 minify, treeshaking, etc. You have heard about it, but you won't get to use it because of TS, does that make sense?
&gt; because Arrays in Javascript are just glorified objects Careful with this kind of reasoning - how arrays are implemented is obviously engine dependent, and in most cases what you said is not true, arrays are stored as arrays unless they're sparse, in which case they're typically hash tables
A full physics library for such a task is an overkill. A quick and dirty example of how you could approach the problem: http://codepen.io/anon/pen/KgWpdB
Is it somehow related to the - broken - https://jsperf.com/?
Ooooh, so it works like JSS and puts a style tag generated by js into the page? So there's no setup required by the consuming developer to use a package that has css defined by csjs. That's nice, very similar to the workflow that you get from JSS
You can't, unless parent page will want to get info from iframe (via postMessage, e.g. you will send script url to add) or parent page will manually add that script. Either way parent page need some work to allow it.
Oh wow, that is rather complicated for me. I will take a look after work. Would you mind if I ask you some questions about this code later on?
Nothing quite so awesome. Just a fan project. It's less about going back in time and more about having the historical/play-by-play data to keep stats. 
Thank you!
you can do an emit when the action trigger creates the button, then have a watcher looking for the emit to add the binding
I don't see that Vue example being any easier than just using jQuery for it. And I don't see it scaling in the way that React and Angular do. In short, I don't see why people pick Vue.
Quit your job. This honestly sounds like a terrible situation. 
Probably not the right reddit for your question. Permanently changing your citizenship is beyond the scope of JS. ...though, you never know. Check github.
So... mostly redundant, with multiple versions of it on the same page, and an entire class of developers who don't know what they are doing because of it?