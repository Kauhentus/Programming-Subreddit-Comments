No, content blocks. That you can append, prepend, or replace. Seen here: http://www.learnjade.com/tour/block-append-and-prepend/
Not built in, but there are helper functions to add it, which I am using in mash.li. Take a look at the following two files: - https://github.com/ChiperSoft/mash.li/blob/master/srv/app/views/layouts/foundation.hbs.html - https://github.com/ChiperSoft/mash.li/blob/master/srv/app/views/pages/index.hbs.html Note the `{{block}}` sections in the foundation file and the `{{extend}}`, `{{append}}` &amp; `{{content}}` sections of index. These are provided by the helpers in [this package.](https://github.com/ChiperSoft/HandlebarsHelperHoard/tree/master/src/helpers/layout)
Cloud9 IDE is pretty nice. It's basically google docs for code. It supports node and a bunch of other stuff too.
Great job on this. Not only is this technically impressive, but it's also a good idea. Bookmarked. :)
That's um... because... (checks BOFH manual. Ah!) when arrays are compared for equality, they're checked for identity equality instead. Because we're Javascript, and that makes sense.
WebStorm is the best ide i've used.
What part is a mystery? Remember to take into account that using the comparison operator on an object does not work the same way as when using it on a primitive data type. Sure, the array has the same numbers inside, but the objects are different instances.
Kinda seems like a case where you need true, false, and mu. Mu means "The question you asked has no meaningful answer" Probably, and I'm no language designer so take this with a grain of salt, that would be unseasonably hard to conclusively prove in most cases :/
Webstorm, hands down. One of the best out there for javascript development. As other people have suggested, Chrome dev tools is great for getting used to debugging. Once You understand how everything is working, migrate over to the built-in debugging. It is slightly different, but has some benefits over Chrome dev tools.
Does WebStorm feel lightweight, or does it consume memory like IntelliJ?
Mac only
I sometimes write a lot of code in the Firebug console - the input area can be expanded and has a nice little text editor to run javascript in. It's a really fast way to prototype new functions and get them working without having to reload the browser. I've been coding Javascript for 15+ years, I only use a simple text editor, no IDE.
My advice for anyone who wants to work on larger applications with shared code bases: Ditch Codekit and learn to embrace build tools like grunt, gulp, or make. None of it is hard to learn and they are infinitely more flexible than Codekit or similar apps Using these tools makes your code more self-contained and easily setup on any machine. It's a pretty bad idea for a code base to depend on a specific application. For example in order to setup any of my companies apps all you need to do is: git clone ... npm install *bower install *grunt build grunt serve *automatically run after npm install This downloads all the code from github, installs all of our dependencies, builds (less, jade, handlebars, browserify, uglify, etc.), runs tests (jshint, csslint, mocha+chai+sinon), makes code coverage reports (istanbul), starts up an express server and API, and opens a browser to the webpage, and watches all my files for changes, and uses live reload to refresh assets on every change.
Since no one told you, well, you're wrong. Check the site and read properly, it's payware with a relaxed system. 
Hi /u/Meomix, Marionette core member here This is a really cool Behavior! You should come join us and show that off in the [Gitter Chat Room](https://gitter.im/marionettejs/backbone.marionette), you can also get a lot of help there. (I'm pretty sure I've seen you around Github and IRC already).
emacs + [js2 mode](http://code.google.com/p/js2-mode/). 
I'm there! :D
Not really, only the downloadable binary is for mac but you can install it by following the instructions of the git repo. I currently use it on Ubuntu. The problems are rather that it's obviously unfinished.
If you are wondering why it's sometimes less responsive, have a look at the HTML it renders. E.g. where the cursor is coming from. The DOM just isn't a good render target for complex UI elements like a text editor. Since I have to open larger files from time to time, that's basically a deal breaker.
I'm hoping they can get it efficient enough for larger files too. I worked on a JS/HTML eBook reader once and to keep it responsive I had to only keep 4 or 5 pages of content in the DOM at once, and as the user scrolled through it I would remove and append elements just outside the field of view. So maybe Atom can be made so that when larger files are open, the rendered document is still small at any given time. An HTML UI is probably fine for just the contents of the field of view. I think it's large documents that make it slow. But who knows
I think github was partially motivated to start Atom by how stagnant the Sublime development has gotten. They saw an opportunity.
To me it just makes big claims that are hard to substantiate. If I need to use it and Angular side by side for a year before I'm going to notice that Angular is leading me to unmaintainable code, and Cosmos is not, then that's a pretty big commitment. You've heard of [Worse is Better](http://en.wikipedia.org/wiki/Worse_is_better), right? If it takes a year for me to understand how your Better is Better then that's a big problem for your adoption. Your tool sounds like an "Eiffel" and not a "C++". Characterizing people who disagree with this style as "bad programmers" probably does not help (even if you imply that is Linus, not you that is doing that characterization). I think that there is an older quote you can use which is not as inflammatory. Several older variants are here: http://www.dreamsongs.com/ObjectsHaveNotFailedNarr.html As for the content of your concept, my main concern (and I guess it is actually React I am arguing against) is that it makes Web interface programming very much like desktop software component writing and moves away from the division of responsibilities that the Web world uses wherein "View programmers" need only know how to write templated HTML and not be full software engineers. http://www.slideshare.net/AgentK/angularjs-for-designers-and-developers You say: "Working with so many entities builds complex relationships. Models, Controllers, Views, Helpers, etc., they're all connected to each other in various ways. " And yet those entities exist for a reason. 1. Models: you must protect your data structures from random modifications. You must centralize them for sharing data across components. All data cannot live within a single UI component. That seems like madness. 2. Helpers: similarly, code must be shared. If you have a single function for rendering a date string in a standardized format, you want that everywhere. Etc. Etc. 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Worse is better**](https://en.wikipedia.org/wiki/Worse%20is%20better): [](#sfw) --- &gt; &gt;___Worse is better___, also called the __New Jersey style__, was conceived by [Richard P. Gabriel](https://en.wikipedia.org/wiki/Richard_P._Gabriel) to describe the dynamics of software acceptance, but it has broader application. The idea is that [quality](https://en.wikipedia.org/wiki/Software_quality) does not necessarily increase with functionality. There is a point where less functionality ("worse") is a preferable option ("better") in terms of practicality and usability. Software that is limited, but simple to use, may be more appealing to the user and market than the reverse. &gt;As to the [oxymoronic](https://en.wikipedia.org/wiki/Oxymoron) title, Gabriel calls it a caricature, declares the style "bad" in comparison with "The Right Thing". However he also states that "it has better survival characteristics than the-right-thing" development style and is superior to the "MIT Approach" with which he contrasted it in the original essay. &gt; --- ^Interesting: [^Unix ^philosophy](https://en.wikipedia.org/wiki/Unix_philosophy) ^| [^List ^of ^software ^development ^philosophies](https://en.wikipedia.org/wiki/List_of_software_development_philosophies) ^| [^For ^Better ^or ^For ^Worse](https://en.wikipedia.org/wiki/For_Better_or_For_Worse) ^| [^For ^Better ^or ^Worse ^\(film)](https://en.wikipedia.org/wiki/For_Better_or_Worse_\(film\)) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+chdhdd9) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+chdhdd9)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
inventive
IntelliJ IDEA consumes memory? It usually sits between 400-600Mb, not sure if that's a lot or not (and probably is limited by the launcher to 750Mb). It feels extremely fast compared to netbeans / eclipse. I often have two or three projects (hundreds if not thousands files) opened simultaneously and it work flawlessly, not a hiccup.
underscore: _.isEqual() angular: angular.equals()
You're being downvoted because technically you are right, one can use ST2 for a lifetime for free. However, it's not very nice to go around telling people ST2 is free since the only part that is free is the evaluation period. For extended use, people are expected to pay up, which is understandable. It's just not enforced.
Cmd + Shift + J
405mb ram hogging for a medium sized front end development project during basic file editing. It feels fast though, as long as you got the ram ;)
Yeah /u/maktouch cleared it up for me. Hadn't read up on the exact terms of the agreement
 JSON.stringify(a) === JSON.stringify(b)
Chrome's DevTools (press F12) is amazingly powerful. There's just a *ton* of stuff in there. You can put breakpoints in your javascript, you can look at the network traffic and the headers/responses, etc. You can even analyze and profile the bandwidth and drill down into the objects prototypes and the like. I use Visual Studio for the javascript development (their intellisense and IDE and reflection back to other JS files is amazing) with Chrome Dev Tools. It's stupidly powerful.
[Enyo](http://enyojs.com/) [Mithril](http://lhorie.github.io/mithril/) [Meteor](https://www.meteor.com/) [Ember](http://emberjs.com/) [React](http://facebook.github.io/react/) 
IMHO, you can use any plain editor like Emacs, Vim or Sublime for coding in JS. The more important bit is Chrome Developer Tools for debugging JS. Personally, I like Emacs + js2-mode + tern + swank-js (for debugging).
Does it work on anything but Windows and/or IE? No and probably not.
You can do that in the browser console in Chrome and Firefox. Don't need anything else.
Netbeans with java from Oracle's site is worth a try for a free, cross-platform debugger.
Got it, thanks. I just wanted to know the animation/css, as that is not my strength. In my previous project, I had a angular http interception code to monitor the traffic, but then I only used a spinner as the animation.
The placeholder attribute is bound to an angular scope, which is how it updates it. I didn't wanna use jQuery, or any other DOM manipulation lib, at all, so if I were to make a stand-alone plugin it'd be pure native javascript one. I didn't wanna go through the hassle of cross-browser compatible DOM-manipulation in native JS so there's why. It's not a hard thing to do though, all it does is updating one attribute of an element, so I might look into it in the future.
Get `deep-equal` from npm. https://www.npmjs.org/package/deep-equal
JavaScript is very meta and flexible. This is both good and bad but it allows for interesting constructions.
Thank you for the JS plugins, I did not know about these. Notepad++ is what I tend to use for other work I do
Looks like you just discovered the concept of chaining?
Browserify dat hoe
Actually both big code editors (CodeMirror and ACE) only render the visible part afaik. But it still is an enormous amount of indirection, especially since every other character has to be wrapped into its own element (to make syntax highlighting work). That's at least one order of magnitude more than what would be needed for an eBook reader - and it has to dynamically updated on every key press.
&gt; To me it just makes big claims that are hard to substantiate. If I need to use it and Angular side by side for a year before I'm going to notice that Angular is leading me to unmaintainable code, and Cosmos is not, then that's a pretty big commitment. I agree about the abstract notions and it's become obvious a tutorial is in order, for people to *feel* the framework and then decide if they like it. Will definitely work in that direction. &gt; You've heard of Worse is Better, right? Can't agree fully on this one. Cosmos' Worse would be less entities/API methods/features. It's definitely not an appealing framework in the standard way, with built-in auth, forms, etc. &gt; Characterizing people who disagree with this style as "bad programmers" probably does not help (even if you imply that is Linus, not you that is doing that characterization). The purpose of the entire "Problem" section is to tell a story and bring context. I thought making other devs from the community emphasize with the problem might create more interest at first, since the framework is new and doesn't provide many features out of the box. Definitely wasn't incriminating anyone, just tellings a story about the pitfalls I personally fell into (and maybe others did as well.) Thanks for the article. &gt; And yet those entities exist for a reason. Of course they exist for a reason, some of the smartest people created them. But then again a lot of people with MVC experience complain about its effectiveness in web frameworks (including me.) I personally started this journey *with* that in mind + piggybacking the knowledge and experience of the intelligent people behind React. Your arguments end up with a couple of logical fallacies. Of course you must protect your data structure from random modifications, but that doesn't correlate into "All data cannot live within a single UI component.", not to mention the "madness" firework. I could just as well say "UI components must be autonomous and cannot depend on external logic. That's unpredictable and seems like madness." Above all, our work is here to serve human needs and use-cases. I'm sure there are cases where MVC is most appropriate and others where not. In my experience maintaining hundreds of UI components and shipping dozens of new ones per week requires as little interdependence as possible, and this is what Cosmos is trying to achieve. 
He should have included universal clone JSON.parse(JSON.stringify(array)) just for comparison.
Thanks for the input. Tried both those units, and got the same error, though. ;(
For now. http://blog.someguy123.com/atom-builds-for-windows/
Looks like you just discovered concept of humor?
I'm curious about your move from "express" to "angular." I was dabbling in the MEAN stack a couple months ago and found it a touch confusing where to put the routing logic/REST calls. Can you explain a bit more about how you dropped express and where angular filled that role? Awesome project man I'm jealous :P 
I use a text editor and the excellent consoles that are in modern browsers. Chrome developer tools, Firefox, and Firebug are all good. If you're just learning Javascript, I wouldn't mess with an IDE. Learn the hard way. Use a text editor you like, a [good](https://developer.mozilla.org/en-US/docs/Web/JavaScript) [reference](http://shop.oreilly.com/product/9780596805531.do), and sweat it out. It will pay off in the long run.
Oh awesome. I'll have to check that out and do the reverse of what they're testing. Thanks!
What is the draw of using this instead of just TypeScript? I may be biased because I love TypeScript, but I think it's weird I've seen a few libraries trying to enforce typing at runtime when you can just do it at compile with TypeScript!
I can't help if I can't read the code. Would you re-deploy with un-minified JavaScript?
Yes, typescript can enforce a lot of typing. I'm using it myself for a big project of mine. (you can see an old version of it at http://boardom.io/ ) However, I've noticed there's quite a few places where typescript can't help you. Namely: Passing data around through methods such as a publish-subscribe module, and websockets. I've written a type safe publish-subscribe module that I've mentioned earlier in this exact thread. Also, with IS, it's easy to design and enforce schemas for event types if you're using socket.io to send data between the client and server. Here's a snippet of some of the schemas I have defined: private static schemas : Object = { 'game list update': { games: is.arrayOf(GameCardData.isValidJSON) }, 'log in': { fbToken: is.string, fbID: is.string, sessionID: is.string }, // etc...
I am in love. Thank you.
The signup page on the demo doesn't seem to want to submit: http://try.ircanywhere.com/#/signup
Strange, what OS/browser? I have no errors from any of my logging services and it submits fine for me. I should mention that IE/mobile support is a bit iffy at the moment.
I am seeing the same thing. Validations aren't allowing form submission it appears.
Hi drunkenfaggot, to left aside a discussion about the impact of Angular.js, I think that DI general should be regarded as one of a variety of patterns. It really depends on one's use case to make use of them. As Node.js already has a strong dependency management system, DI may come in handy in several cases: - when you want to provide functionality across several files belonging to your project without creating your own private npm module or for that - when you want to keep your code DRY: you don't need to repeatedly declare a variable in each file - when you refactor an application It was quite interesting for me to provide f.e. package.json or bound functions like console.log and util.format (as a printf-like function) with this pattern. 
Hope this project prospers, and I can't wait to give it a go - unfortunately the registration on the demo site seems to broken at the moment. Also wanted to mention that one of the most important features of IRCCloud for me is the great mobile apps which seamlessly integrate with the service. Hope that's something that could be seen in IRCAnywhere's future, too :) edit: grammar
Yeah, digging into it now, having unusual production problems from mongodb seems - everything on my local setup is fine. Will see what I can do.
Yeah it's a problem on my end, some production problems with mongodb. Will look into it when I get a chance.
Thanks. Looks awesome otherwise, though. :D
It's a bit of a side note, but I wish we had a standard dialect for Markdown. 
I feel like DI has the effect of hiding dependencies, in the name of flexibility (being able to swap out implementations at runtime)
https://developers.google.com/chart/interactive/docs/gallery
Our only hope is W3C takes up the call and creates a markdown tag with a strong standard. (Zed Shaw said the same thing here: http://vimeo.com/43380467 ) 
Just to piss you off! I like the MEAN stack. There seem to be a few competitors for express lately. Hapi Hapi Joi Joi is my current favorite. It has more application features than express. Have an up vote and a wonderful weekend!
That's a great link, thanks man!
Right-click somewhere in the SOM-tree and select 'Insert script' (or something like that. If you name your script 'formScripts' and add a function like: function alerter(SOMobject) { app.alert(SOMobject.rawValue); } , you can call it from anywhere using: formScripts.alerter(this); _.
This is a template project that shows how you could use each of those frameworks in concert. I cannot speak the the specific implementation but the combination of mongo express angular and node is ok. I love Angular and Mongo Node and Express are alright. 
Cool good to know. Once I'm upgraded at work I'll check it out.
I got that far, right now I'm trying to take the existing functions in that PDF and convert them to something that I can call from anywhere. The problem is they seem to rely on determining an element's location in the form hierarchy, for instance here is the script that gets used when a user clicks a button to add a subform instance: var itemCount = xfa.resolveNodes("sSubtotal[*]").length; if(itemCount &lt; 10) { var newNode = sSubtotal.instanceManager.addInstance(1); itemCount ++; xfa.host.setFocus(newNode.Designator); } else {xfa.host.messageBox("Not allowed more than " + 10 + " lines for this account.","NOTICE")}; So I get what most of that does now - first it counts the number of subforms the user already has, and then if it's less than the maximum (set to 10 here, but I have since converted it over to use a global variable), it then uses the instanceManager to create a new subform instance (a new "row" basically). I added the bit to advance the user's cursor to the first field in the new subform. I can't seem to figure out quite how to modify it so that I can use it as a global function and just have the "Add" button call it. Here's the script for the "Remove" line: this.resolveNode('sRegProg._sSubtotal').removeInstance(this.parent.index); The problem I'm having making that into a global function seems to stem from the resolveNode() bit. I'm not sure if I have to pass something to the function or really how to approach it. What that does is starts with the position of the "Remove" button in the form hierarchy, then figures out what instance the button corresponds to - this lets a user selectively remove a line. Sorry if it's confusing - the PDF I linked to in the OP probably makes the functionality easier to understand.
I think your best bet is going to be to either find/create a function to do a deep check. In reality though this is going to be a pretty rare need case. Either when you compare you are going to have a reference to the same object which will evaluate to true: var a = {}; var b = a; a===b; //true Or there will be some unique ID or Name property on your object to compare against: var a = { ID: 0 }; var b = { ID: 0 }; a.ID===b.ID; // true
Warning: There are links to my employer's site. I really hope people don't think they are too self-promotional, but I feel they are somewhat necessary since they generously allotted me the time to make this!
This is awesome :D I'd definitely use this in my non-Angularjs projects.
Was this inspired by Fabric.js? The API looks very similar. The UI (borders around objects) looks similar. Even src/ and test/ contents look similar, including some method and property names.
Crockford being "main contributor"? How so?
This is a really cool project, I use JabbR daily and really like how it parses stuff like links to youtube videos, images or pasted code to embed them right in the chat window. All the desktop IRC clients look really dated to me, as if they haven't made any progress since the late 90s. It would be nice to have something that is still compatible with them but adds that layer of filters to make chatting a much more enjoyable and efficient experience.
Thanks! Let me know about any annoyances you have or features that would be awesome and I'll see what I can do.
Yeah, this was heavily influenced by angular, knockout, and a little bit of ember. Definitely nothing new here, but if nothing else it is a minimal API with a light footprint. But you're right, mostly it was a learning experience for me.
And I present the famed [big ball of mud](http://imgur.com/BrGgAZk) architecture.
It seems like you still have to write a lot of code to make it work. What value does the library really bring?
Is it possible to dynamically update?
Wanted to try it out but signup and login page seems to be broken.
I like the site. It looks great.
I to have had failed sign up attempts. Tried it in Chrome &amp; firefox on winblow$, Chrome, firefox &amp; pera on my Mac and in Kali. No go. But this is awesome none the less. I have had a IRCcloud account for quite some time. Gona try and install this on a digital ocean droplet here in a few minutes. Thanks for all the work.
repost
if you store money in cents and not in dollars this becomes much easier. 
Excellent question! The example on the site is **seriously** verbose. The code is far shorter without all the comments and when using general selectors to target more than one field (i.e., selecting all `inputs` instead of each one by id). The value comes in keeping your shit organized, and keeping your HTML clean, maintainable and reusable. With the current form validation libraries out there, you are forced to abuse your html with data attributes or you have to deal with a library that does too much for you and is hard to tweak. If you are looking for something that does *everything* for you, then ThatValidator is probably not right for you. If, however, you want to get every aspect of your important sign up/conversion forms right and need full control over the user experience, then ThatValidator offers a very nice api. If it turns out that ThatValidator doesn't do enough for most people, then I may consider writing more examples and extensions for common uses (frequent regexes, like email, credit card validations, popup error messages, etc.).
Yeah sorry it's a backend problem, not a bug with the code something is calling queries to stall but I'm very very busy today so I'm not sure if it will get fixed today.
Sorry updated the post to reflect this. MongoDB is giving me some headaches and hanging on queries, it probably needs tuned or something. However I'm extremely busy today, check back in a couple of days! :)
Sorry, I can't get any further than the eval line :-) 
You can't generally store and use floating point numbers as a representation of money values, because of rounding errors and that kind of thing. The normal way to do money is to store the values as fixed point numbers. In javascript this is done by storing the money value as a string (i.e. store the value as the string "12.99" instead of the floating point number 12.99 which may have who knows how many unexpected additional floating point bits tacked on at the end).
Your label doesn't match its field name: language vs. languages. 
oh my... --------- First of all, `eval()` is slow, and bad for many other reasons. You can accomplish the same result with this: number = Number(number); or even easier with the unary plus operator: number = +number; ----------- Secondly, capitalized function names are generally reserved for constructor functions. It's not required, but is a very good habit to be in. ------------ Thirdly, check out `Number.prototype.toFixed()`. This does exactly the same thing as what you wrote: function ceiling(num){ return +(+num).toFixed(2) }
Regression proofing and proving correctness of domain / business logic. Now if you don't have domain / business logic, for example a trivial CRUD application, then you can probably avoid testing because the value isn't there. In those cases, your tests are often more complex and just as likely if not more likely to be incorrect than the actual code. 
Yeah, sorry. I didn't know about Number() until backwrds mentioned it, and security issues are not a concern in the case in which I am using this because the input is not public. I've since edited the post.
Testing ensures code quality. Coding alone doesn't.
I tend to think of me-in-six-months as another person, one I particularly don't want to irritate.
Along with what has been stated here, having tests gives you a sense of confidence in your code that you are simply not going to get another way.
Unless you are some sort of superhuman who never write any bugs, yes, testing is useful.
Yes.
Yes, unit testing at least, especially on functionality that lots of your other systems will depend on.
Unless I'm missing something, it's not entirely cross-browser compatible. For instance, it would fail in IE with the event handling "onFocus" vs "focus", etc. I know IE is retarded and most Javascript developers don't try making things backwards compatible, but it's possible to make things that way, so I don't see why not.
This right here. As an application grows in complexity, it becomes difficult to anticipate all of the side effects a change can cause. A good test suite will let you know if you break something with your change. You can then either address that breakage directly, or implement your change in a way that doesn't have a side effect. Either way, you will gain significant confidence that your not introducing instability into the system when you ship your change. That said, this the ideal. No test suite is perfect, so you should still do some manual testing, but the scope of what you need to test by hand is significantly reduced. 
Just to add in a real world example. I recently "took over" an application at work, and am going through switching from Ant to Maven, upgrading lib versions etc etc. *Very* little code logic changes. My biggest fear is/has been what runtime issues are going to rear their head with new versions. (In particular, we went from mybatis-3.1.1 to 3.2.6, and a helper class that someone in the org wrote caused _some_ of our queries to throw an exception.....but not all of them. This of course makes me really nervous because with hundreds of queries....who knows what is now broken? If we had tests (we're gaining them slowly but surely as I write them) I could swap library versions out, and once I saw the tests pass... *know* that it was safe to deploy. 
Six months? If I put down a project for two days and come back to it I wonder what the hell me from two days ago was thinking. :)
Good read. I've gone to many of the Javascript Meetups in Chicago and the ones Sean Massa has organized have been fantastic. I'm incredibly grateful that he is able to put these together. If you haven't been to any and are in the Chicago area here is the link from the blog post. http://www.meetup.com/Chicago-Nodejs/ 
I don't know anything about InDesign but the look of the api makes no sense. Why would height be in app.selection[0].properties but width be in its own separate property? Try putting width in the object you are setting to properties. So app.selection [0] = { autoGrow : false, height: "0.5mm", width : "0.5mm" } That is absolutely a guess but it would at least make sense.
Practically speaking, integration tests are more useful than unit tests (if you've gotta pick one or the other).
I wish people wouldn't blindly dismiss eval. It's perfectly fine if input is sanitized and it's not being called in a huge loop. I use it occasionally to analyze equations.
Thank you for the feedback! I disagree that TV requires a lot of code. It requires a decent amount of *text*, but that text can be copied and pasted from examples and the actual code you need to think about is a couple of regexes and how your form should work. That's not challenging and is not 'a lot of code'. You are right that there's no documentation or test suites. It's really not complicated enough for documentation and I'm not sure it should be that complicated. Test suites I am working on. As far as internationalization goes, I would personally much prefer being able to choose which localization library I like rather than be forced to use one embedded into my form validation library (especially if I already have one for the rest of the site!). In TV's validations functions, integrating a localization library is as simple as doing something like: `if(!v.isValidEmail(field.value) errors.push(localize.notValidEmail()) ` If you don't want to write a single line of javascript, then this lib's not for you, simple as that. :)
Correct. That would fail in IE8 and below. IE9 and up work fine. I totally agree it's possible and generally a good idea to make things backwards compatible, but you have to draw a line somewhere lest we'll be stuck supporting IE3 and Netscape forever. The line I chose was IE8 (5 years old, 3 major versions behind and a minute global usage).
Sure, if your application calls for it. Not many "typical" JS web apps have a great need for it, but that doesn't mean it's never a good idea.
There are obviously limitations of this method, but I'm fairly certain that it has serious performance gains with a large number of cases.
The government uses workstations that still use IE7 as part of their standard workstation. I once held your position, but heard the convincing argument that if you can polyfill all the functions you need or "case" whatever you need, it won't really add much overhead and you can easily look anyone in the eye and say, "this will work on virtually every machine" instead of answering emails trying to explain why your code spits an error on something that would have taken 10 lines to eliminate.
More often then not when I'm writing a switch statement is to return or do something when a condition is met. If that condition is simple enough, like x = "foo" or x = "bar", you could use a hash table: // Function stubs function processFoo() { ... } function processBar() { ... } // Mapping var CONDITIONS = { "foo": processFoo, "bar": processBar }; // Login in lieu of a switch function doSomething(key) { CONDITIONS[key](); }
Honestly, I don't differentiate them much. I test the lowest level components that don't have dependencies, and then the higher level components test themselves, and since they depend on other components, that can be considered an integration test. It's all just testing to me. Most important though, is if I break something of find a bug, then I write a test that will check to make sure that I know if it ever breaks again.
I certainly don't blindly dismiss eval, I use it when I have to, when there is no other way to accomplish what I'm trying to do. One of those cases would be a dynamically named function, but even then, sometimes `new Function();` is better. Aside from the "security" concerns, eval is **slow**. In this particular instance `Number(num)` and `+num` are about the same (~7ms for 10000 iterations), but `eval(num)` takes 70x as long (~492ms) Not only is is slow to execute, but if you create a function inside `eval`, the created function will be slow to execute as well. This affects node more than chrome for some reason, but it's still true. For analyzing equations it may be appropriate, but there are [other options](http://pegjs.majda.cz/online) that I would consider first. ----------------- EDIT: I just did a quick test between [PEGjs](http://pegjs.majda.cz/online) and `eval` for a simple equation (`'2*(3+4)'`) and eval is still 4x slower. Just FYI, you're situation is likely more complex than that, but it might be worth looking into.
Eh? What is this?
If you are getting paid, then at least learn AngularJS. Pro developers know what's available and can give an elevator pitch on the pros and cons.
a notable point with this (as it is) is that an unexpected key will cause an exception. this can be a problem or a feature depending on what you're doing.
Thanks!
Definitely... especially if the tester is not the coder... of course it works like the developer expects... if it doesn't they'll fix it... even on big projects, testing (or in more depth, QA) is useful largely because it's another set of eyes... anotherpperspective to make sure the developer isn't making something only they know how to use, or which is usable but unintuitive to others. it can help, as the dev, to 'rubber duckey'... when done, or partly done... present it to a rubber duck, or a stuffed animal, or a plant. the process of explaining/presenting will often untangle problems or point out flaws that weren't aparent. 
This is a good option. For those who don't know, please realize that it's going to result in a TypeError if key isn't in the map. Unless you can very strictly control the circumstances under which doSomething is called, it may be best to do something like var something = CONDITIONS[key]; if (something) { return something(); } return default; // (a default value)
In the sciences they often refer to a program as "codes" and it drives me crazy. That may be the culture this person comes from.
My favourite language is Python, which does not have switch statements. Like others have shown, one can effectively accomplish the same thing using hashes and functions dispatch. However, I do find sometimes that switch statements can be useful being more readable than a series of if/else statements. Here's such an example where doing some function dispatch would be overkill and which does not have a break statement for all case statements. if (orientation === undefined){ this.orientation = RUR.world.EAST; } else { switch (orientation.toLowerCase()){ case "e": case RUR.translation.east: this.orientation = RUR.world.EAST; break; case "n": case RUR.translation.north: this.orientation = RUR.world.NORTH; break; case "w": case RUR.translation.west: this.orientation = RUR.world.WEST; break; case "s": case RUR.translation.south: this.orientation = RUR.world.SOUTH; break; default: throw new RUR.Error(RUR.translation["Unknown orientation for robot."]); } }
It's free of errors, so I don't think it's that. 
I find them elegant in situations like this: switch (thing) { case something: case alsoThis: case andThis: doThing(); break; case otherThing: case moreOtherThing: case etc: doOtherThing(); break; default: defaultThing(); }
Consider making things public and private. Consider extracting those long functions. Consider moving things that look like they should be their own class. (hint: when I see a really long function that needs code extracted into functions, and has a ton of variables that are all related, that's really a class. Consider proper use of MVC. You may have decided that you want to do it the way you did, and that's fine. However, I think you may be putting model and controller code in your views. Your views are doing a lot of logic, and often you won't have really any logic in views. Read a bit up on this. Consider guarding a function at the top against negative code, vs wrapping an entire function in the happy path of an if statement. line 58 of server/server.js Consider doing tdd where the tests are first, then you write the code. Looking at your tests, you havent really done much there yet. Have you thought about using backbones router instead of marionette? Not sure you need marionette there. There's a lot of comments. Comments are ok when leaving yourself todos or a trail when framing things out, but when finishing, there shouldn't be barely any. It's mostly cleanup and such. I'm sure it works, but there's a lot of spots you could easily get bugs or worse in. It would be difficult to maintain. It has room for improvement. Tips: Go spend some time pouring over a few modern OS projects. Download a good IDE like Webstorm and use the refactor|extract until it doesn't make sense to any more. Good luck
This reminds me of the interface I created for a simple text based game when I started playing around with programming in those early days. 
Oh. That wasn't you. It couldn't have been. There's no way you'd write like that. I mean, it totally was that other guy that just quit. Had to have been. Yup. As a matter of fact, I bet that's why the twit left. We're better off without him. Let's rewrite this code. 
Fuglier than a giant switch statement?
For everyone saying that using a hash table is better, why? No one has provided any such reason for it, nor any performance metrics. A simple search is showing that hashing seems to be slower than a switch or if-else, especially in Chrome: http://jsperf.com/switch-vs-hash/29 Can anyone show me that this data is actually incorrect?
Well, not exactly - switches are nicely optimized away by the VMs, if some conditions are met (e.g. for chrome: all options are either strings, either numbers and less than 129 options) to perform better then sets of ifs AND better than hash table.
This is easily dealt with, though. For example, if you just want to ignore a missing key, you can use switchObj.hasOwnProperty(key) &amp;&amp; switchObj[key](); or if you want some sort of default behaviour you can use switchObj.hasOwnProperty(key) ? switchObj[key]() : do_default_thing(); It's not exactly the neatest idiom in JS because of the need to use `hasOwnProperty`, but you can wrap it up in a little reusable function if you otherwise like the look-up table style.
&gt; Like others have shown, one can effectively accomplish the same thing using hashes and functions dispatch. But why? No one is giving any quantifiable reasons why it's better than a switch statement.
Isn't this way more complicated than just using a simple switch statement at this point?
&gt; even faster than switch statements Why would you think that?
http://jsperf.com/switch-vs-object3 switch is slow as fuck when you are hitting cases down the line.
1. don't commit automatically built files in your source repository. An exception to this would be in repositories / branches especially designed for such, like `gh-pages` branches on github. Try to write code that is insular, modular and idempotent. If it's a big, procedural state ball then it will inevitably grow harder to improve and expand as side effects become too hard to reason about. A great way on the path to this is to write code designed to be testable from the get go. This encourages the above general principles very directly, because code that is those three things is code that's very easy to test.
I don't use them a lot, but they seem like a sensible way to do shortcut keys. switch (e.keyCode) { case 37: // left doLeft(); break; case 39: //right doRight(); break; case 27: // esc doEscape(); break; default: break; } 
&gt; http://jsperf.com/switch-vs-object3 Thanks! That's exactly what I wanted to see. Glad someone else actually provided some concrete data.
A demo would be helpful ...
 var foo = require('./routes/foo'); app.get('/api/foos', foo.list); app.get('/api/foos/:id', foo.get); app.delete('/api/foos/:id, auth.isAuth, foo.delete); This is how I usually organize my routes. 
You're not wrong :) I think we can both agree that it is something to be avoided though, aside for a few uncommon cases. Not really relevant, but I really wish functions could be named dynamically without it.
Copy/paste in Vim.
oh, no I totally agree with you there. I definitely include polyfills in my own projects, but on the project level, not at the library level. Wouldn't you rather not have each of your libraries not redundantly add their own polyfills instead of relying on the developer to use the polyfill of their choice? 
The code should be self-explaining. The code should tell the programmer what it does. Then, sometimes, it is reasonable to also leave a comment explaining WHY it does so. But if you have to say WHAT the code does, then you should refactor it in the first place.
as you mention `hasOwnProperty` is essential in case some scoundrel has extended `Object.prototype`
Interestingly for the newest chromes (like the one I'm using) switch is faster, but firefox + older chromes that definitely holds true. 
I haven't come across `using`, do you mean `with`? (it's pretty hard to search for this, so I might be missing something)
Fn.name = 'foo'?
You have it right, I meant with (in other languages it is using...sigh)
Yeah, he's a really talented dude. And very chill too but he's no pushover. Good guy all around.
For example?
What if he overwritten `hasOwnProperty`? That can be bad. Use `Object.create(null)` to get an object without any of the prototype methods (dict-pattern). Then you can safely use the `in` operator. Or use a ES6 `Map` (shim)
Thanks for the tips! I'm having trouble understanding a few. &gt; Consider making things public and private. Within models/views etc? Private methods as opposed to ones attached to properties? &gt; Consider extracting those long functions. This is perhaps a technique i'm not too familiar with. Taking long functions and making them smaller by making code segments into their own functions? &gt; Consider guarding a function at the top against negative code, vs wrapping an entire function in the happy path of an if statement. line 58 of server/server.js What does guarding a function against negative code mean? &gt; Have you thought about using backbones router instead of marionette? Not sure you need marionette there. Why *not* use Marionette's router?
It seems like you're making excuses for everyone's criticism instead of actually doing something with them. In reality, though, there are hundreds of form validators and writing your own form validation isn't that hard. But like someone else said, no documentation and no tests is a nonstarter for a lot of people. Rather than say, "It's not complicated enough for tests" why not say "It's so simple the tests were easy."
I would strongly argue the switch statement is much more readable, and therefor, should be preferred in that instance.
Feel free to send me a private message if one of your WebKit bug is ignored. What is the bug number you have in Apple's bug reporter? I'll link the two bug reports.
JS objects provide far better mappings between data and logic. Switch statements are an antipattern in JS -- perhaps useful for a few corner cases, but you'd be right to question your use of them.
I didn't say it was not complicated enough for tests. I fully intend to make some tests when I get the time! Or feel free to contribute some yourself. I said it's not complicated enough for documentation because there's literally 2 public methods and a configuration API.
This is fine, and use whichever you prefer, but I don't see any objective reason to prefer that to a select (and as others have mentioned, it won't break when key is not part of the object, although that is easily fixed). Plus a select is simpler to extend with fall-through logic if that makes sense in your program (i.e. key codes where multiple keys have the same action, think ASDW and Arrow keys for movement, for instance.) // Function stubs function processFoo() { ... } function processBar() { ... } function processDefault() { ... } // Mapping switch (key) { "foo": processFoo(); break; "bar": processBar(); break; default: processDefault(); break; }
OP didn't mention TDD just testing. my thoughts on the value of TDD have been expounded on widely and probably with too much vigor here in past comments :p I pretty much always do TDD and don't think it's dead. Edit: started off reply with implicit sexism by using "he" which I don't know is true.
Anyone willing to make such statement as "your code is bad and you should feel bad" without elaborating isn't worth listening to, he's just trying to make himself feel important. I can do the same: The guy is a JS engineer at Facebook. That's kind of a joke around SF :)
 Looks cool but I can't recommend libraries that don't have documentation or tests.
 I noticed that you mentioned an alot, MastersInDisasters. Here's a picture of one for you: http://i.imgur.com/kTKRLlk.gif --- --- Hate me? Love me? Respond with an angry/loving comment! I read them all! ^^In ^^case ^^you're ^^really ^^dense ^^and ^^don't ^^get ^^the ^^joke, ^^'alot' ^^isn't ^^a ^^word.
**There is absolutely nothing wrong with using switch statements**, and in many cases they can save you a lot of time, thanks to the cascade functionality. Such as when you need to normalize a bunch of similar but not identical possible inputs (eg, 'n', 'no', false, 'false', '0', 0). Depending on the runtime they can actually be more efficient than building a bunch of ifs, because the engine can optimize for the different conditions and build a reference table internally. Switch can also be really useful when inverted, in order to check a series of conditions with overlapping requirements. switch (true) { case conditionA: // do something only conditionA needs case conditionB: // do something that both conditionA and condition B need. break; case conditionC: // do something only relevant to conditionC break; default: // do something that shouldn't happen under any of the previous conditions. } Now, on a case by case basis, the function hash that others are describing may be a better means of *organizing* your code (particularly if your switch is just calling other functions), and can make your code much more testable, but using that method in lieu of all switch statements is cargo cult thinking.
You are correct, switch statements are much faster due to internal optimizations made by V8.
better than nested ternary operators... but not as funny
It really depends on the code you are writing. Hash maps are one way as everyone else has pointed out (I use them in python -- dicts -&gt; function) but what if you needed some condition to trickle down (omitting the break statement)? It's like a decorator in disguise. I hardly ever use a switch case/when (multilang user here) statement unless something has to trickle through in languages that support it. It's cleaner and easier to read with if else... But hey, everybody codes their own way.
With modern JIT compilers there are cases where they can optimise switch statements like crazy because it can be translated to native machine speak instead of the higher JS layer. From bluebirds author: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#4-switch-case Probably faster because branching on equality of a few simple bytes is native cpu stuff, while hashing is more involved with lookups.
2 schools of thought. In my opinion, well written code rarely, if ever needs comments. Naming, proper sizing, and writing code in the cleanest way possible almost always results in code that is easier to read than a comment.
If you write some kind of interpreter or emulator, yes. Usually, you don't write that kind of code though. By the way, [V8 currently has performance issues with 128+ case switches](https://code.google.com/p/v8/issues/detail?id=2275), which can be a really big problem if you actually write some emulator or interpreter.
I don't know, I was just waffling on about why you should use fixed point for currency amounts. What's a "pow table"?
Oh, good point. Forgot about that.
It's better to just set flags and then react to those flags in your tick function. E.g. on keydown: keys[e.keyCode &amp; 0xff] = true; And on keyup: keys[e.keyCode &amp; 0xff] = false; Elsewhere: if (keys[KEY_LEFT]) { ... }
Looks like [ZWNJ](http://en.wikipedia.org/wiki/Zero-width_non-joiner) or something like that.
Yes.
True. so s/'tdd'/'testing code'/g * and I think my logic still applies
Yea I completely agree with your sentiments. At least I think I do. The Detroit/London comments went over my head but my intention was to say to OP that having tests allows you to change code and add code to your application while having some confidence that things are in a state where they still work (or work as much as your tests had originally proved anyway). However, I've been known to say things unclearly. I guess the fact that we have to resort to drawing stick figures to explain what our apps do to business people implies we all do though :D
Testing code as we know it today comes originally from Kent Beck. He worked at Chrysler. His style is known as Detroit style or classical. There's some that have thought there's a better way, and that's referred to as London style. You were poking the edges in your discussion there. Pretty cool considering you weren't familiar with the names.
The worst comments are inaccurate comments and over-commenting increases likelihood of comments becoming inaccurate over time.
I am familiar with the names. Do the British "others" include Martin Fowler? That'd be especially interesting to me. I had just never heard of divisions in TDD approaches being referred to or divided up in that manner. Interesting stuff. TIL
There's a school of thought that says if you code has many comments, the code must be too obscure. Usually there is a way to better express yourself in code and reduce the comments (maybe this means having more functions and classes).
I hate switch statements, so I wrote this: var dir = {"e":"EAST","w":"WEST","n":"NORTH","s":"SOUTH"} if (orientation == undefined) { this.orientation = RUR.world.EAST} } else { var newRUR = RUR.world[dir[orientation.toLowerCase()]] if (newRUR){ this.orientation = newRUR } else { throw new RUR.Error(RUR.translation["Unknown orientation for robot."]); } } 
... and it is incomplete (and, I would argue, less readable). To make it complete, one would need to change the definition of dir as follows: var dir = {"e": "EAST", RUR.translation.east: "EAST", "n": "NORTH", RUR.translation.north: "NORTH", "w": "WEST", RUR.translation.west: "WEST", "s": "SOUTH", RUR.translation.south: "SOUTH" }; I usually prefer to not use switch statements ... but there are cases where I believe it makes the code easier to read. However, I do realize that this is a matter of opinion.
You would be 100% correct.
Your example is broken. {RUR.translation.east: "EAST"} is invalid. This will not work. 
Err, switch **consistently** outperforms an object lookup on Firefox for me...
I don't get why code readability is ignored by so many developers. :(
That really depends on the scale of your switch.
&gt;Is "switch" ever a good idea
&gt;Maybe it's just me, but I find the longer I've been in the field, the more realization that I can't and won't know everything. More than that, you don't need to. At the end of the day, the client just wants a reasonably robust and extensible solution to some problem. If it works and it isn't spaghetti, you've probably met their requirements. 
In related news, &lt;TABLE&gt; and &lt;CENTER&gt; are alive and well.
That's pretty cool, well done.
&gt; var dir = {"e": "EAST", RUR.translation.east: "EAST", &gt; "n": "NORTH", RUR.translation.north: "NORTH", &gt; "w": "WEST", RUR.translation.west: "WEST", &gt; "s": "SOUTH", RUR.translation.south: "SOUTH" }; Your example above is broken. RUR.translation.south : "SOUTH" is fundamentally flawed. If you tried to do this, you end up with "SyntaxError: Unexpected token ." It's the same as trying to do this: window.xyz = 22 var xx = {window.xyz : 33} It simply does not work the way you think it does. 
Yeah, that makes me wonder, x-skeww, what do you generally work on where it's normal to have a tick function? (I've never seen anyone write javascript like that, I figure you do it for a reason.)
Looking at the [list of features](https://github.com/lukehoban/es6features): ### Arrows This was introduced as a shorthand for creating anonymous functions (lambdas) in Ruby 1.9 - not sure if it existed in any other languages; it's kind of a functional thing, wouldn't be surprised if it were normal in haskell, lisps, etc. ### Enhanced Object Literals No idea, not sure I really understand this feature 100% percent (which means I obviously don't). ### Template Strings Common in scripting languages (perl, python, ruby, php) ### Destructuring Common in functional languages, ruby has support for this to some degree as well. ### Default + Rest + Spread: This is idiomatic in ruby (especially default values for arguments). Rest is implemented via the splat operator, like: def derp(herp, sherp, *args) and you can use the splat to pass arrays as args like so: args = [1,2,3] derp(*args) ### Constants Exists in many languages, I think C is probably one of the earlier to support it (same syntax as ES6) ### Iterators, Generators, Comprehensions Functional paradigm, read the docs I linked above on these sections ### Unicode Pretty important to fully support Unicode nowadays, but programming languages are all at varying levels of support ### Module Support I don't understand the implications of how this works (although I understand in principle what its doing). ### Sets &amp; Maps Sets are like arrays but don't hold duplicate values. Maps I guess are like hashes (ruby) / associative arrays (php)? Not sure about the differences between these and their weak counterparts. ### Proxies Seem like wrapper objects so you can more effectively add additional runtime behavior to existing objects? The docs I linked suggest they could be used for (among other things) logging / profiling of operations which seems cool. ### Symbols Not sure what these are about, although they're a primitive type. If I had to take an uneducated guess I would guess they're similar in purpose to ruby's Symbols, which are the same as a string but without the overhead of a string object, they're just a string (like 'key') except when referencing them all over your code, all instances of the 'key' symbol refer to a single reference in memory of that symbol, instead of creating new strings with the same string contents (thus leaking memory) every time you refer to "key" ### Subclassable built-ins This means you can build wrapper classes around the existing built-in primitive types, from OOP languages. ### Math, Number, String, object APIs Expanded standard library functions for common operations. ### Binary and Octal Literals You can define Binary and Octal numbers easily. I know Java has these, not sure about what else. ### Promises Already exists in JS libraries, but not in the base language itself. Functional paradigm, probably exists in other functional languages. ### Reflect API I think C# and Java have reflection, Ruby also makes meta-programming possible / pretty awesome, so you should be able to do things like ask an object what functions it responds to, or for a list of its properties, or dynamically add those (possibly?). ### Tail Calls Basically I guess they fixed tail-call recursion? I didn't realize this was broken in ES5. 
Is writing a bunch of tests to ensure that inputs are sane supposed to be less overhead than specifying a type? Or do you not check that?
Switch statement, probably by over an order of magnitude. 
Switch statements will always be at least as or faster than a hash lookup + function call. It would be a bug in the JS engine otherwise (since switch statements, especially ones that use small integers, are among the most performance friendly constructs there are). P.S.: "most performance friendly" because the engine can basically say "please just jump the nth address" instead of actually comparing any numbers.
I've seen junior coders use complicated, nested if/else if cascades, when it easily could have been done with a switch statement. And ones who tried to use complex configuration objects where one simple if/else would have been enough. You should obviously pick the right tool for whatever the actual situation is, and using JSON / hash table is the right tool sometimes. But saying "switch statements should be replaced by hash tables if possible" is a *very* weird statement.
I'm currently using a switch statement to determine which regex string to use in a jquery.validator field. I could use a hash table that does the same thing, but I don't see a need to define another object just for a one-off use.
Small remark: `orientation == null` or `orientation == void 0` would do the same but wouldn't have the problems of "undefined may not be undefined": &gt; (function() { var undefined = 2; console.log(undefined); })() 2
Really? My mistake. I thought VMs still had to traverse switches making them O(n) whereas hashtable lookups are O(1).
Ok, voodoo comments about what is "good" and "bad" coding can get incredibly tedious to read. I am learning JS at the moment and am genuinely confused now. Most of the arguments I have seen against it are simply opinion with no evidence. It would be nice to hear a rebuttal from either a performance POV or maintainability POV 
Games.
I get why you did what you did but code like that is a nightmare during the maintenance cycle as the intent isn't immediately clear to someone other than the person who wrote it. I mean a simple % 256 is more readable than &amp; 0xff and most js engines will end up optimising a mod with a pow(2,n) number to using a bit mask internally. PS: ignore the formatting as I am on my phone
Most likely the hashtable. Switch statements using enums/integers are fast in C because it uses a jump table, with a complexity of O(1). In Javascript it gets compiled down to a series of conditional jumps, which is O(n). Hashtable is O(log n). Edit: yeah I confused something here. Hashtables are O(1)
Meetups are easy. I haven't read the original article (don't care too if it was making a case that networking is hard...) Getting out and learning from each other/your users is immensely important in modern programming/development/web dev/business blah blah... User groups are a great way to create a community of people around your product - which will only push your product further in the long-run... I can't imagine not being able to poll my user-base through meetups and user-groups. Just ... gah ... comic sans ... video... gew! =( =(
For a second there I was utterly confused.
Thank you! Bug id is 16397744
Not familiar with the Javascript implementation, but I do know that hash tables have a insert / delete of O(1). You might be thinking of a Tree Map. 
Then this means that the way you wrote your code would not work either as it would miss 4 cases which are captured by my original switch statement.
I really liked your example code! The visualization seems quite accurate within that schema. Very interesting results and concept. 
And if it's conditionB..?
&gt; I haven't read the original article I didn't either, but it's a quick enough read it's worth it. http://www.ugtastic.com/meetups-hard-work/ I think that author made things difficult for himself by approaching everything backwards. Decided on a lot of logistical things, then checked to see if they'd work. He should have found out was available with the venue &amp; other things he selected, then used that to arrange the rest.
The equivalent code would be more like this: if (conditionA || conditionB) { ... // AB if (conditionB) { ... // B } } With more conditions, the switch looks even simpler: switch (true) { case conditionA: ... // A case conditionB: ... // AB case conditionC: ... // ABC case conditionD: ... // ABCD } Compared to: if (conditionA || conditionB || conditionC || conditionD) { ... // ABCD if (conditionA || conditionB || conditionC) { ... // ABC if (conditionC || conditionD) { ... // CD if (conditionD) { ... // D } } } } Not always the best solution, but sometimes the most elegant.
For those wondering: There is an invisible ZWNJ character (x-skeww linked it), in the console.log statements, which you can only see in your editor. It makes it print null every time.
Depends on what you call testing. If you limit your testing to automated unit tests, I feel bad for you.
camus2 got downvoted, but they're not entirely wrong. Many of the ES6 features are lifted from coffeescript, and the rest are lifted from other languages which coffeescript wanted to imitate.
I don't really see the problem, sorry. It's just a bitmask. Everyone should know what that means. Secondly, that line won't be touched anyways. Actually, the whole file probably won't be touched ever again.
I don't recall where Martin has his hand in, but he does. The way I was taught, London gets it from this: http://www.growing-object-oriented-software.com/
This seems useful when many different conditional checks are needed that have common, lengthy resolutions between them. However, to replace a single switch, it would be overkill.
It is so easy not to notice missing break here. I also tend to forget to add breaks when needed. If...else seems more foolproof to me.
&gt; One could write a tool that warns you about missing break; statements JSLint and JSHint both already do this. You have to suppress it by including a comment noting the cascade, thus making it clear that the break is absent.
What if the cases in the switch statement *aren't* conveniently a contiguous range of small integers? You might be right about the relative performance, but the result is not obvious. That's why we profile.
It depends on implementation, I know this is how it works in chrome (from chrome perf tips series), but it's stil O(1) for both switch and hashtable - difference is in access kind: id in array vs hashing and recovering. It might be negligible difference, but there's clearly no reason to use hashtables for perf, if switch tells more.
You're reducing code quality to only part of its definition. Code quality encompasses other things, such as maintainability. &gt; Depends on what you call testing. If you limit your testing to automated unit tests, I feel bad for you. No it doesn't, I don't think you know what the word ensure means.
&gt; Enhanced Object Literals Seems like this feature is about continuing to let the Prototype paradigm be a 1st class citizen of javascript. Right now, Object.create is the thing that facilitates this style of programming. When `__proto__` becomes an official part of ES6 (if that's what I'm reading), then Object.create is redundant. &gt; Module Support Eliminates the need for the UMD boilerplate. See this repo: https://github.com/umdjs/umd I would guess it also makes requirejs obsolete, but we'll see how the browsers implement it. &gt; Tail Calls Tail calls need to be a 1st class feature of a language in order for it to be a legit way to design code. Tail-call optimizations may already happen in the browsers and node, but who can tell if IE11 is doing tail calls in all the places it should. When it's a feature of the language specification and not just a implementation bonus, then you can implement recursion without fear of having a stack-overflow kill you on one obscure implementation. Library writers __need__ this.
I feel like javascript is an exception to this. We've crossed a threshold now where it is possible to do things so concisely and with so little setup, that it can be difficult to decipher exactly what just happened without clarification.
&gt; "that line won't be touched anyways" Famous last words.
I was a fun moment :) once I started I couldn't stop until I had them all.
There are exceptions, certainly if you feel you need to note that something super awesome is being handling automatically outside of what you normally do. However javascript is definitely not an exception to well written code. Quite the opposite. Example of where thestalkmore could improve by removing comments: https://github.com/wmain/PoroTimers/blob/master/server/server.js line 65. // Object used for identifying opposing team members in playerChampionSelections array could be easier to read for most people with something along the lines of: var playerChampionSelections = new Array(generateOpposingTeams()); Most people can read clean code faster than comment + ok code.
I've used that kind of input handling for about 13-14 years. It's always the same, no matter which language I use. Java, Python, Dart, JavaScript... whatever. Anyhow, do you have trouble understanding that line?
mockist is another term! yes. you got it. We're in an interesting time because both sides have valid points, but no clear winner has emerged. If my hunches are correct, someone like Google will come along and make a much better solution and everyone will switch.
I can recommend this book: http://shop.oreilly.com/product/9780596517748.do And Codecademy tends to have very good learn by doing tutorials (in the form of an in-browser editor). http://www.codecademy.com/tracks/javascript
I understood you're setting or unsetting a unique value for each key on hash that you can check against. I'm still unclear on why you'd want to bitshift this, since I can't find any high keycode values greater than 256, and if I could, wouldn't you run into collisions where `232 &amp; 0xff` is the same as `1000 &amp; 0xff`?
I don't do complete unit testing. I test in areas I need confidence in. I rarely do huge function overloading through a single function or text input checking that might result in weird types, and thus rarely have this problem of possibly having multiple types.
Yeah - just read it (was a late night in so-cal last night)... I think he's getting worked up over the wrong details. Honestly looking at his time/cost analysis of the event I was left thinking "and... looks like that was a really successful event with low cost...?"
In edition to the already mentioned, /r/learnprogramming has some stuff on its sidebar you may find useful.
At the moment I lean towards the idea that one shouldn't constrain themselves to a particular way of thinking and that they do both have value. I agree that we are very likely going to see a different approach come along in the next few years. I think the services that need to be mocked have evolved, as well as the genral environment and that is why we are seeing things like DHH and "TDD is dead". Obviously I disagree but it does signify that things are changing and a new way of thinking will be required to truly adapt to those changes. In the meantime I think the main goals and tenets of TDD still ring true and will continue to.
&gt;**Avoid jQuery, all together** jQuery is a great tool for doing dom manipulations with few lines of code, compatible with a vast variety of browsers, but the bowler plate around it makes it painfully slow for situations where we are begging for milliseconds. My $0.02: this is misguided advice. Today's jQuery is not slow. Yes, vanilla javascript is much faster at doing DOM manipulation. Of course it is. But it's also overly verbose and hard to read (there's something to be said about a javascript file that's half as long and easier to read). Meanwhile the *scales* at which we're talking make the differentiation moot. Just to test the performance of your example: [http://jsperf.com/jq-vs-js-element-creationclickbinding](http://jsperf.com/jq-vs-js-element-creationclickbinding) Seems dramatic, right? That is until you realize that even the slow, lazy jQuery approach still runs in a fraction of a millisecond. If you're writing front end code where those fractions of a millisecond you're begging for are necessary, then maybe something's wrong with your design pattern? Use plain JS when it makes sense to. Use jQuery when it makes sense to. Absolutely dismissing the latter is just wrong.
I was talking about cases where switch statements make sense. And those are, very often, small integers. Small integers also include things like characters. A rule of thumb might be if you couldn't use a switch in C, you maybe shouldn't be using one in JavaScript (at least not for performance reasons). Especially since then your function may be rejected by the optimizer, at least in v8, if you use switches for other stuff. If you do use switches for what they are meant for, then the result is obvious.
Yeah, but if you just need those, the key map won't do you any good and a simple keyup handler would be better.
Well, we're talking about the kind of scenario where you have a bunch of those. Switching on key codes just isn't a very elegant way to do it. Stuff like this is configuration. Even if you don't make this user-configurable, you still might need to make this locale-dependent. And even if you don't care for any of that, reassigning those keys is still error prone if you're using unnamed numerical constants. Sure, you can put a comment next to it, which explains that 37 happens to be the key code for "left", but there is nothing which keeps that in sync.
Exactly. Because unfortunately *nobody* maintains their comments which is just as important as the code if you are using them everywhere. 
All these down votes for similar comments...The academic and still in academia contingent has weighed in lol. Give the ones who will graduate and leave academia a little time. They know not what they do.
Thanks for saying that. The guy sounds like a douche and that attitude does nothing for our community. I guess he has the right to treat people that way since he probably fixes bugs related to overflow in IE8 for Facebook. A programmer worth his salt would never dismiss a fellow programmer so flipantly. That isn't to say programmers don't love to rip on other people's code but if he actually had tangible things to point out, a person with that attitude would have gleefully torn his code apart in excruciating detail. I'd guess he didn't know how to respond when asked why.
He probably got downvoted because the majority of these features existed in other languages long, long before coffeescript was a thing.
http://bonsaiden.github.io/JavaScript-Garden/
https://github.com/quilljs/quill from https://news.ycombinator.com/item?id=7716376
Avoid code academy. It doesn't cover the real day-to-day aspects of javascript (for example, you won't learn what a closure is even though everything in real JS applications depends on it). I recommend the following instead (it's the best free resource I know of) http://eloquentjavascript.net/ and perhaps the following if you want a better understanding of the other side of javascript https://leanpub.com/javascript-allonge/read
http://www.asmarterwaytolearn.com I like this a lot. Very easy to follow
This is why every one that is actually involved with...how things perform in the browser have publicly spoken out against using micro performance analyzers. You should base decisions like this based on good practices not performance unless their is an intrinsic reason an approach may reduce performamce. These things could be entirely different in a future version and modern browsers have very short release cycles. I'm not against switch in every case but the main reason people say to avoid it is its easy to introduce bugs with a stray break. Crick ford gives his canonical example in his own code at every one of his good parts talks.
I know this was a bad joke, but table is a very valid HTML tag, and should be used more than it is (for tabular data, of course)
It looks amazing .. and that API .. hnnng. It really is high quality work.
I like the documentation! Especially the "real-world" example is way better than the usual generic examples you see in every project.
Ah, makes sense. My bad, thanks!
The arrows are originally from haskell which is where ruby got them from but JavaScript is getting them indirectly through CoffeeScript as the fat arrow bound this semantics are from there. The class stuff is almost directly out of CoffeeScript the way it creates thin sugar for the current prototype based stuff. Splats, rest params, default params, destructuring, and array comprehension are right out of CoffeeScript which was inspired by ruby. The module system was inspired by racket. (well this is based on speculation by a member of tc39 on irc) Tail call recursion is from many functional languages Maps are proper hash maps inspired by how people wished objects worked. Same with sets that fill in the gap people sometimes use objects filled out with true for The weak versions are ones that can be garbage collected because they can only be used with objects (and you can't iterate then) so once the key goes out of scope they can be garbage collected. 
Yeah but the issue is that the features are explicitly based on the CoffeeScript version 
Aww, /u/html6dev, you're making me blush! ^^Please ^^don't ^^be ^^offended, ^^I'm ^^just ^^a ^^bot.
Hey, /u/html6dev, are you for real? ^^Please ^^don't ^^be ^^offended, ^^I'm ^^just ^^a ^^bot.
It depends on the use case, and the coding style. I might prefer something like the following to a switch: var ActionHandler = { dispatch: function(action){ return this.actions[action](); }, actions: { "m": MenuHandler.openMenu, "p": Game.pauseGame, "esc": Game.exit } }; It's a similar approach, but a little bit more abstracted. Doing something like this lets you swap out different "handlers" based on the application context. Imagine a Keybinding library just parsed keycodes into characters for you, then passed the character to this ActionHandler. In any action, I could do something like `Game.setActionHandler(new MenuActionHandler())`, and have new actions handled. I think this is cleaner than having a function with many switch/case statements.
No, its purpose is to facilitate shorter, simpler, easier to read (and write) code that saves development time. Vanilla javascript snobbery is just that—snobbery. What matters is the right tool at the right time. &gt;And I've seen others who show it magnitudes slower. I already said (and showed with a test suite) that it's magnitudes slower. **It. Doesn't. Matter.** A jet is slower than a missile. But the jet is still fast. A user nor a browser can tell the difference between something that takes 0.001seconds and something that takes 0.0001 seconds. While you're busy writing a long, verbose script that won't be noticeably faster to the end user, I've already written 2 more. You see, this kind of optimization obsession has its place, and it's rarely for run of the mill DOM manipulation. It's one thing to optimize and API call that will be hit thousands or millions of times to save milliseconds and tiny amounts of CPU/memory. It's another to try and save one single browser a 100th of a second. The browser being used and its engine is a far larger factor in speed than jQuery vs plain javascript. When things are the scale of thousandths of seconds, it requires hundreds or thousands of simultaneous calls to notice the difference on the front end. And I hope you're not doing thousands of simultaneous DOM manipulations and bindings ;)
&gt; its purpose is to facilitate shorter, simpler, easier to read (and write) code that saves development time. That's what I said. You presume that any one test shows real life examples but problems arise. A millisecond in one loop doesn't mean anything until you consider you only have 16 of them to move your elements around on a web page before painting occurs and you'll get jank. A lot of us realize [it's just wood.](http://plusbryan.com/its-just-wood)
Sent you a PM - hope to hear from you!
/r/learnjavascript and [How to Learn Javascript Properly.](http://javascriptissexy.com/how-to-learn-javascript-properly/) He does use Codecademy at first, but gets you into things like closures and object oriented programming. That site also has further topics, like Backbone, Node and eventually Angular, Mongodb and Meteor.
&gt; The weak versions are ones that can be garbage collected because they can only be used with objects (and you can't iterate then) so once the key goes out of scope they can be garbage collected. Interesting, thanks!
I'm still waiting for one of these that supports placeholders well and works with validation plugins like jQuery Validate.
~~I generally test everything I can except simple getters and setters. Check out mocking frameworks like [Mockito](https://code.google.com/p/mockito/) and [EasyMock](http://easymock.org/).~~ Sorry thought this was /r/java *facepalm*
NPM/browserify has done wonders for JS dependency management and "packages." It's probably worth a mention; this blog post reads like JS devs are shit out of luck when it comes to modular code. 
You didn't answer his question; you *wouldn't* test the initModule() function - there'd be no point.
&gt; Almost everything is an object. If you count automatic implicit conversion, *everything* is an object.
&gt; Seems like this feature is about continuing to let the Prototype paradigm be a 1st class citizen of javascript. Right now, Object.create is the thing that facilitates this style of programming. When __proto__ becomes an official part of ES6 (if that's what I'm reading), then Object.create is redundant. No, \_\_proto__ remains in Annex B (only required to be supported in web browsers). Enhanced object literals is this: ``` var Thing = {}; var obj = { method: function() { }, Thing: Thing } obj[getKey()] = 1; ``` becomes ``` var Thing = {}; var obj = { method() { }, Thing, [getKey()]: 1 } ```
Avoid w3schools
"Is there something you ask yourself when deciding if you should test something or not?" He asked about the public opinion about unit testing, not if he has to test the init method. 
Sean was describing the amount of effort that goes into putting together meetings but the effort largely goes unnoticed. People think that it's just setting up some chairs and ordering pizza when it can actually be quite stressful and time-consuming.
I think it had more to do with the typical routine getting interrupted which required a bunch of last minute changes. He's been doing these for a few years now and I know personally that Sean is an organized and methodical person. He describes a meeting gone wrong not a typical meeting.
Adding on to the question... Should you test anything related to third party libraries? Or just assume they've tested their code?
Anything that can be, that you want to be. If there's something feasible that initModule does that you can test that may be altered by changes to your application, then test it. Does the init method set any properties? Does it have any measurable effect on your application that you want to be sure is processing? If so, test it. There's a pretty good chance that if the "initModule()" doesn't process correctly, you'll be getting errors in other tests, which is something to consider. Test coverage really comes down to what you feel comfortable with; some people want 100% coverage, some just want to make sure that their core modules are processing things properly. 
Why does it not include ordered/unordered lists?
Bookmarking for later, thanks! So the first link gets into more practical stuff?
Your example is lame, your grasp of javascript and programming is weak, and your logic is flawwed. Have fun with your switch statements.
on the toilet
Can you host an example on Github?
I'm confused, is this built with [KrakenJS](http://krakenjs.com), or Angular? The title on reddit implies KrakenJS, but the title on the repo says Angular.
3rd party libraries usually include their test suite on their repo if they have them. If they don't have them and the library is used in your production code you should test it as well imo.
Didn't he say he would've tested it while he wrote it or alter it if it's not testable? I think the point is that if it's not testable (presumably initModule does *something* and given the name it may do a bunch of initialization work that the entire base state of the application is predicated on so you probably *do* want to test it). 
This is built by [ChipaKraken](http://reddit.com/u/ChipaKraken), so I guess that makes it a Kraken app? Or maybe the music app itself is called "Kraken". I haven't checked out Krakenjs, yet, but according to its [website](http://krakenjs.com/) it extends Express which is a Nodejs web app framework. Therefore, it shouldn't hurt to use Angular with Krakenjs.
Bravo OP, for your attention to details and efforts to make the documentation actually useful, which sometimes even more important than the library itself.
http://mcdlr.com/i/cheerful.gif
What have you tried thus far? This is a forum to help people with questions, so that they can learn from it. Not just hand people questions to their problems on a silver platter.
Correct. It was an attempt to show that these things can take more work than people seems to assume.
Ah! I can definitely see how it would look that way. I run two other meetups out of the same office, but they were already established. I was trying to set up the same things for the Ember.js meetup, all of which I knew was possible, but there were some new problems. The biggest issue was the lower budget, which cascaded into food vendor issues and extra time dealing with chairs and presentation setup. None of that would have been an issue if we could have used our normal presentation room.
Thanks a lot
As it was mentioned bellow I called it Kraken music app just because I'm ChipaKraken 🐙
Certainly. The post includes a link to the following repo: github.com/tkambler/grunt-example
It looks promising. Do you plan to add a file browser or at least a basic king of image upload? 
I was inspired by the classic Williams arcade game Defender. This is not just the first game I coded in JavaScript, it's the first thing I've coded in JavaScript ever. It took me 10 weeks to complete. This is a "Version 1" of the game. It also has a bit of cruft in it due to traveling up the learning curve as I coded it. Thank you for giving it a look-over. I'm interested in any comments people might have. Edit: I forgot to mention that I put the source code for the game on github under an MIT license. [Cthender Source](https://github.com/cleespencer/cthender) 
Lol
Generally speaking, I find it helpful to separate code into modules, and then test the module boundaries. Don't test 3rd party libraries; instead test the functions that you've written that are called by other modules, or are hooked up to the UI. If the user can click a button and it runs a function to do something, then you probably want to test the function to make sure it does what you want. So...you've got a module that handles user auth. You then think about how it's going to be used, eg., "okay, people can login, logout, check to see if they're logged in, register, reset their password, change their password, change the account details", then write a series of tests for each of those. Basically, the mental model should be that your code is a black box, covered in buttons. Every button is something that outside input can trigger, and should be hooked up to some functions you wrote. Those are worth testing. &gt; I have functions like 'initModule' that are used to simple initialize some sort of module, but I don't see how I could test this. It's hard to know without more context, but that sounds too low level to me.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Progressive tax**](https://en.wikipedia.org/wiki/Progressive%20tax): [](#sfw) --- &gt;A __progressive tax__ is a [tax](https://en.wikipedia.org/wiki/Tax) where the [tax rate](https://en.wikipedia.org/wiki/Tax_rate) increases as the taxable base amount increases. The term "progressive" refers to the way the tax rate progresses from low to high, with the result that the average tax rate is less than the highest [marginal tax rate](https://en.wikipedia.org/wiki/Marginal_tax_rate). The term can be applied to individual taxes or to a tax system as a whole; a year, multi-year, or lifetime. Progressive taxes are imposed in an attempt to reduce the [tax incidence](https://en.wikipedia.org/wiki/Tax_incidence) of people with a lower [ability-to-pay](https://en.wikipedia.org//en.wiktionary.org/wiki/ability-to-pay), as such taxes shift the incidence increasingly to those with a higher ability-to-pay. The opposite of a progressive tax is a [regressive tax](https://en.wikipedia.org/wiki/Regressive_tax), where the relative tax rate or burden decreases as an individual's ability to pay increases. &gt;==== &gt;[**Image**](https://i.imgur.com/H8VTqCo.jpg) [^(i)](https://commons.wikimedia.org/wiki/File:IUSY2011_Banner_Tax_the_Rich.JPG) --- ^Interesting: [^Flat ^tax](https://en.wikipedia.org/wiki/Flat_tax) ^| [^Regressive ^tax](https://en.wikipedia.org/wiki/Regressive_tax) ^| [^Tax](https://en.wikipedia.org/wiki/Tax) ^| [^Income ^tax](https://en.wikipedia.org/wiki/Income_tax) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+chfrd2b) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+chfrd2b)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Primitive types are immutable, so no, it's not possible. You can wrap your primitive type with an object, like this: function MyNumber(n) { this.n = n; } MyNumber.prototype.valueOf = function() { return this.n; } var someObject = {a: 1, b: new MyNumber(2)}; var myRef = someObject.b; MyNumber.call(myRef, myRef + 1); console.log(+someObject.b); // convert to number with +
I guess i wouldn't be fair to count that. There is a nice discussion here http://stackoverflow.com/questions/9108925/how-is-almost-everything-in-javascript-an-object/9110389#9110389
You can achieve something similar with closures: var someObject = { a: 1, b: 2 }; function property(object, prop) { return { get value () { return object[prop] }, set value (val) { object[prop] = val; } }; } var ref = property(someObject, "b"); ref.value; // 2 ++ref.value; // 3 someObject.b; // 3 This works because the getter and setter functions have access to whatever bindings were in scope at the time of their creation (`object` and `prop`). You can now pass `ref` around, store it in a data structure, etc.
so this is with the last.fm API? how did you like working with it? 
It could do with image resizing and positioning. It always seems that images are second-class citizens in these editors.
w3fools may not be the best source of knowledge, but it's surely better then it was before: https://github.com/paulirish/w3fools/issues/50
He already answered the question. It isn't doable. The rest of the post is a potentially viable alternative.
The answer is still valid, as there are mocking frameworks for Javascript as well...
Last FM's api is really easy to use. Also there is awesome documentation. So it is good
Did you use the genres tags? I know they provide them, but I did some random tests and it seemed that for lesser known artists, there wasn't any information about the genres. Can you confirm?
It is when you do this: &gt;window.alert = function(){}; Now, when is eval() a good idea?
Thanks. Starred for later :-)
&gt; Certain css stylings cause an element to be promoted to a GPU layer. That's not 100% accurate since: 1) many browsers (looking at you, Firefox) still perform {vendor}-transform on the CPU, 2) only the 3d versions of those properties will move to GPU, and 3) in order for them to be moved to the GPU, you need to initialize them with a 3d init state, for example: &gt;-webkit-transform: translate3d(0,0,0) Otherwise, those DOM transforms will start on the CPU first, and moving it to the GPU will become expensive once all your elements have loaded. Also, if he really want to look at optimization, the author should have started looking at requestAnimationFrame and writing a callback queue in order to avoid layout thrashing.
&gt; A user nor a browser can tell the difference between something that takes 0.001seconds and something that takes 0.0001 seconds. A user will not, but your browser will notice the difference between a millisecond and a tenth of a millisecond -- which is the difference between whether your browser will execute a callback or not firing. BTW, the only real advantage of using jQuery is cross-browser support. jQuery is decent for what it does, but it does create lazy JS developers, and their code could be optimized further even if you had to use jQuery. EDIT: I =&gt; A
&gt; someObject still has to reference your value object or your code doesnt work,so you didnt decouple anything. Nope, read the code again. `someObject` only knows about its own properties, `a` and `b`. `ref` holds a reference to `someObject`. A reference to `someObject` is not needed to use `ref` to access `someObject.b`. I've already explained how this achieves decoupling in my previous post. &gt; You cant pass "value" around ,increment it,and expect objects "referencing" value to increment. Nothing 'references' `value`: **'value' isn't even an object**. It's the name of a getter/setter pair on an object which simulates a property. The `++` works because it invokes the getter/setter functions. We are able to change the properties of `someObject` through `ref` because it retains the necessary references via a closure. It's a proxy for `someObject` which happens to only operate on one property. &gt; it doesnt work. You have to pass an object that has value as property. Perhaps you should try running the code this time. &gt; and ever worse, someObject now cant be garbage collected. Show me a heap snapshot verifying your claim. This sort of closure usage is such a ubiquitous pattern in JS that I doubt it has serious implications for memory usage. If you can correct me here, by all means. In any case, abstractions like these **always** introduce some sort of overhead. It's your choice whether or not to use these patterns; I was simply offering the OP an answer to his question.
Obviously, it's For Tobacco Use Only, duh... 
Good point :) Anyway, maybe someone will find some creative way how to use it. At least it's really relaxing :)
Of course it works with angular, just not out of the box. I've always found it best to use a single controller outside of routes as the path of lease resistance when using larger JS components like this one. This way you can hide it when you need to, but don't have to rebuild the DOM for the tool
Your obtuseness is amusing.
That's really unfortunate given that they should know. Although that may not be a very large sub. Sorry I couldn't help more.
your own curiosity and https://developer.mozilla.org/ learn to explore javascript. That's when it becomes fun!
absolutely. it allows for dynamic updates of chart data, as well as for switching out the entire chart in place. you can actually use it for some fairly nice animations such as an animated bubble chart that shows changes in data over time.... 
Making javascript easier for coffeecritters seems like the tail wagging the dog. 
Thanks.. I'll bear that in mind when I ask one of my minions to get it working ;-)
Nothing annoys me more than seeing coffeescript examples. Please, just show the JavaScript when you are writing documentation, people who use CoffeeScript or TypeScript or whatever can do the easy mental conversion to their language of choice, doing so in reverse is not so easy.
 var arr = [...]; function useItem(x, y, z, itemID, blockID){ if ( arr.indexOf(itemID) &gt; - 1 ){ ... } } Also - I wouldn't name your array "array". Probably should use something more descriptive.
Thank you! The first thing I tried was Phaser, but I couldn't get it to work. I saw that it used PIXI. PIXI worked on the first try, so I stuck with it. And yes, I'm not an artist. I need to find one of those :)
hubspot libraries always have such great marketing sites :)
See the sidebar.
Thanks again.
I know this isn't the most popular kind of project to release, considering the alternatives, but I'm not here to sell you on using it. I'd really appreciate any feedback though.
I think you need handlebars js
http://api.jquery.com/jquery.getjson/ ?
Isn't Ember MVC?
That makes a lot of sense. Thanks. It seems splicing is ~~the de facto most efficient way of removing an element from an array in JS - no matter what size.~~
Effective JavaScript by David H.
Hmmm I think you might be right, I glanced at it, and it seems that may work well. Thanks!!
&gt;I was thinking that Splice would have to allocate a whole new array (like javas array.remove()) to remove a single element. Arrays in Java don't have any methods. Do you mean ArrayList.remove? That one doesn't allocate a new array. http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html#remove%28int%29 &gt;Removes the element at the specified position in this list. Shifts any subsequent elements to the left (subtracts one from their indices). It leaves the backing array as it is and just moves everything after the index by one. The more stuff there is after the index position, the longer it takes. In JavaScript, this stuff is up to the engine. The modern ones use heuristics and runtime information to find the most suitable implementation for a particular use case. Usually, this works really well.
Love the logo and the how clean your code/organisation is! Sorry I don't have much else to add :)
One thing I would like to mention is the sheer level of polish you've put in. Good job. Good docs, CI, coverage, portability and a pretty logo. I like the structure of the utils too. One question, why `Gruntfile.coffee`? As a throwback to `makefile`-esc syntax? Because that's what it feels like. Despite not being a huge fan of CoffeeScript, I kind of like the idea for a build script, providing it was pretty simple. Nice test suite too. Really good job, yet another good example of how to do a JavaScript library right.
Thanks for the kind words! I was active during the early days of Grunt and it used to have a simple, but less portable syntax. Once it became more verbose, I decided to experiment with the CoffeeScript support. I wrote up my thoughts here: http://tbranyen.com/post/coffeescript-has-the-ideal-syntax-for-configurations
Thanks! If you end up trying it out, please report back with issues in the tracker :)
First, your example Java code is poorly formatted, so it's hard to read. Second, your example Java code is much more expensive than just calling the .remove() method. The .remove() method will remove the element at index i, then move all elements over by one. This requires 1 operation for every element that needs to be moved over. But in your swapping example, you're allocating an all-new ArrayList (buffer), and then copying _every_ element in your original list, rather than only the ones after the item that was removed. It's actually your "swap" method is the one that actually allocates a new array, not the built-in .remove() method. Your swap method will always be slower in Java. As others have said the implementation of the array in JavaScript is...well, implementation-defined, but based on your experimental results, the same logic applies to Java as it does to JavaScript.
Good call with Grunt. As a member of the team, I should have known better than to forget writing a plugin :-p on it! As for performance, all templates are immediately compiled to JavaScript, which is then executed separately. I'd only be interested in testing against this compiled code. Do you think it'd help get newcomers more interested to see these benchmarks against stuff like Underscore/Lo-Dash, Handlebars, and Jade?
The Java code is poorly formatted, I agree. I'm relatively new to reddit so I apologize for that. However, you are wrong on how the actual Java code works (due to my poor formatting, I'm sure). The remove() method is an incredibly expensive operation. Shifting each element back, like you said. Concerning swapping, there is no copying of the elements per se, only their references. The buffer ArrayList is never removed or reallocated. That said, inserting an element into an ArrayList is of magnitudes faster than removing an element at a specified index. This is especially true when removing more than 1 element from the array.
Your benchmark is completely broken (like 99% of jsperfs so don't feel bad :P) because you are using an empty list 99.99% of the time for .splice and a full list for swap Run this benchmark http://jsperf.com/arrayswap/3 and you can see that the splice benchmark is not even doing any work at all. Given that swap method was within 50% of the splice method even when splice was cheating, it's pretty clear that swap is orders of magnitudes faster in reality. 
So, first, JavaScript is a dynamically typed language, which means you will want to declare variables this way: `var xPosition`, instead of: `float xPosition`. Second, there is only a single numeric type in JavaScript, [Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number), which I believe is the rough equivalent of floats in other languages. Third, functions do not declare return types (such as `void`); they simply return a value or create side effects (and implicitly return `undefined`). Finally, I assume that the functions `size`, `smooth`, `noStroke`, etc. are SVG functions that are provided for you in the global scope (meaning they can be accessed from anywhere), or that you have previously defined them yourself. Your code is close, but here is how it should look in JavaScript: https://gist.github.com/nicholascloud/4617fd63291a3d1b3f2c
For one, JavaScript is not Java. They are different languages for different uses. With that being said, loops are nearly identical across all languages. However, what you have here is not a loop, at least not a user defined one. The draw() function is a loop that executes X number (usually the FPS ) of times a second. How many balls are you trying to draw? 4 I think? Because you are moving them in the draw() function, it should move every iteration. What is happening when you run it?
For operations like this I like to use [underscore.js](http://underscorejs.org/) or [lodash](http://lodash.com/), both of which have functions that do exactly what you want. `_.contains()` will determine if an array has a particular item. `_.sample()` will pull a random element from an array. Really helpful, and keeps code terse and descriptive.
Splice is using a fully populated list - not an empty one (100% of the time). Additionally, the benchmark is about measuring how quickly to remove obsolete entities from an array (like you'd need to do in a particle system, e.g.). I don't see how the Swap would be faster, in reality or otherwise, based on the benchmarks. aeflash's insight makes a lot of sense and explains the results. Basically the JS array seems to be a kind of hash map pretending to be an array - as opposed to a 'true' array.
The .splice version is operating on empty list 99.99% of the time while the swap version keeps operating on a half-full list. Did you even check the benchmark I linked that shows this?
&gt; also im am 16, am i starting too late? Nope. Starting earlier than a lot of us. It all seems daunting, but pick somewhere to start and just keep going. (I recommend just focusing on HTML, CSS, and JavaScript.) Try building a text adventure game, like Zork. That would be an awesome project, and you could even add images for each "room" later. If you have a hobby collecting things, make a web app to help you track your collection. Or if you're into fitness, make a web app to help you track your sets/miles/whatever. If you like to play MMOs build a web app to help you calculate gear effectiveness. Build a web app (or a console app in node.js) that automatically goes to your favorite news websites and spits out the first 10 headlines for you. Then add an "auto update" feature which polls those sites for changes every X minutes and spits out new headlines. Figure out how to do sprite animations with CSS/JavaScript and then make an old-school rogue-like game in the browser. Best of luck to you.
i have never used genre tag on last,fm because mostly all tag are added by users
I did, truly. Could you further explain what you mean by an "empty" list? The setup phase of JSperf makes sure the list is fully allocated before each benchmark, correct?
Maybe some ES6 stuff is mentioned, but you'd probably be better off with MDN for that 
You should see the text "splices called x pushes called y", the y is like 3000x bigger, meaning it did 3000x more work. So we can calculate it is 1500x faster for this case (N=1000) because it was 50% "slower". The test code is ran in a loop that runs for a while before setup and teardown are called. So the splice code has an empty list after first iteration, and then performs thousands of iterations on an empty list unlike the swap version. Then comes the teardown and setup, rinse and repeat for about 80 samples. But it is actually hilarious how jsperf's design can make people convinced that O(N²) is faster than O(N)
The amount of calls to splice and push is meaningless in this benchmark since we are interested in the result not by the means. Since the JS array seems to be a kind of hash map I'm sure a push and splice have similar costs - but I am not at all interested by the means, only the result, i.e., an array containing alive (!removed) entities. Furthermore, I don't see how the splice would ever attain an empty list. Even if it did - it wouldn't be invoking the .splice calls since it would have removed every single element from the list already if it had.
You are missing the point. The point is that if the benchmark was implemented correctly, those numbers would be close to equal. See this benchmark which correctly gives a fresh list for every iteration: http://jsperf.com/arrayswap/4 and see the splice calls going through the roof compared to /3. However, /4 is not valid to measure the difference in general because the list resetting is now being done during the timed section.
I just published this library which, basically, allows to connect to any Meteor server and treat it like a real-time platform like Firebase or GoInstant. If you'd like to read more about it, I wrote a post on my [company's blog](http://mondora.com/asteroid-a-better-way-to-build-meteor-apps/) which goes a bit more in detail. (The site is in Italian, but don't worry, the post is in English :-) ) I'd love to get some feedback on it, so feel free to share your thoughts. :-)
It seems you are looking at this slightly amiss. The array references (list &amp; buffer) are swapped. The list nor the buffer are never up for garbage collection (Only the removed, i.e., not kept entities are GC'd). The buffer isn't re-allocated either. You mention hidden re-sizing that ArrayList does under the hood (since it is backed by an actual array). But the buffer isn't starting from scratch each swap - it grows dynamically with the list. Moreover, your sample test, while amusing, is completely irrelevant - I think we both know what references are. A single remove() is fine and preferable if you're doing it once. But not when entities are added and removed constantly. Moreover, you would be getting Concurrency exceptions if you would try to remove an index out of an array while looping through it in Java - so it isn't even an option. The swapping method is definitely the best way to accomplish this if you're concerned about speed.
This is a really fun little game. 546 is my highest score so far.
I appreciate the information and enthusiasm but first of all, your point that those numbers should be close to equal is utterly misguided. The splice removes an entity when it is deemed removable (by its 'removed' boolean) while the Swap pushes all alive objects (i.e., those who are NOT 'removed') into a another list. Turns out this is not the way to go in JS because arrays in JS are like hash maps so removing and inserting values should be quite similar in performance. This is why the swapping is bad in JS, unlike in Java where you have actual array backed lists where removing an single element from a position can be costly. Especially if it's an array backed list. I urge you to read the JSPerf FAQ on the setup phase. It is there so you DON'T do setup duing the timed section (like you have done in /4). Here's a small snippet: "(runs before each clocked test loop, outside of the timed code region)"
Hey Tim! Neat piece of code! I'm sure many people would appreciate if you spelled out what's different about combyne as opposed to, say, handlebars.
Firstly, even when arrays are (they are not, unless you are doing something really wild) represented as hash maps the splice algorithm would still have to re-map every numeric key, just like an array has to move every element. Secondly, an initialized list has 50% removable elements so what difference does it make if you call push on a non-removable vs splice on a removable item? And finally: &gt; Here's a small snippet: "(runs before each clocked test **loop**, outside of the timed code region)" Your code is put inside a **loop**, and setup is called only before each **loop**. However, `.splice` has already cleared the list after the first iteration of the **loop**, so it will not do any work for rest of the **loop**. You are completely missing why I put the list initialization in the timed code - it was only to show you how jsperf works: while (notEnoughSamples()) { // Where initialization actually happens setup() // The **Loop** for (var i = 0; i &lt; 1000; ++i) { // Where your code is expecting initialization yourCode() operations++ } tearDown() samples++ }
That makes sense - JSperf.com seems to be down atm. I'll edit when I've looked it over. In the mean time, is it your opinion that swapping is, even in JS, the fastest way?
Good question! There are several differences between Combyne and Handlebars: Pre-compiling: - Intelligently bundles as little code as possible to render the template, which means that if you don't use loops, no code is bundled to run them. Handlebars appears to have a similar, manual feature: `handlebars &lt;input&gt; -f &lt;output&gt; -k each -k if -k unless` - No runtime is required to consume Combyne's prebuilt templates. Partials: - You can use any template engine with Combyne's partial implementation: template.registerPartial("from_handlebars", { render: Handlebars.compile("oh hey") }); Filters: - Chaining, so you can do things like `{{ var|uppercase|reverse|i18n 'en_US' }}` - Defined locally to a template. This aids with portability and assumes you're using good compression techniques like GZip when serving content. These are just some initial differences I can think of, I should think this over more and write a blog post.
Yes swapping is much faster for exactly the same reasons as in Java. Again - it wouldn't matter if arrays are hash tables because instead of moving array's elements, a hash table based splice would have to re-map all the numeric keys coming after the key you want to remove. However, have you considered using data structures like Set which have O(1) removals?
Sure, if sometimes a linked list may be better - but not for entities. Your example is perfectly sound if you only take into account that you are removing a single element. Consider an explosion happens and three entities die and no longer need to be updated (tick():ed). Removing these 3 entities, from your size 10 ArrayList, would reorganize the array on average 5*3 = 15 indices. As opposed to 7 in a swap. Think how that would escalate if more entities would die. The swapping method isn't my opinion but a tried and tested way of solving an issue, and is certainly not the topic of discussion.
Something about this reminds me of minecraft. Pretty neat little project.
Also, wow: https://github.com/wycats/handlebars.js/issues/227 Being able to trivially change the delimiters was a huge requirement for me from the beginning. This is a major difference in opinion.
[Mustache.js](http://mustache.github.com) is a templating library that is very easy to use. Took me 15 mins to add it to my project. 
You're right, my JSperf was horribly faulty and riddled with feces. I appreciate your help, really. Re-aligning the keys in the hash table also makes complete sense. I have not tried nor heard of the Set data structure for JS. It seems it's a relatively new spec and incompatible with most (all) browsers currently? (looking at moz docs). May be usable in node I guess. For the time being it seems the good old Swap is the best/most compatible way of doing things, I presume?
There should be many libraries that implement it, for example https://github.com/montagejs/collections Yes, swapping is the fastest way to do mass removals from random positions if you have an array.
I appreciate the help, could've had some horribly misguided assumptions of JS, thank you.
There are tons of articles on architecture in JavaScript apps. I've linked a few below and I highly recommend reading up on the principles and then trying to apply then yourself. You'll learn a lot better that way. :D http://addyosmani.com/largescalejavascript/ http://css-tricks.com/how-do-you-structure-javascript-the-module-pattern-edition/ http://stackoverflow.com/questions/5400132/javascript-architecture-application-structure-best-practices
If you want to improve on the swapping, you can - but it's probably a waste of time (premature optimization), but it's most certainly not simply calling remove(). There's a new help thread on this issue once every week. Just google it - you can start here: http://www.java-gaming.org/topics/arraylist-vs-linkedlist/27017/view.html And to answer your question of "whom" - game developers.
/r/coffeescript ***** [^report ^a ^**problem**](http://reddit.com/r/LinkFixerBotSnr) ^| [^delete ^comment](http://www.reddit.com/message/compose?to=LinkFixerBotSnr&amp;subject=Comment%20Deletion%20%28Parent%20Commenter%20Only%29&amp;message=%2Bdelete+chge1ye) ^| [^source ^code](http://github.com/WinneonSword/LFB) ^| [^contact ^developer](http://reddit.com/user/WinneonSword)
Cool, I haven't tried it yet. Do you like it? Do you use it instead of jquery? If so in what type of projects is it best for? 
&gt; zepto http://zeptojs.com/
X-post this to /r/proceduralgeneration! This is incredible man, well done. 
&gt;If you want to improve on the swapping, you can - but it's probably a waste of time (premature optimization), but it's most certainly not simply calling remove(). From the scant info you've given I could say everything you're doing is premature optimization, since I have no idea what you're doing or why you're doing it. I thought you wanted to remove 1 item from the list, so .remove() is the appropriate thing to use in Java. If you want to remove more at once, then sure, don't use .remove()--but why are you wasting a ton of time copying every item in the list? Yes, it's wrong to do premature optimization--but is this really so premature? You know there cannot be any situation in which you would prefer the swapping method to the method I presented here. It's a mathematical fact. It's simply impossible. Like, what's the point? It's not more lines of code. It's not harder to understand. It's not any less readable. It's provably faster, it uses less memory--why wouldn't you just do it? You're already going through the trouble of writing your own removal code, so again, why not just do it right the first time? &gt;There's a new help thread on this issue once every week. Just google it - you can start here: http://www.java-gaming.org/topics/arraylist-vs-linkedlist/27017/view.html I don't see a single performance test there. Of course I didn't look very hard, but it doesn't seem like the thread is dedicated to a discussion of whether the swapping method is faster than the the method I've presented here. It merely presents the swapping method as being faster than the built-in .remove(), which is obvious and needs no justification. &gt;And to answer your question of "whom" - game developers. OK, here's a game developer-oriented analogy for you: if a sprite moves somewhere on the screen, how much of the screen are you willing to redraw? The source and destination of the sprite? The half of the screen they're in? The whole screen? Here's another one: if you're doing collision detection, how many other objects do you check for a collision with? The ones nearby the object? All of the other objects? Now here's another one: you have a bunch of triangles to draw on-screen in 3D. How many of them do you draw? Just the visible ones? All of them, including the ones hiding in the back that can't be seen? For the ones that you draw, how much of each of them do you draw? The entire triangle? Or just the side facing the camera? Or just the visible parts of the side facing the camera? And lastly: if you want to remove a few objects from a list, how many other objects do you need to move? Just the ones after the removed items? Or all of the other items? The answers to the first three questions should be as obvious as the answer to the last one.
I'm not sure why you say that swapping is the fastest. Based on your JSPerf, you could have done the whole thing in-place without any swapping at all.
Yep. But ugh, why were you downvoted. I always regret commenting in programming subs. \*shudder\*
Effective Javascript by Dave Herman will turn you from noob to master of the motherfucking js universe; I can't recommend it enough: http://www.amazon.com/Effective-JavaScript-Specific-Software-Development/dp/0321812182
I really enjoyed reading your source, did all the right things and used a consistent code style. Solid entry in a portfolio.
A language in 41 minutes*
My understanding is that he contributes quite a bit to the JS community. I might be mistaken, my touch with JS is quite limited but I hear his name mentioned in some way in every JS tool i touch recently...
I remember a much more basic version of this in an Archimedes magazine. Did you ever come across such a thing? Yours is fantastic, lovely graphics.
minecraft uses the same algorithm for terrain generation, or at least for some aspect of it
This is really neat. Reminded me of WebGL terrain rendering demo I saw earlier http://felixpalmer.github.io/lod-terrain/. I modified OP demo so one doesn't need a page refresh to see new terrain http://jsfiddle.net/kachhalimbu/br8Xd/1/embedded/result/
jQuery [uses](https://github.com/jquery/jquery/blob/master/Gruntfile.js) [Grunt](http://gruntjs.com/).
This is really neat! I know this is petty, but why declare how many lines of code your script runs for? Technically, you could minify it and post that the whole implementation consists of only 1 line. I get it in languages like Python where indentation matters, but with JS, line count really doesn't count for shit. Still really cool though.
I know what everybody thinks: I can do that in one line! :D
more evil version that gets rid of needing the `.value`: function ref(obj, prop, scope, name) { Object.defineProperty(scope, name, { get: function() { return obj[prop]; }, set: function(val) { obj[prop] = val; } }); } // example usage a = { foo: 23 }; // node.js version (browser could use window, either can use this etc...) ref(a, 'foo', global, 'bar'); bar = 'skidoo'; console.log(a.foo); // shows 'skidoo' 
Nice!! Im yet to break 200, ha you have beaten me at my own game.
How do you handle security? It's one of those things that should be mentioned in the documentation explicitly.
played a bit. It's really time-consuming :D GJ with the game
Premature optimization at its worst. Swapping is intuitive, simple and consistently fast. Adding entities is as simple as adding to the buffer. As opposed to looping through an intermediary with your 'optimization'. You're also not taking JVM optimizations into account. Swapping is consistently reading/writing separately while you are unpredictably alternating between reads and writes. Your analogies, while bemusing, are completely irrelevant. The point is, .remove() is not the solution like your original reply suggests. Swapping is the simplest and most efficient way for the common case entity systems. Theory isn't always == to practice.
Would it be the one on printed page 59 of this PDF: http://8bs.com/othrdnld/acornuser/AcornUser8909.zip? (Acorn User, September 1989). I remember typing in, running and modifying this program on both my BBC and, during the next school holidays, the Archimedes my mother brought back from the school.
woaw
Comments from the original author from the last time this was posted: http://www.reddit.com/r/programming/comments/239jbw/dynamic_radial_menu_with_css_javascript_and_some/cguxziu
Its more of a bragging right I expect. Boiling a complex task into so few lines is impressive.
I just figured out how they do it. It starts with a custom grunt task (https://github.com/jquery/jquery/blob/master/build/tasks/build.js) That task just concatenate all JS files into a single jquery.js, it starts with the intro.js (https://github.com/jquery/jquery/blob/master/src/intro.js) and ends with the outro.js (https://github.com/jquery/jquery/blob/master/src/outro.js)
has anyone tried playing with this? it's a little buggy, but i like the idea a lot!
nice one. how hard to write a small wrapper and animate some movement?
There's a well maintained angular project for this: https://github.com/codef0rmer/angular-dragdrop (if you want to go the MVW route)
How exactly does obtaining new turns work? There have been a number of times I've gotten 15 blocks and no new turns.
Everything is NOT an element. I personally think they made some bad decisions to stick to the "Everything is an element" paradigm (like sticking xhr calls in the dom)
I'll admit I'm curious about Polymer, but the author does the project no good throwing in phrases like this: &gt; With Polymer.js, you can craft your own HTML elements and compose them into complete, complex applications that are scalable and maintainable. Whether your application is "complete, complex" and/or is "scalable and maintainable" has nothing at all to do with Polymer. You can make applications that fit those paradigms without Polymer, and I'm pretty sure it's just as easy (if not easier) to create crappy applications with Polymer. edit: evidently, that text was lifted verbatim from the [Polymer website](http://www.polymer-project.org/), so shame on the author for lazy and improper quoting/annotating. If you take a quote from another page, make it obvious it's a quote and don't inject it into your own copy as if you wrote it.
Generalized XHR in the DOM seems like a really bad idea to me too, but I like it for specialized applications. For example, we obviously want to put an `&lt;img&gt;`'s "src" in the DOM, and likewise, I think it makes a lot of sense to write things like `&lt;imgur-gallery src="something" /&gt;`.
This algorithm has been around for a long while. What I like about it, is that when you make your PRNG portable, then you can specify any terrain and recreate it with a single seed. Just pass a 32 or 64 bit integer around, and you can share elaborate scenery with collaborators in a game. 
Good call, this is a very valid point. Marked for documentation: https://github.com/tbranyen/combyne/issues/21
It's an interesting idea, and the basic approach can be seen elsewhere if you look at XHP (facebook's xml-in-hacklang/php library.) I've only played with Polymer.js, but worked quite a bit more with XHP, and it's a big design shift but overall results are much cleaner. The resulting code is much easier for non-developers to read, and goes a long way to improve re-use. Mixing different languages always hurts readability, so it's handy if you can keep your HTML as all XML. ember.js has definitely seen the big advantage to building everything as DOM nodes (http://www.2ality.com/2013/05/web-components-angular-ember.html) , rather than parsing everything as a string. It's absolutely the direction the approved ECMAScript spec has gone in. I'd say it's already the direction that web application development is going in, so perhaps the ? at the end of this post's title ought to be a !.
Based on my limited experience with this (but similar design concepts), it helps with keeping it DRY even more than you'd expect it to. I'm sure you find it's a hard thing to convince others of; you really have to just use it for one project to really grasp its importance. One thing I could see it making much nicer is taking out all that nasty muddying up your HTML content with style and functionality that often happens with bootstrap. Just look at how much you need to stick into your page to do a nice little modal ( http://getbootstrap.com/javascript/#modals ), that could just be something like &lt;boot-modal&gt;Hey, it's a modal!&lt;/boot-modal&gt;
Hah very nice, I did something like this back in 2009 when doing anything with canvas took forever, it used to take about 30 seconds to a minute to generate 1024x1024 terrain. My link is the one in the wikipedia article, midpoint displacement is a great algorithm! [My more recent github vs](https://github.com/loktar00/Javascript-Canvas-Terrain-Generator) pretty close to 130 lines for the terrain gen. [Also generates shadow maps and has diff color map types as well ](http://loktar00.github.io/Javascript-Canvas-Terrain-Generator/). Totally going to implement the isometric view, it looks fantastic.
&gt; Just look at how much you need to stick into your page to do a nice little modal ( http://getbootstrap.com/javascript/#modals ), that could just be something like &lt;boot-modal&gt;Hey, it's a modal!&lt;/boot-modal&gt; Just because *Bootstrap* is a terrible tool for this job, it doesn't mean *all* existing tools are terrible choices for this job. You could instead put this in your HTML &lt;div id='my-modal'&gt;Some dialog stuff&lt;/div&gt; and put this in your JS $('#my-modal').makeModal(); or some similar code, using any of numerous existing UI toolkits that are tried, tested, and available right now. There are some interesting developments going on under the banner of Web Components. However, custom elements in themselves seem to offer very little new value, yet will surely introduce a whole new set of compatibility and maintainability problems.
Web components is a big part of the future, yes
lol - I personally do love js getters and setters, and a lot's changed since 2011. They've been in IE since 9, so they're viable for use on some sites now, though I don't think they can be as nicely shimmed around as most other missing features. 
Lots of typos. I think you meant to wrap your on click event in a function, instead of having an inline expression too.
You don't have to build apps in that style though. The main thing is that custom elements are truly HTML elements, understood by the browser and usable by any code that understands the standard DOM APIs. Custom elements are not just another proprietary wrapper around a chunk of DOM like legacy frameworks like in Angular, Ember, jQuery UI, etc... You can still instantiate your non-UI objects in code rather than markup while using Polymer.
&gt; Swapping is intuitive, simple and consistently fast. It's consistently _slow_, you mean. And how is it intuitive when your first thought should be to do an in-place removal? You'd better have a damn good reason for why you'd prefer to copy the entire list, new allocation or no. &gt; The point is, .remove() is not the solution like your original reply suggests. The point is, in-place removal is the solution here. There's simply no point in creating or using another array, no matter how temporary or permanent that storage is. If you look at the final JSPerf that /u/Esailija provided, you will see that his solution is very similar to an in-place removal, but for some unknown reason, it's being done in a second list instead of the original. ??? I asked for clarification but received none. You accepted the swapping method as gospel without question, so why do you question this method so much?
I'm not sure what you're asking for exactly. Be more specific about the behavior that you want your UI to have. * Are there already items in the light boxes? * Do you drag them into other light boxes or can you drag them into dark boxes too? * Does the box drag with the item? * Can one box hold more than one item?
Reactive programming is the future, but polymers templates are just another in a long line of attempts to hack control flow logic into html markup. That said, make sure to grab some of the shims for web standards they provide, the pointer events shim is especially useful. http://www.polymer-project.org/platform/pointer-events.html
LOVE that demo panel.
[that fixed header isn't annoying or anything.](http://i.imgur.com/wp8b7TO.jpg)
It's problem that concerns 'scoping'. In the first line of code, the variable 'i' is the only variable declared in the scope, so each of the three setTimeout calls will refer to the original 'i', which after 1 second, would be 3. In the second line of code you declare a function 3 times, and each of those three functions contains a 'j' argument. So bascially you now have 3 separate functions and 3 separate instances of the 'j' variable (unlike before where you only had 1 instance of the 'i' variable). You then pass 'i' into each of these functions, changing i by one each time. If you replaced j with i in the console.log, you would print 3 3 3. 
[MDN](https://developer.mozilla.org/en/docs/Web/JavaScript) is and will remain your best friend during the entirety of your stay here in JS land. All the best!
Would this be considered a closure? function() { console.log(j) } It has access to function(j){} even after function(j){} returns. Is that right? What precisely makes a closure is confusing me and what part is the closure.
&gt;You should only need 25 DOM elements at one time, and fill them out with the 25 elements that pass the occlusion test. Ok, _that's_ cool. 
Hi Reddit - I work at Firebase, we're excited to launch Firebase Hosting today. We focused on building something that is serious 'production grade' yet easy to use. The features are a reflection of what we think the best practices are for hosting static content on the web. If you have any questions or comments please let me know!
I put forward some of the logic I did for a widget board on github: https://github.com/rhysbrettbowen/widgetboard Here is a small demo using it: http://rhysbrettbowen.github.io/widgetboard/
While this is a great way to handle data-binding it's adding more logic to apps. More points of failure. More complexity, less stability. 
&gt; We could use a templating language that looks like HTML, but it's much easier just to represent it in JavaScript too This is the real crux of the issue. If we're writing from scratch we're going to spend more time in JavaScript building the components and so laying things out in JavaScript makes a lot of sense. However... If we have pre-built components *anyone* can join them together using web components. Very little JavaScript is needed (perhaps just an API in to the business logic). It comes down to your use case. If you can form a core set of widgets and just want to compose things together you can get by without as many engineers. If you're building large and very unique apps and have a larger engineering team then staying in JavaScript makes sense. Building apps is not building components. It's *composing* them. Sure you'll have something completely new every now and then but you'd be amazed at what you can build without even touching the DOM through JavaScript if you've got the right set of widgets. Best tool for the job.
Sure. Currently we aren't providing something "out of the box". You have to put a crawlable endpoint before our API. This does however work quite well when you're using React, for example: https://github.com/contentful/guide-app — Try browsing the example app without JS enabled. When you're using the API from node and rendering static pages you're not going to have any new problems, of course.
I'm using this for a reference app in a health-related area. I've had some challenges in finding good examples or thorough docs. But, the end result of my first component (hopefully open sourced by June) is really encouraging. Any dev comfortable with HTML can drop this "mini-app" into a web page and see it work. If they know CSS, they can style it to their liking. I think that's pretty powerful but I don't want to make whole sites/apps this way. This works because of my goals for this project.
A closure is a function with references to it's immediately preceding context. In this case (function(j) { setTimeout(function() { console.log(j); }, 1000); })(i) the outer function is the closure that does the trick.
&gt;I'm not going to focus on React specifically. In fact, just in case it would be distracting, we're not going to use React at all. &gt; &gt;We're going to build our own library from scratch that is highly inspired by React. This lets us play with all kinds of ideas with a very small amount of code. This is prototype-quality, of course, and wouldn't scale to large UIs, but using something like React would make it scale. This approach is great, both for teaching and learning.
If I understand correctly, instead of making a call to a local database or filesystem to get content, an app would instead make an http call to an external domain api to retrieve content. Unless I'm missing something, couldn't this significantly degrade performance?
 var ಠ_ಠ = "favorite?";
ಠ◡ಠ
It doesn't work correctly.
web forms, web FORMS, WEB FORMS! &lt;input type="hidden" name="__VIEWSTATE" id="__VIEWSTATE" value="X/mIzGM1Dsrc9a2y63Fpcahi2SUkIVhzvoF8JL5HdgFadqMBD4LXKSi6A0fS1LGkklschd9wB8KfD8x+3AHxJisEj00jxFL2mCRVSAXMJXqmSZumqvaI9luRjGBiWQv0I0r+RUJBVF7TWYk9jj0iie/h0m8fLsNI575OrZkHhK/vrDiwaOSGWGMyT3xUR9BWBUMVJfEs7/iKlOowjCXc7s88VRLLCPi2uVIR0gNLPoVPU0Oy0JU5n2yk7jKr4gfDsJtffQ9tyHqsvJuVYZGZR+AfNBa0E7n2oXHY9xEcnHXvZQg8V2vz72/SsbdudWXIumotXYXmn7GDVPOMLDNf1xa/N1szkhFHA3dW/+sBmc7jYnI+6g8OxGKLpSKhgLZydiw92dzdsaspRMAr8wwYi2i/ws/NLaUxdB9O6JmNA7fKAGEP4EZ56WO5XsFgfytApP4ik5kQkbEvRaaTUGN2k+SYoGD9tIHU6Ok+rALShU/sx6QjBwfkRuSzBIF8hbLbpyZOPmi6Q3N4PY1WxcPGye3G5i3Azf+O1M+/lQcdHo2aNB7Nqn7RpzpOdZai1gp0LSY89Ogm75HqXH/FZMwm3GM90hffTt4VAndJvweL7xJ/xOIV+CeBiztSgA5qjn6anCFNBVaSlXVuHbQXNp5aAWK5ngaHKkuMJY3fvZSuBejyt1Jdk3F95f+rTH10BPs+RW2dvDNzwzlM9+cutxNhXZucMWU/Uw8kwssre+QXEsabz+uXllWk+jKB4Q9QrOsAy51x125gPogAHAtuy0dr9D2bWmguzr7I7py3OOF1t+5ZpTl70kB27YxduSQde5sQuOa4N2drjAibYHdsDbUOQt3BpYqs+YBV3q8iUJjzrcnmfxtUgmHPA4bH/EoziespYY9eSnynTskBKFn1NT/Kfttkk5ZdXCS0VYENPyjnSz1Y7J7Dv3MYQCRHTTgSf46xILcyUH4HtKDRaTozAdCANwk8zVLDU3px58BqM9l6A2kt+SRfPgUM4hvxQWpTmd8x3WSXaQXl9E6pFdxkscYTl8/4XYgx1yqDhWar5pUbcmmqEP7tYJKLefjbPah3aCDdecX0jpqz6dxAYyfgGf9Uqpt9sIcn6JFLu5wPJRGfs/NC6H8GjwseB1QTtoRH71jCqHHHRQ1Gn46M+MfSvhuUfcfla/+5kSPbHYtGksD5uVVgd48HF8kzkB85cH1XvnLd64Q/m7n+cwJHxsAn/1aXQG+VRDSokgwTk3K69SY2uQkiesFgpCBwpVyqvC8RGV2GobilHh+luK4w0dwFWfLQnZ2TbyDL+19a560FhfAPoL5KprgJnQNBPd8BAFMqK83oG6n/806SmaIDI2AZhaPZcjCtI5Hfy/k+8bLNnRYWFxMMSpcWZi7cKa7Ol5yFBWu8kDvWC6Popw6CNjE1R1sQZZtQvebu86oi4tmHWi59ub+XwK2NKTwKfZnsnMbmP5borGYGOTC47pVWsldla/SUF+CbC0TWvdXI0XY2Q103CjRPJBvl8mXpbRvxdK7nFXMO/57qfeZCf6AjvazGkWyqQ/2wKO39n69FhBM9Cl9UJgD3tAJm2tIc+aNnAjCdCJf2HxWI0SSO81OnVXzX2hgOoMmlsTXndm2loilINlkQCMz+I785KHWlzKfIVZfOuI70fZN" /&gt; 
(͡° ͜ʖ ͡°)
（ ͡ಠ ͜ʖ ͡ಠ）
You understood correctly, your service would fetch content from an HTTP API instead of going to disk or a local database. However, here's a few reasons which should make this a pleasant experience: * The API is very fast to respond. It's also hosted on a CDN (fastly to be specific). I just checked again and I'm seeing a very high hit-rate (&gt;90%). We're serving all API responses through the CDN's cache unless a change has been made to the content, in which case the first request is going to take a little while longer. But in general 99% of well-formed requests (those without random timestamps, damnit) are hitting the cache and fastly is reliably very fast to respond there in my experience. I always liked the idea of having a CDN for JSON data whereas most CDNs are purely intended for static blobs like images. There's no difference, of course, you just have to be able to cache and invalidate JSON efficiently. * We very much encourage serving content directly from our API instead of going through another service. We've got lots of iOS apps hitting the API directly. For statically rendered websites there's coglode.com for example. They recently got hammered from hacker news but they took it very well. * The API is able to resolve large relationship graphs of related content very efficiently. Let's say you're querying for a set of IMDB movies and you also intend to display information about related artists, trivia bits, quotes, etc: You can get all the requested information in a single HTTP response which would also be cached on our CDN. So in general: Yes, the latency is higher, but if we're a good fit for a content-heavy use case we should be able to be the only backend you need. We really focus on providing the best service possible by providing low latency, high availability and additional useful features for content delivery use cases (full-text search, single-request related data retrieval, etc). Edit: Here's the public status page with recent Delivery API response times: http://status.contentful.com (there's also a Management API for editing content)
OP here. Can you explain a bit more on what didn't work correctly, so that I could look into it.
I think like it should have been there from the start, I personally hate dynamically rearranging web pages...
Two identical numbers won't collapse into each other.
neat
That video reminds me of [this](http://youtu.be/Xz5Tx7hNR64)
Step through it in a debugger and it will make sense.
One more: * Can an item occupy more than one box (ARPG style)
I'm guessing that symbol takes more than one byte...
Aside from stalking /javascript/new, I look out for blogs that function as newsletters for technologies I'm interested in. Problem is, they wax and wane in activity. For instance, there's [this Grunt blog](http://discovergrunt.com/blog/), and they did a [monthly link round-up](http://discovergrunt.com/blog/category/monthly-best-of/) that was pretty good, except they only did one, and that was back in October. Same for [Angular](http://syntaxspectrum.com/2013/08/angularjs-highlights-week-ending-25-august-2013/), but with August. There are probably some good podcasts to listen to, but I've never been a podcast guy. I think the javascript world moves too fast to have a single reliable stream of information. I hoard links to articles that I'll want to reference later and rely on having a decent grasp of the libraries out there so I can search for more documentation. 
Bad day for it since it's down but http://webplatformdaily.org http://dailyjs.com and http://css-tricks.com
The first version creates three functions that all refer to the same `i` value. Those functions are registered to be executed later, and meanwhile `i` is modified. After the loop finishes, `i` equals three, and then at some later point in time when the timers expire, the three functions each execute, all referring to that same `i` value which equals three. In the section version you are using an IIFE (immediately-invoked function expression) to create the three functions. That adds another layer to the scope chain. Instead of directly referring to `i`, the timeout functions are nested in a function, and refer to `j` in that function. That `j` is a copy of `i` made at the time of the function call, which happened when the functions were defined since this is an IIFE. Both versions exhibit closure, because in both cases a function refers to a non-local variable. The difference is that in the first version, the enclosing scope of all three timeout functions is the same enclosing scope, and so they all refer to the same variable. The second version creates a new function scope for each of the registered timeout functions, so they each have a different "view" of `i` as it existed in a point of time. In other words, the first version is: enclosing scope ^--- first anonymous timeout function ^--- second anonymous timeout function ^--- third anonymous timeout function The second version is: enclosing scope ^--- anonymous function ^--- first anonymous timeout function ^--- anonymous function ^--- second anonymous timeout function ^--- anonymous function ^--- third anonymous timeout function 
well I just spent 2 hours on this game. Couldn't get higher than 256 :/
How is it adding more logic? It does the same thing as data binding, just directly in JavaScript instead of having special syntax to communicate with JavaScript.
This is essentially what the redesign of the build system (using Grunt) at my company looks like that I recently did. It's actually quite effective and very simple to comprehend. I've always had issues with the "split each task into its' own files!" concept because it never really reflected what the build conceptually "looks" like.
Yes. Dark boxes are okay. No, there's no need to drag the box. No, a box per item. 
That's a great idea! You get jackasses in every sub - culture unfortunately. Luckily, in my experience, most devs really enjoy feeling like they are teaching something and I think part of that is a factor in the open mind set in software. OP should pay no mind to that sort of thing but it sure as hell doesn't help our community (where we deeply need more diversity and more people in general) to treat newcomers like that.
ヽ༼ ͡ಠ ͜ʖ ͡ಠ༽ﾉ 
I don't know how to do that. Can you show me with some screenshots. Thank you.
The second version the anonymous functions have all returned by the time the second anonymous timeout functions run right? Isnt' that something unique to closures? Thanks so much for this.
Thank you so much.
http://jsfiddle.net/ms2Mg/
Poorly organized and the colors are wrong but it works!
Sweet jesus its evolving
Definitely not reddit.
yes, its harder than the original 2048. :) Even I could only get to 512.
You should be better about committing smaller chunks of work with better commit messages. Isolated commits with descriptive and short messages allow easy traversal through the git log without having to do a diff on the commit and dig through code.
That's the only thing that I've seen that makes closures interesting to me. Why do people make such a big deal about them? I think I'm missing something.
If the goal was to save characters, and it doesn't matter that it only works in some browsers, all he'd have to do is say something like var $ = window; since elements with IDs are attached to the window scope in some browsers. Then you can just call $.footer
Polymer is very opinionated and strays quite a bit from the web component spec. You're better off grabbing polymer core and writing actual web component stuff.
That's not even it's final form
[Secrets of the JavaScript Ninja](http://www.manning.com/resig/) by Resig and Bibeault is my absolute favourite. 
For anyone interested; I rebooted my system, used WebKit r168728, Chrome Canary 37.0.1990.0 and Firefox 29 (Stable) and threw Google's Octane javascript benchmark at it (only once on each, since cached JS can screw with results). * WebKit: 22100 * Chrome: 21217 * Firefox: 16932 For a comparison the standard Safari 7.0.3 that ships with Mavericks comes in at 15300.
I love the links and articles of http://javascriptweekly.com and http://www.ng-newsletter.com
Thanks a lot!
I thought you were just being snarky but that links to this which is a great tutorial. Thanks! https://developer.chrome.com/devtools/docs/javascript-debugging Not sure how I would have known to search for chrome dev tools though being totally new to javascript. 
Coincidentally, searching for "js debugger" takes you to that exact link.
Ooooo, thanks!
Where's the zip from? Is there an archive anywhere I can download OMG! I don't have many magazines, and I'd love to look through the old code for inspiration!
**THAT'S THE ONE!** I wrote a C version of that years ago in mode 13. It was a straight up copy of the code, with a little function to copy the behaviour of the plot command! Coooool.......
Found one! http://8bs.com/aumags.htm
[Effective Javascript](http://www.amazon.com/Effective-JavaScript-Specific-Software-Development/dp/0321812182). The author was on the [JSJ Podcast](http://javascriptjabber.com/) one week, really interesting. 
They can't be shimmed at all. If they could they'd be being used everywhere.
ヽ༼ຈل͜ຈ༽ﾉ 
thank you.
I use inline SVG a lot at my job and we've dropped support for IE6-8, so I'm lucky enough to be able to use features like getters/setters, `Object.defineProperties`, `Object.freeze`, etc. Definitely makes coding nicer.
React must piss off a lot of people who invested all of that time on the Angular learning curve.
I spend a lot of my time communicating programming concepts to other people and so the _Learn English: English lessons for native and non-native speakers_ website is one which I visit quite often. See [this cool article for one example](http://www.elearnenglishlanguage.com/blog/english-mistakes/everyday-vs-every-day/).
The window object is the global object, so you can just write `footer` instead of `$.footer`
Did not see it. Now I'm ashamed. Thank you, sir.
Another way to consider it is that your second example is equivalent to this, since there's an implicit `var` when you declare function arguments: for(var i = 0; i &lt; 3; ++i) { (function() { var j = i; setTimeout(function() { console.log(j); }); })(); } The self-invoking anonymous function has no purpose except to create a new inner scope, inside of which the variable `i` is copied over to a new variable `j`. Each time through the loop, this new scope is created and a "new" var `j` is defined within it. This scope is inherited by the `setTimeout()` handler via closure, so each copy of that handler has access to its own copy of `i` via `j`. (Note that this only works for value types. If `i` was an object, `j` would refer to the same object instance.)
Props for doing it without JavaScript too. Definitely the best way to achieve this.
Yeah, it didn't mention jQuery once. How many times you have seen that on SO?
Well there's [this](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineGetter), which can be used to extend compatibility a bit. I thought there was also something that works in IE8ish, but I could be wrong.
3 bytes, to be exact. But that's a problem for the compiler, right?
Page isn't loading for me, [here's a cache](https://webcache.googleusercontent.com/search?q=cache:Vo20abj2ySwJ:jlongster.com/Removing-User-Interface-Complexity,-or-Why-React-is-Awesome+). The thing that makes me nervous is the neverending `requestAnimationFrame` loop. It seems like that would be a waste of computing power while the page isn't changing (which is almost all the time). And not only that, but the author creates a good number of functions in every render pass. Sure enough, that post takes up a steady 10-20% of my CPU, even when it's doing nothing. On the React side of things, [this page](http://facebook.github.io/react/), which is performing DOM updates every second and running multiple React components, is at a steady 1-3%. Which is much better – but am I crazy for thinking a ticker shouldn't take up 2% of my CPU?
Concat news perhaps, with the [javascript focus](http://www.concatnews.com/#html,javascript).
http://www.echojs.com/ - though you'll probably see some similar subjects to reddit and hacker news.
I can't find anything about using socket.io with it.
I can't seem to get the css and html to work together though, like it does on your page
This looks pretty awesome. However, does it only access full documents on the web or can we use it to define partials and avoid redundant code in pure HTML and CSS websites? Like: &lt;pre data-src="_navbar.html"&gt;&lt;/pre&gt;
They say imitation is the sincerest form of flattery. I sure hope they are right: https://www.youtube.com/watch?v=IjwSZ5h9Abs
[Doesn't seem to work in IE](http://i.imgur.com/Np2USXo.png), although it's not that big of an issue (pfft IE).
Any critics or ideas for some other tools that can be implemented in JS/PHP are welcome!
Thanks! This looks pretty good and it appears each step has an 'action' function executed when the button is clicked on so I could add custom form filling to that.
Now I feel bad for pointing it out in that manner...
Don't. It was right there, I should've seen it. My bad.
First thought after reading the title: "Someone's going to have a bad day". 
"JavaScript Patterns" by Stoyan Stefanov. 
Look at all those C and C++ web applications ... oh wait there aren't any.
Nice start! The timestamp converter should let the user pick the timezone, though.
i've used [this](http://suprb.com/apps/nested/) project before and it sounds like it fits your use-case.
I think you have it backwards.. Using this method, data-binding is actually more difficult (logically), but there is less complexity and more stability.
That makes sense. I would like to see a component ecosystem with React, npm install component-x, require('component-x'), now it's in your app.
onload and onerror happen asynchronously. In your if statement, all you are doing is saying that when the image loads, wid will become true or false depending on whether the image dimensions are valid. But since image loads are asynchronous, the if statement completes and immediately alerts the value of wid (before the image actually loads), which is initially undefined/falsey. The reason it is false the second time around is that the alert is again firing before the second image loads, but the value of wid has already been defined as false by the first onload callback. Basically, you want to put the alert right after you define wid as true or false in the img.onload callback.
Would be cool if you could create a hook for something like [ExplainJS](https://github.com/bendytree/explainjs) to create those cool code documentation docs.
This is where I got stuck initially, I never learned the html half of things when I went through code academy the first time.
1. How does this integrate with Grunt, or Maven, or other build/project management systems? 2. How does it generate coburtura reports for use in Jenkins, Sonar, and other CI/reporting systems? 3. What deficiencies in the existing testing frameworks is Jest solving? 4. Is it backwards compatible to Jasmine? 5. Painless, but painless compared to what exactly? 6. The mocking thing seems cool, how can I integrate just that into Jasmine?
Author here. 'sup?
see i thought so too... but either i'm not doing it right, or his API doesn't support that. i would guess that whatever you put in the 'action' property just gets called against the Shepherd object, meaning you probably couldn't run any old function there. that property just lets you decide what built in function gets assigned to the button onClick. what you'd have to do is write your own tutorial logic that incorporates calls to the Shepherd.activeTour object, which sounds backwards, but he has the support for that.
isn't angular supposed to be like the way of the future or something? It's part of the MEAN stack and Google seems to be hyping it quite a bit.
ヽ༼ಠ◡ಠ༽ﾉ 
I don't use angular(I use ember), and I think this is good. Everyone should at least try it out (and make an app).
I've seen this before, however these sorts of grid solutions are for never ending grids... in the examples I see that the grid never ends up being cut off. I need something that will jam all my content into X by Y space and figure it out for me with zero gaps.
Source maps are certainly not a solution (currently) to debugging. They make the map between the code you wrote and the code that gets displayed in the debugger more consistent, but they do nothing for the actual *symbols* of the code, which is where all of the usefulness comes in. Basically, source maps are like debugging with GDB, except you have the C source in front of you rather than the ASM. That being said, try it and see if you like it. Personally, I don't write in CoffeeScript because all of its' "good" habits are habits that drive me up a wall (automatic return values being the biggie that makes me want to strangle someone).
Thanks for feedback, i'll add that too as soon as posible!
I don't use Angular, I use _________________, because certain aspects of it are better for me. Here's my contribution to the discussion of this free course. 
I generally use `{{framework}}` with a `&lt;%= framework %&gt;` backend and don't believe __________ is really necessary; retort.
React is usually only used as the V in an MV* app. Angular is a more complete package which can be either good or bad depending on how you use it.
I wrote a super simple grid layout js plugin https://github.com/redronin/gridly This could be a base for your plugin which would have additional logic to handle the # of items retrieved, # of rows and columns you need, etc. Not sure if this helps or not. 
Awesome. I was waiting for this from codeschool!
That's not a shim, that's the definition of how you define getters and setters :) It's impossible in IE8 as it's a syntax error, that's the whole issue.
because I only aim to make an application for chrome, pretty much and nothing else. Also, I don't even know if I will even upload it to a live website.
TL;DR: Use whatever makes you happy and productive. Long version: Use whatever makes you happy and productive. Some extra noise: There are a few edge cases where the optional parentheses may bite you, so if things start behaving weirdly, start using parens. I can't conjure any specific examples, but I believe that there may be some parentheses ambiguity issues around list comprehensions, so watch your step there. The big, A#1 major thing you must remember about writing CoffeeScript is that, in the end, it still comes out as JavaScript. If you keep that in mind, you'll have few issues. When you *do* have issues, check the compiled JS (which is quite readable), and it's usually quite clear what's happening.
Support in Chrome, Safari, Firefox, Opera, Mobile Safari, and Chrome for Android. You're pretty much only missing IE.
Yay ember! Yay angular! Yay JavaScript! Yay tutorials! We all win. 
I love you mom.
Thanks for the heads up on this one! Was this the one dealing with form submission on valid? (3.9) Just tried that one and did run into something pretty similar that we'll work to get fixed. I see 3.8 is a video ( http://campus.codeschool.com/courses/shaping-up-with-angular-js/level/3/section/3/video/1 ), but making sure we're I'm not finding new problems!
Hi /u/zigzackattack , appreciate the reply, however, I want to clarify some things. I want to check the image height width ( for validtion) and if they satisfy the condition, we would go ahead and upload it. The problem I am facing is, I am not able to understand how to store it in variable, If i am storing it in a global variable and then running it, same result comes which is it shows height width for the one selected before. Kindly guide
Use mustache and backbone? I don't see a problem with if/else in views. But if it's something more complex it's probably in the wrong place e.g. use decorators or presenters.
Right -- you just want to make sure that all of your logic that validates and then uploads the file happens after the onload fires. I would do something like this: var _URL = window.URL || window.webkitURL; var wid; function handleFile(file) { // All your application logic should go in here. // wid will be the whether or not the most recent file fits the criteria // and file will be the image file. if(wid) { upload(file); } else { alertBadFile(file); } } function upload(file) { // Do file upload here } function alertBadFile(file) { alert("That file is too small"); } $("#file").change(function(e) { var file, img,hei; if ((file = $('#file').prop('files')[0])) { img = new Image(); img.onload = function() { wid = ((img.width) &gt; 200) ? true:false; handleFile(img); }; img.onerror = function() { alert( "not a valid file: " + file.type); }; img.src = _URL.createObjectURL(file); } alert(wid); });
I'm guessing the site just isn't rendering properly, but I don't see how to actually do anything on the site. [This is what I get](http://i.imgur.com/Nv2EO7s.png) on Firefox 31. Kind of disappointing. Edit: I deleted some elements and managed to start the course, but it seems to be stuck while trying to "check my work". Is this site pretty much webkit/chrome only? Lots of fonts not rendering (and my console is full of errors).
Is meteor really a good recommendation in this case? I don't think OP is looking for a full stack solution
Using Chrome 34 here (on Debian), I got the same as you, and also &gt; Uncaught SyntaxError: Unexpected token &lt; and &gt; ReferenceError: sublime is not defined on chrome's console. Site seems to be useless since nothing works :(
*shit i've been discovered*
Short answer: yes it's possible. The WebAudioContext is effectively a modular synthesizer with a Javascript API. You can generate sounds from simple sine waves, play samples or use the mic as input. Then you can add effects by routing the sound through those modules. For and idea of what's possible, take a look at this [multi-user modular synthesizer]( http://synth-sync.meteor.com/13ezqx).
Does it implement promises?
Hi, can you test again please?
Any chance that you could check it again? I think i've fixed a bug or four.
If you were to master Javascript, you would have no reason or need to use coffeescript. If you had mastered Javascript first you wouldn't be asking this question. Why not spend your time mastering Javascript instead of adding the unnecessary hassle that comes with coffeescript? 
In Knockout if you don't like inline logic in the templates (views) you can instead use a computed observable on the view model (more like a controller). So in [this example](http://knockoutjs.com/documentation/text-binding.html#note-1-using-functions-and-expressions-to-detemine-text-values) you could use the first code example rather than the second. 
jQuery is a library. AngularJS is a framework. You can't compare the two since they are two different things. You can use jQuery within AngularJS because AngularJS is a framework - you can use almost any library within it. jQuery is a library - it provides functions that you can use to carry out some repetitive actions - if your requirements are too small, then perhaps you are better off using [native javascript over jQuery](http://youmightnotneedjquery.com/) I am sorry but this question does not make sense.
Not yet, sorry! Possibly in the near future. 
In angular you already have jquery lightweight - jqLite is a tiny, API-compatible subset of jQuery that allows Angular to manipulate the DOM in a cross-browser compatible way. jqLite implements only the most commonly needed functionality with the goal of having a very small footprint. 
If it's only about images, Monoslideshow supports a filled grid out of the box (group size): http://www.monoslideshow.com/demo
1. The question is not about what is better in comparison of the other. The question is about functionality not possible using one thing or the other. e.g Airplanes and Cars are obviously not the same, but I can't fly with a Car. However, I can park cars in Supermarkets. 2. The technicality about "framework" vs. "library" is completely nonsensical. I reckon that I cannot talk about Dojo because it's a "toolkit", then. A framework is just a collection of libraries working together. How they're referred to doesn't necessarily mean they're incompatible or mutually exclusive. 3. [This site is bullcrap](http://youmightnotneedjquery.com). Of course you might not need jQuery. Webdevs need to stop the hatin' against it. jQuery is created with JS. You can **obviously** do whatever jQuery does with vanilla JS. (That last point is just misdirected anger, this is not against you or anything, please excuse me if I came across as bitchy or whatever)
I used jqLite in the last app I created and I remember it was kind of cool. I missed some of the methods but I think I could work around that. I wonder what really could be useful to have that's not in jqLite though. Can't think of anything (hence the question)
presentation logic is usually fine, right?
It wasn't until MVC became popular in JS that people started calling jQuery a library. For most of its life jQuery has been called a framework and as used as such. I am not pro-jQuery, by the way. I just pointing out that the name game makes for a really stupid argument, particularly when that name game involves the rebranding of a superficial term.
Had some issues with IE9, seems like for boostrap to work, page must start with: &lt;!DOCTYPE html&gt; Now is rendering fine.
If you have what is obviously js in angular views you're doing it wrong. Delegate to a function on the scope. Keeps your view declarative. 
That's a silly conclusion. Mastering JavaScript and using CoffeeScript have nothing to do with each other. CoffeeScript can help you write a little less and faster, so long as you're aware that you're still writing JavaScript.
The point of http://youmightnotneedjquery.com/ isn't to prove that you can do jQuery replacements in vanilla JS, the point is to show that certain functions are **easily** replaceable. So for example, if you are only importing jQuery to use as a selector engine you might not need to import jQuery to do it. The hate against jQuery is because many webdevs import it without thinking about whether they really need it or not.
The first thing I notice is that all the buttons flash when you hover over them the first time. There is a really neat easy solution for this! You don't create 20 images. You create 1 single image with _every_ _single_ image in it (right next to each other). It's called a sprite and looks like this: http://css-tricks.com/wp-content/csstricks-uploads/buttons_sprite.gif Then, you use css to reposition all the images for every button and for the on hovers. It will load instantly and will look very neat :-).
Maybe they made it in Angular.js? ;)
Do you... promise?
Do you have HTTPS Everywhere installed in your browser? I do and found that I had to disable it there for everything to work properly.
Speaking honestly, probably not. Unless you have a particularly niche calculator, it would most likely be outclassed by other online tools such as Wolfram Alpha.
If I understand correctly, your issue isn't with mixing business logic with presentation but with the custom templating and JS-style syntax being added to your markup? If so you might have a hard time finding something to fit your needs with most of the major MVC/MVVM/etc frameworks right now. Angular's [ngBind](https://docs.angularjs.org/api/ng/directive/ngBind) directive might feel a little less intrusive. In my experience [Backbone.js](http://backbonejs.org/) has a cleaner separation between its model and view components than most other large scope frameworks, so that could work for you. And if you'd like to see the opposite of all of that, you should check out React (especially the clojurescript wrapper [Om](https://github.com/swannodette/om)).
Oh, I know (and I've seen some good examples of that). Nonetheless, I've also seen some good chunks of code that are... well... questionable. My main issue against that site is that it drew *way* too much attention and re-ignited the hating against the library (or framework, or whatever you want to call it). I think it's uncalled for because its popularity. "PHP: Fractal of Bad Design" is another example of this. That's just my opinion though.
Why stop there? I can create my own language and dump Javascript.
This is exactly what I was talking about. Good point about the "add just a little stuff into an existing huge project" — if I start without Angular, I should stay away from it if I want to evade a huge refactoring. I also agree with your views on Angular. It's kind of "preachy". I've come to enjoy it, but it does messes up with your flow. I'll check Knockout. Thanks for the suggestion!
Assume I haven't, then.
I see. Thanks guys 
Thank you, this solved my problem!
Absolutely this! I have struggled lots of times with libraries because of this problem. It took me months to understand why I should learn Backbone (or any MV* library). The first thing in docs should always be, "I created this library Y because I was trying to do X". It's like a prologue to your code. I know I can't learn something unless I understand WHY! Why should I learn this thing and not that thing? It's not stubbornness but trying to gain context. It helps with decisions and mapping where each thing fits well. It's utterly narcissistic to ask people spend their hours learning something without explaining to them why they'd need it. It might even help improve your solution by gaining contributors. /rant EDIT: I suggest adding, on the wiki, a list of why each library was created and how it goes about solving a problem. **I'll gild you**!
throw it up on a website. put some ads on the site. see what traffic you get and if it makes any money
Your best bet are the slides, there is a link to them :(
if you think angular has a learning curve, then you should stay away from ember
Or... why people don't understand type-casting
He's part of TC39 committee (ECMAScript) and he did have some influence on ES few years ago (JSON, death of ES4) but is pretty inactive these days.
Okay, "totallymike", if mastering javascript has nothing to do with using coffeescript then how is a noob at javascript ever going to get anything done with coffeescript? Your logic is "totallyflawed". So the trade-off is "write a little less and faster" for having to debug using source maps and using an often [confusing and ambiguous syntax](https://www.google.com/search?num=100&amp;newwindow=1&amp;q=coffeescript+confusion+&amp;oq=coffeescript+confusion+&amp;gs_l=serp.3...63909.64069.0.64244.2.2.0.0.0.0.65.129.2.2.0....0...1c.1.43.serp..2.0.0.2Jzui0xO9_4). Hmmm, I know which one I'd recommend. 
yeah, good luck getting that to work in all browsers though.
this is also why I like Backbone. It gives just enough structure without ever getting in the way of progress.
Or backbone for that matter...
Documentation - The bane of every developers life. Always handed to someone on the team who hates writing documents. Most documents start off as "internal use only" and then get modified for training or external use. There are documentation experts who can develop courseware but most small companies don't bother to invest. If its an open source project it can be even worse. 
https://docs.angularjs.org/guide/introduction https://docs.angularjs.org/guide/concepts Those two pages provide a high level overview of the "Why Angular" and "Why does X work the way it does?". Is that the sort of thing you're looking for?
Ok, I'm just gonna say it, because it needs to be said, and I'm going to say it bluntly: You're getting mad at the dictionary for not teaching you English. Much in the same way the function specific docs provide information but not necessarily context, so too does the dictionary provide you words, but not grammar and sentence structure. You attempt to compare it with other "docs" like "Learn Python the Hard Way," except that's not the official Python docs. That's a book on how to learn it. It's the equivalent of an English class. You're comparing two totally different things with different intents. The docs are NOT a tutorial. You know what is a tutorial? THE TUTORIAL. &gt; (P.P.S. Angular does have a tutorial app, but I haven’t tried it yet. If you’re stuck wallowing in the regular docs, it might be worth a try.) Oh, so you're complaining about something without bothering actually having tried the tutorial you lament is needed. Good to know. Anyone finding themselves agreeing with OP, please go here: https://docs.angularjs.org/guide It pretty much has every resource that OP laments doesn't exist in the docs... except it totally does exist and is part of the docs. As someone else commented earlier, this just seems to be a plug for paid training.
With Angular, you can harness viral APIs with dynamic mashups to design social life-hacks that incentivize citizen-media social platforms. Try doing that with jQuery, son. 
Touche!
Actually, yeah, the "concepts" page is pretty slick!
Actually I agree with "totallymike", I am pretty fluent in Javascript...tried multiple libraries, frameworks, etc... This doesn't seem like it hinders me from maintaining my Javascript abilities. In fact, it seems the opposite. It's like using a higher-higher level language to speed up development. Granted, you do need to know Javascript to write Coffeescript. Sure the language will have it's caveats, but don't all languages? For instance, I'm using Angular with Coffeescript and the generated code seems roughly similar...but the source files themselves are 1/3 the size. Also, the language and documentation seem pretty straight forward, as long as I know what the resulting Javascript functionality looks like. One of the biggest take away's from Coffeescript that I do like is it feels more OOP with classes and extends, which setups the functionality for you to correctly set prototype functionality without having to write the word prototype over and over and over again. And the debugging is actually not that bad. That being said, I'm really just looking for a list of pitfalls and nothing else.
My philosophy is that if you're creating enough elements that you need this optimization, you're doing it wrong. In a typical web app, the JavaScript that doesn't interact with the DOM is rarely the bottleneck. It's all of the DOM manipulation that slows you down. "Kreate" just speeds up the non-dom part. It's analogous to cutting your hair to lose weight. Sure, it will help. Is the difference noticeable? Probably not. Is the change worth it? I doubt it.
Or programming in general. 
Ember supports component creation. Angular isn't as scalable. Since they're not using getters and setters, they have to manually inspect each object for changes to be reflected in the DOM. These things are very significant.
Youtube accounts are free. Why are they using such a slow video player?
I misppoke. You suggest that if you master JavaScript, then you wouldn't feel the need to resort to something like CoffeeScript. At least that's how I read it. Indeed, I believe that competence with JavaScript is a *requirement* for using CoffeeScript, otherwise you won't have a solid understanding of what your code actually does. Take, for example, the different function arrows. Skinny `-&gt;` defines a naive function. The fat arrow `=&gt;` first aliases `this` to `that`, then defines your function. That just doesn't make sense unless you've been bitten by `this` in JS before and understand why it's significant. With respect to debugging, I've never debugged my coffeescript. Sure, I might put a breakpoint into the compiled JS once in a while, but the compiled output is similar enough to the CS that there is very little cognitive dissonance involved with reading the two languages. If you have to debug that often, you might consider improving your test suite. Finally, I won't dispute syntactical ambiguities. In fact, I referenced them in my other post in this thread. In my coffeescript I advocate using parentheses in any function calls more complex than `require 'fs'`, and you should generally wrap list comprehensions with parentheses as well. To counterbalance these syntactical ambiguities, I'd argue that JS has similar ambiguities. Consider semicolons, `this`, `var`, and `===`. To be honest, I enjoy writing in both languages. We use CoffeeScript primarily at work, and I find it to be straight forward and quite productive. For my personal projects I tend to use JavaScript; I find it refreshing, and fun to play with newer JS features, but sometimes I do miss getting to skip some of the boilerplate that CS handles for you. *Edit: Rewrote the last paragraph. It originally only had the first sentence in a less clear form.
Thanks for replying to a couple of people in this thread with the Angular documentation. Comparing it to LPTHW was deliberate to explain why good explanation is worth it's weight in gold (no matter the audience). Good explanation means you never have to worry about the inner workings. You know what it does and why. That's all I need to know. I'll try to use an example: I know using jQuery I can query a `class` without worrying about whether `document.querySelector` is supported in certain browsers. All I ever needed to understand it is: We use `jQuery(".myClass")` to standardize querying classes for all browsers. We could use other DOM methods but we'll risk missing certain browsers. So please use our method to ensure you never have to worry about writing 3-4 lines just to ensure you've covered most browsers. That was a simple explanation covering what it does and why. In short, show us a realistic problem, why the classic approach is wrong/inefficient, how your solution solves it better and finally, the most important part to me, why you went that route. Angular ticks all boxes except the last (although they've done some changes lately to address this). Things I never understood with Angular: why do I need inline scripting/data binding? Isn't that what we've always referred to as terrible practise? Why do I feel like you're hiding something from me? Why do you keep claiming that it's probably because I'm not smart enough? If you can't explain your solution in simplistic terms, I'm inclined to think that you bumped into it by accident. Which is why you can't explain it well enough. **TL;DR**: Devs don't like to feel dumb. EDIT: I've tried various Angular docs about a year ago. They were terrible. I moved to Backbone instead. Obviously they listened to people and improved their docs.
Use backbone + jquery. Angular is stupid to dump jQuery.
My best advice is use a wrapper on Node-Webkit or a PHP compilers and market your desktop app: Node-Webkit https://github.com/rogerwang/node-webkit How to package Node-Webkit (Look for section An alternative way to make an executable file in Windows) https://github.com/rogerwang/node-webkit/wiki/How-to-package-and-distribute-your-apps Different ways to compile PHP/HTML files: http://stackoverflow.com/questions/9046675/convert-a-php-script-into-a-stand-alone-windows-executable
Thanks for the dictionary comparison, I shall use that in the future :) The docs are a reference, just like the MSDN library or the MDN one. Could it use some more examples or details at times? Sure, but it's already very valuable as is. There are actually a lot of resources out there about Angular, besides the official tutorial.
I use none of them. I have played around with all of them but they are, imho, solutions to problems that didn't exist. If I had to choose though, I would choose backbone.js.
Could you elaborate?
&gt; I know using jQuery I can query a class without worrying about whether document.querySelector is supported in certain browsers. jQuery is a library. It has discrete functions that you can use in pretty much any situation. Angular is a framework. The basic difference is that a library works in your code, whereas with a framework, you work within its code. Comparing the two is a false equivalency because one is much simpler and more self contained than the other. With a framework, you must learn how to work within the structure it provides you. &gt; Things I never understood with Angular: why do I need inline scripting/data binding? Isn't that what we've always referred to as terrible practise? I linked you to the page that explains that in your other comment in this thread. It's the [Zen of Angular](https://docs.angularjs.org/guide/introduction#the-zen-of-angular) section. The gist of it is this: Conventional wisdom on declarative code (the inline binding you refer to) is correct. BUT, it's correct within the context of a regular website, not necessarily in the context of an MVC app. Let's say you have buttons which open different modals, right? If you write them as regular webpages in a declarative way, you're binding a lot of onlick events in the HTML, one for every button, and it's redundant and difficult to change all at once. If you're using an MVC framework with templating though, you can make a model of the button to modal relationship, and have the buttons get built by that model. No you're still using something similar to onclick (or ng-click, or whatever), but there's only one of them, which changes depending on the data in the model, and is getting output via a repeater based on that model. You've now removed the major issue with using declarative javascript: the issue of redundancy. But more to the point, this allows you to divide your UI logic and business logic. Your Controller, where you have the actual app logic, shouldn't have to care about things like animations, or transitions, or drag &amp; drop, or anything other than the data end of the application. So using things like Angular's directives allows you to segment that all into the HTML and into directive modules that are separate from your business logic. Understand that frameworks are not one-size-fits-all solutions. The "Angular Sweet Spot" on the Angular intro page I linked to above even admits as much, and advices using jQuery if you're not doing a lot of CRUD (Create, read, update and delete) data operations. Does that help?
hey, author here. I put a few paragraphs at the bottom of the post about my training and an email form. edit: yes, this does mention my training courses at the very bottom. I’m writing about a problem I found and that I want to try to solve for people who are having the same problem. I put my research &amp; thoughts out there for free. 
I have a question for someone with more experience than myself: How could I use Angular along with a backend MVC framework like CodeIgniter?
Yeah but the whole point of building a framework is so you and others can use it to build stuff on top of it. For a complicated framework like Angular, complicated documentation will slow down people who want to use the framework for their projects, which is detrimental to the framework project as a whole.
OC here: This is a little background on the chart: Datasouce: * reddit.com .json api Tools used: * d3js * angularjs * coffeescript * lessjs * git * grunt * jasmine * qunit * selenium * phantomjs * aws * centos * nodejs Tools not used: * jquery About: * This originally started as a proof of concept to create a d3 bubble chart, but has eventually developed into a tool that gives anyone the ability to quickly find any relevant/new/active posts on any subreddit. Features: * can accept any valid subreddit in the URL * responsive layout * tooltips * zooming * panning * domain highlighting from the legend * zoom-type assignment * axis assignment * circle radius assignment
homepage: [webtorrent.io](http://webtorrent.io/) MIT licensed you can also see how is this project progressing on [ohloh.net/p/webtorrent](https://www.ohloh.net/p/webtorrent)
I do, I guess I'll try that. Thanks.
The best things to learn as a programmer is to learn how to read docs. Figure this out, everything else is easier to do. 
backbone with marionettejs and requrejs
Try [CanJS](http://canjs.com). If you use [Components](http://canjs.com/docs/can.Component.html) your logic is in the view model.
I'm by no means a master at angular or JS, but its fairly easy after you watch tutorials on youtube and do a couple online. As someone who's fairly new to javascript and programming I found it intuitive, maybe its the old: "the more you know the more set in your path you become". Anyway, here are a couple tutorials that I used and continue to use for onboarding in case some of you need that extra boost: AngularJS in 60ish minutes: https://www.youtube.com/watch?v=i9MHigUZKEM Treehouse tutorial (they offer free trials): http://teamtreehouse.com/library/building-with-angularjs-and-apis A SO question http://stackoverflow.com/questions/14994391/how-do-i-think-in-angularjs-if-i-have-a-jquery-background?rq=1 AngularJS in 20 min (refresher in case you ever catch yourself derping): https://www.youtube.com/watch?v=tnXO-i7944M
Angular is going to be better with a page that isn't as dynamic (well not dynamic as such, let's say "complicated"), uses a standard set of widgets and will work better when prototyping or letting designers have a go. React will do better if there is a lot of logic in the views, you need your interface totally custom and you want it locked down for engineers. This is why: - Virtual DOM vs Binding (Binding is easier to use for non-engineers but will come with overhead if there is a lot of logic) - JSX vs Templates (your code is in your templates where as in angular it is closer to HTML)
http://i.imgur.com/INBvStO.png
You da man leptons
I cant say which is better for your purpose. What I can say is that I too have a beautiful back end. I decided to go with Angular and it was a journey. I perhaps should have practiced more. I decided to learn as I went after I spent around a week learning. But I learn through doing. I have had to refactor my early controllers several times as they were purely abysmal. My front end is now immensely elegant with some amazing out-of-box UX that people expect from Bootstrap with angular, as well as some impressive directives which help with the enormous data set I am working with. Angular is annoying to debug at first. Often not knowing what it wants itself (Expected 'undefined' still makes me mad today). Two way databinding is very nice. Angular feels familiar. React, from what I have heard, is quite different. My main project is expected to take over 2 years until release due to it's size. Though I will be using for much smaller projects as there isn't much overhead to get it into a project. I personally believe Angular is worth investing time into. Have a play at first. Maybe spend an hour or two converting/creating a web CV using it. It is definitely a powerful tool to have in your belt.
Th e documentation really does need some TLC. You haven't really ragged on Ng either. Merely pointed out that there is a learning curve and that you cant look for much help in the official documentation. There is some fantastic tutorials out there and most things that are beneficial in the long term have a step learning curve.
What's something you can do with a toolbox that you can't do with a swiss knife?
I can elaborate a little on the Angular side, but I can't speak to Ember. Angular uses a $watch function that takes object or array variables. When the values within the object change, for instance if they are bound to a form and the user modifies the form, or if the system performs an HTTP request and updates the object, then the watcher will detect the change and perform the callback function that you defined when you set up the $watch function. The problem is that this $watch function is a Javascript loop that also watches every other $watch definition that you have defined. It's very slow compared to events but the developers usually ignore that because the average user won't mind 60-100ms. The $watcher can take an abnormally long time for very large objects because it has to loop through every property of the object to find the one that might have changed if you want to watch the whole object.
Could you give any details on what your frontend should do?
I do believe having a lot of `$watch`ers in your controller is considered bad practice, and can be avoided most of the time. 
I started with Angular but I'm more of a React guy now. It depends if you want a big framework that does everything (ajax, DI, ...) and enforces you to its constraints, or if you just want to abstract the V (in MV*), ignore the DOM and just code the logic. Also, it's not only about React. Check [Vue](http://vuejs.org/) (personal favorite), Ractive, Reactive, Ripple, Rivets. Edit: a bit biased but thats how I feel now - But Angular is a great framework overall. Just know that you will end up coding "angular" rather than "javascript".
Sometimes it's unavoidable when you have lots of controllers (more than 10?) on a single page, but then I would argue that Angular might not be the best tool in the shed. This is coming from my current project which was set up before I got to it.
Side note, thanks for explaining =&gt; and this/that scope. I saw documentation that said it was scary and no one clearly explained it.
Consider it comparable to reddit. Reddit is built in pylons so it has a python MVC backend with javascript on top. I doubt I would need to accomplish anything more complicated in javascript than anything reddit has to do.
Buckwheat covered Angular. Here's more info on Ember.js components: http://emberjs.com/api/classes/Ember.Component.html I think that page documents them reasonably well.
What's the biggest web app you've ever worked on? If you've worked on a large web app, where you want to enforce consistency of user experience across many pages, I think you'd change your tune. Ember and Angular aren't right for every application, and you can stitch together smaller libraries of your choice, or just make everything yourself, but sometimes there's no point in reinventing the wheel.
From what I've read, I feel like components can be compared to directives, no?
So aren't you answering your own question saying you don't really need a framework?
I think part of his point is you wouldn't need things like classes and extends if you just mastered javascript (which is why even in es6 mr. Crockford is already saying class is gonna be one of the bad parts :p)
I don't know, that's why I'm asking :)
While I think coffescript is a silly perversion of pure and total beauty, this is a very reasonable and well thought out reply. The only point I'd make is there is nothing from stopping a beginner from using coffescript. In fact I'd assume they would if Ruby was their first language and they were just starting up now.
Well there you go :p
So that's your answer then? I should not bother with a framework? It would still make sense tho to get bower and junit up and running tho right? Then just stop there? I have no need to compile js or css preprocessors, that is all handled by my backend.
Well I believe if only smaller tasks require javascript, I wouldn't use a framework, and possibly skip the tests. Bower is always good to learn though, since it handles dependencies.
Miss Ritter: Peter, don't make promises you can't keep. Peter Parker: But those are the best kind. 
You dont really need a framework for the M and the C once you get going. For a more complete development pattern with React you can look at Flux which facebook uses with it.
Even if webclients are just big UIs/views the MC* parts is still responsible for fetching data and making sure the right part of the UI gets updated with the new data. Here is an alternative to the MVC pattern which uses React and is more suitable for large UIs https://github.com/facebook/react/tree/master/examples/todomvc-flux http://facebook.github.io/react/docs/flux-todo-list.html
If you feel like approaching it from an audio engineer's perspective, you can check out my project *audiosynth*: http://keithwhor.com/music/ ... generates .WAV files dynamically in the browser. You'd need to write your own wave functions for different instruments. I'm also doing a complete rewrite soon (that will probably end up as a separate project) that will be easier to modify / work with (... I was playing around with some obtuse ideas about protecting my data structures when I originally wrote the API).
&gt; jQuery is a library. It has discrete functions that you can use in pretty much any situation. Angular is a framework. That doesn't mean the two can't be compared. Again, my point isn't about how one is used but **why** should I use it. That's the author's point too. Framework, plugin, library, API etc all go back to the same question. Frameworks actually need this more than libraries (personal opinion). Libraries are more flexible compared to frameworks. Like you pointed out, frameworks need one to adapt to them. So why should I adopt a certain way of thinking? That's what initial angular docs missed. I have to give Angular some credit. Most people really hated their initial set-up where they failed to document the framework properly. They listened and made some effort. But for a framework. However, it's a testament on what most documentation misses. I bet if Angular came out with this documentation, it would easily been a hit. It lost most people to Ember &amp; Backbone as a result of this. **TL;DR:** Angular fucked up in the beginning.
There's nothing wrong with making money. As long as you're not being a dick about it (spam, sketchiness). He pointed out a clear problem with most documentations etc.
React is always better for all the same arguments that functional programming is always better (whether or not you agree with this, the arguments are the same)
These are exactly my concerns with angular - but at the same time you get some really good support because a bunch of other people are doing things 'the angular way'. It's kind of the same feeling of rails vs sinatra. Also: thanks for linking to vue. I've seen it before but taking a closer look at it, it may be exactly what I need. 
Still kinda late for a product produced by one of the largest tech companies in the world.
Even though the backend is the mvc, you end up still having to represent the models in your frontend after converting from JSON/XML. (for any moderately complex UI) You can pass around POJOs but having the Model layer in the frontend(in addition to the backend) is much cleaner and easier for others to collaborate on.
So this is a recommendation for an MVC framework like Angular?
I skimmed the comments and didn't see this mentioned: Angular has a limit on the number of bindable elements (2000). After that the dirty-checking becomes too heavy. React batches changes using the Shadow DOM. Ember batches changes using the Run loop. So if you are going to have a lot of bindings, you may want to consider React or Ember over Angular. Angular will eventually be using Object.observe to get past the 2000 limit, but this isn't backwards-compatible with older browsers. I also think that batching changes is better for mobile devices, which Object.observe does nothing to fix. 
&gt; rails vs sinatra So Angular is rails and React is sinatra?
This made me smile :) Nice job.
&gt; Angular has a limit on the number of bindable elements (2000) I think if you are going to build Gmail that is a concern but for most web apps that are not js heavy it really isn't.
&gt; The documentation is shockingly amongst the worst I've seen, ever Totally disagree. It's at least as good as MSDN. But it's documentation, not a how-to. React's docs do appear to be better. It also appears to be simpler. I don't know if that's a good thing or a bad thing. 
&gt; I am familiar with many high level architecture patterns with my backend knowledge so I believe I should be able to tackle all those things Downvotes because frankly you sound a bit full of yourself between this and: &gt; The backend of my web application is a thing of beauty. Really? A thing of beauty? That's a bit much. Every piece of software I've built I've looked at it two weeks later and thought, yeah, that's good but I'd improve this and this and this other thing. 
&gt; http://www.reddit.com/r/javascript/comments/25mc76/the_infamous_angular_learning_curve/ To be honest that article mostly goes over how bad the docs are (they aren't), it's just the author is trying to treat the docs as a tutorial, when they are not. They are meant to be a reference not an educational path for learning Angular. If you get MVC and good software design patterns you'll like Angular. The whole framework was built with good practice in mind, DRY, separation of concerns, dependency injection and more. It's not too hard to grasp and all the things mentioned above are things you can get comfortable with in a few days. I teach an Angular course (I'm not selling it and won't even mention where) and by the end of the day most folks there have a basic understanding of Angular and can be productive with it. In terms of Angular vs React , as mentioned Angular is a bigger framework because it's the full MVC cycle on the client, React is really just the V (View generation). Now Angular also supports data binding, client side routing and more and in many cases you may not need all that. So it really depends. We have a large web application that is mostly server side code and knockout on the front end, but looking to transition to angular.
http://www.reddit.com/r/javascript/comments/25mc76/the_infamous_angular_learning_curve/chiokme For why that guy is full of crap :)
&gt; Every piece of software I've built I've looked at it two weeks later and thought, yeah, that's good but I'd improve this and this and this other thing. At this point I've fixed all those things, just not the js :) edit: But fair enough if you feel that way I don't think my intention was to brag I just really do feel that way.
I am one of 2 JavaScript/front-end developers on a large-scale Java web application. Up until very recently we used jQuery for all our front-end work. I pitched [KnockoutJS](http://knockoutjs.com) to our tech leads and they liked what they saw. Here is the core of my pitch: * KO separates model and view concerns resulting in cleaner code * It focuses on two-way binding magic and nothing else (faster to learn) * It plays nicely with what we have already so we may introduce it incrementally * It supports IE 6+, FF 2+, etc. (we have to support IE 8+, FF 3+) I think it's worth taking a look at in your case **especially because you don't need to invest a lot of time to be productive**. It doesn't sound like you're trying to write a SPA (single page application) so Angular, Ember, et. al. may be overkill. Like you said, you're not trying to build Gmail. If you're just doing simple things like [this](http://jsfiddle.net/FKYYY/), Knockout may be enough. *Edit: Fix a typo
That's very interesting thanks for the thoughtful advice. I will definitely take a look.
I agree and I thought I made that clear in the first comment. However, batching changes to the DOM is still a great idea when thinking about mobile, and Angular doesn't have an answer for that (yet).
I didn't say *I've* mastered javascript. That's probably not a good term as I don't know if anyone can say they've mastered any language unless they literally never learn anything new. I guess "perfectly fluent" would be a better analogy. Anyway.......... The point is there are always already a number of ways to do exactly what people try to "simplify" with languages that transpile to javascript and those native approaches are probably actually better (and they are at least not _exactly the same approach__ everytime which is what these tools are there to do. Compile one statement like 'class' to a direct mapping of some pre-defined operation in js.) In some cases inheritance should work one way, while in others it could be different (That flexibility is the true power of javascript. It's pretty hard to have *many* different approaches to inheritance in say, Java). You lose a ton of flexibility to have someone else generate code that is already perfectly doable in javascript, when you use these tools. Here is that es6 video (worth checking out) http://www.ustream.tv/recorded/46640057 and here is another Crock video where, iirc, he is doing some inheritance without ever touching the prototype http://www.youtube.com/watch?v=3WgVHE5Augc (which I guess he now considers prototypal inheritance to not be that great. I disagree). Anyway, it all comes down to the fact that these tools generally give you a more specific way of doing things but in doing so you gain some overhead and lose some of the power and flexibility of javascript (which again is it's real power). It's interesting....you see the same form of argument with frameworks like Backbone vs. Angular. I guess it's baked into the culture on some level. "Do you want to make *every* decision because you are always certain of what you are doing or do you want to let some other guy make some of your decisions for you but incur the penalties that come along with that", etc, etc 
Entirely agree with this. I always say if I look at code I wrote two weeks ago and can't say that it looks like shit then I am not being true to myself. You always have to be your biggest critic.
I'm inclined to disagree a bit here, on a few points: Angular code doesn't have to function as a single-page application- in fact, you can have multiple angular apps running on the same page. It's geared towards writing small, reusable components, which means it works just as well in a CMS as it does a single page application. There's an extra hoop to jump through to import data from external libraries, but it's relatively painless once you understand it. Also, keep in mind that adding a little bit of code is the easiest part of development- the harder part is 6 months or a year down the road when a bunch of little things have been added on and they have to be maintained while more little things get tacked on. Angular was designed around helping you write testable, maintainable code (keeping in mind it's also possible to write crappy code in any framework or language). In my humble experience with Knockout, Backbone, Angular and jQuery applications, Angular was the easiest to work with on a large scale once you got familiar with it. I wish I could have added Ember to that list for a more apples to apples comparison, but my current project started during the many months of crazy instability and haven't had a chance to properly play with it since it stabilized with 1.0.
Looks pretty similar to [superagent](http://visionmedia.github.io/superagent/)
No, I'm not trying to make a direct comparison :) I'm just trying to express what the community and looking for help online feels like. 
Apparently so! Thanks for the link. I've not heard of superagent until now.
Well it depends, do you want to use Angular's single page app functionality (ie client side routing). Angular Core doesn't include that anymore, so you could include only data binding and services on a per page basis. So really I look at it in two ways: * Use MVC server side routing and host angular in your tradition server side views. You get dynamic JS awesomeness on the client, just not page transitions, each page is a new load. The upside is that because it's a full page refresh, there is less of a chance of a javascript memory leak , or I should say a smaller chance it would manifest in a bad way (its still there). The downside is server side transitions are slower. To be pragmatic though, a huge % of websites use server side page loads and its just fine. * Use Angular's client side routing completely and only have a few server side views. IE route on the client, use the server side view engine to load the initial page. Your server side is then delegated to mostly serving up json data. This is very much the way the MEAN stack works. It's great, but the downside here is you lose SEO. I know there are solutions to pre-render your site for SEO and redirect bots there, but I have no idea how well it works. The upside is that it's a nicer experience and you can really divide the work up. A front end dev lives completely in angular/client side world. While server side folks live in REST api, database world. For full stack devs like myself it doesn't make a difference, but some people are very fussy about only living on their side of the fence.
I agree but.. Angular is indeed meant for larger/complex applications, otherwise its complexity is a bit too much for the standard web app.
Also I always think you should have a roadmap in your head of what you'd improve next. By the time you architect and build a perfect piece of software there's probably some new tech that's come along that will do X better in your app. 
Thanks. I agree. I know what sprites are. I was probably focused too much with the JS and didn't consider using a sprite.
I don't know what you mean about cluttering the browser tab history. 
While this thread is far down, I think it actually makes one of the most important points: are you making a SPA or not? I use Angular every day and it is most certainly centered around SPAs, with some kind of API backend. The beauty of Angular is that it lets you completely divide the frontend and backend. First you build an API with all the data you will need. This API can also be used for mobile apps or integration with partners. You then build your own site as a SPA on top of the same API. It's absolutely fantastic to see it working in this way. However, is this is not a structure you can or want to conform to, I think the learning curve is very steep - especially if your paycheck depends on it. :)
js is really crazy stuff :D hehe just kidding!
&gt;Does this sound achieveable? Sounds like a good way to go about it, especially if each page has a specific need for a different type of js experience. It's not really a SPA per se, more like an multiple Angular Apps on different pages. You could do it this way as well (this is how I would structure it). Attach the ng-app to the html document of your layout page. Then on each page surround a div with an ng-controller attribute. This way you can share services among different controllers(pages), but still have reusable parts. For example lets say you want to dynamically load data from a restful api. If you build it as a service and set it up in a central app (the layout page would include a reference to your angular module) then you can just have controllers ask for each piece and it works and they all share the same code, very clean! 
When asked this question, the guys at React tend to compare React with Jquery. I use React and I love it, but my favorite library is backbone. The documentation for backbone is some of the best I've seen. The source code is even well documented and amazing. One of the great things about the React/Backbone combo is that both libraries are agnostic, and accomplish a few tasks very well. Neither tries to do everything. Backbone is really easy to learn, but their 'views' suck. Overall using React for the templating makes me happy because I actually like using html syntax, weird, I know? But React *shouldn't* be used alone, although it could be used that way.
AngularJS is changing drastically in version 2.0, which I believe is expected end of the year or early next year. I would recommend learning React now and coming back to Angular once it hits 2.0 (or the beta). You'll certainly reuse some knowledge from Angular 1.2 but many of the confusing aspects are changing (directives, routing, templates, and more).
Not having logic in the views defeats the point of using a client-side mvc framework, which are mainly built for web-apps. If you don't want logic in the views, then you don't need to use javascript.
I like backbone, I also like learning how to build stuff on my own. Backbone, more than anything, enforces the use of a prototypical object with preconfigured ajax. It's just like a brick you can use to build a foundation.
This makes sense to me! Basically instead of multiple page reloads, etc... I can build in the nice angular functionality to each "section" of the website, using the server side routing to navigate between them. Thanks for the suggestion about the inner wrapper to be able to share between multiple apps. &gt;For example lets say you want to dynamically load data from a restful api. If you build it as a service and set it up in a central app This sounds like exactly as I would do it. I found a suggestion earlier about just building the server-side app as a restful api that only returns json objects. Then use angular to make the calls to get / display / interact with those objects. Sound about right?
Haha! I've already actually seen that project.It's pretty cool, my teacher even showed it to me in class! I was even looking at the code to see how it's done. Definitely going to take away something from it! 
Thanks, I'll surely check it out. I had a skimmed look at it and the effects didn't work for me on the first try, but I have to get home to play with it more and check the code. I do need some help with what I'm doing so I might send you a message. I'll be doing most of the work today and tomorrow (I'm from Europe , so It actually means I'll be staying all night and during the day heh) So I don't know if you will have time. I'll probably send you a message sometime in the near future if I'm struggling somewhere, of course as I promised I can throw a little money for friendly advice and help if you are interested!
awesome, I stand corrected, didn't had time to play around with it. I'm gonna start coding something now. Do you have some time at the moment ? EDIT: I actually just checked out the wikiaudio.org, are you the person that runs the website? I've actually seen it while searching google for somehting simillar and that's where I saw how to do "simple" drum pads, as in the ones in your first tutorial! Awesome to see, developers that I'm already looking up to, replying to this post.
No, I can't see that it's complex. It's really simple, and really ridiculous, akin to people asking why `"dog" &lt; console.log`
You sir, are just doing it wrong.
That's the *best case* number of bindable elements. Your performance can become terrible with way less elements (hundreds) if your app doesn't happen to be in the happy path of what is easy to render for angular.
I'm currently learning angular and finally starting to summit the learning curve after about 2 weeks of bewilderment. It is very weird. It's unintuitive and a whole new way of doing things. I'm starting to enjoy it, and I think it will save me time in the long run over backbone (I havent tried react yet). But it's not something worth learning just for one project. I think the investment will only pay off if you are building front end SPA's on a daily basis, like I do. I dont know much about react but it seems like it would be easier to pick up. And since you dont sound too interested in doing a lot of front-end in your life, you should do what is easiest for you right now.
First of all: is it a full AJAX site or are you rendering HTML on the backend and doing full-page refreshes?
So are you even running server side code? (apart from the api). Your login, error logs etc are all done through the api? Thanks!
Yeah I know.. It's just that for 'traditional' MVC on servers anything sent to the client is a view. There's no logic in HTML (obviously, it's just a piece of paper), but in a JavaScript MVC a 'view' can contain logic, which is theoretically impossible on the server. So we have a choice. We can further separate ourselves from the HTML, or we can fully embrace the HTML and hack it and integrate it completely with our logic. I biased towards views logic, and I use react so I'm not plagued with the view-logic concerns that people have when they use other templating engines (JavaScript or elsewhere). 
I am definitely not building a SPA, just like reddit is not a SPA, I am quite happy with my architecture in general. Just want to clean up the js (and maybe learn a useful tool).
Full page refreshes. But I might want to build some parts that are more js heavy.
Doesnt sound like you need a full framework like angular. I would stay away unless you enjoy being frustrated and confused. What kind of js widgets are you building? chat box? graphs? have you ever tried backbone? it's small and quick to learn.
It sounds right as rain. I've used this exact model to build a few small apps, [one of which is live](https://www.gtgamefest.com/). It's a fantastic model even as a full stack developer because it allows for such clear separation of concerns and makes the dev process really clean(at least for me) * Build out the requirements for your app from business logic, expose endpoints and set up auth(if necessary). * Write the visual aspect in pure client-side code, consume your endpoints and provide some auth interface(again, if necessary). I love it. If you have any more questions about Angular or using it with a RESTful stack feel free to ask, and check out [this neat interface](http://learning.matthewfoxx.com/) I wrote for [AngularJS Learning](https://github.com/jmcunningham/AngularJS-Learning) -- a big github community repository for angular resources. 
This x10. IIRC, something similar occurred with the pre 1.0 Ember docs - people no longer bothered to go back to the documentation even though it'd improved drastically. For somebody with experience working with larger-scale apps in other languages, Angular should be pretty intuitive with it's various features. Makes you wonder how many devs shun the docs just because they saw "transclusion" or some other term while skimming and didn't actually take the time to read up on the (relatively straightforward) functionality said terms are describing.
they understand that. that's why it ends with selling you a course on angular.
That sounds oddly sexual.
Not really produced as much as helped along. Last I heard there were 40 full-time Google employees working on Angular but the project isn't owned by Google, its community driven (unless something major changed within the last 2 months that I missed) 
IMO, having read the angular 2.0 proposals and their examples, I feel that the new version is *less* intuitive. What's a "viewhole"? Why all these specialized, seemingly redundant annotations for components? Many of the team's ideas are compelling (eg. the new http module), but the implementation of Angular 2.0 resembles enterprise Java a little too much for my tastes.
I'd love to see a follow-up on /r/javascript on what you go with and why. Happy coding!
I was just about to post a blog article I had written, but this sticky sure gives me a lot of pause. After spending 10 minutes reading this thread I can't really get a consensus about when it's OK to post your own material and when it's not. It's kind of sad, really. To avoid being flamed out of this sub I'll refrain from posting it...
Not a fan of MSDN though... I put going to MSDN to find something akin to opening up my old COBOL books and going to town on a mainframe UI. I find Adobe docs easier to navigate and MDN a hell of a lot better (if I were asked to rank them...) Trust me, I've attempted to use MSDN for everything from MSSQL to VB6 to C# and I can never find what I need in a reasonable time period and their formatting makes me want to shoot myself in the head. Also, it rarely seems to want to work in anything not produced by Microsoft. If Angular docs are "as good" then that's not saying much... Personal opinion.
Yeah there's probably better examples out there. Crap, I totally shoulda said MDN (Mozilla) that's some solid documentation. 
Like how you configure the route first and then fire of methods on it. If discuss had promises, it'd have a leg up on Superagent :)
&gt; resembles enterprise Java a little too much for my tastes. OT : This is probably my biggest fear with all the libraries and direction people are headed...
Perhaps this has to do with the team's familiarity with the language. Hopefully the resemblance won't progress any further, as the team has already taken great pains to make Angular 2.0 modular and easy-to-use. However, I've kinda become a React convert now - some of the ideas behind it are especially compelling. :)
I haven't dug into either yet... But I really need to and I'm heavily leaning on React. I was a little scared at first that it's a Facebook I initiative, but if anyone can make a site where a few million moms can't break it horribly... React makes sense to me just reading about it and I really just need to dedicate some time to building things with it to check it out.
Some of the logic in the views could be ng-ifs, ng-shows, etc.
Between HN, Reddit and EchoJS I'm pretty much covered for JavaScript news. http://www.reddit.com/r/node+nodejs+javascript+jquery+webdev I also read these sites via RSS: http://dailyjs.com http://npmawesome.com http://tympanus.net/codrops/ And get email newsletters from these sites: http://nodeweekly.com/ http://javascriptweekly.com/ http://sidebar.io/ http://www.smashingmagazine.com/the-smashing-newsletter/
&gt; But it's documentation, not a how-to. If anything, Angular's "documentation" is more a how-to than documentation. I can never find information about what kind of parameters something is expecting and what those parameters might look like.
If you are ever using more than 2000 view bindings at once in any html5 app, angular or not, you are doing it wrong. Stuff like long lists should be paginated behind the scenes, regardless of framework, and deep watches on huge objects is just lazy.
Honestly Facebook has been absolutely *rocking* the open source javascript game. And React is relatively simple to build with, it's a really small API and pretty straightforward. The biggest thing to wrap your head around is the one way data flow and even that is really simple
&gt;Since [Angular is] not using getters and setters Angular 2.x will use Object.observe. http://blog.angularjs.org/2014/03/angular-20.html
Here's the context: https://www.youtube.com/watch?v=ItOY14prFOU At LA Hacks, this was on repeat for a while, and I thought it would be a funny project to make my computer play this every time I need to commit.
Great resources, let me add a few that really helped me. Stick to the free stuff, pay if you like it: https://egghead.io/ New from codeschool, sponsored by google: https://www.codeschool.com/courses/shaping-up-with-angular-js
saying Sinatra is too restrictive makes no sense at all, but I agree his Rails/Sinatra comparison don't really add much to the convo
Nah bro. I dump all browsers and write my own. 
Something about being a model controller, I assume.
ng-Book. Not the only book out there, but the only one that I've spent time getting very familiar with. It really helped clear up questions that the Docs didn't answer very well.
&gt; saying Sinatra is too restrictive makes no sense at all personally I find [Cuba](http://cuba.is) simpler to use.
just wanted to say that there are many solutions to this problem that exist already (bindonce, angular-once, etc). There are plenty of directives that allow you to do background paging for long lists and tables too.
I'm not saying all apps need 2000 bindings. I don't even know a specific use case other than Gmail or a spreadsheet style app. However, to say that no app should ever need 2000 bindings is like saying, "No one will need more than 637 kB of memory for a personal computer". 
Bindonce is good for "bindings" that don't need to update but it does nothing for dynamic data. As far as I know, there is no way to batch arbitrary DOM changes with Angular, yet. If I understand you correctly there batch DOM solutions for "long lists" and "tables". (Don't take this the wrong way, but can you show me a link)
Ah! I see. Great point. At first sight, it really doesn't look like that, though. Do you have any example on GitHub that illustrates this point?
Considering the metric tons of amazing shit that people put up on Github for free, i'm going to go with no. 
Yes. But this doesn't make it non declarative. 
Then I wouldn't really recommend Angular. If all you need is a bit of js utility here and there, Angular will become quite cumbersome.
This was extremely interesting. Thank you.
Wow, it's very neat to hear you were shown it by a teacher. Thanks for letting me know! Glad I can contribute. :)
He gives this link and describes it as what they use to teach vector programming to new devs: http://jhusain.github.io/learnrx/
Thanks, I must have missed that part.
&lt;troll&gt; emacs &lt;/troll&gt; Look at sublime text ( http://www.sublimetext.com/ )
**There is no best.** Seriously. Pick one you like. * [Sublime Text](http://www.sublimetext.com/) is my favorite because it's lightweight, and cross-platform. * [Atom](https://atom.io/) is OS X-only, but will soon be available on Windows and Linux. * [WebStorm](http://www.jetbrains.com/webstorm/) is available on all platforms. Also, please remember that Javascript and jQuery aren't two different languages. jQuery *is* Javascript. 
May I make a suggestion that you consider using CodeIgniter carefully :) We use CodeIgniter for a few projects at work and I have used other MVC frameworks. After a while you start to think ... I wish code igniter had ... I wish code igniter did ... etc.
Yeah, I downvoted you because I don't feel comfortable with anyone feeling happy about his code.&lt;/cynical&gt; Take the downvotes easy :)
Another tip(that you may already be doing): Since you are still in planning/designing phase you could get your back-end team to spec out your endpoints now (once they've finished design of course). If you know what endpoints you'll have then you can just [mock the back-end](https://docs.angularjs.org/api/ngMock/service/$httpBackend) until they've actually coded it. Then you can work on front-end and back-end dev simultaneously without having to worry about conflicting views of the data! P.S. if you're going to go with a full RESTful model check out [Restangular](https://github.com/mgonto/restangular), it provides a more complete implementation of RESTful operations and data modelling for angular than $resource IMO
Atom compiles fine on Linux. You can install it from [AUR](https://aur.archlinux.org/packages/atom-editor-git/) if you're on Arch. Not perfect yet but it works. I've tried it on both Arch and Ubuntu.
[emacs](http://www.gnu.org/software/emacs/)
i use dreamweaver..but can you guys provide the benefit of using sublime? sublime doesnt show the live site in the split view so its really hard to constantly know what are the effects
Hahaha, I haven't seen this troll in a while. You meant vi of course ;) I used Notepad++ for a long time but switched to sublime text in the last 2 years. I'll never go back. It's fantastic! I have heard good things about Atom (on mobile so I don't have the link handy). That is OS X only and I believe you need to have mountain lion or higher :/
&gt; just not the js :) This is kinda like saying "60% of my app is super awesome"... uhh, ok. I wonder why you spent the time to make the server side all pretty but completely neglected the client side. I don't think the downvotes are deserved though. Reddit is weird with the downvote button. 
Highly recommend going through the tutorial. Rx has a steep learning tool and this set of exercises does a decent job of shifting your mindset to grok it more effectively.
webstorm.
I use CanJS and Im happy with it, it offers or features that can Ang/Ember have without loosing JS style coding, Observable objects or values make it simple to control application state with can.mustache (and now can.stache) the dom will be updated automatically I think canjs has great future because it grows in every single version minor or major.
His reduce function is wrong. [1,2,3].reduce(function(a, b) { return Math.max(a,b); }); returns `3`, NOT `[3]`!
I've been using Webstorm for 8 months now. For big projects, I would totally recommend it. The built-in syntax checker, inspect code functionality and integration with JSHint are invaluables.
I'd add brackets to the list. I've been using it lately for some node.js and front-end only projects and it's quite good.
Currently, in all Chrome verisons, a request for desktop notification permissions can only be triggered from a click event. This was done partially because they weren't sure what to do in the case of an iframe requesting push notification permissions. They ultimately decided this would be a really weak way for anyone to attempt phishing/harass users. Glad they implemented things the same way FireFox does now. Pretty much everyone including me had a hack for body.click to ask for permissions.
I want to troll by saying notepad, but when I think about it notepad is pretty good. I like Nano and even kate but if we're being honest with ourselves vim is number one. For the tasks mentioned by you I use jet brains. 
Just a note, this is no longer entirely accurate. Bluebird is still quite impressive but it has inspired the rest of us to get our act together. The latest performance improvements of when.js are very impressive. (RSVP maintainer here)
No problem! One last tip if you do go the way of fleshing out your api in the design process [consider apiary](http://apiary.io/how-it-works), though I haven't had the chance to use it myself it seems extraordinarily convenient in that it lets you "wireframe" your api collaboratively and then build documentation as well as mock the server based on the wireframe.
&gt; 40% of my app is definitely not handwritten js. See, you think that's a good thing. I'm betting there's Submit buttons all over that thing. Submit buttons suck for user experience. The trend these days is to make as much stuff XHR as possible. 
(Post author, here) I've heard it before... But I thought it would be still a better option to stick with the official seed project for introductory purposes... I'll consider mentioning it eventually. Thanks for the feedback :)
This seems pretty helpful. Arguably this will be the first thing I have built a backend for beyond some entry level programming courses, haha. I need all the help I can get! I like the idea of planning the API well before ever coding... similarly to how we are spending probably way too much time on the database before going any further, lol.
I'm pretty sure that's the point of Masonry. It's not concerned with the correct order of items, just concerned with making the cleanest grid possible.
Sure, for example [this](https://github.com/mallzee/angular-ui-table-view) directive, or [this](https://github.com/webux/ux-angularjs-datagrid), or [this](https://github.com/Hill30/NGScroller) one to name a few. These directives will dynamically create and destroy DOM nodes according to the user's scroll position in the viewport. The only dirty checking the digest has to do are for the visible nodes.
Yeah semantic html really sucks.
Also supports coffeescript: https://github.com/ngbp/ngbp/issues/48
What version of IE? Can you open the developer console by pressing F12? How is this page organized? Frames, iframes, or other? Edit: More code is better, of course :)
IE 11. Some users have 8, 9, or 10, I'm sure. F12 does open the console. Here's the page itself. index2 has the javascript. This was created years ago before I worked here; I just changed index2 to have the javascript. &lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;Price Sheets by Zip code&lt;/TITLE&gt; &lt;/HEAD&gt; &lt;FRAMESET rows="7%,93%" frameborder="0" scrolling="no"&gt; &lt;FRAME SRC="index2.html" name="top_frame" scrolling="no"&gt; &lt;FRAME SRC="index3.html" name="bottom_frame"&gt; &lt;/FRAMESET&gt; &lt;/HTML&gt; **Edit**: Here's the javascript: &lt;center&gt; &lt;FORM name="guideform"&gt; Zip code: &lt;INPUT type="text" id="guidezip" /&gt; &lt;BUTTON onclick="zipOpen(); return false"&gt;Submit&lt;/BUTTON&gt; &lt;DIV ID="zip_filename"&gt;&lt;/DIV&gt; &lt;/FORM&gt; &lt;SCRIPT&gt; function zipOpen() { var files = [ "D\\41001.pdf", [ //K-Div "single_files\\K-Div Pricing.pdf", //the file "46701", //the alias ], [ //L-Div "single_files\\L-Div Pricing.pdf", //the file "49013", ], [ //A-Div "single_files\\A-Div Pricing.pdf", //the file "46001", ], ]; //note: must use "\\" for a single "\". or replace "\" with "/" var i, j, entry, search, zip = document.getElementById("guidezip").value; function openFile(url) { parent.bottom_frame.location = url; zip_filename.textContent = "File Name: " + url; } zip = zip.replace(/^\s+|\s+$/g, ""); //trim any leading+trailing spaces zip = zip.replace(/^0+/g, ""); //trim any leading zeroes if ((/^[0-9]+$/).test(zip)) { //make sure input consists only numbers if (zip.length === 5) { //make sure zip code is exactly 5 digits search = new RegExp("\\b" + zip + "\\b"); for (i = 0; i &lt; files.length; i++) { //find in file entries entry = files[i]; if (entry instanceof Array) { //entry with alias for (j = 0; j &lt; entry.length; j++) { //find zip if (search.test(entry[j])) { //zip found openFile(entry[0]); return; } } } else { //entry without alias if (search.test(entry)) { //zip found openFile(entry); return; } } } //alert("Zip code is not found."); window.open("https://www.google.com/maps/search/zip+code+" + zip); } else { alert("Zip code must be 5 digits."); } } else { alert("Zip code is not a valid number."); } } &lt;/SCRIPT&gt;
Thanks for replying, that is true, I was using dream weaver and it did not show the gradient letters which were shown on chrome, so if i use sublime, I will just have to install an extension for live design? Do programmers just open an actual browser window and refresh it when coding ?
Don't mess with compat modes. Use this meta-tag to force IE to render in standards mode (even on intranet): &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; 
&gt; var files = [ &gt; "D\\41001.pdf", &gt; &gt; [ //K-Div &gt; "single_files\\K-Div Pricing.pdf", //the file &gt; "46701", //the alias &gt; ], &gt; &gt; [ //L-Div &gt; "single_files\\L-Div Pricing.pdf", //the file &gt; "49013", &gt; ], &gt; &gt; [ //A-Div &gt; "single_files\\A-Div Pricing.pdf", //the file &gt; "46001", &gt; ], &gt; ]; Trailing commas, this might fix it: var files = [ "D\\41001.pdf", [ "single_files\\K-Div Pricing.pdf", "46701"], [ "single_files\\L-Div Pricing.pdf", "49013"], [ "single_files\\A-Div Pricing.pdf", "46001"] ]; 
then, all, and race. Pretty much it.
If I put that in, the search will work once, and then not again until I refresh the page. What could be causing that?
Oh, those are in there because there are multiple zip codes. I just took them out here to save space. Sorry for the confusion. &lt;SCRIPT&gt; function zipOpen() { var files = [ "D\\41001.pdf", "D\\41005.pdf", "D\\41011.pdf", "W\\47995.pdf", "W\\47996.pdf", [ //with aliases. contains file, then alias(es), K-Div "single_files\\K-Div Pricing.pdf", //the file "46701", //the alias "49001", "49002", "49269", "49328" ], [ // L-Div "single_files\\L-Div Pricing.pdf", "49013", "49022", "49408", "49450" ], [ // A-Div "single_files\\A-Div Pricing.pdf", "46001", "46011", "47388", "47394" ], ];
how about `.allFail` and `.spread`? also, `.deferred`?
Not sure, but at least you should at least be seeing the same issue in other browsers :)
I agree with you when you bemoan the lack of context. Then you end up with a marketing pitch that says "get a discount" if I share my email address. What's a "discount"? A dollar off on a $2000 course? $100 off on a $101 course? Practice what you preach, preacher.
&gt; [ // A-Div &gt; "single_files\\A-Div Pricing.pdf", &gt; "46001", &gt; "46011", &gt; "47388", &gt; "47394" &gt; ], Still a trailing comma right at the end of the array :). 
Still nothing lol IE sucks. It works perfectly in Chrome.
This is good to hear. Would you want to add or remove any methods from the [Pimp api](https://github.com/zeusdeux/pimp#api)? 
That angular-seed was written, mostly, two years ago. Google has updated guidance for project structure: https://docs.google.com/document/d/1XXMvReO8-Awi1EZXAXS4PzDzdNvV6pGcuaF4Q9821Es/pub It should be noted that *yo angular* starts you off on the wrong road for anything other than ToDo or HelloWorld. Check out https://github.com/cgross/generator-cg-angular for a generator that matches the most recent guidance. edit: italics
Yeah, I'd noticed that. The hand-rolled implementation of Array.prototype.reduce() that he has you create returns the reduced value as a single-element array instead of a literal value. I assume that this is so one can continue to run Array functions on the result in big chains, unlike in the ECMAScript 5 standard. Not sure if I dig it; I'd rename the array-returning version into something like reduceInArray() or similar to avoid mix-ups with default behavior. Less terse, but also less confusing.
There are no workarounds for what you want to do because the fact of the matter is that on the vast majority of mobile devices you cannot: 1. Play more than one `&lt;audio&gt;`/`&lt;video&gt;` at a time. 2. Play media without direct physical interaction from the user. You can get around #1 by using the Web Audio API to fetch, buffer, and mix the audio yourself; but you will never get around #2.
I'm fine with vanilla ES6 promises so I'm probably not the right person to ask ;)
Nice troll :-) But we all know that [ed is the standard editor](http://www.gnu.org/fun/jokes/ed-msg.html) PS: I love SublimeText.
I really like this answer. Arguing about what is the best editor is a huge waste of time when instead you could just be learning how to be as efficient as possible in the editor you like best. Personally, I like Sublime. I have my reasons for it, others may have theirs, but to claim that editor X makes you more productive than editor Y is absurd. Its the craftsman, not the tools.
As someone that just got started working on my frontend (new to Javascript), I started with Angular and got loss in it. I went through the ReactJS tutorial and it immediately made sense to me. In short amount of time, I was able to create a feature on my site that was previously hacked together in jQuery. For now, I will continue using it until I have more time to dedicate to learning Angular.
&gt; new to Javascript
You basically have three options: * Accept that the order of elements won't be sorted accurately visually. - Your original situation. * Accept that there will be gaps in between items which aren't the same height. - Using Isotope fitRows * Enforce a fixed height for each items and possibly set their overflow to auto to allow scrolling of the content inside. - Change your CSS
Javascript: The Good Parts
&gt; Javascript: The Good Parts Whats the definitve guide like?
Effective JavaScript is very good at explaining best practices, in fact I would recommend it over The Good Parts.
Another user suggested that tag. When I put it in, it looks like it should, but only one search works. After that the page needs a refresh to search any more.
Well, the standard way is `Object.defineProperty`, which can be partially shimmed using `__defineGetter__` + `__defineSetter__`. But those two functions extend support so little, and remain so far from a complete polyfill, that I tend to think it isn't worth it.
I never read JS: The Good Parts, but I agree that Effective JavaScript is very good at explaining best practices.
The Definitive Guide is extremely detailed (as you might expect from the title). It seems like it would be very good for an experienced JS programmer. The parts that I could understand were very good (lol), but a lot of it was definitely over my head. I took a break from reading it, but I plan on going back to it when I understand the fundamentals a little better.
[Scopes and Closures](http://my.safaribooksonline.com/book/programming/javascript/9781449335571) by Kyle Simpson, finally made closures clear for me. Goes into the details of how the JS JIT compiler runs and allocates scope. Great to read before an interview.
Very fun! I actually got really engrossed for some reason and finished an entire match vs a cpu. Nicely done!
I am in the same boat hence my apprehension towards providing a shit ton of methods. Just want to provide whats needed and what can be built upon. :)
Don't forget Resig's Secrets of the Javascript Ninja. http://jsninja.com/
Right, those are mainly for smooth scrolling, but what about when you have a DOM element that contains 10+ bindings. When it is in view with those directives it is still dirty-checking each visible binding and updating them individually. Batching those changes is not possible(afaik) with Angular's current dirty-checking. I think Object.observe will fix this by being able to chain the observables but I don't know enough about Object.observe to say that as fact.
I am very curious what you are using .race for, it is widely seen as useless.
Looks cool. Is it available on npm?
You do know about MVC, don't you?
Honestly, anything except Dreamweaver. Pick one you like. Discussing which text editor is best is like discussing theology.
Nitpick: React doesn't use Shadow DOM, but instead a virtual DOM. The W3C Shadow DOM and a virtual DOM are quite different in what they're trying to do.
Actually, thank you for that. I was using shadow dom as a generic term. I will stop doing so.
This game is really impressive. I'm bummed that the author won't open source it. You can get insight into the client code just by viewing the page source though.
Want to start writing code without *reading a god damn tutorial on how to use a text editor*? Stay away from vim. Use vim if you understand it and want to use it. Some people prefer more accessible GUI editors because they just want to write code, not learn vim commands.
This comes up in these discussion as the obvious classic, and it deserves to be, but I can't help feeling like the style comes off as... old-fashioned? We've come a long way since it was written six years ago--which is a lifetime. Between Backbone classes and IIFEs, almost _all_ of my functions are declared with anonymous syntax. Mobile development by itself is essentially a new field. 
This. By our own /u/homoiconic
Read the definitive guide and stop asking questions.
Try brackets - it's free. I'm using it instead of SublimeText for javascript and html.
I second this, you can find this book and his other ones on GitHub here is the link. https://github.com/getify/You-Dont-Know-JS
I would recommend [Code Complete 2](http://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670/ref=sr_1_1?ie=UTF8&amp;qid=1400289933&amp;sr=8-1&amp;keywords=code+complete+2) as many fine JavaScript books have already been posted here. Steve (and the hundreds of works he references) teaches you about software construction and best practices, along with functioning inside of company as a developer. Great info. Great reference.
First, we've been able to do cross-domain requests forever, sending data anywhere we want. Think about it. Even creating an "img" element with some data in the query part of the url would send that data and that could be done 10 years ago. Second, you could pass through data, using a client as a proxy, without WebSockets too. Again, AJAX would work.
I skimmed through it a bit, but this video is from 2013 and a lot of the stuff it's talking about is available in stable chrome's devtools now. e.g. in order to find out which functions aren't being optimized and why, just take a cpu profile and [hover over the yellow exclamation indicator](http://i.imgur.com/pF2uJ9o.png)
For sure. "2000 things" is definitely a low number of things to be working with if you're doing, say, a particle system. But that's not what angular is for, it's for building UIs. And you're not going to find a use case for more than 2000 bindings that is going to be something a user is actually going to be able to absorb. If you're building an app that has a heavier component like that, then go ahead and do things the oldschool way. But to go with a crappy and difficult approach to UI when the difference is sub-millisecond is a ridiculous case of premature optimization.
I add this before my doctype: &lt;!--[if IE]&gt;&lt;![endif]--&gt; as described here: http://nicolasgallagher.com/better-conditional-classnames-for-hack-free-css/ This is in addition to &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; 
a kindle.
Here are [some examples](http://wiki.whatwg.org/wiki/Navigator_HW_Concurrency#Example_use_cases).
And if you're reading the code in your IDE?
None, they should be electronic
This book is so good it's unreal.
Shoutout to the homie Raganwald
Yes, you can grab it here https://www.npmjs.org/package/likely.js
I don't think you understand race, it doesn't work like that. The `.any` method works like that. `.race` behaves like `.any` by accident 99% of the time though. So you use one method once where you misunderstood what it does and it's as useful as `.then`? 
Cool! Didn't knew about this one, I'm pretty sure my custom-element declarative element (https://github.com/kentaromiura/custom-element) will work with it too, I'll try it now :) EDIT: it works indeed: http://jsfiddle.net/kentaromiura/cDgQ6/ My opinion: It's nice to have a transpiler that still includes the polyfill, so people can share their native components on top of what bosonic provides, allowing to move stuff from one project to another, if/when webcomponents will be integrated as native elements inside browsers (like in canary) we shouldn't face the problem of being bound to a specific framework/polyfill so the main issue is being future-proof enough to be completely transparent for the today developer. Reading the bosonic documentation it seems to me that they've approached the thing the right way, I'll look more into the transpiler later as I've no time now. Nice!
From the list of polyfills you include I think the polymer-element component should work in your project too, I created mine because I wanted to use components without the shadow Dom polyfill which causes some problems since it cannot wraps all the node reference, and some libraries could have troubles with it, because you can get the unwrapped element instead of the wrapped one and vice-versa, Mozilla x-tag already provided a polyfill w/out shadowdom ( I think for performance issues ) but they don't have a declarative way to declare components.
I wanted to follow up on my street map submission with how to display data on the map. As a side note, I'm trying to improve my writing, so if anyone has any helpful tips, I would greatly appreciate it.
Nope, it has the exact same issue.
This could be really big. Aside from some little issues (bugs, command lag, subpar AI, etc) this really brings a nice RTS to the browser. I'll definitely keep my eye on this in the future.
When I read this book I had already been programming with JavaScript daily for about 5 years and though I was the shit. This book book proved me so wrong. It was a major eye opener.
Care to elaborate ?
Either this framework is extremely important for everyone to know or it's extremely dense to learn because I've been seeing tutorials for it all over the place. ([This one](https://www.codeschool.com/courses/shaping-up-with-angular-js) is pretty cool. It even has its own theme song.) 
&gt; Yes imo. I love crockford but it's time to stop sub setting the language because people might do stupid shit. This isn't limited to Javascript as some of the pitfalls Crockford details are pretty universal (*eval* is bad, using break on your switch cases). The only reason people "learn [to] get by with" is: a) they're new to development, and any language is going to be intimidating, or b) they come from a classical OOP background, and prototypal languages go against what they're used to. In other words, developers who don't like JS talk disparagingly about it because they can't wrap their heads around it; Crockford's book tries to alleviate some of this.
Is it worth it to learn it now, while 2.0 is in the works and may change a lot of things once it's released? Would it be worth it to wait?
true, unless of course you need to programatically change the style based on component props/state. Such as defining width or display:none etc. But that is not what is going on here.
There are a few reasons you are seeing more tutorials. The obvious: AngularJS is popular. Many, such as myself, are starting new projects and realizing the benefit that frameworks like AngularJS, Backbone, and Ember provide. This leads us to seek out new tutorials and documentation. While the official tutorial covers some of the basics, it doesn't go into enough detail for some users. Additionally, yes, AngularJS has a lot to offer and is pretty dense. While the documentation is good, a few extra tutorials go a long way to solidifying that knowledge. 
Would hard CS classes help? What I mean is, I've heard angular's structure can be pretty esoteric. It seems to be founded on html directives which are an attribute type I'd never heard of before angular.js. Correct me if I'm wrong but isn't the entire system kind of made up?
For someone who's been learning Backbone, is there similarities between the two? Should I look into Angular or keep working with Backbone?
It looks very impressive so far, what would you use this for tho?
The demo is really impressive. The source is a little scary, and uses some awful patterns. e.g. All of the [dialogs](https://github.com/andersevenrud/OS.js-v2/blob/master/frontend/dialogs.js) and [GUI tools](https://github.com/andersevenrud/OS.js-v2/blob/master/frontend/gui.js) are thrown into single huge JS files... looks like a maintenance nightmare, especially for a project as significant as an operating system.
You could set it up as a work station and access it from anywhere without any VNC software, just saying.
I wish he showed more code and outputs to better highlight CoffeeScript and the urge concepts he was talking about. That's usually my biggest gripe with any of these "Future JavaScript" talks from all the conferences.
I've been using this so far for storing user preferences in local storage. I tried to keep the API really simple. It degrades to temp storage because I didn't want to deal with cookies.
I think it tries to help them avoid the things that are different and that may confuse them but then again I wonder if those cases would even read such a book. The other group is just people who have a project where most of the code is backend but they once in a while get thrown into javascript and therfore they hate it (this is probably still a decent sized group). However, as time goes on I think it's becoming more and more important for these groups to filly understand javascript as well. In my opinion this can only be accomplished by using it regularly, in its entirety. Even the things you mention that are discussed in the good parts that everyone agrees on as being iffy have their uses. Here is a great video on such things in this exact context http://m.youtube.com/watch?v=MFtijdklZDo
Yes.
This started a few years ago as a .NET coding competition, but I wanted to port everything over to javascript. I'll relax the GitHub auth scope in the next push. The site is quite raw, but I wanted to get it playable before I started going crazy with feature pushes.
Yeah, I watched it, and I still don't see any real benefit to using something like *eval* (which I still think should never be used). He lists three benefits of eval: &gt; Predictable scope If you need this, you probably haven't done much Javascript development. Still, even if you don't know, a console.log(this) inside your function will tell you your scope context. &gt; Global scope He says this is the security counter-measure for 3rd parties running eval'ed code -- which is tantamount to security through obscurity. Since global scope is *window*, I could drill down through its children until I get the proper scope I want (if I were so inclined); so, there goes your safety. The only time this would be safe is if you're referencing a variable from inside a closure, but see #3 as to why that's bad. If you really want your context to be global, *call()*, *apply()* or *bind()* with the first param being *window* will set you into the global scope. &gt; No closure optimization concerns A nice benefit of having your context set to *window*. Now, if you have a closure with parent variables you want to reference, you're just SOL. I hate to rant on *eval* since it's a huge pet peeve for me, but there are other ways to do the same thing that *eval* wants to do that I prefer using the workaround than taking the performance hit just to do it with *eval*. As for type comparisons, sure there's no problem on most projects to just use == instead of ===, but when optimization is a concern because you're building a browser-based game or a site targeted for mobile, x === 2 will perform better than x == 2 since the browser won't have to perform a comparison for each type under the hood. I don't really care about *with* one way or the other; it's just like skipping a break on a switch case -- if you're careful, do it, but beware of the pitfalls.
 function findImg(urltofind, allowPartialMatch) { var imageTags = document.getElementsByTagName("img"); for(var i = 0; i&lt;imageTags.length; i++) { if(imageTags[i].src == urltofind) { //full url provided alert("ERMAHGERD!"); //found it return imageTags[i]; //return the img dom element } else if(allowPartialMatch &amp;&amp; imageTags[i].src.indexOf(urltofind) != -1) { alert("An image location containing "+urltofind+" has been located"); return imageTags[i]; //return the img dom element } } } findImg("dickbutt.jpg", true); You can use toLowerCase() on both sides of the comparisons if you want to ignore case. Edit: of course, this is making an assumption that you're looking for images displayed using the img tag. You might have meant links to an image, in which case, replace "img" in getElementsByTagName("img") with "a" and ".src" with ".href". And if you don't actually care where, and just want to know "if at all", then it's just: if(document.getElementsByTagName("body")[0].innerHTML.indexOf("dickbutt.jpg") != -1) alert("found"); Aaaand there's also background images, which is a whole different ball game.
Curl and grep will probably offer the simplest solution.
debitWithdrawalAmount = 9000000; withdrawDebit(); Lost it all every time. =(
How long until the registrations are open? :)
Learn it now! 2.0 has a lot more performance improvements coming down the pipeline and even if the structure changes I don't think the patterns will change too much. It doesn't take long to get going either. Dive in pm me if you or anyone else wants a start
I don't know what `any` does, I'm just going by the standard ES6 promise spec. Given an iterable of promises, race returns a promise that resolves to the value of first promise in the iterable to fulfill. In my case I don't really care about the resolution value, I'm just using it as a signal. How do `any` and `race` typically differ?
I don't think Angus's intention here is to say "here are some of the things in javascript that people say to avoid and here are places you should be using them". The intent is to say the main reasons anything is forbidden in a language is that people may use them in inappropriate situations and therefore we create these hard and fast rules about the language. However, he is on a team where he considers everyone to be an expert on javascript and thus when a team mate "breaks a rule" he can be guarantee his cohorts understood the gotchas and reasons why people warn against things and had a reason for deciding to use it (rather than working around a language feature). The idea is: is the dev breaking a rule *because* they know the concerns and they are irrelevant, or just because of ignorance? The more we force people to actually learn the language rather than "I know some j query" the less we need to restrict it and lose some of its power. I think his opinions are generally noteworthy is this comminity.
Several people have commented about this and I'm splitting it up into individual files :) I'm using vim and several plugins to make it very simple for me to navigate around.
I originally did this to make GUI applications for managing my servers.... one thing led to another, and this is the end result :P
I do, but not an active poster :) I can safely say I'm somewhat a Reddit addict :P
The closest you can get is using an Iframe or something like this (i guess) https://github.com/jterrace/js.js
I have actually done some experiments loading OS.js standalone on a Linux distro using Webkit and X11... like a thin-client (or full OS for that matter). I have a video of this on my YouTube account... allthough the footage is very crappy due to the computer I used at the time :P
Cool! &gt;...and your done! Rinse and repeat. "you are" or "you're" not "your"
Theoretically yes, the software development ideas/principles and the programming basics. Practically/technically no, they're completely different languages in their usage and syntaxes. So unless you want to code server back ends (doesn't seem so to me), you should get a generic JavaScript programming book.
You like read my mind.... I was thinking of doing something similar.
Then you should do it :) I had so much fun doing this! But I wont lie... there have been some sleepless nights and times I just wanted to rip my hair out :P
logic and brackets
Wow, this looks great. It would be really interesting to see the window system implemented in WebGL to see what you could get the performance like.
Thanks! I've been thinking about this myself.. would be a fun project :)
No, if you're interested in learning JavaScript, you need a JavaScript book. And if you really don't need to buy one unless you like physical books - JSBooks (http://jsbooks.revolunet.com/) has plenty of great books. I'd recommend starting with Eloquent JavaScript (http://eloquentjavascript.net/) - it has a pretty cool interactive console that doesn't require installing anything. 
https://coachgordo.files.wordpress.com/2014/04/escalated.jpg
Indeed!
What about Caja and CSP-type stuff? I wonder if you could weave them together into something interesting?
Next trip to NYC, let me know and I'd love to buy you a beer and hear about your inspiration. This is so cool!
Does getElementsByTagName work in all browsers?
Flash of unstyled content on the demo page, not cool! Including CSS async is bad!
Make it happen man! Also, in the mean time, I noticed that you're using top/bottom/left/right position on windows. You should probably use translate because it's faster (http://www.paulirish.com/2012/why-moving-elements-with-translate-is-better-than-posabs-topleft/)
Too bad I live in Norway! hehe
It probably is much faster. I'll look more into it :)
Caja sure looks interesting. I've actually not heard of it before... will check it out!
Yep, has been around for a looong time =)
Unfortunately no. Java and JavaScript are similar like car and carpet are similar. If you're looking for some basic hands-on practice, codeacademy has some pretty decent tutorials to get you going. Good luck and happy coding!
Please keep us updated. If you ever want to write up your design, I happen to study a specific type of distributed computation (related to mobile code) as a hobby and would love to give feedback. Ever read up on the ambient calculus created by Luca Cardelli?
Sure! Just follow me on github or twitter (@andersevenrud I normally post when I come up with some stuff). Cool. I have not -- but will make sure to !
Yes, that is a problem. Issue #1 is one of the fixes for it after the initial load. Other than that, one of the other solutions right now seem to be including a small snippet of JS on each page to hide the content until Jr. loads. But, this is a small problem that I expect will be solved very soon. Jr. is what I would call "beta".
90% of the languages are the same, in the sense that a programming language is essentially control flow and algorithms and both Java and JavaScript are strongly inspired by C, originally. But some advanced patterns are different (inheritance for objects, scope, etc.). More importantly, the uses for JavaScript and Java tend to be completely different (stand alone application vs front and some back-end web development). But as a new programmer, you could pick up C, C++, C#, Ruby, Python, Lua, JavaScript, Java, PHP and probably a bunch of other and learn useful things for all the others. Even significantly different languages like Erlang would teach you useful things you can use in JS!
It took me a while to find where the footer was coming from. It might be better to add the path to `footer.html` as part of the `Master Top Global Root Base Special Parent Object.... thingy`.
.
Just FYI Unity doesn't use Javascript. They have something called "Unityscript" Which is a weird neutered version of javascript. 
Strange, is this new? I was working with Unity maybe 2 months ago and they had a good library of javascript tutorials along with it,
I've also been working on a 3rd party type of web app, so thanks for suggesting caja. I'll check it out too.
http://media.tumblr.com/tumblr_m4mw154CPr1qitwt9.gif
Well, that's the thing: most developers who use *eval* and stick to == do so out of ignorance. Like I said before, on most sites, this concern is trivial; however, if performance is important (it almost always is for me), *eval* is evil, and relying on the crutch of the == becomes a concern. This is why Crockford makes these suggestions in his book; it serves as a conduit to move a developer from just dabbling in jQuery to becoming a full-fledged Javascript developer as the book identifies the pitfalls of developing in JS. If you want to break them, knowing why you shouldn't but doing so after a cost-benefit analysis, then by all means do it; on the other hand, developers should be cognizant of any issues that may arise with implementing "the bad parts."
Somehow i thought of this.. https://www.youtube.com/watch?v=hkDD03yeLnU
If it's that difficult to learn, it has failed as a framework. Adding a layer of abstraction should make things easier, not harder.
Nope. They've never conformed to the ECMAscript spec. See: http://wiki.unity3d.com/index.php?title=UnityScript_versus_JavaScript
I remember someone once saying: Car is to carpet what Java is to Javascript.
Pretty impressive! :P
Just going to take this opportunity to spread the word of FirefoxOS. All apps are written using HTML, CSS, and Javascript. Is this the future? No idea, as I'm not that experienced in the business. But I think it's exciting. Little more on topic: you can actually make FirefoxOS apps run on Android. Just make a FirefoxOS app, and then anyone with Firefox for Android can use it.
Even better: being able to work with data you can trust to have the properties you expect. 
Everything below is just my biased opinion: 1. For the purpose of broadening your knowledge - yes. For making money - not so much, at least not yet. 2. Last time I checked the performance wasn't great. Native apps are faster. 3. Personally I would love to see native apps being built with ruby. I love javascript but not in the least for it being kind of horrible in it's design. Ruby is great, C# is cool as well, Java 8 will be about as cool as C#. But I wouldn't use Javascript where you actually have a choice. I still can't quite understand why js became a popular option for backend business logic implementation.
&gt; Create a path lookup syntax ... Unfortunately, now we've introduced a new API for object traversal. Introducing new APIs for fundamental operations has to be done carefully, and I think path lookups don't quite strike the balance. No reason is given for why :( This struck me as the best option if you're going to be doing this kind of thing a lot, and there are a lot of avenues to explore here. Not just "this.that" but object querying or selection syntaxes. The stuff at the end seemed like interesting thought exercises, but not something I'd actually use.
I'd agree with the first two points. I've recently (a month ago) worked on a prototype for the BBC using mobile safari for a home screen faked app for demos and honestly mobile implementations of Javascript engines are too slow. Because of UI blocking, animations and the things that make native feel native are choppy. When the engines improve (as I'm sure FirefoxOS has due to its business model) I think they will be viable because (hitting on your final point) everyone knows Javascript. It's not the nicest language but it is easy to use. The more developers you have developing for your platform the more money you make.
From my personal experience not many people actually bother to get into the less obvious aspects of the language as prototypes, scopes, closures and such. While it's not really needed for developers who work in the scope of a good framework, it make hard to find a good mid/senior dev. But ok, I might be biased because I am really butthurt of ssjs. 
Wow! didn't know that bit! That's awesome.
Wouldn't this render in quirks mode since there is no doctype on the initial load?
Completely agree with you on #3. I absolutely love Ruby. Unfortunately I don't get to use at work :( On the plus side, I am excited that there's something such as Ruboto in the works, which allows you to use Ruby (JRuby) for Android apps. 
^ Exactly this. I was one of the many people who hated javascript just because I thought it was only bad design and undefined behaviors, so I just stuck in the backend zone. Then a day at work I was asked to hack a big component of our main engine entirely written in javascript, rewrite it and improve its functionalities... so I studied it and I felt in love after some weeks. Javascript is really powerful, has a lot of way of doing things and some are not intuitive mainly for those, like me, who were mainly working with oop languages. After you just learn how to seriously use prototypes and closures you just instantly mindblow. To get on topic, at the moment I think the low cost of using phonegap is still making it preferable against xamarin (that has really strange prices for its licenses) and something like rubymotion. I would suggest to invest in it. In the worst scenario you still would get a lot of useful experience to become a strong web-dev and a very proficent javascript senior
**Jr** Information: Author: xeoncross Description: Jr. the static, static javascript site generator (you should see this) Main Language: JavaScript Number of Forks: 0 Number of Watchers: 6 Number of Stars: 6 
well there are some problems in your code. one of them is in the last if statement: else if(choice1=="paper") { if(choice2="paper") { return "paper wins"; 
Exactly. I don't think I have ever run into this situation at work.