I'm not familiar with Fiddler, are you not able to use vanilla javascript in the console? If you have access to the document as an html string, eg: '&lt;html&gt;&lt;body&gt;&lt;div&gt;&lt;et&gt;stringrpg&lt;/et&gt;&lt;et&gt;rpgstring&lt;/et&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;' Then, if the string is stored as the variable html, you can use html.replace(/&lt;et&gt;(.*?)rpg(.*?)&lt;\/et&gt;/gi, '&lt;et&gt;$1$2&lt;/et&gt;'); Which gives: "&lt;html&gt;&lt;body&gt;&lt;div&gt;&lt;et&gt;string&lt;/et&gt;&lt;et&gt;string&lt;/et&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;" It looks fucking hideous, but all it's saying is "find all et tags with the characters 'rpg' and replace their contents with everything but those characters". Although that will only catch one instance of 'rpg' per tag. Let me know if you need to catch more.
If you're tracking time on site, then pretty much any good analytics script should suffice. Google Analytics does this out of the box. Are you saying you need something more robust? I'm not sure I'm following, but it *seems* like your over complicating things. 
Some videos on Monads from @drboolean (twitter) https://vimeo.com/105300347 https://vimeo.com/106008027 Hope they add a little more to your understanding. 
This problem could go away if Microsoft would let people install IE11 on older versions of Windows. Chrome runs fine on an ancient XP laptop of mine and it's easily faster and better than IE11.
His series on frontendmasters.com was enlightening.
As a novice Ms Pac Man player but who played the original in video arcades as a kid, this was really well done.
how do you make it go?
This one is worth checking out as well https://www.youtube.com/watch?v=AvgwKjTPMmM. It is quite dense, but even if you don't understand the implementations, it is great to see how these abstractions apply to JavaScript.
That's true. My personal code won't be affected much by the API changes. The dilemma is that I *really* want to start using v0.12 right now because I like the changes!!! But the source of some external libs I'm using will need some major refactoring prior to the next, next release (0.13, 1?). I'm just impatient and don't want to have to worry about multiple projects with different react versions. First world problem.
&gt; document.getElementsByTagName('et').forEach getElementsByTagName returns an HTMLCollection, not an array. HTMLCollections don't have a forEach method. That's why you have to write something like this: [].forEach.call(document.getElementsByTagName('et'), foo); If you want to turn a pseudo array (NodeList, arguments, etc) into a real one, you have to write something like this: var a = [].slice.call(arguments, 0); With ES6, you can use the spread operator for that: var a = [...arguments]; So, you could just write: [...document.getElementsByTagName('et')].forEach(foo); For what it's worth, Dart's DOM API fixed that. All of those list-like things are actual `List`s.
Yes. main.js, line 77. var verifier = eval("(" + verifierScript.innerText + ")"); `innerText` *sigh*
I've written about this, and walked through the creation of a monad: http://aeflash.com/2013-06/monads.html This is the video that made them click for me: http://channel9.msdn.com/Shows/Going+Deep/Brian-Beckman-Dont-fear-the-Monads
Those rules are for pac man, not ms. pac man :)
Excellent video, thanks for sharing. At 0:26 there is the key to grasp the `bind` signature, reducing the whole thing to a simple concept: function composition
Not sure if this is helpful at all but you could also have a look at some compile2js language, like LiveScript/CoffeeScript and make small functions by applying currying and function composition, then have a look at the source code to see how its done in pure javascript. I learnt alot by doing this. The bottom line is that javascript is more like Lisp than C. When you get over this you will learn why some things are done the way they are in javascript.
I've just made a look at the source, yay. This code would obviously fail on my review. Overly nested functions -&gt; 11 levels of nestings in one function OMG :) Loose equalities everywhere, antipatterns for type checking everywhere. But i don't want to be harsh, i can see that there's great amount of time invested into the implementation, but the quality of the code could be better, at least for my taste :)
It always bothered me that the view of a state is not loaded while the states resolves are not finished yet. This is my attempt to go around this. Please share any thoughts. Thanks!
No I didn't know them, they look great !
Thanks ! :D Please feel free to make a more formal code review (I don't know how it works in detail but it should be possible on GitHub) I will take care of it in my next iteration. I didn't spend that much time actually, I had a working prototype in a 3 hour train trip and then modified it a little bit over time to fit my needs in the software I used it, so yes, that definitely has to be improved.
First, i would advise to use a good IDE. My favorite is WebStorm, but it's not free in general, but a free trial is available. I would suggest you this IDE, because it has real-time Linting built in (JSHint + JSLint). Enabling linting would reveal a bunch of antipatterns in your code, i bet. And also, you can set up a more strict version of JSHint to enforce better quality. Also, this IDE has a good "Inspections" functionality/feature which can be triggered before commiting, and the results can reveal other "possibly harmful" code in your source. A free alternative could be Sublime with plugins (e.g JSHint plugin). Another advise is to keep your functions **DRY**, **small**, and **clean**. DRY means "don't repeat yourself" -&gt; if you use the same exact thing &gt;twice in your code, then you should **refactor** and **reuse**. small -&gt; one function should make one thing, another logically different task should be placed into a separate function. In my implementations, I always try to keep nesting under 3, or maximum 4 levels. If my function gets more complex, then i should refactor it into smaller parts. This makes **maintainability**, **debugging**, and reading (understanding) the code easier. You shouldn't use `==` at all. `==` enforce **type coercion**, and because JavaScript's type coercion rules are so difficult (to memorize) it's suggested, that one must NOT use `==` at all. What you want to express with `==` can be expressed with `===` + `explicit conversions`. This would lead to make your code better against side effects.
The pi is more about python. Someone has written most of the gpio functions for node but it isn't fully functional and it isn't built in. Look at the beagle bone black. It's base language is node and it has a good set of guides for how to use it together with a webserver to control the pins. Sparkfun has them in stock last I saw. Most everyone else was having trouble keeping them on hand.
Click "Start" then use the arrow keys to move (keyboard needed).
Coincidentally I just hacked [do notation into JavaScript ES6 using generators](https://gist.github.com/michaelstephendavies/94808d188eb51e66ada5). It fits quite neatly into the rest of the language e.g. you can use it with the standard JS control structures. It's cool but I wouldn't recommend using it in practice. There's some applications there (calculating powersets, solving the 8-queens problem, calculating a bunch of probabilities).
You are seriously confused about how software and computers work. Learn that first.
Relevant: http://gajus.com/blog/2/what-is-the-purpose-of-javascript-generators Explains the inner working of these libraries.
Any chance you'll get a Force-enabled version in the future? Honin' my Jedi skills, yo. (EDIT: Serious note, nice work.)
[Refactoring Ruby with Monads](http://codon.com/refactoring-ruby-with-monads) by Tom Stuart is one of the better articles I've read on the topic.
So you're saying that I can't run node as a web server on any of the three microcontrollers that I mentioned when each of them have examples and documentation to the contrary? This is very possible in a number of ways. I just want to know which is best. 
No. I'm saying you need to learn that which microcontroller you use has no bearing on how you use javascript.
Hmmmm. I have implemented two-way data binding recently for one of my proejcts. I didnt use Object.observe though. Made a coderview asking for people to take a look and tell me what they thought :) Unfortunately no one did lol. http://codereview.stackexchange.com/questions/63266/pubsub-and-two-way-data-binding Theres the post if anyones interested in taking a look, its quite long and may be slightly outdated now. The full source which I was getting the snippets from is my [Cluckles Project](https://github.com/ilikeprograms/Cluckles). The js files are under the src directory, the data binding is handled/setup in the src/Cluckles/theme-modifier.
Sure it does. The interpreter has to support the functions I need. It has to have enough memory. The GPIO needs to be accessible. The processor has to be fast enough, etc. These are all important considerations. The last thing I want is to find out that the microcontroller I choose doesn't meet one of my needs. Do you have any experience with JS on any microcontrollers? If so, I'd like to know what you thought of it. 
Which OS you use is going to determine which controller you use and not how well javascript runs on it. 
How does one fix that for FireFox? Seems to work fine in Chrome.
In order to determine the current value, you have to "cross the bridge". You have to go from JS land, to DOM land, and back again. It's a getter which does some actual work. While getters and setters were fairly recently introduced with ES5, host objects always had this capability. ES5's [Object.defineProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) gives you access to all the magic which was previously only available to host objects.
It's not my code, but that's a great idea for a pull request: https://bitbucket.org/8tentaculos/jspacman/pull-requests
&gt; getElementsByTagName returns an HTMLCollection, not an array. HTMLCollections don't have a forEach method. Stuff like this is the reason it drives me nuts when people are all "you can replace jQuery with `querySelectorAll`!". No, you cannot.
I wouldn't count on all the prototype ones making it in, mozilla removed contains as it broke the web (jsbin literally stopped working) and v8 just removed values (in think). So a bunch of those prototype ones might not make it. PSA this is why extending the prototype of built ins is bad, but on the flip sides is getting easier to subclass built ins so I believe Ember is switching a some point to not array sub classes instead of extending arrays. edit, meant that second paragraph to be a public service announcement, not a Canadian tax
I too heard about contains breaking the web... More info ? Why was values removed? 
Well, you can of course create a small helper function which actually returns an array. var qsa = (selector) =&gt; [...document.querySelectorAll(selector)]; //or the ES5 equivalent thereof [...] qsa('.foo').forEach(bar); That makes it somewhat tolerable.
'object capable' is not the same as 'object oriented' 
impressive ...
This is missing a lot of information. Setup an isolated demo using http://plnkr.co/. You don't need Express to replicate this. Just have static files return the content that you are expecting.
`innerText` is non-standard. There are a couple of solutions. You could use the standard `textContent` where it is supported and `innerText` where that's the only option. Seeing how the page already uses jQuery, one could use jQuery's [.text()](http://api.jquery.com/text/) or if your element is a `&lt;textarea&gt;` you could use jQuery's [.val()](http://api.jquery.com/val/). In this particular case, it seems the `.verifier` element is a `&lt;pre&gt;` so that last one won't do. It seems the problem has been fixed (using `$(...).text()`). Edit: Actually, as the `.verifier`s are just code, code that gets executed, never shown or anything, you could just, well, load it as `&lt;script&gt;` and be done with it.
[Microsoft Outlook Calendar web app](https://esdiscuss.org/topic/array-prototype-values-is-not-web-compat-even-with-unscopables)
contains broke because mootools used it's own contains and it would break in the presents of the new one
"Well, first you need to learn category theory…" \*shoots self in face\*
👍 I recalled that ms thinge... Thank you. 
I like this one var $ = React.DOM; $.div({}, "Hello")
The line app.get('*', ...) seems suspicious to me. I would imagine what's happening is that every time you navigate to a directory other than '/', all your assets are redirecting to 'index.html'. When no JavaScript or styles are loaded, check the 'network' tab to see how your assets are loaded. It's likely all your assets are returning as 'index.html'.
Cool effect. I could feel my phone literally get hot though from the CPU usage lol.
WTF? - There is nothing wrong with recursion - it will not throw an error unless you run out of stack space (which is what I assume you're talking about, but you're statement is idiotic since you claim any recursive function errors) - ES compiler optimizations are often ignored by vendors as long as the functionality works - tail call optimizations don't even apply to the code since the stack needs to unwind to do the multiplication ops Learn about the shit you're talking about before you go spewing nonsense.
Useful, but misstated. These features are similar to Object Oriented concepts, but they are not really OO. You can use the features of a prototype based language to get many of the advantages of OO programming, but there are nuances that will definitely mess you up if you aren't careful.
Can anyone tell me the point of `Array.of`?? Array.of( 1, 2, 3 ) === [ 1, 2, 3 ] Array.of.call( arguments ) === Array.from( arguments ) I don't get it... It's just more typing to do the same thing
Using jQuery, which has the added extra of the hidden div sliding in. &lt;script src="https://code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function() { $("#cog").click(function() { $("#settings").toggle("slow"); }); }); &lt;/script&gt;
obviously they'll be running linux, but a number of devices have been designed to have JS/node play nice with GPIO etc. out of the box. I think the OP is asking if those are worthwhile for what they're trying to do
I was actually at that conference! thanks for the link to the talk. I was a bit too hung-over to really focus on what was being discussed, unfortunately. I blame my boss, haha.
Here's a jsFiddle I wrote up. Without context it's difficult to know exactly what you want, but this basically sets everything to a 'fixed' css position and manipulates the content/settings divs around based on whether or not the cog was clicked. http://jsfiddle.net/bud3d79t/
&gt; do notation into JavaScript ES6 using generators Cool! this is exactly the kind of thing I was looking for. thanks!
&gt; http://aeflash.com/2013-06/monads.html I hadn't seen this post before, I'll have to dig through it.
Hey, thanks for taking the time to write that jsfiddle, I really appreciate it man. But that can be achieved with the CSS checkbox hack, what I'm looking for is when the div is open, if you click anywhere outside of the hidden div for the div to close, rather than having to click on the red dot specifically. Also, is there a way to do it without jQuery in pure js? Thanks again man!
you could just apply an event listener on the window and check if the 'cog' was clicked. if it wasnt, just hide the div. i used jquery because it has a pretty easy to use animate feature. you could technically do it with css3 and just add/remove classes, but then you lose a lot of compatibility if a certain browser doesn't support it. again, it depends on the requirements of what browsers you plan on supporting, but in general i find jquery to be the safe way if you going to do animating dom manipulation. check it: http://jsfiddle.net/bud3d79t/1/
I wouldn't advocate using spread, as the syntax can't be polyfilled (and node doesn't support it yet, even with `--harmony`) Use `Array.from` instead: Array.from( document.getElementsByTagName( 'et' ) ).forEach( fn );
"With ES6" I'm just pointing out what's available with ES6. I'm not advocating anything and I also don't care which browsers/environments y'all have to support.
&gt; I also don't care which browsers/environments y'all have to support Like... any browser or environment outside of a dev browser? There are alternatives, I'm just saying I don't see the point in a statement that, practically speaking, is "In 2017, you might be able to use this feature" You might as well be quoting ES7 recommendations
It's not meant to be used like that. It's an alternate constructor that doesn't have the special case that `new Array(10)` has, namely creating an array of 10 undefined elements rather than an array with one element with value 10. It's meant to be used in generic code, where you want to be able to pass a constructor for a type to something that will later apply it to some arguments.
Been checking both. Javascript console give the error "Uncaught SyntaxError: Unexpected token &lt; " for all of my linked js files in index.html The terminal node server was launched from gives the line "page loaded" ten times
Checked the network tab. When I load /blog,which works, all the assets are loaded from where they are supposed to be. I have angular.js. It says /bower_components/angular and status 200. I tried load /blog/ and /blog/test and I got 304 for all of the assets and its trying to get them from /blog/bower_components. I guess thats the issue? For some reason with the / and extra parameter express tries to load everything from a different directory?
You are correct that it will only error if it runs out of space but space depends on your platform and how much space is used up depends on the complexity of the function, seriously while there may be some advanced cases where this is useful, if your reading msdn you probably shouldn't yet. &gt; ES compiler optimizations are often ignored by vendors as long as the functionality works no idea what you mean by this as tco isn't a compiler optimization while you are correct that tail call optimization wouldn't effect that exact function, it can be rewritten pretty easily to do so. 
It's really important people move away from XP, a 13 year old OS. Doing this is critical for better performance and security (given the OS is no longer supported). Chrome support for XP stops in a few months. 
tl;dr you can run out of memory if you have a recursive function very easily also it is a major pain to debug due to rather large stack traces, unless you know exactly what you are doing you should avoid recursive functions until browsers implement a feature for dealing with them that is coming soon.
Everyone here should be aware what "with ES6" means. I was merely demonstrating how it could look like with ES6.
&gt; Functors are especially not interesting Really? You are using functors whether you like it or not, probably daily in your code, especially if you're using JavaScript. It just happens that functors like `map` only apply to arrays and array-like objects. Now, abstract that away, and you got a `map` that works for *anything* that satisfies the laws of identity and associativity. I find this quite interesting. &gt; Monads can be perhaps used for some cheap parlor tricks to group different kinds of mutations and operations if your programming language doesn't like mutable state I think you missed the point. There is indeed a state monad, but monads are not just about modeling state without mutation. Monads (and applicatives for that matter), are comparable to *function application* with side-effects. Monads enforce the *order* of computations in an otherwise unordered equational world. When you design programs as pure transformations over data, as opposed to series of steps, then you can do equational reasoning at high levels of abstraction. But it is inevitable that at some point you will need to enforce the order of evaluation, and with monads you can do it, but still reason about your program equationally. &gt; Modifying state is not actually so hard if you do it in the right places. I partly agree. But we ought to avoid mutable state as much as possible. This is currently a hot topic of debate in the industry, as we move toward more concurrent and parallel computing.
OP is writing "FidderScript". Anyhow, "ES6" isn't very hard to look up, is it?
The point of my original comment was to point out (mostly to others) that your code shouldn't be used today, because I didn't think it was clear to anyone new to the language. The rest of this conversation has very little point as neither of us is wrong nor is it important :)
Monads are about more than state-handling. They are useful for writing code that would otherwise require a lot of fiddly unpacking of data structures. Monads are particularly great at getting explicit error-handling out of your code, resulting in clearer code with less noise. (Clearer at least to readers who have taken time to study monads.) My background with monads has allowed me to get effective use out of promises. This is the killer application for monads in Javascript. But understanding monads is also useful for getting the most out of functional reactive programming (see [BaconJS](https://github.com/baconjs/bacon.js/) or [RxJS](https://github.com/Reactive-Extensions/RxJS)). FRP pairs particularly well with [ReactJS](http://facebook.github.io/react/). Going into more detail about how monads improve error-handling; let's say I want to write a function that takes a comment URL and fetches the original post that the comment replies to. I need to fetch the comment first to get a URL or id for the post. But I need to handle cases where either the comment request or the request for the post fails. Using callback-style with no use of functors or monads would look like this: function originalPost(commentUrl, callback) { $.getJSON(commentUrl).done(commentSuccess).fail(requestError); function commentSuccess(comment) { $.getJSON(comment.postURL).done(postSuccess).fail(requestError); } function postSuccess(post) { callback(null, post); } function requestError(err) { callback(err); } } But promises are monads, and monads automatically propagate errors. So here is a more concise version of the function: function originalPost(commentUrl) { return $.getJSON(commentURL).then(function(comment) { return $.getJSON(comment.postUrl); }); } Both implementations do the same thing, and report the same errors in failure scenarios. The monad version becomes even more convenient when composing multiple functions that each encapsulate several asynchronous operations. I have an article with details at: http://sitr.us/2012/07/31/promise-pipelines-in-javascript.html *Edit:* Added a missing `return`.
the idea is for it to be useful when you can subclass built ins, you can inherit from it instead of Array if you want to be able to be called with a single number and have it create the array with just a single number not an array of that length
If you really want to understand *why* monads exist and what they're useful for, I wholeheartedly suggest that you pick up some Haskell (or another purely functional programming language). It's really hard to motivate why monads are helpful unless you understand what other programming languages *restrict*. This is the best introduction I know of, it's entertaining and very educational: http://learnyouahaskell.com Monads are covered in [chapter 12](http://learnyouahaskell.com/a-fistful-of-monad), which is pretty late into the book, and for good reason. Building up to them in this fashion will give you the proper understanding of what they are and why they're useful (and why most of them aren't very useful in non-purely functional languages).
Yeah, [functors are awesome](http://www.haskellforall.com/2012/09/the-functor-design-pattern.html).
Pretty cool. I feel like you(or author) could cache a lot of the calculations and get better performance. During the countdown is when the caching could happen.
Advanced cases? I write recursive functions all the time. Deep parsing objects, handling trees of unknown depth (including html structures), all the time with image algorithms on canvas, etc... Yes, there's the _possibility_ that these can overflow, but it's a judgement call based on your normal data input. If I have an HTML page with 1,000 nested nodes of a specific type there are other problems anyway. Recursion is a _useful tool_, and your original comment is simply not true. And TCO is a compiler optimization _by definition_. The compiler sees a specific pattern and it changes the way in which memory/stack are handled. In languages that fully support TCO, you could argue that it's a pattern, but for JS, a language that has many implementations, it is an optimization and will be for years to come.
I've been checking out some more stuff. In sources ,on the pages that break the site all of the files are called index where there should be file thats supposed to be loaded.
Ive written algorithms like that too, I've also rewritten algorithms to not do that when they were found to blow up on mobile devices that have much lower memory limits. I would advise a beginner to avoid synchronous recursion and all others to be very careful with it. As for a compilers optimization... Tco will apply when JavaScript is run by an interpreter or a jit and while you are correct it wont be available universally for a while but this is in no way a rewrite, it is strictly speaking called proper tail calls and simply does not add a new entry to the stack if the function call is in a tail position 
No offense, but you writing bad code does not mean an entire language feature should be avoided. A million people advocate recursion when it's appropriate. Your argument simply isn't valid simply because you can't tell when it is or is not appropriate to use.
The location of the explosion is way off in the silk browser, but a neat effect 
Even so, that's not a reason to press for the dismissal of an entire language feature! I could make the same argument about _anything_! For loops, function calls, basic addition.
Or like eval or declaring a global by omitting var, or using == instead of === or new Function or a host of other things that have a time and a place but we tell people learning the language not to use them Edit: pressed send too early 
Considering this is es6 only, it seems like [...arr] would be a better alternative entirely. Cover all cases and is shorter. 
It's a great idea with decent execution. The big caveat is that they don't have usable stack traces. Bluebird's coroutine() (a competing implementation which does the same thing) solves this problem: https://github.com/petkaantonov/bluebird/blob/master/API.md#promiselongstacktraces---void I think the technique is good, just use Bluebird instead of co.
Tail call optimization is fairly interesting: http://duartes.org/gustavo/blog/post/tail-calls-optimization-es6/
it is very easy to write a recursive rtree or what not, but you'll notice that the good implementations make a point of not being recursive because that gives you a hard limit on how big your tree structure can be, see [rbush](https://github.com/mourner/rbush) and [functional-red-black-tree](https://github.com/mikolalysenko/functional-red-black-tree) removes that upper limit because having a stack of items is much smaller then the stack that is captured by a function especially a complex one.
Upvoted for inclusion of Baudelaire. 
so cool, so cool.
&gt; they're not useful for building large, complex software systems Three words: functional reactive programming. Building an app with, e.g., BaconJS and ReactJS is just really nice.
Well, you seem to have made up your mind on this. What "good" implementations make a point of not being recursive? By the way -- using a non-recursive algorithm does not automatically give you a hard limit. You have to code a hard limit. And you can code a hard limit with or without recursion. They are not really related. The code in rbtree.js is recursive, and pretty much exactly like I think it should be done: //Visit all nodes within a range function doVisit(lo, hi, compare, visit, node) { var l = compare(lo, node.key) var h = compare(hi, node.key) var v if(l &lt;= 0) { if(node.left) { v = doVisit(lo, hi, compare, visit, node.left) if(v) { return v } } if(h &gt; 0) { v = visit(node.key, node.value) if(v) { return v } } } if(h &gt; 0 &amp;&amp; node.right) { return doVisit(lo, hi, compare, visit, node.right) } }
I wish people would stop down voting this because they disagree. The discussion in response is valuable and relevant.
http://jsfiddle.net/o5fjvLx1/ $('input:radio').change(function(){ //check if a radio button has been pressed var total = 0; //set total price to $0 $('input:radio').each(function () { //iterate through each radio if($(this).is(':checked')) //if that radio is selected { switch($(this).val()) //get the value { case 'small': total += 8; //add the total price break; case 'medium': total += 10; break; case 'large': total += 12; break; case 'meatlovers': total += 7; break; case 'hawaiian': total += 8; break; case 'deluxe': total += 9; break; case 'delivery': total += 4; break; default: break; } $('#total').text("total = $" + total); } }); }); You'll have to add a div with an ID of 'total' and use the jquery library
Er I was looking at a different part of that code that has an explicit stack, and my point was non recursive avoids the limit
just put an id or class on each &lt;source&gt; tag and change the src attribute for each. Also, using google can help: http://stackoverflow.com/questions/21656810/change-video-source-in-javascript-jquery
To add the library try. http://www.w3schools.com/jquery/jquery_install.asp
 /^a(?:|b(?:|(c|d$|de)(?:|f(?:|[g-h]+))))$/gi
You can try out Side Comments. http://aroc.github.io/side-comments-demo/. It make each paragraph have a commenting section. I am on the look for something where I can do work by word or sentence by sentence though.
&gt;However because Primitive Types are immutable, we’re unable to assign properties to them. The parser will immediately discard them when attemping to read their value. Not quite. &gt; var x = 'asdf'; undefined &gt; x.foo = 'bar'; "bar" &gt; x.foo undefined What happens in that second line is essentially this: new String(x).foo = 'bar'; It's auto-wrapped. This explains why that line works and it also explains why "x.foo" is undefined. It's because "new String(x).foo" is undefined. The temporary String object in the third line is a completely new one. Personally, I think that having primitives in the language was a mistake. From the user's point of view, they should have made everything look and behave like an object.
Go ahead and implement the promise/a+ spec. Promises/futures are monadic constructs. If in your code, you have pipelines that have stages, implement each stage as a monad. Give your Monad type just two methods, bind and return. Bind takes a monad and a function (that is given the value contained in the input monad) and returns a new Monad. Return inserts the value that you give it into a Monadic structure and returns the monad. Make sure that these methods satisfy the constraints a strong monad is supposed to (should be in the Wikipedia article on Monads). So now, you have a way of converting simple values into monads and accessing these values. That is all you need to implement pipelines where at every stage a value is transformed by a monad. Write a simple mathematical expression parsing pipeline using these concepts. 
You can update all the sources and let the browser pick the right one, or you can use the `canPlayType` of `HTMLMediaElement`s to know in advance which format the browser is willing to play. [Example](http://www.simpl.info/canplaytype/).
Ignore the nay-sayers. It's anti-intellectual bullshit by blub-language programmers scared of learning something new. Functors, Monads, etc are extremely useful in real world code. I write Scala and Javascript for a living at the moment, while learning a bit of Haskell on the side for fun. Once I got my head around the concepts, I found I was able to apply most of the things I'd learned back into my professional codebases, solving real world problems in a much cleaner way than my earlier implementations. I'm not some ivory-tower academic mathematician. I'm a normal software engineer that spends most of his day writing Scala and Javascript for a normal software company. My only regret is not learning these things 15 years ago, since i've been able to use them to solve problems I wouldn't have dreamed of being able to solve until recently. tl;dr Learning and understanding the 'Haskell' way of things has led to the most significant leap in my ability as a programmer, and I now use these techniques on a day to day basis to solve real world problems. Whether you like Haskell or not, it's pioneered a lot of incredibly useful concepts.
You sound like you're seriously confused about how software and computers and microcontrollers work. You also sound like a troll. What work have you done using javascript to work with microcontrollers? I have about 15 years experience doing just that, so go ahead and try to swing your dick around, let's see what you actually know.
If I were you, get up to speed on arduino and the many "shields" that plug-in to it that allow interfacing to RFID, or other security hardware. Connect to the arduino using serial port, and read and write data to/from the arduino from any OS platform you like, using nodejs serial module. 
Probably, but you gotta admit, that's pretty far down the list of javascript design flaws.
&gt; Personally, I think that having primitives in the language was a mistake. You've got to be fucking kidding me. You think mutable strings are a good idea?
I think you should read up on the future plans for AngularJS (with Object.observe) and have a closer look at how the recommended "polyfill" actually works. &gt; It looks a lot like angular, but this is just cause, well, they get it right. This doesn't make any sense to me. AngularJS is designed to take advantage of Object.observe when it becomes available. *That* is why you can easily build something that looks like AngularJS and uses Object.observe. For now, AngularJS uses dirty-checking to emulate Object.observe, just like the polyfill does. Dirty-checking can be slow, as you mentioned, so it is really important to minimise the number of dirty-checked values. AngularJS will stop dirty-checking when a scope is destroyed, so too much dirty-checking is not a common problem there. Your solution would need a corresponding strategy to be practically useful with the polyfill.
I found this article a nice read and really helped me. 
&gt; You think mutable strings are a good idea? genuine question. what would be wrong with mutable strings?
What I don't get (and don't like), is that `typeof null` is 'object' yet `null.foo` produces an error for any "foo". That is so inconsistent. It would have been better if `typeof null` was anything but *not* an object. Now you have to double work when checking parameters, check if a parameter is not null and if it is an object. Just the latter should have been sufficient.
I built computers from the TTL level in the 1980s. If you ever had eye surgery, there's a 50/50 chance my machine was used. If you ever used a vending machine, there's a 70% chance you used my hardware. If you go to the theater, there's a chance you can see my handiwork. Don't fuck with me, kid. I'm not in the mood to deal with the likes of you and other reddiots. If you can't get your OS to work on a controller first, then nothing else matters. You seem to think the controller runs javascript directly. But you are talking about this on reddit, and not somewhere else, so I doubt you are capable of the first and probably think the second. Now get off your mom's computer before she finds out.
It wouldn't be a mutable string in the sense you're thinking of, merely a String object to which you can attach new attributes.
I actually had to test this: var a = new String("abc"); a[0] = "f"; a; Kinda strange that doesn't work. Does the standard specify that the String object is immutable?
It is quite heavy on devices that manage memory differently then computers. It's still quite remarkable, though. (If you don't like this comment, blow it up.)
[Of course it would.](http://picardfacepalm.com)
There are three mentions of javascript on the page. NOT NESSCASARILY IN THE ARTICLE. . . ' One in the tags, one in the classification and one on the title of a article. Not this one. Oh, and the example is broken too.
ask them to pay you to do it
jQuery is a library. Sometimes I question why a library needs a library to work. That the most visited web sites use a certain library doesn't mean your library needs to use the same library, or a library at all. I expect a library to be as small and as fast as possible. jQuery does not do either compared to plain javascript. 
Just out of curiosity, why do some people want it independent of jquery? What is the advantage? It's not like pulling in jquery will slow down their website much, since it's cached on so many computers, and it's rather compact anyway. I would not bother at all if anyone wants this, using vanilla js will only increase changes of old browser quirks
That's what I am thinking. renooz disagrees (http://www.reddit.com/r/javascript/comments/2jooy9/is_it_worth_the_effort_to_write_jqueryless/cldo0ig). Though, then again, he contradicts himself in the very same statement "I expect a library to be as small and as fast as possible." Removing jQuery as a dependency will certainly not make the library smaller and it is very unlikely that it will make it faster. Add old browser support, and it will almost always make more sense to have jQuery as a dependency for a library that deals a lot with DOM manipulation.
I got rid of that route and changed the other too /* and added &lt;base href="/index.html"&gt; to the index.html and it's loading all the correct file. I output the req and saw that for the pages that are broken were also had requests for /blob/folders for all the assists. Guess Angular thought it was in a different folder and requested the wrong path. All works now, Thanks for the help.
I use a variation of this bookmarklet: http://www.learningjquery.com/2009/04/better-stronger-safer-jquerify-bookmarklet/
I don't see how jQuery makes anything smaller. If you mean you can write a statement to do something in one line compared to three in vanilla, that's ignoring that you are bringing in a 60K library (or whatever it is now). As far as speed goes, it's a given that jQuery is slower cause it has to touch all the bases, dot all the i's and cross all the t's. Lots of benchmarks around about that. The 'cachable' argument is a weak one. Not everyone has your version of jQuery cached and chances are good it's not there at all. Someone (Souders?) wrote an article stating you had less than a 20% chance jQuery will actually be in cache.
A JS `string` is immutable, a `String` is just an object wrapped around `string`, it doesn't change the immutability of the underlying string just as `new Number(3)` does not result in a "mutable number".
JSON/JS. If there were a JSON subreddit, I'd post it there.
JQuery isn't just a library, it also brings a philosophy with it that is quite different from vanilla Javascript. You might think that it's the correct philosophy, but there are others who will disagree. Your library seems to have adopted the JQuery philosophy, so it's a little strange to ask for a version that doesn't include JQuery. Though, if your library depends on a different version of JQuery than what is already used, that could be a little annoying.
Numbers are objects. They have methods. For instance, here's how you get a decimal string of fixed precision: Math.PI.toFixed(2); // "3.14" (4.57647).toFixed(3); // "4.576"
It may be a nice read, but it's mostly wrong. The primitive types are actually special objects. You can have the same functionality with regular objects using ES5's new constructor options. 
Congratulations! Good to be one of your first purchasers. You might want to feedback that having my email address plastered all over the PDF I printed is exceptionally poor - if I want passing colleagues to have that address, ***I'll*** give it them. It's totally not a decision Manning should be making for me, and a simple hash would have been a trivial solution. Hopefully it won't be on the snail-mailed copy. I'm with McKayLemons about the cost of CORS in hours, but such it is when grafting new tech onto old - thinking around HTTP is hard enough without doing the same through the prism of CORS (or any prism), but I'm glad to have at least started that road - I've found it an effective way to get cross-origin done, and I've found making these kinds of requests a marvellous way to keep the load off poor servers. I know the practice; all I need now is to learn the theory. 
If you're building a utility library, here's just a few reasons you should not use jQuery: - jQuery pollutes global scope - jQuery is relatively huge, and you're probably only using a couple of functions (like dom select) - jQuery represents an "old school" way of writing JS. You need to manually download the right version, drop it into the right folder, set up a `&lt;script&gt;` element, and set up any compression or concat tasks (i.e. for plugins). This is a lot of work for those who are using npm/browserify/webpack/etc to automate their workflow - jQuery versioning always presents a problem. If you have a lot of plugins or libraries depending on different versions of jQuery, it's always a game of "let's see if it breaks." - a lot of people (even jQuery) are dropping support for IE&lt;9 to avoid the added code complexity and bloat. If you're trying to support IE6-8, it makes sense to use jQuery. With all of that said, it doesn't mean you should try to re-write a selector engine just to avoid the jQuery dependency. Here's my suggestion: you either continue using jQuery, and tell them to suck it, or you actually change the way you build libraries so they can be smaller and more modular, only pulling in the code they actually depend on. e.g. - You can author your code in CommonJS. This allows you to split it into separate files if you wanted it to be a bit cleaner. - You can depend on [qwery](https://github.com/ded/qwery) for cross-browser DOM selection, [domify](https://www.npmjs.org/package/domify) to parse HTML strings, [add-event-listener](https://www.npmjs.org/package/add-event-listener), [lodash.throttle](https://www.npmjs.org/package/lodash.throttle), etc. - You can bundle a UMD build with browserify/webpack so that the final `dist/contents.js` is no different than it currently is. You end up with a very small and concise codebase that automatically resolves dependencies (i.e. so you get their patches upstream), and uses well-tested dependencies (as opposed to your attempts at re-writing it). And, to top it off, anyone else using browserify/webpack can rely on your CommonJS code for better dependency resolution and an even smaller bundle size. More info [here](https://github.com/mattdesl/module-best-practices) if you're curious about this approach. :) 
Looking at your code, most of them are easily replaceable by browser native implementations. $(window).on('scroll) document.body.onscroll $(document).find('#' + idVariable… $('#' + idVariable… document.getElementById(idVariable… // EDIT: thanks /u/talsesInc $.each arrVariable.forEach Object.keys(objVariable).forEach $('&lt;ol&gt;') document.createElement('ol') It's not that jquery is bad. It's just convenient for a library to not depend on another library especially if your library doesn't use the larger functionally provided by jquery. The Ajax api for example or the ease of configuring custom widgets. Backbone depending on jquery makes sense. But a tooltip widget library doesn't. EDIT: thanks /u/talsesInc
Yeah, I know that it doesn't change the immutability of the underlying string. However, I was talking about the immutability of the String object. It could be either immutable or mutable, and it appears to be immutable. For example, JavaScript String Objects *could* work like this: var a = new String("abc"); a[0] = "f"; a === "fbc"; // true But they don't, as String objects seem to be immutable.
What
 &gt; !!new Boolean(false) true Exposing the wrapper machinery to the user is a very obvious flaw. There is zero benefit.
Don't call me kid, kid. Been doing this shit since the 70's. Built shit out of 74-series and CMOS before you probably had a clue. If you're "not in the mood to deal with the likes of me and other redditors" then why do you only come here to shit on people? You're one of those fucking neckbeards the "kids" around here seem to not give a shit about. You're bringing a knife to a gunfight, and you are out of your depth here. Do you even know what javascript is? Have you ever touched it before? I seriously doubt it. &gt;If you can't get your OS to work on a controller first, then nothing else matters. You seem to think the controller runs javascript directly. This is fucktarded. Where did I ever insinuate that I think the controller runs javascript directly? I didn't. There are so many microcontrollers that don't run an "OS", that don't have the resources or need to run an "OS", but that could still interact with javascript running elsewhere. I'm not really sure what you were trying to say but you didn't say anything helpful, useful or interesting. Maybe you shouldn't get drunk before posting nonsense on the internet. 
Yes, numbers aren't objects but, up to a slight performance hit because of the wrapping, you may freely treat them as objects. 
&gt; Does the standard specify that the String object is immutable? Of course it does. Strings are immutable in pretty much every language.
https://www.npmjs.org/doc/cli/npm-install.html
Except Ruby (and people complain about Javascript being a stupidly designed language)
That's what I am going to do, if I decide to remove jQuery as a hard dependency. Thanks for the advise.
That's a good point.
&gt; Your library seems to have adopted the JQuery philosophy, so it's a little strange to ask for a version that doesn't include JQuery. Judging on what?
Sure, but that's separate from not everything being an object. If you consider them the same, then I agree that it's reasonably high up on a hypothetical "JavaScript Flaws" list.
Interesting. Kind of like regex engrams. I can see it being useful. Awesome.
&gt; However, I was talking about the immutability of the String object. It could be either immutable or mutable, and it appears to be immutable. It does not, and is not: &gt; var a = new String("foo") undefined &gt; a.bar undefined &gt; a.bar = 3 3 &gt; a.bar 3 &gt; For example, JavaScript String Objects could work like this: &gt; var a = new String("abc"); a[0] = "f"; a === "fbc"; // true That's a tentative assignment to the underlying `string`, which is immutable. `string` and `String` are not completely separate things, `String` is merely the wrapper object for the `string` primitive.
Calling me a kid is just plain trolling. You are a troll. You've given nothing substantial, you've only given personal attacks. We're probably around the same age, but I've kept current and creative while you seem to be fading away. Good luck with that, neckbeard. 
Ruby is one of the few exceptions. Strings are immutable in Java, C#, Dart, Python, Go, Lua, and so forth.
Let's take like 5 steps back here. What is it that you are actually trying to do, and why wouldn't connecting to Gmail using something like POP3 or IMAP in something that isn't javascript be better?
Couldn't you just check if `x === null`?
Explain to me how you could possibly find mutable strings advantageous vs the immense problems it leads to (such as hash tables losing values because the string keys get mutated)
Judging on the code examples in your readme. It all looks like JQuery-style code. That's not a bad thing, it's just different from vanilla.
&gt; Explain to me how you could possibly find mutable strings advantageous They're efficient and they "just work" for a number of cases (such as concatenation and repeated concatenation where they avoid the quadratic explosion of immutable bytestrings, though ropes are certainly an alternative there) &gt; vs the immense problems it leads to (such as hash tables losing values because the string keys get mutated) This is a problem of shared mutability, not of mutability itself.
If the objective is to eliminate a dependency then suggesting to replace the dependency with another dependency is not the way to go.
&gt;It does not, and is not: By "it could" I mean "if JavaScript were specified that way", I wasn't talking about how JavaScript actually is. &gt;That's a tentative assignment to the underlying string, which is immutable. "string" could be immutable and String not, and assigning to the single variable could still change the mutable String even if the underlying primitive value were immutable. I'm talking about language design here, not how JavaScript works &gt;string and String are not completely separate things, String is merely the wrapper object for the string primitive. Obviously. EDIT: Made a simple "mutable String object" example: function MutableStringObject(primitive) { this.myValue = primitive; for(var i = 0; i &lt; primitive.length; i += 1) { this[i] = primitive[i]; } this.valueOf = function() { var str = ""; var i = 0; while (this[i]) { str += this[i]; i += 1; } return str; } } var myMutableString = new MutableStringObject("abc"); console.log(myMutableString.valueOf()); myMutableString[0] = "f"; console.log(myMutableString.valueOf());
jQuery is a big inefficient library with a bunch of functionality that you probably aren't even using. Why should someone have to force the visitor's browser to parse that huge script just to use a few functions from it? It's unnecessary bloat.
It is if you gzip it. Obviously your browser has to parse/execute the uncompressed code, which is ~100KB (for the latest minified 1.x version).
Okay. I'm trying to retrieve messages and if possible compose or reply to them. Because I'm building a client side application and I would prefer for as much to be done on the client side as possible. Also because the only languages I intend to use in this project are javascript / jquery and golang. 
&gt;This is a problem of shared mutability, not of mutability itself. All i'm saying I guess is: "the less foot guns, the better". What's isolated today can easily become shared tomorrow. 
ignore this tool. I've read his posts and it looks like he just loves throwing terms around without demonstrating anything. 
[Receiving email in Golang through IMAP](http://blogging.makesmeanerd.com/?tag=golang) [Sending emails in Golang through SMTP. Does this work for your needs?](http://nathanleclaire.com/blog/2013/12/17/sending-email-from-gmail-using-golang/) Golang has an SMTP module built in.
Better overview: http://kangax.github.io/compat-table/es6/
&gt; Math.PI.toFixed(2); // "3.14" What actually happens: new Number(Math.PI).toFixed(2); It's auto-boxed. Whenever you try to access some property of a primitive, a temporary wrapper is created to make that possible.
I just looked for that too. That's in 7. https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_7_support_in_Mozilla that one is easier to just polyfill. most of these we have to transpile
I think the complaint here is that jQuery is a **huge library**; so a library that depends on a small piece of jQuery (such as the AJAX functionality) still has to include the irrelevant pieces (such as animation, DOM traversal, browser events, etc). While it is possible to [build jQuery with selected modules](https://github.com/jquery/jquery), most existing libraries don't take advantage of that. 
Full disclosure: this is my blog.
Much better article: http://javascriptweblog.wordpress.com/2010/09/27/the-secret-life-of-javascript-primitives/
No. jQuery 2.1.1 is 84 KB, 1.11.1 is 96 KB. It's true that compression techniques let you download significantly fewer bytes, but the data that you download isn't JavaScript, it's data that needs to be decompressed into JavaScript. The parse and execute steps are still dealing with 84/96 KB of JavaScript.
Chrome's console says: Uncaught SyntaxError: Unexpected token { 950d1f8e2d86353bad090522d762188b9513d1ad.js:14 fast-route data found, but no collection exists for: settings 950d1f8e2d86353bad090522d762188b9513d1ad.js:20 Uncaught ReferenceError: isAdminById is not defined 950d1f8e2d86353bad090522d762188b9513d1ad.js:20 Uncaught TypeError: Cannot read property 'isAdmin' of undefined 950d1f8e2d86353bad090522d762188b9513d1ad.js:1 Exception in defer callback: ReferenceError: Spacebars is not defined at null._render (http://mean-stack.io/950d1f8e2d86353bad090522d762188b9513d1ad.js:13:1470) at null.&lt;anonymous&gt; (http://mean-stack.io/950d1f8e2d86353bad090522d762188b9513d1ad.js:10:26626) at http://mean-stack.io/950d1f8e2d86353bad090522d762188b9513d1ad.js:10:25734 at Object.e._withCurrentView (http://mean-stack.io/950d1f8e2d86353bad090522d762188b9513d1ad.js:10:28753) at http://mean-stack.io/950d1f8e2d86353bad090522d762188b9513d1ad.js:10:25692 at e.Computation._compute (http://mean-stack.io/950d1f8e2d86353bad090522d762188b9513d1ad.js:5:16650) at new e.Computation (http://mean-stack.io/950d1f8e2d86353bad090522d762188b9513d1ad.js:5:15913) at Object.e.autorun (http://mean-stack.io/950d1f8e2d86353bad090522d762188b9513d1ad.js:5:17886) at e.View.autorun (http://mean-stack.io/950d1f8e2d86353bad090522d762188b9513d1ad.js:10:25663) at http://mean-stack.io/950d1f8e2d86353bad090522d762188b9513d1ad.js:10:26565 :(
&gt; 60% of the 10,000 most visited websites use jQuery 60% isn't a high number really?
Please read up on reddit's rules @ http://reddit.com/rules, specifically point #1 of rule #1. Our [guidelines](http://www.reddit.com/r/javascript/wiki/index) also have more information regarding promotion &amp; self-promotion. **Consider this your only warning.** If you continue to post _only_ a single site, we'll be forced to take action. Thanks for your understanding.
Many of your points might have once been true but are certainly not anymore. I know you were addressing "utility" libraries, but that sounds like a loaded term and I'm just going to omit it in favor of actual websites and apps. You can use jQuery with CommonJS or AMD and not pollute the global scope, through its UMD. You can use individual pieces of jQuery if you would like to via either custom builds or a module loader/resolver (might need shimming depending on your setup). Many of jQuery's largest pieces are also some of its most used. The AJAX module, for one, is very frequently used no matter what kinda of site/app you are building. jQuery's versioning is actually very good, because of their positioning the team is extremely careful about not making breaking changes, and they are fast to respond when they do. Versioning in dynamic languages like javascript has always been and will continue to be an issue, but the jQuery team does an excellent job. Also if you're ever reducing yourself to "let's see if it breaks" that's on you for not testing your code properly. A lot of jQuery's patches for native behavior are actually for modern browsers. Even if it didn't, the primary feature of jQuery is not browser compatibility, but that it offers a model that is both comprehensive and compact. Hence the slogan "write less, do more" not "write once, run anywhere". This attitude that jQuery's days are numbered is ill-informed. jQuery is a bigger part of the future of the JavaScript (browser) landscape than any module system, framework, or browser. Now I'm not saying jQuery is a necessity for everyone, that is certainly not the case. But the reasoning I'm seeing for it is just not valid. Btw on a 3mbps connection 30kb is about 80 milliseconds. You spend significantly more time establishing a connection. So let's stop pretending that's massive. If you're really dealing with a place with an extremely slow internet connection. Go get a free account on CloudFlare and stop worrying about it.
&gt; over 60% of the 10,000 most visited websites That's not a big number. I don't know what the actual statistics are, but if only 60% are doing something, that means 40% are not, and that number is too big to ignore. 60% is only a bare majority.
Nice one ! Thank you !
Thank you !
Please don't post stuff like this, thanks.
If you really want to do this using javascript maybe try [node.js IMAP module](https://github.com/mscdex/node-imap)? 
That is assuming the other 40% are using the exact same technique. 60% is a large majority.
Well, no. 60% are using jQuery and 40% are *not* using jQuery. So making something jQuery-dependent alienates 40% of users, while making it jQuery-*in*dependent alienates none of them.
Looks like you have an incorrect closing brace after your success function. I don't think that will parse as written. 
Again, what? 
... no. I replied to /u/dfltr, not /u/theregularlion.
Thank you for posting this. I feel like all too often developers feel they need jQuery simply because they don't know how to do basic JS programming without it. This results in sites including jquery just to get shortcuts to things like document.getElementById or document.createElement because the dev didnt know any other way. Not that its bad to have wrapper methods or frameworks for those type of common calls, my point is that if you understand the fundamentals of what that shortcut is doing and why you need it, you can probably implement something better or at least better evaluate other options instead of blindly using the same large hammer for every job. 
What are you doing later in the code? Does this execution path end at any stage so that the JS engine can continue with the next thing in its event queue? 
I'm following that documentation. That is where I have gotten everything from, but I shouldn't be getting undefined when I call a function and attempt to use it's first argument. I've tried asking on SO and no one there is willing to help.
I'd honestly prefer to using node.js. Sorry to be picky, but that is another library to include and it is server side. Since the gMail API exists, why not use. I just need help going further.
Less dependencies are not always better. Imagine three libraries all have their own `debounce` function. They all implement it slightly differently. One of the implementations has a bug, the other has a memory leak. And at the end of the day, you end up with three functions in your final JS bundle rather than just one. Now imagine if dependencies were used. All three depend on [debounce](https://www.npmjs.org/package/debounce) and get patches (bug/memory fixes) upstream as they are fixed (through a package manager). The application is more robust, the bundle size is smaller, and the debounce function is now decoupled from the rest of the code that requires it.
Even though you are presenting this for `requireJS`, this specific solution has been around for a LONG time (i.e. don't cache the index page, but cache everything else). It's called file revving. So, when you drop a new index page that points to `xyz.2.js` instead of `xyz.1.js`, browser will handle it for you. Also, using query params to cache bust ~~is actually bad performance~~ might not always work. http://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/ Just reference the filenames directly, but use something like [grunt-filerev](https://github.com/yeoman/grunt-filerev) to automatically swap in the hash when you do a build. Hash is generated by passing the file contents, so if you see a different hash value, the contents have changed. 
A website about MEAN stack built using [meteor](https://www.meteor.com/). Is this a joke or something?
Yup. You're right
Oh, I misunderstood. I thought you wanted to check for null. If you want to check if a variable is an object, you could use `instanceof`. &gt; null instanceof Object; false &gt; (window.someObject = {}) instanceof Object; true Or probably better yet, `instanceof [[DesiredType]]`. I agree it's pretty nonsensical, but I wouldn't say it necessitates doing "double work".
You don't pipe a stream to `browserify`. You bundle `browserify` which then gives you a stream. Here's a browserify from one of my own projects, with your inputs. `entries` is your starting input. Also I havn't seen transform used that way... : var reactify = require('reactify'); gulp.task('build', function () { var bundler = browserify({ basedir: __dirname, entries: ['./src/js/main.jsx'], extensions: ['.jsx'], debug: global.isDevelopment ? false : true, cache: {}, packageCache: {}, fullPaths: false }).transform(reactify); var bundle = function () { return bundler .bundle() .pipe(source('bundle.js')) .pipe(gulp.dest('./dest/js')); }; if (global.isWatching) { bundler = watchify(bundler); bundler.on('update', bundle); } return bundle(); }); **Edit** I wrap the last part in a function, because then it can be used with `watchify`.
Yeah, I guess your wording was a little strange. 
Okay, add a return to return the promise that the find is generating like this: console.log('in the moodEntryQueryFuction'); return moodEntryQuery.find({ success: function(results) { and change the query.each to query.each(moodEntryQueryFunction) .then(function() { which is just easier than adding a return to what you have, which would have ended up with query.each(function(User) { //console.log(Object.keys(User)); console.log(User.get("email")); return moodEntryQueryFunction(User); }).then(function() { Assuming that works, then the issue was that the .then() function was getting run before your moodEntryQuery results were in. The main issue with what I'm suggesting here is that the moodEntryQuerys for each User will get run sequentially instead of in parallel. There are ways around this, however, if that's an issue. 
Paid or hobby?
&gt; Please note that some of these tests represent existence, not functionality or full conformance. This table is more accurate for Firefox, as the compat table doesn't check for spec compliance. For example,`let` semantics in SpiderMonkey didn't adhere to the spec until recently, but the existence of `let` is enough to constitute support for this table. Still a useful resource, though.
I assumed it was not a new concept. Thanks for naming it. The argument for not using querystring revving appears to be some popular proxies don't support proxy caching with querystrings by default. As these are configurable settings then it seems revving on the querystring is fine as long as one sets the configs accordingly. Revving on querystring does have advantage in that systems like grunt-filerev are not needed. Please correct me if I have missed another important point.
Could be both, as long as it's interesting.
Correct (i.e. I modified my comment). The file-revving is nice because the hash won't change if the source didn't... but if you can stream-line the require config building to generate those hashes for you, probably good enough.
Ah, in that case yes. But we would also have to assume that jQuery developers are going to look for general JavaScript libraries instead of jQuery compatible ones. I think that could go either way.
some concerns with this. it seems to automatically parse &lt;Array&gt; tags as a special case, assuming that each &lt;Array&gt; tag represents a single value in the object as an array accessed by the key 'array'. I think this is not desirable semantics. 
Who doesn't gzip their code? If they aren't, then that's the actual problem, it's not jQuery. As for making the browser parse/execute the code, almost every browser out their today has a JIT compiler. Making this time negligible no matter what the size of the library is.
Actually, I don't think either of us used the 'gulp-browserify' module which does seem to pipe the source. Try this with just the 'browserify' module, which accepts the array of src files or an options object: https://github.com/substack/node-browserify#var-b--browserifyfiles-or-opts The gulp-browserify module is fine, but it's just adding some unnecessary overhead.
Going through a vetted Gmail API should be a lot less painless than using imap/pop3. Authentication on its own is going to be leaps and bounds easier (and scalable) than one-offing an IMAP or POP3 client.
&gt; Making this time negligible no matter what the size of the library is. Well that was the original comment, it's not negligible, especially on phones. It was frustrating slow on my old laptop as well - about 150 ms. &gt; almost every browser out their today has a JIT compiler That makes the parse+execute speed slower, not faster. The JIT compiler is for optimizing later execution at the cost of more work up-front.
If you take the top 10,000 websites that are heavily powered by Javascript (excluding webpages that have little to no Javascript), I guarantee the vast of them will use jQuery in some form. I'm including jQuery, Zepto, jQuery-like libraries, and embedded jQuery implementations (angular+jquery lite). Also, 60% is still be a massive number of websites. There is very few pieces of technology out there that are used by 60% of anything. I don't think unix/linux-based servers even represent that high of a number. 
Great point. Here's a quick demonstration/proof of it: &gt; var x = 'asdf'; undefined; &gt; String.prototype.getSelf = function () {return this;}; function () {return this;} &gt; typeof x; "string" &gt; typeof x.getSelf(); "object"
Uh no... it's a little more complicated than that, but I won't get into that discussion. But basically that time is chunked into the first or first few executions. Running some tests on devices I have handy. I'm testing with and without a some basic jQuery code (seen below): &gt; ``` &gt; $(function() { $(document.body).css('background', 'red'); }); &gt; ``` | Device | Browser | Runs jQuery? | Evaluation Time | --- | --- | --- | --- | | MacBook Pro | Chrome | No | _N/A_ | | MacBook Pro | Chrome | Yes | 53ms | | MacBook Air | Chrome | No | _N/A_ | | MacBook Air | Chrome | Yes | 62ms | | iPhone 5s | Mobile Safari | No | 6ms | | iPhone 5s | Mobile Safari | Yes | 98ms | | iPad 1 | Mobile Safari | No | 18ms | | iPad 1 | Mobile Safari | Yes | 112ms | &gt; N/A means no evaluation event was recorded. Evaluation time was the calculated from the mean of 5 different runs. Now, let's dive into the slowest number on this chart, the original iPad running mobile safari with jQuery usage taking 112ms. Let's compare this to the total wait time to first paint on a popular website: reddit. On that same iPad, it's take over 8600ms. So you're talking about just over 1% of the total time to first paint. Btw, it's not for another 6 seconds until the page is fully rendered.
But: &gt; \&gt; new Number(5) == new Number(5) &gt; false
Point being? In a language where everything is an object, this kind of thing would of course work. With operator overloading, it would also work for your own objects.
&gt; You can easily make plugins that do not pollute the global namespace, in fact most do not. You've clearly never tried to use a plugin with jQuery + npm + browserify... Anyways. If you want to depend on jQuery/D3 or some other monolithic framework for your libraries, that's your choice. :) 
http://domenic.me Editor Domenic Denicola's website
All the styleguides that are hip these days recommending putting the loading operations into resolve. I don't get the point of that, it just makes the app unresponsive.
some of these are already in google chrome 38 like sets and maps (i know the update broke our app &gt;_&lt;)
As the others have said: you can't pipe directly into browserify since gulp is using using a vinyl-fs stream, not a regular node stream. That's why you can't pipe directly out either without using that vinyl-source-stream module. There's a lot of ways to make it work, however. Personally, I piped into and out of browserify using through2 and streamifier like this: // Browserify stuff .pipe(through2.obj(function(file, enc, next) { var stream = this; browserify(streamifier.createReadStream(file.contents, {"encoding": enc})) .bundle(function(err, buffer) { if(err) { throw err; } file.contents = buffer; stream.push(file); next(); }); })) Keep in mind you'll have to give a basedir option to browserify if you want to relative requires. 
No. There's an anti-jQuery hysteria going on, and it's all really for nothing. Just use it. It's works. It makes like simple. If you ever get to where life is not simpler with jQuery, come back then and ask how your life could be simpler. Right now all the answers given here are just going to make things harder for you.
That is intentional.
I'll check it out tomorrow and update you. Thanks so much! :)
Right now I work on a lot of cordova/phonegap projects. Plus I try to do angularjs in everyone one of them. The second I add jquery plus angular performance because super silly awful. So yeah I'm always looking for tools that don't require jquery. Right now I'm looking for a good waypoints option.
I can't find a link to a live demo of this... am I blind or is there not one available? EDIT: I'm blind http://usablica.github.io/intro.js/
Obviously not as a long term solution. That really goes without saying. If one only needs the "selectors" feature of jquery, it would be better to embed that specific Zepto module than include all of jquery.
Check out: http://cylonjs.com/ 
People using Dojo, Angular, vanilla, etc will likely not even consider using your library if it depends on jQuery
Hi, Mithril author here. Have you considered looking at sweet.js? James Long wrote a JSX parser with it here ( http://jlongster.com/Compiling-JSX-with-Sweet.js-using-Readtables ), and I also use it for Mithril's template compiler (it basically takes m() calls and converts them into the respective output data structures). In theory, it should be possible to adapt these projects to transpile from one vdom structure to another (and possibly even to transpile to the higher-level view languages (i.e. h(), m(), jsx). I think interop between frameworks is a bit of a loftier goal. Personally, I don't think anyone would want to write code targeting an universal vdom because xkcd.com/927 I think it's more realistic to think of tools to make existing components transpilable. FWIW, I took your universal proof-of-concept ( https://gist.github.com/gcanti/52d6240ee8e51b857985 ) and ported it to Mithril and the code turned out almost identical ( https://gist.github.com/lhorie/0391520181d761722977 ). Would also be interested in seeing someone try writing a React-to-Mithril or to-Mercury adapter.
There is a staggering amount of spelling and grammatical errors in that article. Normally i wouldn't worry too much about it but in this case its pretty hard to read.
Wow. Talk about a blast from the past. The two lines at the top are browser detection. If you called 'document.all', and the object wasn't undefined, then you knew you were in IE land, and likewise, only Netscape supported layer elements. 
I have actually, every single day for work and open source projects. In fact my coworker works very closely with substack on plugins/transforms around Browserify. I'm also on the core team of Marionette.js, a Backbone framework which uses jQuery. And here's an open source project I have that uses Browserify, jQuery, and several jQuery plugins: https://github.com/thejameskyle/marionette-wires. So if this is a question if I've actually used this technology, the answer is yes, I have. I've use all sorts of frameworks and libraries and work very hard to keep really massive applications rendering as fast as possible. There's never been a time in my career where removing a generic library has sped up time to first render in any significant way. There's a lot more going on there. Paul Irish has some great talks on the matter if you're interested.
&gt; You definitely right, there are plenty of features which are very nice! This comment in response to a correction (apparently) on the fat arrow syntax made me unhappy. The commentator had gone into detail to explain the value of the dickenpfeil, in his or her opinion, and this was the response. The putative error was neither corrected nor upheld. They're using *github* to host their blog, and they don't make revisions: that makes me feel like this person is putting erroneous crap out there and they don't even really give a shit. 2/10 would not read again. 
Thank you! I feel like I need to get a proper handle on the innards of JS before I can be good at programming with it. 
meteor is built with MongoDB and nodejs. And telescope is the easiest solution to setup such a site in no time. So no that's not a joke.
People should run their codes (well at least the ES6&gt; ones) before writing *fancy* articles imo (pointing at that IIFE for the onclick). Also what /u/LordAndrew said.
Yeah, and forget legacy support. But, these features are already (mostly) available in Node, yes?
&gt; For example, a developer from a “C” language background is more familiar to block level scoping, but will have difficulties understanding lexical scoping in JavaScript. This doesn't make any sense; block level scoping and functional scoping (javascript) are both a type of lexical scoping.
https://github.com/JustinDrake/node-es6-examples Correct me if I'm wrong, but it seems most of what was is stated the OP's link are available in Node 0.11 while some are currently available in 0.10. Looks like you just need to set some --harmony flags :)
&gt; Hi, Mithril author here. Hi! I really like Mithril, till now it's the simplest framework to address my experiments (and here I mean "simple" as a big compliment!) &gt; Have you considered looking at sweet.js? Yes! It would be more efficient. Now my proof of concept relies on runtime transpilation. The good thing about runtime is that you can change a VDOM with vanilla JavaScript before transpiling. I'm not an expert on sweet.js, but I'm afraid I'll end up to reinvent an entire language (as the several template systems reinvent a language instead of using JavaScript). &gt; I think interop between frameworks is a bit of a loftier goal. Personally, I don't think anyone would want to write code targeting an universal vdom because xkcd.com/927 :) I thought the same thing when I posted on Reddit. I know there is a risk in this operation, but as a frontend library author, IF the pros are strong, I could think to use an intermediate language for my components if I can target more frameworks. &gt; I think it's more realistic to think of tools to make existing components transpilable The problem with this approach (absolutely more pragmatic I admit), is that when you add data binding (even bidirectional), stateful components and custom component methods, it's tricky to obtain a reliable transpilar. I'm not even sure it's possible with an intermediate representation like the universal vdom, I'm working on something more than a proof of concept with my tcomb-form library as a real world example.
well, i guess .. good developer will want to get prepared for it. 
Right on the home page, http://mean-stack.io/ ... it just shows a blank page and throws these errors in the console.
Definitely! Thanks for the link - Subbed.
Well, for IE certainly, but the others aren't doing too badly. http://kangax.github.io/compat-table/es6/ has full details - the last release FF has 80/106 features implemented, Chrome has 69/106, and IE11 has 12/106 (sigh). Node is at 50/106. Getting there (and I'd certainly expect Chrome and FF to have the lot stable within the next year), but you're right that's it's not really in a place where you can use them without worrying about backward compatibility yet. The [IE status site](https://status.modern.ie/) has updates on their progress towards this, they're currently in development on the vast majority of it, presumably aiming for IE12. Otoh, there are good compilers to let you write ES6 and automatically port it back for better support ([Traceur](https://github.com/google/traceur-compiler)), or get most of the way just with runtime shims ([es6-shim](https://github.com/paulmillr/es6-shim/)). If you really want to, you can write ES6 all the time right now, and get it working through those. Debatable whether it's worth the cost of an extra build step in your case though.
Quite. All the new "fancy" stuff seems to boil down to non-JavaScript programmers wanting non-JavaScript methodology because they don't want to understand that JavaScript is a different language with a different way of doing things.
Hm strange I can not reproduce the error. Which browser do you use?
I agree, the way the author wrote it makes no sense but my guess is he meant to say that the function scoping of javascript might surprise someone used to block scoping. 
Google Chrome 39.0.2171.27 (Official Build) beta-m. User agent: Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.27 Safari/537.36
Pretty sure the fat arrow function example ain't gonna work either...
I love JavaScript. Having better syntax for 'let' and '=&gt;' is a huge win for everybody.
The author is using wrong adjective to describe js. My guess is that English is probably their second or third language and they have no reference for the nuanced usage of the word. I think the definition they were shooting for was "elaborate in structure or decoration (adj)" (from google) which no software developer would use to describe a language and which misses the positive nuance of the verb fancy. TLDR; Don't worry grandpa, you haven't missed the boat yet.
&gt; 'Hi, I am ${name} and my age is ${age}'; I haven't seen this until now but it seems like an exploit waiting to happen on the server side of things.
It’s not hard to write perfect articles in English without being a native speaker. In my country, we get taught English starting in the first grade, and you’re constantly exposed to it online, especially when you’re a programmer. Posters on reddit frequently think that I’m an American even though I have a horrible accent when actually talking.
As I already said Telescope, which is built with Meteor, is the easiest way to create a link sharing website in combination with MailChimp-support right out of the box. (The whole setup took me less than 2 hours.) And for me there is nothing wrong with using the cheapest solution to build an MVP and find out if there is any interest in a service like this.
Oh come it, it's exciting! For some of us we're seeing our favourite programming language come of age with some amazing new features that aren't available in a lot of other programming languages! List comprehensions, generator functions, template strings and a foreach loop we can use with arrays? Hell yeah!
It is not a problem. The string template has to be a literal and can't be supplied from elsewhere (i.e. from someone trying to exploit your server by getting at your variables). 
Yep. Unfortunately most of the features Node --harmony supports are oddly specific trigonometric functions like Math.asinh() that aren't really going to change anyone's life. I'd say the most useful additions are the string functions like String.contains(), maybe typed arrays (maybe??), and promises.
**I'm a big 'ol fan 'o dis right 'ere!** var { url, methodType, data2 } = config;
its being down-voted because jQuery. +1 for a solution that works
Fancy can be used with a derogatory tone to describe things that are overly-convoluted like the hoop-jumping current JS requires of you in some cases. The workaround was fancy in that someone figured out the elaborate incantation required to make it work and it required a more sophisticated understanding of JS to understand and use properly.
Oh, I'm actually using browserify too, not gulp-browserify. It looks like I can pass in src files as the first param and opts as the second param, unless it's just failing silently. ~~In any case, I still can't get my page to load properly. I see the generated bundle.js, and I see it downloaded, but nothing seems to be executing.~~ Edit: I removed the type="text/jsx" from the include, and it works fine. Also removed the react include at the top of the page.
&gt; someone used to block scoping. AKA, everyone that current colleges kick out. I don't know of any colleges that teach non-class based programming in their regular classes. Sadly.
Solution: use a module system. It's not the bad old days any more.
[node-jsx](https://github.com/petehunt/node-jsx) will let you use many of the new syntaces in JavaScript today. You can similarly use ES6 in browser-targeted code with [jsx-loader](https://github.com/petehunt/jsx-loader) for webpack.
I belive string templates require one to use backticks, to prevent breaking old code. http://tc39wiki.calculist.org/es6/template-strings/
I can highly recommend the [MEAN stack](http://mean.io/). Since you didn't mention anything about php, but for such a thing, you will surely need server side code. So it wouldn't be a bad idea to use server side javascript, which this stack gives you (through node).
several ES6 features were deployed in google chrome 38 http://blog.chromium.org/2014/08/chrome-38-beta-new-primitives-for-next.html
tl;dr The new IE compiles JS slightly faster than it used to. I don't know if I would call this a 'new trick'; it's definitely an improvement, though. Now if only MS would work on filling up [the compatibility table](http://caniuse.com/#compare=ie%2B11%2Cfirefox%2B33%2Cchrome%2B38%2Csafari%2B7.1). 
&gt; Math.asinh() that aren't really going to change anyone's life Perhaps not for many web apps, but I can see how asm.js and others might benefit. Having to reimplement asinh in js manually probably doesn't possess the same accuracy as a builtin.
Last I checked (a few months ago) V8 still didn't support fat-arrow functions and I think also template strings and maybe destructuring (and yes, I use `--harmony`). SM have supported fat-arrows and destructuring for a long while, so there's that at least. Looks like the next Firefox will add template strings as well. Those (and API changes, which seem to be pretty well-implemented in SM) are probably the ES6 changes I'm personally the most interested in. Hoping V8 catches up so I can use them in Node.
There are two things that could bring me to the "transpiling side": types and macros. For now I haven't found a good solution, given these concerns: - *Additional compilation step*. Ok, this is a minor point but still... - *You must learn two languages*. The exception is TypeScript being a superset and trying to adhere to the ES6 specs. - *Interoperability with js libraries*. It could be a pain (ffi). - *Runtime type checking is still necessary*. I don't want a `string`, I want names, surnames, emails, urls, patterns... I don't want `number`, I want integers, negative numbers, even positive numbers, ranges.. and I want null and undefined handled correctly. Otherwise I keep my sweet JavaScript. - *Make the boundaries of my system safe*. I have two choice: runtime checking again or write a ton of definitions and imports (a la d.ts files). - *Compiled javascript*. it's always a mess, or at least not idiomatic, so you can't discard easily the transpiling language later. Some languages (Dart for example, last time I checked) have a big runtime and have old browser compatibility issues. - *Macros*. Yes they are useful, but functions and function composition are already quite powerful. And there is always the threat of "a different language for every developer". However I hope you can destroy those concerns since I've tried to switch for years! 
I'm pretty happy with TypeScript: it is very much still JavaScript and the generated code is very idiomatic. I only wish there was a way to (optionally) use it's type system at runtime (I think what you mean with 'boundaries of my system'). Maybe it should support some keywords/pragmas or whatever to export/inline the types to like JSON so some other library can assert with that info. Have you looked at [sweet.js](http://sweetjs.org/) for macro's?
This is the link ya dodo: https://github.com/getify/You-Dont-Know-JS This looks pretty good to me.
The future is less grammar.
You're asking your question a bit prematurely. You can't meaningfully pick a library or framework until you know how those tools will affect your project (both positively and negatively). Start by planning out your application. You may find that you don't actually need to use a third-party library, or that one or two in particular will stand out. Keep things simple. Don't just use a library or framework because you think it's the "right" thing to do. Only use one when the benefits to your project are clear.
If it's your first project you could try rolling it yourself with a python, node or PHP backend. It would involve some fairly simple get/post requests, some JSON data, and read/writes to a DB. I think it's useful to understand the basics before using a framework. The tricky parts are ensuring your app prevents SQL-injection &amp; XSS, and that it authenticates, manages sessions and account passwords securely. So I would start with a simple "naive" implementation first then polish it off with better security. Then you'll know what to look for in a framework.
I updated all the sources for each video format, and it works well in all browsers on mac and windows besides Safari. Safari just says "loading..". I have an MP4 source update but I don't know why Safari isn't choosing it.
I know, I tried using it for this post but Reddit said it had been used last year. I just learned about this over the weekend and wanted to share it here (hopefully everyone clicks the link in the Hacker News post).
I'm here for you brother, I feel you. Can't help you though. I think the exact same thing about unit testing.
Testing helps a lot with catching bugs as you make changes to an app. And as you make a refactor, you have more confidence that the next deploy or release won't break something. It's not foolproof, but a good test suite helps a lot. Testing javascript with jasmine is typically unit testing. So you don't test the full stack, but more test bits of your logic. Your end to end or integration level tests cover a lot of the app. General features &amp; flow, but sometimes there's specific things you want to test, the nitty gritty that integration tests just can't quite touch well enough.
It looks like the article has an incorrect example. This can only be done in string literals defined using back-ticks, like the multi-line strings.
Testing is like safety net you build in order to experiment and grow your project. Once you make sure it is working as desirable, you may improve your code without the fear that it will break. Coded tests are also useful to ensure your application behaviours weren't damaged while introducing a new feature. You may rest that what was once working and covered by your tests is still working (and if not, your testing suite will warn you). Functional tests may be done using other tools, and can be done manually. And manual tests are also very useful. They'll catch usability nuances that may be harder to implement in a coding verification. One thing does not exclude the other. They make the safety net together. Even when you find a bug testing manually, you should create coded tests to ensure the bug is not going to play phenix with you as you continue your application development.
&gt; And there is always the threat of "a different language for every developer". This is my main worry as well. Restricting macros to those that can be expressed as valid js prior to compilation (eg. "function calls" which are inlined) should be relatively safe, though. Really not impressed with languages like Dart that bring along massive runtimes and terribly obfuscated code. ClojureScript is guilty of a similar crime, but a) ClojureScript's runtime mainly consists of of it's standard library (as opposed to internal plumbing) and b) it appears to be rather Closure Compiler friendly.
This answer might get big, but I'll try to tackle all your pain points, as I've felt them myself in the past. &gt; Adding test code to your project means more code to manage and the amount of code overall increases which surely means more bugs. You're totally right in the sense that more code === more bugs. Having said that, try following this approach for your next test: 1. Before writing code for the feature, write out the test. This will force you to define an "interface" (not a UI, think of it more in terms of input -&gt; output) and a set of expected results given various inputs. 2. Now you should have a failing test. Implement your code and make the test pass. 3. Optionally, you can now refactor your implementation code with the test as a safety net. 3. Does your feature need to cover more use cases than the first test you've written allows for? Go back to step 1. Once you have all the needed cases covered then your feature should be complete and with 100% coverage! I just outlined the basic principles of [TDD](http://en.wikipedia.org/wiki/Test-driven_development), so feel free to read up on it if you wish to dig deeper or something doesn't "click" right away. &gt; I think that wherever possible, testing end-to-end by actually using your app UI is going to be more efficient. The only reason that it's not as effective is because end-to-end, UI testing is **expensive**. Automating this procedure actually involves writing a non-trivial amount of code using a tool like [Selenium](http://www.seleniumhq.org). The actual testing process actually also takes a long time to complete, and this time grows exponentially as your app increases in complexity. The good thing about unit tests is that they're supposed to be contained (so they only touch *one* unit of code) and really fast to run. This means that your feedback loop, as you're developing, is extremely fast, meaning that if something breaks you'll know straight away. &gt; I've been spending all morning trying to debug an issue with a Jasmine test This falls into the realm of getting know your tools. Think of it not as time wasted but as a learning exercise. I'm sure you've spent similar amounts of time struggling with jQuery, Backbone, Angular or anything of the sort. Once you get to know Jasmine a little better and find out patterns for common tasks, you'll be just as productive writing tests as you're writing code nowadays. &gt; Please help me see the light. In the end, you'll commonly need both unit and integration test suites. The first can be used as an extremely quick feedback loop to help you know if your individual modules work as designed, and the second will be used to test the "glue" of your app: communication between modules, UI workflows, etc. They're both extremely useful tools to ensure that you're developing an application with as less bugs as possible. EDIT: Formatting
The best thing about JavaScript is that it was created in a very short time, and that short development cycle didn't allow for any scope creep. JavaScript is simple and easy, and it should stay that way. With ES6 it is starting to bloat. Feature creep is showing its ugly head. ES6 isn't JavaScript, it is a Frankenstein language, and it shouldn't be called JavaScript. The features it is getting are trying to please programmers from other languages, and that doesn't serve the JavaScript community well and it also won't lure developers from other languages either. Go ahead and downvote me if you must - but if you do, come back and read this comment in a few years. 
&gt; Classes are a nightmare. Proving MrBester's point. &gt; non-JavaScript programmers wanting non-JavaScript methodology because they don't want to understand that JavaScript is a different language with a different way of doing things.
There is a picture of a poop (background, right bottom side) that says clean it up in Russian. I am somewhat disturbed by it. "let" is amazing and should have been part of the language from the very beginning.
I can see your logic perfectly and I understand why if you were building from scratch it feels....pointless and possibly crazy to add more code just to test your code. I can give you a real life example, I'm working on a project now that has over 300,000 lines of code, there are roughly 6000 unit tests and 100 selenium tests. Would you feel comfortable refactoring anything or modifying any existing pieces? How do you know what you changed didn't affect 20 other features, do you have time to test 20 features every time you change something? Unit tests are also a way to document how your code is expected to behave, someone can look at the unit tests, see what is input and see what the expected output is without ever looking at the actual piece of code your unit testing. End to end tests are also important, but if you can catch some mistakes in unit tests it's easier and faster to run those before you push your next set of commits.
Because tests tell you when something is wrong. As a developer, you want to know when something is wrong, as soon as possible. If you want to change a bunch of stuff around, how do you know you haven't broken anything? You run the tests. Your level of confidence that you *actually* didn't break anything is directly correlated to how good you think your tests are. Part of being a good dev is learning to write tests well, it's just something you must learn. Part of that is "testing the test" so that the test does not falsely pass. A false negative is annoying, but you fix it and move on. If your test suite is non-deterministically throwing false negatives, you will either go crazy or disable the tests. Then you won't know when something is wrong! So you have to have good tests. Testing is part of the general idea that you should know what the hell is going on in your code base. Because when something breaks, if you don't know what's going on, your goose is cooked.
Well, TypeScript is still ol' JavaScript so I don't think they'll change the typeof and undefined mess. Although I find using TypeScript creates a clean coding practice that eliminates most undefined (t)errors. Anyway, as imperfect as it may be it still is most effective transpiler I know for improving JavaScript workflow. I don't like sweetjs/macros because of the ''different language for every developer' you mentioned.
Somewhat unfortunate the article doesn't mention tagged templates either. A pretty powerful, overlooked feature IMO. 
Unit tests are supposed to be fairly simple and quick to write. Their main purpose is to _simplify_ your testing and to catch regressions. For instance, let's say you write a ripple-carry adder (which is just a very low-level way of doing math that I had to do as one of my first CS projects in university). The input and output are absurdly simple, and your unit tests would simple be something like: adder( 2, 2 ).should.equal( 4 ) adder( -2, -2 ).should.equal( -4 ) ..etc You then go on to add test cases to catch things that are more "edge cases", e.g.: adder( 2^32, 2^32 ).should.equal( 2^33 ) which might test your 4 byte overflow, or: adder( 2^128, 2^128 ).should.equal( "1.16E77" ) If you go on to make this a full ALU and add multiplication, division, etc then your unit tests help to ensure that you're not breaking anything by introducing changes. I personally have my unit tests running _all the time_. As soon as I save a relevant file, the appropriate test runs against that file. If the test fails, I get a little notification that pops up on my screen saying exactly which test(s) failed. Think about it -- You're looking at code you haven't touched in 6 months, or perhaps you never have since someone else wrote it. You make a seemingly innocent fix for a bug, but your fix breaks another case _that you didn't even know about_. As soon as you save the file you get an alert saying "Hey, you broke something else". The alternative is that you push the code to dev, the regression possibly gets missed, it goes to production, and you get a bug report a week later on something you just "fixed". tl;dr -- Unit tests should only take a few minutes to write but can save you countless hours of time
Once you get used to your testing framework you can use it to debug your code base without clicking through the ui every time. Besides being a great debug tool, tests are useful for working in a team and to keep some control over a big code base. You don't need to test everything, you don't need to go full TDD, you don't need 100% coverage, but every little bit helps. Just go for the easy tests and don't obsess over test setup and and framework problems.
While I really understand your point, I can tell you from my own experience that testing is a great idea! I've been developing in JS (MooTools, and lately AngularJS) as well as Python (mainly single-page webapps). My MooTools projects I did without testing, but most of my AngularJS and the latest Python projects I've done with testing. Everybody knows that you can't write code the right way the first time. One way or another you will have to test what you're writing. In JS, I used to do this by implementing a part of my code, and then fire up a browser and test some parts of the implementation. Not everything off course, if just a part worked I thought the rest would hold as well. Also, it's not always easy to test every case from your browser, especially error handling. That's where the problem starts. At some point you're going to discover something's wrong, but since you've been working on several different parts of the app, you can't find what's wrong at first sight. You'll have to dissect everything and put `console.log()` at some 10 places to track some variables. This get's messy really, really quick. The biggest problem remains that you're not able to test everything!! When you apply unit testing you test every small part of an app separately. In that way you make sure that every little bit performs as expected. If it doesn't, you're able to fix that small part and continue on. Just yesterday I had a problem that makes a perfect example. I'm working on a tool to easily manage and maintain email aliases on [mailgun](https://www.mailgun.org). Right now I'm working on the backend which is a Python based REST API for an AngularJS frontend. I have aliases that can point to other aliases. To prevent endless recursion while going trough these nested routes, I built in a `recursion` list that saved the ID's of each route. class Alias: def getRecipients(self, recursion=[]): if self.id in recursion: return [] recursion.append(self.id) rec = [] for r in self.recipients: if isinstance(r, Alias): rec.extend(r.getRecipients(recursion)) else: rec.append(r) Some people who are experienced in Python will already noticed what is wrong, but I didn't see my error. So, unit testing. def test_getrecipients(self): a = Alias(5) assert a.getRecipients() == alias_a.recipients b = Alias(6) assert b.getRecipients() == alias_b.recipients Alias 6 (`b`) refers to Alias 5 (`a`), so it should include all the recipients from `a`. But, alas, it didn't. Hmn. Strange... I'll skip the debuggin, but the bottom line is that `recursion` points towards the exact same list for each instance of Alias, instead of creating an empty list if the argument `recursion` is not passed to the `getRecipients` method. So every alias that had `getRecipients` had been called on since the starting of the app would be skipped. Yaiks. If was easily solved by stating `recursion=None` and `if not recursion: recursion = []`. I actually don't want to know how much time it would have cost to debug this fault if it was implemented in the whole application. I would be left with behaviour that would depend on the order in which the routes are handled, as well as the complexity of the routes. It would result in hard-to-pick apart, opaque mess. So, I'm glad I included the tests and in an early stage identify my error and being able to solve it before any of it was used by a more complex application. I hope this case helps a bit. I can assure you that writing tests spares me time rather than costing time. And as an added bonus you get some extra satisfaction from the "18/18 tests passed" in bright green colours in your terminal.
Thank you for this. Beautifully written and very informative. I really enjoyed the quotes that preceded each chapter. 
So you recommend I get started reading API's? Or make my own stuff using tutorials or something? Thanks for your input!
inf0rmer's answer is good. But there is an even better reason to write automated tests. The tests are the very finest documentation of what you code should do and how it should be used. If someone comes along later and wants to use your API, the test cases provide example code exercising it exactly as intended. And remember, 6-months-from-now-vt97john is a different person from today-vt97john. You'll be the one needing that documentation! It's worth adding that badly-written unit tests will break often as you add new features or update your application. As you get more experience with automated tests, you'll learn to write them so they don't break as often.
Another reason for unit testing is that it helps with scalability. After the code base grows beyond a certain size or complexity, managing the secondary effects of making code changes can potentially become more difficult than making the code changes themselves. Unit tests help track where those secondary effects are. This becomes much more important once the developer base grows large enough that individual programmers can't be familiar with the entire code base. Unit tests help programmers to add a new feature in unfamiliar code without breaking something.
Yeah right, I understand what you mean, focus on the objective and when you're facing problems try to find the appropriate tool. Is that correct ? Thank you.
I find the greatest value in unittests comes as I inevitably go to refactor something or as I add or remove functionality. With large application, I can't take the time to manually test that everything "still works as it's supposed to." When I have a full suite of tests, I can make my changes, run my tests, and feel pretty good about the result.
Right, I'd rather write the server code in js than in php, as soon as my application is planned I will take a look a this . Thank you.
I recommend Kyle Simpson's You Don't Know JS series (also check out his video course on Frontend Masters), Douglas Crockford's JavaScript the Good Parts, Object Oriented JavaScript from Packt Publishing. Lastly, it's kinda geared towards beginners, but check out Kirupa Chinnathambi's website: www.kirupa.com
Welcome to the wonderful world of floating point numbers.
I dunno, the logic around parseFloat has always been weird, and highly dependent on implementation. I wouldn't be at all surprised if you got different results with different JavaScript engines. Whenever I want to ensure a (more) consistent behavior, I just make everything a Number and then display it using toFixed().
For general JavaScript, I've seen numerous people round here recommend this: eloquentjavascript.net
I'm vaguely recalling someone telling me that javascript is not the best language for math operations. This is beginning to make sense.
That's what I thought. Would you be willing to help me with the API ?
A good developer doesn't need ES6 to get work done. ES6 seems purely a push to make Javascript more like other languages, which is a huge mistake. Javascript should remain javascript. It doesn't really need the new features being proposed. The things that could use fixing aren't getting attention. It's a huge debacle, but new devs eat it up because they don't know any better.
Well at least I'm not the only one who notices weirdness with parse float. I'm still curious as to what's going on under the hood but toFixed() will work for my use case. Thanks.
Or to translate the angular js or curl code they have into vanilla js?
No, not for everybody. I don't need "let" or fat arrows to get things done with javascript. And ES6 isn't javascript, it's a "franken-language". 
That's not valid javascript. 
How much is "a lot" to you, maybe 5 or 6 devs? ES6 isn't even a standard yet and most platforms only support a very limited subset of its proposed features. If there are devs using ES6, they aren't doing serious work with it, and if they are they are idiots.
Why don't you write a simple loop and test it?
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Double-precision floating-point format**](https://en.wikipedia.org/wiki/Double-precision%20floating-point%20format): [](#sfw) --- &gt; &gt;__Double-precision floating-point format__ is a [computer number format](https://en.wikipedia.org/wiki/Computer_number_format) that occupies 8 bytes (64 bits) in computer memory and represents a wide dynamic range of values by using [floating point](https://en.wikipedia.org/wiki/Floating_point). &gt;Computers with 32-[bit](https://en.wikipedia.org/wiki/Bit) storage locations use two memory locations to store a 64-bit double-precision number (a single storage location can hold a [single-precision](https://en.wikipedia.org/wiki/Single-precision_floating-point_format) number). Double-precision floating-point format usually refers to __binary64__, as specified by the [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point) [standard](https://en.wikipedia.org/wiki/Standardization), not to the [64-bit decimal format](https://en.wikipedia.org/wiki/Decimal64_floating-point_format) __decimal64__. &gt; --- ^Interesting: [^Floating ^point](https://en.wikipedia.org/wiki/Floating_point) ^| [^Single-precision ^floating-point ^format](https://en.wikipedia.org/wiki/Single-precision_floating-point_format) ^| [^Half-precision ^floating-point ^format](https://en.wikipedia.org/wiki/Half-precision_floating-point_format) ^| [^Quadruple-precision ^floating-point ^format](https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+clev4la) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+clev4la)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Great comment. I came into this thread because I confess I've also felt a bit perplexed by code-to-test-code, and what you've said here really helps to cast it in a different light.
why are you setting 3 variables to the same value?
&gt; you’re Correct use of you're, not native speaker checks out.
Nice, I'm just getting ramped up on Node at work... this table is beautiful. And kinda sad at the same time. 
Well, fat arrow functions work the way he describes, just not the way he coded it. var Greeter = function (greeting) { this.greeting = greeting; }; Greeter.prototype.greetEveryone = function (names) { return names.map(name =&gt; `${this.greeting}, ${name}`); }; var frenchGreeter = new Greeter('bonjour'); frenchGreeter.greetEveryone(['Tim', 'Janice', 'Alex']); // =&gt; ['bonjour, Tim', 'bonjour, Janice', 'bonjour, Alex'] `greetEveryone` will work correctly, because the fat-arrow function syntax does not change the value of `this` in its scope. The reason it won't work as OP coded is *because* the value of `this` doesn't change … meaning that it will be pointing to `window` in this case. **Edit**: More ES6 sugar because why not.
Yeah, I meant it would be nice if: var obj = { name: 'Jerry', sayName: =&gt; { console.log( this.name ); } }; worked, but as you said I believe `this` will point to `window`. I think the main use I'll find for fat arrow's screwing with `this` is I won't have to use .bind() when I'm binding an object's method to an event. I would have preferred if it had just left `this` alone so I could use it everywhere and not have to worry about it.
For me, it's mostly a safety net for fixing bugs, adding new features, and for new developers ramping up. You can't possibly know all the places that rely on the code you're modifying, so having good test coverage ensures that those other areas are verified automatically for you. If you unwittingly break something else, you'll know and can address it ahead of time. Relying on manual testing for that means that you'll likely be neck deep in something else by the time you find out that you broke it, or worse, QA didn't test it because they didn't think it would be affected. Being able to modify code, then run the tests and see what breaks is also a good way to learn dependencies in your system, and potentially identifies areas for removing tight coupling.
You can think of tests as an automated QA person who never gets tired, works 24/7, and absolutely 100% tests everything every time at the drop of a hat. Getting good at writing tests is a skill just like any other programming skill. It takes experience to get a feel for what types of tests are effective and which ones aren't.
I think that if you can quickly test end-to-end, that is the preferred solution. I don't use unit tests for small projects. However, big projects quickly reach the point where testing every feature takes a long time. If you have to spend 2 hours trying every function every time you add something or change something, testing starts to make sense. It's a quick way to say "Given this thing I just changed, is everything else still working the way it used to?".
[Devdocs](http://devdocs.io/)?
That's why you don't write code to test trivial things. Test high-level complex behavior. Take Reddit, for instance. You could test things like Post a comment with text 'xyz'. See if the resulting comment is 'xyz' Posting a comment is a pretty complex procedure that can fail in many places (we're talking due to bugs only): The client has to: * grab the comment text from the form * submit it to the server along with the cookie/session, and CSRF tokens, parent ID, etc The server has to: * check the user identity * make sure the comment is for an existing post * make sure the user is allowed to comment (e.g. not banned) * apply the markup * sanitize * store in the db * update all kinds of caches and comment counts So your simple test checks that all these steps work (or at least don't fail). 
clojure depends on the closure compiler to produce something of a sane sized application. The closure compiler on its own is really excellent, one of the design goals is to run the application without having to compile (dev mode) as well, which is super handy. Also a warmed up jvm works wonders for compilation speeds.
Check out closure compiler, easy to write your own compiler plugins (something which lacks in Typescript along with tree shaking) 
Encapsulation what?
There is a bug in your code: for(var j=i-1; j &gt; -1; j--); person.friend(mem[j]); that person.friend line will only execute once. Look at that semicolon.
Dash? - http://kapeli.com/dash
If someone says I don't know js, who am I to argue?
Just had one of these come up today in our app. In the last year I've completely rewritten it. I also added 500 some unit tests for the most crucial code. Today my boss made a little change, 8 errors popped up. He said "well, I change 4 lines and get 8 errors, at least we know things are tested. makes me feel better." In the end, that's what it is all about. I can go to sleep at night knowing my code won't break under the common uses.
It *does* just leave `this` alone, though. That's what makes it unique. Creating a function is what screws with `this`.
Riiiight, so TC-39 and implementers only cater to non-JS programmers? News to me, seems pretty strange for the JS standards body and JS implementations to cater to people barely even use their product.
It essentially proves what you wrote actually does what you expect it to do. That way whenever you make a change in code, you verify that you didn't break something that was outside the realm (or inside the realm of) of what you just changed. It's good for when you have a very large code base to ensure changes don't break things without having to manually test every piece of your application.
I suppose the standard points apply. - javascript is not a classical programming language - `new` and convenience classes added in JavaScript are just sugar - it's better to do `{}` instead of `new Object()` or even `Object.create(..)` have you tried running your tests on newer versions of node? `0.11.x`
I used to think exactly the same way but I recently inadvertently made tests for a system I was working on to take a string of user entered text and convert certain syntax into HTML elements using regular expressions (for copying memos for call center interactions). I made a page that displayed the array of options available in the system (like put [v] to make a checkbox that is checked by default for example) and had buttons that would allow you to test the input you were seeing. When adding new features to the system I found that those tests that I had made for the user were actually super valuable to me as the developer in making sure that all of the features I had made previously still worked. I still have a lot more to learn about testing but this really demonstrated it's value to me. 
Think of it as future-proofing your application. You're making sure that anyone who changes your application in the future (including you) is not breaking any functionality that's currently working. Writing tests is more like formalizing the requirements in the same language as the code rather than a vague language like English.
&gt; their codes ಠ_ಠ
I suspect that's because Rails has a built in ORM. String interpolation is only really an issue if you're using it to insert user variables into SQL without escaping, which is definitely an issue in PHP.
would be nice if you could undo a cut.
It's valid ES6.
I may never fully understand it, but I try.
For a 1 man show unit tests are also a really great way to be able to work slowly on a bit of code. By "slowly" I mean that every few months you come back to the code for a few days. With unit tests you can see what's working and what's not. Without the unit tests not only do you have to remember all the code you have to remember "oh yeah I was gonna fix X, Y, Z" and you have to remember all the places where a change you're making might impact.
Unit tests are first appreciated in v1.1
oh thats cool. Thanks for the explanation
Just wait until you find out it also works for arrays and can be arbitrarily nested. Oh, and there's a [~~rest~~spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator) that replaces the need to mess with `arguments` or `Function.prototype.apply`.
If your app is that big and changing one things affects so many other things then clearly you have some architecture problems. Just my two cents... :)
The objective is not to write code to test code, it is to **automate** the tests and run them **all** as **often** as possible to prevent **regression**. Yes, this is more code to maintain, but its worth it most often.
A lot of good points have already been mentioned. There's another benefit of writing tests which I'll explain. Say for example that you're trying to write a test for a particular function. As you write the test you'll notice that there are numerous external dependencies that the function relies on and you'll attempt to mock those dependencies. It will become very clear that the function is completely out of whack and testing it is hard and or confusing. That will indicate to you that the function needs to be simpler. This will take time but your ability to write better code will improve, because you'll subconsciously be writing code that is clean and simpler to test. Finally tests are critical to have with an application that you plan to continuously support. It becomes nearly impossible to add or change any functionality without knowing if you completely borked other parts of the application.
I have managed 5 development projects for applications deployed at a remote facility 2000+ miles away. Every one of these projects is at 80% test coverage or higher. In the past eight years we have had less than 15 support calls to resolve defects in these applications. That's the proof to me.
Well I know that 90% of Angular projects run on Karma+Jasmine because that is what majority of examples and tutorials teach. I would be quite interested in what the world outside Angular uses...
It's not that `parseFloat()` is doing any rounding. That's not how you should look at it. The way you should look at it is that neither 34.799999999999997 nor 34.8 can be represented exactly by binary floating point. The closest representable IEEE double is 34.7999999999999971578290569595992565155029296875. As you can see, that value lies in between 34.799999999999997 and 34.8. That is, if you ask, "What is the nearest representable value to 34.799999999999997?" the answer is "34.7999999999999971578290569595992565155029296875, which is slightly larger." Likewise, if you ask, "What is the nearest representable value to 34.8?" the answer is, "34.7999999999999971578290569595992565155029296875, which is slightly smaller." In other words, as far as IEEE binary floating point numbers are concerned, **34.799999999999997 and 34.8 are equivalent values.** They are two different ways of referring to the same number, 34.7999999999999971578290569595992565155029296875. When given a choice between two representations for the same number, the smaller or more compact one is chosen. This is an implementation detail, but it's one that's commonly made. 34.79 also is impossible to represent exactly in IEEE binary floating point. The nearest representable IEEE double is 34.78999999999999914734871708787977695465087890625. So when you write 34.79, you're getting 34.78999999999999914734871708787977695465087890625. As before, when displaying a floating point number, the library routines try to find the smallest representation that still round-trips to the same number. That's why 34.79 is the result of printing 34.78999999999999914734871708787977695465087890625 and not 34.78999999999999914734871708787977695465087890625. As a thought experiment, we can undo this choice, however: parseFloat("34.799999999999997") == 34.7999999999999971578290569595992565155029296875 parseFloat("34.8" == 34.7999999999999971578290569595992565155029296875 parseFloat("34.79") == 34.78999999999999914734871708787977695465087890625 That's what's actually going on. Those are the real values that you're using. It's just that for display purposes, people don't want to deal with 34.7999999999999971578290569595992565155029296875. If two things both result in the same value, they are equivalent, and the smaller one can be used as a representation. 
https://www.youtube.com/watch?v=PZRI1IfStY0
Many excellent answers have already been given, so I'll confine myself to a metaphor: It's **error-correction code**. Fundamentally, you can make an error writing your code. There is some probability of writing code with an error you don't detect. Likewise, there is some probability of making an error when writing your tests. Fair enough. Writing code + tests increases the number of errors you will make, it has to! But the odds of making an error in both code and tests in such a way that they cancel each other out and the code and test both appear to run properly is much, much smaller than the odds of writing an error in your code if you didn't write any tests.
So true. The tests are the best documentation you have of the project. Any new devs added to the team should be able to use the test suite to learn how the product works, feature by feature. I was able to get up to speed quickly at my latest job because the first few tasks were updates to a module with excellent test coverage. 
Good eye, took me a sec to realize the issue after staring at it for a few seconds. The results after fixing the semicolon: $ node test.js abstractions abstraction time was: 1252050683 nanoseconds abstraction memory was: 386.22 mb $ node test.js userobject user object time was: 1240053629 nanoseconds user object memory was: 386.71 mb $ The world is back to normal now.
What problems have you had? I use [grunt-mocha-istanbul](https://github.com/pocesar/grunt-mocha-istanbul) for server side mocha tests, but it supposedly also works for client coverage reporting.
Please read up on reddit's rules @ http://reddit.com/rules, specifically point #1 of rule #1. Our [guidelines](http://www.reddit.com/r/javascript/wiki/index) also have more information regarding promotion &amp; self-promotion. **Consider this your only warning.** If you continue to post _only_ your site, we'll be forced to take action. Thanks for your understanding.
Please read up on reddit's rules @ http://reddit.com/rules, specifically point #1 of rule #1. Our [guidelines](http://www.reddit.com/r/javascript/wiki/index) also have more information regarding promotion &amp; self-promotion. **Consider this your only warning.** If you continue to post _only_ your site, we'll be forced to take action. Thanks for your understanding.
Please read up on reddit's rules @ http://reddit.com/rules, specifically point #1 of rule #1. Our [guidelines](http://www.reddit.com/r/javascript/wiki/index) also have more information regarding promotion &amp; self-promotion. **Consider this your only warning.** If you continue to post _only_ your site, we'll be forced to take action. Thanks for your understanding.
Removed, please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
The problem with TDD is that it's contradictory to agile methodologies (not that I agree with agile). The design and requirements are constantly changing. In agile there is no concrete interface to create as nothing is concrete. Trying to only results in spending more time refactoring the interface as the requirements change next sprint. This is a problem with agile not TDD, but many shops try to aspire to both. TDD wants at least some semblance of a design document. Agile is a couple drunk squiggles on a cocktail napkin. 
Not totally true. As you alluded to, it is possible to write badly written programs that even a slight change makes the world come crumbling down... But, in the real world, applications are not always small. Applications have dependencies. Sometimes hundreds of dependencies. Now say, one of those dependencies changed. Even if the change was a bug-fix, the application code is no longer interacting with the dependency in the same way as it did before. And sometimes you'll get bugs. Even medium and small-sized applications have this same problem. The scale of the application just exacerbates the issue, but like a car, multiple things may depend on the functionality of one larger thing. That does not suggest it was poorly designed.
Karma can work with mocha.
Can you elaborate on bad decisions?
Dude, where the hell has this been all my life?
I didn't know that. Thanks, I'll look for it next time.
Testing your code is unnecessary if you can write flawless code every time. When you were learning to code did you learn to occasionally put in a “println” statement to see “how far” your code went before it failed? These markers are crucial in figuring out what section(s) of your code need to be altered. 
This. I can't tell you how many times i've made a very innocent change that has completely blown apart hundreds of my unit tests. Note, the application worked PERFECTLY fine for most uses, but broke so many corner cases. Without unit tests i'd be spending 99.9% of my time trying to debug a one line code change....
We use Jasmine for unit testing Marionette/Backbone and are thinking of adding integration testing with Pioneer eventually. I personally really like Mocha but we already had Jasmine integrated with Rails and Guard when i was started working there. I have no complaints about Jasmine except that spies can be difficult sometimes with Backbone.Event mostly with Marionette's pub-sub messaging bus. We use Rosie for building factories and use Jasmine's Ajax.Mock for test responses on ajax requests to check that 'box:error' and other events are being triggered with bad responses. We also use Jasmine's DOM library for checking if elements exist on the page which isn't all that difficult without the library but it's helpful in some scenarios.
You don't need it for everything. It is worthwhile though for low level code that you are likely to break with future modifications.
One thing that you might not have noticed yet is that since unit tests are code, you can fashion a way to have them run automatically. For example, most of my projects have scaffolding for tests that automatically run when I save / modify a relevant file. This way, I can catch a lot of breaks I've accidentally introduced into my own code right when I make them. And while it is true that more code === more bugs, unit tests (in general) are fairly simple to write. You'd normally write your tests as you'd expect to use your interfaces anyway, so if a test breaks, the benefit of the doubt is generally in favor of the test, not the code it tests. One good way I've structured my tests in Jasmine is to have a `describe` spec for a logical body of code (say a file, or a prototype). I also put in nested `describe`s for functions on the body of code. Then I pepper my specs with as many `it` tests as I can think of in use cases. I also try not to think too much of whether I've written enough tests; when a bug comes up (and they will), put in the fix, write the test/s that catches the bug, and you can rest your head easy that you won't change anything in your code that'll reintroduce that bug again in the future.
1) Yes, modifying built-in prototypes is highly frowned upon. I personally will not accept _any_ commit to _any_ project that modifies any native prototype (the _sole_ exception being polyfills for accepted features). But not because it confuses people (I actually prefer the syntax), rather because it's unstable. This is especially true in Node.js where two libraries (or even two different versions of the same library) could very easily create the same method with different functionality. 2) No, it's not alright. Crockford is plain wrong here. But again, you could easily document these so that's not why. 3) Same as 1) and 2) In general, any book you read on programming should be taken as advice, not requirement. Crockford's especially, since he's an arrogant ass that is not only wrong a lot, but that completely flips his own advice every couple years. &gt; Aside: I also hate, hate, hate semi-colons. That's one syntax convention Crockford won't convince me of (at least in node.js). You're so absurdly wrong on this point. Semi-colons provide clarity, and in some cases they're _necessary_. Not using semi-colons except when necessary is just craziness that only leads to errors. Crockford is (somewhat) correct on this point -- Any feature that provides zero benefit and causes bugs should be avoided. Not using semi-colons is the very definition of this (or the definition of "not this" I guess)
Sorry, but if the tests are the best docs, then you need to write more docs! You should be able to describe a module, it's functions, and interesting edge cases much more efficiently in words, and I'm sure your maintainers would rather read a few pages of docs than 6000 unit tests. Now, tests do have one advantage: they're always up to date! (At least, the ones not commented out.)
I think the first method is preferred over the latter. Looking at most libraries you will rarely ever see the second technique. Crockford is a good philosopher but what libraries has he actually built? Look at Backbone, Underscore and Marionette or any other library you'll see class.prototype all over.
Presumably one that doesn't lead to minor changes affecting so many other things?
Yep his recommendations change over time. In general by moving from OO design patterns to functional. If you are going through JavaScript the Good Parts it may be worth seeing his recent suggestions from JSConfUY 2014 (jumped to the "Good Parts Reconsidered" section) https://www.youtube.com/watch?v=bo36MrBfTk4#t=1135 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**IEEE floating point**](https://en.wikipedia.org/wiki/IEEE%20floating%20point): [](#sfw) --- &gt;The __IEEE Standard for Floating-Point Arithmetic__ (__IEEE 754__) is a [technical standard](https://en.wikipedia.org/wiki/Technical_standard) for [floating-point](https://en.wikipedia.org/wiki/Floating_point) computation established in 1985 by the [Institute of Electrical and Electronics Engineers](https://en.wikipedia.org/wiki/Institute_of_Electrical_and_Electronics_Engineers) (IEEE). Many hardware [floating point units](https://en.wikipedia.org/wiki/Floating_point_unit) use the IEEE 754 standard. The standard [addressed many problems](https://en.wikipedia.org/wiki/Floating_point#IEEE_754_design_rationale) found in the diverse floating point implementations that made them difficult to reliably and portably use. The current version, __IEEE 754-2008__ published in August 2008, includes nearly all of the original [IEEE 754-1985](https://en.wikipedia.org/wiki/IEEE_754-1985) standard and the IEEE Standard for [Radix](https://en.wikipedia.org/wiki/Radix)-Independent Floating-Point Arithmetic ([IEEE 854-1987](https://en.wikipedia.org/wiki/IEEE_854-1987)). The international standard __ISO/IEC/IEEE 60559:2011__ (with identical content to IEEE 754) has been approved for adoption through [JTC1](https://en.wikipedia.org/wiki/ISO/IEC_JTC1)/SC 25 under the ISO/IEEE PSDO Agreement and published. &gt;==== &gt;[**Image**](https://i.imgur.com/a6MQaKT.png) [^(i)](https://commons.wikimedia.org/wiki/File:IEEE754.png) --- ^Interesting: [^IEEE ^754-1985](https://en.wikipedia.org/wiki/IEEE_754-1985) ^| [^Floating ^point](https://en.wikipedia.org/wiki/Floating_point) ^| [^Significand](https://en.wikipedia.org/wiki/Significand) ^| [^NaN](https://en.wikipedia.org/wiki/NaN) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+clfbv0n) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+clfbv0n)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I've found that refactoring is the hard part of almost every change. Every change that isn't easy.
As crockford say: "Is JavaScript object-oriented? It has objects which can contain data and methods that act upon that data. Objects can contain other objects. It does not have classes, but it does have constructors which do what classes do, including acting as containers for class variables and methods. It does not have class-oriented inheritance, but it does have prototype-oriented inheritance. The two main ways of building up object systems are by inheritance (is-a) and by aggregation (has-a). JavaScript does both, but its dynamic nature allows it to excel at aggregation. Some argue that JavaScript is not truly object oriented because it does not provide information hiding. That is, objects cannot have private variables and private methods: All members are public. But it turns out that JavaScript objects can have private variables and private methods. Of course, few understand this because JavaScript is the world's most misunderstood programming language."
I'm a node developer, and at my job we always ensure unit and integration test coverage for all functions we write. Here's why: When you're writing code, you may not be writing an entire application at once. You're probably only working on a small part of it. So you need to be able to *quickly* test your chunk of the code to make sure that it works. It's not always feasible to run the entire application to check some corner-case behavior of your module, especially because there may not even be support for that feature yet, so how do you know that it works? You write tests. You specify the input and output and call the function. The idea with testing is to execute all of the code and get expected results in all branches. You can run over a hundred tests in less than a minute, for example -- good luck doing that with e2e! As an example, I'm currently refactoring a rather large module. How do I ensure that I didn't break anything? I run the tests! I don't have to try every little scenario to see that things work. Then there are the bugs -- the whole point of testing: &gt; the amount of code overall increases which surely means more bugs Yes, you get more bugs. But bugs are only bad if you *don't* find them! If your test is buggy, it will probably fail. You'll look at the test that failed and debug it. If the code is buggy, the test will fail. You'll look at the test that failed and debug it. And test code is generally very repetitive, which means you're less likely to make a mistake while writing it. Now, I've had bugs that have gotten around the unit tests -- one such bug had to do with the format of some input data. The code was working perfectly fine with the test data, but the test data was in the wrong format, and the code was breaking with the real data. Whoops! Unit tests are not a substitute for integration tests or e2e. They *all* need to be done. Bugs can pop up anywhere, but for bugs to pop up in *both* tests and code and for them to cancel out, that's unlikely! So if you have adequate test coverage, you can be pretty confident that your code is *less* buggy by a *lot*, even though there's more of it, because of the tests. Finally, there are some things that are easy to test via the UI, but there are some things that aren't. For example, let's say your app implements some sort of security by IP range. How do you test that? You have to try IP's in different ranges... but you don't have those IP's! The way to do it is to mock it in code, and feed it an appropriate IP yourself. And this security might well be *way* behind the scenes, so you wouldn't be able to see anything from the UI without some considerable difficulty. How do you ensure that your code is behaving the way it should? Tests. Manual testing, while important, is a HORRIBLE way to see if *all* of your code works the way it should. You may even forget to check some things, because humans are fallible. Put it in code and you don't have to worry about it anymore. If there's a bug, the test suite will catch it so that you don't have to.
Ever since JavaScript first came out there have been people complaining about the lack of "classic" OO. It's like water dripping on a rock.
First rule about test driven development: your test has to fail first, then you have to write code to make it pass, not the other way around. This way you will ensure that you don't have any false positives (or at least it will reduce the chance of happening).
Have you really worked on a non-public project that keeps it's non-code documentation up to date? It's a nice thought, I'll give you that, just never seen it happen before.
Fair enough
Tell that to the Angular or React developers.
WTF? Just use node's EventEmitter. Most sane people are using browserify these days anyway.
Please read up on reddit's rules @ http://reddit.com/rules, specifically point #1 of rule #1. Our [guidelines](http://www.reddit.com/r/javascript/wiki/index) also have more information regarding promotion &amp; self-promotion. **Consider this your only warning.** If you continue to post _only_ your site, we'll be forced to take action. Thanks for your understanding.
You test only your public interface While this is more about ruby the premise applies to any language. http://youtu.be/URSWYvyc42M This knowledge changed how I write tests for the better. I can't stress how important see a failing test is. It sounds to me like your tests are brittle and require list of work to change when I requirement changes. What Sandi Metz teaches us is what to test an what not to test. Her space capsule example is excellent.
Thanks for the advice .
The clients get the official state of the data from the server, though they are allowed to diverge temporarily until their operations are acknowledged by the server. The state on the client is not taken very seriously, only the operations the client generates are. Meteor doesn't do anything fancy to enable offline support (yet). But there's nothing to stop you from making your operations be CRDT operations, or from queuing them while the user works offline and then sending them unconditionally when the user reconnects. What's interesting to me is that I don't think that's as widely applicable a strategy as people often imply when they view a web app as a distributed system.
This is pretty rad: http://wavepot.com/?r
The crux of testing IMO is that it provides not only evidence that your application works as expected, but also a safeguard against it breaking. If someone makes a change to your application that introduces a bug, the tests can alert you to that fact automatically. This is a good thing especially in large teams. Writing test code can take a while, and can be boring, but usually it isn't too taxing as long as your application is well-written in the first place.
This is a micro-optimization and your benchmark is optimized away. https://www.youtube.com/watch?v=65-RbBwZQdU&amp;hd=1
Crockford created jslint, json and to my knowledge as Yahoo's chief JS engineer was also involved in the design and creation of YUI (which is used as the basis of other frameworks like Sencha). Although I think he's wrong in this case (and his opinion about fixed point), I think that he's generally correct in his suggestions.
From a framework standpoint I am a huge fan of Angular.js. Been developing web pretty much from the beginning and this is, to me, is the best solution thus far. Choose your back-end, I am partial to Node.js.
test runner (node): node test.js run a directory of tests (node): tape test/*.js code coverage (node): covert test/*.js test runner (browser): browserify test.js | testling run a directory of tests (browser): browserify test/*.js | testling code coverage (browser): browserify -t coverify test/*.js | testling tests look like: var test = require('tape'); var somelib = require('./'); test('whatever', function (t) { t.plan(1); var s = somelib(); t.equal(somelib(5), 555); }); output (node): $ node test.js TAP version 13 # whatever ok 1 should be equal 1..1 # tests 1 # pass 1 # ok output (browser): $ browserify test.js | testling TAP version 13 # whatever ok 1 should be equal 1..1 # tests 1 # pass 1 # ok pretty output (faucet): $ node test.js | faucet ✓ whatever # tests 1 # pass 1 ✓ ok pretty output (tap-spec): $ node test.js | tap-spec whatever ✓ should be equal tests 1 pass 1 Pass! For each of these tools, there are dozens of other unixy approaches that you can swap in to any section of this workflow. Because everything is shell pipelines, this approach works particularly well with [npm run](http://substack.net/task_automation_with_npm_run) or a makefile. Other stuff like mocking or shimming is a minefield of bad ideas and fragile approaches and there is usually a better approach like more explicit parameters. Longer version: http://substack.net/how_I_write_tests_for_node_and_the_browser Aside while I'm here: what's up with globals and test harnesses? It seems like every test runner pukes a bunch of globals all over your code. Why is that wrong everywhere else in programming but somehow it's ok for test runners?
I totally share your opinion. There is a developer on my team who loves writing tests. He writes the tests first, as people in this post suggests, and then writes his code to pass the test. This is great except that he misses test cases in his test script, so even though the tests pass, the code in production still fails. On top of that, it takes him twice as long to complete his tasks each time, and the code is still buggy.
We work only with AngularJS and Node at work. It's a really nice framework to work with day to day. 
probably u are right. as a new coder, i think it should be like developing the frameworks that does the job, node, angular, backbone, etc etc. 
apologies if its not appreciated here, or violates sub-reddits policy. will remove it if admin asks. 
&gt;Emscripten is an LLVM-based project that compiles C and C++ into highly-optimizable JavaScript in asm.js format. This lets you run C and C++ on the web at near-native speed, without plugins. http://kripken.github.io/emscripten-site/docs/introducing_emscripten/about_emscripten.html
glad you like them. HTML5 All in One for Dummies is my latest, and it has more up to date php than the php series.
This is very important, when you report a bug a few hours or the day after the problematic change has been made, it is way easier for the programmer to dive back into it and change it. If you find the bug one month later, you have to re-familiarize yourself with the context of the code change.
Isn't there already a Shakespeare programming language? Edit: http://en.m.wikipedia.org/wiki/Shakespeare_(programming_language)
Pastebin appears to be down (under heavy load) - maybe try and find somewhere else to post your code?
Dude... learn to use your debugger.
I perceive the semicolon aversion as a hipsterism at the expense of clarity Edit: oops, we agree..that was the quotation (just skimmed)
Is it just me or is node.js and its creator not nearly as interesting as the others in your list? I just don't see node.js as being that substantial...But sure...it may be in vogue but I don't see it lasting
I'd agree with this, but meteor seems to have stagnated or just doesn't get nearly as much press these days. I do hope it succeeds, but am skeptical that the problem they're solving may be at a layer too high which imho makes it kind of a hack rather than a solid foundation for a new paradigm
Production servers.
Glad to see this is still around. Still a great overview over the advanced JS concepts. I once learned a lot from it.
Been in development 10+ years, 6+ companies ranging from Fortune 500 to 3 employees. I've literally never seen docs that were anywhere near what you describe. The best I've seen is a stale architecture diagram. The beauty of tests over docs is that you'll actually know when the tests are stale (they fail). If docs get out of date, nothing happens. 
That's silly. If you're coding right (i.e. reuse) one method will be used in many places therefore changing that one method will affect many things.
Do it for a while on faith and then you will come to realize the benefits. **NOTHING** has saved my behind more than having good unit tests when making a change to existing code. Tests are also a much better indication of what the code was "intended" to do than any other mechanism (specs, docs, code comments, etc.) Beyond that... UI testing is the most expensive and resource intensive kind of testing. Other forms of faster, cheaper testing are used to get a tighter feedback loop on errors. Besides, what do you think your UI tests are written in... pixie dust? They are code too. Unless you are talking about manual testing in which case you have lost all sense of reality and need to seek help. ;-p 
Just answering for OP..
Well if someone is changing my code then they might have to change my test code as well and possibly get that wrong. Now i have to worry about them breaking two different things.
Fair enough
This is why there's the [Open/Closed Principle](http://en.wikipedia.org/wiki/Open/closed_principle). You want people extending your code and writing new tests, not modifying your code and changing your tests.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Open/closed principle**](https://en.wikipedia.org/wiki/Open/closed%20principle): [](#sfw) --- &gt;In [object-oriented programming](https://en.wikipedia.org/wiki/Object-oriented_programming), the __open/closed principle__ states "*software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification*"; that is, such an entity can allow its behaviour to be modified without altering its [source code](https://en.wikipedia.org/wiki/Source_code). This is especially valuable in a production environment, where changes to source code may necessitate [code reviews](https://en.wikipedia.org/wiki/Code_reviews), [unit tests](https://en.wikipedia.org/wiki/Unit_tests), and other such procedures to qualify it for use in a product: code obeying the principle doesn't change when it is extended, and therefore needs no such effort. &gt; --- ^Interesting: [^Strategy ^pattern](https://en.wikipedia.org/wiki/Strategy_pattern) ^| [^Single ^responsibility ^principle](https://en.wikipedia.org/wiki/Single_responsibility_principle) ^| [^SOLID ^\(object-oriented ^design)](https://en.wikipedia.org/wiki/SOLID_\(object-oriented_design\)) ^| [^List ^of ^object-oriented ^programming ^terms](https://en.wikipedia.org/wiki/List_of_object-oriented_programming_terms) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+clfmafj) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+clfmafj)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Definitely [Brototype](http://www.brototypejs.com/). :)
Hiring manager here: it doesn't matter. A good search engine will find both. Generally, use whatever the package uses on their website.
I'd say this is pretty cool [fantasy-land](https://github.com/fantasyland/fantasy-land)
I've been around a bit longer (started coding professionally in 1989) and also have been at both Fortune 500s and startups, and I have seen (and produced) code that is well documented. But you're right that it's relatively rare. What seems to drive good docs is either writing code that is meant to be used by other programmers, e.g. sample code or libraries, or code that is very important, e.g. enterprise software. When incorrect docs creates a support burden, you fix the docs. And when downtime costs you a million dollars a minute, there's (usually) structure in place to insist on correct docs. [Here what works really well is making the people who write the tests use the docs as the source of correctness.] Using tests as docs is a kind of lazy way to force discipline. Which is why it works so well, but I much more appreciate the programmer who takes the time to write a few paragraphs at the top of a module that explain it well, and a line or two around interesting bits of code that explain the purpose.
Thanks. So you think sites like dice and monster are smart enough to to equate angular.js with angularjs? 
I dont fully understand the scroll thing you got going on but i think you can make an array [top,foo,bar,baz] then use that to scroll through the different sections so the next section button would get the current id it is on then add 1 and go to the next array item and if &gt; 3 then go to value 0 thus going from baz to top EDIT : something like this : var x = 0; var pictures = ["dota1.jpg", "dota2.jpg" ,"dota3.jpg"]; function set() { document.getElementById("Pics").src = pictures[x]; } function Next() { x++; if (x &gt; pictures.length - 1) { x = 0; document.getElementById("Pics").src = pictures[x]; } else { document.getElementById("Pics").src = pictures[x]; } }
Generally anyone would be searching for "angular" and not anything more specific - so again, it doesn't matter. But in most cases, the engines are smart enough to figure it out.
To be overly pedantic, "angular.js" is a file. The project is called AngularJS (per https://angularjs.org/). You want to be proficient in the relevant framework / library, not with the file.
I use Mocha for everything. E2E, unit tests, integration tests for both front-end tests and back end. I use it with Karma and Protractor for Angular stuff. It's just easier to stick to one testing framework than have to figure out semantics of another one depending on what I'm writing tests for.
this whole "run your javascript on a server" is mind blowing to me. i'm currently wrapped up in projects but i find the whole damn concept fascinating the plethora of write once/run anywhere javascript toolkits for mobile apps is also pretty cool 
How about just making it a function of a utility file/js object and replacing all your uses in code with the function call rather than writing those three lines everywhere.
nice, clear response :) Just for clarity, my personal dislike of Crockford comes from the fact that he controlled the only linter for JavaScript for a long time and how he acted about that control. Effectively, he was trying to force his coding _style_ onto the world and calling anyone that disagreed with the smallest things idiots that shouldn't be coding. This attitude was actually why jshint was created in the first place. Some may argue that it was "his tool", so he could do what he wanted, but he pushed it out to the world, spoke about it in talks, and it became required at many companies. Then one day he decides that `++` is evil, so changes his linter to throw errors on it and says "Change your code to use `x+=1` instead" Or I filed bug reports that my psuedo-code _in a comment_ was causing an error and his response: "Change your code" Is your white-space around parentheses different than his? "Change your code" Granted, a lot of this slowly changed, but a lot of it is still in place. My general point is that you shouldn't have to fight for a tool that's widely used by an entire community to actually serve that community as opposed to one-person trying to act like a dictator over an open arena.
&gt;25 years experience with autoexec.bat.
You could keep all the scripts in individual files and concatenate the ones you need for each project using a script. That way you like have one file for each project but maintain modularity. 
Right, it is a function, but where do I store it? If I just copy-paste it into projects that need it, then if I discover a bug I'm not (reasonably) able to update it everywhere I used it. Do you mean to use a single utility file across every project?
What is Firebase? Googleing is mostly just taking me to meetup pages and stuff.
https://www.firebase.com/ It is a backend service that allows you to store and sync data across multiple clients without hassle.
I would recommend you look into https://coveralls.io/
In real-time 
Is this going to be an acquihire or are you guys actually gonna use Google resources to build out the service. I'm currently looking into using Firebase as a core part of one of my applications...but I'm scared that'll it'll get shutdown like a lot of other Google acquisitions.
I use the exact name the project itself uses, including punctuation and capitalization. It's almost always found in the &lt;title&gt; of the project homepage. URL|Title -|- https://angularjs.org/|**AngularJS** — Superheroic JavaScript MVW Framework http://emberjs.com/|**Ember.js** - A framework for creating ambitious web applications https://jquery.com/|**jQuery**
&gt;50+ years of using .lnk files
Not that surprising. Google was already using Firebase for a bunch of stuff, including the polymer topeka demo. Very curious what this will mean for AngularFire, as both Firebase and AngularJS are now "guided" by Google. 
So if you write a tool, have a bunch of people adopt it, then break it in ways that piss everyone off and even close it off to bug fixes or pull requests to fix it, what does that yield? A good number of people weren't free to "take it or leave it", as many companies forced employees to use it. So they're stuck using a broken tool. They've even fixed the tool, issued pull requests, and were basically told to screw off. So now large numbers of people are stuck writing code in an idiotic style, just to get around crockford's broken tool. Yes, you can shift the blame to the companies, or wherever else, but crockford was a huge contributor to the problem and the only person realistically in a place to fix it. Yes, it's his tool, but it makes him an asshole. Imagine if any company did that -- sublime suddenly breaks some highly used feature and tells everyone that complains to "fuck off, you're an idiot"
I would do something like this: HTML: &lt;a href="#" class="nextsection"&gt;Next section&lt;/a&gt; jQuery: $(".nextsection").click(function () { $("#top-menu li.active").next().find('a').click(); e.preventDefault(); }); 
I am assuming they will integrate it with google drive/google storage. Dropbox already has a similar feature, although tied to each user, and it is pretty awesome. 
From the Hacker News discussion (which has interjections by the guys at Firebase), it looks like it'll use Google resources and staff. If Firebase now survives beyond the magical Google Two Years, it'll likely be a permanent service. 
&gt; So if you write a tool, have a bunch of people adopt it, then break it in ways that piss everyone off and even close it off to bug fixes or pull requests to fix it, what does that yield? It means that people should have exercised the right Crockford generously granted them via the license which JSLint is distributed under, and forked the code. &gt; many companies forced employees to use it What companies force their employees to use can hardly be blamed on Crockford. That makes no sense. &gt; Imagine if any company did that Companies do far worse than that on a regular basis, except that in those cases you've paid money and don't have any rights to modify or fork the source code. 
[Firebase team member here] We’re joining Google so that we can accelerate Firebase development. We’re a great fit for Google’s Cloud Platform because of our technology. The team will continue to work on Firebase. Nothing is changing for you and you can continue to use Firebase as you normally would. You can expect the same great development experience, tools, libraries and community commitment that have become synonymous with Firebase. We’re going to continue to be platform agnostic and provide clients for iOS, Android, Web and more. 
It's Google, they'll find a way.
Are you a time traveler? 2014 -1995 ----- 19 (years)
Not sure what you mean by &gt; displayed on a webpage as an email but I believe you can feed the same options/params into the [Static Maps API](https://developers.google.com/maps/documentation/staticmaps/#URL_Parameters)
Would this work with locally defined (XML) markers? 
Yes it is possible, but it is likely that you would write html or css as well. 
Yeah, I've been around the block a couple of times, I know the ropes, man.
That is fine. CSS is just proving to be quite hard to learn at the moment. Hopefully it will get easier. 
I was expecting iambic pentameter!
Okay but why did Google buy you?
IT Recruiter here (I know you guys hate us) but When we are doing a search for someone, boolean pulls the keyword "angular" no matter if you write it angular.js or angularjs. Not sure if that was part of your question, just thought I would share. Also, if you are a developer in Colorado, get in touch with me!
Oh sorry, was thinking about multiple files within a single project. For multiple projects a module would work or a utility module with multiple of these mini-modules
Reading internal variables should be fine, just no direct writing. Use the build-in Express functions like get, post and use to edit the internal router.
Change the regex: &gt; rxDatePattern = /^ (\d{1,2})(\/|-)(\d{1,2})(\/|-)(\d{2})$/; The last group (\d{4}) checks for 4 digits so changing it to (\d{2}) checks for only 2 (YY). I hope this helps? 
CSS is harder up front, easier overall. (you have to learn the box models, etc) Javascript is easy up-front, more difficult the more you learn (in a good way though)
Interesting. I wonder if it has to do with you searching jobs vs. searching resumes. Because when I am looking for candidates, I just use "angular" OR "bootstrap" or any other js technology I get the same hits. Best of luck in your search! JS is super hot in the market right now, so I am sure you will find work quickly.
OK I will try this in a little bit. Also, what about the IF statement? Do I need to change anything in there?
Anyone know for how much?
I have no idea
I have not heard
I don't think it'll get shut down.
I think you are confusing it with Facebook.
Nicely done!
Also expensive
And you're asleep, ignorant, or both.
I'd say the big idea was that you should just go with the official name which is used on the project's page.
A dancing dickbutt for which you can change the colors, size, orientation (of the dance), flashing. Maybe just by clicks or also by entering passcodes. The world is yours. Your imagination the only limit.
Good lord this is a pessimistic bunch. The only story here: Google buys hot startup because its a good investment. That's it. 
Hell yes it is possible.
Could someone please explain whats going on here... 
Please read up on reddit's rules @ http://reddit.com/rules, specifically point #1 of rule #1. Our [guidelines](http://www.reddit.com/r/javascript/wiki/index) also have more information regarding promotion &amp; self-promotion. **Consider this your only warning.** If you continue to post _only_ your site, we'll be forced to take action. Thanks for your understanding.
If you don't move and shoot once, then hold down the space bar, you shoot a one continues laser. Nice little game.
It's using `true` and `undefined` as strings and taking the letters it needs from those. alert( ([] + !![])[+!+[]] /* r */ + ([] + !![])[(+!+[] + (+!+[]) + (+!+[]))] /* e */ + ([] + ([][+!+[]]))[+!+[] + (+!+[])] /* d */ + ([] + ([][+!+[]]))[+!+[] + (+!+[])] /* d */ + ([] + ([][+!+[]]))[+!+[] + (+!+[]) + (+!+[]) + (+!+[]) + (+!+[])] /* i */ + ([] + !![])[+[]] /* t */ ); I'm not sure why `+!+[]` equals `1` though. 
I decided not to change the default keyboard behaviour. After level 4 invader bombs start moving on x axis aswell, so you can't really cheat by standing somewhere and spamming bullets. I made it to level 25 btw :O
Nicely done. Reminds me of [a recent presentation](http://vimeo.com/105955605) on building up space invaders from scratch.
it on a spaceship? pretty neat
Would you guys relo for an intern? Lol.
Karma with Mocha/Chai/Sinon/RequireJS, and using Istanbul for code coverage. It works great for us.
This line is checking for leap year: &gt; var isleap = (dtYear % 4 == 0 &amp;&amp; (dtYear % 100 != 0 || dtYear % 400 == 0)); Since you'll be only checking the last two digits of a full year, (dtYear % 100 != 0 || dtYear % 400 == 0) clause won't give you the correct check. A leap year is: * evenly divisible by 4 * If the year can be evenly divided by 100, it is NOT a leap year, unless; * The year is also evenly divisible by 400. Then it is a leap year (http://www.timeanddate.com/date/leapyear.html) You can either convert dtYear to YYYY format to make sure always ... or remove **&amp;&amp; (dtYear % 100 != 0 || dtYear % 400 == 0)** and your code will be good until 2400 :P
Exactly right and to answer you question +[] makes 0 !+[] makes true +!+[] makes 1 The plus turns whats after it into a number, 1 if true or 0 if false.
Ah, I was a little confused at first. But I played with it in the console, and it made much more sense Thanks heaps :) 
I guess we could expect Google's Continuity. 
Got a link that explains this? I'm not even sure what to type into google
I've never actually seen any resources on the topic. I would have guessed to search for something like "javascript using boolean in calculations" but it seems there isn't much out there. Feel free to ask me anything on the topic, i will be around for a while.
Sup. my job is basically playing with javascript all day. I love it. I work for a licensed netsuite re seller and work on customization for clients. This involves client and server side javascript and occasionally some css or html.
Let's hope that will be the same story one or two years from now. Best of luck!
It is premature, and possibly foolish, to say that Firebase "is here to stay". Given Google's history with putting "more wood behind fewer arrows" suggests that Firebase, as it is now understood, will disappear in time. I think others have put this time period as about two years.
Take a look at this http://aem1k.com/world/, it returns the code that is used to create the next frame of the animation and loops
It's not like Google (or any other of the big players) has a better track record than Facebook in this regard.
Go read the API that's linked. It's pretty clear
it was the () around "true" that threw me off, I just realized it
Pretty sweet. Did you make the music yourself?
Yahoo
They raised $13 million, so it wasn't cheap. Probably +$50mil?
Firebase = *expensive*. Let's hope Google introduce a better free model.
Acquihire
Look here: http://www.jsfuck.com/ This is an interpreter that converts any Javascript into "an esoteric and educational programming style based on the atomic parts of JavaScript." The guy who wrote this, [Martin Kleppe](http://aem1k.com/), has also written Javascript in [Hebrew](http://aem1k.com/%D7%A9%D7%9C%D7%95%D7%9D-%D7%A2%D7%95%D7%9C%D7%9D/) and [Japanese](https://github.com/aemkei/katakana.js).
Also the humble mozilla bundle which are all games compiled to js using emscripten and available in the browser https://www.humblebundle.com/
Wow, this definitely takes it to another level. Thanks
[deployd](http://deployd.com) is an open source alternative if you dont want to give google all your data. they *are* in the targeted ad business after all.
Awesome little game! How long did it take you to make?
From my personal experience I can recommend to get an account at CodePen (http://codepen.io) and keep looking at other people's CSS. I learned a lot about CSS just from creating absolutely fun and useless stuff with it. Also the number 1 gold thing is finding a group of developers you can join so you can teach each other and help each of you improve. That's how I advanced my skill level and even got my job. 
I don't think you can get a typescript ast out of sweetjs. Not 100% sure though. Cool ideas anyway. 
congrats! I had the chance to meet some engineers and the founder of Firebase in a hackathon, they're great people and is probably come a great thing. *lower prices will be welcome :) 
Very cool, 
Do you have any information on Flow, or how it'll be used with React? I'd love for propTypes to just become static type information to statically describe a components interface to a consumer. I'm absolutely loving the tech you guys are producing at IG/FB; mindblowing stuff
Dear Google, Please don't fuck this one up. Regards, Everyone
You should have stayed independent. Google own too much already.
Nice. Where did you get the image assets from?
Nope, I got it [here](http://opengameart.org/content/legends). I actually got all my assets there.
Around 50 hours...including learning about canvas and 2d game development in general. I spent lots of time searching for assets and preparing them in photoshop (I suck at photoshop:)
All assets are from [opengameart](http://opengameart.org)
I was thinking to a source -&gt; source transformation hacking the token stream returned by the sjs.expand() API
Okay if you want that behaviour, another easy thing to do is listen for the keydown and keyup events. Each time the player has a keydown on spacebar, they fire a shot, and then shooting is disabled. Then on keyup, shooting is enabled again. That means the player can shoot as fast as they spam spacebar, but holding it down will only shoot once.
Can confirm [only limit is imagination](http://puu.sh/clWmg/cad0573a3b.png)
Like this? http://angular-ui.github.io/ui-router/sample/#/contacts - using UI-Router
dingdingdingdingding Winnah winnah chicken dinnah
StackOverflow for people who don't have local programmers groups to hang with.
Thanks a lot!!
Think about problems you have that nobody else is solving. Attempt to solve that problem with JavaScript. If you really want this to be big and remain your personal project here is what you do: * Fuck absolutely everybody else and set priorities in your product that solves only YOUR problem. Once you have a complete, but not perfect, product that solves your problem only then show it other people. * Prepare to be disappointed by people's responses when you first show it to them. So long as the problem is a valid problem and your product solves it directly people will eventually buy into it. It is a ratio of which is the greater end-user frustration between accepting the problem or risking a solution with your product. Over time trust will build up and your product will become less frustrating to use. * Continue to improve upon it. The more refined and perfect it becomes the more useful it will be to other people, but more importantly it will be more useful to your own productivity. * Always listen to input from your users, but only gradually modify your product with user enhancement requests. Don't allow user enhancement requests to detract from the project's core priorities. * Refactor, listen, improve, repeat.
This .. is the comment I wish I made first. Completely agree with this mentality!
Can these features be added in to IntelliJ via plugin? 
What a shit article.
( your explanation why here )
This article is wrong. It's demonstrating Partial Application, not Currying. A Curried function is one that can partially-apply itself based on the number of arguments it receives. To demonstrate the difference, here's partial application: function teach(student, subject, hours) { console.log(arguments); } var teachAlice = partiallyApply(teach, "Alice"); var teachAliceEnglish = partiallyApply(teachAlice, "English"); teachAliceEnglish(4); Here's currying: var curriedTeach = curry(teach); var teachAlice = curriedTeach("Alice"); var teachAliceEnglish = teachAlice("English"); // Note the distinction here. teachAliceEnglish(4); 
The examples were terrible. The ones provided are problems much better suited to other patterns. In addition, the author had the definition of currying wrong (/u/inmatarian is right). 
They have a 1.0-pre release out and i suspect a 1.0 stable on the "world wide meteor day", the 6th of november. I am one of the lucky few who has a fulltime job working in meteor. So it seems far from being stagnated.
I've already done that for a personal project. JS : http://pastie.org/9667738 HTML : http://pastie.org/9667740 In my case, the user can move the map and clic on a "save" button to take snapshot of the map (using lat/lng/zoom). The snapshot is saved in the localStorage so it can be viewed offline (using appcache) And then, the user can check "track" to show it geolocation. It can be customized to show any google map information. Hope it will help you.
Poor grammar. Confusing, stupid sentences. Bad examples.
Great to hear
I do understand the reaction. Big companies in general and Google in particular have a track record of buying things and then destroying them.
Meteor is already available in the IntelliJ plugins repository. I presume like all other features, these too will be available for WebStorm and IntelliJ Ultimate users. However, I am not speaking on behalf of Jetbrains.
Christ, those animations are nauseous 
I'm curious about that too. Do IntelliJ Ultimate owners have to wait for the WebStorm plugin to be updated or does their license work with WebStorm too?
Is it doable though for most people? Looks like fun and a good learning experience 
One of the advantages of a curried function is that you can pass any known arguments to the function at any time. This means that the function you write doesn't have to know which arguments are going to be known at any point. So for instance: var teach = curry(function (topic, teacher, students){ console.log("%s is teaching %s to %d students", teacher, topic, students.length); }); These are all equivalent: var a = "CS101"; var b = "Prof. Smith"; var c = ["James", "Todd", "Rebecca"]; teach(a)(b)(c); teach(a, b, c); teach(a, b)(c); teach(a)(b, c);
yeah man pisstaking! its a slow day at work.
As far as I know, you'll have to wait for the WebStorm plugin to be updated. The WebStorm product is the bleeding edge release, while IntelliJ plugins lag a bit behind. 
What's this Flow you are talking about?
I like cursors.io because it uses new chrome api (mouse access) &amp; realtime features by using websockts. This kind of stuff wasnt possible earlier (maybe with flash but I don't think it offers mouse apis). Phonegap/Cordova/Node. In general: everything that wasnt possible with js which is possible nowadays. It shows how well javascript evolved in the last years. Hell just look at all those webgl apps... just stunning
The programming part is of average difficulty if you have a good grasp on javascript and OOP. Making this kind of game is actually a really good way to improve your programming skills. And yeah its pretty fun. The only pain in the ass is audio. Web Audio API lacks browser support and requires fallbacks to HTML5 audio which is pretty crappy for making games (shitty performance and you can't play multiple sounds at the same time, so you gotta use buffer arrays and such...bleh). That's why I used howler.js for audio.
Can someone explain this in Layman's?
Well SO lacks a good "community" feeling, like it's "only" Q&amp;A. I don't have a local group either but I've found a group of people through CodePen &amp; Twitter I chat with whenever I can. We're located all around the world and have all kinds of skill levels. It really helps a lot!
Can you point me towards are resources you used to get started? I have a pretty good grasp of OOP but not really JS 
Please gtfo with your shit comments. Explain why or don't bother posting.
There are signs of a powerful convergence on typescript syntax. Announcement: https://twitter.com/fbOpenSource/status/511643210482208768 https://code.facebook.com/atscale Comment on Reddit linking to facebook-future: http://www.reddit.com/r/javascript/comments/2jgrzr/react_v012_rc/clbz3s5
what is partiallyApply here ? your given code is not event working http://jsfiddle.net/wwz09gn2/
can you plz give a working demo of your example? 
Well you'll need to know intermediate JS to be honest. Some resources: [Mary live codes a JS game](http://vimeo.com/105955605) [Space shooter tutorial](http://blog.sklambert.com/galaxian-html5-game/) - not a big fan of how he wrote the game but theres some good advice to get you started [Another good tutorial](http://jlongster.com/Making-Sprite-based-Games-with-Canvas) [Canvas performance](http://www.html5gamedevs.com/topic/7735-myths-and-realities-of-canvas-javascript-performance/) 
Yes, that presentation inspired me to make my own version. You should give it a try.
At least it's a goal - I've been working with C++ for awhile now Thanks! I appreciate the links!
I've written an end-to-end website in TypeScript with a 5-man team. We have a TS front-end (written in a framework that we built ourselves from the ground up in TS) and a Node/TS backend using Express and MySQL. It has gone incredibly smoothly. The only issue we had was there were no typings for [node-mysql](https://github.com/felixge/node-mysql), but I ended up writing one that is now on DefinitelyTyped ([here](https://github.com/borisyankov/DefinitelyTyped/tree/master/mysql)). Most of the guys I work with all come from a .NET background, and have found working with TypeScript to be a pleasure. It actually inspired us to write our own framework that borrows a little from ASP.NET.
You need to get it from a functional library. I recommend [Ramda's lpartial](http://ramda.github.io/ramdocs/docs/R.html#lPartial).
You're further proving my point, thanks. So you have a method, and you use it all over... then later change it for one place, but then realize it breaks things elsewhere... Do you really not see the architecture problem with this? You're using a method all over and for some reason you're expecting it to be treated differently in one place than in another... THAT is silly. If you reuse a method that should be because you always expect it to be used the same way in each place you're reusing it, otherwise you shouldn't be reusing it, or else you need to abstract out the parts of it that are the same, then override some methods of the class or something to add your customization to that particular instance.
I'm boycotting until they support my nitch javascript framework [ractivejs](http://www.ractivejs.org/)! ... Kidding. Actually it's mostly because the java font rendering on linux makes me feel like I've stumbled through a timewarp back to the 90s. I should probably give it another spin under java8 with useSystemAAFontSettings tweaked. Edit: Fonts still crappy. Blurg, Swing needs to die a horrible flaming death.
Heres a clearer example of how neural networks work: http://harthur.github.io/brain/ You have an input of whatever data you want to analyze, and you get out a normalized float (0.0 to 1.0). If there isn't any training, this will be entirely random, but in the linked example it compares the input/output to determine how successful it was and train it better over more generations. Very cool stuff, I've got a game where I'd like to implement this for the artificial intelligence of enemies.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Code reuse**](https://en.wikipedia.org/wiki/Code%20reuse): [](#sfw) --- &gt; &gt;__Code reuse__, also called __software reuse__, is the use of existing [software](https://en.wikipedia.org/wiki/Software), or software knowledge, to build new software, following the [reusability principles](https://en.wikipedia.org/wiki/Reusability). &gt; --- ^Interesting: [^Duck ^typing](https://en.wikipedia.org/wiki/Duck_typing) ^| [^Library ^\(computing)](https://en.wikipedia.org/wiki/Library_\(computing\)) ^| [^Reusability](https://en.wikipedia.org/wiki/Reusability) ^| [^Information ^hiding](https://en.wikipedia.org/wiki/Information_hiding) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+clgpxi7) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+clgpxi7)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Yes, I code, "bro". If one is reusing code, one would typically expect that each place it's being reused is because that point of the program needs the same functionality. If one then changes that functionality to do something in one place, and then have a problem because it breaks something elsewhere, clearly there is an architectural problem. It is not logical to expect something that's reused to be interpreted differently in two different places. In that case, it shouldn't have been reused. If you don't understand this, let me know and I'm happy to provide further explanation.
... :(
~~Don't think intellij products use swing. AFAIK idea-based IDEs and Eclipse all use SWT or something similar.~~ As for fonts, have you tried using the the patched openjdk with fontfix on linux? Works like a charm. Edit: Axed misinformation over which ui toolkit Idea uses.
I am using those, but it only tells me about code that is executed. If a file doesnt have a test file, there is no coverage reporting on that class/object. 
&gt; Yes, I code, "bro". Lighten up man, it was a joke. &gt; It is not logical to expect something that's reused to be interpreted differently in two different places. In that case, it shouldn't have been reused. See, I don't get where you are getting this from. The scenario is simpler than that: - Dev makes a function `f`. `f` returns `y` for input `x`. - Function is useful, so other devs (who are practicing code reuse) will use it in their code - Oops there was a bug in `f` for certain values of `x`. So someone changes `f` to return `y'` instead of `y` - Code that was expecting `y` is now broken That's not an architectural problem. It's just a natural part of code reuse. Sometimes code has bugs. Bugs introduced in a heavily reused function will cause failures in many places. &gt; If you don't understand this, let me know and I'm happy to provide further explanation Let's not get condescending. Just because I don't agree with you doesn't mean you're right and I'm misunderstanding. It could mean that you're wrong. 
&gt; AFAIK idea-based IDEs and Eclipse all use SWT or something similar. Eclipse uses SWT, IDEA does in fact use Swing.
Thankfully with the release schedule of JetBrains' products usually all of the updates to the other IDE's get rolled up into IntelliJ IDEA at the end of the year when they stamp a new version. So in theory I'd expect all of the WebStorm 9 features to hit in IntelliJ IDEA 14. EDIT: In fact, Phonegap/Cordova support is [part of IDEA 14](https://www.jetbrains.com/idea/nextversion/#HTML5) so it does look like it's getting the updated plugin.
Ionic support is what I was happy about.
I'll just leave this here http://stackoverflow.com/a/1732454/3943749
Reads like yet another article about currying...But here's my try anyway. Currying is such a buzzword! But why is currying useful anyway? If you realize that functions are values, and that any computation can be abstracted into function composition, then you'll see why currying is so useful in higher-order abstractions. Say we have an arithmetic expression: 3 * 2 + 1 Let's abstract it over a number: x * 2 + 1 We can think of `+` and `*` as binary functions: add(mul(x, 2), 1) When `add` and `mul` are curried we can rewrite the expression: add(mul(x)(2))(1) Since addition and multiplication are commutative, we can reorganize: add(1)(mul(2)(x)) If we replace the partial functions with names we can see that what we got is just function composition: add1 = add(1) mul2 = mul(2) add1(mul2(x)) We know that `f(g(x)) = (f ∘ g)(x)`, where `∘` is composition in infix notation, therefore the example above is the same as: compose(add(1), mul(2))(x) Now we got a transformation as the composition of two functions, the `x` is no longer needed to express the computation. So we get that: 3 * 2 + 1 === compose(add(1), mul(2))(3) In conclusion, a value is a function, and computation is function composition. Think that you can do this with *anything* because lambda calculus is turing complete. Operators like `*` and `+` are just *functions*; if we assume commutativity and associativity, then there are only a few things we can apply these functions to. But if we assume associativity only, then a function like `+` can apply to numbers, strings, arrays, tuples...
Thanks, well I would like to create a task manager. Suppose I could create something basic and then build upon it. Thanks, love the points btw very helpful... and true :)
What area do you live in? This is a role that is hugely in demand.
Which is why I dont think angular is ready for primetime. Major CPU-melting bugs are just now being fixed, and not even in a stable release yet.
 var isLeap = function(year) { return new Date(year, 1, 29).getMonth() === 1; } simply check if 29th feb exists for a given year!
Thanks... got it working. snippet.scope = function (string,startEnd) { var regex; var match_; function createRegex() { var match = string.match(new RegExp(startEnd[0]))[0]; if (/^\&lt;[a-zA-Z]+/.test(match)) { startEnd[1] = '&lt;/' + match.match(/&lt;([a-zA-Z0-9]+)/)[1] + '&gt;'; } regex = [startEnd[0],'(?:|[\\s\\S]+?)',startEnd[1]]; } function buildMatch() { match_ = string.match(new RegExp(regex.join(''))); } function loop() { function matchLen(string,token) { return string.match(new RegExp(token,'g')).length; } if (match_) { if (/^&lt;[a-zA-Z]+/.test(match_[0])) { startEnd[0] = '&lt;[a-zA-Z]+'; } while (match_ !== null &amp;&amp; matchLen(match_[0],startEnd[0]) !== matchLen(match_[0],startEnd[1]) &amp;&amp; regex.length &lt; 85) { regex = regex.concat(['(?:|[\\s\\S]+?)',startEnd[1]]); buildMatch(); } if (regex.length &gt; 85) { throw 'The length of the scope is too much (' + regex.length + ')' + '\n ' + match_; } if (match_ === null) { regex.splice(regex.length-2,2); buildMatch(); } regex.splice(1,0,'('); regex.splice(regex.length-1,0,')'); return [match_[0],regex.join('')]; } return false; } createRegex(); buildMatch(); return loop(); }
Thanks but that gave me an array of unexpected items.
Neural networks have a set of inputs, just an array, the values go from 0 to 1, the have a set of outputs, just an array of values that go from 0 to 1. You can decide how many inputs/outputs (or the array lengths) but once you start it, that can never change. You "correct" a neural network when the outputs do not match the inputs you want. This is called training. Want to build one? Its easy: 1. take a video from someones dashcam, grayscale it, crop it by 256x256. 2. Take a neural network, create one that has 65,536 inputs, and 2 outputs. 3. For each frame, give the network the frame of video, and the X/Y value of the car. 4. Once you're done with every frame in the video, you're done training the network. 5. Get a brand new dashcam video, only give the network each frame of video, it'll figure out the X/Y values. The neural network will (to some degree of accuracy) return the X/Y coordinate where it thinks a car might be. Congrats, you taught a computer to see a car. 
You should have no problems then. Just take a look around and see what's out there.
progress bar makes me think codecademy.com but you probably looked into that already... also it's kind of basic
I haven't used WebStorm, but I like the cut of its jib. Is anyone here a WebStorm convert from Sublime? Does this compare favorably as an editor?
What I wanted was something more like ng-admin (https://github.com/marmelab/ng-admin). However, I would prefer a tutorial that I can copy and apply to my instance so that I know how to build it and learn from hacking it.
I honestly want to help people understand these things if they don't get it, my intent was not to be condescending. I'm curious to see a real example of this problem you're envisioning, not oversimplified hypothetical pseudocode: f(x) = y. As a consultant I've seen plenty projects that had "100% passing test coverage", but were still fundamentally broken, and when you bring this up to the developers or management they usually respond with something like "but wwe have 100% test coverage and they all pass!". Yeah man, breaking your algorithm into a bunch of one liners and exponentially growing the length and complexity of your code isn't a good thing. You just destroyed any semblance of cohesive architecture by smashing it into a bunch of tiny useless pieces and introduced more API surface area and functional overhead for the sake of unit testing. Test driven development is the epitome of premature optimization, and if you need a test to tell yourself the API you just came up with is shit, then you've got a very fundamental problem to deal with. If you're writing tests it should be to ensure that code is meeting business requirements, not to ensure that your code isn't shitty code. If your code is shit, your tests are shit. Code re-use is one thing, but having one API affect many other pieces is a perfect example of bad architecture, period. It's exactly like you said, you changed it to fix something in one place, and broke things in another place. This is bad! This should not happen! You shouldn't need test to tell you that this is bad. Needless abstraction adds more complexity, and leads to this kind of bad architecture. Like I said, it's my opinion... I'm not saying I'm right and you or anyone else is wrong... It's just my opinion based on my experiences.
I just converted to PHPStorm. A bit slower than Sublime but predictions and refactoring is awesome. The keyboard shortcuts make a lot more sense since in Sublime, many of them come from plugins and are thus scattered all over the place. It also has the minimap as a plugin. It took me a couple of tries but I don't think I'll go back this time. Keep both though as Sublime is still a much better quick editor. Webstorm/PHPStorm can only have one project open at a time.
&gt; Test driven development is the epitome of premature optimization Honestly that's just ridiculous. If anything TDD is the opposite -- you optimize after you have a clear idea of what the code should do. Architecting too much ahead of time is... well no battle plan survives contact with the enemy. 
Wrong, this is in stable 1.3.0 already. Also this is hardly CPU-melting bug. Most people use filters for few dozen of values at max. That is a number that won't sweat any CPU. If you want to filter each of the thousands of records in a table, then you should use something else-like u/Conradfr suggested-filter manually in controller and display the result.
I use both. In my opinion, they feel very very similar and have many of the same text editor features. Webstorm justs adds on a bunch of useful integrations and IDE features. My biggest complaint with the Jetbrains line up is how segmented there lineup is. For example, in order to edit PHP files, you need to buy PHPStorm. It includes all of the Webstorm features, but has defaults geared more towards PHP. Webstorm is also fairly limited in terms of language support outside of HTML, CSS, and JS. I'm okay with this because I use languages that fit within their support. The thing with Jetbrains is they intentionally choose a limited scope of popular functionality and they do it really, really, really well. If your work falls into one of their products, you will almost certainly love working with i. Sublime is still my fall back for anything else. As I'm sure you know, it covers absolutely everything - and it does it pretty well.
ok so they fixed it last week, big deal. That doesnt really change my assessment of the current state of angular. There are still a bunch of other unfixed gotchas that have given me so many headaches. I'll wait for 2.0.
The way I would do it is to put a [`MutationObserver`](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) on the container element that holds the tweets, and arrange for your callback to be called when new elements are added. To avoid having to rescan the whole list, just keep track of the last tweet seen. Now you don't have to worry about any of the implementation details of Twitter, you just get called when new elements have been added, however that happens. You can use this in a variety of ways, for example I used it to write a user script that loads all Disqus comments on a page by continuously clicking "Load More Comments" whenever the button appears without having to use delays or polling, but by detecting whenever a new chunk of comments was added. 
In addition to point below about opening multiple projects at once there is also a quick edit feature if you use the Open option that let's you open a non project file in the editor. 
Yea I'm mostly interested in the gulp and node features currently.
good, I was afraid you were going to say Backbone. Backbone fucking sucks IMHO.
Thanks for the input.
An absolutely wonderful description. For better or worse, most of the currying examples/utilities in js are more flexible about having curried functions decompose into non-unary functions (as opposed to haskell, ocaml and others). eg. Being pedantic: curry(someFn)(1)(2)(3) vs What js currying utilities usually allow for: function someFn(arg1, arg2, arg3) { // do stuff } curry(someFn)(1)(2, 3) 
Backbone has many advantages over angular. For example with backbone you actually know when the DOM gets updated because you have to do it yourself. If you need to do things like measure the pixel dimensions of DOM elements that are being updated with ajax data, angular makes it very difficult.
Use a hash map. Here is roughly what it would look like: var menuMap = { option1: [1,2,3,4,5], option2: [6,7,8,9] //etc }; Use the map as a lookup from your first select box, then iterate over the array to create the second select box. I'd recommend using jQuery for this, as it it much easier if you don't know what you're doing inside the DOM. Also check out /r/learnjavascript.
Nice share.........
Thank you so much!
Chrome web inspector's responsive tool allows you to set your viewport to different sizes, even ones larger than your screen.
I will check it out, thanks.
Your programming language is in another castle.
Looks like you're installing the Java SDK - this is the Javascript subreddit. You might have more success asking in /r/java. (Despite the similar name, the two languages have virtually nothing in common with each other)
IMHO, Is just a wasted of time to focus in so many frameworks, news will comes old will fade, they should be focusng in improving the more generic and usefuk features.
If anything they should be officially developed plugins rather than integrated into the product optionally. But I do like this editor, I use it with IdeaVim and it's perfect and lets me use the mouse much less. Learn a few of the common navigation commands and you are set.
Java script is not same as JavaScript. Try /r/java next time. Anyway... that error message is self explanatory enough. You might want to redownload it again using a download manager. And if it's an online installer, try to download the offline installer (if any).
And then there is Github's ATOM, which is free, and is getting some headway. When My licence runs out I'm going to try and use that for a period of time and see if I'll go back. TBH I just need an ide that has a console, vim mode, good nav shortcuts (context aware and able to search for modules and functions globally) and the ability and community to expand functionality. I love jetbrains because it has a lot, and for the specific purpose of web and node development it is pristine.
[Here](http://jsfiddle.net/arunpjohny/2pza5/) is a decent JQuery based example of what you are trying to do. Google: 'Cascading dropdowns' also. Does the data come from a database or will you have it hard coded in the page? Do you have to support multiple browsers? (JQuery is the way to go if the answer to the latter is 'yes')
From a person that's used d3 pretty extensively, an intro is going to take more than 10 minutes. Even then, I would have intro-ed with selections. Like... "Selections" on the DOM, you say? What the hell is different between that and JQuery? Well they're just data-driven selections: http://bost.ocks.org/mike/selection/ And then build me a freaking sweet Bar Chart part [1](http://bost.ocks.org/mike/bar/), [2](http://bost.ocks.org/mike/bar/2), &amp; [3](http://bost.ocks.org/mike/bar/3)
I am a convert from WebStorm to Sublime. I will never go back. JetBrains' pricing schemes are extraordinarily expensive, and they're built on Java using widget toolkits to emulate native OS GUIs. The configuration pane is way over-engineered to the point that you *must* spend a considerable amount of time tweaking, saving, then going back, then opening settings, tweaking, saving, then going back, then opening settings, etc. I've spent several hundred dollars with JetBrains before I came to the conclusion that I'm not saving time or money with their solutions.
/u/rhomboid's suggestion is probably a more practical way to do what you're trying to do (if you're fine with only supporting newer browsers). If you don't want to go the MutationObserver route, you could also try to determine exactly when the ajax call is sent by watching your network tab in developer's tools. Most likely it's scrolling past a certain point or a special object that fetches more tweets when it becomes visible. If it's being triggered by a DOM object becoming visible, you could try replacing that object with one of your own that swaps in the other one and triggers it when necessary.
It's in Firefox too. Ctrl+Shift+M.
To max out perf, your best bet is probably doing an r.js build to a single file, replace require with almond.js (in just the built file), and putting an async attribute on the built file's script tag. I don't think pagespeed would/should help with that at all. Add super long caching and rev your filenames on update to go the extra mile.
People are rightfully worried that an acquisition may mark the beginning of [an incredible journey](http://ourincrediblejourney.tumblr.com/page/2)
yes I agree with this.
tbh i don't think its all that relevant. sounds like something you'd only need to know for an interview and not beyond that.
I hope you offer them a pen and paper. There's a bit too much to keep in your head all at once (due to the swapping). I recommend that you ignore this and revisit it 6 months or so from now to better gauge the question's difficulty. Though I have to ask: Why bother with a silly puzzle when you could just ask them to explain it to you? It'll take less time, be less patronizing, and help you better gauge their technical knowledge.
Thanks for the input. I was trying to make an example that demonstrated the effects of bubbling/capturing, where they could trace and work out the code on paper rather than me asking several questions about concepts. They could take time to think about it, and I wanted to see what level they were at, not that they could solve it in x amount of time. I wasn't expecting an answer which involved the colors-- that was just to make it a working example. I thought that the div output would allow them to take a step out of the code, and trace the flow of events between child and parent. edit: words
The operators checking for Google, bing and yahoo should be &amp;&amp; not ||. Because the &amp;&amp; says it can't be any of them, the way you have it, it finds the first one to be true and stops checking the rest.
I use Intelij ultimate (we write a lot of java, groovy and scala as well) and for javascript if you other to annotate your code the contextual help is excellent. GIven that I use the closure compiler I anyway annotate my code, truly a pleasure to work with.
Just tweak you fonts. I run one buntu and one arch box and while it ain't mac pretty it is awesome, in enough other ways, that I am happy.
 oSession.uriContains("aan1") &amp;&amp; oSession.uriContains("ann2") &amp;&amp; oSession.uriContains("ann3") &amp;&amp; !(oSession.hostname.Contains("google.com") || oSession.hostname.Contains("bing.com") || oSession.hostname.Contains("yahoo.com"))
omg ... really .. didnt knew about it! o.O 
That's not it unfortunately... but thanks for your reply!
The problem is there's too much going on. If you don't want to involve the colours, then leave them out. At least you could grey out those lines and tell the candidates to ignore them. It's not going to be a "real world example" anyway, so what it does is only add confusion about what you want to reason about. Also... [you're just being visually mean with the divs arranged that way](http://i.imgur.com/IVxI4Yl.png). ಠ_ಠ
This isn't an answer to the question, but can someone tell me what the point of JScript .NET is? It seems to be a dialect of JS that runs on the .NET framework, but why wouldn't you use one of the well supported languages like C#? Is it just aimed at the very specific audience of JS programmers who want to make windows apps?
Not everything has to be a one liner. If what you are doing is becoming incomprehensible (and even worse, unmaintainable), find another way to do it. For this, you could do something like: function test( value ) { if... return true; if... return true; if... return true; return false; } Easy to understand, easy to alter, easy to reuse. 
Don't think he knows it's pronounced "neeshe" either
Well guys, I'm an ass hole. D': These were the first interviews I've participated in, so I really appreciate the feedback. I'm checking with you guys first next time.
I hope you got it was meant a bit tongue-in-cheek ;) But really, I think arranging the `&lt;div&gt;`s a bit better is a good idea.
Do the Nodejs/Grunt/etc integrations now work over ssh ? I was recently on a project where those things were running in a Vagrant box so these were de facto useless (not a big deal though).
Why using “ and ’ ? It's not well interpreted here. I have to do some replacement otherwise output look like this. var dataArr = [1,2,3]; d3.select(â€˜bodyâ€™).selectAll(â€˜pâ€™) .data(dataArr) .enter() .append(â€˜pâ€™) .text(function(d){ return â€œIâ€™m â€˜pâ€™ element number â€œ+d; }) .style(â€˜font-sizeâ€™, function(d){ return d*10; }); 
var s = $(window).scrollTop(), opacityVal = (s &lt; 4000) ? (s / 2000.0) : (3 - (s / 2000.0)); $('h1.b').css('opacity', opacityVal);
I was checking out new dev tools and tried atom but didn't like it as much as Adobe's brackets. They are very similar but brackets seems more refined and has a few more features. Both free as well.
How you map jj or jk to IdeaVim again?
The Man in the middle proxy tool I use called [Fiddler](http://www.telerik.com/fiddler), runs its Script Engine on JScript.NET.
Webstorm is $50 for the first year and $30 a year after that. I wouldn't consider that expensive for a professional grade development tool. And yes, there are a lot of options to be tweaked to get it perfect; but that's with _any_ IDE. Sublime doesn't have that problem because _it's not an IDE_. If you're going to switch from a basic text editor to an IDE, you're going to have to put the work in; no way around that.
How does this compare with something like [the orm package](https://www.npmjs.org/package/orm). Or, rather, why use one over the other? Is it the persistence aspect? Are you involved with the project? Can't help but notice you created an account just to post this.
&gt; My problem is, Your problem is...?
Agree. If javascript programmers are working with native dom events -- it should probably be because they're writing their own library/framework code. It would be painfully bad as a standard practice...
Hmm so an editor has less options/configuration than an IDE? I've been doing it wrong with my two thousands LOC emacs config! \#emacsmasterrace
Hey, I know these people! These guys are super high energy and amazing people. ThunderPlains was an amazing success and a great conference.
Those two are not related. Yes, the persistence aspect is very important - there is no need for for explicit saves on a row, the transaction will take care of it. Also, the filtering is quite different. Yes, I am the author of rdb. It was initially closed source at Timpex (www.timpex.no), but we decided to open source it.
Thanks, hmsimha, I'll try that.
Developer usually get confused in Partial application and Currying, both are have the same behavior but Currying takes argument and returns a function which takes other arguments while Partial Application takes the function and first argument on first invocation and invoke the provided function with the provided arguments. 
&gt; Functional programming is a programming paradigm which primarily uses functions as means for building abstractions and expressing computations that comprise a computer program. There's nothing wrong with starting the learning journey here, but this deserves a footnote. The fine print is that in 2014, practically nobody accepts this as a definition of *functional programming*. Depending on who you are talking to, "functional programming" means some or all of: 1. Functions as first-class entities. 2. Pure functional programming, meaning that there are no "side effects" or "mutation of state." 3. Recursion, lazy evaluation, or other optimizations that allow program algorithms to closely resemble mathematical formulae without performance penalties. 4. Sophisticated type systems that allow for some measure of "programs as proofs." JavaScript certainly embraces #1 on this list, but not #2, #3, or #4. #2 and #3 are necessary if you wish functions to operate at the same level of abstraction as formulae. Otherwise, what a programmer calls a "function" is an *implementation* of what a mathematician calls a formula. #4 is necessary if you wish programs to operate at the same level of abstraction as what a mathematician calls a proof.
Sorry, power blackout. It messed up my title, I will rewrite
I use both...for Web/Node development I use Sublime (love the plugins + I can write/edit faster) and switch to Webstorm for debugging Node issues.
Its...ok but not at all great. Everyone can answer the question in some regard so thats good, but to me it feels so far from what I'd do in real life that it doesn't have real value. I always use useCapture false, it seems that using both would be a code smell. In a normal event, I would probably use stopPropagation to keep events from leaking and emit a custom event for that element if anyone else wanted to respond to it. So that would be my 'real' answer if I had time to think, and your puzzle wouldn't have helped at all. It would be equally useful to just say "tell me about different ways you have handled events" and see what they've done in the past, what they like, what they dislike, and why.
Thanks greshick, I'll double-check the code for something that looks similar.
Yes you are correct.
I'm not 100% sure what you're asking. Do you need to remember state between requests? I'm not familiar with FiddlerScript, so I don't know the best way to do that. Maybe it implements some local storage API? If I'm reading this right, you're going to have to keep track of which URL you assign to the first request so you know NOT to use that one in the future. Also, it might help if you use actual data. I'm not sure what you mean by "If TargetString is found in www.example1.com". Clearly, the string "TargetString" is not a substring of "www.example1.com". And finally, you say: &gt;The above code says, if the TargetString is found in RequestHeader, then redirect it to a random URL. There's no redirect code at all. All you do is assign some variables. Are you trying to match TargetString in all of the request header? Or just the request URL? [Here's some documentation](http://docs.telerik.com/fiddler/KnowledgeBase/FiddlerScript/ModifyRequestOrResponse) on how to play with the HTTP request - it looks significantly different from what I see in your example.
You're still missing one of the most important advantages of a curried function. You can pass any known arguments to the function at any time. This means that the function you write doesn't have to know which arguments are going to be known at any point. So for instance using Lo Dash's `_.curry`: var teach = _.curry(function (topic, teacher, students){ console.log("%s is teaching %s to %d students", teacher, topic, students.length); }); var a = "CS101"; var b = "Prof. Smith"; var c = ["James", "Todd", "Rebecca"]; // These are all equivalent: teach(a)(b)(c); teach(a, b, c); teach(a, b)(c); teach(a)(b, c);
The wikipedia articles on [partial application](http://en.wikipedia.org/wiki/Partial_application) and [currying](http://en.wikipedia.org/wiki/Currying) are reasonable introductory resources for those interested in either.
Sorry, let me be more clear........Just forget about RequestHeader. If TargetString is found in www.example.com/TargetString redirect and assign it to unassigned url ( example: google.com ) and NOT to use that one in the future. 
You should participate in ThunderPlains 2015!
No...., I just want to pick a random URL from array list and NOT to use that URL in the future. Any Ideas?
var sites =['www.bing.com', 'www.google.com', 'www.yahoo.com', 'www.sandbox.com']; if ( sites.indexOf(document.location.href) == -1 ) { var url = sites[Math.floor(Math.random()*sites.length)]; document.location.href = url; } Than you can use sites.splice to remove it from the list. Maybe I'm not understanding what you're trying to do?
Hah. We'll see. Got three small kids at home right now. Travel is a challenge. Maybe 2016. :D
You can remove the array by doing something like var index = sites.indexOf('www.google.com'); if (index &gt; -1) { sites.splice(index, 1); }
What do you guys do that requires Angular on a daily basis? AS much as i like angular and see the benefits it carries, where i work most of the websites done are CMS based with mostly static content. A few months ago my boss kept pushing for Angular but i really couldnt see how it could fit into the websites we do. Nothing we do can be considered a web-app also. On the other hand, we also sell a lot of social media integration and SEO positioning of our sites, and im aware that crawling of Angular based sites is not an easy task to fix. Still, i'd like to find some proper projects to try angular eventually. 
This is great, and it works very well under Firefox for me. I also really like that you can add your own defaults in (although this might get confusing if you are browsing a repo without an editorconfig but with a unique style). You should look into adding Bitbucket support. Even though it is less popular, it's still used quite a bit.
The company is from US
What do you mean. I only know J and K are down and up respectively 
Well just to give you some ideas - I don't know if this is a best practice. For my admin views I typically drop the model into a table/grid and then add my edit/delete/save buttons and enable inline editing directly in the table. I personally dislike admin panels that open new windows. It just adds to many clicks imo. Here's an example of this using [Ng-Table](http://bazalt-cms.com/ng-table/example/16) or this might be a better [example with a detail view](http://bazalt-cms.com/ng-table/example/22) Other options: * [trNGGrid](http://moonstorm.github.io/trNgGrid/release/) * [Adapt-Strap](http://adaptv.github.io/adapt-strap/) * [Ng-Grd](http://angular-ui.github.io/ng-grid/) being rewritten as [UI-Grid](http://ui-grid.info/) * [Smart Table](http://lorenzofox3.github.io/smart-table-website/) 
Sorry, late to the party, not sure if this is an "allowed" answer, but browser caching is my least favorite thing about JavaScript.
maybe [survivejs.com](http://survivejs.com/)?
We build software. Angular is a great web app framework. Not sure it is necessary in a CMS platform unless you wanted the look and feel of a single page app. Mind you if you're API produces json, I'd rather build a front end using angular than having no framework. It's much faster to build on than not having one. 
Yeah, this (IMO) emphasizes trivia over understanding. For instance I can tell you what event.stopPropagation() does, but I've never used addEventListener's third parameter, so I probably wouldn't have been able to precisely predict what the code does without knowing in advance that this post is about event bubbling. Instead of asking candidates to explain everything a piece of code is doing (Ain't nobody got time for that), you should craft a question that will quickly determine what you want to know. For this code, I might say the following: When I click div-3, div-0 changes color. Why does it do this, and how might we prevent it? A candidate that doesn't understand event bubbling would get as far as determining that the foo and bar methods only modify direct parent or child elements, and then would probably blame magic. To a candidate who understands events, the problem would be almost immediately apparent, and they would likely be able to provide a possible solution, or at least explain what's going on, even if they haven't memorized `addEventListener`'s signature. You could dispense with the example code altogether and just ask the candidate to explain the difference between the concepts of "useCapture" (the third param) and "stopPropagation" (the event method) but even that is a bit too specific to really gauge someones ability. It just determines how closely they've read the spec. *TL;DR* a good programmer knows enough to solve problems. Knowing everything isn't necessary to do that. 
You should definitely rip this developer a new one for bad style, but in Javascript, a function is a type of object, so this is correct.
A function is an object. It's not a quirk. It's just how it is. And I might add that if you didn't know that, you probably shouldn't be thinking about ripping anyone for style.
&gt; How is this possible for a variable to be both an object and a function? Flip the question around. Why *shouldn't* a function also be an object? After all, we can write this: function foo () { return function bar () { return 'baz'; } } And: var buzz = function foo () { return 'bzzzzz'; }; This shows that functions are values that can be returned from functions and assigned to variables (amongst other things). So why can't they have properties? Or a prototype? Or even methods? var bedlam = buzz.bind(null);
What is Pusher in comparison to Pushbullet?
1. Functions are actually a sub-type of object in JS -- technically called a "callable object". All objects can have properties. 2. There's absolutely nothing wrong with putting properties onto functions -- there's many use cases for it. Of course, you have to decide if YOUR use-case is correct or not, but I don't think this is a case for head-ripping-off.
This is perfectly normal. It works similar to a singleton: function person (name) { this.name = name; } person.sayHello = function () { console.log('hello'); } Everything in JavaScript is basically an object and you can set attr/methods on anything. In your first example, you are overriding the object with a number, however: var x = 4; x.foo = []; x.foo.bar = 'string'; typeof x === 'number' Array.isArray(x.foo) === true typeof x.foo.bar === 'string' That's all perfectly valid. Addy Osmani wrote a [book on JavaScript patterns](http://addyosmani.com/resources/essentialjsdesignpatterns/book/) that you both might find useful to sort out this kind of confusion in the future.
No use case springs to my mind. I'd say it is unusual enough that it would certainly warrant asking the developer to explicitly add a comment like // Note: I'm adding a property to this function in order to...
Agree with @getify - it's the expected behavior of JavaScript and there are use cases for it. But, depending on the use case, you could argue it's a code smell. More often than not, when I've been tempted to use that pattern, I've been able to find a better way to rearchitect the code in question. It's not a typical approach, so it may not be what a future developer expects to find there and will in turn add to the time needed to grok the code they are maintaining.
No one should have their head ripped off for style. I don't care how senior you are. Just gently tell the junior dev "even though you can do this in JavaScript, it's normally not good practice." Maybe you meant it as hyperbole but it really bugs me when devs shit on each other for not knowing everything. I'm curious to see the actual code snippet though.
jQuery makes heavy use of this. $ is a function with many properties. Also, Function.prototype is already not empty and has properties, such as length (which indicates arity). Also, to the OP, chill the fuck out. Why don't you just go ask the "junior dev" instead of the internet?
There are a few [primitives](https://developer.mozilla.org/en-US/docs/Glossary/Primitive) and everything else is an object. If the object [is extensible](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible), new properties can be added to it. Typically, data isn't stored in a property of some function. Gluing some data to some function is just weird. **Edit:** The main reason why it's weird is because you have to access it "from the outside". You can't use `this`. You have to access it via the identifier, which is used in an outer scope, to refer to this function. var foo = function () { console.log(foo.x); // &lt;- the name which was used in the outer scope }; foo.x = 42; foo();
How about this use case: we want to specify a prototype for objects constructed from a particular constructor. A good, simple way to do that is to add a "prototype" property to the constructor. And that's how JS works. JS itself needs functions to be objects.
When I used JetBrains, I began with Rubymine. Soon, I found out that it didn't have all of the tools that Webstorm had, so I bought that. Then, I needed python support so we buy PyCharm. This is the point where our whole team unanimously agrees that JetBrains is the "DLC model" for IDEs. We could have got IntelliJ for $499 + plugins, but again that's outrageously expensive for the utility it provides. These are Adobe prices in an Electronic Arts business model, which isn't great to me, even though others seem to not be bothered as much by it. Are you familiar with the Sublime plugins system? When I want support for a new language, I simply type a command, type the language I want, and its installed ready-to-use instantly. Configuring the plugins is not only simple, it's very useful as all configs are flat-files that can be checked directly into a repo. I'm not even really here to defend sublime or explain its features. I'm here just to warn people that JetBrains is an expensive path, and my team feels more productive now that we're using less-complicated development environments.
its a nodejs export: module.export = function() {}; module.export.someFunction = someOtherFunction; It just seems unusual for me. also about style, things like JsHint enforce style and consistency to make things ultimatly easy to read. Compared with other languages javascript is very forgiving; however, its considered best practice to use a linter to enforce consistency. Often it will catch stupid errors like using the same key twice, but it will also prevent you from posting shitty code like this (Which this jr dev has and argued with me about how its more readable than using the callback hell...with a linter it will tell you there is an error and a good indicator that you should consider re-factoring it.) currentUser ( function() { likers ( function() { searchingFor (true, function() { similar (true, function() { random (true, function() { searchingFor (false, function() { similar (false, function() { random (false, function() { send()})})})})})})})}) 
Junior dev is idiot sophmore in college who writes code like this: currentUser ( function() { likers ( function() { searchingFor (true, function() { similar (true, function() { random (true, function() { searchingFor (false, function() { similar (false, function() { random (false, function() { send()})})})})})})})}) and argues with me about how good it is. 
Obvious blogspam.
Thank you. That is a really good way to look at it! The context that's throwing me off because it isnt being used as an object but rather an module.export (Also from a "Code smell" perspective, i'd use something like person.prototype (because isnt just assigning it to the person object make it hold on to duplicate copies of the code?.... OO javascript has never been my strength)) 
Maybe you should have more respect for your Junior Developer, who appears to know JavaScript better than you! As others explained, the fact that a function is an object is a standard and useful part of JavaScript. It's something that any JavaScript developer should be expected to know. A property on the function can be a handy way to store data that's common to every invocation of a function. Here's an example: var count = function() { return ++count.counter; }; count.counter = 0; console.log( count() ); console.log( count() ); console.log( count() ); Of course there are other ways you can do that too, such as a closure. Depending on what you're doing, one approach or another may be better. But setting a property on a function object is certainly a valid tool for the right purposes.
If it was a constructor pattern, yes. However, if it's just a singleton you wouldn't want to because then you'd have to call each function on the prototype. For instance: person.prototype.sayHello vs person.sayHello. Only when you instantiate with the new keyword can you forego the prototype attribute since it's looking at its own methods, then the parent's prototype. Since a singleton is only ever in memory once, there's no need to instantiate with the new keyword.
because he argued with me for 2 hours about how readable this is and how it doesn't have any code smell and complains about why the application is sluggish with poorly designed schemas and code rot. (Did I forget to mention this kid is acting CTO, so really he should know better or have a really open ear when it comes to constructive criticism about best design practices.) 
Stoked I don't work with you.
It sounds like you're using the linter as a crutch while your junior dev actually understands critical parts of the language that you don't. If you come at said dev with the attitude of "should I rip his head off or not" then they are not going to help you understand those critical parts of the language, and then they will be the ones ripping your head off in the future. Both of you should have open minds that there might be a better way for you to do things, and saying "the linter flags this as an warning/error" isn't a good argument that something is better, you have to understand WHY the linter is flagging the code. So go back and talk to the junior dev, tell them that you'd like to work with him to find a better way to solve this problem that is better than his mixture of named/anonymous functions and avoids callback hell. For one thing, find out if these functions even need to be asynchronous, because if they don't then there is a much better and easier to read way to solve this flow problem.
Let's take a look at the top depended packages on npm. * 7385 underscore * ~~6881 async~~ * 6014 request * 5572 lodash * ~~3880 commander~~ * 3772 express * ~~2760 colors~~ * ~~2757 coffee-script~~ * 2755 optimist * 2437 mkdirp * 2419 debug * 2342 q * ~~1980 chalk~~ * 1749 yeoman-generator * 1631 moment Ten of the top fifteen packages use this pattern. It's not even in the realm of unusual. Based on this sample it's arguably unusual *not* to.
What was your solution to the problem?
I didn't say that editors have fewer configuration options, I just said that IDEs have a lot (which usually ends up being more than a plain text editor).
I do hope TS doesn't turn into the kitchen sink of programming language features like C# has. It makes things much less approachable for newcomers, in my mind. Anders seems to do that. :-/
So you are saying than editors have less options than IDE's... Which I agree with. By the way I didn't downvote you, I actually agree with both your points. My reply was more of an humorous one, I certainly don't think that my lengthy emacs config is representative of the average editor's config.
That's not what your website conveyed when I checked it out.
I work for one of the largest NodeJS companies there is and we use that format for all our modules. Its easily extendable and makes building a private/public separation a lot more understandable. Im sure it has other benefits but i'm by no means a nodejs expert. 
the reality is at large organizations (Bloomberg, eBay, etc) there are very strict coding standards. When you work on a team of 15 devs, those standards become law and not following them can get you fired. 
Thank you so much! I just have one quick other question if you wouldn't mind. If I wanted to reference a CSS filter instead of opacity that was like this: div.blur { filter: blur(20px); } How would I get the 20px part to change? 
I didnt even fix it. I just tabbed it out to get the linter to give it the OK. If i were to fix it I would unroll the callbacks, maybe use promises or async and make it very clear why we would chose the order we did. (even if we stick with searchingFor calling searchingFor. 
Yes exactly! Thank you so much! You are a true hero! God I looked up and down for "surviving js" and "js survival guide" and what not and just couldn't find it again. Survivejs... who would have thought :-)))
We gracefully handle issue tracking, code reviews, deployment, debugging, version control, dependency management, configuration, testing, linting, optimizing, and more as well. We do it with a combination of Sublime, the terminal, some git hooks, and documentation. You and I don't really have an argument. We agree with each other that the aforementioned aspects of product development are very important, and that they must be satisfied in some way. You find value in JetBrains software to get there. We do not, because we found that we can achieve the same goals with far less configuration, and the flexibility we need to deal with our complex problem domain. Additionally, we like that it takes an hour to train a new developer on our team because they can use the editors they are already familiar with, rather than spending days getting familiar with a new hotkeys, etc. Some might frown upon this because they believe there's value in homogenizing developers' tools, but we find that everybody's different in how they approach productivity, and our people get things done faster when they're given a reasonable amount of flexibility in the tools that they choose.
I think DOM events are a good subject to bring up in an interview. I prefer to approach it another way though. Instead of having people interpret code like this in a white board/pen and paper situation, have them write the html and javascript for something that is accomplished much easier with event delegation. In the real world you don't have to interpret code like this in your head, nor should you when running it and debugging takes a fraction of the time. A standard goto is a very simple todo list with a remove button for each entry that the user dynamically adds. Many people may use todo as an entrance to frameworks, but they are really simple without frameworks as well. If the interviewee realizes they can attach a handler to the container for their todo list that listens for any of the remove buttons to be clicked and removes the corresponding text, then it's safe to say they have a very decent working knowledge of events and delegation.
I could ask you why you *don't* use FF. It's sort of a dumb question (especially with the presumption that it's the wrong choice), and I'm not sure why you asked it. Anyway, here's some of my reasons: 1. I won't use Chrome as my primary browser. Full-stop. * I already go out of my way to limit my interaction with Google these days. They *really* don't need that kind of insight into my life. * I hate the lame kiddie interface. * I don't personally like the dev tools, even though Firebug is going through a rough time right now. 2. Safari doesn't cut it for me, far too limiting. 3. Opera gave up, and is just a weak Chromium implementation. 4. No other browser has nearly as good a selection of plugins. * The AdBlock in FF actually prevents the request from going through. Last I heard, AB on other browsers merely hides the ads, which means they are still able to track you. * I have customized the *heck* out of my FF, to the point where there are some plugins I would rather not live without. 5. Related to above, you can actually customize FF to be what you want, even when they go out of their way to ruin the interface. 6. I don't agree with your opinion on "slow CSS animation" or "cross-platform differences". * CSS animates fine for me. * I only use it on one platform, than you very much * Until *very* recently, Chrome couldn't even render web fonts correctly on Windows, they looked like absolute crap. 7. I assume you mean H.264 when you say MP4 support. It doesn't matter that much yet, but they just added the ability to play back H.264 MP4 files in the last update. 8. Performance and memory characteristics between the browsers is mostly irrelevant these days, they all do a pretty good job. 9. I believe in supporting OSS projects whenever practical.
I also forgot to mention the whole thing is wrapped in a closure regardless (think RequireJs modules)
I'm guessing that falls under the heading "align with ES6". 
So far there was only some work to make the compiler not barf if let and const are used: https://github.com/Microsoft/TypeScript/issues/19 (see comments at the bottom)
Closures are slightly slower, but we're talking about things on the order of 0.3µs vs 0.15µs. Yes, fractions of microseconds. So unless you are creating thousands of them in a single tick of the event loop, I'd go with closures to get "real" encapsulation of private functions and variables,
Nice to see there are other developers in Oklahoma!
I tend to put in closures functions that make little sense outside of the context of the "main" function (ex. add12IfDomainIsGoogleOrYahoo). Exceptions can be made if the function is big, and I want to unit-test it. PS. As far as peformance goes the approaches make no difference in FF, but for some reason I can't imagine Chrome prefers module-locals http://jsperf.com/module-local-vs-function-local
I asked because I wanted to know what you thought, but I'll not bother you with any more sort of dumb questions.
nor generators. that's the number one reason i can't move to typescript :(
Ummm so why would I use a JS solution for this rather than basic CSS? 
Oklahoma City ain't in the Midwest but Thunderplains was nice :)
Well, like usual, it comes down to the fact that CSS really sucks. It can't do everything this does.
in the grand scheme of things, we're saying its .15 micro seconds different but from a performance stand point its twice as slow. Remember often we are trying to create huge scalable web applications on the order of 10,000 concurrent requests and sometimes (not always) processor heavy operations. (Though if we are really going to go down that route, Nodejs is not the best tool to use. )
With Google now [crawling JavaScript](http://googlewebmastercentral.blogspot.com.au/2014/05/understanding-web-pages-better.html), I wonder if progressive enhancement is really worth the extra development time at all. Personally, I feel that [Discourse's](http://try.discourse.org/) approach is a good balance: Users without javascript get a minimal stripped down page with no interaction (which is also good for SEO for search engines that don't execute javascript). Users with javascript get the full experience. The proposed isomorphic app idea is interesting, but I don't think it has much value unless your backend is written in javascript as well.
We're just talking about the overhead of the particular flavor of encapsulation. Any computation you do in your actual methods is likely to dwarf whatever that overhead is. http://jsperf.com/prototype-vs-closures/69 Again, don't optimize until you determine that this is actually a bottleneck in your system.
"Though CSS offers the basic layout mechanisms needed for initial letters – floats and ::first-letter – the solution is incomplete. For the result to be visually appealing, a drop cap has to align with its adjoining text in a specific way. The diagram below shows ..." http://blogs.adobe.com/webplatform/2014/10/02/drop-caps-are-beautiful/ 
I spent 3 minutes of Googling and found this explanation: http://blogs.adobe.com/webplatform/2014/10/02/drop-caps-are-beautiful/ 
Good find. Can confirm that dropcaps.js does more than css alone: http://jsfiddle.net/3qa2gphs/7/ &lt;- As soon as you do get the drop cap aligned properly, the lines will wrap. That said; the CSS-only solution is only 2px off to be fair.
It's still millions of operations per second. Closures have an encapsulation benefit. Prototypes have a speed benefit. Trade off as you will.
Sorry, I meant how do you map jk to Esc in IdeaVim?
There's a method call in there as opposed to a property check, so it doesn't surprise me that the former is faster. Over a hundred times faster is a fair bit, though.
I'd argue that a DOM lookup shouldn't be on the hot path. The method invocation style is slower, yes, but if you've written your code so that there is a cold path (I.e. event handlers responding to user interaction), then it's acceptable to take the invocation hits. Once you're on the hot path (nested loops and things where you have to craft a changeset that will trigger a reflow), then you'll want to cache that value where the JIT compiler can find it. I guess what saying is this performance test doesn't really impart any useful knowledge. Sorry.
Yeah, but how many times in a single execution flow are you going to be checking something like this? Even if you have an ungodly number of checkboxes (50+), the time taken will likely still be imperceptible to the user. This is a micro-optimization that you should rarely, if ever, consider.
At this point I'm only responding so that new programmers searching Reddit aren't lead astray by your blog using incorrect terms and collecting ad revenue. A function that returns another function is what is meant when JavaScript is described as having 1st Class Function. The value contained within a variable is a function. The parameters and variables that are visible to the inner function are enclosed in a "Closure", meaning that the 1st Class Function has data contained within. Partial Application is when you have a generic function that can enclose another function and some parameters in a Closure. Invocation of the enclosed function is deferred until the next invocation of that closure. Currying is when a function has been enclosed in a recursive partial application. Every invocation of the curried function will return a new curried function that is used for partially applying additional parameters. Invocation of the original function is deferred until all parameters have been partially applied. Closures and 1st Class Functions are built into JavaScript, partial application and Currying require a 3rd party library such as lodash or ramda.
Thank you for the suggestion. It may be that generators are the way to go.
You don't need to use a plugin to call a command line script, read node's docs.
Its always good to know how to optimize your application. What if you were creating a table where you needed to check every checked value on a 1,000 element table? On the other side of things, (server side that is) if you're using nodejs a 100 fold performance increase is huge, it means you can handle way more requests from your users or process more blocking tasks in less time. 
Are these two even doing the same thing? I thought $el.attr("checked") returned the 'checked' attribute in the DOM whereas $el.checked == $el.prop("checked") which is the current checked state. Comparing $el[0].checked to $el.prop("checked") would probably be more appropriate. 
&gt; What if you were creating a table where you needed to check every checked value on a 1,000 element table? I still get 300k ops/s. So, checking 1000 would take like... 3 msec. Even with this ridiculous example, it still doesn't matter.
I don't know where you heard that, but being a toxic team member will get you fired a hell of a lot faster. 
I'd go for the Revealing Module Pattern. I think it is clean, provides encapsulation and easy to use. Also avoids having to cache "this" just to get access to one of the public functions from a private one. This blog does a good job at explaining it. https://carldanley.com/js-revealing-module-pattern/ 
ok lets scale it up to 1,000,000 element table. (without using slickgrid)
Wouldn't it be a better idea to *not* check all those 1M checkboxes? This would be sluggish with the other option, too.
lol.
If you're checking the state of 1,000,000 checkboxes, deciding between jQuery method calls and DOM node attribute accesses is the least of your concerns. I appreciate your desire to find a problem for your solution, but the fact remains that micro optimizations [just]( http://blog.codinghorror.com/micro-optimization-and-meatballs/ ) [don't]( http://blog.codinghorror.com/the-sad-tragedy-of-micro-optimization-theater/) [matter]( http://blog.codef00.com/2009/02/11/micro-optimization-is-stupid/). Focus instead on writing clear, maintainable code.
&gt; Drop Caps Are Beautiful Am I the only one who actually finds this design to be kind of disorienting? I mean, I have OCD which causes me to do certain things with letters, but I can't be the only one who would prefer that it's just a capital letter constrained to the same line as all the other letters, right?
&gt; The TypeScript team is working with both the Flow and AtScript teams to help ensure that resources that have already been created by the JavaScript typing community can be used across these tools... In the long term, we will also be working to fold the best features of these tools into ECMAScript, the standard behind JavaScript. This is great news, as it answers much of the questions arising from the Flow and AtScript announcements.
Made me hungry for some reason... 
Turn that frown upside down! :)
I think the idea is that you can find the start of the text more easily.
if `object.open` evaluates to `false`, than `object.open.on` is going to be calling `false.on` which is an error in any sane JS envrionment. Also, making up words is a bad idea.
Not only are functions objects, I made a sweet.js macro to let you create literal function objects to let you avoid the imperative style of declaring a function and then adding properties to it: https://www.npmjs.org/package/fn-obj-literal
CPU usage isn't the issue, memory usage is. In *this particular* closure example, you're creating a new anonymous function for each instance of Person. The prototype option creates one globally. Closures aren't inherently evil when used propery. It's just that this isn't a good use of them. (a instance of a class *is* effectively a just a bunch of methods inside a closure).
I'm fully against doing someone's work for them, whether it's school or professional work, if they're not making an attempt to actually learn. Thankfully, those types of posts are relatively infrequent. I'll remove them if they're against any other guidelines, but generally the sub does a good job of voting these off the front page. As for the _"How do I ...?"_ posts, I've mulled it over before, and I've noticed that these posts usually have a binary outcome: * Either they're uninteresting and don't go above a few votes (they often are at 0). * Or occasionally, they're somewhat interesting and generate decent discussions. I enjoy these, because I often learn something new when so many different viewpoints are given. I also hate to close the door on anyone, seeing as sites like SO can sometimes be very harsh on new students, and it isn't a very good place if you don't know what to ask. And that's where we come in -- many times, the user simply doesn't know where to even start, and reddit does the threaded conversation thing really well.
I couldnt agree more. But if you can still remain clear and optimize performance (this isnt a particularly good case) would you?
Not if my team or I have higher priorities. New features, UX improvement, bug fixes, refactors, test writing, etc will all take precedence in any scenario involving time or money. If I'm working on my own side project, perhaps, but for the education more so than any nigh imperceptible performance gains.
Identify via performance measuring where the hot-paths of your code are. For instance, anywhere you modify the DOM a lot, or draw to a canvas element, those are hot-paths. On the hot-paths, you want to minimize the amount of work you do. Let me say that again, performance gains come from eliminating work from the hot-path. In the case of a DOM modification, those trigger a reflow. If you can stage the change and do it all at once (a good trick is to detach-modify-append the parent element of a large number of child changes), then you only trigger a single reflow and will eliminate work from the hot-path (making it a cold-path). On the cold-path, optimize __NOTHING__. Instead, write simple code for clarity and maintainability. I tend to write things like this (assuming requirejs) exports.some_module = { some_fn: function() { /* code */ }, some_other_fn: function() { /* code */ }, }; exports.SomeClass = function() { /* code */ } _.extend(exports.SomeClass.prototype, { some_method: function() { /* code */ }, }); But of course write what your coworkers think is cleanest. 
Making up words is an amazing idea. And yes you can have object.open evaluate to false and object.open.on... Jeez. &gt; var obj = {} &gt; Object.defineProperty(obj, 'foo', { get:function() { var b = new Boolean(false); b.on = function() { console.log('foobar'); }; return b; } }); &gt; obj.foo == false true &gt; obj.foo.on(); foobar Didn't say it was a good name, or a good idea, but every blue moon it's very useful.
How about you fire the guy that bound two event listeners to the same div. 
That sounds like a well-reasoned approach, thanks :)
I think I'd rather spend the extra two minutes tweaking :first-letter than load unnecessary Javascript ...
If you are checking values directly from the window object I would manually resize the window and make it fit the desired size. If you are using variables to refer to the values I would just set the value of those variables to mimic the value required meet your case. If you want a more detailed log of the window size you can bind a resize event listener and have it log the window size. Be warned it triggers very frequently and should be denounced for any application outside of testing. window.addEventListener('resize', function() { console.log('Width: ' + window.innerWidth + ' Height: '+ window.innerHeight); }, true);
Use Grunt, Gulp is pointless if you already use Grunt. It also has much more mature plugins and elegant structuring if you dive deep into it.
If you have that many nested callbacks, I would HIGHLY recommend you guys start using promises. That oddly written code is his solution to making callback hell look a little cleaner (and it does). Unfortunately it makes it more difficult for others to read, which is even more problematic, but not something he's had to deal with yet. As for "variables" holding a "value", yes, they can only hold one at a time. In this case, the variable is holding a reference to an object which happens to be a Function. In fact, practically everything in Javascript is an object, even numbers. (2).property will return undefined. The reason you have to wrap 2 in parenthesis is because the javascript parser will try to interpret 2. as a fraction and expects a number to follow it. All that being said, I think using functions as the root of the object you return is an amazing practice that everyone should start adopting, because it allows you to create cleaner interfaces for you library. Look at jQuery, for example. The $ variable is assigned a function that acts as an element selection engine, which then chains all the jQuery methods.
Also, an alternative to promises, you could create a library that lets you build a query and auto currys your functions. Here's some "psuedo code" as an example: var result = new Query() .currentUser ( function() {}) .likers ( function() {}) .searchingFor (true, function() {}) .similar (true, function() {}) .random (true, function() {}) .searchingFor (false, function() {}) .similar (false, function() {}) .random (false, function() {}) .send(); And, in fact, this looks the same as the code your dev wrote, but without all the callback hell. I just replaced the callbacks with a function queue that feeds right into the next function. Depending on how your code is written, this could even be turned into something like this: var result = new Query() .currentUser() .likers() .searchingFor(true) .similar(true) .random(true) .searchingFor(false) .similar(false) .random(false) .send();
your button is inside your Javascript script tag. Move it to your body tag and you'll get a button on screen. &lt;body&gt; &lt;button ..... &gt;Press&lt;/button&gt; &lt;/body&gt;
i love you. whoever you are i love you.
You are correct, I just verified it with the ECMA 262. It is on Function instances. That's actually more analogous to what we're discussing anyway, e.g. the OP's example code. Thanks for pointing that out, though!
There are two groups whose browsers choke on a site running IE8-compatible JS: * The 1-2% of users that choose to run with JS disabled or use a browser that doesn't support JS at all. * The 4-5% of users that are using ancient browsers. Regarding the latter group: * If you don't get a lot of visitors from SE Asia, cut the number in half. * If you're using HTTPS and mitigating POODLE, then you're already excluding most of these users. Supporting non-JS or old-JS browsers isn't worthless, but it's getting to be a hard sell if you value your time at all. Isomorphic JS is a great idea, but there's a big difference between being able to render your app's HTML on the server and having your app actually work without JS. Popping up an overlay in your fancy modern frontend? Prepare to add a separate route that re-renders your page with that overlay visible, or add a completely different view to replace the modal version for non-JS browsers. You're going to do significantly more work either way.
I strongly recommend reading this book. It will teach you JS extremely well along with the relationship to the DOM (html I guess). I struggled too yearrrs ago and everything came together because of this book: http://www.amazon.com/JavaScript-The-Complete-Reference-Edition/dp/0071741208/ref=sr_1_2?ie=UTF8&amp;qid=1414129241&amp;sr=8-2&amp;keywords=javascript+reference Do not give up! The frontend development world is extremely Javascript heavy now that it's a super valuable language to learn.
):
Related discussion on Reddit (AtScript): http://www.reddit.com/r/programming/comments/2k4mlk/google_atscript/
Damn, looks like strong typing is on the brink of being "in" again, even among the js hipster crowd.
You sound like an arrogant prick. If your junior dev decides to leave because you seem so adamant about "ripping his head off" please do have him send his resume my way; he seems to know more than you about js.
CSS doesn't suck, it's just a complicated problem to solve. If the solution to every technical issue could be implemented as easily as it is to explain verbally ("Just make the first letter align with the text, *surely* it can't be that hard") then the world would be a very dull place and we'd find our job security in question. The serious answer is that the baseline in typography is the bottom of non-descending characters on which the type is set (like in a schoolbook) but on the web the baseline is an imaginary line in the vertical middle. This makes it very difficult to implement dropcaps when the top and bottom of a character cannot be known until it it's rendered, hence a JS solution.
I would too, until the webfont fails to load and it falls back to Helvetica and breaks the alignment. As I said elsewhere: &gt; The serious answer is that the baseline in typography is the bottom of non-descending characters on which the type is set (like in a schoolbook) but on the web the baseline is an imaginary line in the vertical middle. This makes it very difficult to implement dropcaps when the top and bottom of a character cannot be known until it it's rendered, hence a JS solution.
Feel free to fork and improve
Yeah, rip his head off about it so everyone in the office knows how stupid you are. Hopefully you get fired.
That's initial page load time. If you're checking the state of 1,000,000 checkboxes on page load, then you're doing something wrong...
That might matter when you are creating table with millions of entries which containt checkboxes, but as someone already pointed out the performance of checking checkbox won't matter then, because your whole UI will just probably freeze and die until that point. And if you really want to optimize then you should consider using MVC framework where you would have models/collections and you wouldn't need to access DOM elements _AT_ALL_
It was not meant not be cocky. Maybe it is just my english that is bad. I am just saying that I am not going to put any effort in convincing "why use framework X instead of Y". And I dont know all the implementation details of other nodejs ORMs. 
If you're using the full ES6 grammar, then no, you don't need to use the `var self= this;` pattern for creating a closure with the `this` value. You can instead use fat arrow syntax `(args...) =&gt; { body... }`. If you aren't using fat arrow syntax, then yes, you still need to do `var self = this;` to store `this` in a variable that is closed over.
Why would I want this over an arduino with something like [johnny-five](https://github.com/rwaldron/johnny-five)? 
MutationObservers are really cool, but another option to know when new content arrives its to hijack ajax. Here's a simple example I posted at SO once.... http://stackoverflow.com/a/11811558/189093
Johhny-five requires it to be plugged in to something running node. This runs JavaScript right on the board.
Don't ever 'rip' anyone a new one. Not only will they hate you for it, but they'll also take nothing onboard which you said. Senior dev should be a mentorship role, not a 'I'm your boss asshole now code exactly like I say just because'. Teach them and they'll love you for it.
The serious-serious answer is that CSS is a black box whose machinations are designed and approved by committee. And so, if CSS cannot do something, you are screwed. If a new feature was added to CSS, you'll be waiting years before it becomes relevant, but it will be buggy anyway and there is nothing you can do about it. 
Some jquery event handlers change the context to the element that the event happened on. Since `this` would be meaningfully different, you'll need to keep tabs on what self is.
i dont use jquery
Looks like you need to read up on how *this* works in js. I don't think answering this question will give you the answers you really need. [You Don't Know JS: This &amp; Object Prototypes](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/README.md) covers it really well.
thats not it. He's an arrogant prick who fights his code reviews to the death when there are serious design flaws, bugs and other careless issues. 
Sure, instead of get combination, try making a combine object. Just overload the + operator (and the += operator) of combine, and you can define that regardless of the order received, the combination will result in standard output
Nice trick :D Here's another writeup about it: http://peterhrynkow.com/how-to-compress-a-png-like-a-jpeg/
I think that's a little pessimistic. The specifications may be written behind closed doors but it's browser vendors who have the ultimate veto when it comes to support. No-one's holding a gun to vendors and forcing them to implement the spec, nor is anyone doing governance on the specifics of the implementation (note how the specs never go into the mathematical nitty-gritty for things like `border-radius`, despite its obvious reliance on bezier curves). In this particular scenario, the problem was addressed with the `:first-letter` pseudo element but it can't be used for perfect dropcaps because of the way the type is rendered on the baseline. To fix this would require all vendors changing browsers to show type above the baseline rather than over it, and that's not an easy problem to solve. Do you introduce a new mode like we did with `box-sizing` or should it be a separate browser mode (like compatability mode)? Even if you do successfully get a new baseline model into the spec, vendors need to actually implement it. It's imperfect, sure, but it's not all doom and gloom. We can't have people adding things willy-nilly when these things affect the entire internet.
&gt; No-one's holding a gun to vendors and forcing them to implement the spec If only they would! &gt; To fix this would require all vendors changing browsers to show type above the baseline rather than over it, and that's not an easy problem to solve. Do you introduce a new mode like we did with box-sizing or should it be a separate browser mode (like compatability mode)? Even if you do successfully get a new baseline model into the spec, vendors need to actually implement it. This like a confirmation of everything I posted. Not sure if self-aware or not.
It's a neat trick, but that example is not very honest. You can easily toss the initial gauge graphic into [ImageAlpha](http://pngmini.com/) &amp; [ImageOptim](https://imageoptim.com/) and get the PNG down to 35K with no visible loss (certainly no more loss than JPEG). This makes it a difference closer to 10KB (77% of the original size), and gives you broader support without worrying about SVG edge cases, or potential performance issues. Actually, I just tried it again, and at 128 colors the gauge was only 28KB, with very minor noise. **Edit:** Obligatory THANKS to whoever gilded me! I'm glad I could share these tools (which are not mine) with you.
The only thing motivating browser vendors to implement new features is competition, stability and development efforts. There's no such thing as a perfect browser but you're free to fork chromium and give it a go! I'm not disagreeing that the closed nature of much of the decision process is a bad thing, but to say that if a certain feature isn't implemented in a certain way then there's nothing you can do just isn't true. Floats, for example, were made for aligning images but for years we've used them for layout. We've always strived to make things happen regardless of the odds and proclaiming defeat because Opera decided against so-and-so goes against the spirit of the industry. Besides, to whom would you give the authority to make these decisions? An elected body? Leaders in the field? Those with a vested interest in the state of the web, like browser vendors? What I am disagreeing with is your assertion that new features are buggy. See the first part of the quoted paragraph for explanation of why it's not a bug but just how browsers work.
I tried this yesterday and every test I did was actually larger than the PNG. They do say: &gt; There are cases where the size of the original PNG is actually smaller than the SVG version. That is usually the case with images that have large monochrome areas or certain types of linear gradients. In these cases PNG can use some very efficient compression methods that are better suited than JPEG. Well, you can't win all the time. So maybe it's only better on images that require contain more complex gradients and transparency. I can't immediately recall every needing an image like that in any of my projects though.
&gt; Besides, to whom would you give the authority to make these decisions? That isn't the point. Any technology which is so high-level that its behavior can only be changed and maintained by one party (the browser vendor) is inherently unsuited for software development. Thankfully, CSS Extensions will allow you to simply rewrite bad CSS behaviors in JavaScript, and that should greatly help us get CSS reliance out of our lives. Things like Dropcap.js will comprise most of your CSS work.
No, as stated in the faq you quoted, the more complex gradients and transparencies are NOT going to reduce in size (generally speaking) with ZorroSVG. This would work for GUI elements that are image-based or logos/icons. I got some major size changes with these types of images in the drag-n-drop box. 
For a basic solution you could use a couple of objetcs, e.g. http://jsbin.com/qemixaputu/1/edit?js,console
Yeah thats what i figured. I wanted to give Gulp a try, and everything up to this point was going ok. I still havent figured out my issue, and if its working fine on the Grunt side, i might as well stick with the one that works.
Classes don't do anything about `this` so yes, any time you need to close over the this value you will need to assign it to a var.
for future use you could do var numbers = []; var x = prompt("number"); numbers.push(parseInt(x)); var x = prompt("number"); numbers.push(parseInt(x)); var x = prompt("number"); numbers.push(parseInt(x)); alert(eval(numbers.join("+"))); 
Doesn't work in Firefox.
probably size
Hum. Most of the images I tried were much heavier with zorrosvg than originally, often thrice the size or more. Does this reduce the size only for not optimized images ? Also, there seems to be a problem on Chromium ( *Version 34.0.1847.116 Ubuntu 12.10 (260972)* ) : images aren't rendered.
Why did I not know about this tool! Its incredible. A 430k png with tons of color shrunk down to 73kb.
"var x" doesn't need to be defined 3 times, the first "var x" defines it for this scope, so "x" exists after the first prompt... It is better in practice to define three discreet variables for the scope, as they are indeed 3 discreet things, and if the code ever needs to be worked on later, it will be much easier to know what is what and when. There is absolutely no need at all to use "eval" here. It is ill performant and totally doesn't give you anything. Just do: var total = numbers.reduce(function (previous, next) { return previous + next; }); alert('' + total); Sure, eval is shorter, but it isn't any clearer, gives you nothing, and is not an appropriate use, see here for more info: http://jslinterrors.com/eval-is-evil
I am trying to do the same thing with grunt but I can't seem to get it to work. I need to workon a virtualenv and start the server: bgShell: { _defaults: { bg: true }, workon: { cmd: 'workon projectname' }, workon: { cmd: 'manage-projectname runserver 8080' } }, But i just get this: &gt;&gt; /bin/sh: workon: command not found &gt;&gt; /bin/sh: manage-howard: command not found &gt;&gt; Error: Command failed: manage-howard runserver 8080 &gt;&gt; Error: Command failed: workon howard So my question is what are you doing here?: cmd: 'python &lt;%= paths.manageScript %&gt; runserver 0.0.0.0:&lt;%= port %&gt;' 
Please read up on reddit's rules @ http://reddit.com/rules, specifically point #1 of rule #1. Our [guidelines](http://www.reddit.com/r/javascript/wiki/index) also have more information regarding promotion &amp; self-promotion. **Consider this your only warning.** If you continue to post _only_ your site, we'll be forced to take action. Thanks for your understanding.
Please read up on reddit's rules @ http://reddit.com/rules, specifically point #1 of rule #1. Our [guidelines](http://www.reddit.com/r/javascript/wiki/index) also have more information regarding promotion &amp; self-promotion. **Consider this your only warning.** If you continue to post _only_ your site, we'll be forced to take action. Thanks for your understanding.
cool. nodeJS support?
Thanks, I understand.
Those wrapped by &lt;% %&gt; are just variables i set. O your code, i dont think having 'workon' twice inside your bgShell helps. It should have different names. Then when you call it, it should be something like: grunt.registerTask('serve', [ 'bgShell:workon' ]); 
Hmm well that is odd. I tried with 3 different PNGs with no gradients and each saw between 200% and 450% size increase. I'll have to read up more on various compression types I guess. I only have basic knowledge in that area. 
Disclosure: I worked on part of this website – not the collage module, though.
That's really cool, but all it can make me think about is just how bad inflation is? What is the price measured in? So the S&amp;P was worth 100 (somethings) in 1970 and it's now worth 1800 of those somethings today?
Fair question. Unit is U.S. Dollars. 
Unless your job is to implement JS engines, I don't think you really need to spend much time reading the specs cover to cover. Like you said, they're a very dry read. But also, you won't get much out of it. It doesn't tell you anything about "best practices". You will not remember the details once you've read it so you'll always need to use it as a reference anyway. Using the document as a reference is really the key skill you should be exploring. For example, play a game. Take a snippet of code, maybe from the famous WAT presentation, say `[] + []`, and figure out how it should behave without running it. Then run it in browsers and see how it behaves to check your work. If you find that browsers act differently, congrats, you've probably found a bug! Spec reading is a skill I think more people should have. A large number of questions in this subreddit are trivially answered by the spec. It's definitely a good skill to have, but don't try to read it cover to cover. It won't help you much IMO.
Yikes, I think you're being harsh but I agree; that solution is incredibly unmaintainable. 
haha sorry just a typo, so that variable is just a path to the folder that has the manage.py file?
It's a simple(?) Logic puzzle with ill defined rules... You say that if both of them being the same is incorrect, then marking the first one correct if it's the correct answer is not the proper solution. You need to wait until both answers are selected in order to analyze the result. If the rules state that they can select the first one and get it right immediately, then they are right. This boils down to what the ruleset is. Both of you could be right, but the rules need to be more clearly defined.
Jesus, i really hope this guy is trolling...
Downvoting for Blog spam and: 1) you can re-write #4 to using a for loop over the length 2) BAH! never do #5. I will hate your site forever.
FYI, the name of a named function is bound within the scope of a function. So, you can write: var foo = function myself () { return myself.x; // &lt;- the name of the function }; foo.x = 42; foo(); //=&gt; 42
I typed it on my phone and it didn't keep the formatting. So Sorry! Ok so the question is: What is a note that is one half step away from the note A So possible answers are Gb and A# so there needs to be two places for the user to answer the question. If the second drop down is the same as the first drop down, for instance the user selects, Gb Gb then the second one is automatically wrong. However the first one could be right and give the user 1 point instead of the possible 2. Then the check doesn't happen until the user presses a button at the end that says grade. Since it is a long quiz, there are many little checks and a number correct counter that increases by 1 every time there is a right answer. When the answer is correct, it outlines the entry field green. When it is wrong it outlines it with red. My version of the code is like this: var userAnswer1 = document.getElementById('theDropdown').value(or what ever it is) var userAnswer2 = document.getElementById('theOtherDropdown').value(or what ever it is) if (userAnswer1 == userAnswer2) { userAnswer2 is outlined in red and does not give a point //then check if answer1 is correct if (userAnswer1 == "Gb" || userAnswer1 == "A#"){ userAnswer1 is outlined in green numberCorrect++ } else{ userAnswer1 is outlined in red and does not give a point } } else { //Then check if answer1 is correct if (userAnswer1 == "Gb" || userAnswer1 == "A#"){ userAnswer1 is outlined in green numberCorrect++ } else{ userAnswer1 is outlined in red and does not give a point } //Then check if answer2 is correct if (userAnswer2 == "Gb" || userAnswer1 == "A#"){ userAnswer2 is outlined in green numberCorrect++ } else{ userAnswer2 is outlined in red and does not give a point } His code would be something like this: var userAnswer1 = document.getElementById('theDropdown').value(or what ever it is) var userAnswer2 = document.getElementById('theOtherDropdown').value(or what ever it is) if (userAnswer1 == "Gb" || userAnswer1 == "A#"){ userAnswer1 is outlined in green numberCorrect++ } else{ userAnswer1 is outlined in red and does not give a point } if (userAnswer2 == userAnswer1){ userAnswer2 is outlined in red and does not give a point } else { if (userAnswer2 == "Gb" || userAnswer1 == "A#"){ userAnswer2 is outlined in green numberCorrect++ } else{ userAnswer2 is outlined in red and does not give a point } } While I know that both would accomplish the task. Which is better? 
&gt; some find crockford's rules pedantic and dogmatic If you don't then you're lying to yourself. The only thing I can recommend that came from Crockford is JSON. JSLint and JSMin are trash.
i didn't want to come off like an ass saying "well, i'd suggest you do this because you don't know any better but i think it's shit..." for someone starting off with a year of experience and no style who's been reading the es6 spec for guidance it seemed like a step in the right direction. i use jshint [tuned to my style](https://gist.github.com/paulwe/560f6b39ff896e48f808) but i wouldn't recommend taking that step without some guidance to begin with.
A user-friendly way would be to remove the item selected from the second drop down when it is selected in the first. It's a quiz though, so that might alter their answers... Need more input, Stephanie.
The prompt function will block until it's gotten the input from the user, at which point it will return the input. So it would look like: var sideA= prompt("What is side A?"); The result of whatever was typed into the input box will be in the "sideA" variable. You'd do that 2 more times to get the other sides (and probably validating them for number input, I suppose).
Impressive, but glitchy.
Care to elaborate?
Safari has had major problems with transition for a few years now. I don't see it getting fixed any time soon. If you need to support Safari, I'd recommend that you avoid using transition entirely. As a side note: don't trust jquery to 'smooth over' those kinds of cross-browser issues. Despite its reputation, that's never been a strength.
very impressive. alot of flickering on chrome 38 64bit
I'm guessing the glitchyness is due to the browser. Chrome does an alright job, but you see some flickering of shadows. Firefox is really slow and glitches all over. I guess this is a good benchmark for 3D CSS transformations.
Jquery may add prefixes to css property names, but I highly doubt it's going to parse through the value and prefix it. Try passing '-webkit-transform 10s ease' as the value (will also work in chrome) and I think you will find that it works. Or better yet, use a css class and autoprefixer. The css method alters the style attribute directly and this should be avoided. 
Wonder what version of JavaScript. Also how will speed and energy efficiency compare to, say, arduino.
It's literally impossible to give advice at this point without a lot more details... Have you tried looking in the console?
This could be very interesting. Being able to configure Nginx with JS? That has possibilities.
A less opinionated (but still opinionated) linter would be the fork JSHint.
As ayouker mentioned, the problem is the transition property. Changing the transition to be applied on all properties makes this work. The transform property is prefixed in Safari still, hence plain 'transform' does not exist. Vendor prefixes issue, put plainly. ie: http://jsfiddle.net/tzjedpr1/1/
Odd that things are so bad! Surely a webkit browser that prides itself on javascript performance would be able to do animations.. By the way, I agree about not trusting jquery usually, but for this fiddle you get the same results with or without prefixes.
I agree.. I'm using jquery for prefixing just in this jsfiddle, and doing the prefixing manually has the same result. With that in mind, any idea how to solve the problem? 
Ah! Perfect, thank you! Couldn't find the issue mentioned anywhere on google, which surprised me for something so basic. 
Unless this thing utilizes V8, then I'd say no. I didn't see it in any of the details. It looks like they're rolling their own run-time.
Zoom in and out for funny result.
Ha! You and I have similar JSHint rules. The only big difference is I enable "asi". I normally use semicolons, but I hate being forced to use one at the end of a block (e.g. `if (bar) { foo.bar = bar }`) [1, 2, 3].map(function(i){ return i * 2 });
2008 post :(
Your liquidSim.paint is called every 10 milliseconds. That's overkill because 60fps is only every 16ms. So either set setInterval for 1000/60, or -- even better -- just use requestAnimationFrame because it's typically 60fps and it will be synced with the browsers redraw.
Odd, it's insanely slow to move in Chrome for me.
Maybe not the answer you're looking for, but I would do this with a Python script, and not try to make a browser plugin for this. [Requests](http://docs.python-requests.org/en/latest/) to pull data from the web and [BeautifulSoup](http://www.crummy.com/software/BeautifulSoup/) to scrape the HTML. Once you get the data into a native Python structure, doing what you . I didn't read your entire post, but this combination of Python modules will let you scrape and parse pretty much anything from the web. I'm sure it's possible to solve this problem with Javascript but it honestly sounds pretty awful. 
The AirBnB JavaScript style guide is pretty decent to work off, https://github.com/airbnb/javascript I use it all the time when I'm doing development for myself. But it is worth checking a few others as well and maybe picking and choosing the bits you like. I had a look at the jQuery style guide a while ago, it is definitely not my preference but everyone has their own style they feel comfortable in so worth the read incase you spot something you like. Always be flexible, if you start working for a company that have a particular style guide, be able to work with it too. Really, it doesn't matter what style guide you're working off in a team, as long as everyone is using the same one, then you'll get uniform easy to read code. 
I'm on a mac and here I tried Firefox, Chrome and Safari. * Firefox was glitchy and slow. * Chrome was better but somewhat glitchy. * Safari was smooth and without glitches. Run on a MackBook air.
var shit = (parseInt(prompt("Side A"))\*parseInt(prompt("Side B"))\*parseInt(prompt("Side B")))/2; ???? profit?
var str = "swag"; if(str == str.split("").reverse().join("")){//execute}
Getting Undefined in Chrome Console.
same thing but maybe this one alerts. var str = "swagaws"; if(str == str.split("").reverse().join("")){alert("swag!");}else{alert("not swaggin");} either way i didnt do anything to it. so copy paste better?
Zoom in/out is essentially a FOV setting in this case.
Very cool, but I wished they would collaborate with TypeScript instead of going their own way.
Maybe you should link directly to the site &gt;_&gt;
It's only a matter of time before someone creates a (partial) compatibility layer (if has not already been done, since the actual firmware exists for a few years now).
Looks like Actionscript 3. I like it - but I've become so used to the expressiveness and flexibility of duck typing I don't know that I would like it in practice. When coding in Java, I get irked by the troublesome typing - and the need for all that jazz. I find the way javascript works to be faster and more clean. The code is more terse and there is little need for all the extra crap you need for aspect oriented programming in Java. 
Good. But the Problem is, When I read source of Gmail , i cannot understand what is stored where. But In other websites, i can easily find datas in cookies, query string or input hidden or data-. 
Don't forget IndexedDB. A full document database in the browser. Check out db.js for a nice wrapper. 
Glad to know skynet is supported 
I'd love to see ML style type inference. A large portion of code written *today* could have static type safety with little or no syntactic changes. Would be very useful when maintaining complex codebase. Do-notation would also be a nice addition, especially for writing imperative looking async code. 
From the bottom of the article: &gt; # Prior Art &gt; &gt; The AtScript has been influenced by TypeScript and Dart. Here we would like to discuss why these existing solutions do not meet our needs. &gt; &gt; ## TypeScript &gt; &gt; * Types are analyzed statically only. &gt; * Static analysis makes it difficult to have optional types, since static analysis can not analyze what is not typed. (type inference has its limits) &gt; * Static analysis can not be used to assert that the JSON returned from the server has valid structure. &gt; * Lacks meta-data annotations &gt; * Provides no mechanism to access the annotations at runtime
Did you do the prefix for the argument as well that I mentioned? I think it will prefix the key ('transition') but not the value ('transform 10s ease'). Safari doesn't support unprefixed transition or transform so you need to use -webkit-transform 10s ease. Edit : don't forget the transform argument in there could be any css property like width, font-size, etc. It'd be a lot of work with a lot of potential edge cases for jquery to parse out that string, determine if the first argument needs prefixing and then apply it for you. The property name makes sense to auto prefix, the value is a string with multiple (possibly malformed) arguments and it won't prefix that for you. The other option is to pass all the prefixed versions into the css method yourself. 
Also this guy's response is bs. Safari has no issues with transforms that I have seen and I use them generously on ios and Android. The only problems you run into are that ios 8 now supports unprefixed transition and transform, but that's progress we want, not a problem. 
One thing to keep in mind is that iterating using forEach is slower than a for loop because it incurs a function call for each item. Not noticeable in most apps but could make a difference here.
sessionStorage is a flavor of localStorage that is cleared when the tab closes.
In addition to what everyone else said you could store data by writing comments to the page in javascript, store data inside the color channels of an image with canvas, store data in css properties that don't get used, store data by hiding it inside an asynchronous function - maybe something [like this](http://jsfiddle.net/wpb4rh8d/1/)
Don't use an unordered array to represent large amounts of data you want to search. An easy solution, if not a perfect on: if the values in the array are all strings (or can be represented as such), push them all into a hash. (Do this once, *not* every time you want to search the array.) var arrayHash = {}; array.forEach(function(v){ array[v] = true }); ... if(arrayHash[URL]) { // do something } If you need to update the array data, you can write a function that pushes the new value onto the array and simultaneously sets the corresponding hash key. Now, this *might* still be very slow, because that still might be the wrong data structure for your needs. It's just a lazy solution that might be good enough. (It's also terrible for memory usage, but only you can tell if that will be an issue for you.) A better solution *may* be to use a more appropriate [search data structure](http://en.wikipedia.org/wiki/Search_data_structure), such as maintaining a sorted array and implementing a binary search, or maintaining a binary tree, and scanning that for the item. Both of which you can search for implementations online.
I should have pointed out, one of the reasons the native `indexOf` is so slow is that it must check for *both* type and value equality (`===`), and it knows nothing of your array's data, so it has to scan *each* item, one at a time, until it either finds something, or makes it to the end.
in memory.
Other replies already address performance, so I'll just point out a bug: Array.indexOf will return 0 or 1 for the first and second items in the array, and -1 if the search item is not found at all.
=== is actually more efficient than ==, it's just the large array size and linear search that's the problem here. also the hash will never be slow, hash lookup is pretty efficient, it just may use a lot of extra memory.
Yes but instead of expanding on the existing work they start again from scratch and increase fragmentisation. Now every IDE and other tools has to support another language and we waste again a shitload of effort.
Do a quick google search for 'safari transition' and you'll get a good overview.
Huge webapps like Gmail are usually built with frameworks. Most of, if not all, the markup is automatically generated by Javascript. Look at the markup of [this example app](http://dev.sencha.com/extjs/5.0.0/examples/simple-tasks/index.html). It is unreadable, because everything was generated. The same frameworks are responsible to store the data, usually in Javascript objects.
Oh, I'm not disagreeing with you. I just wanted to provide their reasoning for advocating this instead of TypeScript.
That's a good point, but keep in mind that JS arrays are really (usually) implemented with the same hashtable behind the scenes. If every array reference is just a hash lookup, then there's no way a binary search can win. [This stackoverflow article](http://stackoverflow.com/questions/12241676/javascript-objects-as-hashes-is-the-complexity-greater-than-o1) has good benchmark links.
My feeling is TypeScript has entrenched itself, has gone extremely defensive about being a static compilation toolset. They explicitly rule out the kind of problems AtScript targets: enriching runtime type information. It would be great to see TypeScript collaborate with a project (* really many projects) that try to make type information available in the runtime.
What this (and TypeScript) do is a lot like the way ActionScript evolved. AS2 was pretty much syntax sugar on AS1 (which was basically JavaScript/EMCAScript), just like the ES6 style classes.
My guess is A(nnotations)T(ypes)Script.
no. just no.
SessionStorage URI hashes Global heap variables (duh) Some flash and silverlight technologies probably Dynamically generated script tags (ideally with type set to application/JSON) Hidden plain text DOM elements Arbitrary CSS generation Window.name IE5-9 also support a proprietary technology called binary behaviours (but it's pretty obscure) There are probably an *infinite* number of ways.
Thanks, I have a question. how can I do function abc.foo() {//blah blah} ? I am getting an error.
They're trying to bring dynamic types and inference to C# and iOS (via Swift) and static types to JavaScript. What the fuck is wrong with these people? ES5/ES6 brought/will bring plenty of cool features and syntactic sugar to the language. I think that's more than enough. I find all these (CompilesIntoJavaScript)Script a total waste of time. JavaScript is a great language all by itself.
http://i.imgur.com/ER6kpPY.png
Looks alright to me to be fair. The use of *i* as a loop counter is contentious, but a fairly reasonable piece of code from what I can see. I personally make many variable declarations, to help break tasks down into chunks and hopefully make the code more readable with clear variable names. Also, as far as is reasonable I try to make them single-assignment, following from a more functional approach to make the code more easy to reason about. JSLint is a fine way to run your code through some excellent rule sets, though I'm not sure I agree with all of the out-of-the-box rules. 
&gt; https://github.com/airbnb/javascript wow I had no idea airbnb put so much into the style of their javascript -- it's a little scary even.
Try using a front end MVC framework like Backbone, it will help organize your code and separate out your HTML. 
I always wanted to learn some MV* framework but It's was hard for me to choose which one, I think i would give backbone a chance In what backbone bewtter than angularJS or Ember?
&gt; My feeling is TypeScript has entrenched itself It is way too early to make that kind of call. The 1.0 release was just this year! The TS team have plenty of work to do maturing TS and filling out the most useful extra features in their static type system. For example, tuple types and union types have landed in trunk and are being ironed out. Putting in runtime type info is useful, but they have more important things to do right now. 
They are all different in their design philosophies. Personally I have not used angular or ember, but I use backbone extensively with the isomorphic JavaScript framework Brisket. Check it out: https://github.com/bloomberg/brisket Someone else might be able to comment more about angular or ember. Backbone is pretty straightforward 
the definitive is here: https://github.com/rwaldron/idiomatic.js/
&gt; I've become so used to the expressiveness and flexibility of duck typing The vast majority of functions expects very specific parameters and they return one particular thing. With optional types, you can tell your tools, your colleagues, and future-you how some function is supposed to be used. You can do something similar with doc comments, but no one wants to write those. In JS, they also aren't standardized and tooling support for them is rather poor. The types of your variables are usually also rather fixed. E.g. you use some `var` to store the result of some function which returns an `int` and you won't reuse that variable to store, say, a `String`. The reason why you generally aren't flip-flopping types is because it makes the code extremely hard to follow. Also, how could the name of a variable be any descriptive if it could refer to all kinds of things? Furthermore, flip-flopping types is terrible for performance. As a direct result of that, type inference can usually figure out what all your `var`s are as long as the "surface area" (e.g. arguments and return types of functions) is annotated. This means very few type annotations are needed to get all of the tooling benefits. Inside your functions, type annotations generally won't be needed. The exception are things like getting some element from the DOM where you then might want to clarify that this is actually, say, a `CanvasElement`.
It is very difficult to keep things clean when you're inserting HTML with jQuery like that. I think this could benefit from dividing a lot of the logic into functions. It would also help to assign some of these values to variables with more descriptive names Whenever i am about to write a loop or a condition I always consider creating a function instead. In many cases it can make your program a lot easier to read. It also becomes more scalable. Example: var pageExists = correct[$(this).attr('data-link')] // assign a rather complicated statement into something that makes a bit more sense if(pageExists) { setHtml(); //Or a better description of what's going on } This is a much more scalable way of dealing with listeners. You can potentially move the logic into separate files as well. // OnReady $('[data-link]').on( 'click', dataLinkHandler) $('.something').on( 'click', somethingHandler) You don't need to use a template engine like http://handlebarsjs.com/ but it makes it possible to move html to separate files. That makes things a lot cleaner. In your case I would just do something like this. function getListTemplate() { for(var i=0; i&lt;list.length; i++) { html += "..." } return html; } If you want to take your JS a bit further I would recommend looking into a framework
i've updated my assignment. do you have any magic answers for this one?
All of those are pretty difficult to learn if you're not familiar with MVC frameworks. Knockout.js might be easier just to get started, then you could check out any of the ones you mentioned. There seems to be a lot more jobs with Angular than any other framework, but I'm sure that depends on where you live.
i have no idea what you just typed. keep in mind this is my very first attempt at any kind of programming ever. what you did was the equivalent of throwing someone who's never played games into dark souls.
To see how it's used: https://github.com/resonantcore/lib/blob/master/demo/diceware.html
Aaaaand it's down.
You can't declare functions like that. If you are looking to have a class abc with method foo, you would have to do something to the effect of `abc.prototype.foo = function(){//bar}`
Angular is pretty great if your cool with doing things "the angular way". If all you want is some structure to your display code, I would check out react, otherwise angular/ember/backbone/knockout are all great choices for structuring the front end of an app. I really like react, but angular is great when you just want something to take care of everything.
Are you sure about that? I just ran this in my Firefox console and it worked as expected. (function () { 'use strict'; console.log(foo()); function foo() {return 'foo' } }());
holy shit -- that might be what I'm looking for.
More frameworks yes! More. 
my goal is basically to not pollute the global namespace, so I can have functions abc1.foo() and also abc2.foo(). will the 'prototype' let me do this? 
I'm also of the belief that observables/computed observables along with templates are good at describing most things in contemporary web applications. By comparison I've found Backbone's and Angular's main abstractions to be less apt. Although I haven't used it, React seems to employ a similar strategy of providing conceptually simple "core" facilities and building from there. As far as "architecture" goes... yes there are some common organisational conventions, and working with a "framework proper" (ex. Angular) could be a good learning experience. It's rather hard to say whether the approach is generally good or bad.
Thanks for catching that - looks like I forgot to turn off some dev flags when starting up the server. Should be a bit faster now. The uncompressed JS file is dynamically generated on the backend, and serves all the inline Mojo components such as the code editors. It also contains the Ace editor, which also explains its large size. 
I do see an issue with your code. JavaScript is case sensitive. "date" is not the same thing as ["Date"](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date). Always make sure you are capitalizing things correctly (note: this does not always mean capitalizing the first letter). You have to do four things: 1) Get user input. 2) Get the date. 3) Make decisions. 4) Print something to the screen. I have literally just googled "Javascript get user input", "Javascript get the date", etc. and got a helpful result on all four of those. What in particular are you having difficulty with?
The MVVM pattern that it encourages has a lot of value, i.e. you craft your code to bind to an existing DOM element, and where you can those elements have already been described in the html document. It leads to an interesting simplification that if the HTML element is missing, you just don't create and bind the object, which makes the code fairly reusable.
Ditto. I'd like to hear the arguments against optional static typing. Seems like a development and performance win, if you opt in. &gt; and there are probably people on the committee who would rather anything happen but types be added to JavaScript.
Couple things that are helpful to keep in mind: - Save DOM manipulation until the end when possible. - Can't see the rest of the code, but looks like you're leaking variables into the global scope. - Return early or handle the "bad" case first when you have giant if blocks (referring to your data-links click handler). - Better variable names might help (mainly referring to "correct"). Also, it can be helpful to style your variables differently depending on their scope (such as prefixing with _). - If you find yourself constantly referring back to a DOM element or an object property, just cache it (this is especially important for DOM elems). This has the added benefit of improving readability. It's honestly not that bad, it just needs some TLC to be maintainable. Some other posters have made some excellent comments about separating your event binding from its handling. Doing this helps your readability (and reusability) tremendously. I was kinda bored so I took a stab at refactoring it... haven't tested it fully so it could be broken to hell :P. Sometimes it's just interesting to see how other people solve the same problem. http://pastebin.com/ydtudi5v 
Its main competition is React, not Angular, Angular does a ton more. And all the cool kids have moved on to React. I still use Knockout, I like it, I think it's underrated. But its syntax is pretty ugly compared to newer alternatives. Maybe my favorite thing about Knockout is it's simplicity. Compared to other data binding libraries, it's easy to wrap your head around. It's also easy to make sure you're not running tons of useless updating code, which is very common in Angular.
I try not to use square brackets when I'm not doing a variable lookup. With `$_GET['distro']` the string 'distro' never changes. So you can just use dot notation.`$_GET.distro` and cut out some characters. Also if you're going to run a look up more than one, consider storing the results in a variable. For example you do `distro[$_GET['distro']]` a couple times. Instead store the result `var distroValue = distro[params.distro]` This is especially important with jquery lookups like this `$('#inner')` because its a really heavy operation to execute a DOM lookup. Instead store the results of the lookup for later use. `var $inner = $('#inner');` [Heres an annotated version of your code with my notes.](http://jsfiddle.net/blueeyeguy/ue3m0xre/) [Heres a more readable version of you code.](http://jsfiddle.net/blueeyeguy/ue3m0xre/1/) Also read [_Clean Code_.](http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1414285191&amp;sr=1-1&amp;keywords=clean+code) 
Hello. Maybe this code is what you are looking for: (function () { // Asks for the name var name = window.prompt("Type your name please:"); // Get the current hour of the day var currentHour = new Date().getHours(); // Initialize the welcome message var welcomeMsg = ""; // Morning if (currentHour &lt; 12) { welcomeMsg = "Good Morning "; // Afternoon } else if (currentHour &lt; 18 &amp;&amp; currentHour &gt; 12) { welcomeMsg = "Good Afternoon "; // Night } else if (currentHour &lt; 24 &amp;&amp; currentHour &gt; 18) { welcomeMsg = "Good Night "; } // Get the body DOM element var body = document.getElementsByTagName("body")[0]; // Write the welcome message with the name body.innerHTML = welcomeMsg + name; }()); Here is the JSFiddle with the example above: http://jsfiddle.net/qwpdrpmg/1/ I hope it helps.
If you really like Knockout, I recommend checking out the SPA framework Durandal (http://durandaljs.com/), which is built on top of KO. I haven't worked on a long-term project with Durandal, but I have played around with it in my free time, and I really enjoyed it. It may be worth looking into if you are looking to compare different SPA frameworks for a project. 
Don't need to. Real world experience with the platform/os for which I develop real life apps is enough to know its got the same level of issues as any other web platform feature from any other vendor, and for the most part... I've had zero issues with transitions and transforms in ios since ios 6. If you have specific examples you'd like help with, please feel free to post them. Further more, stating you shouldn't rely on one of the most mature tools we have, one whose major function is (literally) smoothing out cross platform issues is just silly (and you are doing it in a context where OP misunderstood the tool and what it does, which is why it 'didnt work' in this case...to boot!)
The Guide page has duplicate "What makes Mojo different?" sections in the sidebar.
This. While we're on the subject of ML-like features, native folding and currying utilities would also be wonderful. 
It would help if you formatted your code to be valid. `var str = &lt;body&gt;` is not valid JavaScript. Read the "formatting help" link. Anyway, this doesn't seem to have anything to do with regular expressions, it's just simple string literal escaping. If a string literal is delimited with single quotes and it contains single quotes, they need to be backslash-escaped. If a string literal is delimited with double quotes and it contains double quotes, they need to be backslash-escaped. If a string literal contains only one type of quotes, then as an alternative to escaping you can choose the other type of delimiter. But if the string contains both types, then you're going to have to escape one kind. Example: "can't" 'can\'t' 'finger "quotes"' "finger \"quotes\"" 'can\'t "quote"' "can't \"quote\"" 
Thanks - should be fixed!
it is
Before you can infer types you need a complete system of types. The type of most things in Javascript is just [object]. Doesn't give you much type inferencing leverage.
If it's got a decent js interpreter it might be able to run Johnny-Five itself.
I believe that Atscript can be used as a Typescript superset. 
Java was more than a decade behind the state of the art in type systems when it was invented and had not caught up yet. It gives static typing a bad name. 
Definitely. If I already use framework *X* you need to not just beat *X* on features, but also beat my existing comfort with *X*, the institutional knowledge at my company around *X*, and the technical debt I'll have to take on if I want to move off of *X*. That's a pretty steep sell. Your site has to demonstrate significant value for me to even get from the front page to the examples.
Some of my thoughts: * Cache lengths in loops: // OK, but i and len get hoisted. for (var i=0,len=items.length;i&lt;len;i++) { ... } // better var i,len; // at top of method; may as well hoist these yourself // then when you need the loop: len = items.length; for (i=0;i&lt;len;i++) { ... } * Use strict equivalency: 10 == "10" // true -- avoid; coerces types 10 === "10" // false -- good -- no implicit type coercion * When possible, prefer using dot notation (unless the property is not a valid JavaScript identifier, or you're creating new properties on the object dynamically): var x = someObject["property"] // avoid var y = someObject.property // good * Avoid polluting the global namespace whenever possible. It looks to me like you're leaking some variables in your code -- always use `var` within your methods in order to create local variables. If you don't, they'll be created globally. * Cache DOM elements and other objects you use more than once var $this = $(this), innerElement = $('#inner'); * Name your anonymous functions (makes it easier to read stack traces!) $('[data-link]').on( 'click', function itemClicked() { ... } * Use `Array.forEach`, `.map`, `.reduce`, etc. var x = [1, 2, 3]; x.map(function double(n) { return n*2; }); // [2, 4, 6] x.reduce(function sum(prevValue, curValue) { return prevValue + curValue; }, 0); // 6 x.forEach(function logNumber(n) { console.log(n); }); // logs each item to the console &gt; If you've got an array-like list that isn't an `Array`, you can convert it: var listIsNowAnArray = [].slice.call(arrayLikeList,0); * Don't build HTML like that, please! Either use a templating library or build the DOM elements up manually. You're open to DOM injection this way, which is a security risk. var fragment = document.createDocumentFragment(), ul = document.createElement("ul"); // let's say you have an array of items, each with a text property and want to // make an unordered list with a list item for each item items.forEach(function (item) { var li = document.createElement("li"); li.textContent = item.text; // don't use innerHTML -- DOM Injection risk li.addEventListener("click", doSomething, false); ul.appendChild(li); }); fragment.appendChild(ul); // add fragment to DOM document.getElementById("someElementId").appendChild (fragment); * Prefer `camelCase` for identifiers. Use `CamelCase` when talking about classes. I use `UPPER_CASE` when talking about constants. list[i].Name // avoid list[i].FirstName // avoid list[i].Total_Price // avoid list[i].total_price // avoid list[i].name // good list[i].firstName // good list[i].totalPrice // good var PAGE_SIZE = 20; // of course, this assumes PAGE_SIZE won't ever change... var pageSize = 20; // use this if pageSize isn't constant. // in this example, "person" is an /instance/ of the "Person" class var person = Person( {firstName: "John", lastName: "Smith"} ); * Use self-documenting variable names. `correct` doesn't tell me much. `$_GET` isn't much better, though I see where you're coming from. Furthermore, the case on the latter leaves a lot to be desired -- `urlParameters` or `urlParams` would be better. * You've not got a lot of code here, but I suggest starting off with a module system from the start of any application so that things are more maintainable. RequireJS and Browserify are systems I've used. Essentially, you can split your code base into multiple files with `var someModule = require("someModule")` in order to import the contents of another module. * Comment, comment, comment! And then make sure you keep your comments *up-to-date*! Hope that helps! 
I used Knockout for several projects and then gave it up for richer alternatives. Knockout's small surface area and relatively low level of complexity are appealing, but you get those things at the cost of lower productivity. One of the biggest drawbacks of Knockout (or Ember, for that matter) is that you have to explicitly wrap everything that you want to make observable. In Angular, you can bind into arbitrary JavaScript objects without having to wrap anything. This is especially useful in cases where you want to, for example, make a view that binds into some JSON that you have retrieved via XHR. With Angular, you don't have to pick apart the data and wrap it—you just assign it to a property on the scope and bind away. Angular also benefits from having a richer set of mechanisms for encapsulation and code reuse. Being able to isolate functionality inside of directives and services is very helpful when you are building a large, complex application. The downside of Angular is that it feels like you are plugging a circus into the side of your application. It brings a lot of baggage with it and introduces convoluted terminology that isn't adequately explained by the official docs. Fortunately, the learning curve isn't actually as steep as it looks. Figuring out the terminology and understanding where you have to use $scope.$apply is about 90% of the battle. Having said all of that, it's worth noting that there are a bunch of lesser-known alternatives that are also fairly compelling. If you really like the lightweight, low-dependency approach of Knockout, you might want to check out [Vue.js](http://vuejs.org). I'm also a really big fan of [MontageJS](http://montagestudio.com/montagejs)'s functional reactive binding system, which you can [optionally use standalone](https://github.com/montagejs/frb).
Mojo was initially developed in-house at ClassDojo to phase out an existing codebase built with Backbone.js. Unfortunately, there wasn't any other framework available at the time that could safely phase-out our existing app, so we ended up building Mojo with the Strangler Pattern in mind (http://www.martinfowler.com/bliki/StranglerApplication.html). Everything was built to be modular so we could easily scale the front-end. It's now used in a few apps consisting of ~ 40k LOC, and served to more than 35 million users - 20% of which use IE 8+. I'll add a note about this on the main home page. 
Thanks for the suggestion. I'll include additional information comparing certain frameworks. Here are some interesting benchmarks I created a little while ago: 50k list items with paperclip: http://requirebin.com/ (1.5 s on my machine) dots benchmark: http://jsfiddle.net/2keRL/14/ 
If ever I answer someone's homework question, I try to make it /really/ obvious it's written by someone who knows js to ensure they don't try to lift it for their assignment: alert("Good " + ((h=(new Date()).getHours()) &lt; 12 ? "Morning" : (h &lt; 18 &amp;&amp; h &gt; 12) ? "Afternoon" : (h&lt;24 &amp;&amp; h&gt;18) ? "Evening" : "") + " " + prompt("Enter your name")); Just hope it's not 12 or 6.... then it's just "Good".
what bug is that? 3rd item will returns 2 right? Is that a bug?
up again 
The test was if (array.indexOf(...) &gt; 1), which will fail if the url was first or second item in the array.
&gt;The framework now supports more than 35 million happy users around the world. Yeah... i'm going to need to see something to back that up.
Hey I understand! I'm not coming here to have people just blindly do my work for me. I **WANT** to understand js I'm just having a harder time than most. 
This is fantastic!:)
I've always wondered what the advantage was of &gt; var abc = {}; &gt; abc.prototype.foo = function() { return "bar"; } Versus &gt; var abc = {}; &gt; abc.foo = function() { return "bar"; }
Mojo supports the entire front-end / back-end stack at ClassDojo which has a user-base of around 35 million teachers, students, and parents around the world. 
but but but you need a computer plugged to the board, isnt that against the concept of an autonomous robot?
Thanks for pointing that out - I'll add some clarification around that statement. 
You have brought interesting information but your reference to Opa does not strengthen your case. Opa encourages you to use Power Rows instead of Javascript objects for precisely the reason I outlined. Javascript objects are too loose. http://hbbio.tumblr.com/post/31526019499/power-rows-the-datatype Even that simple blog post demonstrates one of the risks of type inference which is inscrutable error messages. They would probably be worse for a language with a poorly designed type system like Javascript's (relative to Opa). I want to know what the inferred type signature looks like for a function taking an object with a method which has the semantics of "map". Will programmers be able to read the error messages if they actually pass a function taking an object with a method that has the semantics of reduce? 
I understand that, in your personal experience, you've never encountered a problem with transition in Safari. Many other people have, and have been for a while. I suggested a specific search on a specific search engine as I knew that that query would provide numerous examples spanning from 2011-2014, showing that Safari has had issues with transition for many years, as I claimed. (If you must have an example, here's one for iOS, as you mention iOS Safari specifically: http://joelglovier.com/writing/solution-for-css-transitions-crashing-safari/ ) I won't bother with the jquery comment. You clearly hold very strong opinions about it and I doubt that I can offer anything that would soften them in the least. It'll be easier for the both of us, if you're really interested in understanding my perspective, for you to do some research regarding my claim on your own.
amazing
Bad idea, what we need is to fix javascript and/or find a better replacement instead of throwing hacks on top of it. We should have replaced javascript with python or ruby when we had a chance few years ago. This is just bringing more fragmentation to the table.
I love Knockout, but for larger application I use it in combination with Backbone: http://kmalakoff.github.io/knockback/
Even Rob Eisenberg ("the guy") says Durandal is not yet dead and he is actively working on the next version in parallel to his work with AngularNext. He also says there will be a migration path. I've been using Durandal and I really like it, and it's easy to get into if you're already using KO.
JavaScript is there to stay whether you like it or not. These things they add are not hacks; the addition of types is proven improvement, see the massive success of ActionScript 2 and 3. People have been making crazy interactive media stuff in Flash for more then a decade. And not just n00b hackers, serious businesses with huge client and userbases did big stuff in those languages. Besides rich media there was also Flex which was widely used in financial services markets frontend tools (more then anything else). It may be imperfect but it is *effective*.
There is a mapping plugin that you can use to wrap everything to an observable. One of the nice thing about knockout is that it's dead simple to extend that library. 
Ask him to make a todo app, no persistance and in vanilla js, you should be able to judge the quality of code he currently has. I'd just hand him a computer and give him an hour to finish. Either allow internet access and log the pages he visits, or give him a javascript cheat sheet. 
I think this is the right way of doing things - I always think that it's best to get someone to do the type of work they'd be doing rather than just seeing if they are good at answering interview questions. 
Knockout comes out ahead in benchmarks I've seen like [this](http://vuejs.org/perf/). Of course the devil is in the details.
Perhaps I'm missing something? That blog seems like a pretty compelling argument *for* row-polymorphism, not against it. Again, I haven't actually used Opa - that was a secondary example to show something closer to Javascript, but if the type inference works anywhere near as well as Purescript then it's a net win. There will always be things you can do in a purely dynamic environment that cannot be type checked, but in the vast majority of cases you *can* properly type check. So why not leverage that where possible, and provide an escape hatch when you want to do something unsafe? &gt; I want to know what the inferred type signature looks like for a function taking an object with a method which has the semantics of "map". A function is just a type A -&gt; B, so this would be no different to primitive types when it comes to reporting errors to the user. Even if it was a little cryptic (Which it wouldn't have to be), it's sure as hell a lot better than "Undefined is not a function", which is about as detailed an error as I ever get out of Javascript at the moment.
I don't know what is the general feeling, but doing paired programming seems a bit off-putting for some people. Although it might be a good "stress"-test.
todo app, as a list of checkboxes?
[...](http://i.imgur.com/kLTq228.gif)
I think [**u/drink_with_me_to_day**](http://www.reddit.com/user/drink_with_me_to_day) is thinking more of the "front end" aspect of the qualification than the "mid-weight" aspect of the qualification. To me it seems like this would mostly test familiarity with the DOM, which is probably not as crucial as it was in the bad old days. I do find the suggestion of page-logging interesting, because it might give you a good sense of how the developer works. My mind has now wandered and I'm wondering what small movies of keylogged source code + captions for website visits and search terms, played side by side, would look like. Would one be able to identify the most skilled developer on sight? Or do some otherwise skilled people have meandering string production like: &gt; var fooValue = funcion(x) { var &gt; var fooValue = funct &gt; var fooValue = function(x) { var self = this; if(x){this.fooValueIsFooValue = true; this.fooValueValueOfFoo = x; } ; retu &gt; if(foo){ 
&gt; migration path from angu Thanks @Stephen for reply.i have seen some video@youtube which are using MCV4 and Angular.js .its simple and easy to use. * https://www.youtube.com/watch?v=Ja2xDrtylBw 
I know PHP but i m not good@PHP and i have worked @Dot.net Asp.net and MVC C# so planning to GO with it .if u can give some link or blog post for learning Or some Ex for MVC4 with Angular that will be great start for me Thanks for reply @btreecat :-) 
Works great with WebAPI providing data services. If you've got a Pluralsight subscription, John Papa's course [Building Apps with Angular and Breeze](http://www.pluralsight.com/courses/build-apps-angular-breeze) is a good starting point. 
if you are comfortable with the .net stack, my suggestion would be to use WEB API for server side instead of full fledged MVC stack
It's all about [inheritance and the prototype chain](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain).
Give him or her a problem to solve. Don't tell them how to solve it. Don't give them a ridiculous time limit. Don't ask to see any particular code pattern. See how they solve it. In my opinion the only way to test a developer. You'll see how they approach problem solving and what their best practices look like (they're trying to impress you, after all). 