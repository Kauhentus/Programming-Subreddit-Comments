you aren't supposed to, you are supposed to have custom directives that define this behavior. Think of a &lt;blink&gt; tag or whatever, angular gives you a way to define a tag that is supposed to have some type of behavior.
What most people should realize is that angular works best when it is used properly. If you throw out everything you know about js and try to use angular.js, you're gonna have a bad time. You should create your objects, functions, and models just as you would in vanilla javascript in most cases. At that point, you then attach instances of those objects to angular's scope. the scope is meant to provide a glue between the view and controller, its *not* some object that you start defining properties and building your objects on. And as someone who has built tons of angular apps, I still dont care that much about custom directives. they serve such a little purpose in my opinion. I think bi-directional data binding, services, factories, interceptors, and message/broadcasting events is the major advantages of angular.
The first programming language I was taught in school was C. While that gave me a lot of useful insights into how computers work, C is a *really bad* language for learning how other programming languages work. Bootstrapping from C to something like lisp is *really* hard, because there's no way of mapping from the new thing you're learning to the thing you already know. Javascript has a nice mash of OO, functional, asynchronous, and imperative ideas. I find that writing in other languages, I can more easily map that language into JS concepts than a lower-level language like C. There are other languages with the same properties -- Go seems like a good first language to learn. But getting set up with a Go development environment is tricky for someone who has never had experience setting up environments. With JS you can start with JSBin or the nodejs repl, and start poking around.
Wow! It's an article, not a list! ...with a completely linkbait title. ...and not much to add really.
&gt; The digest cycle is a pain, but it was the right choice. Dirty checking is what allows Angular models to be POJO (plain old JavaScript objects) where Ember needs a custom object. Exactly, a point that often gets overlooked.
I'm not quite sure I understand what you're trying to accomplish. Are you just looking for window.location = ?
&gt; My only concern is that the function itself maintains state instead of returning a new version of the function with the additional state appended. I can see where you'd want to go with that. My personal taste is that if I call: myFunction.addBefore(function () { ...}); I expect to mutate `foo`, because objects maintaining their own mutable state is one of the fundamental ideas in OO. If I want to create a copy of something with a change, I'd use a decorator function, like so: var newFn = before(myFunction, function () { ...}); Personal taste, but I expect functions to behave in a more "functional" style than objects.
This is the result of not structuring your app properly, angular has a steep learning curve and its worth every bit of it. People tend to follow this pattern too often: read a little bit about it -&gt; build an app -&gt; make many mistakes (not a big deal, they are just learning) -&gt; think "this is what angular is? it sucks" -&gt; go to some other framework.
you probably need to use some of angular's mobile directives or fastclick.js, i think there is a 300 ms delay by default for touch devices before click events fire, has nothing to do with angular https://github.com/ftlabs/fastclick
Well the point of ajax is to get the information without reloading the page but if you wanted to load the page then you could just set the window.location like riddilogic suggested. 
I know how angular uses POJOs and I use angular daily at work...I also have a lot of experience with other libraries and frameworks...my main qualms with angular are its architectural choices around not incorporating observables, violating [UAP](http://en.wikipedia.org/wiki/Uniform_access_principle), and dirty checking...these complaints aren't born from thin air, I have experience with other frameworks (as well as writing my own MV* stuff)...and these aren't my only complaints but thats what we are talking about here. To sum them up a bit, here they are: 1) Making values dependent on another (ie: computed values, especially from another $scope) becomes an excercise in managing scope...when, where, and how it updates. This is annoying and opens up holes for bugs as now I am having to manually ensure data synchronization and view presentation state. 2) Not having true observables (like Ember, or others like Knockout) means constructing dependency chains for values will not follow [UAP](http://en.wikipedia.org/wiki/Uniform_access_principle) and becomes extremely cumbersome and fraught with a heightened likelyhood for bugs. Dirty checking on POJOs is a hack...and angular tries to be fancy and handle it for you...but as soon as you jump even slightly out of the box, BAM there you are tracking and managing it all manually. **EDIT: I love it when people disagree with me, it means that maybe there is something I haven't thought of or that a different perspective might help...but to those that downvote all that I ask is, please explain why/where I am wrong...otherwise all I can assume is you are in love with a tool and hate it when people speak badly of it.**
That depends on if you want to play games or do MIDI.
I am in the "never use on" camp I guess, since usually it's contextually clear that you're registering event handlers.
To be clear, I have plenty of professional experience with Angular, not just tinkering around with some crumby side project. When you get to the point of having 100+ routes and dozens of different models, things get messier than a similarly sized Ember app.
Presumably if you need an action to occur before a render, that'd be my preferred naming scheme, though camelCase is largely a personal preference as I find it easier to read.
This is like in a job interview when you say your greatest weakness is your commitment to quality or something. Cmon
Events are the one case when I don't use camelCase to be consistent with what is already in js (DOM): element.onclick = function() { } Also it solves a few more naming problems and allows more automated operations as you don't have to think over onMouseMove vs onMousemove
TAKE THAT BACK!
What makes you say this? I find Angular templates to encourage more separation, since I have yet to find a single itch I can't scratch with either putting data in $scope, as a Value or encapsulated as a Directive. I have a pretty big internal project using Angular and not a single line of pollution in any of my HTML or CSS files. Where does this belief come from? Can you give any examples?
I think they mean adding js to html. Things like ng-click="function()" are reminiscent of the onclick days.
Thanks for clearing it up haha, I got slightly confused
&gt; average Backbone app probably uses 95% well I call that bullshit. Enterprise apps I see tend to utilize much smaller part of it. Most people write apps with it in the same manner as with jQuery. 
Chrome dev tools has a section in the elements panel that will tell you what events are attached to an element, i mostly just use that. 
&gt;AngularJS, despite being a large library by itself, cannot handle some common patterns in Web apps outside the box (e.g. nested views). You have to depend on yet another AngularJS library to implement these patterns. But you don't get ng-router out of the box right, you get to pick whether or not you want to include ui-router, ng-router, or something else? 
personally, I have no issues with integrating third party libraries -writing directives, etc- and I don't know anything about the angular "digest loop", but I do agree with your third issue about not being able to handle common routing patterns natively. I don't want to write a whole bunch of code based around a library which may or may not be abandoned in the future. According to /u/Newworldodour's comment they are going to integrate ui-router into the main angular dist though, which is awesome. Going to have to look into that more...
Internally to JavaScript it is best to think of events as both a noun and a verb. Events are attached to objects, typically DOM nodes, as properties of the object. This allows a function, or something else, to be assigned to the object property and thus the event. The function that is assigned is called the *event handler*. It is this more common situation where the "on" prefix applies. Here is an example: div.onmouseover = function () { var that = this; this.style.display = "none"; }; In the above example *var that = this* is a common convention to allow code internal to a handler access to the event's object and all its properties. Since *this* is a keyword it has no properties. In some cases you need to dynamically execute an event. The common intention is that a handler is already assigned and you want to execute that handler without regard to what that handler is. In this case you can treat the event as a method. This is where you do not include the "on" prefix. Here is an example: myButton.click(); The limitation with this approach is that it is not natural. When a user triggers a click there is first: "onmouseover" and "onmousedown" followed by: "onmouseup" and "onmouseout". None of those events occur when you dynamically trigger a click event. Typically when an event is dynamically fired its default DOM side effects continue to occur, such as checked state or change of selection index or the firing of an anchor's href. While these things may occur by default in the browser it is a dangerous assumption to expect them to occur without first inspecting the contents of the handler. If the handler finishes with a *return false* or contains either a *stop propagation* or *preventDefault* you should expect something wildly different than the default behaviors to occur.
And backbone isn't opinionated? Riiight. Opinions are not bad, they are necessary, you might not agree with them and that is ok, but being opinionated is not a bad thing.
so its 1k except it relies on jquery which is an additional 93kb? im not sure the comparison adds up. its roughly the size of angular. 
&gt;Attributes with ng- instead of data- (I know about data-ng- but that's way too verbose). I hate when frameworks use prefixes to denote their custom attributes. It really makes the HTML so much more readable. Fucking unbearable. 
It was also like this in the early days of general Javascript libraries, with Prototype.js, MooTools, YUI, and many others coming out months apart - nobody was sure which would 'win out'. Now that JQuery has pretty much been the victor of that round, there's a new set of libraries like Ember, Angular, Node, Backbone, etc (that do mostly different things, to be sure). The difference I see between the 2 examples though is that in 2006-2010 era the libraries were all trying to achieve the same goal (making Javascript not suck), and now that we have that covered the new libraries all have their niche uses and areas of expertise which makes me think they will all be around for a while.
&gt;I've never really felt that 'backed into a corner' with Angular, and have generally found it really easy to refactor things/shift things around without it being a 're-write'. this so much. You can really feel the MVW design philosophy behind angular . It's opinionated enough to point you in the right direction, but ultimately it's up to you how you want to separate your concerns and organize things.
I'm not talking about the click event lag that happens on mobile, I'm talking about updating/ removing elements in the DOM.
The trend seems to be shifting towards putting more of the load on the front end, which of course has pros and cons. Part of that means front-end and back-end people have to work together more so the back-end markup includes all the special syntax stuff the JS requires. The most extreme example of this I've come across lately is when backend devs have to include Backbone JS templates (written by front-end team) into the back-end code, spit out in the HTML on page load. Which means there's basically a JS block which includes a HTML template with JS logic sitting in the back-end repo, but the coding for it is managed by the front-end team. Kind of weird.
Sometimes infuriatingly so. Today, I was using a directive inside an ng-repeat (think interchangeable UITableCell classes inside a table view if you know ios) and the index parameter doesn't update inside the directive when you resort the list. So I have to duplicate html for every table that needs a different directive, or write custom code to determine a directive's position in the list. I'm sure if I looked through some more documentation and source code I could work out of this was a bug or feature, but easier to work round it for now 
Heh. They actually have an entire section in the docs devoted to why Riot.js does *not* do two way data binding. Apparently it's a sore spot with them. Unfortunately, I think their arguments are deeply flawed. It all comes down to the idea that this: &lt;div&gt;You've clicked &lt;span data-bind='text: numberOfClicks'&gt;&amp;nbsp;&lt;/span&gt; times&lt;/div&gt; &lt;button data-bind='click: registerClick'&gt;Click me&lt;/button&gt; var ClickCounterViewModel = function() { this.numberOfClicks = ko.observable(0); this.registerClick = function() { this.numberOfClicks(this.numberOfClicks() + 1); }; }; ko.applyBindings(new ClickCounterViewModel()); Tightly couples the view and controller, hardcodes logic in the DOM, and means that you can't change the view and controller independently, but this: &lt;div&gt;You've clicked &lt;span id='numberOfClicks'&gt;&amp;nbsp;&lt;/span&gt; times&lt;/div&gt; &lt;button id='registerClick'&gt;Click me&lt;/button&gt; var numberOfClicks = 0 $('#registerClick').click(function() { numberOfClicks = numberOfClicks + 1; $('#numberOfClicks').text(numberOfClicks); }); is perfectly fine, because you can change the template and the view logic completely and everything will still work just fine. This is madness. The first example doesn't "harcode logic in the DOM", despite what Moot claims, but it *does* represent some degree of coupling (although not as much as critics claim), and it does mean that you can't just randomly change your templates without updating your logic. But that makes it *exactly like the second example*. The conviction present in some quarters that any sort of coupling between the view and controller layers is wrong *unless* the coupling overloads CSS class names in which case it's fine is just bizarre. In the real world CSS classes are the *worst* way to do it, because it means your designer tinkering with the DOM, refactoring your CSS, or even just adding a wrapper DIV to fix some obscure layout bug in early versions of Firefox can break your entire app. If you're using CSS classes as some sort of "hey, this DOM element needs to represent the value of this variable" flag, then just add a data-bind or ng-model attribute or whatever and be done with it. You're making things more fragile —and no less tightly coupled — by using CSS. Meanwhile, the entire idea that coupling itself is bad is *itself* wrong headed. You shouldn't mix concerns, but your view and controller are still linked together via an effective API; in my Knockout example my viewmodel exposes numberOfClicks() and registerClick() functions. **NO** you can't randomly change your API without updating the client that consumes that API. That's not a problem or a code smell that's How Coding Works Here On Planet Earth. Meanwhile the jQuery example is just as coupled via a closely analagous API, but good luck glancing at the code and figuring out what the API is, since it's buried under jQuery event bindings. Yech. TL;DR: Looks like a good library, but they've drunk the koolaid on the subject of two-way data binding.
Use addEventListener/Event emitters instead. The problem with on events is you can't hook multiple listeners, which sucks.
I don't think what a good software engineer does with your tools is the test of your tools, so much as what mediocre software engineers do with them. I think machty's point is kind of, if you make bad things easy (you can easily inject anything into anything else), people without great discipline will do bad things, and it may be as much a failing of the tools as it is of the developers. It's kind of like the difference between a cast saw with a safety shutoff when you hit skin and one without. I can cut your cast off with either one if I'm really good with it, but one tool is clearly safer than the other, and can be put into less skilled hands, and sometimes that matters. But, obviously, it's a philosophical thing. If you make everything easier, that's still a win over vanilla JS, and maybe that's all you need. What I like about Ember is the feeling that if I need extra hands on a project, or I lose a team member and have to replace them, I can bring in anyone who's got some experience with Ember and they can hit the ground running, because of how conventional it is. Whereas if it's an Angular project, because the framework is less prescriptive about structure, you're going to have to invest a lot of time in orientation, and more time on documentation.
&gt; In the above example `var that = this` is a common convention to allow code internal to a handler access to the event's object and all its properties. Since `this` is a keyword it has no properties. I think you might be misunderstanding something here.
Anything that let's you write less code with clearer structure is good. Too much magic can be bad and/or limiting. Angular may not be for everyone or every project, but that doesn't make it any less awesome.
its a convention, generally speaking prefixing (regardless of capitalization) is a good idea, it helps distinguish event handlers from functions/methods.
It was absolutely sarcastic, and as you yourself mentioned, if you are concerned about HTML validators or "adhering to the spec" you can add 'data-' before the 'ng-*'. So your point is a non-issue.
I'm sorry, I want to be more specific, but I honestly don't know where the confusion is. All I can say is that your function would work perfectly well and just the same without `var that = this`.
This is a keyword that can evaluate to an object, and as such, may have properties. var that = this is merely a convention to closure capture this, and is not specific to event handlers or specifically for "accessing its properties".
Not vague, this isn't being used in their example. That's all!
I've worked with it for a few months, and it's impossible to figure out. When I had a caching issue (the header links don't change upon log-in, but extra ones get added) I didn't know how to fix it or why it happens. It also did email validation by itself when I didn't want it (for testing purposes). It's just too big, too complicated, too hard to understand.
* Learn HTML5 canvas. * Learn the physics of velocity and acceleration and maybe even how a spring works. * Learn 3d to 2d transformations. * Start trying :)
The code you provided doesn't really make sense - at least not without more context or explanation. `var that = this` is setting _that_ to the current value of _this_, which refers to the current scope of the function. _this_ in an event handler will point to the element on which the event was triggered; in other contexts, or when the function is called a different way, _this_ could refer to a different object. In the context of the example above, there's no benefit at all to doing `that = this` - you aren't even using _that_ after it is assigned. You also say 'this has no properties'. `this` has whatever properties the current scope has (since it's just a reference) - you prove that by calling _this.style.display_ on the next line. Where the _that = this_ convention is useful is when you have other function scopes inside of your event handler, but you still want to access the event handler scope. For example: div.onmouseover = function () { var that = this; // Using jquery's ajax function for simplicity $.ajax( ... ).done( function () { // this now refers to a different scope // but we can use that instead, because we kept it as a reference to the outer scope that.style.display = 'none'; }); }; Also, you shouldn't really set event handlers in that way - what happens when you need to add another handler for the same event on the same element? Instead, proper event handling should be used - addEventListener, or the _on_ method if you use jQuery or most other libraries.
I'd probably call them "render" and "onKeyPress", assuming the render function renders, as opposed to responding to something else rendering. And the capitalization is just a matter of preference. Everyone has their own. I like to camel case everything that's not a class name. And I'd probably define the class with a prototype like this rather than defining a single object inline: function Scene() { } Scene.prototype.render = function() { } ... var scene = new Scene();
Thing is, there's a semantic difference between `render` and `onRender`. The first implies that we're telling the object to go and render itself. The second implies that the function is reacting to having rendered.
After. Always after. If it isn't after, the author messed up. If the event is to fire before the action, then there should be a different event, such as `onBeforeFoo`.
Defining something as non-issue is not constructive as different people see different things as issues. As for the `data-ng-`, that is impractically verbose. I would expect exactly zero people to use it. On the other hand, I do see a point in having that kind of namespace, so maybe the standard should have considered it since custom elements are using similar approach anyway.
There's more than one way to do web components and you don't necessarily have to put it all in one file. Take a look at customelements.io and x-tags. The major advantages of web components are better encapsulation, better reusability, and a better API/syntax -- cleaner more understandable HTML, custom attributes, more declarative code. Ideally you will be able to take advantage of existing third-party components so you won't have to write the code for those at all.
The main improvement web components make is significantly improved encapsulation, reusability, and maintainability of web-based components. There are other ways to do components in a web application using various frameworks or just JavaScript, but web components are designed specifically for web-based componentization and provide a more tailored approach that integrates well with HTML5. &gt;Web Components enable Web application authors to define widgets with a level of visual richness and interactivity not possible with CSS alone, and ease of composition and reuse not possible with script libraries today. http://www.w3.org/TR/components-intro/ The benefits of using components in a web application are the same as the benefits in any other type of user interface or application generally. http://en.wikipedia.org/wiki/Component-based_software_engineering &gt; Component-based software engineering (CBSE) (also known as component-based development (CBD)) is a branch of software engineering that emphasizes the separation of concerns in respect of the wide-ranging functionality available throughout a given software system. It is a reuse-based approach to defining, implementing and composing loosely coupled independent components into systems. This practice aims to bring about an equally wide-ranging degree of benefits in both the short-term and the long-term for the software itself and for organizations that sponsor such software. 
I'm not sure I'd say I was "against" it, but I do see both pros and cons. The pros is obvious: Good, solid framework, nice community, and **a real focus on testability** (bolded because *so* important). The con is basically this: You're not really programming in JS any more; you're now programming in a new "angular language". And it's not entirely clear that it's a very good language. Or perhaps it would be better to say that it's not clear the Angular devs even realized they were *making* a new language. For a detailed discussion of this last point, see: https://koglerjs.com/verbiage/angular Again, I'm not sure I'm "against" Angular. It's just that it's a very different.
http://docs.angularjs.org/api/ngRoute You have to include ng-route separately if you want it. This allows you to choose between ui-router and ng-route without a penalty. They have been working on splitting up modules like this so that you can choose better alternatives from the community. Another example is [ngResource](http://docs.angularjs.org/api/ngResource), you can choose to use $http (which comes in the "angular core", or include ngResource and get a better experience interacting with REST APIs, or you could include Restangular which is similar to ngResource but considerably more powerful. The reason I phrased it as a question is because I haven't used AngularJS in a while and wasn't sure. Seeing as how you seemed so knowledgeable on this topic, I figured you would know.
Not really just for reuse of third-party components. Breaking your front-end into different components, including the parts that are specific to your application, usually makes it easier to write and maintain the code.
It says you didn't know what to call it. How about "sperm". Heh.
*this* has nothing to do with scope. It refers to whatever invoke its containing function. Calling properties upon a keyword produces a syntax error. this.someProperty //syntax error Assigning *this* to a variable allows access to the properties of the thing referenced by *this* without the syntax error.
There is a way around it, but it's definitely better if the library author uses true events, rather than callback hooks. Example of shimming true events onto a library with simple callbacks: https://gist.github.com/mcordingley/6754394
 function test() { return this.someProperty; }; test.call({someProperty: 1}) // returns 1 It is certainly not a syntax error to dot off of this. Grammatically speaking, this is a valid target of a member expression.
http://lmgtfy.com/?q=javascript+sound
I actually prefer 'handleTheEvent', and I use that convention for all, and only, event handlers. Probably just comes down to personal/team preference. 
Marionette.js (backbone extension) follows this exact pattern. These functions (if they exist) will be called before and after the tense function is executed. 
More precisely, `this` in a function body is passed by the caller (along with the function's arguments) and is stored as the *ThisBinding* of the function body's lexical environment record ([10.4.3](http://es5.github.io/#x10.4.3)). The `this` keyword evaluates to that binding. ([11.1.1](http://es5.github.io/#x11.1.1)). From a syntax standpoint, this is a primary expression similar to identifiers ([11.1](http://es5.github.io/#x11.1)) and so, in expressions, this is allowed anywhere identifiers are.
It is said that lodash and Lazy.js are faster than most library like that.
been using angular since summer 2011, so going on 3 years now. Hardly a fad. Plus, it actually solves the biggest problem with js apps and allows you to write testable code. but whatever.
I figured it out...
If what you are trying to achieve is to submit a form and then get all input fields as parameters for an URL like: ?input1=value&amp;input2=value2... And so on, you actually don't need JavaScript at all. Just add the URL you want to go to the action attribute of the form element. Now, it's important to know that this will trigger an http POST rather than a GET on that URL. If this is an issue, just add the attribute "method" to your form and assign it a value of GET. Here's an example form that uses this method to trigger a search in google: https://gist.github.com/enrique-ramirez/8366897
JavaScript is single threaded, but at its core it is an asynchronous state machine with arrays and objects passed by references. Since this function is an object it will pass by reference and all operations on counter.i will propagate back to this single point.
You called a property on _this_ in your own example. I'm not really sure what you're describing - I have never seen the behavior you talk about. _this_ evaluates to the function binding and can be used without arbitrarily assigning it to a variable. You only need to assign it to a variable if you wish to use it later in a different scope. If the function binding contains _someProperty_, then you absolutely can do `this.someProperty`. If you're getting a syntax error referencing _someProperty_ on `this`, it's likely because the function has not been called in the context you expect. Consider binding the function explicitly, e.g. using underscore: _.bind( myMethod, the.object.I.want.this.to.be );
You may want to keep an eye on the upcoming open source framework [famo.us](http://famo.us/). They are taking sign-ups for a beta but if you close that and click on the icons at the bottom there are some demos that might be similar to what you are looking for. 
&gt;outside the box Noone said outside the box &gt;Having said all that, It is good to know ui-router will be eventually added to the core distro. That isn't what I said at all. JQuery has plugins, why can't Angular? The community made a better router, let the Angular team focus on more important shit.
I am aware and fully expect that "all operations on counter.i will propagate back to this single point". Wasn't that clear when I gave the guarantees on what would happen?
just dont user either if at all possible. 
I was responding to your original comment: &gt; But you don't get ng-router **out of the box** right, you get to pick whether or not you want to include ui-router, ng-router, or something else? True, jQuery has plugins, but core features of jQuery handle common usage patterns (DOM traversal and event binding) very well that they rarely, if ever, need to be replaced. But routing is a core aspect of SPAs, and yet Angular's default router is not powerful enough that one ends up using third party routers.
I've developed my own little event pattern. I created a little generic event constructor, to create event objects -- that can be bound to, and triggered.. I'm open to critique. function Slideshow(){ var slideshow=this; // Defining our events var events={ slideChange: new SlickEvent(slideshow), play: new SlickEvent(slideshow), pause: new SlickEvent(slideshow) }; // Slide change functionality triggers the slideChange event function slideChange(){ // transition to the next slide.. events.slideChange.setThis(newSlide.image).trigger(newSlide); } // We listen to our own events to take action to play and pause the slideshow. events.play.bind(function(details){ // internal mechanism to start slideshow.. }); events.pause.bind(function(){ // internal mechanism to stop slideshow... }); // Friendly public interface: slideshow.play=function(details){ events.play.trigger(details) }; slideshow.pause=function(){ events.pause.trigger() }; slideshow.onSlideChange=function(f){ events.slideChange.bind(f) }; slideshow.onPlay=function(f){ events.play.bind(f) }; slideshow.onPause=function(f){ events.pause.bind(f) }; } // Instancing my Slideshow var slideshow = new Slideshow; // Binding handlers to the events slideshow.onPlay(function(details){ console.log("slideshow playing") }); slideshow.onSlideChange(function(slide){ console.log("slideshow: slide change") }); // You get it $playButton.click(function(){ slideshow.play( "S-W-A-G".replace(/-/g,'') ); }; $pauseButton.click(function(){ slideshow.pause(); }; I use this pattern all the time for all kinds of widgets.
After, is the only choice that makes sense, with `on`. onTurkeyEntersRoom(function(){ console.log( isInRoom(turkey) ); // false wtf? }); How mad would you be, if this output 'false' because the handlers were fired *before* the turkey had yet entered the room? With `on` implying *after*, we should let `before` imply *before*.. - `beforeTurkeyEntersRoom(function(){});` - `onTurkeyEntersRoom(function(){});`
achen, what gave you that idea? A frightening thought, it is. I do something similar with my `this`'s, with regard to the `var that=this` business, but I do it specifically for constructors -- just to give a synonym because `this` is ugly. window.website = new function Website(){ var website=this; // website.slideshow=1; website.pages={}; website.pages.about=null; //... }; I usually internally use the same name as the constructor, but non-capitalized camel-case.
I can't help but feel like Gulp and Grunt are becoming non-interactive shells in JavaScript with extraordinarily unsuccinct "commands" to accomplish tasks. JavaScript: var fs = require('vinyl-fs'), map = require('map-stream'), zlib = require('zlib') grunt.registerTask('zip', function () { fs.src('./build/build.js') .pipe(map(gzip)) .pipe(fs.dest('./build')) .on('end', this.async()) }) // all you need to do is modify the file's // contents and then call the callback. // Just remember it's always buffer in and buffer out. function gzip (file, cb) { zlib.gzip(file.contents, function (err, buffer) { file.contents = buffer file.path = file.path + '.gz' cb(err, file) }) } Compared to Bash: gzip ./build/build.js &amp; Maybe a bad example. Let's add pipes. cat ./build/build.js | gzip &gt; ./build/build.js &amp;
The fantastic thing is that you can do whatever you like to the element, not only assign events. E.g. swap out an ugly text input with a fancy jQuery sortable list. That's definitely not possible with delegated events since there has to be some sort of event (like a click). I will publish additional articles explaining this in detail, stay tuned!
Or just imagine this scenario: You are loading content that includes a list of sortable elements. How would you apply $().sortable() to it?
That's what the article concluded.
You can still wrap the whole table inside a form and it'd work out.
You can use it without jQuery, if you want. Or with a modular version of jQuery or even only Sizzle. Or another toolkit.
While this is a useful, if not incomplete, resource, I would not expect anyone to be writing idiomatic Jacascript after reading this no matter how "sophisticated".
[Functional decorators without coupling](http://bahmutov.calepin.co/functional-decorators-without-coupling.html)
Only reason is ignorance of the language.
`eval()` isn't evil, it's just [misunderstood](http://www.nczonline.net/blog/2013/06/25/eval-isnt-evil-just-misunderstood/). If you find yourself using it, you should probably rethink your code, but there are some edge cases for its use.
It’s not as stupid as it looks. If JavaScript didn’t have the bracket operator, you would need to resort to meta-programming to replace `propName` in `obj.propName` with an arbitrary string.
I designed a fairly similar framework for a client last year (though not as complete). It worked well, because at the very least it provided some structure to the application over the typical jquery spaghetti, while not being so burdensome as some the large application frameworks (ember, angular). 
Holy crap this is the most condescending writing I've ever seen, immediately closed after the author redirected the unwashed masses to w3schools.
I had the same thought. I actually was looking forward to reading this, because I've recently been programming a great deal in JavaScript and I find it difficult to grasp what is idiomatic and where the anti-patterns are. Further, it's easier for me to find myself in the woods because of the asynchronous nature of JavaScript. Finally, it seems like a tough first language for a potentially undisciplined programmer: it's almost like one could write huge amounts of code without using a return statement, using all side effects. In light of this, I often feel like I'd like to study idiomatic code (outside of Crockford's stuff) to learn where the common pitfalls are.
I've watching closely at gulp and the development. While doing so, I made my own seeds, that while it's not targeted for the angular niche, it's light enough to be generic for pretty much anything. https://github.com/Dashed/javascript-seed-project https://github.com/Dashed/coffeescript-seed-project Sole purpose for these seeds is for me to clone and code. Angular can be placed within it easily.
Great seeds. I am targeting more of the Angular/RequireJS/Grunt community moreso than creating a generic js seed. Setting those up can be a pain for people.
Ya, decent resource. Pompous author. 
the twitching and pulsing is a bit eerie.
oh, I like it: looks a bit like some deep sea creature. i don't know how to fix the instability, maybe it needs some dampening?
Tip: If you care about the text and other miscellany nodes, use xNode. If you only care about element nodes, use xElementNode or similar. All nodes =&gt; Element nodes element.firstChild =&gt; element.firstElementChild element.lastChild =&gt; element.lastElementChild element.childNodes =&gt; element.children element.nextSibling =&gt; element.nextElementSibling element.previousSibling =&gt; element.previousElementSibling The speed gains are measurable with fewer iteration counts and operation counts (node type checking, etc.)
Nice
Make it restart when you die!
Thanks for the suggestions. It's funny you mentioned underscore because I found it recently and it immediately felt useful and familiar to have a `map` and `each`, etc. I wondered if I was suffering from a desire to simply turn js into something more familiar by relying on it.
I guess... The sole purpose of that seed is for angular/browserify/gulp though.
Interesting. I played around with the code a bit and noticed the tails fade by a transparent, black rectangle fill on each update frame. I can't figure out why the repeated fills don't eventually change the trails' color to black. It's more evident if you set context.fillStyle = 'rgba(0,0,0,.02)';
These are good - wasn't aware. One thing (may not matter to many/some) - some of these don't work correctly for IE8 and lower. 
&gt; If JavaScript didn’t have the bracket operator But it does.
Not sure exactly what you're looking for, but the [Angular expression docs](http://docs-angularjs-org-dev.appspot.com/guide/expression) should cover you. 
&gt; any rules that are widely known to be performance killers such as Quick, someone tell Paul Irish: http://www.paulirish.com/2012/box-sizing-border-box-ftw/
Maybe, but I kinda feel like it's the same issue with tables in HTML, they just aren't used properly. The eval() function has a specific and important use, it's just that it gets abused and can be inefficient. If the JavaScript indexOf function was inefficient for some reason, it wouldn't be wrong to use it, you just have to make sure it's the best available option.
What if new developer steps in and wants to attach a second click handler to the button? And he want's to extend the application so that it's a separate module without touching existing code. That's easy with the second approach.
So... looking at this, it's just a bunch of wrapper methods. They don't even have descriptions, they're just a bunch of code samples. Like, is there even a difference between $map and $$map? What does $samples and $$samples do? How are they different? I stopped there. If I can't see why I would use it or what it's for, it's just not worth looking at.
Under 1 second is the damn bare minimum in this day and age 
I always check on back-end for data validation. And then make some basic form for the front-end. That way if an advance user is able to make a post. I'm still covered. But like suggested below. Did you want to implement your own? or use a library? I've always written my own. 
Basing my first angular app off this, thanks!
My guess would be that he or she programmed web apps for Android either running in the browser or as native apps using a framework like [PhoneGap](http://phonegap.com).
Depends what your use is. Formatting looks fine to me. http://en.wikipedia.org/wiki/JSDoc
Native Android apps are written in Java, NOT JavaScript. There are also cross-platform apps that are written in HTML5 which is becoming THE solution for writing apps that work on Android, iOS, and other supported mobile and desktop platforms. HTML5 heavily utilizes JavaScript and its implementation slightly varies by platform. I wonder if he meant this. In any case, it is purely worded on his resume. 
Mousetrap is pretty good - http://craig.is/killing/mice
comment nodes for one. See https://developer.mozilla.org/en-US/docs/Web/API/Node.nodeType for all the types of nodes. MDN isn't loading for me right now but I think the only ones that aren't deprecated are text, element, and comment nodes. I think the usage of everything else has been too scarce to warrant keeping anymore.
Thanks! I was close, but https://developer.mozilla.org/en-US/docs/Web/API/Element wasn't very enlightening.
Good point - but I'm all for raw DOM traversal methods - usually boiling down to getElementsByID/getElementsByTagName and querySelectorAll() which never seem to give IE grief in IE8+ for the work I do - typically via the small lib I have written if a more involved/complete project: https://github.com/magnetikonline/picoh/blob/master/picoh.js The ability to safely jump whitespace/comment nodes using native DOM methods would be great though - maybe once I rule out IE8....
There is another "mindset" of doing Javascript validation that is picking up popularity in the HTML5 side of things. In this style, you separate your code into a set of rules that are validated against -- then you write the rules into your HTML. Let me show you the HTML -- that will make sense first. The rules are: * The field is required * There is a maximum string length of 10 `` &lt;input name="samplefield" is="samplefield" data-val-required="This field is required" data-val-maxlen="This string is too short" data-val-maxlen-min=10 /&gt; &lt;span class="error-message" data-for="samplefield"&gt;&lt;span&gt; With these rules defined, it is a much simpler matter to write a generic 'validate' function that goes through the various INPUTS and looks for the rules. I can't show you the actual code I use at work, so pardon this 'off-the-cuff' solution that may have syntax errors -- but you should get the idea. // Warning -- Type off the cuff, but should give you the idea. function validate(form) { var hasErrors = false; function setError(el, msg) { // Can't recall the syntax here, so here is jQuery's $span = $("[span.data-for='" + el.id + "']"); $span.text(msg); hasErrors = true; } var rulesNames = []; var ruleFuncs = []; ruleNames.push("required"); ruleFuncs.push(function(el) { if (el.value === "") { setError(el, el.getAttribute("data-val-required"); } ); var inputs = document.getElementByTagName("inputs"); if (!inputs) {return;} for (var i = 0; i &lt; inputs.length; i++) { for (j = 0; j &lt; rulesNames.length; j++) { var field = inputs[i]; var ruleName=rulesNames[j]; // Does this input have this rule? if (input.getAttribute("data-val-" + ruleName)) { // IF so, call the validator runeFuncs[i](field); } } } }
Yea this is a technique I picked up a while back for fading. I also don't understand why they never totally fade out, but I don't think it is horrible as it is (maybe I am just used to it at this point :/ who knows) - I will inquire about why this is, and if I find out I will post back. 
+1 on Mousetrap.
You don't need to install browserify globally. npm scripts can run programs from your node_modules/ folder as if they were in your path. So once you have browserify installed locally, you can just add an entry like this in your package.json: "scripts": { "build": "gulp browserify" } And everything will just work. Also I am curious why you are using bower if you already are using browserify? Why not just pull all your packages from npm?
Consider making a library for something that we don't already have multiple libraries for.
Um. I don't think this actually happens in real apps. A given view or template maps to *one* controller/viewmodel, more or less by definition. You can't really have two different modules, eg, controlling the text contents of the same span of HTML, and while you can *technically* have two different modules both providing a click binding on a single button, I'm struggling to think of a non-contrived example where you'd possibly want that, or couldn't solve the same issue much more easily and elegantly through a clean design pattern. If you're relying on Module A's template, you aren't *really* a separate module in any meaningful sense of the word. But...yes, you can easily do that in the Knockout example, if that floats your boat (I imagine Angular would be just as easy, but I don't know it as well). // Template from Module A &lt;div&gt;You've clicked &lt;span data-bind='text: clickCounter.numberOfClicks'&gt;&amp;nbsp;&lt;/span&gt; times&lt;/div&gt; &lt;button data-bind='click: function() {clickCounter.registerClick(); stupid.alertOnClick();}'&gt;Click me&lt;/button&gt; // Code from Module A var ClickCounterViewModel = function() { this.numberOfClicks = ko.observable(0); this.registerClick = function() { _this = this; _this.numberOfClicks(_this.numberOfClicks() + 1); }; }; // Code from Module B var StupidViewModel = function() { this.alertOnClick = function() { alert("Why am I doing this?"); } } // Entry point MetaViewModel = { clickCounter: new ClickCounterViewModel(), stupid:new StupidViewModel() } ko.applyBindings(MetaViewModel); If you don't like the clunky click binding, you can do various clever things with custom bindings, or using an event bus, or a bunch of other things. Indeed, if it's important to you that this use case work well, and you don't want to have to modify the template at all, you could use [Unobtrusive event binding](http://knockoutjs.com/documentation/unobtrusive-event-handling.html). (Although again, I would argue that this is actually bad: Module B now has a dependency on, of all things, the STYLING of Module A's template. Change Module A's class and you break Module B, and there's absolutely no way you can tell this by looking just at Module A; you potentially have to look at every module in your code base to try and see if anything happens to be binding on that selector. Explicitly referencing Module B in Module A's template doesn't *ADD* a dependency, it makes an existing dependency explicit, which is very, very good.) In short: You can do what you're discussing in *both* design patterns, but you really shouldn't. Writing your code to be harder to understand *SO* that you can easily do fragile, hard to understand things is not wise.
It's for a simple JS library.
I think I should make a library that writes custom libraries.
jQuery has key events, wouldn't have ever thought to use another library for it.
Consider not being rude
Consider that this is the Internet where polite/rude is completely inconsequential
I just took a look at picoh. It reminds me more of qooxdoo than jQuery, but a bit better structured. If you can spare the time, you could check out my current project, [m².js](http://atk.github.io/m2.js/), which aims to be both as minimal and as modular as possible.
This is really cool, few things. * When I change my role, and don't fill in a name, it should prompt stating this name input field needs to be populated. * Syntax highlighting will be a nice feature to expand with. * Two users of the same name can join a room(not sure if this is intended)
So this is basically just underscore.js/Lo-Dash with $ - prefixed method names?
Dude, this is freaking awesome! Any thoughts on open-sourcing it?
Yes that is definitely the plan! But I want to wait until I'm a little less of a Meteor noob and I can spend a little more time auditing security
It should resolve any discrepancies after a few more keystrokes, the code editor is using ShareJS which runs an oplog and seems to be pretty robust. Unless you mean the cursor is losing its position in one browser? I've been testing mainly on Mac Chrome, so there may be some issues. Thanks for the heads up.
Can you give me some links about how Backbone scales poorly while Angular works really well for large apps? Definitely interested.
Awesome!
space bar is throwing burgers
Would be so amazing if you could wrap constructor functions as well ...
lol, focusing on useless micro optimizations when his site is violating every single know best-practice.
Thanks for the article. Interesting read. Didn't quite well answer to the original question about scale. It focused more on the feature set and convincing the reader that Backbone is *not* minimalistic and requires you to have additional tools to get the full set of features that Angular provides. 
Who needs constructor functions? Factory functions work fine. function Widget(radius, mass) { this.radius = radius; this.mass = mass; } Widget.prototype.area = function() { return Math.PI * r * r; }; is in all important ways equivalent to: var Widget = {} function createWidget(radius, mass) { var result = Object.create(Widget); result.radius = radius; result.mass = mass; return result; } Widget.area = function() { return Math.PI * r * r; }; And it's no longer "special."
I'm a huge fan of wrapping functions. I believe that the technical name for a function that wraps another function is a combinator. If you mix wrapping functions with some currying, you get a combinator. For example, if you have (I've tweaked the OP's first example slightly): function before (advice, fn) { return function () { advice.apply(this, arguments); return fn.apply(this, arguments); }; }; You could hand-curry it into a function taking one argument and returning a function taking one argument: function makeBeforeAdvisor (advice) { return function (fn) { return function () { advice.apply(this, arguments); return fn.apply(this, arguments); }; }; }; How do we use it? Instead of writing `var addWithLogging = before(logger, add)`, we can write: var logsItsArguments = makeBeforeAdvisor(logger); var addWithLogging = logsItsArguments(add); The difference seems subtle, but now you can reuse `logsItsArguments` all over your code. For example, when you're constructing an object of some sort: function MyFoobar () { this.initialize.apply(this, arguments); }; extend(Myfoobar, { initialize: logsItsArguments(function (foo) { ... }), save: logsItsArguments(function () { ... }), // ... };
Thanks, i'll remove browserify from the global install. I originally was going to use bower to get specific versions of angular (with grunt copy). May still do that, but figured the latest version works for the example.
have a look at: https://github.com/angular/angular.js/blob/master/src/ng/parse.js
tl;dr: Use functional programming to make coding easier ;) (compose (curry before arguments) (curry fn arguments))
We're tied to ancient browsers.
 x === undefined *ReferenceError: x is not defined* typeof x === 'undefined' *true* var x; x === undefined *true* jQuery uses `=== undefined` in cases where the variable has been declared but may be undefined. They also use the `(function(window, undefined) {...})(window);` trick to make sure `undefined` is really undefined within the scope of the function. And they also do `core_strundefined = typeof undefined`, followed by a lot of `typeof ... === core_strundefined` throughout the library instead of using the hard-coded string. I don't understand why they do that, but hey that's why that stuff's hidden in a library. 
As always.. /r/AngularJS
/r/AngularJS
/r/AngularJS
Interesting for sure. If I took one thing away from the article, it's that even jQuery could use a good amount of improvement. If anything, it inspires me to continue thinking of different, and better solutions to working with the DOM.
Thanks! I didn't know that. I had always added the full relative path to the executable like this: "scripts": { "build": "./node_modules/browserify/bin/cmd.js browser/main.js" } Good to know!
Wh... Why?
I thought the organization was fine, the copy was clear (and not overly verbose) and I found the code snippets helpful as well. 
Is AngularJS not javascript? :(
You're invoking a regular function instead of using the special ``new`` syntax. Which means that function can be wrapped and manipulated like any other function could be, without changing its behavior. Using the functions defined in this article, you could not do something like... var wrapped = before(function(radius, mass) { if (radius &lt;= 0) { throw new Error('radius must be positive'); } }, Widget); var myWidget = new wrapped(2, 10); Because you'd be creating a new instance of ``wrapped``, not a new instance of ``Widget``. But with the second version you can do: var wrapped = before(function(radius, mass) { if (radius &lt;= 0) { throw new Error('radius must be positive'); } }, createWidget); var myWidget = wrapped(2, 10); ``Object.create`` is just a more explicit way of doing what the ``new`` keyword does implicitly. And it's not particularly more verbose.
Nothing wrong with having good libraries to make a language usable. Most browsers and Node have map, reduce, filter, forEach, etc. supported for Arrays so I don't use Underscore's versions anymore.
Yeah my main goal really is to let others know the sub exists. Not trying to tell you not to post it here by any means, sorry if it came off that way.
Its all good! Sorry for misunderstanding. Have a great day. :)
&gt; My POV on it is, don't program for dumb people. If they want to change what undefined is and it just so happens to break code, that's their fault not yours. I disagree that "fault" has anything to do with this. Consider that you write library *X*, and Ivan Diot writes library *Y*. I require both *X* and *Y*, and something goes wrong. If you guard your code against Ivan redefining `undefined`, I will be able to track down Ivan's choices much more quickly than if you allow his redefinition of `undefined` to poison the behaviour of your code. For this reason, I recommend coding defensively as long as it isn't making your own code impossible to read and/or debug. It's hard to code around the case where someone redefines `Array.prototype.push`, so don't do that. But it's easy to code around changes to `undefined`, so do that. 
Ahem... var singleton = (function() { var privateData = "foo"; var privilegedMethod = function() { return privateData; }; var why = { not: "just", create: "a", literal: "object", with: privilegedMethod }; return why; }()); console.log(singleton.privateData); // =&gt; undefined console.log(singleton.with()); // =&gt; "foo" 
{} Why did you guys waste so many characters?
This is much better. The original is another case of someone forcing a pure OOP design pattern onto JavaScript's much lighter Object-only design. (The only drawback is if you want lazy initialization...)
It's a type of art, some people enjoy, such as myself.
Hey man, love the use of canvas, can't believe this is the first one I've seen! You've got a couple bugs in the code though, looking for them now. I think they stem from no filters being applied. Chrome/OS X
Exactly. There's simply no need for the classical singleton (oxymoron) pattern in JavaScript, because we have object literals and IIFE closures. What's great about this IIFE is we can remove two characters and it becomes a factory. That's how we achieve lazy initialization - an object should not control its own creation and lifetime. The common singleton pattern is nothing more than a hack for class-based system that violates a few OOP principles. Look at the problem singletons try to solve - they ensure that a given class can only have one instance at any given time... But we don't have classes in JavaScript! Just objects. No problem to solve. And remember that even if you create a singleton like this, someone can always do `_.clone(singleton)`, though the two object will share private scopes and you'll wish you just started with a plain old object literal.
Had some time so I thought i'd try to answer my own question. I set up three objects with similar guts: properties a-z, methods 0-9. The methods, though, were defined based on the three ways stated above. Then I declared a million new instances of each object to an array in a simple for loop, and timed how long it took. Obviously the timing results varied, but generally I saw a pattern: **1: outside: 1,500 ms** **2: inside: 3,000 ms** **3: prototype: 500 ms** I have a JSFiddle up here if you'd like to see my method: http://jsfiddle.net/72KqM/1/
Ah, I see. Cool experiment, I guess - basically you are just messing with the base64 data from the canvas in random ways. I wonder what would happen with other file types :-) 
Hopefully this [isn't considered spam](http://www.reddit.com/r/javascript/comments/1qyqvn/sticky_please_report_spam_here_when_you_see_it/)—it's my own content, but I first heard about Gulp here on Reddit and I thought folks would be interested in how it stacked up in my tests. (Full disclosure: letscodejavascript.com is a for-profit subscription site, but the post I linked is free and there are no ads.)
How is inventing your own pseudo-keyword better than using what the language already has? compare `new Widget()` to `createWidget()`, `makeWidget()`, `begetWidget()`, `newWidget()` or whatever convention. They are replacing the keyword with some made up prefix. And there is ridiculous difference in performance.
What I am really having a hard time understanding is why we need to reinvent what is essentially shell scripting in JavaScript. I've been posting this around /r/javascript and /r/webdev the past couple days, kind of making this my own personal campaign against wasting time on these things. I know I'm going to get a lot of strongly worded opinions against my own. Everything I have seen Grunt and Gulp do is easily solved with 1 or more lines of bash, or tcsh, or zsh, or whatever shell you prefer. You don't even *really* have to rely on a specific shell if you're just calling system tools and commands. Here's an example of concurrent gzipping that I posted in another thread. &gt; JavaScript (Gulp): var fs = require('vinyl-fs'), map = require('map-stream'), zlib = require('zlib') grunt.registerTask('zip', function () { fs.src('./build/build.js') .pipe(map(gzip)) .pipe(fs.dest('./build')) .on('end', this.async()) }) // all you need to do is modify the file's // contents and then call the callback. // Just remember it's always buffer in and buffer out. function gzip (file, cb) { zlib.gzip(file.contents, function (err, buffer) { file.contents = buffer file.path = file.path + '.gz' cb(err, file) }) } &gt;Compared to Bash: gzip ./build/build.js &amp; &gt;Maybe a bad example. Let's add pipes. cat ./build/build.js | gzip &gt; ./build/build.js &amp; Your point about the speed of Grunt and Gulp is interesting. What difference does the speed of your (what is essentially) "main" function make? The overhead is in the tools that Grunt and Gulp run, unless I'm missing something here.
The problem is that constructors don't play nicely with combinators/wrappers. Consider: function Widget(radius, mass) { this.radius = radius; this.mass = mass; } Widget.prototype.area = function() { return Math.PI * this.radius * this.radius; }; w = new Widget(2, 10) w.area() //=&gt; 12.566370614359172 Great. Now let's wrap `Widget`: var before = function (before, fn) { return function wrapped () { before.apply(this, arguments); return fn.apply(this, arguments); }; }; function hello () { console.log('hello'); } FriendlyWidget = before(hello, Widget); friendly = new FriendlyWidget(2, 10) //=&gt; hello { radius: 2, mass: 10 } Looks good so far, printed "hello" to the console and correctly initialized the properties. Let's call its `area` method: friendly.area() //=&gt; TypeError: Object #&lt;wrapped&gt; has no method 'area' D'oh! The trouble is, the `new` keyword has used our wrapper function to set the prototype instead of using `Widget` as a prototype. You can see that in the error message, or we can test it directly: Object.getPrototypeOf(w) //=&gt; { area: [Function] } Object.getPrototypeOf(friendly) //=&gt; {} Once you get into AOP-style programming, it's very common to want to give before- or after- advice to constructors. Combinators are obviously not going to work "out of the box" because of the prototype, so you have to do something else. I'm not going to say that factory methods are the only way, or the best way. One alternative is to copy Ruby and always use a method called `initialize`, and wrap that instead of wrapping the constructor. Another is to do some backflips in your wrapping code to detect when the wrapper is being called as a constructor. There are some choices to be made, but there is clearly a problem that needs to be solved if you want to use wrappers on the code that initializes an object. **update**: Here's a variation on `before` that does the backflips. It is not to everyone's taste: # shim for Object.setPrototypeOf Object.setPrototypeOf = Object.setPrototypeOf || function (obj, proto) { obj.__proto__ = proto; return obj; } var before = function (before, fn) { function wrapped () { if (Object.getPrototypeOf(this) === wrapped.prototype) { Object.setPrototypeOf(this, fn.prototype); } before.apply(this, arguments); return fn.apply(this, arguments); }; return wrapped; }; FriendlyWidget = before(hello, Widget); friendly = new FriendlyWidget(2, 10) //=&gt; hello { radius: 2, mass: 10 } friendly.area() //=&gt; 12.566370614359172 
So I'm not a fan of Grunt or Gulp, since there is npm run. However, I think the purpose is to have a cross-platform build system. I can't run bash on Windows and if I'm going to have to write a Windows specific build script I might as well make a platform agnostic one.
There are several reasons, but you may not find them compelling enough. That's fine. I do, though: 1. The programmer may know JavaScript better than the shell, or consider it to be more readable. 2. As builds grow, they become increasingly complex. It's important to use the same sort of code cleaniness and abstractions that you use in production code. It's probably easier to do that in JavaScript than in shell scripts. 3. It's valuable to have your repository be entirely self-contained with no external dependencies. That way your build doesn't break when your environment changes—for example, if you switch to a different distro, upgrade your OS, or upgrade a tool. 4. A special case of (3) is people who want their build to work on both Windows and Unix. 5. A good build tool provides features that raw shell scripts don't, such as useful CLI processing, task documentation, and dependency analysis. 6. You may want to take advantage of libraries you've written in JavaScript. 7. If a lot of your build dependencies are written in JavaScript (such as JSHint, Uglify, and so forth), you can avoid the overhead of spinning up a JavaScript VM each time you run them. 
Regarding the speed difference between the tools, it's a real difference. The overhead time is negligible: Jake: 0.12s Gulp: 0.18s Grunt: 0.21s So the multi-decisecond difference I saw in my test is due to actual differences in the way the tools work. (To measure the overhead, I wrote a little build file that had a single "default" task that executed `console.log("HI")`.)
3, 6, and 7 are compelling reasons, and 5 to some extent. I don't intend to get into a long argument, but to summarize: 3) I do really like this about node.js (the presence of npm). However, the bash scripts I write just run node tools anyway, so it's almost a moot point. Bash is likely available. 7) True, but how significant is that overhead, really? 5) CLI processing is easy with shell scripts, but the documentation and dependency analysis I can agree with. The one I have the most trouble with is #4. There are plenty of node.js tools that don't work in Windows. What I ended up doing for my own dev projects anyway, is to run Grunt and node.js in Git Bash. I haven't have any issues with it. Different strokes for different folks, I suppose.
Oh yea, I'm not doubting that there's a difference, I'm just wondering how much it matters in the end.
If you did Object.create instead of object literal notation it would have a prototype. If we're going all out for over engineering an iife
In methods two and three, you create anonymous functions. The second example will always be the slowest, because they are re-created every time you run barObject(); In the first example, you have declared named functions, and then assigned those functions to properties / methods inside of fooObject (method1 and 2). One would expect that this could be faster than option 3, as the JS engine doesn't need to look up the prototype chain to find the method1 / 2 definitions. However, I suspect the difference pointed out by mattlag may boil down to how JS engines optimize JS code as it runs. By creating the functions as anonymous and assigning them to object prototypes, there's a lot of scoping issues the engine doesn't have to deal with when it executes fooObject(). Furthermore, zedObject is more strictly defined- some engines (I'm looking at you, V8) may have an easier time creating static classes for objects this way, again because functionOne / functionTwo reside in a different scope when fooObject() is called from various scopes. Method 3 is generally preferred as it is also easier to document and maintain, depending on the scale of your application.
I'm so confused. Is this satire, or real?
Will do - yeah I'm not trying to mimic anything with Picoh, it's really for me and how I like to work when it comes to Frontend JS - and keeping things light/minimal - ideally Picoh looses code footprint as I decide to drop support for IE8 and above around the event handling/CSS3 animation code (e.g. remove the polyfills).
This article tells bullshit which is rather harmful than useful for anything. 1st advice has no affect on complexity: it is still O( n^2 ), but this time interpreter will have a hard time trying to optimize the mess. 2nd advice is just wrong. [1,2,3,4].map(function(n){ return n&lt;&lt;2; }) &gt; [4, 8, 12, 16] Note: “forEach” is inappropriate here, so I replaced it with “map” to get actual results. 3rd advice (“Round real numbers before multiplying them”) is bullshit because it only costs two additional string—number conversions. Multiplication performance does not depend on precision, two numbers are multiplied as two doubles after all. Just out of curiosity, I tested the third one in the Chrome console by running exact examples 100000000 times. Regular multiplication: 136 ms Pseudo-optimized with "toFixed": 34113 ms
The "best" version of the for loop is also incorrect (ie. the result differs from the other loops).
Are you talking about something like [JSHint](http://jshint.com/)? If so, I use JSHint via the command line as well as within Sublime Text 2 (via UIPoets JSHint package).
http://jsperf.com/1f5fd88a219e http://jsperf.com/1f5fd88a219e-2 http://jsperf.com/1f5fd88a219e-3 My conclusion: If God wanted sharks to sit in cars, it would have given them butts.
&gt;First of all I think it’s important to evaluate technologies on objective rather than subjective features. “It feels nicer” or “it’s cleaner” aren’t valid reasons: performance, modularity, community size and ease of testing / integration with other tools are. That's a pretty controversial premise, and not one that should be dismissed so easily. Sure, "it feels nicer" is subjective, but what's wrong with subjective? If a large majority (I'm not saying this is the case) think Angular "feels nicer" than React, isn't that significant? I would think that could play a large role in community size/quality. Besides, it seems like he starts off with a claim of objectiveness, and then makes a handful of subjective arguments. The bottom line is, most of the design decisions he discusses with Angular were made with one thing in mind: testing. He pontificates about the difficulty of large apps, but ignores testing and dismisses dependency injection. If you want to convince people that a React codebase is more maintainable, compare tests. StackOverflow threads [like this](https://stackoverflow.com/questions/20412505/how-do-i-simulate-browser-events-when-writing-tests-for-react-js) make me want to hold off on looking into React. On a side note, I find Google front ends to be much more impressive than Facebook's. They're not Angular based, but Google+, for instance, is a much nicer web app than Facebook IMO.
Regarding testing -- the testing API is actually really beautiful since it's just a Simulate.eventName(elem) function call. It's just not packaged very well right now but it's an easy fix. Think about it this way -- we've seen a lot of success stories in production *without* this exposed or any PRs to expose this. This is because when you reduce the amount of mutable state in your application your need for testing is much reduced. Either way we should still probably expose this since being able to test is better than not being able to test :)
&gt; map will modify the array in place and return the result. It will modify a copy of the array, the original array passed in will remain unmodified. var a = [1,2,3,4]; var b = a.map(function(i){ return i &lt;&lt; 2 }); console.log(a); // [1,2,3,4] console.log(b); // [2,4,6,8]
Looks like a joke - the author made another that is a bit more blatant. https://medium.com/cool-code-pal/acb44515497f
You don't need a lib for that simple stuff. http://jsfiddle.net/Ry8E4/ As you may see, all you need to add is a random function and a list or something to store the URLs in.
Hey there, guy who owns skulbuny.com here. The *only* reason I "created" that post was just because it related to the website. I hardly break 10 views a month so I never thought it would have been seen by anyone really. The post he made was really informative, to say the least, but also controversial, so I thought it was at least worth spreading to the 10 people who look at the site. As /u/pygy_ (and the prefix of the whole post that said it's from Reddit... three months ago...) pointed out: [Here's](http://www.reddit.com/r/javascript/comments/1oo1y8/i_know_angularjs_are_there_any_reasons_i_should/ccu651g) the original post by /u/floydophone who deserves all of the credit. He's here in the thread if you feel like discussing it further. Also, if anyone wants me to take it down, I'll gladly do so. It wasn't really meant to be seen anyway. If you want to see what I mean, [here's](http://i.imgur.com/QThDHr9.png) a screenshot of my analytics. Shit's cray.
Excellent presentation. Feels like I'm in college again, except with a decent prof. ;) edit: Can you recommend any other resources/reading material on the last two principles (or the like)? Interface segregation and dependency inversion. Those two seem to be commonly breached in mine experience and I'd like to become more comfortable with fixing them.
Cool beans. Thanks for typing that out - I think that's enough for me to work with. 
That one cracked me up. Still, if even just one person actually falls for some of this stuff, was it worth it? I'm not sure :/ Programming is confusing enough and people come up with such stuff in earnest already.. let's not make it harder on them? But then again I feel that way even about sarcasm. We write things for people of our understanding or above, but that's kinda mean to those who don't get it. I honestly wonder if sarcasm in public posts that will stick around should be considered harmful. Oh well, sorry for rambling, I really need to go to bed.
The line throwing the Error looks technically okay, but I suspect a number of other arguments would also be invalid (e.g. null, number, boolean, object, etc. would all survive that check but probably cause problems later). Supposing the only valid selector is a non-empty string, it would make more sense to verify that it is a string with length &gt; 0 instead of looking for all the things it can't be. Where you would want the try-catch is around `new PlaceholderRotator();`. Currently, that line triggers the exception and halts the whole script. If you catch it then you have a chance to gracefully recover and keep the rest of the script running. Or if this is some crucial piece of functionality, you might just let it crash and consider it a major bug to fix.
Also would be interesting: 1. Documentation to add your own CSS filters/plugins that get a canvas object to redraw on (requires HWaccel.), maybe a set of photoshop composite filters? 2. Documentation around how to use it in the browser / nodejs. 3. Cross platform testing or implementing the webkit layout unit tests. 4. Pure "JS" browser demo built in nodejs? (would require FFI bindings for native window controls) 5. API/Framework for automated web application testing (e.g, similar to PhantonJS?) 6. Move to the JS rendering implementation of SKIA 7. Someone to write a funny joke based on the movie Inception?
thanks! What I'm essentially trying to do is take that "$0.94" that you see in the console in the second picture, and get the corresponding numbers for about 130 other items on that website, then put them in an HTML table, so it would look like this: | Item 1 | $0.94 | | Item 2 | $3.36 | | Item 3 | $2.59 | and so on, for about 130 items.
Don't add your listeners in the setInterval function's function.
You can not just use javascript to load an external URL. Your best bet is a combination of javascript/jQuery with a server-side scripting language like PHP. Here is a very simple example of how I would go about it: **cloner.php** &gt; &lt;?php &gt; header('Content-type: text/html'); &gt; $url = $_REQUEST['url']; &gt; &gt; echo file_get_contents($url); &gt; ?&gt; **index.html** &gt; ... &gt; &lt;script type="text/javascript" src="http://code.jquery.com/jquery-latest.min.js"&gt;&lt;/script&gt; &gt; &lt;script type="text/javascript"&gt; &gt; var elem = $('&lt;div /&gt;'); &gt; elem.load('cloner.php?url=http://example.com'); &gt; var price = elem.find('#result_0_image .market_listing_num_listings_qty').html(); &gt; ... &gt; &lt;/script&gt; After that I guess I would split the string by "&lt;br /&gt;" to get the price. This might not work on the first try as I didn't test it at all, but at a glance that is roughly how I would do it. I actually did something similar to this when I was younger so I could input my Christmas list and it would scour the internet for the best prices and watch for deals and email notifications to my parents when it found unusually good prices haha EDIT: reddit's code formatting is shit...
No need to prematurely optimize--the cost of instantiating an object only matters if you're instantiating lots of them. If so, ``new`` is appropriate and AOP, in any flavor, probably isn't. **Edit**: To be clear, when I say "lots," I mean you need to be doing [millions of instantiations per second](http://jsperf.com/object-create-vs-constructor-vs-object-literal/49) to start being hurt by the cost of object instantiation using ``Object.create``. Odds are, you aren't instantiating that many objects, and your bottleneck is elsewhere.
I'm still working on my graph library. This example shows how to render a 10x10 grid graph within your terminal... as ASCII art. Abstraction shows its power when `screen` object is [injected into the graphics](https://github.com/anvaka/ngraph/blob/a902bf92356156f6a8b0d3c2faac3f5c77b99131/examples/terminal/01%20-%20ASCII/index.js#L9-L12), which allows browser to pretend a terminal. These [ten lines](https://github.com/anvaka/ngraph.ascii/blob/62c2a9540986539e07421d20a822bcf1374c4c9d/demo/faces.js) of code render graph inside real terminal (like in video). I'd love to hear your feedback.
&gt; AOP, in any flavor, probably isn't. That's a very sweeping statement. How do you feel about the [separation of concerns](https://en.wikipedia.org/wiki/Separation_of_concerns)?
One obvious benefit of grunt is that when a task fails, no future scheduled tasks will run and the script will exit.
If it's simple I just play with Chrome Developer tools. If It requires some markup, I do use [plnkr.co](http://plnkr.co/edit/) or [jsfiddle.net](http://jsfiddle.net/). I'm using vim as my primary js editor, and [vim-quckrun](https://github.com/thinca/vim-quickrun) is a nice plugin to run code quickly.
Looks great! I'll give it a try
I also use vim for almost everything, I'll check out that plugin, thanks!
I think `decorator` is actually the proper term here
This hasn't been my experience. There have been plenty of times that I've forgotten a bracket in LESS and saved the file, having the watcher pick it up, run the task, fail, and run it again when I save the file again. Am I misunderstanding, and you mean that it won't run something like csso if SASS fails? Does this count? https://gist.github.com/aholmes/8412456
Sure it is! I think I might not have made my exact point very clear. I run a bunch of node.js tools through shell scripts, and I use grunt-contrib-watch to watch files and make the calls. You can still use npm and install tools local to your projects.
Yeah you can grab elements in a web page using JQuery [selectors](http://www.w3schools.com/jquery/jquery_ref_selectors.asp). It should be a piece of cake once you figure out how they work. How you grab the webpage itself and update it is up to you. As a side note, JQuery is a javascript library not a standalone thing.
Which is fine. That works for you--great! I have also found a system that works for me, utilizing Grunt and the aforementioned library of plugins to very quickly add and configure functionality to my build process. Also great! What's not great--and I'm not saying you're doing this, but some people certainly do--is when people automatically assume that their simpler toolbelt is de facto superior, and that people who use a wider range of tools *must* be doing so because they are less competent. Like I said, not accusing you of that sentiment (though for all I know you share it), but I'm getting really tired of it's frequent appearance in the recent rash of grunt vs gulp posts here.
I mostly agree with this — especially the part about race conditions and the overall immaturity (as in, it's new). I was trying to replicate the Gruntfile for ngBoilerplate, and it felt like an uphill battle. I have already experienced: * Plugins that don't work right, but don't fail, either. ~~The `gulp-less` plugin is/was just not outputting anything for some files, but working fine for others. The author was completely at a loss as to how to properly fix it last I checked.~~ **Update:** Since I wrote this, I checked and the less plugin has been updated. The bugs are gone! Other issues with indecipherable errors still occur, but I'm learning more about why and how to correct them. * Plugins are so focused that it's a hassle to do commonly grouped operations (such as lint, compile, and compress `less` files — what's wrong with doing all those at once if you prefer it??) * It's difficult to work with more complex file sets without writing them to disk (which is sort of the point of gulp). For example, I want to run `jshint` and `ngmin` on my app files, then `concat` the vendor files, a prefix, my app files, and a suffix, then `uglify` the whole mess. Right now, there's almost no way to do this *and* guarantee file order. You are almost better off writing the app files out and then running a separate task to concat, etc. * The thing that drew me to gulp at first was how much easier the gulpfile was to read — it just made more sense, less magic. But, as I started fleshing out the file to handle more components, it got ugly fast. it's not necessarily any easier to read than the Gruntfile as you get past a few basic tasks. I haven't even gotten to Karma! Mind you, that's been a pain under Grunt/ngBoilerplate, already. I hope it gets better, though! I like most of the concepts, at any rate. ---- **Update:** This last one is another issue where the more you learn, the better you can make it. It turns out I didn't understand how to configure dependencies. *However*, and this is a big one, just about all the docs are currently showing the *wrong* way to write tasks. You should always return the stream, and make sure that every tasks only has **one** stream. Rather than this: gulp.task('build', function() { gulp.src(vendorFiles).pipe(gulp.dest(buildDir)); gulp.src(appFiles).pipe(gulp.dest(buildDir)); }); Write them this way: gulp.task('build-vendor', function() { return gulp.src(vendorFiles).pipe(gulp.dest(buildDir)); }); gulp.task('build-app', function() { return gulp.src(appFiles).pipe(gulp.dest(buildDir)); }); gulp.task('build', ['build-vendor', 'build-app']); Now you can use these tasks as dependencies, guaranteeing they complete before the next task runs, if that is important. The individual sub-tasks will still run concurrently. I use this format to handle `clean-&gt;[compile-scripts,compile-styles]` and ensure there is no race conditions.
christ, just use make or python or bash any of the other languages that are designed with this in mind. Watching javascript come to the system with node, etc is like watching web developers remake the userland in the worse way possible... eventually, one of you is going to port busybox to node on accident...
That makes a lot of sense. I tend to prefer the simpler syntax of all the arguments in the first function call instance. I'm not sure why, maybe it's just that it's a simpler introduction. Anyway, if you have a partial utility you can easily do the same sort of thing. E.g. var logsItsArguments = partial(before, logger);
Sorry, not a lot to explain. Unfortunately it isn't a terribly exciting utility, but I always looked at it and wondered when I would even use it. Figured if I was wondering this, someone else would be. 
Are you interpreting my post outside the context of this thread? /u/Esailija complained about the "ridiculous difference in performance" using ``Object.create`` versus ``new``--*if* you're instantiating millions of objects every second, such that you have to worry about the performance cost of whichever method you use to instantiate them, then the performance cost of AOP is probably not worth the benefit. You're clearly working in an extremely performance-sensitive application. But for the 999 out of 1000 cases where the performance difference *doesn't* matter, using these methods helps you maintain cleaner code, and you shouldn't prematurely optimize.
I am interested.
I dunno, it feels sometimes like people are afraid of learning old shit like shell scripting or make. However, arguing about choice of batch processor is also silly. Whatever works, works.
Curious: why?
&gt; I find Google front ends to be much more impressive than Facebook's. They're not Angular based, but Google+ Google+ (gmail, docs, maps etc) uses closure. Feel free to ask any questions on that, we have been building our products using their full stack and it is pretty awesome. Some people in the closure community have adopted react to do their binding, but as good as react is, prerendering on the jvm is just so much better than with node IMO.
closure uses something akin to Simulate ala: goog.testing.events.fireClickEvent(buttonEl); to simulate a click event. Whole bunch of stuff in that lib that is worth looking at IMO
because he doesn't want to support most browsers obviously.
Actually Web Components are supposed to be a standard way to handle components on the web, which is one of the main functions of both React and Angular. And I think the way Web Components work is straightforward.
Yeah, lots of respect for that lib here. React is actually advanced mode compatible, though we don't use the toolkit directly.
Quite a few people switched to react in the closure community, for us loosing jvm based pre-rendering was not an option, closure templates and our in house code generators + frameworks work very well. As a point of interest, our in house approach to binding looks something like this: &lt;input type="text" class="{css new-text-input}" data-bindings="{binding( 'keyInput', 'enterListener', ['target':13, 'handler':'this.enterKeyed();']) }{sp}{binding( 'textInput', 'newTodoText', ['handler':'this.newTextChanged(event.target.value);']) }"/&gt; which gets picked up by the soy templates compiler and then in our JS generation phase generates all the bindings as javascript, allowing us static analysis on our actual binding code + the ability to generate tests for those bindings automagically. 
ps, react is an excellent library, kudos to you guys.
Hello ns0 I work at Ludei, a company that has created a WebGL renderer for HTML5 games used to avoid all the problems when creating games in the webview. I'm really interested on this and the status of your project. In our experience, everything that has been ported with emscripten seems to be slow, would be great to test your renderer in CocoonJS which is our platform to deploy canvas base solutions. Regards @k4rliky
anything in particular i should look for? didn't find anything interesting in the first few hundred lines 
Self-teaching mainly. That and [StackOverflow](http://www.stackoverflow.com)
tldr: famous has a weird founder but there's not a lot of code so we'll wait and see. 
Learning by doing. Once my websites needed to be interactive, I started to use functional JS (that was before toolkits like prototype, jQuery came much later). I learned a lot about the DOM and browser shortcomings. At the time I was more of a generalist, doing backend and frontend stuff alike. About 6 years ago, I abandoned freelanceship in order to specialize on the Frontend Development. This allowed me to learn more about JS than I had ever dreamed of learning before. My advice for you: read JS. Go through existent code and try to understand what it does, how it does it and why. Start with well documented code (e.g. jQuery), work your way up to the sometimes rather cryptic examples of http://140byt.es
haven't tried it in safari, but chrome on OSX works like a charm: http://imgur.com/Ymh01Y6
Open-source code or GTFO. If the technology's any good then it'll speak for itself. Constant hyperbolic statements made to the press and an overly-secretive grip on the actual code just *hurt* the perception of it in the development world - they don't improve it.
Works fine with Polymer.
Oh yeah, your example works as it should in Safari: &gt; var ಠ_ಠ = 5; &lt; undefined &gt; console.log(ಠ_ಠ); [Log] 5 Emoji is something totally different. If you run Mavericks you can press Ctrl+Cmd+Space in text fields and you'll see an Emoji selector that works like the Emoji keyboard on iOS.
Start out doing basic stuff, learn it from the ground up. You might be tempted to start using fancy libraries that will do everything for you, but you'll be shooting yourself in the foot. Js has a bunch of weird quirks, and when those libs start failing, you need to know the stuff happening under the hood.
Can you add comments to the source? I was confused by ts("body").css("width", "400px"); and had time in understanding that ts() is not a selector like $()/Y.one(). I am still confused. 
by the way, this wait is being so long that the smell of vaporware is filling everyone's nostrils.
They used to use a lot of Unicode variables for the various mathematical symbols. But I just looked at the source code again and I don't see them any more.
It holds the community back as a whole to do this. It isn't a compatibility issue. As a JavaScript programmer at any level, if you are redefining undefined, you are doing it wrong. End of story. Checks like this is just enabling people to continue to program badly. Obviously this isn't the only thing that can make you a bad JS developer, but it is something that someone should take a stand against. Compatibility is one thing, but "guarding" against something so idiotic is... well... idiotic.
Oy, you plugged your own site! Your flair betrayed you :) OP, in all seriousness though, like all of the replies say here, learn by doing. Make mistakes (hopefully, make mistakes on your own projects!), and learn not to make them again. I've also read *[Javascript: The Good Parts](http://shop.oreilly.com/product/9780596517748.do)*, and it is a good complement to your self-education. Learn not to be dependent on libraries like jQuery or Mootools, otherwise, they will become a crutch, and you will be dumbfound when someone asks you how to iterate over an object, and you can't think of any proper reply except `$.each` (jQuery), or `Object.each` (Mootools).
Sorry to plug my own site, but these examples have helped me learn about operator precedence, the dark edges of coercion and a lot of stuff you'd never do in JS otherwise.
Relevant http://mathiasbynens.be/notes/javascript-identifiers edit:A word
I personally think that `Object.create` is conceptually way cleaner than `new f()`. You get to specify the prototype instead of getting the function's prototype in a clean way, and you get to (optionally) define some properties. I was just referring to AOP. I happen to like using things like method combinators to separate concerns.
&gt; "end of story..." "idiotic..." I don't enjoy discussing programming issues with people using this tone of voice. It doesn't sound like a sincere discussion of the merits, instead it sounds like one person trying to bully and belittle someone else. I'll leave you to your opinion.
try { (╯°□°）╯︵ ┻━┻ } catch() { ┬─┬ ノ( ゜-゜ノ) }
I would contribute as much as I can. I spent a good part of the day yesterday trying to find an alternative to wrapping phantomjs. I have minimal experience with C++, my last job required bug fixes in a legacy VoIP system and I've only written small things outside of school. I have experience in C#, Scala, JavaScript (frontend and node), and many other things. A guy on my team in Hungary is learning C++, he'd probably love to contribute.
A significant portion of Web traffic is mobile. Please supply source snippets or link to the source with these kinds of things. I do a bunch of research on my phone on my way to work, and I'm certain I'm not alone. 
Oh, it uses lots of mathmatical symbols like (pi). If you forget to include it on a page with UTF-8, the browser errors on those.
React: 1. No IOC container. 2. WTF is this HTML doing in my JavaScript? Number 1 alone is enough to keep React out of my enterprise environment. JavaScript must be "SOLID" if you're going to have a team of &gt;60 people maintaining it. Angular helps this by default, Ember has this as an *option*, and React skips it altogether. Therefor I'd never use React for anything but a very small project. 
Creator of gulp here. You can make as many streams as you want in a task you just need to hint to the task system whats going on (we have something in gulp-util for this). Most of the complaints I've seen so far boil down to confusion because we don't have a lot of documentation/tutorials yet on best practices. We're working on it, but as you probably know writing good documentation is a difficult process.
Heh, I just found out about it a few days ago and ended up implementing list comprehension with the [set-builder notation](http://upload.wikimedia.org/math/e/f/e/efe0811ead0b5ff85b1036c388b1439e.png). doesn't look exactly like the mathematical notation, but sorta look like it which is pretty cool. If anyone is interested tell me and I'll post it tomorrow when I get in front of my work computer.
Unless you make far-reaching modifications to webkit, you'll probably also be compiling in the Javascript engine with emscripten. This means you'll get JS-in-JS performance (worse than JS), and you'll still be paying the C++ toll bridge, but slower (because it's just simulated in slower-than-C++ JS). Using actual browser engines is probably better, especially with projects like Crosswalk.
Fair. My point being that you can't guard against "bad" programmers or malicious programmers that do things intentionally to break code, all the time. I bet 99.99999% of JS programmers would redefine undefined in an application. It serves no purpose. The only people who do it are likely malicious programmers or bad ones.
Isn't this an ad?
I'm trying to replicate a lot of effects seen on porn websites. Biggest problem isn't IE, it's my girlfriend.
I have a coworker who evaluates JS code inside his editor. He's definitely a tool. I can send you his email if you're interested.
Using `matrix3d` will not do much for your app's performance, unless your app is just rendering [lots of spinning quads](http://famo.us/). If you want to build an app using `matrix3d`, just pick up any matrix library like [gl-matrix](https://github.com/toji/gl-matrix). You can apply the perspective matrix to a DOM element, and then model matrices (i.e. translation, rotation) to that element's children. You could use a library like [cam3d](https://github.com/mattdesl/cam3d/), which will make the camera math easier to deal with.
A JavaScript library that will outperform native rendering for everything? Call me skeptic because I am. 
Thanks for the feedback. I've added some comments to [the source](https://github.com/DavidTimms/tiny-style/blob/master/tiny-style.js). You're right, ts() doesn't select elements on the page, it just specifies which CSS selector you want to add properties to. You don't have to call it ts either - you could just as easily use `var style = TinyStyle()` then call `style(".nav").css(...)`. ts is just the name I used in the examples. I hope that helps. 
While everyone else is professing their love for closure I'll throw this in there: https://github.com/rhysbrettbowen/PlastronJS It's built on top of the closure library and is ADVANCED mode compatible. If you're used to working with goog.ui.component to build your application then it works very much like that but with models and helper methods to hook everything up.
That's part of the issue i'm running into, JavaScriptCore compiles with a regular 'ole LLVM, but the WebCore outputs as a static library in emscripten. I've worked around this by creating custom JavaScriptCore headers that just bounce specific types to actual javascript (which is fairly trivial). In addition typed arrays have an ugly hack going from webkit. But it doesn't use JavaScriptCore, it simply relies on the host JavaScript. Unfortunately this is only true one way, going back and modifying the fake dom has 0 effect on the renderer, i'll have to look into this more but the fake dom would need callbacks to the webkit code to perform correctly (see issue #1 at the top of the list). Right now it only renders a webpage and with very limited functionality. Currently there's no support for: 1. Any form elements or native elements 2. Caching 3. Workers 4. CSS Jitting (requires assembly) 5. Plugins/object/embed tags (obviously) 6. Media streams/sources/audio/video/webrtc 7. It will only support data url's, i'm not sure why but any other schemas (even though i've bound to the resource loader) is causing a whole host of errors 8. DOM modifications 9. Script tags (even with a data url) 10. CSS shaders/filters (unsure why at this point) 11. iframes 12. XSLT (although this should be trivial with a libxlst JS port, i just haven't cared to try) 13. Encrypted media (obviously) 14. SQL/SQLLite 15. PDFs (will probably never support PDFkit) 16. Web Sockets 17. Accelerated compositing (although this shouldn't be too difficult to turn on, just multiple rendering contexts) Keep in mind i'm only compiling the layout/rendering code from WebCore, not webkit entirely. 
I hate it when John Resig steals all my secrets.
I'm in the process of cleaning up the experimental build (basically one huge hack of deleting files and fixing link/build/runtime errors without a care for maintenance). I'm about 10% the way through providing actual compiler settings and proper pre-processing commands to build webcore. Once i've finished it i'll post up the code and js library on github and come back and link it. (I'd link it now but no one would have any idea what to do with anything). In addition it only compiles with Xcode, i haven't worked on VS++ or GCC. I probably should also put together contributing/getting started guide.
As most have said already: learn by doing. Think of something you'd want a webpage to do and then make it. Making something *you* want to use will keep you motivated. Also, things **will not** work right away. You won't know why and it will be crazy frustrating. Just keep trying, take walks, etc. and eventually it will work. Sometimes you won't even know why it will work. Lastly, developer tools are your best friend. Learn the crap out of them. Console.log() is your best friend. 
Well its not going to be production ready code anytime soon. As far as performance there's isolated corner cases that seem to be faster than regular rendering, but this might just be a fluke. In addition it doesn't support the full HTML5 subset without the host platform (browser/nodejs) knowing how to fulfill the request (e.g., resource loading, video/audio/etc..). In other words, don't hold your breathe. I'm just looking for anyone with C++ and JS skills to see if they want to help fix some of the major show stoppers. I'll post up the build code on github soon but i'm not sure if it'll be any help at the moment without a lot of bug fixes, documentation and guides.
Related: а = 1; a = 2; a === а; // FALSE edit: copy the code into your console if you're confused
For my two cents: - Angular makes it easier to separate out code and markup, easier for designers (who can't code) to use without endangering the product - React is based on more solid fundamentals and will be faster for extremely large applications - You probably aren't making an extremely large application - even if you think you are. If you are then think about reducing complexity first. - Angular is looking more to the future with web components - DI is one of the best things. ever. period. Even if it could be done better it's still an improvement to not using it. - You don't have to code around angular, just encapsulate things you think go against the program in their own directive. Now you only need to add in the directive to have that thing that is "non-angular" working. - one line changes to get a 20x speedup, that scares me a little. What happens if that one line is put in the wrong place naively? I'd rather that speedup come in by design by using a certain component over another. Performance should be baked in to the design of an application, not as an afterthought. - I do like react, I really do. But it is for *complex* (again, your application probably isn't as complex as you think it is) applications where there is a larger team that includes designers who code. And even then it will work better for now, but 2 years from now? We'll have to wait and see. 
In src/math/random.js and src/math/trigonometry.js
They're back! /u/ya6adu6adushechka I reported already, but figured I'd follow-up here since they're becoming problematic.
Cross-post to /r/AngularJS please!
thanks, i'm just gonna ban the domain
basically it would have been good 2 years ago when I first saw the demos, but now it's too little too late. The march of technology goes on and performance improves all the time on the hardware and software layer meaning things like the famo.us engine behind. It's basically a hack to get performance we should be getting soon.
So [horse_js](https://twitter.com/horse_js) reads /r/javascript I see... 
Right, but maybe in your defense I wasn't being clear: I'm not trying to make the app work despite I.Diot's code. I'm trying to prevent his code from breaking inside of my library, which can be hard to debug. So yeah, if you're writing some code for your web app, maybe you can't be bothered. But when writing something like a library or utility to be open sourced or to be used by others on your team... I can see some value in using things like `typeof(foo) === 'undefined'` instead of `foo === undefined` or using `void 0` instead of `undefined`. My concern is that it can be hard for a third person to figure out that the problem is I.Diot's bogosity.
Also relevant: JavaScript Variable Name Validator http://mothereff.in/js-variables
Not OP but done.
React by default lets you write small composable and unit testable components with a clearly defined interface. React has been designed to be used by large teams of people. Each team is responsible for their own components
Looks really interesting. It might be helpful to show the generated CSS in your examples.
Yeah that's pretty similar to how we do things. One of the things that sets closure and react apart from other tools is that both systems care a lot about being statically analyzable. While React's tooling isn't there yet it's designed with static analysis in mind. We plan to have all user code strongly typable so we can find logic errors at lint time. But this is still a ways off :)
I can understand the concern. I guess what I am getting at is that you are thinking of it in terms of "compatibility." Whereas I don't see this as a compatibility issue. Changing the value of undefined should not be done in the first place. I think it is completely opposite of when writing jQuery plugins. You usually write something like this: (function($) { // Code }(jQuery)) This is perfectly fine because the $ could and is viable for use as a variable in any framework. Using undefined like this shouldn't happen. And if it is, it isn't so much a compatibility problem. It is more like a badly coded framework/piece of code. In my opinion at least.
Given JSON does not have identifiers, care to explain the relevance?
Thanks. I've added that to the readme
**off topic:** gulp is lowercase, by the way.
Here are the few steps that you need to accomplish to be a 'good' javascript developer: 1. Learn to hate ruby and php (and most importantly why) 2. Have an opinion on coffeescript (hint: there is only one correct answer, it sucks) 3. Grow a beard 4. Argue with other developers about module systems (requirejs vs amd) 5. Roll an .vimrc with lots of sweet plugins to make development awesome (sublime is also acceptable as an editor) 6. Make a github and travis-cli account (badges in README.md are the ONLY way to show you are cool) 7. Drink a lot of coffee 8. Save off the beard, it looks terrible 9. Look at the tutorial for angular-js and think about using it on your next project 10. Read what all the fuss is about with ECMA6 and generators 11. ????????? 12. Know javascript There! Do those things and you can get a job programming javascript anywhere! In all seriousness, the best way is to learn by doing. I would suggest starting with some of the projects listed here: [100 Programming Projects](https://github.com/karan/Projects). Pick at the ones that you don't know how to do in javascript, then start a project of your own. Just keep at it, and eventually you will be able to code as well as anyone else.
...and we've come full circle. This was an april fools joke back in 2012... http://badassjs.com/post/20294238453/webkit-js-yes-it-has-finally-happened-browser 
So how, exactly, are they unit testing JSX? There's no dependency injection requirement or IOC implementation. Every team is left to it's own devices to implement an AJAX handler (looks like they're leaning on JQuery here). React is at best a view processing framework. It's hardly a full framework like Angular or Ember. The OP's comparison is comparing apples and fruit markets.
Can be useful if you wish to obfuscate your code! 
Itt: People confusing utf8 (an encoding) with Unicode (a specification of existing characters).
The link to the source is in the top right corner.
The statements made may have served the objectives of the founders of famo.us well. It's made me very skeptical though as a developer, and it's seems fraudulent to say things such as it bypasses the browser and talks directly to the GPU when it does no such thing.
I'm interested! I'd love to see this.
var D = "God, you're so immature."; var ಠ_ಠ = 8==D--
ಠ◡ಠ
[ahem.](http://www.reddit.com/r/javascript/comments/1qyqvn/sticky_please_report_spam_here_when_you_see_it/cepbmaz)
While we're on the topic of syntax - if you want to be really nasty, write some [C in JavaScript](http://jsfiddle.net/mZC5s/).
Why is this?
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Predefined_Core_Objects?redirectlocale=en-US&amp;redirectslug=JavaScript%2FGuide%2FPredefined_Core_Objects#Array_comprehensions
 &gt; 'а'.charCodeAt(0); 1072 &gt; 'a'.charCodeAt(0); 97 In other words, the 1st `a` is actually from the [Cyrillic alphabet](http://en.wikipedia.org/wiki/List_of_Cyrillic_letters).
document.head is not available in older browsers. Use document.getElementsByTagName('head')[0] instead to be sure.
How is that possible ? (I think I'm missing something here) Edit: Didnt think about scrolling hehe. Now I know
1. Don't learn to hate ruby and php (it's not worth your time). It's just good to know when to decide not to use it. 3. Not all great JS hackers have a beard. If you want, cultivate your facial hair, but it will not change your JS skills. 5. It is perfectly OK to adopt sublime instead of vim. 7. If coffee is not to your liking, you may try tea or mate lemonade. 8. beards or the lack thereof are still unsubstantial. Also, some women like them while other do not. It doesn't matter. 11. Read, re-read, think about it. Find ways to do things smarter. Find your own style. Learn regular expressions, and when not to use them. Write ugly code. Re-write it. Again. Improve. You can do it. Find a one-liner to achieve what you would have done in 12 lines a few days ago. Learn about coercion and when to love/hate it and what to do about it. Exchange ideas with other JS devs.
Learn to debug is a good idea. Have my upvote.
Yes I know. I was giving a couple reasons why I find grunt valuable compared to just shell scripting, not vs gulp. 
overriding toString() to customize the DI algorithm locally in the controller?? holy IoC loophole Batman! %-P 
Pretty awesome :)
ʘ = ☉ + ⊙ ∏ = Π + П 3 different characters in both cases
is there any reason why http://www.jsoneditoronline.org/ couldn't be forked for something like this? it has a pretty lovely UI. 
Glad I got at least one :)
Doesn't that evaluate to "disapproving look == false" As in, you're not disapproving?
Wow, it does have a lovely UI :) Absolutely possible, and had I known about it, I would have forked it instead. They already solved 2/3 of my needs (external url + collapsable elements)
Fine, function lovesthe() {return false;} var yourmom = false; var D = "God, you're so immature."; var ಠ_ಠ = 8==D--==yourmom + lovesthe(D); ಠ_ಠ; EDIT: Crap, my original code implied that your mom didn't lovethe(D), which we all know to be false. I give up. It appears only art and video can correctly describe your mom's whorishness.
ಠ◡ಠ
Not sure what you mean by that comment. Did horse_js reply to this subthread?
you should give it a go! If you have a sufficiently extensible and configurable json editor (i.e. defined uneditable parent keys etc) then i don't really see why you can't start exposing editable jsons to the end user for config etc. Dev's dream...!
Sounds awesome. I'd love to see a demo, even a quick screencast. I'd love to see this on GitHub. (And just as a nudge of encouragement, I wouldn't worry too much about polishing it before open-sourcing it. People who are interested in the core concept will not care if it's not production ready yet!)
I have the prototype of a full beard. 
Alas, XP is still in use and IE8 the most modern native browser on that outdated system. Granted, these people could use Chrome or Firefox, but the unability to update the system will not recoil from the browser.
Or if you want to bypass a profanity filter. But everybody knows that, right? 
see also: * [VVVV.js Lab](http://lab.vvvvjs.com/) * [vvvv](http://www.vvvv.org/) a hybrid graphical/textual programming environment for easy prototyping and development
True, true - still I will base that decision on worldwide usage percentages rather than "XP is still in use" - with MS dropping XP support channels very soon - this should really start to accelerate.
The source code in the geo projection plugins makes use of this, [here for example](https://github.com/d3/d3-geo-projection/blob/master/src/natural-earth.js)
The characters ☉, ⊙ and ∏ are symbols, not letters, and cannot be used as JavaScript identifiers.
Ah, thanks for correcting me. So this still works: Π == П
I don't understand how "new" is a problem. It's pretty easy to know when to use "new" and code conventions should make it even easier by making the function name start with a capital letter if it needs "new" in front of it. Also, unlike "new", `Object.create` will not work in legacy browsers.
as always with older browsers, there is a polyfill: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create
"Problem" doesn't mean "impossible," only, perhaps "annoying." But capitalizing some functions won't solve the problem of having to burden wrappers with extra cruft. That is a hint that two things that could work the same way, don't work the same way. So why not use one thing that always works the same way?
&gt; This polyfill […] doesn't take the second argument into account.
i'd be interested to see what you guys develop. from the base you have statically analyzing bindings becomes an interesting math game. as always game changers do the job when needed.
i have a list of chars that i was told are all valid http://pastebin.com/UNjncX95 (haven't tested them all myself, but they seem legit)
your jokes are worse than your code
There's a bug in your C code: void main() { char *a; a = malloc(2 * sizeof(char)); a[0] = 'j'; a[1] = 's'; printf(a); free(a); return; } As you know, `printf` requires a zero terminated string, and this code does not zero terminate the string. You just got lucky because JSFiddle uses a special C compiler that protects against errors like this to avoid crashing the site. A more typical production C compiler may leave garbage in memory after the string, and `printf` could either print that garbage, crash, or do something worse. The code should be: void main() { char *a; a = malloc(3 * sizeof(char)); a[0] = 'j'; a[1] = 's'; a[2] = '\0'; printf(a); free(a); return; } [Updated fiddle](http://jsfiddle.net/mZC5s/1/)
I'm an emscripten dev, let me know if there's anything we can help with on the emscripten side of things. This project sounds very interesting! :)
&gt; In our experience, everything that has been ported with emscripten seems to be slow Pretty surprised by this statement -- can you give some examples of what you find slow? Most of the ports and projects we've done or helped with (I work at Mozilla on much of this tech) are quite fast, and the industry seems to agree.
They still use them: https://github.com/mbostock/d3/blob/master/d3.js#L1178 Personally I think it's a ridiculous thing to do, but d3 is popular and I am not.
That's the point.
 object1.prototype = object2.prototype According to the article, that has got interesting effects where object2's prototype is copied rather than object1 having its prototype property point to the same prototype object.
Carry on then.
In some classes I make, I have the constructor work differently when it's not called with the new operator. The object gets instantiated in abstract mode, and operates differently, as a representation of what it is. For example, a DB related class would normally be able to connect to a database, but when in abstract mode acts as a representation of that database, so can not (or at least does not get used to) actually connect to the database.
Does "&lt;javascript code here&gt;".length * 4 = Size of javascript code in bytes, always ? var t = "try { (╯°□°）╯︵ ┻━┻; } catch() { ┬─┬ ノ( ゜-゜ノ); }"; t.length*4 = 192 bytes
[Lame.](http://i.imgur.com/H0WfRFf.jpg)
can you mention an example? Thanks!
How about a defensive `before` like this: function defensiveBefore (fn, beforeAdvice) { return function wrapped () { var context = this; if (this instanceof wrapped) { context = Object.create(fn.prototype); } beforeAdvice.apply(context, arguments); var result = fn.apply(context, arguments); if (this instanceof wrapped &amp;&amp; Object(result) !== result) { return context; } return result; }; } That is how I would imagine writing it, and I believe it conforms to the `new` keyword semantics (and keeps the `before` function with the correct context, which another solution involving `Function.prototype.bind` would not).
&gt; The trouble with instanceof is that it is unreliable whenever you use Object.create instead of the new keyword Is there an example of this actually happening? I can't think of any outside of replacing the prototype object on the constructor, which makes perfect sense. 
I think in many cases actually using symbols is a bad idea. In this particular case I think it's acceptable because it increases readability, and they're only used in functions that are not going to change (so no one has to keep copy/pasting them). If however π was really the value of Math.E instead of Math.PI, then it would be insane. 
looks like ghostery was blocking it.
I guess it could be worse. &gt;"IDN silliness and unicode combining characters" This is a valid URL: http://░͇͇͇͇͇͇͇͇͇͇͇͇͇͇͇͇͇͇͇͇͇͇͇͇͇͇͇͇.ws It wont link in Reddit, but Copy and Paste it into your address bar for SCIENCE!
&gt; TIL: JavaScript allows for UTF8 variable names It's UCS2 actually. Try apple emoji characters?
To me it seems like he is trying to apply Classical Inheritance to JS's prototypal inheritance and making problems out of nothing. For example, &gt; The trouble with instanceof is that it is unreliable whenever you use Object.create instead of the new keyword From my understanding of Object.create, this is "unreliable" since it works entirely differently than the new keyword. Object.create() returns the prototype of the passed Object. The programmer must then set the constructor and the parent. Once this is done, it will work just like "new". As for when to use "new", I agree that it's a bit confusing at times, but it also doesn't seem like a huge problem to me. Use "new" when you are creating an instance of an Object, don't use it when you are simply calling it as a function. **tl;dr This isn't a problem. It's JS and JS sometimes a lot different than other languages (specifically with inheritance and object creation).**
My favoured pattern for class-like objects is something like this: var Person = (function () { function Person (name) { this.name = name; } function createPerson (name) { return new Person(name); } createPerson.prototype = Person.prototype = { talk: function () { console.log("hello, my name is " + this.name); } } return createPerson; })(); It works with or without `new`, and `instanceof` works correctly. Defining the prototype as an object literal is a lot less messy than having stuff like `MyClass.prototype.newMethod = ...`all over the place.
It seems you just like "full stack" frameworks. Others (like me) like when frameworks don't dictate too much and basically they don't like frameworks at all and like libraries which can be composed together. This is the case with React — every cell in the table which have "no X" for me is a big plus — you can just use your (usually better) solution for that. Like for Modular code-organization I use CommonJS and bundle all my code with browserify. For routing I have a top level React component (which is open source, code on GitHub). And so on... Others have different requirements and so different solutions. By the way, some of your points don't make sense at all, like "The use of text-based templating to define HTML...".
&gt; From my understanding of Object.create, this is "unreliable" since it works entirely differently than the new keyword. Object.create() returns the prototype of the passed Object. The programmer must then set the constructor and the parent. Once this is done, it will work just like "new". That isn't what happens. In its simplest form, `Object.create` takes a prototype and returns a new object with the supplied prototype set. So: var myProto = { say: 'hello' }; var speaker = Object.create(myProto); speaker.say //=&gt; 'hello' myProto.isPrototypeOf(speaker) //=&gt; true myProto === Object.getPrototypeOf(speaker) //=&gt; true `Object.create` does the simple and obvious thing, it creates a new object and sets the new object's prototype. If you don't want a prototype, you can call `Object.create(null)`. If you want the same default thing you get when you use an object literal like `{ ... }, you can write `Object.create(Object.prototype). You have complete control, but you don;t have to set any prototypes yourself, `Object.create` does it for you. But, this isn't "classical" in any way, shape, or form. A class is a metaobject. Classes have methods that create objects, define methods, and so forth. Prototypes are not classes, as they don't present an interface of any kind for manipulating or even creating objects. `Object.create` is simply a tool for creating objects that avoids certain edge cases that the `new` keyword presents. They both produce objects with prototypes. 
This is the most correct answer out of everything here, but you're not completely right. You **can** use JavaScript to load an external URL, via AJAX, but it can be a total pain in the ass if you're not on the same domain.
jQuery wouldn't be required for this, but it would make it a lot easier.
Well, if I write: var myProto = { say: 'hello' }; var speaker = Object.create(myProto); `speaker` isn't an `instanceof` *anything*: speaker instanceof myProto //=&gt; TypeError: Expecting a function in instanceof check, but got #&lt;Object&gt; `instanceof` wants a function, and it wants the function to have a prototype, and it'll check the prototype. We can fake it: function unused () {} unused.prototype = myProto; speaker instanceof unused //=&gt; true So, I mean that `instanceof` is unreliable in the sense that it is checking the wrong thing. It takes a function as an argument but it's really a proxy for checking the prototype. So why not check the prototype directly with `.isPrototypeOf`?
Gotcha, thanks!
Here is an overview of what you should do (without being too specific): 1. Create your table with a radio button group on the left and an image tag on the right with HTML 2. Figure out how to execute JavaScript when one of the radio buttons is clicked 3. Figure out which radio button was clicked using JavaScript 4. Based on which radio button was clicked change the image tag's src to be the URL of the corresponding countries flag image using JavaScript
𝑓ᵁℂk Ч⫑һ ᗷ|┯ᑕḪ إإإ
&gt; could work the same way But they clearly don't work the same way and aren't intended to. They do different things, as you well know. Important to know the difference? absolutely. Problem? not really.
/r/forhire 
No, it's a direct assignment. Both `object1.prototype` and `object2.prototype` are the same object. If you try to add methods to `object1.prototype`, instances of `object2` will get them as well, which is not the desired behavior. You should use `Object.create()` in this situation: function Shape(sides) { this.sides = sides; } Shape.prototype.sayHi = function() { alert('Hi, I am a shape with '+this.sides+' sides!'); }; function Rectangle(w, h) { Shape.call(this, 4); this.w = w; this.h = h; } Rectangle.prototype = Object.create(Shape.prototype); // Rectangle.prototype = Shape.prototype; // Doing this gives all Shapes a resize method Rectangle.prototype.resize = function(factor) { this.w *= factor; this.h *= factor; }; var rectangle = new Rectangle(4, 3); The author's described method of using `new Shape()` will actually call `Shape`'s constructor, which may have unintended side effects.
Their website at http://phantomjs.org mentions at least 4, in big bold letters like **HEADLESS WEBSITE TESTING**
I wrote a visualizer for showing relationships between objects, prototypes, and functions. It takes arbitrary code, runs it, and visualizes the resulting object graph. I found it useful when I was trying to figure out how the #$@! JS handled objects. It's here: http://www.objectplayground.com 
I think JavaScript is the best language around :) It's flexibility has allowed me to code very expressively.
[Well, duh.](http://i.imgur.com/nCDOpCL.png) :p
Agreed. A lot of JavaScript's "problems" can be eliminated through simple hygiene. 1. "use strict"; 2. Lint your code. If you do that, misusing "new" is a non-issue. It's also simpler and more idiomatic than Object.create().
I think you're funny
Good title, sounds like a conspiracy
PhantomJS has a webserver module: [http://phantomjs.org/api/webserver/]
I'm sorry, but I don't understand what you mean. PhantomJS is a *headless* browser. What possible function could that have on a "live web server"?
I hear you; still, it's &gt;5% of our user base, so I can't sell that decision to my superiors at the moment.
Well, the `'j'` and `'s'` in that C code are just character literals; you could put any characters there, even more characters if you assign them one by one in the same manner. Just be sure to allocate the character array the right length in the `malloc` call so you don't have a buffer overrun, and zero terminate it! For example: a = malloc(4 * sizeof(char)); a[0] = 'C'; a[1] = a[2] = '+'; a[3] = '\0'; [C++ fiddle](http://jsfiddle.net/mZC5s/6/)
&gt;It's also simpler and more idiomatic than Object.create(). Depends on the ecosystem you're talking about. Exposing factory methods from your module is standard operating procedure for Node, for example: require('http').createServer(/*...*/).listen(8080); Of course whether that uses ``new`` or ``Object.create`` internally is up to the library's authors. But idiomatically, Node modules sidestep the whole question. To me, the existence of ``Object.create`` demonstrates the ``new`` keyword to be a fossil left over from the days when JS was still masquerading as Java. It's a reserved keyword, an operator with weird precedence, and a way of invoking a function that's unlike any other function invocation. ``Object.create`` imposes no reserved words, follows the precedence rules of any other function call, and acts like any other function call when invoked. Conceptually, JS is a simpler language without the ``new`` keyword than with it, and it's a bit closer to the functional language that it desperately wants to be. But these preferences are all aesthetic--both options work, they do pretty much the same thing, and the performance implications only matter *in extremis* and probably only until browser vendors get around to optimizing ``Object.create``.
I personally like frameworks which are 100% typescript, and can manage to generate client side domain model (in typescript), and have a server side part (dataservice). The server side part must be written in c# (because i know it well). The framework should have very good datagrid and it should use MVVM pattern (like MS Silverlight)and should work in javascript strict mode (no evals). For those criteria i know only one such framework https://github.com/BBGONE/jRIAppTS which i usu to create LOB applications at my work.
It is used by some Node.js webservers to render client-side templates on the server for compatibility with non-js clients such as search spiders.
Just asking but besides requiring "new" is there a difference between the following code and your code. var Person = function(name){ this.name = name; } Person.prototype = { talk:function(){ console.log("hello, my name is " + this.name); } }
Sounds good. Thankfully I have a Mac so it shouldn't be a problem. I'm interested to hear back from you! Thanks! 
Not certain if you're attempting to make a comment on the difference between character encoding and character set. To clarify, [String.length()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length) always counts the number of characters in a string, regardless of encoding. However, how many bytes long that string is will generally not be available to you. Since you presumably know the encoding of the document which holds your Javascript, [you can use that information to calculate the byte-length of your string using the function in this StackOverflow answer](http://stackoverflow.com/a/5515960/106769). As a rule, Javascript or not, if your document is encoded as UTF-8, the bytes-per-character of a given string will vary. If your document is encoded in UTF-32, you will have exactly 4 bytes per character.
According to the spec, it must start with `$`, `_`, any unicode code point with the `ID_Start` property (the category itself is not a concern) or any unicode escape sequence. 
Dude, stop spamming your own blog please.
As far as I know you can't change the default one. However you can make your own and overlay it or something.
You should use &lt;video&gt; tag JavaScript API. According to your requirements, this can be implemented relatively easy.
Have you ever tried to a) create a new framework/library and b) come up with a unique name for it? It's a lot of work to achieve a), let alone b). So please shut up about names and thank these people for sharing their code instead of wasting their time.
And you can't extend his code or subclass the function. Making it kind of useless to even use the prototype.
Other comments nailed it. If you don't know it yet, you could also check [casperjs, a headless testing and scripting utility](http://casperjs.org/) based on phantomjs.
I prefer the function wrapper, as it allows you to have private functions and variables in there without putting them in the global namespace. Your way is fine though - it's just a matter of taste. 
I have been wondering how can one create this kind of service on his own VPS. I mean if I wanted to mimick Puhsbullet, Pushover or Pubnub's functionality.
Sweet, now i can have boobs in my variable name! ϾϿ
I don't think phantom is what you think it is.
I do function wrappers too and pass the object to window but use the structure as I used here. That way you have a private environment but keep the simplicity and readability of the structure.
That is a good way to do it in the browser. I do quite a lot of Node stuff, so I try to stay away from `window` though. 
[Helpful guide](http://ionicframework.com/blog/ionic-and-nitrousio/)
You can always make your "classes" new agnostic: function User(name, pwdHash){ var self = this instanceof User ? this : Object.create(User.prototype); self.name = name; self.pwdHash = pwdHash; } This way you can both call: var user = new User('Mike', "abc"); and var user = User('Mike', "abc");
Sorry, I guess I skipped that part. And I agree about the constructor, but people tend to be confused. So I chose class in quotation marks. 
Sounds like it's overboard for my purposes. I'm keeping this simple and only hosting on GitHub Pages.
A good blog series talking about the difference between constructor functions and Object.create: http://davidwalsh.name/javascript-objects
Does Mustache have the logic for date comparisons that I'm looking for? Skimming their documentation, it doesn't seem like it does.
My bad, we're on the same page with respect to "classes." I agree that it's acceptable to refer to a JavaScript "class" if you use air quotes. 
"There are only two hard things in Computer Science: cache invalidation, naming things and off-by-one errors." I would have thought that for most JavaScript projects the issue can be resolved by checking whether the name is still available on npm and bower.
Yes, if you have control of the page you are trying to pull from, you can modify the Access-Control-Allow-Origin to make it work. I didn't mention it because he was clearly trying to pull from major commercial sites which he shouldn't have access to. I am not aware of any way to make it work if you don't have access to the domain, but you seem to be implying there is a way. How would you load information directly from a site like Amazon without cloning it?
"Ionic is a beautiful front-end framework for developing hybrid mobile apps in HTML5" Guess the one word which is completely unnecessary. Also, if someone on the project/team reads this, please consider adding more contrast to your typography. That would be beautiful.
[http://░͇͇͇͇͇͇͇͇͇͇͇͇͇͇͇͇͇͇͇͇͇͇͇͇͇͇͇͇.ws]( http://%E2%96%91%CD%87%CD%87%CD%87%CD%87%CD%87%CD%87%CD%87%CD%87%CD%87%CD%87%CD%87%CD%87%CD%87%CD%87%CD%87%CD%87%CD%87%CD%87%CD%87%CD%87%CD%87%CD%87%CD%87%CD%87%CD%87%CD%87%CD%87%CD%87.ws) Damn... I tried everything. I'll let this be as a sign of my failure.
And then you missed it because it only was on sourceforge or github or google code... in addition, your quotes without attribution show how difficult names are for developers some times.
I kinda don't like that this is an article for purely about selling PubNub's services (not that there's anything wrong with their services), because there's far more fluff than substance. For more in-depth discussion and, most importantly, code samples, check out these HTML5Rocks article: http://www.html5rocks.com/en/tutorials/webrtc/basics/ http://www.html5rocks.com/en/tutorials/webrtc/infrastructure/ Those two links should get you (almost) everything you need to know about WebRTC and how servers come into play. It's also illuminating to read every link contained within those articles - there's tons of great, supportive information of what HTML5R wrote about. And then, go do their WebRTC codelab: https://bitbucket.org/webrtc/codelab Basically, if you want to mimic what they do, you just need to have your VPS act as a signaling server through some sort of API that your clients can then use to connect to one another. The only thing the server does in a RTCPeerConnection is make sure the peers can all connect to each other. It's like if you're friends with a dude, and you know a chick from high school, and she wants to hook up with said dude, you bring the two of them together. A direct P2P connection would be if you were all at the same bar and just had to walk each one to the other. Something using STUN, and then TURN (traversal using relays around NAT) if STUN fails, would be akin to giving said chick the dude's number, and vice-versa. 
There's some additional code down there when you scroll. Don't feel bad, I fell for it too :-P
I think either Underscore or Handlebars/Mustache are two good choices. The thing with underscore is that you can write actual js code within your templates, so I don't know how you feel about that but I believe it is an asset. Underscore also has a ton of awesome functions, so you can use those too, or just strip everything from the file except for the template function
&gt;The non-peer-to-peer side of WebRTC is the SDP exchange All RTCPeerConnections use SDP. Even in an environment using something like a MCU, or where you have one stream publisher and multiple stream subscribers, the publisher needs to know what the video, audio and data capabilities are of the subscribers, and vice-versa. From the HTML5R article I linked above: &gt;In the real world, WebRTC needs servers, however simple, so the following can happen: &gt;• Users discover each other and exchange 'real world' details such as names. &gt;• WebRTC client applications (peers) exchange network information. &gt;• Peers exchange data about media such as video format and resolution. &gt;• WebRTC client applications traverse NAT gateways and firewalls. But, SDP is not required for using RTCDataChannel, since an active RTCPeerConnection needs to be present.
I'm not disagreeing, really. Naming things _is_ hard and name clashes are inevitable. Checking bower and npm can at least prevent you from picking a name of a thing that's already well-known and popular. As for the quote -- I'd have attributed it, but there doesn't seem to be a reliable attribution for that particular version. Apparently the original version (without the off-by-one error) is indirectly attributed to Phil Karlton, though.
That's pretty clever, but I'm not convinced creating classes for what are essentially singletons is a good idea (plus the syntax is only this nice using CoffeeScript or an ES6 translator). Also, I'm not sure overriding `toString()` is the best approach. If it wasn't class-based you could simply return an array and avoid the function decompilation.
never heard of vvvv before but looks really cool It looks like processing meets scratch edit: The demos are incredible!
I'd say handlebars or mustache, depending on the amount of logic you're willing to put in your view. You could also map your (possible) json object to a view model which then could contain all view logic (getters/setters with defineproperty), that way those two layers are separated nicely. In that case you could go for mustache.
Make it a phone yo. https://github.com/versatica/JsSIP
Would I be correct that loading the content via a javascript template would ruin any sort of search engine results?
Except that won't actually support anything other than enumerable, writable, configurable values.
Apologies for jumping in. I may not be properly tracking the conversation. But rather than explicitly interact with window why not pass your context as a parameter? (function(context){ var Person = function(name){ this.name = name; } Person.prototype = { talk:function(){ console.log("hello, my name is " + this.name); } } return context.Person; })(this)
That title.. nnngh. "What is WebRTC, and why should you use it?"
You're not actually assigning anything to the context there, so the code has no effect. Did you mean `context.Person = Person;` instead of `return context.Person;`? Either way, `this` does not reference the global context in Node, so it wouldn't be platform agnostic. This way works regardless of context: var Person = (function () { function Person (name) { this.name = name; } Person.prototype = { talk: function () { console.log("hello, my name is " + this.name); } } return Person; })();
that's why there are mantras like "release early release often" and "done is better than perfect"
If you run Node.js then http://peerjs.com/ is very nice to get the basics up quickly.
lol 
Cool it. If you can write a framework, I'm sure you're able to use google and check that (at least) it's not colliding with another JS project. Naming things is hard work, but it's just work..
yeah.+1
And the Chrome frame for IE.
You have to be inventive with this. [Here's how the Meteor framework is currently solving this, despite being a client-rendering framework](http://docs.meteor.com/#spiderable).
There are no unnecessary words as far as SEO is concerned ;)
lol, awesome trick! =)
You got quite a few!
You'd think a corporate plug would get its wording right.
=) Thanks!
Is there a pre-compile option that might be better suited to what I'm doing?
Yet Another Forgettable List of Libraries. I'm officially coining YAFLL.
Srsly, whence are all the upvotes coming? The only useful information the article contains can be synthesised in one line: &gt; WebRTC is a p2p protocol allowing browsers to send realtime video, audio and data without using a plugin. ... which I hope most of this subreddit is already familiar with. The rest is fluff, marketing, and shit like this &gt; To an end user, WebRTC applications “just work” right out of the box. No Flash, no Silverlight, no JavaScript API, just pure video, audio, and data communication on any webpage. ... which does not make any fucking sense (no JS API? o.o) I really hope these upvotes are all from PubNub's employees.
I pretty much agree with you, but I'd like to dive deeper: I say that `new` is simpler than `Object.create` because it reduces duplication for *programmers*. You're arguing that `Object.create` is simpler than `new` from a hypothetical language design perspective. I agree, but it's not an issue I'm concerned with; I care about how to use the JS we have. The reason `new` is simpler than `Object.create` is because `new` creates and initializes. Without `new`, programmers have to write two lines of code: var me = Object.create(Person); me.initialize("James"); *With* `new`, you write one line of code: var me = new Person("James"); The second reduces duplication and also eliminates the error case where the programmer forgets to use the initializer. You could argue that people should always use factory methods... var me = Person.create("James"); ...and I agree, but how do you communicate and check that convention? There's no standard, so invariably some people will use `Person.init(),` some people will use the Node-like `aFactoryFunction(),` and some people will expect you to use `Object.create()`. The convention of using `new` with capital-letter functions is well established in JS and easily checked by a widely-deployed static analysis tool (JSHint). There's no such convention or static analysis for Object.create() and initializers. (Not even in Node. The Node library itself is very consistent, but third-party Node.js modules aren't.) All of these issues are solvable. The question is: why? What gain do we get? In my perhaps-insufficient research into prototypal inheritance design patterns, (primarily [this article about Self](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.56.8715)), prototype-based design looks an awful lot like class-based design. The names change but the overall organizational structure remains pretty much the same. If `Object.create()` and prototype-oriented structures led to amazing new opportunities for abstractions and clear communication of design, I'd be all for it. But I haven't seen anything other than a different way of doing things. One that's a bit more clever and a bit more "pure," but that's also more prone to error, less common, and—because it's not common and familiar—actually *less* clear than `new`. I'm hoping /u/homoiconic will weigh in on this with some neat and useful abstractions I haven't heard of. But in absence of new design possibilities, I don't see what prototype-oriented design using `Object.create()` gets us.
I want browser -&gt; server UDP, not browser -&gt; browser UDP :(
Curiosity here: what for?
Interesting but there is a name collision. There is already another prominent javascript library named Lazy.js. http://danieltao.com/lazy.js/ You might consider renaming to something more specific like LazyLoader.js.
I don't want other developers on my team thinking they can use `Object.create` per-spec when they cannot. Therefore I wouldn't bother using a polyfill that doesn't conform to spec. I'll continue using `new` until the platforms we support have `Object.create` available natively.
That's a good idea. Are you basing your new editor on an existing one, or starting from scratch? Will it be open source?
Thanks, /u/DavetheBassGuy! I'm looking around, I think I might attempt starting from http://github.com/nbrogi/Proper I will definitely be open source (MIT-licensed).
It's useful for games and other latency-sensitive apps from what I've read. It's often used in combination with TCP and requires a lot of tricky code to be effective.
I'm not sure this is what you want, but: [http://phantomjscloud.com](http://phantomjscloud.com) which is... phantomjs hosted as a webservice. disclaimer: i wrote it. 
uppercase
Well, thank you :) 
1. Save the total width of the control bar as a variable 2. Save the current position of the video as a function of the total width of the control bar. That's where you start your loop. 3. Save the ending position of the loop as a function of the total width of the control bar. That's where you end your loop. 4. Highlight the bar in between the ending position and the starting position. This would look like this -- function selectWidth(){ // find total Width of progress bar ... // Now find User's starting position within the progress-bar div ... // Now find User's ending position within the progress-bar div ... // Now change progress bar color in between and do all of the other stuff you need to do (loop over video ... etc) } Let me know if this isn't clear.
I'm worried that npm is going the route of nginx and they are going to start charging for "enterprise" features that should be in the open source version.
You mean `ALL_UPPER_CASE`?
https://github.com/jasonmoo/t.js I use this but I have very simple needs.
Most people will answer uppercase. I just like to throw in a point I think I was once reading from Microsoft about C#. If you make something uppercase it's like you provide too much information about your API.
http://stackoverflow.com/questions/242534/c-sharp-naming-convention-for-constants
I would recommend personally. [JavaScript: The Definitive Guide](http://www.amazon.com/JavaScript-Definitive-Guide-Activate-Guides/dp/0596805527/ref=sr_1_2?ie=UTF8&amp;qid=1389847951&amp;sr=8-2&amp;keywords=javascript)
I'd make an exception for bash. All-up generally indicates system vars, like HOME, PS1, IFS, etc. You don't want to clash with those. Shell aside, I agree with the rest as a general rule.
All caps with underscores. The usual thing. By the way, there is `const` (i.e. real constants) in ES6.
Is I already was writing in the top comment: This is not true: see C#.
Fast paced multiplayer games where TCP has a lot of flaws.
I recommend these books (in this order): * [JavaScript: The Good Parts](http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742) * [JavaScript Allonge](https://leanpub.com/javascript-allonge) * [Functional JavaScript](http://shop.oreilly.com/product/0636920028857.do) 
Would it be hard to fork node or npm if that happened ?
I think he means the opposite of CAMEL_CASE!
I didn't know nginx was doing that, now I'm sad
Unless [http://caniuse.com/#search=webrtc](http://caniuse.com/#search=webrtc) is outdated, the answer would be not to use it?!
You mean you think he means the opposite of camelCase?
What about the non open source plugins built on top of npm?
Sorry, care to expand on that - don't quite get your point.?
Hey dude, I made [this project over the holiday season](http://kadodamball.byethost8.com/d3.html). I used [d3js](http://d3js.org), [DataTables (jQuery plugin)](http://datatables.net) and [tablesorterjs(another jQuery plugin)](http://tablesorter.com/‎). I would recommend checking out d3js. Even if you don't need it, you'll almost always find it helpful because it's that good. In my project, I scrap the data as csv, do an ajax request for it, and manipulate/draw using d3js. The two jQuery plugins are later for simple functionalities like sorting tables and doing a search function. Edit/View can easily be handled by jQuery anyway. 
Do you mind elaborating on that?
ALL_UPPER_CASE_WITH_UNDER_SCORES
should be = entitlement = bs
Mhhh.. is not really a template engine but you can keep a look [React](http://facebook.github.io/react/). Try to define a way to represent components in a dom style and optimizing the changes based on models. He as they own syntax (JSX) to define agnostic components. And is already in production in Facebook and Instagram (webapp).
I'm not sure how it plays with Require, but Slickgrid is one I've used in the past that I liked. Just please do not use jqGrid...
Two things happen with the return value of the function passed to "then" 1. it will become the input for the next handler in the chain 2. if it looks like a promise, it will block the chain until it is resolved values, including undefined, are considered to be resolved promises. See if this helps: var when = require('when'); // returns a promise that has already been resolved. function foo() { console.log('first!'); return when( 'from foo' // this value will become the input to bar ); } // returns a promise that will be resolved shortly function bar(x /* 'from foo' */) { var deferred = when.defer(); console.log('third! bar', x); // defer execution until some future time process.nextTick(function () { console.log('fourth!'); deferred.resolve( 'from bar' // becomes the input to baz ); }); return deferred.promise; } function baz(x /* 'from bar' */) { console.log('fifth!', 'baz', x); } foo() .then(bar) // will be called right away .then(baz) // will be called with the bar promise is resolved ; // note: most promise libraries defer the resolution until the next // tick. thus this will be executed after foo() but before the // promise chain is fired console.log('second!'); 
C# breaks a lot of standard naming conventions... For seemingly no reason other than "because".
UppercaseFirstLetter is PascalCase opposed to camelCase.
Because letting someone know they can't change a value would be helpful. ;)
Your problem is that you're not returning the promise from the deferred you're creating. That `then` handler is implicitly returning `null`, which is causing its promise to resolve. Add a `return deferred.promise;` to fix the problem.
Oh, did not mean to sound condescending at all. Sorry if it came across as that. And that looks very cool, I will look into it, thanks for the links!
Instead of for (D in B), one should use for (var D = 0; D &lt; B.length; D++); or even better (if older IE versions do not matter), use the native and faster .indexOf method: var A = (function(B){ return function(C) { return B.indexOf(C) &gt; -1 || !B.push(C) }})([]); It took me about 2 minutes to reach this solution. I think ~10 minutes are ok. However, I agree with TheMoonMaster that this test is not very practical.
I personally hate it when programming tests have nonsensical variable names. I keep forgetting what everything is if you call it ABCDE. Even something like var aFunction = function () { var anArray = []; return function(something) { for (value in anArray) { if (anArray[value] === something) { return true; } } anArray.push(something); return false; } }(); Already makes a lot more sense to me. var aFunction = function () { var anArray = []; return function(something) { if (anArray.indexOf(something) &gt; -1) { return true; } else { anArray.push(something); return false; } } }(); Isn't that what you're looking for?
It's not entitlement. It's knowing that open source gatekeepers have to be very careful not to create a conflict of interest between their open source endeavors and their business endeavors. Companies use open source and associated community to gain market dominance. Once companies have that dominance, they should not turn around and screw the community that helped build the company by nickle-and-diming the community for important features.
There isn't even anything to compare the "speed" against. It feels like this is stacked against the programmer.
You could use an insertion algorithm which keeps the array sorted. This would let you use binary search to check whether the element is in the array in logarithmic time. JS arrays would rarely be large enough for that sort of low-level optimization to be necessary, though.
If you are using backbone.js or are willing to, backgrid.js works pretty well. For the editing in a modal window, you will be on your own though.
How do I get my console.log statement to output on a whiteboard? Should I go back to alerts?
If I saw JavaScript like this on an interview question I would run from the job.
I'll echo JavaScript: The Good Parts
In general, if the majority of the programmers you are interviewing are getting your question wrong, chances are it's a bad question and needs to be scrapped. Try using a chunk of your existing code, throw some errors in it, and ask them to fix it. This will be a much better gauge as to whether or not they actually know how to read and interpret the code.
That's crazy, and it is a big red flag for the interviewee that this would even be given as a test: * It is a maze of nonsensical letters. Would you really want to see code like this in your codebase? I certainly would not. * You're giving it as a test. Is this something you really think is effective at gauging candidates? It doesn't take much thinking about the problem "from someone else's shoes" to see the flaws in this test. It should be immediately obvious. That is a red flag on the part of the management here. It says they don't make much of an effort to see things from their worker's perspective. Long hours, weekend work, and unrealistic deadlines are going to follow. * Why, exactly, are we caring about the speed of a javascript function? Javascript is insanely fast. All the slowdowns in the browser are DOM related. Another red flag. Just what are we doing here? I'd consider reworking your example by eliminating it altogether.
Both answers are O(n), so not right. Correct answer would be O(log(n))
The code was taken from real life problem. It was buried in some contractor code we used to normalize genetic information (Human Genome Project). In that case it was written in PHP. When the code was replaced with an optimal version the run time for the normalization went from 8 days to 3 hours. This pattern is very useful when removing duplicates from LARGE sets. 
Uppercase with underscores
A common answer, and a lot closer. But complicated. I give a partial pass for this. The full answer is much simpler. But definite bonus for doing the efficiency comparison. 
lessmilk.com is my pet project, hope you'll enjoy it! Let me know if you have any questions about it :-) I'm also looking for feedback on how I could have improved my games, or how I can promote my little project to more people. Thanks! And FYI, you can look at html of the page to see the javascript code.
JS nooblet here-- can anybody tell me how someone's supposed to call this function once it's defined? That C parameter doesn't go into A when you call A. So the best way to optimize this function to do what it's doing right now would be... to delete it? Edit: OK OK, A.call(whatever);, but then B's still an empty array anyway, I guess idea being there'd be something there. Even though I'm unqualified to say so I'm guessing this is some pretty yucky style.
1) Maze: Not all real world code is clean, certainly not when you are using external libraries. There are only a few variables here, and it's simple enough to just rename the variables as you go. This shouldn't tax a professional programer. 2) Effectiveness. So far the test has never returned a false positive. Against the people who i've hired, and my smaller set of professional friends: Not one top programer has failed to identify the problem in under 2min. However, and this is the rub, my results are much more mixed in the "negatives" set. I'm worried the filter may be too tight. 3) speed matters. network time especially. This pattern is used in real world settings to reduce network traffic (similar to a bloom filter, but optimized for computation over memory). 
Optimising the code is dependent on figuring out what it's supposed to be doing. Because you've used single-letter variables, it's not obvious what's going on, so that could turn people off. If all you care about is getting people to optimise it, the code could possibly be written a little better, with descriptive variable names, and a comment or two. From what I can tell, it's a function that will return if it's already been called with the argument you're now passing it. You could explicitly state that at the top of the question that that's what it's does. Naturally, I'd assume you'd want my answer to mention binary searches, because that reduces the complexity from O(n) to O(log_2(n)), which results in a speed improvement for sufficiently large n. Of course, that relies on the data being structured or sorted. Fortunately, when performing a binary search, if we get to a null node (i.e. we didn't find what we were looking for), we can insert or splice the item into the structure at that point, and the data remains sorted.
1) it is the only technical question of the entire interview. The rest is just getting to know one another. 2) asking a programer to work through actual (real world) code, is not an unreasonable request. The snippet is small, and should take no more than 5min.
&gt; self-executing functions ... need to be wrapped inside braces like so: &gt; var five = (function() { return 5; })(); Not always true. You have function *declarations* and function *expressions*. Only function expressions can be immediately invoked. If you have something that looks like a function declaration, you need to wrap it in parentheses (or prepend a `!` or `+` or somesuch to it) to turn it into a function expression, prior to immediately invoking it. `var five = function () { return 5; }()` is already a function expression, so no additional parentheses are required.
1/1000ths of a kilobit, what a peculiar unit.
After reading all your reply's, it is obvious you are just looking for validation and not getting it. Most everyone in this thread is saying it is a stupid question, you might want to really think about that.
I just wanted to jump in and say that I have published a module to npm called "promise-it-wont-hurt" that is an interactive CLI workshop teaching the use of promises through code challenges. It is currently hosted (or really just promoted) at http://nodeschool.io. It can be installed and run using npm install -g promise-it-wont-hurt Sorry if this is shameless but the whole purpose of writing that module was to give people a painless and powerful way to teach themselves javascript promises. I can be reached on twitter @stv_kn if needed. Cheers
I didn't take it as you being condescending, truly. No offense taken, I honestly am not smart enough to make a multiplayer game in the browser, I said that mainly to let you know I might not know what I'm talking about, and to take what I say with a grain of salt. :) We're all good!
I was wondering how you like Phaser compared to other frameworks and why you picked it
https://github.com/stevekane/promise-it-wont-hurt/blob/master/tests/always_async.js This file is a solution (spoiler alert) to one of the early workshop modules. It shows the always-async nature of promise resolution and might give you insight into how they work. it will always print "FIRST" "SECOND" because the functions registered w/ .then are NOT called until the next turn of the javascript event loop. This is a very important aspect of promises for making their behavior deterministic.
Hey thanks! Looks nice a nice project.
Good question. I looked at a lot of frameworks, and tested a few. AFAIK the 2 best frameworks for 2D games in html5 are Cocos2d and Phaser. They are both actively maintained, have good documentation, work well on all modern browsers, are free, and are quite easy to use. Cocos2D is better if you want to do multi platforms, but Phaser seems easier to use for me. So I picker Phaser. And did I mentioned that www.phaser.io website looks super cool? :p I plan to write a more detailed answer to that in an article in my blog soon.
Hopefully this will come off as more "practical" advice. &gt;it's simple enough to just rename the variables as you go. You can't rename a variable if you have no idea what it's trying to do in the first place. The names of the variables help the interviewee understand what the code is supposed to be doing. Thus, one of the issues with your test is you're expecting your candidates to do two things simulataneously: to figure out what the code does, and then optimize it. This is not your intention. Your intention is just the latter part of that. The former, however, is not to be trifled with. What you're doing is ensuring you only get candidates who already know what this piece of code is supposed to do. IE you're choosing candidates who already know about network optimization and bloom filters. This is also probably not your intention, since the concept is not complicated for someone to learn, and you would not want it to be a gating requirement. However, due to the way the challenge is laid out that's exactly it's doing.
That looks pretty nice! I think I've seen the name but never looked into it.. I'll have to give it a spin.
Yeah, when you're actually exposing a module. In the give code example this introduces a really unnecessary overhead. Ideally this should be an extra module called "Set", as it is mimicking the functionality of such.
Perhaps you could explain to the interviewee what the code was intended to do and ask them to write a function to do it. Good code is not only fast but also understandable and maintainable. I would say your contractor who wrote this function was a poor coder. The fact that no other programmers can fix it is not a sign that all programmers are terrible, it's a sign that the original code is terrible.
This is a comment so you know we have laugh, nod and smiley about this. *insert internets macro here*
&gt; 2) asking a programer to work through actual (real world) code, is not an unreasonable request. The snippet is small, and should take no more than 5min. This is *real* code? Used in production? Wtf?
You should find better contractors if they're naming things like A, B, and C. Also, you need to be more specific than optimal and have something to actually test it against rather than just saying the phrase, "optimal".
Very close but simpler. 
&gt; Correct answer would be O(log(n)) Hahahaha what. No it's not. You told us *nothing* about what B is. Is it an object? Is it an array? Is it a sorted array? Based on your response, I can tell you mean for B to be a sorted array and for us to implement binary search. There's nothing wrong with being ignorant about something... but holy crap you are arrogant. To ask an ill-posed question in real-life interviews and then go on about how professional programmers can't answer it. And then continue to defend yourself when people tell you the question is awful. Also: How big is B? If it's small enough, then binary search might actually be slower than simply iterating over the array. Modern CPUs are very fast at iterating over arrays. Furthermore, if the size of B doesn't grow much, then "O(log(n))" is completely meaningless in this context. Either way, not only is O(log(n)) the wrong answer to the question you asked, it's a completely meaningless answer too.
Several programmers have solved it. It's a common pattern in most languages. 
Binary search is possible, but a complicated solution. But seeing that the parameter does not need to be a primitive is one of the the things i look for in candidates.
 var a = function () { var b = []; return function(c) { var i = 0 while ( b[i] !== undefined ){ if ( b[i] === c ) return true; if ( b[i] &gt; c ) i = ( i &lt;&lt; 1 ) + 1; else i = ( i &lt;&lt; 1 ) + 2; } b[i] = c; return false; } }();
dojo dgrid
An entire article about "scope" and no mention of closures? That's ridiculous. Ignore this article and read about [Closures on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures) instead. &gt; {returnTrue = true;} Nobody ever, ever defines a block for no reason like this. All this does is declare `returnTrue` in the global scope, which is exactly what this article says **not** to do at the bottom. &gt; What it means for our returnTrue variable is that it is in another scope, which is not the main scope. In fact it is a sort of "lost" scope (which we usually call anonymous scope), in the middle of nowhere, that is not actually used. So, javascript can't find our variable in the main scope. Javascript is sad. **NO!** `returnTrue` is global, the braces just confuse the issue and have absolutely nothing to do with scope in JavaScript. **JavaScript is not block scoped,** and this entire paragraph is misleading. &gt; In most of the cases, a javascript scope is some code contained in { } That's just flat out wrong. Completely, totally misleading. "Scope" is dictated by closures, which are created when a function is executed. This is a **block**. &gt; javascript Am I the only one who is bugged by seeing "Javascript" and "javascript" in articles? It's [**J**ava**S**cript](http://en.wikipedia.org/wiki/JavaScript). tl;dr: What the fuck, OP? 
Change b to a hash. Seems like an easier answer just to do if (b[c]).
I'm going to assume that the insight you would like your interviewees to have starts with initializing B to an empty object rather than to an empty array ... If that's the case: &gt; Is there a better way to write the test? 1. "Rewrite the function below for optimal speed performance:" This could be restated as "Here's a hot spot we found in our code a while back. Let's see what it's doing and see if we can do something about it." This is much more inclusive and tends to invite a conversation and lateral thinking rather than a desperate mental surge to understand the code in its entirety exactly as written and find some "optimal" solution... Since they don't have access to the rest of the source you should provide context (at least in the form of decent variable names and / or what types we can allow C to be). Using a hash map here only works if C is or will be coerced into a (unique!) string... &gt; Am I doing something unfair to trip up the interviewees? You're expecting the interviewee to: 1. Decode random tokens without meaning or context. 2. Arrogantly override the judgement of the original author (let's keep these in an array) without any knowledge of the types involved. Good engineers want to understand the problem *completely* before doing a rewrite, and then only rewrite reluctantly. You haven't given them enough information to know whether that's safe in this code base, and you're doing it in a context (interview) where we all know to keep our little arrogant mouths shut. &gt; How much time should I allow to solve the problem? How about talking through the problem with them, leading them to the solution if needed, and judging them based on the entire process? And don't forget that since this is your go-to interview question you are intimately familiar with the problem and comfortable in the space in which you are working, whereas they are neither. And you could learn something from them. After all, *if* this is actually the solution you're looking for it's not doing the same thing that the original code is.
What's your answer? The only obvious answer I see is: alert('I don't want this job');
If this is the expected answer, I don't see anything unfair with your question. Giving more descriptive names could help, but I don't see it as a problem. Maybe specify that the elements are comparable, but again it should be taken for granted IMHO. It took me ~5 minutes to write.
Cool! I found one bug you might want to be aware of for the future. I'm playing on Firefox and it hangs for about half a second about once every 10 seconds. Not sure why, garbage collection maybe. But when that happens, you can fall through the floor. I suspect this is because you're using a variable timestep, and when it hangs you drop enough in one frame to fall through the floor. You should probably limit the maximum timestep to something like 0.1s.
Correct
Correct
Thanks for reporting it, I was not aware of that. I'll look into it!
This is what I started to type out but then I had the same concerns you did (is C a string or a number or an object with a unique toString()?) I don't know if asking about the type of C is part of the test or not. If it isn't, the interviewee should be told "C is a string" or "C is a number".
I've got this feeling your game has been inspired by a certain vlambeer game about boxes ;p
That's because you are right! :-) I was inspired by Super Crate Box for game #4.
I'm not sure I understand. Should I be posting a picture of Xzibit?
Javascript objects are not hashtables. Some strings can collide. Even with a prototypeless object, you still cannot avoid "__ proto __".
Do you make the music yourself? It is excellent!
I'm not one to be overly-dramatic but I was really excited to start learning JavaScript and then I saw the ratings for the book. Should I just suck it up and deal with it or should I find somewhere else to take it over the summer because it seems I'm already starting in a deep hole by using this book. Any advice from a professional would be great. I feel demoralized right now. ;(
&gt; I didn't mention closures because they are a most advanced and tricky thing to use, that is actually rarely necessary, so I don't want to confuse people with it while I'm only explaining how variable access works. ... the whole point was to understand what happens when you are looking for a variable. No. Closures are intimately involved in how variable lookup works, and they are *constantly* necessary. Your article is incomplete and misleading without them. &gt; Of course I know putting a variable in a block has no use, it was an example of the behaviour of scopes and variables, I never said people should do it, I said it can generate errors, which is an incentive to not do it... Wrapping an assignment statement in a block does not modify the behavior of the assignment statement, so it's a useless example. Furthermore, it actually can't generate errors, it's just a block, it effectively does NOTHING. &gt; Although I may have put it in a function so it is more "real" code, yes, but I would then need to explain closures. The point was that there is some code in a lost block, it gets executed but the variable isn't accessible anywhere - unless it is global There was no point here, it was nothing but a reflection of your own misunderstanding and serves to do nothing more than confuse the reader. &gt; Also, I thought there were cases other than functions that produced scope, but it turns out there aren't any, so I can actually replace my general {} case by functions. Good, you're learning about closures. &gt; calm down. You should expect to be grilled whenever you publish anything online. This article was so misleading, I could never recommend it to anyone who is learning JavaScript. Do yourself a favor and completely rewrite this article to focus on closures as scopes. You quickly changed a few things in response to my scathing review, but it's not enough. You need to do your research and write quality material if you want to contribute to the community.
Hopefully this gets enough interest (although it seems not), I believe that aside from learning this project can bring some interesting uses, the main concern is performance I guess.
I saw your previous post about your weekly games, and I've been checking periodically to see your next. I saw this last night, and I really enjoyed not only the game itself but also seeing your progression. After seeing your first post, I actually decided to give Phaser a go, but there are still some things I'm not sure of. Is your source code available? I'd like to take a look at it to see if it will help clear things up. That said, the biggest thing I'm concerned about is structuring a project. Is there a general structure you've employed for your games? I'm used to frameworks like Backbone and AngularJS where I can intuitively break up my code almost like I would a Java project, but this doesn't seem very straightforward with Phaser, and there doesn't seem to be a general guideline for how to organize things.
Thanks for the advice. I am going to try and suck it up and just get through it. I look forward to what other people have to say. Also thanks for the book recommendations. I'll add them to my wishlist and purchase them after I pay my mortgage. Edit: Apparently you can rent on Amazon. Rented each of them for the semester and spent less than $30. :-)
Nice, I'll probably start playing with this. It would be a good idea to register on bower btw.
Sweet thanks! It seems great for action games. Im building a puzzle game like Clash of Heroes. Did you use any tutorials besides the official Phaser intro? Its a pretty awesome example of the physics that comes loaded with Phaser with such little code. Cant wait for future games, keep it up!
Thanks for your support! You should register to my newsletter to not miss my next games www.lessmilk.com As you said there is no guideline on how to organize code in Phaser. I'm still trying to figure out the best way to do it actually. Here's an interesting tutorial about this subject: http://toastedware.com/?p=258 As for my source code, you can read it by looking into the html.
See, and what's bad is I don't even know why that's bad. Just the horrible HTML?
Thanks! You should register to my newsletter to not miss my next games www.lessmilk.com As for learning Phaser, I think the best way is to go through the examples: http://gametest.mobi/phaser/examples/
Oh, my sarcasm detector is in need of repair again...
The Good Parts is a terrible beginner book, while it is a fantastic book that all JS/Front-enders should read, it definitely assumes you have a pretty good overview of the language and is not suitable for an introduction to JS. Years ago I found DOM Scripting to be really helpful, but I'm not sure how well it's been updated throughout the years http://www.amazon.com/DOM-Scripting-Design-JavaScript-Document/dp/1430233893
Mobile using the tilt sensors! https://developer.mozilla.org/en-US/docs/WebAPI/Detecting_device_orientation
From what I can read in the example pages, this book is outdated and overly complicated for something as simple as JavaScript. I have to concur with iends advice to read "JavaScript: the good parts" as well as http://jsforcats.com/ - it is that simple, really. Also, it could be a good idea to frequent /r/learnjavascript from time to time.
Because [#onegameamonth](https://twitter.com/OneGameAMonth) is not enough :)
So much class and culture in that post.
I just subscribe to /r/learnjavascript this week due to my classes starting. 
Already subscribed :D I'll dig into the html to find the code. I wasn't sure if you had it hosted anywhere. Thanks for the reply!
`document.write` shouldn't be used to display content on a page. For one, if the page is already loaded (which is a lengthy concept in and of itself), `document.write` will replace all the page content. If you need to update content on a page, you should be using `document.createElement` to add new nodes like `&lt;p&gt;`, and then `&lt;element&gt;.innerHTML` to update it's text, for example.
That makes perfect sense. This is gonna be a hall of a semester.
Phaser, huh. I had never heard of that. Maybe I'll have to give that one a try.
After (briefly) looking through the book, I get the impression that it's goal is to, specifically, teach JavaScript. This means the DOM API and HTML are minimally focused on, along with "good modern practices." To me, that's fine when teaching a language. There's no point in bogging down new-comers with details like module loading, what the difference is between `element.nextSibling` and `element.nextSiblingElement`, why `document.write` is, in general, bad practice, etc. It is good that you are aware that the book might not be that great. It will probably teach you the core of JavaScript, which is great. You'll understand how it juggles types, how closures work, etc. Along with the other recommendations for this, I'll add my voice and say buy JavaScript: The Good Parts. You might also want to look into some material on modern best practices and the DOM API. I would also say to stay in the class unless you feel prepared for something more advanced and up-to-date; in which case, find a different JavaScript class.
Overpriced, too. You should be able to get a quality beginning JavaScript book for half that.
Hey lessmilk, how advanced a developer are you? I love your pixel art!
I think as long as you keep in mind what is generally considered not to be "modern," you'll be fine. As I mentioned in my other post, the point of the class is to teach *JavaScript*, not web development. Don't be afraid to challenge your teacher, or research with him/her either.
Don't sweat it. Literal step by step "how to write this language" is not unusual in an academic setting.
Just wanted to let you know that the full course is now available. We released the last 3 levels today. 
Isn't "Clash of Heroes" pretty generic? I would pick a different name.
Haha, got it. Cheers!
At least once I've been bitten by not properly requiring d3 in a given page. The fix is to do something like this: &lt;script charset="UTF-8" src="d3.js"&gt;&lt;/script&gt; IMO no mainstream JavaScript library should be limited by character set.
Very cool. It's the kind of trick that only really works once, but it worked great here. It's a neat way to show something artistic that can't easily be replicated in a traditional (non-digital) medium. I wish they had included something to black out the top-and-bottom of the screen, since I could see a sliver of the other videos.
Of course this would never be chosen over the underscore version (especially since I didn't default to native `reduce`). I'm just working on reimplementing some of the underscore functions as a way to improve my JavaScript. Any feedback welcome! One thing I like about `_.reduce` is the use of `_.each` to generalize the iteration over the object/array, helping to bypass the `keys` variable and the `obj[keys[i]]` nonsense.
I hope you don't mind another question, but are you unit testing any of your code? If so, what are you using, and how do you find unit testing with Phaser? I realize the projects are quite small, but unit testing is a big priority for me so I'm curious how others might handle it.
Looks like it has been [supported in WebKit since 2012](https://bugs.webkit.org/show_bug.cgi?id=88526), but it hasn't found its way to Safari yet.
This really helped thank you! What's the difference between say `return deferred.resolve('foo')` and `return when("foo")` 
I usually use Underscore/Lodash's `_.extend()` for this, and I'm fairly sure Lodash has most of their modules available as separate pieces on npm, if you don't want the whole thing.
yes that is true. I usually use lodash. But, in this case, I wanted something smaller for a client side sdk.
If you've got [Lodash](http://lodash.com/), you can do `var obj = _.cloneDeep(someOtherObj)`. Or you can reinvent the wheel :)
Damn, I've never heard of phaser before, thanks for pointing it out!
Seems like a library might be overkill but neat none-the-less! function mix(obj, into) { Object.keys(obj).forEach(k =&gt; into[k] = obj[k]) } 
Just to throw it out there, there are other ways of making new instances, namely using an object literal. var point = { x: 4, y: 9 }; There is also no reason why you can't use this essentially build classes to: function movePoint( x, y ) { this.x += x; this.y += y; } function newPoint( x, y ) { return { move: movePoint, x: x, y: y } } var p = newPoint( 3, 4 ); p.move( 9, 2 ); This can result in objects taking less time to construct, and method calls that are faster. Although this is not idiomatic, breaks things like instanceof, only works when the object has very few properties/methods (when I did benchmarking that number was around 7), and I'd expect heavily depends on your overall code (in regards to how it will get traced). So it's not something you should do by default. But it helps to show further that what we think of as a class or an instance of an object, does not have to be idiomatic JS.
trying to figure out what this even does. is this basically the intended usage? &gt; y = new A() [ function ] &gt; y(1) false &gt; y.B [1] &gt; y(1) false &gt; y.B [1, 1] &gt; y(1) true edit: in other words, does your "for..in" give back values or indexes into D?
Oh thanks, and the difference with `return when('foo')`?
Not sure if you're still looking at this thread but do a project or something. For my high school senior project I will be doing a ton of work with JavaScript and that's pretty much my biggest impetus for learning.
Steam has a Web api http://steamcommunity.com/dev
very cool idea. i'm learning some ios development currently. is it ok if i borrow some of your ideas for an app (giving you credit of course)
If you are using jQuery try the $.extend() function.
Doesn't have identical semantics to your lib (will overwrite properties for example) but it works in a pinch!
and if you are using AngularJS you can try [angular.copy()](http://docs.angularjs.org/api/angular.copy)
Yeah I was referring to this game &gt;&gt;[Clash]http://en.wikipedia.org/wiki/Might_%26_Magic:_Clash_of_Heroes "Clash") . It was free on xbox during the holidays so we logged a lot of hours into it. 
If this was 2005, maybe... $100 for any book on JavaScript is criminal and your professor must have intentionally found the most expensive book possible on the subject. Why do college professors do this??? Do yourself a favor and grab any iteration of JavaScript: The Definitive Guide. The name speaks for itself. From there I could recommend any host of books, but that's what I started with and can't think of anything more succinct and accurate.
The videos from today were already uploaded. The videos from tomorrow will probably be also uploaded at the end of the day. There is also a live stream on their website: http://ng-conf.org/
I wouldn't - ever. It's essentially the EMCAScript spec in book form.
bluntm almost had it, but the syntax was a little off. Where db is your database, collection is the particular collection, and 5 is the id you are searching for: db.collection.findOne( { _id: 5 } ) mongodb is manipulated by passing json objects to its methods, so it would help to familiarize yourself with the syntax. Mongoose will ultimately be very helpful too, but be wary of abstracting mongodb too quickly without grasping core concepts. 
There is nothing about modules or package managers, which is the most important aspect of my own conception of "the right way". Also, this page seems to be about "here are a lot of ways" instead of "the" right way, as if such a thing existed in the first place.
The script causing the problem is in an iframe in the original link, it's located here: http://www.kaistale.com/blog/140115beam2d/ The source code is also browsable here: https://bitbucket.org/ksaksela/beamtrace2d As the script IS working, albeit slowly, I'm finding it difficult to pinpoint the problem. I'm not quite sure if this is the right place to ask questions, but I thought someone here might recognise the problem.
I wrote a similar (ES3-compatible) mixing library: [mixed](https://github.com/pluma/mixed) There's an [extension](https://github.com/pluma/mixed-mixer) that provides similar `mix(Foo).into(bar)` syntax. The main difference is that `mixed` is intended to be used with constructors rather than plain objects. Both libraries are published under the Unlicense and thus effectively Public Domain.
are you planning to share code on github at any stage? loved playing your games loving the simplicity and fun factor
I'm curious, where do you find the time? Are you studying or unemployed, or do you never sleep. I'm envious and all the more power to you!
If you are looking for more options, I wrote a website to analyze github and find related projects. Here is what it thinks is similar to Phaser: http://www.yasiv.com/github/#/costars?q=photonstorm%2Fphaser Hm... After rereading this for a second time I feel like I'm a spammer, but I know PIXI is good and fast, and Cocos2d is also among related. I just hope it is helpful..
Oh shit. I forgot to see "like" there. I'm sorry.
*The Right Way*? So if you don't obey, the you're doing it *Wrong*?
Keep it up!! :)
Oh please, the One True Way of doing things. Damn cultists.
Is your instructor's name "Don Gosselin"? Because if so, drop the class and take a udemy course.
How about asking the professor why he prefers to use this book and bring up the negative reviews? He might have an explanation as to why he chooses to use this book.
I clicked the book preview out of curiosity. [This book is so wrong on so many levels.](http://i.imgur.com/jiMuUVU.png)
This was the first thing I thought as well.
sup, skeptic bro?
angular copy is very heavy on the browser if used a lot. jQuery clone is good 
What about [Professional JavaScript for Web Developers](http://www.amazon.com/Professional-JavaScript-Developers-Nicholas-Zakas/dp/1118026691/ref=sr_1_10?ie=UTF8&amp;qid=1389972700&amp;sr=8-10&amp;keywords=javascript)?
Work for free. Your code belongs to them. Prizes given to their employees/friends. I hate this shit.
Whoa. That is awful. Wouldn't the Dom rerender after the first write, immediately closing the &lt;p&gt; and breaking the intention of the next the lines? (Sent from my mobile)
I'm also tossing in a $50 bounty for each round to make it a little more interesting, paid in Bitcoin. I mean, what's the point of playing poker if you can't win a little money?
if you have no programming experience: take the course! you can laugh about it later and you can still forget the most part if it is bad, nothing is set in stone, don't worry. if you really want to learn javascript, you yourself decide how much you want to learn. you have incredible resources at stackoverflow/mozilla developer network or other sites, you can download firebug for firefox or use the chrome web developer tools and start coding. you don't have to set up a server/compiler/ide ..., it won't get easier than that :) don't blame others, it's time to take matters into your own hands ;) 
Some mixed-matched advice; you could certainly do it like that, but usually you see one or the other (either purely DOM methods, or purely `innerHTML`), but I don't see both too often... Either: var para = document.createElement('p'), strong = document.createElement('strong'); strong.appendChild(document.createTextNode("Today's special")); para.appendChild(strong); para.appendChild(document.createTextNode(": ")); para.appendChild(document.createTextNode("Buy a large meat lover's pizza")); para.appendChild(document.createElement('br')); para.appendChild(document.createTextNode("and receive a free Caesar salad ")); para.appendChild(document.createTextNode("and two liters of Diet Pepsi!")); document.body.appendChild(para); Or (more commonly)... document.body.innerHTML = "&lt;p&gt;&lt;strong&gt;Today's special&lt;/strong&gt;: Buy a large meat lover's pizza&lt;br /&gt;and receive a free Caesar salad and two liters of Diet Pepsi!&lt;/p&gt;";
Why? 
Does jQuery clone works on objects? I thought it only worked on DOM elements...
Thanks for the correction. I didn't realize innerHTML isn't a "real" DOM API construct. Of course, createTextNode would put my example in the same realm as createElement, but what a pain! Unrelated to your response, I checked out innerHTML here http://www.quirksmode.org/dom/innerhtml.html What I got from that is "just use innerHTML when you can." Anyway, I learned something new today, so thanks! 
http://wicky.nillia.ms/enquire.js/
That would be a better choice over *Javascript: The Definitive Guide*, but it's still going to (potentially, depending on who you are) be a heavy book of reading. No doubt Zakas is going to deliver a thorough book, but based on the OP's request of "Javascript for beginners" and something that is "logical and easy to follow", I would still suggest *Eloquent Javascript*. Give Eloquent Javascript a read, too, if you'd like - it has a free online edition.
You should crosspost this to /r/poker.
Thanks a lot for your answer &amp; time! I've tried having it both off and on. The FPS is still slower on Firefox, at least on the couple of computers I've tested, even when Firebug's off. I also tried comparing the CPU profiles from Firefox (with Firebug) and Chrome, but I really didn't get that much wiser from it. The problem might lie somewhere in the functions rayTrace, lineIntersection and/or inFrontOf, if I'm interpreting the profiles correctly. It's strange, apparently there's nothing obvious I'm doing wrong? I'm relatively new to (advanced) JavaScript, so I thought there might be something obvious I'm missing. Something that Chrome and Safari are able to correct through optimization.
In my experience, it's those coming from arguably "better designed" languages (*cough* Java *cough*) that used the pure DOM methods; although exceedingly verbose, those devs were used to that baggage and felt more comfortable using methods for everything. Most everyone else, myself included, used/use `innerHTML` exclusively, just because it's so much easier to write and work with. The DOM methods paradigm really highlights the power of jQuery, since you can do `$("&lt;any valid html&gt;")` and it just _does the right thing_ to create the HTML you want.
Hi, I'm just a beginner programmer, but I've been having some fun with this. However (and this may be because of something I did wrong), I'm getting an error when my bot is being evaluated after a test, specifically at the email checking. I have the email property set, but I get this error: TypeError: Cannot read property 'length' of undefined at Context.&lt;anonymous&gt; (/root/JsPoker/test/challenger_test.js:52:31) at Test.Runnable.run (/root/JsPoker/node_modules/mocha/lib/runnable.js:194:15) at Runner.runTest (/root/JsPoker/node_modules/mocha/lib/runner.js:358:10) at /root/JsPoker/node_modules/mocha/lib/runner.js:404:12 at next (/root/JsPoker/node_modules/mocha/lib/runner.js:284:14) at /root/JsPoker/node_modules/mocha/lib/runner.js:293:7 at next (/root/JsPoker/node_modules/mocha/lib/runner.js:237:23) at Object._onImmediate (/root/JsPoker/node_modules/mocha/lib/runner.js:261:5) at processImmediate [as _immediateCallback] (timers.js:330:15) I looked in the challenger_test.js file, and that line is the email verification. Like I said, I'm a complete newbie so I don't really know how to troubleshoot it any further than that
http://www.codecademy.com/ isn't a bad place to start. You will want to learn about HTML/CSS first, or else many of the reasons for using Javascript won't make sense.
Perhaps surprisingly, my background is in OOP PHP and C#. Admittedly, there is a certain appeal to the verbose way, and you would think that the "lower level" DOM methods would provide more power and speed. Ironically, innerHTML is faster. Perhaps this is because it (presumably) uses the browser lexer and parser instead of (sort of) reimplementing it in JavaScript. Regardless, being used to a certain way of doing things, or having the knowledge to over-complicate things is not an excuse to write inefficient code, or to refuse to adapt to an entirely new ecosystem. I *really* don't like JavaScript as a language, but we're stuck with it, and so I take the time to learn its idiosyncrasies. It's powerful, it's everywhere, it has *some* nice features, and I might as well be good at it regardless of my background. So, as a result, now I will be using `innerHTML` more. jQuery's selector is great as long as you use it efficiently. For example, the selector '#container &gt; div' is slower than $('#container').children('div').
Hit me up with a gist, I'm happy to take a look, but it seems like the email not getting set properly on the player, while the challenger.name must be working.
I had to check the date on this to see if it wasn't from before the rise of JS MV* frameworks. This isn't bad advice at all, but we already have tons of projects in the community that provide a view layer much more versatile and well-known. Use one, don't reinvent it unless you have to.
Just saw this link via Twitter (can't vouch for every link on it, but seems legit): http://jstherightway.org/ BTW: whoever told you to start with JS deserves a high five, +1, upvote or whatever relevant "F*@$K yeah!" is appropriate!
[Here you go](https://gist.github.com/HandmadeMercury/1ab5d7056b98457eae0a) If you need the whole file, I have a fork of the project on my account
Also contains a brief but nice overview of techniques for implementing "private" object properties.
I am so happy that this giant list of bikeshed colors is getting the panning that it deserves here. Compared to the zealous gushing [over on HN](https://news.ycombinator.com/item?id=7074307), the reaction on r/javascript seems so much more level headed.
Is it cheating to require('hoyle').Hand, to find the rank of your current hand? (required changing the package.json to add dependency)
Looks like it's against the rules https://github.com/HandmadeMercury/JsPoker#rules
Looks like this should be `playerInfo`. (also need to call `done()`) it("should be your own bot", function (done) { assert.ok(challenger.playerInfo.name !== "Nameless Challenger", "Start by naming your bot"); assert.ok(challenger.playerInfo.email.length &gt; 0, "Give your email address"); assert.ok(challenger.playerInfo.btcWallet.length &gt; 0, "Where should we send the money?"); done() });
Ah I see, thanks.
This is an outstanding answer. Every technical interviewer should read it. I'll just add a couple of things: Calling it "our code" puts the candidate in the uncomfortable position of criticizing *your* code. You could call it "code we found in a third-party library" or "code from a contractor who's not working with us any more" or the like. I would even add, "As you can see, it's a bit of a mess" to encourage criticism. A seasoned JavaScript developer should notice a couple of WTFs in the code right away - even before thinking about what the code actually does or what would be a better way to do it. These are: * The accidental global variable `D`. (Ironic since the code goes to so much trouble using a closure to hide its internal state.) * The inappropriate use of a `for..in` loop on an array. 
I use a different more efficient, but more verbose approach. You can check it out here: http://javascriptweblog.wordpress.com/2011/05/31/a-fresh-look-at-javascript-mixins/
Well, the rules don't keep you from just copying all the code into one file and using that. It'll be a giant mess, but it should still work.
But you could determine the rank by yourself ;)
update: I stumbled upon this: http://jsfiddle.net/sqnXM/29/ seems with some code additions I can achieve what I want in raphael! Any thoughts on that? Could imagine this would render well on iphone, etc too eh?
I hate the title of the article. This is more about design patterns than anything else. I think it's helpful to the person that needs to know how to write testable js. It certainly would have been gold to me 3 years ago.
Well I ended up writing a smaller version of ranking it. https://github.com/mdp/JsPoker/pull/2
You could try the clone function in https://github.com/metabench/jsgui-lang-essentials/blob/master/jsgui-lang-essentials.js The clone function uses other functions from that same library (x_clones, fp and tof) so you would not be able to simply copy that single function.
Hey, try highlighting a portion of text. They have a pretty interesting text-reader that I've never seen before.
A `documentFragment` is an element that is more like a holding bucket than anything; when you insert it into the DOM, it fully disappears, and its contents are emptied into wherever you placed the `documentFragment`. Your example doesn't illustrate its power too well, so let me offer a different one; let's say in have a `&lt;select&gt;` already on the page somewhere, and it already contains 100 `&lt;option&gt;`'s. Your task is to append 100 more `&lt;option&gt;`'s to it. There are a couple of ways to solve this problem; you could of course build the HTML as a string for all 100 options, and then use `selectElement.innerHTML += optionsHtml;`. Which is fine, though you're back to using strings (there are many heated debates about whether or not using strings of HTML is categorically _good_ or _bad_), and so for sake of argument let's say you can only use the DOM methods. Using the DOM methods, you'd have to do one of the following: * remove the existing `&lt;select&gt;` and `&lt;option&gt;`'s, recreate, then add back (or, clone the existing, add new, remove old, then append new). This is inefficient as you're having to recreate those other 100, as well as possibly having to re-add event handlers, re-set the user's prior choice, etc. * append the new `&lt;option&gt;`'s one-by-one to the `&lt;select&gt;`, which sucks for performance since the browser will repaint+reflow for each item. * append the new `&lt;option&gt;`'s to a `documentFragment`, and when complete, append the `documentFragment` to the `&lt;select&gt;`. This method incurs only 1 repaint/reflow, and when you append the fragment, it disappears and only places the `&lt;option&gt;`'s into the `&lt;select&gt;`. edit: found some more jsperf tests [1](http://jsperf.com/appendchild-vs-documentfragment-vs-innerhtml/15), [2](http://jsperf.com/appendchild-vs-documentfragment-vs-innerhtml/24)
I believe this way will provide more accurate results: (function(){ var differences = {}, ignoreList = (prompt('Ignore filter (comma sep)?', 'jQuery, Backbone, _, $').split(/,\s?/) || []), iframe = document.createElement('iframe'), count = 0; ignoreList.push('prop'); for (prop in window) { differences[prop] = { type: typeof window[prop], val: window[prop] }; count++; } iframe.src = 'about:blank'; iframe.style.display = 'none'; document.body.appendChild(iframe); iframe = iframe.contentWindow || iframe.contentDocument; for (prop in differences) { if (prop in iframe || ignoreList.indexOf(prop) &gt;= 0) { delete differences[prop]; count--; } } console.info('Total globals: %d', count); return differences; })();
Clever technique! This could be implemented in ES5 by giving each instance its own unique ID: var SomeClass = (function() { // We'll store in an object to be as light as possible var privates = {}; // Each instance will get its own ID var nextId = 0; function SomeClass() { // Store a non-writable property called _ // This will contain our instance's ID Object.defineProperty(this, '_', { value: nextId++, writable: false }); privates[this._] = { // Private stuff here privateString: 'This string is private!' }; } SomeClass.prototype.destruct = function() { // Cleanup after ourselves delete privates[this._]; }; SomeClass.prototype.someMethod = function() { // Get a private variable var privateString = privates[this._].privateString; console.log(privateString); }; return SomeClass; }()); [Gist here](https://gist.github.com/lazd/8481583). ~~The author doesn't cover it, but you would want to do a `privates.delete(this)` when destroying an instance.~~ As /u/radhruin said, the WeakMap technique doesn't require manually cleaning up references on destruction, see [WeakMaps on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap) for more info.
What's the point of it?
The point of using a weakmap is that you don't need to remove the reference. If the object you attach privates to goes out of scope and would otherwise be collected, then it will be collected along with the private state. The weakmap does not hold a reference to its contents.
Well, it's an open source project. I was hoping that people would help me to improve the guide and contribute, to help other people, like it helped me when I started. But it seems that people prefer to complain instead doing something about. That's really sad.
How does this compare against jRespond performance wise? https://github.com/ten1seven/jRespond 
No clue. But it would be helpful if a browser threw that in as a default feature. Oh wait they totally are.
This is not an easy question to answer. Popularity vote would still likely go to Express. There are a handful of extensions to Express for other niche use cases (Sails, RESTify, Kraken [paypal's new thing]). Personally I have been more and more impressed with Hapi.js from WalmartLabs. Eran Hammer is a fucking hero over there, and I've looked in to a few example apps with how things are structured and am really impressed with it. I believe in regards to the points of MVC, ORM, and "full stack" you may enjoy Sails.js the most. It's new however, but from what I've *heard* that it's supposed to deliver it may be more in line with what you're looking for.
I don't know of any single framework that does it all, but here are the bits and pieces I use and am really happy with: * MongoDB * node.js * mongoose (object mapper/CRUD) * express (web server/api layer) * AngularJS * Bootstrap
You're going to get downvoted for your btw: but I looked through this site and I must say it would be a good teacher. Wish I'd had this at my disposal when I was starting out.
The more important question, of course, is whether you want a full-stack web framework for node.js in the first place. You can write Java in any language -- the same is true for frameworks.
Thanks for sharing! Been trying to wrap my head around this sort of thing, the replacement of done/fail with ok/cancel cleared up extend for me as well. You rule. :)
I don't think people are so much complaining as they are voicing their opinions. I tried to relay things that stood out to me as inaccurate, which is arguably contributing back to your open-source project. Now that you're armed with that information, it's up to you to do something about it. One thing that might be turning people off from contributing is that your name is plastered all over the site. It looks commercial, minus the ads. The other consideration is there are already a *ton* of JavaScript guides out there. Why not contribute to those instead?
I'd say just try to convert some decent examples back into vanilla javascript, it'd probably be a pretty good learning exercise.
I ended up getting Eloquent Javascript. Thanks!
just put it in jsFiddle and post the link.
I think most people are going to say its silly to not use a library if you are going to write a lot of JavaScript. It may not be jQuery, but they'll use something.
Thanks, that's very helpful.
You might want to upload all the files, just so we can see the error happen in action.
It will be a little bit to get it up and running (the html index/output module works through folders so I'll need to edit things a little to make it work on the site). 
That's a whole lots of repeating code and one long if/else What if you stored those things in something with an index like an array and then use the random number to select it from the array. (I'm also new to programming but it seems like there has to be an easier way to get the behaviour you're looking for. 
Get to know why people use JS Libraries now a days. Back in my day, there were no frameworks for JS and JS was the devil! =)
Right on, I'm glad you liked my post. Thanks for the feedback!
I agree. Maybe you or I should blog about that, too.
My three points are nit-picky. First, Typedef has nothing to do with typing (low level or otherwise) so the name is confusing. Second, your use of underscores is inconsistent. Last, you don't have any docs or examples on how to use it, so I would have left the project if I stumbled on it. But, those are minor. You have passing tests, your code is clean, and great comments in your code! I'd say it's pretty good. 
Naming is tough. The name typedef has a long story behind it, but it is a misnomer. Any suggestions on expanding the examples in the README to provide better docs / usage? Any particular examples of inconsistent underscore usage? I try to follow the convention that prefixed underscore implies non-public, and postfix underscore is simply when using something that would otherwise be a reserved word (e.g. extends_). Thanks for the feedback
It's pretty fun and I enjoyed some of your sourcecode :D cookieFunc = function (x) { /* Spells out: cookie */ But still, the idea is unfortunately impossible. A client always controls the JS engine - could easily trace it or strings the interpreted file to get any idea of functionality / hidden data - but still a fun project :)
In [`extends_`](https://github.com/bvalosek/typedef/blob/master/lib/extends.js#L15-L19), why does the parent override the child? It should be the other way around so the child can override methods of its parent. 
Because in my code I had typically been calling extends_ before setting any static members. You are correct that statics would get overridden if extends_ is called afterwards. I've fixed that in [this commit](https://github.com/bvalosek/typedef/commit/69a6ab29719e9ea04b603010639c7f5e9b15be83)
For infinite scrolling, it looks like it only handles 1 identical height for each element? If so that feels pretty limiting considering that most lists have items of variable height. Overall very awesome work though.
Use [parentNode](https://developer.mozilla.org/en-US/docs/Web/API/Node.parentNode)
JavaScript: document.addEventListener('click', function (e) { if (e.target.className === 'classOfElementToClick') { e.target.parentNode.remove(); } }); jQuery: $(document).on('click', '.classOfElementToClick', function () { $(this).parent().remove(); });
I've recently started a project with Meteor and can say it's absolutely fantastic as a full stack framework, however contains a lot of black magic. I ended up ripping it out and re-writing using a custom express.io / ember solution because I wanted more power. So ultimately I'd say try it out (also look at Derby) and see what you feel like. If you decide against it I'd consider rolling your own solution with express or hapi (this is really nice aswell)
That's not the case though. I've used iScroll4 before and it handles variable sizes without a problem. 
Next comes encrypted sections of code.... Bye bye open source.
Encrypted code is impossible unless you control a hardware TPM. Then again there's ways around that too.
There doesn't seem to be anything wrong with the code you posted here. Your function is a bit silly, trying to achieve a distribution ratio by repeating the same line over and over again, but it isn't wrong at all. I would guess that your problem happens in one of the functions that the one you posted calls. adjectivefem() adjectivemas() adjectiveandro() descriptorpre() generatenamem() generatenamef() androgenerate() generatedescriptorpost() descriptorpost2() generatesurname() generateregion() descriptorpost() 
&gt; why he prefers to use this book and bring up the negative reviews Yeah do that, professors LOVE that!
Didn't somebody else call this technique "currying"?
currying is splitting a function with multiple arguments into a series of separate functions, one for each argument
Hey, let's give that "make it chainable" idea in the comments a go. http://codepen.io/andytuba/pen/CoaGs var compose = function () { var fns = [].slice.call(arguments); var composed = function (result) { for (var i = fns.length - 1; i &gt; -1; i--) { result = fns[i].call(this, result); } return result; }; composed.push = function() { var push = [].slice.call(arguments); fns = fns.concat(push) return composed; } return composed; }; What other utility methods should we slap on our composed function? Tack on "failure" / "success" / "complete" callback queues, or is that getting too close to Yet Another Promise Implementation?
Nope, it'll keep on chugging along unless one of the sequenced functions throws an exception.
Having an issue with jsFiddle, some files won't index as resources for no apparent reason. Any idea how to circumvent (it's a js file, so I should just be able to write it's name then .js to index it, right?)
Right, I'm currently working on getting it to work on jsFiddle. It's taking a while though because I've never used the site and am having some issues. Also there are ~40 files in all, a lot of the functions that the main generate function calls call more functions as well. And I know that my coding isn't at all elegant, how would you suggest doing it?
Its ORM Waterline doesn't support object relations yet, so that's a huge downside. Otherwise it looks awesome.
Use C if you need pointers :) But, seriously, googles your friend. Plenty of places to learn (stay away from w3schools though).
While I think that it is important to have a good grasp on the fundamentals of any language, I think avoiding libraries is a silly thing to do. One of the most important things about programming is reusability. Pretty much any language has mechanisms for reusing code. Perhaps you write a function so you can call it multiple times. Maybe you encapsulate some state into a Class so you can create multiple objects of similar type. If your goal is a particular project, then I think you should just use jQuery... or any library that helps you succeed for that matter. A lot of time and effort has been put into making it a very good library that, as you point out, is pretty ubiquitous. If your goal is academic, though, I think a lot can be learned just by looking at the pieces of jQuery that you are interested in. http://robflaherty.github.io/jquery-annotated-source/ This is source code with the comments next to it. Or you could look at the source directly. Some of it is probably pretty dense and hard to understand, but if you really try to step through it things will make sense. Speaking of stepping through the code... you could (read: should) learn the basics of Google Chrome's debugger. It is absolutely fantastic (at work I spend a good portion of my day in it). Lets say you are interested in $.ajax and how it actually makes a request. In the console, you could type $.ajax And hit enter. It will print out the contents of the function, but more importantly give you a little link to click that will bring you to that function (make sure you're doing this on a page that has the normal, non-minified source code). You can then put breakpoints and step through the code and observe what is going on behind the scenes. If you're not familiar with debuggers then the last paragraph might not have made sense. Just work through a basic chrome dev tools tutorial and play around with it.
Get a book by Douglas Crawford called Javascript the Good Parts. It's a thin, compact book that's very easy to read through. It specifically talks about the language. It doesn't touch on DOM api's or frameworks. Just sticks to the language. 
Jquery is unavoidable, as it simplifies a lot of things that you would end up rewriting over and over again, such as dom manipulation or asynchronous requests. All that jQuery does you could do with plain javascript, but you'd better use your intellectual resources tu build something that has not been built yet... jQuery is just one of many libraries that just add a lot to javascript, without which you would find yourself losing time doing low-level stuff instead of being creative. Some argue that you are more creative when you do all from scratch but it is not my opinion. Programming is a lot like cooking. Sure you could do everything yourself when cooking a cake, right down to making your own butter from cream, but you could also buy butter, saving your limited time to concentrate on the cake. That said, it is still important to understand the basic concepts of the langauge that you use. So, trying to replicate some of jQuery's functionnalities with plain vanilla javascript sure is an excellent way to learn, but I would never do that in a real project. 
jQuery is slow compared to vanilla JavaScript, because everything in jQuery is a function that often points to other functions. Its selector system is substantially slower than using the native DOM methods. Just learn to write in actual JavaScript and you will be fine. The petty problems solved by jQuery are fairly simple and common, which means time spent learning jQuery could be better spent approaching the problems directly in the first place. Abstraction languages like this are most convenient for developers who are required to perform front end development, but are not front-end developers by choice and don't really care to be. Front end developers are extremely high in demand on the job market and sometimes there is a lot of motivation to demonstrate marketing potential opposed to engineering capabilities.
Sorry, seems I didn't read your comment properly. Still, I'm not quite sure what the problem is. If you're using infinite horizontal scrolling and the containers all have a set height to that of the window/wrapper then you nest iScrolls inside each that provide the vertical scrolling. Or maybe I'm misunderstanding you again.
I agree, as essential as jQuery is, it obfuscates JS for beginners. On the other hand, it hides you from a lot of DOM stuff, which isn't all that interesting from a JS perspective. So as long as you are learning JS in the context of web, you are stuck between a rock and a hard place.
I thought I'd agree with you until I started doing real projects that required IE8 support, Safari, Opera, Firefox and Chrome. I spent so much time writing code to handle one off cases that I found it easier just to load up JQuery and let it abstract those variances. If you find yourself in a situation where you only need to support Chrome and Firefox then sure... Drop JQuery and code to your heart's content. Since we live in a world where people insist on using IE8 (I assume XP users) for a better than 10% use case of our client's user base... Using some of the newer features just doesn't fly in production.
That's just one result, probably from an insanely fast machine. You'd need to run the same test on the same machine a number of times to have any kind of meaningful data.
with a sample size of 1 machine of unknown specs doesn't mean anything
Well, it's just a different API. You're still writing regular JavaScript. That DOM stuff isn't part of JavaScript. It's just something this particular environment (a browser) happen to provide. Node or Rhino, for example, don't provide this stuff, but they give you other things to play with. Supporting older browsers (IE8 and below in particular) is really inconvenient without jQuery, because many useful things are missing and because there are many horrible bugs you have to work around. If you want to learn more about the DOM API, check MDN's docs. Just add "mdn" to your searches and you should get the right page as the first hit. E.g. *mdn addeventlistener* leads to: https://developer.mozilla.org/en-US/docs/Web/API/EventTarget.addEventListener
I rarely identify cross-browser differences and when I do it typically comes down to differences in the rendering of form elements. Differences in DOM access between IE8&lt; and every one else take very little time to learn and identify. Perhaps it just comes down to experience. You won't find that experience wasting time with abstraction though.
I too am trying to learn JavaScript without resorting to jquery, and like you I'm finding it very difficult. One resource I'd recommend is Eloquent JavaScript it is one of the few resources I've found that actually deals with some of the things that people routinely use jquery for, but in plain JavaScript.
My personal problem with javascript is that it has many ways to do things (especially with objects and classes). JQuery helps that by doing things one way. [Another thing that helped me was this video. ](http://blip.tv/pycon-us-videos-2009-2010-2011/pycon-2011-javascript-for-people-who-know-python-4900851) - js for python users. 
Another good one is [overthrow.js](https://github.com/filamentgroup/Overthrow)...it doesn't have as many features as iScroll but it's good if all you want is scrollable overflow:auto on touch devices.
thanks, i missed that.
Consider the difference between: &gt; This seems pretty stupid, because ___ And: &gt; It seems like ___, what is the benefit? The first question I'm inclined to downvote as not contributing towards Reddit being a useful resource for learning, whereas I would answer the second question like this: --- When you know in advance that you want to compose `Math.round` and `parseFloat`, then of course you can write either `function(a){return Math.round(parseFloat(a))};` or `compose(Math.round, parseFloat)`. And there are benefits to writing the function, for example you can name the function by writing `function number (a) ...`. Performance may matter, although quite honestly I'd have to see a profile run before I'd worry about `compose` being slower. But what argument is there for `compose`? Well, what if you don't know in advance what functions you are going to compose? What if you want to make that decision at run time? For example, say you are processing markdown text. You might have a bunch of extra goodies above and beyond basic markdown syntax, things like syntax highlighting declarations, file inclusions, some YAML frontmatter like the stuff Jekyll uses, and so on. You might decide that you want to have some options turn the extra goodies on and off. If your goodies are written as plugins like this: function basicMarkdown(input) { ... } function processYAMLFrontMatter(input) { ... } function processSyntaxHighlighting(input) { ... } // ... Then you can write a function that reads some configuration to know which plugins to apply. It returns an array of plugins, with `basicMarkdown` first: function selectedPlugins(configFile) { ... } And now your pipeline function something like this: var pipelineProcessor = compose.apply(null, selectedPlugins(config) ); Of course you *could* stick a `for` loop inside `selectedPlugins`, but then you'd be mixing two separate concerns: How to compose functions and which functions ought to be composed. This matters a great deal, because by separating composition from selection, you make it easy to do either of two changes: 1. You might want to change the way you select plugins without changing the way you compose functions, or; 2. You might want to change the way you compose functions without changing the way you select plugins. The latter isn't that fanciful. If you're processing books, perhaps you want to do things asynchronously and chain the functions together with promises instead of directly. It's easy to pull `compose` out and replace it with something like [sequence from allong.es](https://github.com/raganwald/allong.es/blob/master/lib/allong.es.js#L1503).
They talk about how modern javascript debuggers allow you to view eval() so perhaps this was more relevant in the past when they couldn't.
There is nothing wrong with using jQuery. It would not be so pervasive if its usage had inherent flaws. But there is a problem with abusing it. Let it help you, but don't let it be a crutch to avoid more complex JS coding. I like it for simplified AJAX calls and DOM manipulation. I do a lot of work adding features to existing codebases at run-time, and jQuery makes that easy. I also like its cross-browser compatibility, as I still support old IE versions. Once it exists in a project, I see no problem using it pervasively through that project, so long as you are intelligent about it and don't create your own performance issue by making it parse the DOM every time you set/use a variable, etc. I draw the line at excessive use of plugins - most plugins are bloated beyond what I need them for, so I find it more worthwhile to break down my problems and create my own solutions vs. ending up with an app that is full of extra plugins to solve what are usually just UI problems. 
Fair enough. I know I'm coming across very strongly. There is a lot of self-promotion on reddit, so I guess I'm sensitive to it. I don't really have the right to be offended by someone else's project, so that is my mistake. Good luck with your endeavor.
Totally agree. My company has never used jQuery and have no reason to, though sometimes we have found some technique we wanted to use and didn't have time to figure it out ourselves so we include it until we find the time. I feel sorry for people trying to learn vanilla js only to run into the, now, countless examples using jQuery instead of the real thing.
jQuery is NOT essential and a lot of us don't/won't use it.
If you're just starting out and use jQuery, you won't learn the DOM or any of the other ins/outs. Don't hide things from people trying to learn. Otherwise, how would people like Reisig have ever created things like jQuery in the first place?
What do you use instead then?
You should definitely read "JavaScript, The Good Parts." When you're done with that, I've PM'd you a free coupon for [JavaScript Allongé](https://leanpub.com/javascript-allonge). I hope you find it useful.
Plain vanilla javascript.
What you've done is take `compose` and unroll it manually. Now if you want to change things to use promises, you have a line-by-line rewrite on your hands. If you are absolutely opposed to compose, you might at least consider using `.reduce`.
Cool. Down the line, can we change the configuration to usebasicmarkdown, then syntax, *then* yaml? Then back? What do you mean we have to recode? Sure in this toy, that's no problem, I guess, but it seems like at scale it wouldn't be as easy to maintain or adapt to new business needs.
This is horrible advice for someone who is trying to learn javascript.
jQuery done right is faaaar superior to whatever vanilla JS you are writing. To each their own though.
Well I want to make a siri model using JavaScript 
I thought you meant like... Sentient... Hal 9000 style... 
You can't hone a skill you cannot see. jQuery covers all that up. Most of our js is smaller than all of jQuery. And we do all the things jQuery does for others. We didn't get that way using someone elses code.
We won't hire anyone who can't perform without jQuery. jQuery only does the things you don't want to. It won't outperform any code we wrote (tested) and that's been shown elsewhere (that jQuery can be slow).
The development costs saved almost always outweigh the millisecond you (rarely need to) shave off. There are many factors in superior code... Why don't we write more programs in C?
Having gotten a chance to use it recently (albeit in C# and not jscript), it's surprisingly awesome.
Pretty rudimentary but it explains everything very well.
this is an awesome concept, do people use this often in js?
If you don't need IE8 support, check out [Snap.svg](http://snapsvg.io/) as well. It's the successor to Raphael.
Because writing code in C requires intelligent thought while using jQuery any old junk written will work. That's why we now need Ghz procs and GB of ram and the average web page is well over a MB. Cause no one cares about quality anymore. Well, we do, but that's why we make the big bucks
"However, the class-less programming style has recently grown increasingly popular, and has been adopted for programming languages such as JavaScript, Cecil, NewtonScript, Io, MOO, REBOL, Kevo, Squeak" Ah yes.. growing increasingly popular, as evidenced by it's addition to... those popular languages....
Alright so you clearly are trying to validate yourself. I don't give a fuck about what you do or the $ you make... I *promise* you that if we go down that road you will regret it. It is very possible to write high quality jQuery code. If you guys need to reinvent the wheel because you can't leverage jQuery properly, then that's your problem. End of story.
I would do it like this: // distribution of possibilities, as a percentage, totaling 100% var perc_ratios = [25, 25, 10, 20, 20]; for(var i=0; i&lt;perc_ratios.length; i++){ var k = perc_ratios[i] / 100; if(i &gt; 0){ k += perc_ratios[i-1]; } perc_ratios[i]=k; } var ratio_index = -1; var distribution_choice = Math.random() if(distribution_choice &lt; perc_ratios[++ratio_index]){ return "the quick brown "; }else if(distribution_choice &lt; perc_ratios[++ratio_index]){ return "fox jumps "; }else if(distribution_choice &lt; perc_ratios[++ratio_index]){ return "over the lazy "; }else if(distribution_choice &lt; perc_ratios[++ratio_index]){ return "dog "; }else{ return "wow such distribution "; } 
In practice, you'll usually see [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) used instead for partial application: function add(a, b) { return a + b; } var addTwo = add.bind(null, 2); addTwo(7); // 9 The approach in the article is neat, but in practice, a function's length property can't be trusted and you rarely want to totally curry a function rather than just partially applying it.
It's horrible to learn libraries? Why? My point was that you don't need avoid them - if you learn them, you'll start to understand what "pure javascript" is. There is no reason to avoid libraries. jQuery taught a lot of people to code, and that's _awesome_, wither you like it or not.
That's because you're submitting the form to the page and basically just reloading the page with the values of the form. Try this: &lt;form method="post" action="#contact"&gt; Do you have other programming knowledge? How are you planning on retrieving the data submitted to the form? I would recommend against building a form on your site until you have an understanding of website security in regards to form data. 
Could you give some examples? Specifically non-framework examples?
Yes. I have already fixed the refreshing problem. Now i just gotta figure out how to get the form the send the data to my email. 
This is a good overview. I've been really hammering away at gulp for the last week, trying to build a more full-featured gulpfile.js similar to ngBoilerplate's Gruntfile.js I **really** like gulp, and I think that it's going to go somewhere, but these simplified buildscripts are often too simple to really show everything necessary to have a real build process. * None of them setup tasks with proper **async** support, so you can't use them to build up task dependencies. This is most easily handled by returning your pipeline: gulp.task('foo', function() { return gulp.src(...)...; } If you don't do this, then task dependencies won't work — the tasks will be run simultaneously. * They rarely handle anything other than the most basic JS and CSS precompilation and minification. Once you need to integrate this with HTML processing, template processing, or other functionality, you *will* run into asynchronous stream issues. And they are an absolute bitch to figure out. * I've yet to see one use `gulp-watch` to show incremental builds, which is really important when using `gulp-liveload`. You really don't want to have to rebuild *everything* just because one file changed. This is even more important with automated unit testing. The only reason I think it's important to realize these things is that these ~20-40 line gulpfiles are not a fair comparison to a full-featured Gruntfile. My gulpfile right now stands at about 261 lines (185 LOC), featuring 13 tasks (all but a few are really subtasks), ~35 requires (you can use `gulp-load-plugins`, but it makes it harder to edit/debug in my IDE), several custom functions, and *lots* of workarounds for piping issues. And I don't have karma running yet. :-) As soon as I get a little further (and see a few outstanding plugin issues fixed), I'll try to publish the complete setup as a Github repo.
pm if you need help
One of the best arguments for using jQuery is browser compatibility. The simple fact is browsers don't behave consistently and libraries can normalize their behavior, which reduces bugs and speeds up development. When you use jQuery you don't have to deal with [compatibility tables like this (keyboard events)](http://www.quirksmode.org/js/keys.html).
A: I want to learn make a sandwich so I can get a job at the local deli. B: Okay, you're probably gonna want some bread, lettuce, mayonnaise, ... A: No, I'm trying to assemble protons and electrons into atoms to build molecules to make my sandwich. B: Er... it'd probably be a lot easier if you just use some pre-existing bread, or at least flour and milk or something... A: Considering that bread is made of protons and electons tells me you have a lot to learn about sandwich making.
&gt; We won't hire anyone who can't perform without jQuery. jQuery only does the things you don't want to. Pretty sure if an candidate came to me, and told me "jQuery only does the things you don't want to", I wouldn't hire that candidate.
Should have used an elegant reduce instead of the loop
You need to use something besides HTML for that. Most common way to send email is via PHP where you would POST the data from the contact form to the PHP script that would compile it and then send it as an email. Do not use Javascript for this, it has no security features to protect email addresses and such. That is why lechatron asked if you have any programming knowledge. PHP email scripts can be rather complex, but there are plenty of resources out there to show you how to create the script. For example, a simple one from css-tricks: http://css-tricks.com/nice-and-simple-contact-form/ But you also need to consider spam protection when building the form. Something like reCaptcha or a honeypot method should work.
Could you provide a link for the "wrapper" article?
http://lodash.com/docs#curry
On the other hand, JavaScript uses a lot of obscure concepts (for imperative programmers like closures, function scope, and first class functions) which will make it harder for newbies to grasp JS if they don't learn their existence and use early on. That's coming from experience. Because I didn't know about function scope, I made a lot of terrible errors, that could have been easily avoided. I just assumed, like many others starting in the language, that it would have block scope.
This is class based OOP, and Javascript is not class based. But is okay, people coming from a class based OOP language will feel at home learning a tutorial like this. 
Nice article, but I think you could have gone further, replacing the loop with a map, and generalising the behaviour of sequence into a flip function i.e: var flip = function (fn) { return function () { return fn.apply(this, [].slice.call(arguments).reverse()); } }
Btw, I didn't mean to come off as negative about your post or your gulpfile, it was more a general thought. I actually worked out the last bugs and got karma working (it was *easy*) since I wrote that. I now have a fairly perfect script for building, testing, and compiling. The watchers are particularly awesome. I have two more npm modules to release before I can share it, but `npm publish` was not working tonight. I'll try to get something posted in the next day or so, but I might not have the time for a few days.
No, it was a good comment and I agree with it. Look forward to seeing it!
It's *possible* to write an `unvariadic` function that can fix the arity of functions returned from things like partial application and/or currying: https://github.com/raganwald/allong.es/blob/master/lib/allong.es.js#L265 At it's heart is an application of `new Function(...)`, and that is gross.
&gt;I promise you that if we go down that road you will regret it. We've been "going down that road" for 10 years so it won't change any time soon. Most amateurs think jQuery prevents them from writing high quality code and creates a need to reinvent wheels while ignoring the fact that jQuery is written in plain javascript. To which they're reply is always, "I don't give a fuck ..." You probably need to read [this article](http://thefederalist.com/2014/01/17/the-death-of-expertise/) about developing an expertise in something.
I've spend a few days on gulp in a new project but I think it is still very immature, especially compared to grunt. My gripes with gulp: 1. lack of documentation beyond utter basics 1. it is rigged-up from different modules, this means if you want to know how it works you end up trawling a shitload of dependencies (also lacking docs) to figure out how to do anything beyond the simple examples. 1. difficult to switch between sequential and parallel executions. 1. all examples are extremely limited (like /u/OverZealousCreations mentioned) 1. it is not really streaming as it claims. If I read it correctly it streams whole file buffers (not their contents...). so basically all your files exists as blocks in memory. 1. takes to much technical insight into working with streams to make a plugin, this is reflected in the quality of the plugins. 1. plugins lacks testing 1. many tools that could get wrapped into plugin work based on files-on-disk, not streams. take for example `mocha`. 1. many plugins don't support running more then once (some try to fix this but fail to clear the `require`-cache properly) 1. the stream supports 3 modes: path-to-file, Buffers and byte-streams. Not every plugins support all of them, and this fragments everything. 1. messy to run pipes on the result of concatenation or compilation (where amount or location of files change). basically you have to make two tasks for that, and then figure out how to run them sequentially. 1. even thought it claims to be all about streams it is still heavily tied into the concept of 'files' in all kinds of ways. 1. plugins are a mess: most of them feel like the author just wanted to be the guy to run a popular plugin. And ultimately: All-in-all it doesn't actually offer any (promised) benefit over grunt besides not-being-grunt. I'll re-evaluate in 6 months. For now I call hipster on the whole buzz around it.
I come to /r/javascript for interesting links about new technologies and insightful articles. Not the (literally) first result of googling "object oriented javascript". Why is this being upvoted?
&gt;genderTeller(); // alerts undefined WHY!?!?!? (Java background).
Not really useful without any annotated examples or readme.
I'm going to write a reddit bot that automatically comments this on every announcement here. It will also mention the lack of tests.
Out of curiousity, how do you come to that conclusion? Statements like that make you sound like a religious disciple operating on faith instead of empirical observation.
Hi everyone. I've been working on this over the weekend for use in a larger project. It's the first standalone library/component I've ever open-sourced, so I'd love to know what you think of the code, the documentation, and everything else. Thanks!
On face value you have over complicated things. I'm unclear on why for any given route you have such complex resolution of templates? I generally serve views as static assets with unused view elements css display:none'd. That can get shipped off to the client while the server sorts out any query parameters etc effecting the content of the page. That content then gets applied in a clientside callback.
I've used require.js and text.js with Backbone before and it worked fairly well. However, in the end I just embedded the templates directly in the initial page load as most of our templates were small. Having to make a GET request to grab a template slowed down our interface considerably and felt bulky.
To summarize what I'm reading: 1. Prototypes do not encapsulate behaviour. 2. Classes do not *perfectly* encapsulate behaviour. 3. Therefore since neither are perfect, the distinction is moot. Is that what you are saying?
I don't like the idea of implicitly pulling in code dependencies really. I think I'd need to see a more compelling case to stray from the npm/CommonJS/Browserify ecosystem (and make it even harder for editors to intelligently autocomplete).
What is the argument for going async at all for client-side views? A very large set of static HTML views powering an app? Typically when I do client-side templating I'll use a solution that bakes in all my compiled templates into my bundle.js (see: [hbsify](https://github.com/epeli/node-hbsfy)) file so there is no fetching of any resources required. This means your JS scales as the number of templates does but I've found this to be acceptable within my constraints (e.g, SPAs, dashboards, etc).
Good job on having demos and a fleshed-out README. However, especially for something touching the DOM, I'd add tests and browser compatibility notes (ideally both via [Testling](http://www.testling.com)). Also, a quick look at the code makes it look like the progressor object maintains global state and cannot be used multiple times cleanly on the same page. You might want to rethink the API to use the typical constructor/prototype style of OO or maybe something like a jquery plugin. 
Interesting, I'll definitely have to look into Testling. And you're right, I still need to check it works across browsers. For my own personal use case, one instance per page sufficed, but again you're right - being able to use it more than once per page is definitely the next step. Thanks! Edit: Filed both your points as [issues on github](https://github.com/ejb/progressor.js/issues). Thanks again.
I've just recently found the underscore-tpl plugin, which uses the text plugin too. We were already using Underscore in our project, and that plugin precompiles your template as a _.template() before you get to use it. Simplified things up a bit.
Obviously Ruby classes are not *exactly* Smalltalk classes, but quite clearly Java, Ruby, Smalltalk, Python, and many other languages cluster around a common idea of a class, namely that it is an object itself, that it encapsulates the behaviour it defines, and that there is a notion of a metaclass. If there isn't a canonical definition for "class," that's too bad, but there isn't a canonical definition for "functional programming" or "object-oriented" either, but we make do. It's always important to understand fine distinctions between things, but it's equally if not more important to understand when things have an underlying, important similarity. The difference between a JavaScript prototype (and/or constructor) and a Ruby Class is massively larger than the difference between a Ruby Class and a Java Class. That's the point of the article. (edit: Small*t*alk.) C++ "classes" are indeed another thing entirely, a point that's mentioned in TFA.
Yup, true SPA so could have 10-15 templates to pull down. Honestly my goal is to just not store them in the initial mark up that gets delivered, broken up into seperate files, and only on demand. Not going to break the bank performance wise but I just don't want to use that practice anymore. Can you elaborate a little more on what you detailed above? 
Looking into the textjs route. A few builds behind on require.js, was under the impression it was for resource and object loading. Any chance you have an implementation example? 
This is stupid. Someone who's learned everything about programming from Ruby has come to JavaScript expecting syntax perfection and has been disappointed.
1. I did not learn everything about programming from Ruby. My first language was actually [SNOBOL](https://en.wikipedia.org/wiki/SNOBOL), and my first OO language was Smalltalk. 2. Syntax has nothing to do with it. In fact, the article carefully avoids syntax by mentioning that Ruby's classes have a `define_method` method just to get away from the question of syntax. 3. If the article seems to suggest that classes are *superior* to prototypes, I accept the criticism and will look into it. My belief is that classes are superior if and only if you want to do your metaprogramming in an object-oriented style. Not everyone does, and it isn't always important.
Instead of storing the templates in the static HTML markup that is served, and instead of fetching them asynchronously after loading, I'd like them to end up in my compiled Javascript file. An example is to use Broswerify to combine all of your JS files into a single bundle.js, with the hbsfy transform that allows you to require Handlebar templates that get pre-compiled and inlined as a function. Doing this means all templates are included in the single request for your bundle.js, and the templates are pre-compiled to just Plain Old JS functions. 
http://stackoverflow.com/questions/784929/what-is-the-not-not-operator-in-javascript
Ha, I know. I learnt OOP in Uni with Eiffel (like 4 years ago), Bertrand Meyer's language. Which I believe never was commercially successful, but it has been greatly influential in other languages (and things like programming under contract seemed, at least on paper, great ideas). Maybe NewtonScript was great, but... who knows? It was still an easy victim haha
Write them as HTML files. Have grunt task with live reload/watch that wraps them in a requirJs module. In dev, async load them individually as needed. In prod, bundle with rest of the js dependencies and download one bundle per route.
&gt; But it *is* wrong. Oh god. Somebody is wrong on the internet!
I do the same thing with [require handlebars]( https://github.com/SlexAxton/require-handlebars-plugin) Although I can see why someone might want to do async if you have too many view and templates
&gt; s is an object and, by default, it has access to the Shape constructor’s prototype It seems like you still don't exactly get it. Shape.prototype is not Shape constructor’s prototype. Shape.prototype is prototype of objects created with Shape constructor. Shape constructor’s prototype is Function.prototype (because Shape is a function) and s doesn't have access to it through inheritance. It's probably one of the most confusing parts of JavaScript that Shape.prototype is not prototype of Shape.
&gt; Shape.prototype is prototype of objects created with Shape constructor Appreciate the clarification. I'll change the wording. Thanks! 
In the html just put the class ".active" to the item that start clicked Then use this css .item:not(.active):hover, .item.active { } If you use javascript just add or remove the active class on clicking. 
I use [component](http://component.io) so the HTML gets converted to js and rolled up along with the js. We then improved it by using a grunt component plugin to use handlebars templates and partials. https://npmjs.org/package/grunt-component-build https://github.com/kewah/component-builder-handlebars So we don't lazy load them. We roll them up at build time into the js code. The component build spits out dev and production versions that take a little time configuring, but it's pretty straightforward. I then split up the application into multiple modules. Each one a component and load them using a standard js CSS lazy loader. Along with encouraging modules that don't share functionality and makes modularized code intuitive, it also allows you to quickly share common resources using the package manager's dependency configurations. 
The following would lead to clearer code, with the same result: foo = Boolean(myVar); But sometimes us JS coders are just lazy, and like shortening stuff.
I use it extensively in my last project : [one of my view](https://github.com/fbeauchamp/striim/blob/master/app/scripts/views/LandingView.js) I use grunt-require , to make one big javascript file also containing the templates 
NewtonScript did have an interesting idea that relates to JavaScript. In client-side JS, there are two parallel invocation models: Messages go through prototype inheritance, while events bubble through DOM hierarchy. NewtonScript mixed the two together into one model. It was heterogeneous multiple inheritance: Objects inherited behaviour from their prototype-like parent and also from their DOM-like container. I have always felt that event bubbling being a separate thing from message handling felt a little awkward.
[Duty calls!](http://xkcd.com/386/)
[Image](http://imgs.xkcd.com/comics/duty_calls.png) **Title:** Duty Calls **Title-text:** What do you want me to do? LEAVE? Then they'll keep being wrong! [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=386#Explanation) **Stats:** This comic has been referenced 213 time(s), representing 2.30% of referenced xkcds. --- ^[Questions/Problems](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Website](http://xkcdref.info/statistics/)
A little bitter cause it's over your head? There's gotta be an app for that? Suffice to say, if you need jQuery, and obviously you do, then you aren't qualified to do the work we do. As in, you aren't good enough.
The :hover css selector cannot be "forced" on. Your best bet is to write a css rule like this .element:hover, .element.active { // your css } Then, you can use the "active" class to toggle your hover effect with javascript. If you use jQuery, it shouldlook like this : $('.element').on('click', function() { $(this).toggleClass("active"); }); There you have it, a :hover style relying only on CSS and a toggle on click events with a bit of js. 
Have you done any side-by-side comparisons to Grunt? I'm curious how Gulp's promised speed works out in reality.
How do you access Shape's prototype if not via Shape.prototype?
We use require.js and the text plugin during development, our Gruntfile combines all the relevant javascript and places the templates at the bottom of the &lt;body&gt;. Our MVC system checks if these templates exist and uses them instead of loading the .html files.
Because it uses `this`. A function's `this` is only bound to an object if it is explicitly passed (e.g. `genderTeller.call(thisObj, arg1, arg2)` or `genderTeller.apply(thisObj, args)`) or if it is invoked as a method (e.g. `someObj.genderTeller(arg1, arg2)`). Let me repeat that: there is no difference between methods and functions in JavaScript. There are only functions. Except functions can be invoked *as methods*. If a function is not invoked as a method, `this` will be something you're probably not expecting: `undefined` or the global object (i.e. `window` in a browser or `global` in node.js), depending on whether you're using `"use strict";` or not.
You are failing so badly at this discussion. We don't 'need' any libraries... We choose to use them to avoid duplication of effort. You really think that vanilla JS is over my head, after this whole discussion we've had? Kindly fuck off now.
Let me get this straight: the toolchain resolves all implicit dependencies and then downloads the *latest* version of each dependency? Compared to `npm` or even `bower` this is absolutely mental. I hope this is just meant as a way to get started when you're building a prototype.
CSS noob here. Is there any reason for .item:hover to exclude .item.active? Are there any properties that could be set in this selector that 'double-dip' and get applied twice?
Function.prototype is Shape's prototype, but what you probably want to access anyway is Shape.prototype not Shape's prototype (but it is not prototype of Shape, it's prototype of objects created by using Shape function as a constructor).
I never read the web for fun on a PC any more, only via my mobile/tablets, etc. IMHO, you should be creating all these games to work with touch first.
Couple of suggestions for you: 1. Your README.md should at least contain a basic usage example to give people an idea of how to use your library. Bonus points if you list the functions it exports and how to use them (API docs). You have an example folder -- that's neat, except unless I happen to know about [rawgithub](https://rawgithub.com/steelbreeze/state_lite.js/master/examples/test_lite.html) I can't look at it without having to download it. Consider adding a github-page if you think you can best explain your library with a demo. 2. If you're going to release a package on npm, resist the temptation to name it "something*.js*" -- if it wasn't JavaScript it wouldn't be on npm. Same goes for the anti-pattern of calling libraries "*node-*something". It's okay if you name your repo that way, but don't do it in package.json. 3. As others have mentioned, testing always makes your code more trustworthy. [mocha](http://visionmedia.github.io/mocha/) and [expect.js](https://github.com/LearnBoost/expect.js/) are an easy combination to get started. If you want one of those "build: passing" badges, sign up for a free open source account on [travis-ci](https://travis-ci.org/). For bonus points, add [testling](http://ci.testling.com/) for automated cross-browser tests and [coveralls](https://coveralls.io) for test coverage reports ([istanbul](https://github.com/gotwarlost/istanbul) is a great tool for that). 4. For maximum compatibility, give [umd](https://github.com/umdjs/umd) a try. It's a simple pattern that lets you support CommonJS and AMD alike with a fallback to browser globals. 5. Keep up the good work. You're making the world more awesome with open source contributions like this. You're shipping, everything else is a plus.
Well i've put that because I use it to apply a different css for .active
Javascript has classes. They are part of ES6. They desugar to prototypical inheritance. That said, prototypes are not classes in the same way that bricks aren't a wall.
You have accidentally written a very concise introduction to JavaScript prototypes for someone who knows a class-based language. Thanks!
Interesting post, but I feel like it conflates Ruby's choice of reflection API with the definition of what a class is. Sure, an object representing a class in Ruby has a lot more stuff on it. Stuff that's related to classes. And a prototype in JS doesn't. So they're pretty different. But that's because Ruby chose to hang its entire reflection API directly off the Class class. For contrast, classes are first-class in Dart, so you can do this: class Foo {} var fooClass = Foo; But what does that buy you? This `fooClass` variable will be referencing an instance of class `Type`. What does that give you? [Not much.](https://api.dartlang.org/docs/channels/stable/latest/dart_core/Type.html) That's because Dart puts the reflection API in a separate library, [`dart:mirrors`](https://api.dartlang.org/docs/channels/stable/latest/dart_mirrors.html). If you'd used Dart as your example class-based language in the post, would you have drawn the same conclusions? Personally, my feeling is that most JS that follows the pattern you describe [is effectively class-based](http://gameprogrammingpatterns.com/prototype.html#what-about-javascript). If it looks like a class and quacks like a class, as far as I'm concerned it pretty much is one.
I think this is just a wording difficulty since JS has two prototype properties, "internal" and (on non-arrow functions) "external". The only distinction in the spec is symbolic (ie. [[prototype]] vs. `prototype`) and contextual, neither of which can be put into words very precisely. When I talk about prototype I tend to always say "internal prototype" and "external prototype" to remove the ambiguity. Is there a better way?
I personally would have enjoyed the article a bit more if there was less fluff surrounding your points :)
(shameless plug:) I wrote a (ES3-compatible) library for partial function application (both ways!) called [par](https://github.com/pluma/par) (licensed under the Unlicense, i.e. Public Domain). Partial function application is different from currying, but usually good enough. The problem with autocurrying in JS is obviously that many JavaScript functions have optional arguments or are variadic. So unless a function is written to be curryable, it doesn't have to be. In fact, the `autocurry` function the article describes does not support multiple currying: the curried function can not be curried further (and because it is variadic, it can not even be passed to `autocurry`). So it's not really any better than partial function application.
It's open source, been actively developed for years, used by many prestigious websites, beat out the competing libraries by a long shot, need I go on? If ad hominems are all you have to contribute, you might as well just not.
if the case stated, the reason why it's being used is because the writer is trying to pass a Boolean in the object if they were just doing a conditional, it would be unnecessary if (window.addEventListener) { } javascript evaluated this to a true/false to determine the conditional the writer is trying to save a Boolean values of existing features (for feature detection most likely to deal with older browsers). I would have prefixed the object keys with "has" in this case (i always prefix all Boolean values with "is" or "has", common practice) var feature = { hasAddEventListener : !!window.addEventLIstener, hasQuerySelectorAll : !!document.querySelectorAll }; without the "!!", these object keys would just point the respective functions, with the "!!", they are Boolean values that lets the writer know if the functions exist in the browser being used edit: spelling and grammar
&gt; quite clearly Java, Ruby, Smalltalk, Python, and many other languages cluster around a common idea of a class, namely that it is an object itself, that it encapsulates the behaviour it defines, and that there is a notion of a metaclass. Aren't these three claims true of JavaScript prototypes as well?
You have no idea what you are talking about. I code for a small team of developers who have built an internal application worth multi-millions which generates multi-*billions* (for a multinational company) and runs/maintains flawlessly. The front end has impressive architecture, and we do leverage jQuery. Your snotty attitude towards jQuery is really laughable to me, and just tells me you haven't seen it used properly in a professional environment.
Prototypes don't [encapsulate] the behaviour they define, they expose the behaviour to be defined to be directly manipulated. If you had to call a method on the prototype to create a new method, you would have some encapsulation. [encapsulate]: https://en.wikipedia.org/wiki/Encapsulation_(object-oriented_programming)
&gt; But what does that buy you? This fooClass variable will be referencing an instance of class Type. What does that give you? I have no idea what it gives me in Dart, but I know that if I have prototypes, I can build whatever I want without the language designer dictating my OO flavour to me. That's a good thing. On the other hand, if I have classes and I have metaclasses, then I can define classes with new kinds of semantics, such as adding AOP myself so that I can write things similar to Rails' model lifecycle methods and chained method filters.
"prototype" has 3 syllables and "class" has one syllable. so my coworkers and I say "class". Miraculously, we understand each other and we are able to get a lot of work done, even though we are wrong.
If the fundamental features of a true class system are encapsulation of behaviour and restricted outside meta-programming, then surely Python's classes are just as unworthy of the title as JavaScript's prototypes.
I'm amazed we're not seeing eye-to-eye on this. If you have an object, either you have hidden internal state mediated by methods, or you don't. This is an axiomatic thing. If object-oriented programming doesn't mean "internal state mediated by methods," to you, that's fine, but that's what *I* mean by it. Likewise, when I say that an object *encapsulates* its internal state, I mean that it mediates access to that state through methods. JavaScript makes enforcement of this difficult, but I'll settle for *intent*: If you write an object such that you intend for other entities to interact with it through its methods, that's encapsulation to me. If you intend for other entities to directly manipulate an object's internal state, that isn't encapsulation. In fact, there's no "internal" about it, you have external state. Prototypes do not encapsulate methods and properties, it's that simple. It isn't a bad thing per se, it's just obviously a different thing than languages where that internal state is hidden from the programmer and mediated through methods. Now In Ruby you have a syntactic construct for defining methods, but you aren't actually manipulating the class's internal structure. Your access to it is mediated by a language construct. But you are still at arms-length from the internal structure. Is it a hash? A list? A B-Tree? Without looking at Ruby's source, we have no idea what the internal data structure of a class is. Again, it's not a bad thing to have prototypes instead of classes-in-the-sense-that-Ruby-and-Python-and-SmallTalk-have-classes. But they aren't the same.
Based on the tone of your message, it sounds like you are making a few false inferences about what I am saying. So just in case, let me make a few things explicit: I don't think that you are saying JavaScript is "bad", and I don't think you are saying prototypes are "bad", so you don't need to clarify that. I am not making any claims about what is or is not object oriented programming; I'm accepting your axioms for the purpose of this discussion and trying to point out that your conclusions don't follow from your axioms. With that out of the way, I'll continue addressing your points now. &gt; Now In Ruby you have a syntactic construct for defining methods, but you aren't actually manipulating the class's internal structure. Your access to it is mediated by a language construct. But you are still at arms-length from the internal structure. Is it a hash? A list? A B-Tree? Without looking at Ruby's source, we have no idea what the internal data structure of a class is. Isn't the same thing true of JS? It seems like I could implement JS in such a way that when you write "MyClass.prototype.foo = whatever", MyClass.prototype doesn't *have* to be implemented as a hash (at the C code level, where I'm implementing my JS engine); Although that's the obvious implementation, it could also be implemented as a list or a b-tree. &gt; Again, it's not a bad thing to have prototypes instead of classes-in-the-sense-that-Ruby-and-Python-and-SmallTalk-have-classes. But they aren't the same. Another point of clarification of my position: I think that classes and prototypes are different; but I don't think your arguments demonstrate that classes and prototypes are different.
Arstechnica and wikipedia seem to be using jquery from their own CDN
&gt; Personally, my feeling is that most JS that follows the pattern you describe is effectively class-based. If it looks like a class and quacks like a class, as far as I'm concerned it pretty much is one. Same here. The only noteworthy difference is that's an imperative non-standardized roll-your-own thing. There are incompatibilities (e.g. an Impact "class" is very different from a Backbone "class") and your IDE will have a hard time figuring out what's going on. That's what ES6's addition of classes will fix. It isn't just syntactic sugar.
May I hug you?
You may, but careful not to have the emotional connotations of a huge trigger an "us-vs-them" feeling, leading to always upvoting me and always downvoting them, without regard to the merit of the arguments.
So I'm guessing when you are using this technique to cast to a boolean, you would rarely just use a single 'not', correct? A single not is useful when checking for truthiness, but if you wanted to return that as a boolean and store it and use it later it's hard to imagine when you would want to return an inverse value. Am I safe to say that this "cast to a boolean" trick really just has this one version with the 'not not'? And not a 'not' version .. if that makes sense?
Well put - fan of "has" / "is" as well for booleans - but in this case it's inside a "feature" object - so the author intention probably is pretty clear anyway.
Maybe because you aren't the only person that visits /r/javascript and thus aren't the intended target of every post? Just a thought...
I think what some people forget is that prototypes in JS aren't different from objects the same way instances in classical inheritance are different from classes. A prototype by itself is just an object. It only becomes special by being assigned as the `[[Prototype]]` of another object -- and even then it's merely the relation between the two object that is special. Any object can be the prototype of another object. It's primarily just a means to defer undefined property lookups to another object. You can make it more class-like by having constructor functions (well, initialisers really) and special syntactic sugar, but you're still just dealing with plain old objects (not in the same way that functions are objects). In, say, Python classes are objects in the same way functions are objects. But they are special: classes can be instantiated or they can be subclassed. In prototypal inheritance, that difference only exists on a conceptual level. This also means there can be meta-classes that have the same relation to classes as classes have to objects. In JavaScript these are all just prototypes -- *maybe* with constructors.
You're a cog doing what you're told to do. I run the show where I'm at. Our (my) biggest customer is a global restaurant chain so don't think you have anything to teach me. Wait. I forgot. I'm not messing with you anymore.
This seems dumb. You lose your data, do an extra computation, and end up with the same result.
It is possible to implement Class objects using the prototype system: http://ejohn.org/blog/simple-javascript-inheritance/ https://github.com/metabench/jsgui-lang-essentials/blob/master/jsgui-lang-essentials.js Once they are defined in the old-style pre ES6 JavaScript which I still program in, they are available to be used.
I'm just going to do a mass-response right here: Obviously--I hope--I know how prototypical inheritance actually works and it doesn't bother me in any deep way. I'm a big fan of "cutting with JavaScript's grain," as evidenced by my love of things like function decorators. And I have written prototypical inheritance code before, I actually had a shareware NewtonsScript program way way back in the day, and I have done some in-house Runtime Revolution work. I get the argument that "class" is an overly broad word. I prefer a narrower interpretation, but where words are concerned, what matters is the *shared* interpretation. CoffeeScript, ES6, and C++ have "classes" that are very different from what I was describing. I'll sleep on it, but I suspect I will wake up thinking that it is still important to understand the difference between a prototype and the kind of metaobject that presents more of an abstraction or encapsulation. But maybe that thing already has another name, and I should be using that name instead of "class." In any event, I think the quality of feedback here has been very high. Not just useful for me personally, but if I imagine someone reading the post and then reading the comments, I think that the person will be better off for having read both. So **thank you**.
You are coding a website for a fucking restaurant, and you think that jQuery is not performant enough for you? LMFAO. Me being a cog in the machine (a small dev team of &lt; 5 people) hardly is a response to the fact that your entire view on jQuery is childish... Which you force onto your team. LMFAO. I code financial applications... Plz sir, teach me how to style a restaurant's menu for web display?
It is a way to normalize an object|value|function to either true or false. For example if an object exists, the !object is false. The extra ! then turns the false to true, thus transforming the object to a true value. It is a neat little trick and of course there are other ways to get there. This is very concise and of course looks cool. I wrote a blog post on !! a few months ago, http://love2dev.com/#!article/What-the-Heck-is-!!-in-JavaScript
I have difficulty with the internal state argument as well. One of the patterns in JS to maintain internal state is to preface it with "_" and directly accessing those fields outside of the class is 'bad' and certainly nothing that somebody would do accidentally. If you added a JSHint rule that protected against this, would prototypes suddenly become classes? On the other hand, if the "private" keyword was removed from Java would it no longer have classes?
I am not attacking you, but your commentary about adoption popularity does not address the point I provided to you. Unfortunately, it does reenforce the comment I made, which you believe to be an ad hominem.
&gt; I think that classes and prototypes are different; but I don't think your arguments demonstrate that classes and prototypes are different. I'm going to think on this for a good while. Scotch may be involved.
very not working on my ffox and chrome
unintentional pun?
`object.__proto__` [is deprecated](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto).
wow! thats really cool, just found this now and tried it out. amazing to that there can be so many new levels everytime. i'm interested in learning javascript. how did you get into javascript and how long have you been doing it?
Yeah. Good thing Object.getPrototypeOf() exists.
I am glad someone finally posted this.
Yes, I'm familiar with the convention with respect to length and width. My point is that `prototype` is a public property of `Rectangle`, a property that any code manipulates directly. `area` is the exposed surface area of a Rectangle *instance*, but Rectangle the class doesn't have any private state, it just throws `prototype` on the table and says "do with this what you will."
&gt; If Ruby allowed you to add fields and methods to a class outside of the Class.new invocation, would you still consider it to have classes? Ruby does allow classes and methods to be added outside of the `class` invocation. The key point is that when a metaobject--be it a class a module, or something else--*mediates* the addition, modification, and removal of behaviour from instances, you can do certain kinds of metaprogramming that are difficult to do with prototypes... Unless you build a metaobject protocol yourself. Examples: Mixing Aspect-Oriented Programming or Design-by-Contract with inheritance and/or reflection.
I don't see the progress indicator within the bar at all on any demos, Chrome 31.0.1650.63 on Mac OS X. [Screenshot](http://i.imgur.com/iPQHidO.png)
Rectangle can have as much state as it wants. eg Rectangle._myState = 32; The deeper question here is: Who are you afraid of and why?
Can you give examples of what these kinds of metaprogramming are? Also note that this is definitely moving away from "prototypes are not classes" to "prototypes are not ruby classes".
I think you should add some code that just includes the * on the front and end for you and take off the instructions about adding the *. Because that is the way most searches on the internet work. Other than that seems great, not sure why people downvoted it. Except that reddit is just lame like that.
Using just one ! will cast a value to a boolean, but it will be the opposite of the value you probably want. The second ! is there to flip the value back. If you were going to write a function called "isEmpty" that took a string and returned true if it was empty, you could write it as: function isEmpty(val) { return !val.length; }; This would return true if the length of the passed-in string was 0 and a false otherwise.
If you have big object and only strings, bools, numbers and objects as values then one of the fastest way to clone object will be: obj = JSON.parse(JSON.stringify(someOtherObj));
The premise is interesting ("get rid of the soup"), but in practice, I feel this could create some very hard to test scenarios where your function gets weird arguments it doesn't expect because a form was incorrectly matched against a set of arguments. I do like the `randomInt` example, but part of me feels the library's interface could be a bit more elegant.
**Is it better encapsulated?** function Gallery(){ var gallery=this; gallery.collection = []; gallery.Photo = function Photo(){ gallery.collection.push(this); // &lt;-- appropriate? this.blah = true; }; } $(function onDOMReady(){ window.gallery = new Gallery; new gallery.Photo; new gallery.Photo; }); - *Separation of Concerns:* now encapsulated, is the gallery sufficiently self-concerned? - *Modularity + Don't Pollute Global:* surely alleviated by the encapsulation - *Function Purity:* Surely the real heart of the issue all along? **Would this be the satisfying alternative?** function Gallery(){ var gallery=this; gallery.collection = []; function Photo(){ this.blah=true } gallery.addPhoto = function addPhoto(){ gallery.collection.push(new Photo); return gallery; }; } $(function onDOMReady(){ window.gallery = new Gallery() .addPhoto() .addPhoto(); }); I suppose *Function Purity* is the only concern. One might worry, that a programmer might not expect the `new gallery.Photo` to both create a Photo *and* add it to the collection. Or is this something that is reasonable to be expected? `gallery.addPhoto()` vs `new gallery.Photo`? There's something I find strangely erotic and minimalistic, in omitting the helper function `addPhoto` -- it feels perhaps, redundant, or unnecessary?
I have not, and I believe it would be very difficult to do a proper comparison (because the systems work very differently). I believe the fact that Gulp avoids using the filesystem until the processing is complete is probably a benefit. Overall, it's pretty fast — especially when using `gulp-watch` to incrementally process files. But it's not like Grunt was terribly slow. Really, though, I just like the gulpfile format much more than Gruntfile. Grunt has such a bizarre organizational structure (config-first, with sub-task-steps being the top level element, then sub-tasks, then tasks). It's very hard for me to work within a Gruntfile when you want to add functionality, requiring a lot of hunting all over the file. For example, when I wanted to add gzipping to my gulpfile, this is the steps involved: * run `npm i --save-dev gulp-gzip` * Add `var gzip = require('gulp-gzip');` to my gulpfile * Locate my `compile-*` tasks (there were three) * Add this to the end of each set of streams (which ended with a pipe to a destination): .pipe(gzip()) .pipe(gulp.dest('compile')) That's it, and I get two output files for everything, one plain, and one gzipped. It was a minimal amount of work. Most gulp changes are similar, as long as you are manipulating a simple stream. And because the file buffer is still in memory, gzip didn't have to read from the filesystem. It's very immature — I had my gulpfile working perfectly at 6AM today, did an `npm up` around 1PM, and it was broken requiring a significant rewrite. There is a lot of volatility right now, and there's still some big concepts to solve. This is fine right now, since I'm enjoying myself. If I was using it in a production environment, I would choose Grunt, no questions asked.
Actually, using `Circle.prototype = new Shape();` creates an array, `types`, on the prototype shared by each circle object, which the author points out. Using `Object.create` doesn't run `Shape`'s constructor, so those properties are not added to `Circle`'s prototype. I do agree that the point was a bit lost because the notion of calling `Shape`'s constructor inside of `Circle`'s was introduced at the same time, but the author is correct in this situation.
I think that a lot of the problem is that it's so extremely volatile. Changes are being made daily to gulp and the plugins, so the plugins have serious quality differences. Many of the plugins are extremely simple, being just a stream wrapper around an existing tool, which is why there isn't a lot of testing. I believe that there are a lot of decisions still being made, too, regarding how to handle errors, the "right" way do things, etc. I think it is only prudent to wait before using gulp in a production environment. As I wrote above, I would definitely use Grunt over gulp for now. Of course, it's not like complicated Grunt scripts are magically easy, either. I've had a ton of trouble getting livereload to work consistently in the past. The one in gulp has been much more consistent — probably due to the way watching and pipes work with `gulp-watch`.
Sure. I have Child extends Parent. I have an instance method, foo(x) {...}. I want to say that before .foo is evaluated, I want to add a guard clause:If the argument x is null or undefined, return undefined without evaluating the method. I can do this now by decorating Parent.prototype.foo, but if I override this with Child.prototype.foo = ..., I lose the guard clause. Whereas if I was calling something like Parent.before('foo., ...) and Child.defineMethod(foo, ...), I could add a mechanism to inherit guard clauses even when I override a method.
Ummm, that's what I said. Borrowing the constructor was the only useful thing done in 3, switching to Object.create was irrelevant.
This isn't a Java-style bondage and discipline exercise. Mediating access allows you to decorate behaviour in all sorts of ways, especially if you have inheritance involved. I don't feel like arguing the case for OOP all over again. If you like using POJOs in your code that you manipulate directly and not through methods, you'll like directly manipulating prototype properties. Whereas if you have a bunch of use cases for wrapping internal state with methods that provide a protocol, you'll grasp that the same reasoning applies to why you might sometimes want to mediate access to prototypes.
Useful at API borders. If someone is expecting a boolean they can use with ===, and you give them a MySuperSpecialObject, you will break other people's code. It also provides for better encapsulation of implementation details.
My two cents, I'd avoid using `var gallery=this;` Also, this.collection.push( new Photo(arguments); ); This will also allow you to pass arguments to `addPhoto` and they'll make their way to the `Photo` constructor, e.g., `gallery.addPhoto({ width:99, height:99, src:'test.png' })` I'd also move the `Photo` function outside of `Gallery` ... But, whatever works
Ummm, you still don't get it. If you do `Circle.prototype = new Shape();`, you would still have a useless array on the prototype of `Circle`. &gt;You can replace "Circle.prototype = Object.create(Shape.prototype);" with "Circle.prototype = new Shape();" and get exactly the same result. This statement is **false**. It is not *exactly the same result*. Yes, the `Shape` constructor will override the `types` property, but anyone who inherits from `Circle.prototype` will get a random `types` property equal to an array of strings, and there is no guarantee that their constructor will override it. Run the code if you need further convincing, but you are misleading in your comments.
Its not the same because calling new Shape will execute the Shape's constructor which may not be desired if the constructor has special setup functionality you don't want to run yet.
Looks like someone is *wrong* on the internet.
Hi, thank for constructive criticizm :) - Ill do it today, I'll add stars to search string if none are present
Should have used recursion instead of iteration. I'll give a more detailed response when I get in front of a computer
No true Scotsman would allow his definition to be externally modified at runtime.
Worrying. I'll take a look myself as soon as I can. Thanks!
Thanks for doing such a thorough review of my code! &gt; constructor-style init This was mentioned by someone else in this thread earlier. I need to do quite a bit more reading up on the subject, but it's definitely something I want to implement. &gt; bullets 2 &amp; 3 I'm on my mobile right now so will take a look at this once home. But yeah, I was wondering how to use "this" in anonymous functions! &gt; destroy method Excellent point! &gt; no comments I don't have a good answer to this question... :) &gt; #timestamps not present Whoops, you're right - I left that out of the basic demos.
Well, a single negation is useful if you want the result to be the opposite of the boolean value of something, e.g.: function isEmpty(arr) { return !arr.length; } If `arr.length` is `0`, it returns `true`, otherwise `false`.
I keep working on graph algorithms. This is a demo of fabric.js graph renderer, rendering graph with 1k nodes and 0 edges. You can use mouse wheel to zoom out, and left button to drag nodes. Description of how it's built and more examples are [here](https://github.com/anvaka/ngraph/tree/master/examples/fabric.js/Node%20and%20Browser/). 
The mouse wheel doesn't work for me (Chrome, Ubuntu 12.04).
Smalltalk and CLOS are the canonical examples of Metaobject Protocol languages. Ruby and Java are just two of the languages that follow the idea somewhat. 
Seems like a solution looking for a problem. JavaScript intentionally doesn't have function overloading - most scripting languages don't (at least the non-C derivatives). Adding a bunch of cruft to add a language feature that you don't really need is overkill, IMHO. I can't imagine any scenario where I'd want to use this. People keep trying to [shoehorn their favorite language into Javascript](http://phpjs.org/), but it's actually a pretty decent language without all of these nonsensical "improvements." 
As interesting as this is, I think you would be better off using a different technology. I'm not a fan of changing the core concepts of the language -- if you are, you should probably just be using a different one altogether. If you haven't encountered [ClojureScript](http://himera.herokuapp.com/synonym.html) yet, maybe you should give it a shot. Variable arity functions are supported quite well.
Require.js is an async file/module loader. Unfortunately I don't have personal examples. I would do a google search and see what you can find. 
I like that idea. Hadn't thought of that. We already use Grunt to manage everything else. What plugin are you using to embed the temples into the html?
you...you're on the verge of recreating the universe!
For async calls, I propose an asynchronous pattern to enable the page/app to access partials: addTemplate('template1', '&lt;h1&gt;Hello&lt;\/h1&gt;'); ... The connection submitting templates and data can be kept alive for some time, saving further transmissions. So even if you cannot serve some part of your templates/data at the moment, you can resume it later and have a working app at every time.
Considering pace is 25K unminified vs Nprogress's 7K unminified, I would think about switching over. Even with the extra 1K of CSS that nprogress needs, it still comes out on top.
What do you mean? We develop the templates in seperate HTML files. When it's time to deploy, we run Grunt and a custom Grunt task that places all the templates at the bottom of the &lt;body&gt; with IDs that relate to the filename.
Someone is a fan of Dark City.
And again, no attempt to respond to the the facts I have argued. You fail sir.
Big Time.
Wicked, way cooler then Bluetooth :) Got a bunch of questions: 1. Can this also send JSON-like objects (or the full UTF8 JSON-strings)? 1. I see you mention limited bandwidth, have you got some numbers for that? Or an idea what kind of stuff we could stream? Like could we use a mobile as trackpad to stream cursor coordinates (at 60hz? 30?) 1. Have you though about add tech like base64 or messagepack for binaries and objects? 1. What about gzip? 1. How crazy will it get if you use multiple setups in one room? What about using named message channels? This needs a node.js module too so it can be used a transport module for stuff like a local noflo or socket.io :)
Interesting questions. The following points should answer your queries. 1. The current implementation of Remote.js is capable of sending only very basic signals. It can't send meaningful text (JSON, base64 etc.) or binary data (gzip, executables etc.), but it shows enough to inspire someone to come up with a way to send text / binary data. 2. I don't have the bandwidth numbers. The current implementation cannot be used for sending coordinates etc.; you will need text / binary data for that. 3. The current implementation is prone to interference from other instances. This can be overcome by allowing the developer choose the frequency band for their apps, and maybe a pairing handshake. 4. There isn't anything universal like Web Audio API, for the commandline; so taking it to Node is not that straightforward. If done, you could do some really crazy stuff. 5. I plan to further work on the technology - binary file transfer is my ultimate goal. Recently there was some [news](http://news.cnet.com/8301-1009_3-57614442-83/malware-jumps-air-gap-between-non-networked-devices/) about some researchers who managed to propagate malware using a similar technique. But I find their claims incredible.
Well, once you include their code on your page you can't really keep them out of the DOM. I assume this adware traverses the DOM and looks for suitable blocks of text-content to extract words from and replace with links. So you got to obfuscate your text from that. What you could try is scrambling your text splitting it into nested DOM objects (like `&lt;span&gt;`). You can take it further by using block-level objects `&lt;div&gt;` and using CSS to style them `display:inline`. A problem is this might hurt your SEO. Maybe you could leave the text intact at first, then runtime restructure the DOM. Not sure if GoogleBot is cool with that though. If the adware is on a delay then you can periodically restructure the scrambled DOM (from a clean copy) so the adware's attachment get dropped. This might hurt memory (garbage-collector). Some other ways: 1. write your content into an IFRAME 1. use new tech like ShadowDOM, custom elements and HTMLTemplates to hide your textual content from the visible DOM (because code cannot access the ShadowDOM from outside). 1. see if you can use cross-domain security, not sure if possible here though.
in this example nodes are disconnected. Example where all nodes are connected is definitely slower and less stable with default configuration: [80 nodes](http://anvaka.github.io/ngraph/examples/fabric.js/Node%20and%20Browser/index.html?graph=complete&amp;n=80) - this is complete graph. 
Who knows, maybe we are ourselves are part of such universe in post-human's browser :)
On chrome on mac, says i need to be on canary with flags turned on. 
Thanks for your detailed response. As far as i can tell, the code isn't included on the page, it just runs in the browser. As a result i'm not entirely sure whether the same-origin policy would apply. This is more like a browser plugin than a piece of code loaded into the DOM. SEO is of absolutely no concern in this case, so I'd be interested if could you elaborate on your comment about about splitting them into nested DOM objects? Perhaps provide a JSFiddle if you have the time. I'll look into ShadowDOM. Sounds like it could do the job nicely. 
Without a hand-written copy constructor, your object gets, by default, shallow-copied and so encapsulation can only be preserved if you write copy constructors for all objects that do deep copies, which is a ridiculous requirement to preserve something that OO is supposed to support out-of-the-box.
Hi. I just noticed that the response from: /summaries/world/ /summaries/business/ if different when compared to: /summaries/technology/ Is that intentional?
If it is a browser plugin it still will work somewhat similar as described, but with more privileges. Many plugins are also JavaScript based (in modern Chrome and FireFox). Here is a minimalistic fiddle for the obfuscator: http://jsfiddle.net/F9tps/5/ If your inspect the output you see it is split into span's. This can be greatly improved with deeper nesting, dummy elements (empty nods or chaff from nodes on display:none etc) and/or spitting over word boundaries (although your text linebreak flow may suffer). Also you can use structural nodes (`li`, `ul`, `dd` etc) as use css to display them inline. Of course an advanced hostile ad injector can still try to fight this by trying to extract the raw text and replacing your obfuscated content, it all depends on how much time they pump into development: it is a fight.
I actually agree with you about JavaScript being "a pretty decent language". I've been using it for 10 years and if I was forced to choose a favorite language, I'd probably choose JavaScript. And it's incredibly flexible and expressive on its own. That being said, the language was essentially designed and delivered in about a week 18 years ago and hasn't changed much at all since. I don't think anyone can deny that it's got some bad parts too. I think one of the bad parts is how JavaScript handles arguments, and how limited we are in that regard, which is why I created this project. THAT being said, I really do like JavaScript, which is what compelled me to try and find a solution in JavaScript proper, rather than searching for a solution in a compile-to-js language (dart comes to mind as a language that provides a more robust arguments interface, and another commenter suggested ClojureScript). Long story short, I think there are ways we can improve our use of JavaScript through libraries like this, to limit the amount of boilerplate code we have to write, thus improving the overall readability and maintainability of our code.
I'm glad you find it interesting :) I think you make a valid point about changing core concepts. I haven't use ClojureScript, though I have experience with Common Lisp and I've looked at Clojure a little, so I think you're talking about method overloading using generic methods? As I mentioned to another commenter, I really like the JavaScript language itself (most of it), which is what compelled me to try and find a solution that didn't involve using a compile-to-js language. There are some drawbacks to my approach though, probably the biggest being that everything happens at run time so it's not optimized at all. There are ways you can optimize at runtime by saving and reusing the results of calculations, etc, but it can't get any faster than a language that compiles all of its syntactic sugar down to a single function. I guess that's the price JavaScript pays for (or the benefit of?) being "the assembly of the web", as people like to say nowadays.
&gt; That being said, the language was essentially designed and delivered in about a week 18 years ago and hasn't changed much at all since. First off, this is patently false. Secondly, if you find that you *need* something like what you've written, I'd suggest you're still thinking from a C-standpoint, and not accepting Javascript for what it is or how it works. Again, lots of people have a hard time shaking off their "native" language's hallmarks, but personally I've **never** had need of something like this in fifteen years of working with Javascript. You should probably find a native javascript way of dealing with it. E.g., your example: v.form("category") // form 1: string .form("end") // form 2: date .form("category", "end") // form 3: string, date .form("start", "end") // form 4: date, date .form("category", "start", "end"); // form 5: string, date, date Would be more javascript-ic by using chainable functions, rather than passing random garbage to a single function. Better: v.category('category').start('start').end('end'); 
Agreed. What are your reasons for **not** wanting to use it? I used to write plain old JS developing in huge project for my company. After I made the switch to jQuery my development time has quite literally been cut by half. DOM traversing is easier (I can't edit the original HTML and there are virtually no classes and very limited IDs, so jquery is a godsend). I can't think of a single project I have done where it made more sense to go vanilla.
&gt; First off, this is patently false. How so? From the horse's mouth: http://www.youtube.com/watch?v=Rj49rmc01Hs#t=1m45s . I didn't just make that up. &gt; Would be more javascript-ic by using chainable functions, rather than passing random garbage to a single function. My example *is* using chaining... Maybe I'm confused about what you're saying. Are you saying it would be better if, when you specify a parameter, it adds a function with that name to the 'v' object? Also, to what "random garbage" are you referring?
When is `this` outside of `gallery`? *I think one out of the two of us, is confused :)* Are you referring to how the chainable method `addPhoto` returns the gallery object? There's surely nothing wrong with that -- chainability is surely an accepted practice, right? Surely there is no difference between passing `this` itself, over passing a reference to `this` (a synonym like `gallery`)? Other than that basic chainability, I don't see any other way `this` is escaping the gallery object.
That's mprogress, the internal code name for Pace before it was released. It originally was a take off of trying to build an nprogress which didn't require manual updating.
https://news.ycombinator.com/item?id=7086201
I tried this with Chrome on my Mac as the receiver, and my iPhone as transmitter, and it didn't do anything. Should I be able to hear the audio signal, or is it outside the human hearing range? There are definitely some Web Audio API differences between mobile Safari and Chrome for Android, so it might be that… Edit: Tried again and it works. wacky.
True enough. If the further subclass doesn't chain to the constructor it will fail both cases, though at least it will fail fast for the Object.create case which is a definite advantage.
Fez looks pretty interesting. I haven't dug deeply into it yet, but I'm liking it better than Gulp (the other new build tool that's been getting a lot of attention lately): 1. Fez is more pragmatic. It has a strong ideology, but it also tempers that with escape hatches for when your needs don't fit that ideology. 2. Fez's pipelining is really simple and elegant. Gulp's pipelining is verbose and it's easy to forget to return the stream, which leads to race conditions. 3. Fez has dirty-checking so it won't run tasks on files that are up-to-date. 4. Task functions look much simpler to write (and thus, less error-prone). If you're interested in the dirty checking and rule-based approach Fez uses, [Jake](https://github.com/mde/jake) has excellent support for this approach as well, and it's nice and mature. Here's a few things Fez seems to offer that Jake doesn't: 1. Automatic concurrency. Like Gulp, Fez's subtasks run in parallel. It looks like Fez launches them in subprocesses in order to prevent conflicts, which is a good idea. I'm skeptical of parallelism in builds, though, because race conditions lead to nasty, hard-to-detect-and-fix bugs. I don't think the theoretical speed boost is worth the potential of defects getting into released code. 2. Automatic pipelining. Also like Gulp, Fez can pipe the output of one operation to the input of another. This is useful because you can avoid dealing with temporary files. Unlike Gulp, Fez has an extremely simple and non-error-prone way of constructing those pipelines. I like it. The major advantage of Fez (and Jake) over Grunt and Gulp is that they use file timestamps to tell if a task needs to run. This can lead to major speed benefits. I recently modified my Jakefile to use this sort of dirty checking on my Sass compiler. I don't change my CSS that often, but the css task was doing an expensive "shell to Ruby" command on every build no matter what. Adding dirty checking shaved my typical build time down from 6.5s to 3.5s. Overall, Fez looks like a really nice tool. It has a strong ideology (rule-based transformation of files) tempered by a nice dose of practicality. For example, although Fez wants every task to define a file-transformation rule, it also supports "imperative mode" for tasks that don't fit that model. It's very promising, and I'm looking forward to learning more. 
Fair enough - so to be clear this is your requirement for saying a language has classes? Only languages with Metaobject Protocols can be considered as having classes?
Tried it in chrome, but frame rate was horrible.
The spaces in their code highlighter make everything confusing
Update Node &amp; NPM and try again.
http://davidwalsh.name/pseudo-element &gt; Written by David Walsh on April 2, 2013 Why haven't I been able to find this *anywhere*?
The interesting detail about point-events:none is that those events go right through the element. So, you can, for example, put a div with a translucent gradient above some links or whatever (e.g. for a fade-out effect) and those links will still work as usual. As far as any mouse-related interaction is concerned, this div doesn't exist.
You should probably post this in /r/node. I wasn't sure the use for this until I saw it was a node object. That said, I like the idea and might use it in the project I'm working on to give some better info in errors.
Thanks for the heads up. Yes, this is probably not very useful outside of node.js. However it has no dependencies other than ES5, so it should even work in browserify if you need HTTP status errors for some reason (in an AJAX library maybe?).
I might have to give this a try. I really hate Grunt and Gulp.
If I'm understanding the code correctly there are 13 available symbols but if we needed to use binary data we could assign 8 of the 13 symbols to represent bits ranging from 000 to 111. By OP's recommendation we should transmit a symbol for 200ms. This means that you could send 3 bits every 200 ms which would give us a bandwidth of 15 bits per second.
So it's a less-powerful version of [sonicnet.js](https://github.com/borismus/sonicnet.js). Also, i don't know about yall, but I've had horrible luck with both
Spent some time yesterday evening on this. I had been meaning to roll my scripts with require a for quite some time but hadn't any urgency other then it seeming like a solid scoping/dependency handler... didn't realize it handled templates as well. A little more retrofitting left but It definitely looks like it fits my use case. Thanks for the nudge in the right direction.
Interesting. Any possibility you could hook this up to a POS system?
I'm not so sure about lazy-loading stylesheets. Why? They load asynchronously anyways. I suppose there are some cases where you might want to take action after the sheet has loaded...
Win 7 x64 - Athlon II X4 640, 9800 GT, 16 GB. (I forgot to cpu on my lite coin mining the first time), but the HUD keeps getting to shoved to the top or just disappears. 
Noob here, how is this different from using jQuery's Events?
Make sure you take an average of how long each test takes to run. Currently, you're only getting the speed of one test. Secondly, your lookup method can have a factor in how fast your loops also run: http://jsperf.com/object-keys-iteration/3 Since you're using nested loops, the lookup for that inner-loop can have much more of an impact on time. Personally, I'd use a single loop and run it multiple times. Then get the average of those times as that would be more indicative of performance.
I think you're on the right track. This mechanism can be tweaked to work with Node.js or even used to share code between client and server JS code by changing the anonymous function parameters.
Also seen but not tried: https://github.com/Katee/quietnet
Awesome. Thanks for the feedback.
On my tablet, so I can't look at the code and confirm, but it probably IS using jQuery events. The distinction they are making is that this is how everything in the framework communicates. So instead of directly calling a function on another object by reference, you trigger an event and the object reacts. Backbone promotes a similar model.
I sort of found the answer, but would like feedback on the linked git hub project
Oh! Fascinating! Thanks...
Yes, definitely use IIFEs to wrap your code. Unless it's a very trivial script/project, I like splitting my js up into multiple files using npm/CommonJS style module definitions and [browserify](http://browserify.org/) to package it for the browser. Set up a task runner like [Grunt.js](http://gruntjs.com/) or [Gulp.js](http://gulpjs.com/) (my new fav) to watch your files and run the browserify compile on change. Here's an example, IIFE's not shown. Main entry point var foo = require('./lib/foo.js'), bar = require('./lib/bar.js'); foo.thing(); bar.thang(); // ... In lib/foo.js module.exports = { thing: function(){ // DO A THING } // ... } In lib/bar.js module.exports = { thang: function(){ // DO A THANG } // ... }
The pattern I usually end up with: myClass = function(opts){return this.init(opts)}; myClass.prototype = { init: function(opts){ /* ... */ return this; } }; Btw. the second solution will not work in older versions of IE. Also, if you want, you can also remove the requirement for the new framework if you define function myClass(opts) { return this instanceof myClass ? this.init() : new myClass(opts); } instead.
In the article, they're doing Cat.prototype.constructor=Cat so that anything that extends from the Cat object inherits all of Cat's properties. Otherwise it would be extended from Mammal in which case would not inherit from Cat. I feel like I'm making sense and not making sense at the same time.
Looks good. You're halfway there for [UMD](https://github.com/umdjs/umd).
"curl" is not Javascript, it's a Javascript library. Even this blog ("This blog lazy loads PrismJS...") loads it from http://davidwalsh.name/wp-content/themes/jack/js/lib/curl/src/curl.js?v1377886924147. Git: https://github.com/cujojs/curl
seems not to work in firefox (v. 26)?
I wrote about this recently. Hope it helps: http://mrjoelkemp.com/2014/01/javascript-an-exploration-of-prototypal-inheritance/
As I explained elsewhere, I acknowledge that people are now using the word "class" pretty-much interchangeably with "metaobject," with or without protocols. People tell me that prototypes are classes. A keyword that is syntactic sugar for prototypes is a class. And so on. So, I'm not going to say anything about the word "class" any more. It seems meaningless to say that JavaScript doesn't have classes, or that it does have classes. I'll go further: I have a hard time imagining a language that has objects but is designed in such a way that everyone would agree that it does not have classes. For example, `Self` is described by its designers as being class-less, yet it has classes in the same sense that JavaScript has classes.
&gt; Sadly, the global object is unique in this respect, because the same assumptions cannot be made about any other scope. Local variable declarations are unobservable, and we can only keep track of properties added to an object or defined on its prototype. I have always felt sad about this lost opportunity. Having a global object that can be inspected and modified via `this` inside functions called in global scope can be the source of bugs when you aren't operating in strict mode. But if *every* scope operated this way, you would have some benefits that would make this more of a design tradeoff than a loose floorboard. [Scheme](http://sicp.ai.mit.edu/Fall-2004/manuals/scheme-7.5.5/doc/scheme_14.html) works like this: Environments are first-class objects.
Fantastic demo on the project page.
I looked at React. Meh.
&gt; I'm not a fan of changing the core concepts of the language -- if you are, you should probably just be using a different one altogether. I agree with this statement in general. For example, as much as I like using first-class functions in general, I use them in very simply when I'm writing Ruby. Things like combinators aren't a good fit with its model. JavaScript feels a little different to me in that it's very spare and small compared to a language like Ruby, Common Lisp, or SmallTalk. To me, this encourages building things upwards from what it provides. It could be a question of scale. Some mechanisms are very heavyweight for a feature on a web page, but might make sense if you're building out a large web application on Node. But in general, I agree with your cautionary comment and always ask myself, "Am I cutting with the grain or against it?"
&gt; My example is using chaining... Maybe I'm confused about what you're saying. Are you saying it would be better if, when you specify a parameter, it adds a function with that name to the 'v' object? Also, to what "random garbage" are you referring? What I'm saying is, the "Javascript Way" is to create a query object and set mutators on that object, rather than a single, catch-all function that can take any parameters and guess what you mean. Just as a for-instance.