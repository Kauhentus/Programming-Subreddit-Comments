Do you have to draw into a canvas? Why not use any other drawing app that lets you output to something like a JPG/PNG and presto! No code needed.
I tried polymer back when it was 0.5 to 0.8, and stopped messing with it just after it's 1.0. It's pretty heavy, and at least back then the docs were pretty rough (which I understand has been fixed). Getting something up and running in polymer takes a lot more, and it takes a bit more wrangling to work well with a module system (although again, they could have cleaned that up since I last touched it). Also, Polymer is VERY opinionated. I consider that a good thing for a framework like this as it enforces structure very well, but know that it's difficult to incorporate into projects that didn't start with it, whereas i've been able to convert shitty-home-grown-framework™ apps into a functioning react app in days. But at the end of the day I felt like it didn't give me anything that React didn't. Using 2-way binding is chaotic, and after using something like react that gives me so much control and lets me test things so easily, it is tough to go back. I will say one thing about polymer, the Polymer team seems to be making tooling a first class citizen. Vulcanize, the web-component-tester, and other tools are being developed and maintained along with polymer, and using them together makes for a nice experience. It was much easier to get my first component fully tested in polymer, but it was much easier to do the 2nd through the 100th in react...
Even if you aren't, you're probably bundling or minifying. It's not transpiling at all, but it's still something.
I consider the book fairly outdated and the idea of ignoring language features because someone said it was "bad" a sign of laziness. If JS is your main language, understand it well, *even* the parts that you consider warts (you might not after learning them well!).
Post something related to JavaScript on /r/programming, you'll get a ton of hate!
Here's my experiences: I first tried it a bit when it was in 0.8. My first real project with Polymer used 1.0, and I've done a few projects with it now. I disagree with some of your points. For example, you don't need to use two-way binding, Polymer supports one-way binding (in fact, majority of bindings should be one-way). I also feel like getting started is quite easy, it's at least not more difficult than React. It's also possible to use Polymer quite similar to React. You can use one-way binding everywhere and use Redux too. The rough edges with Polymer are currently things like using a module system / loader like you said. The solution in my opinion will be &lt;script type="module"&gt;, we just need to wait for a polyfill now that the spec is finalized. Polymer's biggest feature is that it's based on native custom elements, and from what I understand the browser specification for those has been finalized now too. I expect that in the future you can choose from a number of frameworks to implement your custom element, and they all work together.
Know the pillars of JS and you'll be happy
You need to pick if it's broken or not already. F500 companies running broken MySQL? Don't make me laugh. All these companies are so WRONG! http://www.mysql.com/customers/ and should listen to you!!! "MySQL is our core data store that we used for storing all data that powers the site as well as the metadata around the users." San Lambert, Director of Technology, GitHub OH NO GITHUB USES MYSQL! ALL OUR CODE WILL BE SILENTLY TRUNCATED. I think you need to re-read what you think you know about modern MySQL. 
Even in your experiences, there are too much words like "polyfill for this", "polyfill to that, not yet fully specced", "will be solved after we wait", etc. From what i see, its too much bleeding edge to reliably use it aside from small projects. 
FWIW, I'm far more productive in javascript than in python or php, which are my other primary languages. While it's true that the correct language to choose depends on the problem, javascript is great for application programming where performance is non-critical, and iteration is necessary. Another thing I love about javascript is that it respects the developer. It's like php in that it gives you plenty of rope to hang yourself with, but it's also a very multi-paradigm language (even more so than python I'd argue). You can do OO, functional programming, procedural spaghetti, or even good old-fashioned early-2000's web-scripting if that's your thing. It's what you bring to the table that shapes the quality of what you come up with. The one thing it's really missing is a good type system. But if that's a big deal, TypeScript is a great alternative. The most-complained about aspect of javascript I've seen is how it handles the nuts and bolts of equality and types, as well as the DOM api. But with the right utility libraries, you can almost entirely forget about those problems. Also, if you want to feel downright inspired, and get to know javascript at a deep level (which is where it really pays off), read [javascript allonge](https://leanpub.com/javascript-allonge) - javascript is really a lisp in disguise; discovering this, along with some functional techniques made me really fall in love with the language.
Why is this such a terrible idea?
Lambda scope === closures?
Did you send them that $3000 they were asking for?
I'm surprised how, let's say, not well Meteor is doing in comparison to the others. They were the first framework in all of these lists I tried and started diving into and it seemed very compelling even in those early stages of the framework. Personally, I've been really digging Ember. It's my go-to at this point, and I've been trying to contribute help in the slack and some PRs to the auxiliary packages, fast boot especially. I'm a big fan of hbs. Always have been since the first express tutorial I did swapped in HBS instead of Jade. I've not had a chance to work much in React. I've helped a few folks troubleshoot apps and, if you understand the idea of these frameworks and JavaScript, it's easy enough to find your way around. The pragmatist in me wants my next side project to be a React app just to get a better feel for it though. 
Javascript is not as fully flushed out as other backend OO-languages (C#, PHP) but it's a necessary requirement for doing any type of front-end work and integrating with APIs. And with ES6, node, and the rise of typescript, Javascript is probably one of the must lucrative languages to know in depth.
Yea, the first argument of drawImage can be pretty much anything - even an SVG, a video, or another canvas(!).
Thanks, this is very helpful. I guess what I'm wondering is what is object.create doing exactly, if not just setting this.prototype = That.prototype? 
Almost every modern project uses Babel or some other transpiler.
Almost every modern project uses Babel or some other transpiler.
&gt; It doesn't do oop like those languages Well, it does do OOP in its own way. But things have (happily) been leaning for awhile towards functional programming in JS.
My desktop installation of Linux didn't come with a JS interpreter, a browser, nor even a GUI. Just came with a package manager and GNU tools. (of course, I know I'm being pedantic, and feel free to not respond to this)
Seems like a nice project, but can you shed some light on why I wouldn't just use ng2 or react/redux in place of this?
Out of interest, what "desktop" distribution doesn't include a web browser in its default installation? These days the definition of desktop is that you can view cat pictures on the internet.
more like jupyter notebook
Why is React so popular? Why do people use it? What happens at the end of the fad chain I feel like it's currently on? I hear really mixed opinions about mixing logic and markup and would really like some objective viewpoints on this. I would hate for us to get 5 years down the road and see all React apps as the crustiest things in the world.
That's the one. I've never used it, but I came across those a lot as I was learning python
As someone said elsewhere, it's still written in Java. We use GWT to convert it to JS, and we only got that working recently.
Most of my work has been freelance work for small clients, but I am looking for full time work right now. I have used npm for certain things, but not regularly.
[Inkscape](https://inkscape.org/en/) can save your drawing as javascript code to draw into a canvas. You just need to `Save as HTML Canvas` [Here](https://gist.github.com/anonymous/b5a06535a043f9c880ce3fca73a5d2ea) is an example of the output, you'll see it puts comments in with your object names. and [here](http://htmlpreview.github.io/?https://gist.githubusercontent.com/anonymous/b5a06535a043f9c880ce3fca73a5d2ea/raw/e18ddf738c33366d2c388ca873e04ba4f314141a/test.html) you can see it rendered.
I am legitimately curious what makes you think Javascript is better than Ruby (also python, but I don't care for python all that much so doesn't mean as much to me)? Edit: As a language. Obviously like you said javascript is the way to do frontend web.
&gt; JavaScript can be super simple, or super complicated - it all depends on the application requirements. FTFY
The stampeding herds of framework fanatics. Do you hear the faint clopping in the distance? Soon you will hear also the drums of war, pale yellow "JS" heraldic banners asway in the breeze of this red letter day. The vote is compromised, word has leaked, and they are coming. Soon, the March of Unkempt Developers will grow to a thunderous din (mainly of minor complaints on style issues or module export format), and those of us who dare use Vue, Backbone, or lesser known JS frameworks (les frameworks du resistance!) must burrow down and go dark lest we are captured by React's veritable Genghis horde.
It's only an opinion but i think React allows you to very rapidly have enhanced HTML as opposed to having to then write some jquery or vanilla to get the level of interaction. Now with this said it's easy to bloat it up with logic and abuse the sweetness of it, and end up quickly with unmaintainable code. It takes some thinking, maybe experience too, to properly separate the concerns. One thing I think is that it's hard to have a proper look back on what you are building and you must advance knowing you are not necessarily making the best choice, but then again you can't know that most of the time and need to often refactor any code. One last thing is that react doesn't provide you the application state layer and you need another solution on top. 
yea
Personally I don't see the need for most of them. Babel is different given that isn't a workflow tool. I think a lot of workflow tools are premature optimization. Things that you should only need to do once before you release into production. However there is a somewhat dying trend of needing different preprocessors, coffeescript, less or sass, etc, that need scripts run at each save. Which is terrible. This is JS, you shouldn't need to compile anything. This is where workflow tools come in. 
Alright, I'm beginning to see... If I wanted to use pre-processors or had to push to production daily, then I would want to automate all the things that entails (preprocessing, minifying, other tools) using gulp/grunt. But if I'm working on an infrequent development to production, and had no preprocessing, then gulp/grunt is unnecessary. Or if I had just some preprocessing, there's probably a more appropriate tool than gulp or grunt. And pre-processing/minifying/other tools depends on my workflow. Which, again, would not really be necessary if I am not implementing them frequently - as I could better optimize things on my own, as a human, at each push to production. I'd like to hear more opinions! In agreement or disagreement!
Hi /u/feketegy, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
I think this might be the wrong subreddit for this type of post. A more relevant subreddit might be /r/learnprogramming or /r/learnjavascript That said cool that you're learning, first off, I would probably try to seperate the data from the code, you can do this either by defining JS objects somewhere, but even better, you could do this by loading a JSON file and parsing the content of that through your code. This makes the code more manageable, and makes it a lot easier to add new data. I would also look into using [ES2016](http://www.ecma-international.org/ecma-262/6.0/index.html) syntax, as the entire JS community is rapidly adopting it everywhere. Finally I would look into using more descriptive names for your functions, and/or writing inline documentation for it. Also, as with most programming, it's always a good idea to create some automated tests of the code, this way you know new code won't break what you've already built. When sharing code, it's also a good idea to use a code sharing tool, like [gist](http://gist.github.com/) or [Codepen](http://codepen.io/pen/), as it provides syntax highlighting and structure that helps others understand the code more easily.
That is *exactly* what I was looking for. Thanks for this. 
gotcha gotcha so if the value that's returned by this is not in that range for any of the three angles then we can safely say it's not a triangle? (m.pow(a,2) + m.pow(b,2) - m.pow(c,2)) / ( 2 * a * b)
Great response. People like to talk shit on the language and even the community, but honestly you would be hard pressed to find a language with a better ecosystem of both extensions (modules) and educational materials. Thanks to Node.js, you can use JS to do just about anything you would with most other languages in a fraction of the time. Not only that, but it is just about everywhere and is constantly improving. My opinion on it, coming from an OOP background; yes, it can be funky, really funky, in the way it abstracts over things. The issue I see is that it's a language that is really easy to learn the "wrong way" because of its low barrier for entry. However, this flexibility allows for creativity in design patterns that has spawned some really cool ideas. When approaching it, make sure you really dig into the fundamentals of how the language works down to the roots. There are two really great tutorial series by Anthony Alicia that I recommend: * Learn and Understand JavaScript: The Weird Parts * Learn and Understand Node.js On mobil, don't judge my spelling =)
Version 52.0.2743.116 m, "Google Chrome is up to date." Windows 7, 64-bit. And the only reason I even checked Chrome is because another user reported this issue with one of my userscripts. `if( ! Promise.resolve ) { alert( 'nope' ); }` fires in Chrome but not in Firefox. Autocomplete in the console does not offer `.all`. This issue isn't just me and isn't just a goof. ... hang on. It works in this tab, but not the tab running the userscript. What the hell?
I agree to a point, but the use of npm packages has become out of control for many companies/projects. I had a project that ultimately downloaded 26000 deps from npm to spin up. That's ridiculous. 
&gt; Why is React so popular? I'm wondering that also. I haven't used React yet, waiting a bit longer to see how Angular 2 turns out before I jump on that or React. But I'm surprised at React's popularity. Something I like about Angular 1 is how much functionality it provides*. When I look at React I'm confused by the choices you have to make (Redux, Flux, Alt etc.). For some reason that seems to be widely accepted, but at the same time there's lots of complaints and endless "JavaScript fatigue" blog posts about the overabundance of choice in other cases e.g. build tools (Grunt, Gulp, Webpack), testing frameworks, package managers etc. There's so many parts being glued together now in frontend development that I'd like by main JavaScript framework to be more stable than React *seems* to be. Note that I'm not seriously bashing React here because I haven't used it at all so my criticism could be complete bullshit. Maybe it's not as bad as it looks. I'd be interested to hear opinions from people who actually use React. --- \* I know someone will say "Angular is a framework, React is a library". But I mean the React ecosystem. I assume very few people are using JUST the React library without other things to go with it.
Nice and easy to read examples of how to use proxy! I've added it to a resource collection I've been gathering over a couple of months: https://github.com/mikaelbr/proxy-fun/
An open survey is not really a good way to measure usage and feedback anyway, especially when their only methods of promotion is social media / word of mouth. They should have atleast measured some demographics to give contrast with the diversity in background for developers answering these questions. 
No, lambda scope is the big concept or feature. Closure is a product available because of that feature.
About a year ago, I decided to only write vanilla js until I felt confident with the language. I just started getting into libraries and frameworks about 3 months ago. Going this route was the best decision I could have made. Aside from the obvious reasons, every time I try a new package, my mind is absolutely blown by how powerful and time-saving it is. After writing vanilla for so long, I feel like this is a whole new world!
A language is only as good as the people who write it. There is some really beautiful code (somewhere, probably) written in Perl, Cobol, and PHP. And there's undoubtedly terrible crap written in Erlang, Clojure, Smalltalk, etc. It's possible (and not hard) to write very good, reusable, maintainable code in Javascript. Given the available tools and developer base, it's absolutely not "wrong choice" for many web projects. A better question to ask is who wrote the code base for the project you're on, what's their design philosophy and coding practices? That will determine your level of happiness or frustration much better than anything else.
I don't think "56% of Angular developers wouldn’t want to use it again" is a fair observation, because the question was worded "I’ve used it before, and would not use it again" because what qualifies as "used" in the context of this question -- the tutorial, one custom app, multiple custom apps? I'd imagine most people who self identify as an "X framework developer" would want to use that framework again - but then there's also me and I identify as a Django developer but i really don't like Django. But that's extrapolating from an incomplete data set, too. 
I've used Arch, and Gentoo for that matter. I think describing the base image of either as "desktop" Linux is disingenuous to say the least. You almost-definitely can't count it as a desktop Linux installation without a browser, and you definitely can't without an X client.
I didn't realize people talked bad about JavaScript (besides people who don't know it). Doesn't everyone love JS? It's everywhere nowadays...
webpack isn't a task runner. It has nothing in common with gulp or grunt. I think the reason they're often confused is that gulp/grunt was often used as an interface around some other libraries (browserify, Sass, etc) that would concatenate/transpile/minify/whatever your code. Grunt/gulp would handle dependencies between those tasks and send the necessary files to the relevant libraries. However, if you use webpack, it's handling all of the CSS/JS/image stuff, so there's not really much left over to do in most projects. Often the remaining jobs can be taken care of just using npm package.json scripts, or just plain .js scripts. Nothing stopping you using gulp/grunt to call webpack though.
Oh yeah, that's not to say it's not utterly absurd (something something left-pad). But I mean, if used judiciously, it's a lifesaver when you're spinning up teams. 
P.P.S. In defense of Backbone, and libraries like it, I should mention that it's entirely possible to follow modern best JS practices without React. I worked on a Backbone application for several years (before converting it to React), and there's absolutely nothing stopping you from favoring composition over inheritance, having discrete components, or keeping state in a separate store (heck you can even use Redux with Backbone if you want). But the problem is, Backbone gives you a powerful toolkit and says "go do whatever with it". Many people have had poor experiences with Backbone precisely because the library gave them enough rope to hang themselves. For instance, the library's class system is awesome (especially pre-ES6). However, there's nothing in the Backbone docs about composition (they don't need it, since you can compose stuff with plain JS), and mix-ins are second class citizens, so you naturally wind up building standard OOP class hierarchies that are more brittle than composition-based alternatives. As much as I &lt;3 Backbone (and I really do; I wrote a book on it!) I think React's approach of structuring your natural flow towards best practices (without being pedantic and trying to force you to do anything) is a key reason why it's flourishing and Backbone is dying off.
Nice fiddle example and great use of data to drive the end result. Id recommend OP to take a good look at your code but it might be over his head if he is a beginner. The code is good for sure but requires a larger understanding of `this` scoping, `prototypes` etc. The one thing I could comment on that may not be 'kosher' is your use of '==' over '===' but if you are careful with types in-&gt;out its probably not really an issue in 99% of code.
I just tried "Promised.resolve" and "Promise.resolve" inside a console in a Blank page using Chrome 52 - Windows 8.1, and both things returns a function. Do the same, and you can start discarding if your app is overwriting something in some place...
https://www.youtube.com/watch?v=bo36MrBfTk4
All those languages you mentioned are 25+ years old. Java and JavaScript are over 20 years old. They accumulated quite a bit of cruft. Java 1.4 (2000 - before generics, enums, autoboxing, metadata, and varargs) was a small simple language, for example. There really wasn't anything to it. ES6 is massive in comparison. Lots of syntax. Lots of quirks. Sure, it's much simpler if you stick to a subset, but all that other stuff is still there and you still have to know how it works. You've to know why you aren't doing something and you've to deal with other people's code, too. If you use TypeScript, like I do, there's even more syntax. But I think it's worth it. If you use a subset of ES6 and most of TS, you get a fairly decent language with good tooling. As a lousy architect, I've to move code around quite often. Without the compiler covering my back, this would be really scary and messy. Anyhow, the point was that while the language itself isn't that simple, using it (or its offspring) doesn't have to be difficult.
I find the biggest need for preprocessors comes into play quite quickly on anything but the simplest apps due to JS (in the browser) having no native module system. So you either put it all in one .js file (hard to maintain), split it into separate files (lots of requests and you have to worry about dependencies being declared in the right order), or you use a preprocessor to handle that for you.
Is canvas crack or something? I'm on codepen for a while and all i see is canvas stuff! I didn't even touch it yet.
You need to fix your whitespace, sir. Then the difference between these two becomes extremely clear. for (var y = 0; y &lt; affixes.length; y++) { if (y === 0) { // do stuff } if (typeof statstuff !== 'undefined') { // do stuff } } for (var y = 0; y &lt; affixes.length; y++) { if (typeof statstuff !== 'undefined') { if (y === 0) { // do stuff } // do stuff } } 
The book series [You Don't Know JS](https://github.com/getify/You-Dont-Know-JS), which is open-source on GitHub with about 40k stars, is highly regarded and does a fantastic job of explaining some of the concepts that can be troublesome when coming from other languages.
Every toddler knows about the event stream, and will be able to relate to standing in the queue at Starbucks for the morning mocha.
&gt; typeof statstuff !== 'undefined' foo !== undefined is fine. The global undefined, NaN, and Infinity values are readonly since ES5. If you don't create a local undefined variable, undefined will be `undefined`.
A userscript which does nothing but test Promise.all or Promise.resolve fails to find either. It's purely a userscript issue, apparently. Either Tampermonkey is screwing with Chrome or vice-versa... in a very specific and bizarre manner. 
It certainly isn't a Chrome issue. It's either caused by Tampermonkey or by the page you're running that script on. Run it on about:blank or something and you'll see if it's caused by Tampermonkey.
I don't see a need for accessing variables which weren't defined. I would have gotten a squiggly line immediately. I would have seen that "bob" isn't defined. I've never seen a use case for that typeof guard.
What do you mean by hashtags and agency design, and also wes bos brogrammer?
&gt; What's small is its standard library Which is ironic considering JavaScript is the one language where you really do want a very extensive standard library, so that less data has to be transferred from the server to the browser to give JS functionality that it needs. Of course, that leaves the issue of really fragmented support for the standard library across different browsers, but it would still be nice not to have to pull in lodash.js or moment.js and worry about their impact on the size of your response.
Doesn't that error only happen in REPLs?
Do you want to print all properties of "item" or just those properties whose names happen to be in that list?
Why not a for/in loop over the item object?
I hate this so much it almost physically pains me.
Honestly? Modern web dev focuses on developer experience, not user experience. Hideously slow and buggy solutions are praised if they're sufficiently easy to arrive at. Basically, you get paid a lot and you can't fail.
This story begins about 10 months ago - we were building the front-end piece for the product of our new startup. Prior to that I'd been doing full-stack dev work with Angular for front-end stuff. I'd been using Angular for just over a year at that point and felt pretty proficient in it. But then you run into the typical issues with Monolithic Angular apps... Somewhere along the line the framework wars really started to pick up. Angular 1.5 came out and the community recommended it as a way to transition to Angular 2. I'd already been writing as much as I could as self-contained Directives, so moving to the Component model felt natural. I quite liked Angular 1.5, I could've just stuck to it, but all the framework hype really started to get to me. Somehow I was convinced that I needed to move to Angular 2 or React because it was "the right thing to do long-term". So I looked into Angular 2. I decided it wasn't for me as the cognitive load to pick up Typescript + the other stuff just felt like too much. So the alternative was React, because, hey, that's what everyone was talking about. So I tried React and used it for a month. It was good, but it made me miss working in Angular. I liked working with template. I liked separating JS, HTML, and CSS. I believe this separation of concerns is good. I know, I know, these words will get me stoned nowadays. *Aside* -- I come to realize now why I prefer to work with templates: it's because I visualize things from a design perspective first, then add in the code separately. So when it comes to by development methodology, I write the templates then add in the code to make it work as expected. So when I heard about Vue and it's philosophy, to me it just made sense. It felt like I was getting the best parts of both Angular and React. --- Fast forward to today and we've got a product with multiple clients built completely in Vue. Looking back at things now, I believe we could've stuck with React (or even Angular 1.5) to build our products. I understand this is a really rambly post that doesn't really answer your question, but off the top of my head, the two best things from Vue that I've seen are: 1. vue-cli is the most awesome way to get an app scaffolded and ready to go. This has been such a huge timesaver when starting out. Without it, I'd probably still have stuck with React as it made getting into developing production apps so much easier. 2. How much easier it is for less skilled front-end devs to pick up.
How exactly does this work? I'd like to learn what's going on here.
Glad that this was posted, I remember reading about it on Wired a week or two ago. Will take a look.
"to modify the language". "nowhere in the article does he mention" Those are exactly my points. 
&gt;Erosion is just one process, and the next obvious thing to add would be fluvial deposition, which would allow for flood plains, river deltas, etc to form. If you wanted more realistic mountains, then glacial processes would be worth looking at. Volcanic stuff could also be fun. Sounds like someones wants to go all "dwarf fortress" on this...
Javascript classes are popular because people are fucking retarded. edit: Oh, I see that everyone who uses ES6 Classes has found this comment. Downvoting me doesn't make me wrong. If anything, it proves I'm right.
&gt; why did they decide to add classes to ES6 To truly and honestly answer this question, we'd probably have to sift through the [standards committee's meeting notes](https://github.com/tc39/tc39-notes/tree/master/es6). Personally, I'm not motivated enough to do that. I roughly recall somewhere [Rauschmayer](http://www.2ality.com/2015/02/es6-classes-final.html) saying ES6 classes standardize what many libraries have already been doing for years but in mutually incompatible ways. Unfortunately, class critics will often invent reasons out of thin air that helps them justify their criticism, such as by saying, "people are confused by prototypes and don't want to learn new stuff." Make sure you check their source, because odds are good they don't have one and they just made it up. &gt; why didn't languages like JS with prototypes and behavior delegation become popular They did. ;-) Turns out JavaScript isn't the unique snowflake we like to think it is. Python has prototypes and behavior delegation. Ruby has prototypes and behavior delegation. Smalltalk has prototypes and behavior delegation. As it turns out, the biggest difference is only that we in the JavaScript community like to make a big fuss about it. &gt; instead of languages like Java with class-based OOP? This, of course, begs the question, "what is a class?" Kyle Simpson has made it clear in other discussions that he uses Java as the gold standard to decide what a class is or isn't, and what inheritance is or isn't. The problem, though, is that his definitions would also mean Python's classes are not real classes, that Ruby's classes are not real classes, that Smalltalk's classes are not real classes. And, by the way, both Python and Smalltalk pre-date both Java and JavaScript. Maybe Kyle made a mistake? Maybe using Java as the gold standard was actually wrong? At least a couple ECMAScript editors have implied or explicitly stated that the notion that JS classes are "fake" is incorrect. So how then could we define what a class is that accommodates Python/Ruby/Smalltalk as well as Java/C#/C++? Based on a tweet from Allen Wirfs-Brock, an ECMAScript editor, I think a good definition is: A class is a descriptor for an open set of objects that share a common interface and implementation.
https://jsfiddle.net/xqkay6vt/
Ahhh, thank you - I was just looking for how to do this. Most results were about fixing one's own patches. Hadn't thought to use a new iframe. I'll use your solution if I can't grab the property directly from the Promise prototype. 
its literally just abusing toString methods and indexing
I'm open to feedback but I feel like there's no wording that covers all possible scenarios, apart from being specific to the point of making the survey twice as long. Even with vague wording though, we can assume that at the end of the day, the results in aggregate provide *some* value. 
Huh I really wish I could explain my love for JavaScript. There's a little hate in there, but it's part of the love too. :p just read some good books, and enjoy the ride of coding in it. 
This is just awful. Doesn't surprise me that you're "making a game". I bet you plan to start your own indie game studio and spend the rest of your life making your own awesome games that everyone will want to buy and play? Truly pathetic, /u/robertx33 
I get so much satisfaction at looking over a codebase which is clean and follows the best patterns in JS. It's without a doubt not only the right way, but an awesome way, to code. Object composition is just great, and loving functional programming in ES6
Thanks! I have a five year old that understands OO pretty well but he's had trouble with this whole reactive thing. He's stuck on focusing on encapsulation and this really helped him get over the hump. This is perfect!
When Java came out there were a lot of other languages in the competing space, but Java had a huge company behind it that pushed teaching the language to everyone at the college level, and offered a lot of retraining workshops to people who wanted to use the language. Additionally, they hired all the best people in the virtual machine space to come in and optimise Java (e.g. they basically swallowed the entirety of the Self compiler authors to make Hot Spot). C# could have had a chance to compete had Microsoft done the work of getting it to work on every OS immediately from day one. Java did all that and additionally even worked in the browser with a plugin. Google back in the day used to write in Java then compile down to Javascript for some of their web apps (not Gmail though, I think). As for classes vs composition vs other---I think it's nice when an object oriented language has as many features for code structuring as possible. My ideal language takes all that, and cherry picks functional features like first-class functions, and the pipe operator onto that, then adds union types if its statically typed. 
I don't know how fair Javascript popularity is. It's the only thing that works in 100% of web browsers by default, thus everyone who even vaguely approaches a web app gets exposure to it. Actionscript was a competitor but acquired a reputation of being slow.
&gt; The thing is though that classes seem to make things more complicated and brittle than behavior delegation. Ah but that's your opinion, many people feel differently. Personally I think its better to have standardised classes in the language, than a dozen half backed class-like constructs created for everyones pet-framework. 
So would you say classes are more popular because of a historical inertia and not because the author is wrong that behavior delegation is the better pattern in most cases?
&gt; The thing is though that classes seem to make things more complicated and brittle than behavior delegation. Behavior delegation seems to make things easier to write and maintain than class-based designs. Can you show a specific example? I suspect you've been reading articles that grossly exaggerate the differences.
Thumbnail looks like the Daesh flag!
The entire chapter i linked covers it well if you want examples. I'm not personally experienced enough to make the argument. It's this particular resource (which is highly recommended) that got me thinking. 
My kindergarten CS 201 class taught currying on the 1st day right after free play time 
I think age, general location, type of employment (freelance, full time etc.), primary role (front end, full stack, etc) and affiliation(yes/no about whether they are affiliated with framework's authors) would be most important to know, make it optional if you are worried about privacy concerns. It's just difficult to say how accurately the results represent the field, when you don't know who is taking the surveys at all. Very easy for these things to get skewed considering people are sharing within their own circles.
Um, be a jerk much? What value did this bring to the conversation? If you don't like people learning and being, well, people just move on and read the next post.
Lol. Holy crap that was not ELI5. Still not sure what reactive programming is. 
&gt; more enjoyable one to program in i find it easier to debug. There is no magic hand waving when using a library. you just straight up read the source code and understand what happens. not sure how angular or specific piece of react work? just look at the source. Cant do that with java or C# (for proprietary libraries..and its painful to get the Open Sourced libraries open) 
came here to say this. Objects are mostly used as a container for holding functions or data. unless you're using a framework, you'd be hard pressed to use any sort of inheritance in javascript. 
Awesome answer. I certainly learned some things. &gt; This, of course, begs the question, "what is a class?" To raise the question is not question begging. http://begthequestion.info/
I just have to say that this is probably one of the nicest, most well-reasoned, and thoughtfully worded criticisms of React (and for that matter, the "newer" set of front-end technologies) that I've seen in awhile. For what it's worth, I appreciate that. :) You raise a lot of good points with legit technical merit, but you're doing it without being an asshat, and that's really rare. Kudos.
Backbone fan sees results, sees that Backbone is only at 19%, goes and fills out the survey. React fan sees results, sees that React is already way ahead, doesn't feel compelled to fill out the survey. That's just one example.
Hi /u/Kerdaloo, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
https://msdn.microsoft.com/en-us/library/aa767914%28v=vs.85%29.aspx You have some work ahead of you, but it's doable. 
Dude this uses backpropagation to make a slider able to set some calculated value via modifying its input. That's pretty amazing. Why do you feel the need to downplay this?
The backpropagation thing is awesome and powerful enough to be a real game changer for some people. Everyone developing parameterized algorithms should benefit from it.
What Windows version are you using? I remember using it on default XP installs, and just tried it on a default Win10...
Weird. I'm on a regular (upgraded from 7) Win10. I do have the Windows Based Hosted Scripting program (or something like that, on mobile), but as I said it's not able to run the file. 
The group of people responding to this are definitely the cool kids group.
Looks nice! I've yet to use mobx, how does it compare to redux? How have you used lowdash FP?
People are not going to like the way I phrase this or my tone. But I think the tone is warranted due to the number of man-years wasted on this bollocks. First of all, JS _is_ popular, obviously. And to be clear, I have been primarily a JavaScript programmer for at least 6 years. Prior to that I did work for many years with a number of other languages. The 'prototype vs classes' etc. stuff is a bunch of bollocks. Every 'anti-OOP' JavaScript programmer uses something like classes, but just calls it something else and does it slightly differently from other people. But they ARE doing OOP and using classes, even if they insist on doing it in an awkward, ass-backwards way, and never admit it. And I know this is a fact because it is the case for almost every JS framework or application I have seen for many years. Object-oriented or class-based programming doesn't mean you don't delegate. The idea of delegation over inheritance has been popular for many years, before JS was even a big thing. The point of having classes is that lots of times you want to have multiple objects that do the same thing. If Kyle wants to say there is no 'class' involved even when he has 10 objects that use the exact same code, then.. well I'm sorry but that's bollocks. By the way, here is an example that takes care of an issue that can sometimes happen with (unbound) `this` if you don't do it this way (you will probably need babel): class Horse { gallop = ({speed, style}) =&gt; { this.pos += speed; this.style = style; } } See also https://github.com/runvnc/whyes6hasclasses How many man-years have we wasted with this crap? Say there are only 100,000 JavaScript developers involved over the last several years (it may well be an order of magnitude more). 100,000 * average of 100 hours re-inventing/arguing about/writing books on JS OOP semantics = ~ 10 million man-hours minimum / 24 hours / 365 days = _at the very minimum more than 1,000 man-years wasted_.
&gt; ({speed, style}) Why the "{}" here? (sorry I am learning JS)
I started using named parameters via destructuring because it is easier to read and less error-prone. http://exploringjs.com/es6/ch_parameter-handling.html
I'm not a beginner but I still do agree with your observation.
But how are they even calling toString?
Thanks for the link! This explains how to use it, but not what it is. I will google for it. Just to confirm: without the {} it would still work, right?
&gt; For about 10 years, it's also pretty fast. It still is, faster than node in a lot of cases too. https://www.techempower.com/benchmarks/
JS didn't become popular because of prototypes.
Huh? I just wanted to make something for myself. I'm a sucker for loot but i can't find an idle/active game with a focus on loot so i decided to practice javascript by making a game for myself. I don't really plant to be a game dev. You sound like i offended you though.
I thought it explained it pretty much. When they put stuff in curly braces like that they call it destructuring. You can use it in a few different ways. One way to use destructuring is for named rather than positional parameters. So instead of `function blaseblase({apple, orange}) {` you could just write `function blaseblase(apple, orange) {` but if you do it that way then you better remember to call it as `blaseblase(apple, orange)` rather than `blaseblase(orange, apple)`. If you use named parameters you can pass them in any order such as `blaseblase({orange, apple});`. So you name the parameters rather than passing them in a certain order. That also can help to make it clear what you are passing when you call that function (apples and oranges).
Just those who are. I saw a stackoverflow answer that's about using hasownproperty, but this seems very similar to my own undefined check. I thought there was a way to loop through an object without using all possible props 
Yeah, but OTOH hello world in java takes up an insane amount of memory.
Why is the performance so damn fking bad? Compare it to http://www.hellorun.helloenjoy.com/ which runs perfectly smooth on my Nexus 5.
Additional documentation (see 'Ajax Loader' and 'Ajax Sample Code' items) - https://shrinktheweb.com/content/pagepix-plugins-automated-website-previews.html
FYI that 'for loop' is called an iterator not a generator. Generator is another JS feature that is being added to in ES6
It's crazy, calling people retards, giving no argumentation whatsoever about your opinion and then blaming negative reception on butthurt people. What a useless guy, I bet he has the strongest opinion about brackets placement and indentation style.
Why did they decide to add classes to js? They didn't, the community did and all the new class keyword does is make easier the behavior already being done with Object.create, so users decided that their behavior. Because in a lot of cases classes are a pretty good way to do things that have more performance. More generally class based oop is actually pretty good and other schemes can have advantages but they arn't always without cost so can have additional complexity costs that out weigh benefits. 
This reactive programmings sounds like event-based programming. How is this new? I mean we've been subscribing to events for many years now and handling them as they happen. It's called the Observer pattern. Is this just an alias for the same? If not, can someone explain the difference?
I know! I mean it's my random item generator! I call my baby like that :3 
&gt; do you (personally) jump right to the APIs and start there ? Actually, yes. I usually check for the API documentation and get familiar with the functions or check out the example pages. I learn best from code or "code documentation". so I'm not a good reference here but I get your point. &gt; How do you organize those doc's? I have PHPDoc/JSDoc strings all over my code to document it and sometimes I create a README.md to be shown on GitHub where I manage my code. I'm a huge fan of "inline documentation" or the documentation pages that are rendered from it.
Because of use of complex 3D physics (softbodies). Hellorun doesn't use 3d physics.
the old form of begs the question is pretty useless and unintuitive, most people would just say "circular logic" to describe the same thing and even that sees so little use trying to preserve the original meaning of "begs the question" is kind of pointless.
edit: here's a one liner function openWin() { sessionStorage.getItem('session') ? : sessionStorage.setItem('session', true); window.open('http://google.com', '_blank') }
Yes. But supporting private repos seems still a bit "risky" to me as I have to invest more effort in security (I have to checkout the "sensitive" code). But it is great you asked (you're not the first one) and at some point I'd like to do it (maybe I have to take some money for that).
By adding (`+[]`) an empty array, there's details in the [GitHub repo readme](https://github.com/aemkei/jsfuck)
In my head (not sure if this is correct or not) the major difference is that Rx is pull based, rather than push based. So, when the consumer is available, it will ask for the next available event. This allows you to easily handle situations where the producer is faster than the consumer by implementing backpressure. In a push based model, a fast producer/slow consumer situation would in time consume all your resources.
TL;DR : [wikipedia article](https://en.wikipedia.org/wiki/Reactive_programming) is easier to understand
I'm not even sure if my framework would make sense if you jumped straight to APIs, considering you need to know patterns to actually build out any custom components (although there's tons of core ones ). We are documenting the APIs for all of our core components. But that's just one package in the ecosystem. I feel like there should be something to explain the overall architecture. And where to start, but it's hard to know where to start unless I know which feature the user wants to utilize first. :/
I'm not downvoting you because you are wrong, Donny. I'm downvoting you because you are an asshole.
Can you recommend a resource where I can learn about Ruby prototypes? Are They called something else in Ruby? Thanks.
Ah, ok. It looks somewhat similar to SAS. I am trying to research UNIX too because I'm a newb with that. 
Very few large projects will use the DOM interface and methods directly. Instead, they'll pull in a library or framework to help architecture the application and ease development. jQuery, for example, provides a great interface for manipulating the DOM. React, another example, provides a great way to describe the way you want the DOM to look without having to manually manipulate it at all. You've mentioned you're out of your league. What problems specifically are you running into? Are you finding there are specific tasks that you cannot accomplish using your current knowledge? Or is your codebase becoming too messy and unstructured? Either way, it may help for you to provide some examples of your own code.
They hate on it because its much more popular and easy to use than their less popular and largely outdated favorite language. Also, because they don't know how to write good JavaScript code. This is because they never learned the newest features. Use `babel`, take advantage of `async/await`, classes, destructuring, closures, generators, etc. There are actually lots of things about JavaScript that older less maligned languages copied from JavaScript to try to keep up.
Hey hey hey - I have opinions on those things myself. Although there is no right and wrong. But we had a discussion briefly amongst my dev team and we implemented some Lint and EditorConfig file rules simply to ensure that everything was standardized across all files. You can use whatever bracket placement you want but when you merge your work back into development branch using git you have to run Lint tools including the auto-lint handler which will fix 90% of the rule violations for you and the rest you can manually fix quickly since those violations are identified with line numbers and column numbers. This allows developers to work the way they are used to and perhaps most efficient at but also have a single format for the end-result codebase. 
cool maps - bad fantasy names though
The Airbnb code standards and eslint are very good - my dev team actually implements a slightly modified version of those to keep things clean, consistent and standardized across the board. 
Hi, In bigger projects they don't tend to manipulate the DOM directly but instead they use some JS framework to do so. In older days we used jQuery to shim away browser differencies but in some way that was DOM manipulating "by hand". In modern javascript we use so called templating engines. A prime example for such a templating engine would be handlebars.js which is a framework agnostic html templating solution. But angular 1.x have it's own templating engine which is very similar to handlebars. To provide an example look at this html snippet: &lt;div class="container"&gt; &lt;span class="red"&gt;{{ user.name }}&lt;/span&gt; &lt;/div&gt; Now you found out that `{{ user.name }}` is not a valid HTML property but instead this is a reference for the name property of the user object and user lives in javascript context. This is called data-binding where you can reference a javascript context value from HTML. &gt;&gt; ps: I'm not a big fan of such templating engines because it's much harder for me to read javascript code in HTML than the other way around. There are other solutions for abstracting away DOM manipulations like React, where we write ~~HTML~~ JSX in javascript files and the created markup will be bound to the body (or to another container) of the page. Let me write some buzz-words to get you going: "angular templates", "react jsx", "handlebars", "two way data binding" Cheers
Mostly my codebase is getting messy but it probably is a bit of the other, too. My problems may stretch beyond the DOM and using Javascript to build apps (as opposed to writing small functions to perform a simple task on a web page.) Since most of my apps so far have been little web applications I mostly deal with DOM, Javascript, CSS, and HTML. I suspect I will be looking into React in the near future. But for right now I wanted to get a good grasp of JS beforehand. Unfortunately I don't really have any published code except for codepens which are trivial in size. I'm working on some Github projects but I have these architecture/knowledge problems to overcome first. Some of the questions I had recently were: Should I be building the apps interface as static HTML or should I be building it in JS then inserting it via the DOM? What is standard practice? Should I be creating objects that handle only the view and build the HTML on the fly (I've used Model-View-Controller design with PHP in the past. Should I be emulating something like that in JS?) I've looked at JS projects like Adobe's Brackets to learn how to architect a javascript app but it was only so helpful because Brackets isn't really a web app. I guess what I am looking for are github projects that are web-based front end, Javascript-centric, and are good study examples. It may very well be that examples like this are hard to find because they are being built on other libraries like React? (something that is on my list of things to study.) 
The javascript irc channel has some strong opinions on the definition of "class".. they don't like the argument that js has "classes"
It comes from reading too many promotional items on the internet and the few articles on reddit before realizing that a few posts on reddit is virtually nothing compared to reality. You'll read a bunch of posts about some new tech and everyone acts like they've used it for years and are the current expert and you're an idiot for not having discovered it on your own years ago when the reality is virtually no one uses it, or some small percentage. Then employers and head hunters grab those buzz words of "must haves" but they are the worst at determining what's important. Then, next week, it's something else. Reality check: most people don't use React or Angular or any of those other "hot tools must haves". If one really needed these things, one would have sought them out. A good programmer would already have coded their own tools years ago. Funny: if you're not using Angular, you aren't shit, yet I see so many questions and posts about people struggling with it, I always say to myself, "If they just stuck to the basics, they'd be far ahead of the game without Angular." Or any other hot tool must have.
I use the console sometimes for this, just type `someVar.` and the console will list everything for you . http://imgur.com/a/GnbY3
&gt; None of these languages is prototype-based, they're all class-based with a fairly strict separation between classes and instances, although somewhat blurred by the fact that they all have metaclasses where classes are themselves instances: they don't implement automatic delegation between instances, only between an instance and a class, and a class and its parent(s for Python). I don't think that's right, at least not for python. From the linked article: &gt; This linkage is exercised when a property/method reference is made against the first object, and no such property/method exists. In that case, the [[Prototype]] linkage tells the engine to look for the property/method on the linked-to object. In turn, if that object cannot fulfill the look-up, its [[Prototype]] is followed, and so on. This series of links between objects forms what is called the "prototype chain". In python, any instance has __class__ which refers to its class, and each class has __bases__ which is a list referring to its base classes (python has multiple inheritance, unlike javascript). When a property of an instance is accessed, and the instance does not have that property, then the __class__ class is checked, and then the __bases__ base classes, and so forth. This sounds exactly what javascript is doing, do both as prototype based (though python uses a different name) (or neither is!) Granted python has has a "conventional" class syntax from the start, but underneath both are very similar. 
ive been doing web dev for 10 years, what i usually see is two patterns or MVC (framework). - classes/oop custom code. break it down to each reusable component and then wrap everything in a global object. ex: `Yahoo.Calender.init()` `MyCompany.Util.MakeListtoDom()` or `Yahoo.Dom.variousDomFuncs`. that is then initialized once per page and then you can use all your utils, and initialize the components you need. This pattern is also good if you want to start from scratch and build your own helper funcs. [like this: github](https://github.com/devmynd/practical-object-oriented-javascript) - per page scripts (one for each template) and a shared `helper.js` function. this is basically just write enough JS to make the page work, mostly using jquery, and write very page specific code. just save it in the template so its easier to find (imho) or make a `page-foo.js` for each page. optionally put resusable stuff in a shared `helper.js` file optionally you can put all your scripts into one file or not, but its up to the author how they like it.
&gt; That's completely different from Javascript or Self where you can set any random object as an other object's "parent" and see messages automatically delegated. True. Usually the way I phrase my original point is, "In Python and Ruby, a class is itself a memory-consuming runtime object, and inheritance happens by delegation," because those details are what some think makes JavaScript different and special.
But that's got nothing whatsoever to do with the original claim? &gt; a class is itself a memory-consuming runtime object That's got no relation to anything at all, and that's also the case in Java. Hell, to an extent that's even the case in C++ (except the memory it consumes is part of the binary you're loading). &gt; inheritance happens by delegation Delegation between class objects is what class-based inheritance is.
move your trial script import to below the button tag in your HTML. Javascript files get run when they are imported, at the point your file runs document.getElementById('save-btn'); will be undefined. I'm surprised you're not getting "undefined has no function addEventListener" in your console.
Thanks!
Just do a search on github and then filter results to code and language to JavaScript: * https://github.com/search?l=javascript&amp;q=%29.getElementsByTagName%28&amp;type=Code&amp;utf8=%E2%9C%93 * https://github.com/search?l=javascript&amp;q=%29.firstChild&amp;ref=searchresults&amp;type=Code&amp;utf8=%E2%9C%93 * https://github.com/search?l=javascript&amp;q=.appendChild%28&amp;ref=searchresults&amp;type=Code&amp;utf8=%E2%9C%93 * https://github.com/search?l=javascript&amp;q=%29.getAttribute%28%22&amp;ref=searchresults&amp;type=Code&amp;utf8=%E2%9C%93
It's not bad, really. I'd only do a couple things: - Use `join` instead of `toString().replace`, it's more semantic, and more closely mirrors the way you split the original string. - Usually if a function does dom manipulation, it's going to be unmaintainable (I don't know if that's a factor here). I'd put the text in the element outside your function, or factor that into another function. Here's a fork of your codepen: http://codepen.io/anon/pen/PzrogW
The code is assigning a handler to the page's load event. In other words once the load event completes that function (the second argument) will fire. This handler contains a setTimeout set to asynchronously delay an execution for 0ms (yes, its stupid... get rid of the setTimeout), which then changes the page's scroll position to the top left corner of the page.
thank you missing_goat, for nice words and suggestion.
I've seen code like that used in an attempt to hide the URL bar in mobile browsers. I don't know if it still works in modern mobile browsers, though.
Looks like the application was made in a certain way. I think you should let it be otherwise, you might see this: If you are scrolled down and you navigate to another page in the app, you would still be at the same scroll position and it won't reset to top, like it should. So, let it be. And that setTimeout(hideURLbar, 0); is also important, it delegates the function to run in next tick, so that everything else in the current tick after the page reload is complete and only then it's executed. So, it's well written actually. Let it be.
As missing_goat showed, you can get rid of the intermediary variables completely, but if you're gonna use them, the key to making your code easier to understand is to name variables well. We're not in the 70's, harddrive space is hardly an issue. A person reading your code will not understand what "ime" or "zec" stands for, not to mention something as ambiguous as "y". Don't be afraid to use long, descriptive, human readable variable names. Humans are who you're writing your code for. Humans are gonna be the ones to maintain your code later, and fix bugs. So change `ime` to `arrayOfWords`, change `zec` to `uppercasedArrayOfWords`, and change `y` to `outputString`. 
Yeah I know, I have opinions about that too but I dont consider people who disagree "retards" nor do I really care at all if we're not working together.
For the past few weeks I've been working as a student teacher for a web dev class. I decided to use the materials make a easy to learn tutorial for complete beginners. This one is basic JavaScript only and a few of my students thought it was really useful. Note: this account might seem like a throwaway but it's not. I don't want my actual Reddit account to be linked to my name Edit: I forgot to mention that the entire thing is 10 lessons long. This is the first lesson
It sounds like you're using the word "delegation" differently than the rest of us in this thread. When we say delegation, we're talking about a specific implementation and runtime algorithm, where when you access a property on an object, then the system/language searches at runtime for the property name on that object, and if it doesn't find it, then it follows a link/pointer to another object and searches for the name there, and if it doesn't find it, then it follows another link/pointer, and so on. This specific implementation is definitely not how Java or C++ works.
Javascripts objects are barely more than hashes (though they've been getting more featureful as time goes on) and ruby has hash destructuring built-in. The syntax is different but I actually can't really say I like the es6 syntax better than the ruby equivalent. Object destructuring is trivial to add to your own classes (or monkey patch to Object if you are ambitious). Edit: Hash destructuring uses http://ruby-doc.org/core-2.3.1/Hash.html#method-i-values_at (if you want the version that looks like es6 destructuring). So es6: ({a, b} = {a:1, b:2}); Ruby: a, b = {a:1,b:2}.values_at(:a, :b) # A little more repetitive though clearer when the hash is a variable instead of a literal IMO Only thing missing in ruby appears to be the "rest" destructuring from es6. That would be harder but not impossible to implement. 
So what replaces these languages if they are dead? Surely we won't be using JavaScript for everything. With there be a new c with OOP and prototypes instead of classes that replaces c++ for instance? What will people use for systems programming? What about learning in an academic setting? I'm wondering what the implications are if one entertains your idea that those are essentially dead languages (which I feel would be hotly contested, though not by me as I am a student and one who would look on to such a debate with extreme interest).
I would recommend Python or Java. Python has some really expressive features like list comprehension and generators that let you build cool stuff in a short time. Java is pretty universal, and you can learn a lot about strict typing and inheritance by practicing that. Try some of the easy problems on codewars.com to get a feel for what the language looks like.
A lot of people are using Golang as a pairing to JS lately. Previously it would have been Python.
Lol, makes sense.
I would go with a strong object oriented language like Ruby. Or something functional like Elixir.
thats fair
Wow, was looking for something like this last week. Did you make this?
if all you know is JS, I would reccomend learning css and html as something to "go with javascript" if you are looking for something a little lower level, but not super low level, I would reccomend c# or java or golang. as far as for something to make money off of, I would reccomend C#and .Net, where I live, there are literally NO javascript only jobs availalble, everything is .Net with some front end js included
Sorry I should have mentioned I have years of experience with HTML, CSS, and JS. I'll definitely check out your suggestions though, thanks! 
I've heard a lot about Rust, I'll check it out! How does Rust compare to C and C++?
Ah, those sources look much more like what OP needs. Thanks!
Similar performance. More strict.
C, C++, Java, C#, and Python are probably the most popular languages to know. With the exception of C, they're all great for doing pretty much any sort of computing you can think of. I only say C is an exception because there's a lack of options when it comes to things like GUIs and web frameworks. Still doable, but just a bit of a pain. What C is great for is if you want to make a *very* portable library. Pretty much anything that can be called a computer can run C code. Even if all you know is JavaScript, you shouldn't have an issue picking any of these up. With the exception of Python, all of them use similar syntax. Python's syntax is very simple and easy to pick up. C and C++ are unmanaged so you have to handle memory yourself (which isn't nearly as complicated as it sounds). I'm not exactly sure what abstractions you're talking about. Even C is a high level language that abstracts a lot. If you truly want something low level, you'll need to learn assembly and a bit of computer architecture.
:-) yes, about two years ago, and finally had the opportunity to publish the code.
http://stackoverflow.com/a/5298684/92446 it's probably difficult to stop them from scrolling on page load, that is an html thing so you can link to to ids on the page. If the hash doesn't point to anything on the page, it's probably doable.
Well you can do this in CSS with `text-transform: capitalize;`
Yes, I did. If you find the DOM methods hard to read you can always write your own abstractions in far shorter time than configuring in some massive framework. https://www.reddit.com/r/javascript/comments/4vz58a/how_best_can_i_write_this_code_appending_multiple/d62liqw The DOM isn't the real reason people choose massive frameworks. They do it because planning and governance are hard, particularly for leaders who have never held a leadership role outside of development teams. Once planning becomes easy and the technology becomes comfortable you don't want to be bothered with this massive tech debt and wasting your life behind slow build times. The op does not indicate these kinds of maturity problems. He/she just wanted more efficient examples of integrating the output of the logic back into the DOM.
Damn, very impressive, great work. I've been wondering if the Web Audio API could be used to create a spectral average drone, like what R. Luke DuBois did for [Billboard](https://rlukedubois.bandcamp.com/releases). You'd need to run through an audio clip and calculate an overall FFT average, and then run that average through an IFFT. Not sure what else would be involved. Any thoughts on the feasibility of doing that in the browser?
What version of safari are you using? Its only (reportedly) fully supported on 10+ https://kangax.github.io/compat-table/es6/#safari9
Different approach http://codepen.io/anon/pen/PzrkJO Wrote this from my phone, please forgive the formatting in the es6 version. var cap = function (str) { return str.split('').map(function(item, i, orig){ return i === 0 || orig[i - 1] === ' ' ? item.toUpperCase() : item; }).join(''); }; const cap2 = str =&gt; str.split('').map((item, i, orig) =&gt; i === 0 || orig[i - 1] === ' ' ? item.toUpperCase() : item).join('');
9.1 (11601.5.17.1)
So you're gonna have a bad time. ES6 native subclassing is one of the things that isn't fully possible in ES5 ([babel lists this as a limitation of theirs](https://babeljs.io/docs/usage/caveats/)), so you may or may not have any luck with what safari 9 currently has. If possible, you might want to go with a wrapper instead.
I never said it was
babel-register is recommended. babel-core/register might eventually be deprecated because all it does is export babel-register. https://github.com/babel/babel/blob/master/packages/babel-core/register.js#L3
thank you this is really helpful!
Hmm... well I would say it would be average magnitude at each frequency bin with random phases. I recently downloaded a program called [Mammut](http://www.notam02.no/web/2005/10/mammut-2/) which performs an FFT of the entire sound (no windows). It has an effect called "Multiply Phase" which will multiply all phases by a given value. What's more interesting, however, is when you select "Random Phases" and run the transform... the result is a drone that can be quite gorgeous given the right source material. It sounds kind of like what I'm after: a mix of all the frequencies in the source, smeared together and sustained across time. If I could figure out how to do that in the browser, that would be pretty damn cool.
Here's an example: https://jsfiddle.net/sf3edmx0/
I have to second this. It is truly a beautiful language. C#6.0 and C#7.0 has some syntax candy that I don't like, though. It compiles down and is remarkably efficient no matter how you code. It's a great back-end programming language to learn, if you want to become full stack
I have never in my life (with the exception of some Unity developers) met someone who didn't know HTML/CSS, but knew a decent amount of JS.
On your abstractions comment, I guess the answer is I don't really know which ones I'm talking about myself! All I know is that I hear of JavaScript as being a high level language where stuff like you mentioned, C, C++ are lower and you learn more about what the computer is doing. 
That is the problem space for eslint or jscs, not editorconfig 
Aside from memory, C doesn't generally require you to know more about what the computer is actually doing. Many C developers will have a good idea of what the resulting assembly will be, but it's not necessary. C still abstracts a lot for the developer, but not "as much" as a language like Python. You can look at something like https://assembly.ynh.io/ or https://gcc.godbolt.org/ to get an idea of how C code translates to assembly.
And [LINQPad](http://www.linqpad.net) is a great (free) environment in which to write and run small programs or snippets.
I made a few games for a 3 week class using PIXI, and if I got up and running on "game 1" in less than two days with zero game dev experience, no one has an excuse to not be able to make some sick stuff with this: https://github.com/jakereps/CS413-Virtual-Worlds
Niiice
Because of dungeons and dragons, discusing computer scieence in terms of classes worked well for the DnD crowd who most of the programmers of the time ascribed to. p.s. I just made that up
what was small talk used for?
I built a site with pixi a few months back. Sorry the load is so long, lots of large images. Also, works best on desktop in a 16:9 aspect ratio. http://www.blacksciencematters.com
For applications programming client side it is - to all intents and purposes - javascript, server side node is winning, slowly but not surely. Hardcore coding - systems, embedded, compute intensive, scientific, numerics, maths - for now same as it ever was C, R some fortran, python glue. Maybe the functional languages will get bigger. Julia might happen. The object system doesn't really matter, what matters is that there are tools for expressing abstractions. 
Already had experience with C/++/# but nothing particularly deep. Enough to do a few simple things. And also everyone's favourite language, PHP. But we use Scala at work so I chose to learn that as well. It's helped me learn about typesafety and functional programming. Still struggling with a lot of the higher level concepts in Scala but it has definitely taught me a few things. Also we use Typescript at work, so learning to enforce types was really helpful.
C# has a lack of libraries?! If that's so then I don't even want to start with Java... \#praiseIntellisense
You're requesting information from the network, which **takes asynchronous time**, meaning it takes time to fill `picks` even though you're trying to use it immediately. One way to solve this is to put all the code that uses `picks` in your getJSON callback. Another is to use [Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).
I dont think I quite understood what you meant. What values are you saying to round? I thought I was already doing what you mentioned in my code.
 Attached as text. looking at what you mentioned now. 
&gt; if you like pulling you hair out, try rounding your centiseconds correctly. Am I not rounding it correctly already? Don't think I get what you mean.
Not me. I appreciate any sort of help. 
Drop a cookie. Look for the cookie. Don't redirect if found. 
Waited about a minute and was still loading so bounced
Might have to refresh the browser - jumping right into a level is a little odd the first time you go to the game.
 Without using arrays and assuming string isnt preceeded by white space: function cap(str) { str = str.charAt(0).toUpperCase() + str.substring(1,str.length) for (var i = 0; i &lt; str.length-1; i++) { if (str.charAt(i).indexOf(' ') &gt; -1) { str = str.substring(0, i+1) + str.charAt(i+1).toUpperCase() + str.substring(i+2, str.length) } } }
I'm no Java fan, but I thought they are about the same speed. Unless you add anything graphical. Then everything is faster than Java.
To add to the suggestions of learning C++, might I suggest Udemy's [Unreal Engine](https://www.udemy.com/unrealcourse/) course? You'll learn the basics of C++, plus how to use an industry standard rendering engine. It never hurts to know more, and you might enjoy building things with Unreal on the side.
Some people would like javascript to have a stronger type system. By using typescript they can catch instances where they are passing in or out the wrong types.... during compilation, rather than finding out at runtime that something undesirable happened. It doesnt make things more difficult to debug, exactly the opposite. You dont use typescript to enforce javascript doing things right, you use typescript to enforce yourself/your team doing things right
Typescript is a superset of JavaScript so anything you so on JavaScript is doable in TS as well. You just annotate your objects and functions with types, no layers involved. The benefits of TS are telling you when you are making a mistake at compile time rather than runtime. Ie you want to do some math and your code does `item.price * 100`. JS will do that but TS or Flow will check the type of the price field to make sure its a number. For small projects it might seem overkill but after a certain size you are not going to remember all the types in your app so having a compiler really helps.
Here's a great podcast about just that: https://devchat.tv/js-jabber/209-jsj-typescript-with-anders-hejlsberg In general, Typescript allows us to have better tooling and gives us more insight into errors at "build time" and "run time" 
well explained! Still have a feel that it keeps us (a bit) far from the concept of prototype-based programming in JS. Array and Function inheriting from Object.prototype.
I agree this is the best answer.
I was being somewhat facetious, though in reality, I barely know html and dont really know much about css... I am generally not a very visually oriented person... if it wasnt for bootstrap, and google, I wouldnt really be able to do web development, even though I know JS pretty damn well, I still have to google how to do anything with css outside of the common classes I know from bootstrap / other css frameworks... my background is in system administration / shell scripting / system integration ... I can make stuff work together, but struggle to make it look decent lol
Thanks for the warning. I might reconsider it...
it doesnt change anything, just lets you ensure you dont shoot yourself in the foot by doing things like passing into a rarely used function in your codebase: "100" instead of 100 or making sure you pass in: { id: 1 name: "something" price: 100 updatePrice: function(newPrice){ this.price=newPrice } } instead of: { waffle: "something" point: "bug" } or atleast helping you find out you did it before your code is running in production 
&gt; Am I not rounding it correctly already? Well, do you get correct results?
Good point. Fixed the useless "ignore case". About your suggestion to rewrite in a clearer way, what is exactly unclear about it? RegExps are just a tool, and the one used is trivial to understand.
Why would you say JS is broken? There are a few well-known bugs in the language [e.g., `typeof (null)` //Object] but those are still living due to backward compatibility reasons. JS is a very powerful language and loose-typing (type coercion) is a good thing to have.
Good code is as much about communicating to future readers as it is about communicating with the computer. Regexes are indeed powerful, but their power and compactness comes at the cost of readability. Whereas OPs solution is basically self-documenting (so long as reasonable variable names are chosen), your regex requires that the reader to mentally decode the pattern and then apply the semantics of JS's replace behavior to the tiny grammar that you've specified. Maybe you can easily see the DFA and visualize exactly how your regex will behave, but it's a good bet that the person reading your code later can't, which means you're wasting their time, usually for no real benefit. And that becomes ten times worse if the regex needs to be modified or debugged. And remember, the reader isn't just trying to understand *this* code. They're trying to understand the entire context around it. That said, there are obviously times when regexes are the correct solution. They are fantastic for searching and processing files on the command line or in your editor. They can also be great in code when they are extremely simple. And of course, there are times when they are the easiest way to process text efficiently, so if you're dealing with a performance hotspot, they can be a good move (but of course, you should have plenty of documentation). And finally, they're great for code golf. But in particular in a case like this, where the point of the exercise is learning the basics of the language and/or of programming, the explicit solution is clearly better.
If JS is 'broken' for your use cases, why wouldn't you pick a different language? 
I don't mean 'broken' for my use cases but 'broken' in general. What alternatives do I have?
The benefit of TypeScript is making certain bugs impossible, and making things much easier to debug. First off, you're confusing a bit of terminology. Loose/weak vs strong/strict typing and static vs dynamic typing are different things. JavaScript is dynamically typed, which means the program doesn't know what types values have until it actually runs. Imagine that you assume some call `getUserEmails` will return an array of email addressses, so you write code to sort through that array and handle all the values. But it actually returns an object where one of the properties is an array of addresses and others are booleans telling you whether the call was successful or something. In JavaScript, that code would crash when you tried to execute it. In TypeScript, the second you wrote the line, you would immediately get a red flag in the editor saying "Uh, you know that's not an array, right? This isn't going to work." So you can fix the bug before you write a whole misguided solution, before you build your files, before you run the tests and open the browser to manually test the program. Now you might think "yeah, but so what, seeing failures in the browser console or test suite is fine." For small programs it is. But when you have a really big complex program, little bugs like that might only get activated under very specific circumstances. Someone might come along in a year and try to tweak the code and break it because they're not aware of the circumstance in which it crashes. The larger and more complex your program becomes, the more likely it is that you will introduce bugs that are really hard to track down. You will spend your time trying o reproduce a crash someone else experiences, figuring out what circumstances they were in that made it possible. TypeScript prevents you from writing these bugs in the first place and can catch them *without* having to actually run and experience the crash. You can summarise this by saying **JavaScript doesn't let you know things will crash until it happens. TypeScript lets you know they will crash in advance.** Some more robust and elaborate alternatives, like Elm, actually try to guarantee that if you don't get an error warning in your editor, your program will *definitely not* ever crash -- they can actually prove, mathematically, that an error will not occur while users are running your code.
The types in typescript are completly lost in javascript. The types have nothing to do with the code you execute. They are purely a tool to find bugs before you even run the code. If you combine typescript with a strong IDE like visual studio code or webstorm, and do some refactorings in it, then going back to just javascript feels barbaric and poking in the dark. Here an example: getIds(): Promise&lt;{id: number}[]&gt; A method the returns a promise that resolves into an array of objects with an id property. You can just do: getIds().then(entities =&gt; entities[0]).then(entity =&gt; entity.id); Now if you change the result from getIds() to observables, or rename it to fetchIds(), or change the object structure ... with typescript you don't even have to execute the code or any unit tests, typescript just tells you all points in your code you have to change. 
I agree with you except for one point. Since OPs is clearly a beginner, and given that regexps are part of every PL, they should study them as much as any other part of the language. This case is a silly example, the main problem being ignoring the existence of non-english languages (but that is going to be fixed soon-ish with the introduction of [Unicode property escapes](https://mathiasbynens.be/notes/es-unicode-property-escapes) in ES), but the point stands. Since the problem at hand is about parsing the input string and transforming it, the correct solution is to use a state machine, wheter implemented as a black-box-ish regexp or coded from scratch. I could have proposed yet another (broken) way to handle the problem, interesting in a way because it exploits how ASCII characters are encoded, using bitwise operators (another fundamental part of every PL that is too often deemed evil and avoided) to flip the 6th bit of chars to change the casing. Unclear? Sure. Useless knowledge? Absolutely not. A beginner, before worrying about writing "good code", should study and experiment as much as possible, because programming is (also) fun.
Some people think types will help them catch bugs that they couldn't (or didn't/wouldn't) catch in tests. 
video game programming... to write a video game you have to write subsystems to use the: filesystem, render, networking, anti-cheat (cryptogprahy or secure communication), keyboard and mouse input, data-storage, 2d/3d math, server/client, compression/unpacking. &gt;thats everything needed to write any program 
It does in unary.
Though of enabling [Github Pages](https://pages.github.com/) on the repo then people can play your games.
No. I do know.
Java eats memory like candy, whether it's graphical or not. C# is a lot more efficient in this regard.
What about it is "broken" then?
It isn't that tests can't catch type-related bugs. The fact is you probably aren't testing your code against every type. Having something like Typescript or Flow is giving you those tests for free.
has anyone used ng2-redux to compare?
Thanks. I think learning React will be my next project. Right now I'm just finishing up a 300 line script that is sort of an exercise to reinforce some good practices in Javascript (I hope they're good) with the DOM but as I've been learning I think React is one of the pieces missing from my JS toolbox. Up until now it seemed like overkill to import a framework into a project of a few hundred lines but maybe that's pure ignorance on my part. I suspect when I start digging into it I'll be able to define the other missing parts more easily. I also suspect I will be looking into Meteor as I keep coming across it when I'm in research mode. I may take you up on your offer and send over a question at some point. Thanks. 
Hey r/javascript, I wrote this small module to keep track of whether a set of elements are in the viewport. Feedback is very welcome in the form of issues and pull requests!
I've been in JS for years, and I don't think I've made this conscious realization, thank you. What language would be an example of loosely typed?
Thanks. I've pretty much decided to release as ES6. ES6 code integrates better with everything I have anyways, so providing an ES5 release is just a 'nice to have', and enough people have said they can live without it since they're using a compiler like Babel.
TypeScript provides [static analysis](https://en.wikipedia.org/wiki/Static_program_analysis) by verifying the arguments you are passing around and returning. If your code has any mismatched types, the compiler will immediately tell you where you messed up before you have a chance to execute or commit bad code Vanilla JS's dynamic types don't allow for static analysis as you can't make assumptions about what type the arguments are meant to be - nor do you define return types in vanilla JS. In vanilla JS you can only do this with runtime checks in code as you described. Also, because of the strong types and type definition files, TypeScript has a whole suite of autocomplete and signatue hint tools for your favorite text editor that make JS development a joy. edit: [ugwe43to874nf4 nicely clarified your confusing use of typing terminology](https://www.reddit.com/r/javascript/comments/4ztbcd/why_typescript_js_is_looselytyped/d6yms48). I hope everyone who stumbles in here takes the time to read it. 
Yes, whether you are using Babel , TypeScript, or your favorite flavor of *Script -&gt; ES5 com/trans/piler, you should be developing with source maps. It's 2016 and life is good in JS land if you use the tools bestowed upon us.
Hi ugwe43to874nf4, that is an awesome explanation. As for not explaining how computational steps are reduced; I have indeed said, in the beginning &gt; whenever you make a DOM change all the following steps in the flow, right from the creation of the render tree (which requires recalculation of all the style properties of all the elements), to the layout, to the painting step, all are redone. &gt; In a complex SPA, often involving a large number of DOM manipulations, this would mean multiple computational steps (which could be avoided) that make the whole process inefficient. But I agree that it could have been expanded upon in detail, and you have done such a great job at it. I have updated the article with your explanation (and of course, attributing it to you.) Thanks a lot, for taking out time to put it all so succinctly. 
yea ill second this, theres at least 2 or 3 ways to do OOP with JS (some removed, and just just labeled as out-dated).
Benefits/Differences to https://github.com/stutrek/scrollMonitor? Beside that: You should add some unit tests ;)
ES classes are just syntax sugar for prototypes. Classes doesn't change any fundamental things about the object system in JavaScript.
&gt;So, what problems does class-based programming solve here? It sets a standard. That's it. A problem that the JavaScript universe has is that everyone and their brother does object abstractions differently. What some people are complaining about is that the standard that was chosen was not the standard that they would have chosen. But that's the inevitable result of making any decision.
to me classes solve the problem of 'we need to create a lot of objects of the same type. now we have to pick from the 4 or 5 different approaches to doing that. and no one on my team can agree'
To answer OPs question first, while the language is loosely typed that doesn't mean you can't benefit from types - *static* types used during development and not present or checked during runtime. It can help you find errors that could otherwise only be found by analyzing the code - but mostly *never*. What you do with types is you *add information about intent*. For example, if you return an object from a function that another function just iterates over and prints, development tools like your IDE or any code checker would never be able to find out that property "xyz" is important, that you expect it to be in the output. but if you add a "type" that says "this is an object that has a mandatory property xyz", and then annotate the code to say that that function is supposed to return that type, then your code checker has a chance to see that you never add such a property to the object that is returned. You could add code to do such checks, but that would be bad: Those checks are (very often) only needed during development, no need to have them around in your actual code. So the type systems for Javascript are supposed to help during development, to help code tools check your code. They are not supposed to do anything during runtime, but that is not necessary, the static checks already help significantly (especially in large projects, with lots of people, over a long time, and with new people coming in). They don't help (as) much with small projects of the "fire and forget" type (the code is not maintained) of one or few developers. I prefer [Facebook's Flow](https://flowtype.org/) (which now also supports Windows). I only want type checks (for my ES 2015 node.js code), not a language extension, and the focus of the projects is different too. So Flow is a type checker not a compiler. Related thread: [Flow vs. Typescript](https://news.ycombinator.com/item?id=11844574), summary: - TypeScript and Flow have influenced each other heavily - Basic typings are pretty similar - Both also support React - Many more constructs like union, intersection, and array types in both - Flow can even understand TypeScript declaration files - TypeScript is a compiler, Flow is a checker - Flow shoots for soundness, TypeScript for tool support - Flow has non-nullable types as defaults - Generics in TypeScript are easier, but less expressive - Flow's type system is generally more expressive - Flow written in OCaml, Typescript in Typescript
Wasn't aware of scroll monitor. Looks very robust! At a glance, I'd say the main difference is simplicity. I deliberately limited the options to what I thought I'd want. And, yes, unit tests are on the way!
It also means you get to write less tests.
I'll add that you don't actually need a virtual DOM to implement diffing / reconciliation. [morphdom](https://github.com/patrick-steele-idem/morphdom) and [incremental-dom](https://github.com/google/incremental-dom) do the diff off of the actual DOM tree. As for DOM update batching, the only system I know of outside dom diffing is the Sencha team's TaskQueue for doing batch updates across a codebase. I played with it briefly and found it cumbersome and my conclusion at the time is that update batching is possible but not practical.
...and some other stuff like: var __decorate = (this &amp;&amp; this.__decorate) || function (decorators, target, key, desc) { var c = arguments.length, r = c &lt; 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d; if (typeof Reflect === "object" &amp;&amp; typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i &gt;= 0; i--) if (d = decorators[i]) r = (c &lt; 3 ? d(r) : c &gt; 3 ? d(target, key, r) : d(target, key)) || r; return c &gt; 3 &amp;&amp; r &amp;&amp; Object.defineProperty(target, key, r), r; }; and var __param = (this &amp;&amp; this.__param) || function (paramIndex, decorator) { return function (target, key) { decorator(target, key, paramIndex); } }; See? JS just like you're used to! (Not hating, just teasing. It should be pretty obvious what these generated functions do). If you're a JS guy trying to get your head around TS it's well worth it to look at the compiled JS.
Not quite "free"... but for the low low cost of learning a whole bunch of extra syntax and fighting to find/write/maintain TS interfaces from your favourite library (or giving up and just declaring it with `as any` totally defeating strongly typed TS).
Good overview. Though I do find it odd someone go to Typescript the basically use type &lt;any&gt; all over their code. Seen it here and there.
What about contributing to scroll monitor to improve the signal rather than noise?
Thats actually super readable and makes sense. Im sure babel does the same thing in its polyfills too.
It does.
On the question of typescript, does anyone know any non trivial examples out there? Or even some open source projects that are using it. Is it possible to slowly bring it in to an existing codebase?
Yeah! I never said it wasn't readable. In fact, I said "It should be pretty obvious what these generated functions do". Why downvote?
And less code. No more need to check for e.g. `null` or `undefined` for every argument (although you're probably not doing that anyway).
I was playing around with paper js and built a cool visual playground using react and the color lovers api. http://color-lovers.herokuapp.com/
A proper JavaScript type system really needs row polymorphism in order to support the way people use objects. 
Isn't this just a Producer-Consumer queue wherein the consumers check in with the producer when they are ready to do more work? I have heard of this before without it being called reactive. 
Hi /u/rkcudjoe1, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
That seems like a good idea, I hadn't heard of it before. FWIW, I tried it in the project I'm working on now (which uses babel + browserify) and got this fun error message: Error: Plugin 0 specified in "foreign" provided an invalid property of "name" while parsing file: app.js Hopefully I can reduce it to a smaller test case and submit an issue...
Yep, project is https://github.com/dumbmatter/basketball-gm and all I did was install the preset and add it to my package.json.
Ah, I'd add an issue to their github. It was just a first guess, sorry I couldn't be more help. 
I self taught C# and I can say it is so close to JS it is probably the best language to branch off into.
monolithic projects, not big projects.
Gotcha, thanks. Auto-indenting worked fine (using Atom) before I created an editorconfig, and the problem came up after I made it. I'll double check my Atom settings and see if that's where the problem is.
I guess what I want is a summary with bug fixes, performance increases and such like the other versions got. Would be nice 
It's usually either a CS degree or "equivalent experience". 
Yes. In those cases there's virtually no benefit to typescript. TS helps when you are willing/prepared to correctly type things. 
Thanks! That fixed the first error, but I'm getting another as it's processing my code... I'll refrain from bugging you about it until I can make a smaller test case :)
Yeah, but nobody programs in unary.
Isn't inheritance using `Object.create()`, `new myFunction()` and Mixin pattern simple enough? 
If the input to a function always is random, then the input is never the same - or am I missing something here?
Hi Guys! https://jsgolf.co/ I've been working on a coding golf website exclusively for javascript for a while, and I think it's ready to demo. If you do check it out, please leave feedback, negative or positive! p.s. You can use ES2015 lamda expressions too, e.g. `a =&gt; ...`
When you `Object.create (null)` your resulting Object still has a property `__proto__` that cannot be overwritten.
Does throwing an exception make a function impure? I wouldn't have thought of JavaScript exceptions as being particularly stateful; as long as they are thrown reproducibly due to arguments or constants (not due to external or internal state) that doesn't come across as impure to me. I guess the stack property is based on where you call it from.
Hi! I made a [next gen client-side framework](http://www.nx-framework.com/). It uses ES6 Proxies and Web Components internally. Browsers support is not the best, but it comes with a lot of features out of the box (data binding, routing, visual flow, etc) Some feedback or even contribution would be awesome! Thanks!
&gt; • The elements in the array don’t have their valueOf functions tampered with This possibility means literally nothing in JS is pure. Also, why the hell does this arbitrary designation matter? Programmatic functions are not mathematical functions, their purpose is completely different. 
&gt; Brazil? &gt; You could get mugged, shot and your code plagiarised all at once. Thanks for the useful comment, it seems you are very smart and know Brazil very well. It also shows that you care a lot for events that happens worldwide with your very constructive feedback for this subreddit community.
Nobody, OP is just nitpicking and arguing about corner cases. If it behaves correctly for what I want it, it's pure enough to me.
The problem is, not all libraries out there provide type definitions. You can always write your own interfaces, just the instinctive nature of "let's get this to work" comes in the way. 
&gt; Programmatic functions are not mathematical functions, their purpose is completely different. That's very true. IMHO the article was great, but the example did not help make the point clear enough.
This Post is about Java script Array methods , with Blur event 
This
Hey, I'm the PM on TypeScript, so I'd like to hear your feedback on this if you try it out. You can gradually introduce TypeScript using the `--allowJs` flag which allows JS files to be understood using some heuristics and JSDoc annotations, as well as compiled (i.e. if it's written using ES6, you can use TypeScript to downlevel it to ES5). You can then start adding `.ts` files or converting `.js` files over as you need. As for projects that use them, we have a bunch of internal ones (the Azure portal is probably our biggest one). As someone else noted, there's VS Code as well. Obviously, TypeScript is built in TypeScript. I'm definitely going to miss a bunch, but [Angular 2](https://angular.io), [RxJS 5](https://github.com/ReactiveX/rxjs), [Dojo 2](https://dojotoolkit.org/community/roadmap/), [MobX](https://github.com/mobxjs/mobx), [Cycle.js](http://cycle.js.org/), [Ionic 2](http://ionic.io/2), [NativeScript](https://www.nativescript.org/) and others are all built using TypeScript. Ember's [Glimmer 2](https://github.com/tildeio/glimmer) rendering engine was recently built with TypeScript. [Aurelia](http://aurelia.io/) is considering migrating over to using it as well. Apart from libraries &amp; frameworks, [Black Screen](https://github.com/shockone/black-screen) is a modern terminal emulator built in TypeScript. [alm.tools](http://alm.tools/) and [cats](https://github.com/jbaron/cats) are two editors written in TypeScript. [Shumway](https://github.com/mozilla/shumway) is a Flash VM built in TS too. Google's [TensorFlow has a playground](https://github.com/tensorflow/playground) using TS as well. I could probably keep going, but I think you get the idea. :)
TypeScript will just translate that to JavaScript. It won't affect what happens when that JavaScript is run. That's one of the things we stick to - the types don't change how your JavaScript get run. They just get stripped out. I encourage you to try out all your noob questions on the [TypeScript Playground](https://www.typescriptlang.org/play/). :)
Does it matter? If the function does what its supposed to, who cares?
I certainly can't speak for all other languages. I think his point was also that other languages provide better ways to validate the input to your function. Which is why he mentioned haskell at the bottom.
Sorry I am still a reddit newbie. Is "/s" to mark as sarcasm?
i like turtles
Ain't nobody got time for that
Most people really like using classes for fleshing out the structure and a functional style where it's convenient. Being able to freely mix and match these things is really great. ES6 added classes because many frameworks used their own custom wannabe classes which all worked slightly differently and which were incompatible with each other. Furthermore, they weren't declarative which meant they were inaccessible to tooling. We'll probably see mixins or traits being added in the future. That's the only thing which is missing right now.
I *really* want the pipeline operator in JS. I'd prefer the `|&gt;` symbol personally but to do this in Babel requires a patch to the Babylon parser and they don't want to do it if the proposal isn't even stage-0. Anyway thanks, hopefully this pushes the idea forward. 
It's easy for JS education to descend into shock and awe on how the language can be subverted or is unintuitive. The phrase "You don't know JS" is easy to deploy. To demonstrate, here's another object you could pass into the protected sum() function to force it to be impure despite the checks... var x = [0]; Object.defineProperty(x, 1, { get: ()=&gt;x[0]++ }); sum(x); // 1 sum(x); // 5 
It probably is *simple* enough, but that is beside the point. It is not expressive, and looks alien to anyone used to classic non-proto OOP. Because of this, different frameworks and individuals have invented their own class implementations. With ES6, there is now an obvious and expressive way of doing classes.
I like it, cool and fun, and potentially educational (if you apply yourself). My feedback: * The `// Your code goes here...` is actually not accurate, it should probably go above the `function() {}`, because I can replace `function() {}` with `() =&gt; ...` and it's accepted, which was unexpected (the way it's setup implies that only the function body can be altered). * I'd like to be able to see others' solutions. * After solving the first challenge, I was at a loss what to do next; there's no prompting to go to the next challenge, and I had to go looking for how to advance to the next one. * I'm not sure how to feel about whitespace treatment; I thought I was missing some super-secret techniques until I realized that I just had to remove whitespace. * You could make it a little more educational by offering tips, i.e. suggest using `() =&gt; ...` over `function(){}`, remove whitespace, etc. edit: * "Babby's First Map", the description might could be worded better... it says: "Produce a function that takes a map and returns an array of values of the keys", and the "of the keys" makes me think it just wants `Object.keys(obj)`. I think I'd expect something like, "takes a map and returns an array of its values" or "takes a map and returns an array of each key's value".
&gt; Math.random That's cheating.
I wrote an SQL gateway for SQLite and Express that lets you make Ajax calls to your database with plain old SQL and enforces permissions by parsing the SQL and checking a permissions table. https://github.com/groovy9/Node-Express-SQLite-Raw-SQL-Gateway-Example
Hey! Thanks for the feedback, I really appreciate it :) &gt; The // Your code goes here... is actually not accurate, it should probably go above the function() {}, because I can replace function() {} with () =&gt; ... and it's accepted, which was unexpected (the way it's setup implies that only the function body can be altered). Yeah, so what happens behind the scenes is that the code you submit is wrapped in parentheses and executed, e.g `(_=&gt;'Hello World!')()`. However I'm not sure how to express this to users without coming across overly technical (maybe that's a moot point given that this is a coding game?) Definitely something that needs to be worked on. UX is absolutely not my forté! &gt; I'd like to be able to see others' solutions. Yep, this is a 'nice to have' in my Trello. &gt; After solving the first challenge, I was at a loss what to do next; there's no prompting to go to the next challenge, and I had to go looking for how to advance to the next one. Good point, I should link the exercises somehow. &gt; I'm not sure how to feel about whitespace treatment; I thought I was missing some super-secret techniques until I realized that I just had to remove whitespace. I contemplated putting a 'minify' button on the page that automatically runs your answer through a minifier, but then thought that ruins the experience a little. Not sure. &gt; You could make it a little more educational by offering tips, i.e. suggest using () =&gt; ... over function(){}, remove whitespace, etc. Yeah, the UX is still so-so, I want it to be intuitive, but I don't think it's quite there yet. Thanks for the feedback!
1 - Begin with modularizing JS/view (frameworks call them components). See them as "code that controls a specific rectangular region of the page"..and the page is divided into several regions and thus the code as well. Generally ES6 imports (or browserify or AMD) and JS "Classes" also are used for the modularizing. 1.5 - Use either a templating engine like Handlebars/doT (convert to DocumentFragment and insert to document). This reduces DOM manipulation. But there will still be a lot of DOM API calls when updating the UI after the initial/first-time render. For small applications this will be ok. - I am not sure whether using a library like [dom-diff](https://github.com/skatejs/dom-diff) at this point will help (didn't hear anyone trying that). 2 - After this point, many switch to using a framework. Why? because it reduces the direct DOM API usage (doesn't eliminate it completely..and never will)..the library does the DOM manupilation internally...and the developer mostly thinks about "states"/data.
FYI, I edited my original response as I hadn't seen your reply yet. &gt; I contemplated putting a 'minify' button on the page that automatically runs your answer through a minifier, but then thought that ruins the experience a little. I was mulling that over as well, and think that a full-on minify would be counter to the theme of the game, however... maybe a simple "remove extra whitespace" type button would be useful. Perhaps just encouraging users to remove whitespace on their own would be good enough, and wouldn't require making it overly complex. 
p.s. feel free to remove my score for the last question (the Roman numerals one), I cheated my butt off :P x=&gt;x==1?'I':x==4?'IV':x==1500?'MD':'MCMLXXXVI'
I like it! Not sure if you intended it, but Babby's First Reduce happily accepts `x=&gt;x.reduce((n,p)=&gt;n+p)` which seems like cheating.
ES2015 is totally allowed! You're the second person to question it, so I think there's a bit of work to be done on good explanation Thanks :)
If I'm already using babel with webpack, can someone please tell me what benefit I gain from this? I must be incredibly obtuse today, because I just don't see it.
Rarely tbh
Did u consider using animation frame instead of a plain throttle?
I have a hard time to see why you need to frame this in a web context. The DOM handling and the HTML adds a lot of overhead, while having nothing to do with javascript array methods. I understand, however, that it is tempting to let students create something that *actually does something*. But when it does what it does in a non-sensical way only to cram in as many relevant concepts as possible, it becomes a bad start off point to any potential web dev.
How is SQL injection not a concern? 
I haven't seen a plug for [Free Code Camp](http://www.freecodecamp.com) yet - it's a 100% free full-stack web dev course that focuses heavily on javascript.
Well, it is to some degree. The SQL is parsed to figure out what tables are being read from or written to, and the permission to do the requested operation is checked before proceeding. It's not vulnerable to old school injection where you blindly pass a form field into an SQL query because the whole query is being parsed. So you have to be authenticated and have to have permission to read/write the table, but at that point the user could write to a table they have permission to write, but in a way you didn't intend. You wouldn't use it for a public API, but it's fine for smaller internal apps. I wrote it as the backend for a small business and the odds of any of my users hacking SQL are zero. Furthermore, you could trivially wrap the raw SQL engine in normal REST routes and control the SQL yourself.
Just about everything Eric Elliott has ever said about classes or inheritance or composition is factually wrong.
What about graphql? You could have a graphql server and use a client to make the requests.
I solved my problem as follows function myFunction() { var x = document.getElementById("myFile"); Papa.parse(x.files[0], {header: true, complete: function(results) { console.log("Parse results:", results.data); } }); } 
DAE **Hask** isn't really a category? 
Authentication uses JWT and doesn't store the token in a cookie, which as far as I understand makes it CSRF-proof.
You are using an out of date reivison of gameboy-online code I wrote half a decade ago... I did a quick view-source. :p You should be using the latest revision which is already pretty ancient... https://github.com/taisel/GameBoy-Online 
It appears to be a layer between the browser and server. If you detect a user agent that supports es6 then you take the already transpiled es5 code and convert it back to es6 minified? But that's just after a glance, I could be wrong.
Please fix the link for https://github.com/grantgalitz/GameBoy-Online It should be https://github.com/taisel/GameBoy-Online
I had problems with the latest revision in multiple browsers, so I opted to use the older version. Also since this is meant for mobile, I stripped some of the features that were more suited to desktop.
Working perfectly in safari iOS / android. It's a shame that sound couldn't work for mobile, I had it sort of working but the delay was significant.
&gt; x can now change while sum is being executed. I don't think the single-threaded nature of JavaScript, the event loop, etc., actually allow for this sort of thing. The sum function will completely execute before some other async function can come in and mess with `x`.
Elliott has claimed "new" violates the Open/Closed principle and the Liskov Substition principle, both of which are wrong. Elliott has claimed his alternative to classes and inheritance is immune to the fragile base problem, [but that's wrong.](https://medium.com/@w1fj151/the-wiki-page-for-fragile-base-class-gives-a-code-example-775f67a3585c#.3r5nmijad) Elliott has claimed his alternative to classes and inheritance is immune to the diamond problem, [but that's wrong.](https://www.reddit.com/r/javascript/comments/3oy9c3/composition_vs_eric_elliott/cw20tsl) Elliott has claimed his alternative to classes and inheritance is immune to deep hierarchies, [but that's wrong.](https://medium.com/@jeffm712/though-be-careful-not-to-think-of-stamps-as-a-silver-bullet-5b650eaf27c6#.j6sdvm9lg) Elliott has claimed his alternative to classes and inheritance has no hierarchy at all, [but that's wrong.](https://www.reddit.com/r/javascript/comments/3oy9c3/composition_vs_eric_elliott/cw57h6n) Bizarrely, Elliott has even claimed that `class A extends B {}`, even in a language like Java or C++, is *not* classical inheritance. It's sad that I have to explicitly rebut this, but [he was wrong.](https://medium.com/@xwt23v/i-m-genuinely-trying-to-figure-out-where-you-draw-the-line-between-inheritance-and-what-you-call-ab11d70f7aaa#.2uc971756)
What? You mean overwriting default object behaviour may cause unexpected things to happen, such as making your pure functions impure? You might as well argue that your function could be impure because code somewhere else might overwrite it.
I feel that you are asking for multiple different things. You want something to generate forms of some sort. As well as a template engine. Normally template engines work from databases and have all the "answers" so they don't have to "ask" for something. Maybe a template engine that generates forms?
How would you expect a template engine to ask for parameters? I think by default with ejs it will fail to render the template if the template uses variables that arent passed to it. Is that what you are asking for? 
I cant think of a time I would rather not have the rest API, rest API always gives me more flexibility in the future and I try hard not to only build for the present.
SQL is basically the definition of flexibility, isn't it? No need to add to the back end. Just ask for exactly what you want right from the front end. Obviously, the use case isn't huge teams or public APIs. 
Templating engines often have API references that to can look through to see if any of them provide this information. Maybe the source map stuff here? http://handlebarsjs.com/reference.html
No function is pure because maybe the NSA is listening in on them or something even as absurd. Taken to the absolute, you can drain the practical value of any concept.
I added support for C#, TSX, TypeScript, and Java to Pretty Diff version 2.1.5. * http://prettydiff.com * https://github.com/prettydiff/prettydiff
&gt; let x = [Math.random(), Math.random(), Math.random(), Math.random()]; This is not the same as his example. Here, you have a set of random values that you keep changing. In Staltz's example, he has a set pointing to the random function.
something I have noticed here lately, that confuses me, probably because I only speak english..... why do so many people refer to inanimate objects such as a templating engine, with masculine pronouns, like: &gt;I would like to have a template engines that with that input would "know" that he has to ask for "name" and "age". instead of using pronouns for inanimate things, like: &gt;I would like to have a template engines that with that input would "know" that it has to ask for "name" and "age". ? is this a common thing in countries where english is non-native but still commonly spoken?
Would you be down to help implement the newest revision into this mobile UI, Dropbox rom loading is functioning and saves could easily be migrated as well. I understand it's a decent amount of work, I hope that it's OK I continue to work on some of these new features :)
lol, I was gonna ask if he was going to present the user w/a console or how he expected layout to happen :) I think you missed the part where you get the users input for the variables in the template though, but the prompts are in a list now anyway. edit: here is an easy peasy textarea as console example: https://jsfiddle.net/1o501mu4/2/
Hi /u/IslandTropical, it looks like you're new to /r/javascript, welcome! Thanks for the submissions, but please make sure you read our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `gamingdirectional.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [gamingdirectional.com](/search?q=%28and+site%3A%27gamingdirectional.com%27+author%3A%27IslandTropical%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|20|95% [self.learnpython](/r/learnpython/search?q=%28and+author%3A%27IslandTropical%27+is_self%3A1+%29&amp;restrict_sr=on&amp;sort=new&amp;feature=legacy_search) (also gamingdirectional.com)|1|5%
Someone on my team was looking for something like this yesterday. I'm glad I came across your post. Great job!
There's a Web API for that, and a polyfill for browsers that don't support it API: https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver Polyfill: https://github.com/WICG/IntersectionObserver/tree/gh-pages/polyfill 
ok thanks for the advice
Cool to see more uses of babel plugins to do non-es6 AST transforms. Babel is a wonderland of largely untapped power.
Rather than creating a new templating engine that enforces a particular schema, a simpler solution might be to separate the templating and the schema validation part and just use existing libraries that handle those tasks well. For example you could create a function that takes a [JSON Schema](https://github.com/epoberezkin/ajv) schema and an template and returns a "render" function that takes some data, turns it into a string according to the template, and throws an error if the data fails to match the schema. eg: const template = "Hi {{name}}"; const schema = { type: "object", properties: { name: { type: "string" } } }; /* implementing buildRenderer() up to you, but you can leverage ejs and ajv libraries to do this in just a few lines of code. */ const render = buildRenderer(template, schema); const string1 = render({ name: "Bob" }); // =&gt; "Hi Bob" const string2 = render({ foo: "Bar" }); // =&gt; throws validation error since arguments do not match schema 
I chose to override the bitwise operators for the mean time only because of the issues with babel as already mentioned. I don't now about you but I very rarely use the bitwise operators which is to say I can't remember the last time I used one so they seem to be the most suitable choice to use this functionality now. Keep in mind that my plugin has the "no pipe"; directive so you can use still the original bitwise operators in parallel with the plugin which makes it slightly less of a bad idea to override them. As soon as babel can support new operators I will switch it straight away to |&gt; and &lt;| and run a find and replace on my code as well. But if you are like me and REALLY want to use this feature right now hopefully this will satisfy your needs for now.
[removed]
I will admit it's tempting, because I would love to have this feature. Still, I can't see myself convincing my team to use it in production. Might be fun for a personal project, though.
This is exactly why I created the plugin because I simply can't live without some kind of pipe operator when writing functional style javascript. I tried a few other plugins last night that used the | operator as well as one that could override any binary operator but none of them supported backward pipe which is something I like to use. As soon as babel supports it I will replace the operators with |&gt; and &lt;| respectively and do a find and replace on my code but for now this does the trick for me.
You never know especially since pipe forward/backward is a well established idea in many other languages already. With babel it doesn't really matter if a proposal or idea will make it into official ES spec or not any more just so long as everyone knows they can or cannot use it on a certain project and even if the official adoption uses a different operator you can either find and replace, migrate new projects to the new operator or continue to use the bitwise operators. 
If you haven't installed globally, you need to include the local path to Babel's executable. So instead of: babel script.js Use: ./node_modules/.bin/babel script.js Alternatively, you can add a script in `package.json`: "scripts": { "babel": "babel script.js" } Run it with `npm run babel`. This works because `package.json` looks for local Node packages, but your terminal does not. EDIT: Just realized I repeated u/a_simple_pie. Oops!
The purpose is to catch some programmer errors at compile time, rather than runtime. Whether or not a language "has types", function have expectations of their arguments. TypeScript can verify some of those expectations at compile time. That's better than waiting until runtime because all of your code runs through the compiler, but code might not actually be run except under specific and subtle conditions, forcing you to track down and replicate those conditions to catch the error at runtime.
Exactly. Pure functions _can_ return different outputs if the inputs are different, which is the case here.
If you need more, maybe [faker.js](https://github.com/marak/Faker.js/) could be handy as well. 
Can I have him? Seriously this I my dream child. I hope when I have a kid he will love programming the way I do
If you're interested in Aurelia and how to improve loading time with bundling, I just completed an article about how I did that on http://www.arenaoftitans.com/: http://www.jujens.eu/posts/en/2016/Aug/17/switch-to-aurelia-cli/#bundles I hope I am not too late ;-)
Then arguing about function purity is just... I don't know the English idiom, but it's an unnecessary and uninteresting complication.
I suppose that depends on how you learn best. For me, it helps to understand the bigger picture and abstract concepts so I will be able to generalise it to future situations.
The whole point is to not edit them manually at all, because there's plenty of them. Remember, it's now really about how to update dependencies, its about how to update _dependants_. Say, if you have module A, and then you have B, C and D depending on it, and A gets updated — you want to update B, C and D's `package.json` with new version number of A. That's a lot of edits, and you can obviously miss something. There should be a way to automate that, or maybe I'm doing it wrong :)
well you'd set B,C and D's entry for A to get version *. then npm update will grab your new version of A. 
They're not that interconnected. It's a hierarchy, and there's some common modules, on which many other modules depend.
Shared with a friend who's working on a Web app to do with the premier league. Cheers! 
I have automated tests with nearly 100% coverage which solve that "checking if it still works" problem. So it boils down to updating a version number by hand, which is tedious and surely could be automated too. I think that small modules should not be harder than monolithic approarch, if you have proper tools. Maybe I should go write a couple of shell-scripts, rather than spamming reddit with stupid questions... :)
Is this a micro services setup or more breaking it into libraries?
Greenkeeper https://greenkeeper.io/
Another thing for a thing for a thing. Redditors will eat it up!
Have you considered setting up a private npm repository with something like Nexus OSS and publishing modules to that instead of using NPM link. Then NPM update package would take care of your dependency issue and you wouldn't be linking all over the place.
thank you so much for creating this service! i have a few queztions about the data set: how often is the data updated? is it possible to get more detailed data about a specific game? things like goal scorers, cards etc..?
Yes, this is the whole idea. When you're a one-man show like me and developing a DB-backed tool, having to simultaneously extend both front and back end for every widget I add just slows things down. Now I can bang out the logic in a hurry entirely on the front end and once it's set, it's nearly a copy/paste to move it to a dedicated route on the back end while still reaping the benefits of auto-transactions and whatnot in the SQL engine.
I speak spanish, we don't have a different pronoun for inanimate objects. Even more, we don't use the pronoun often because we conjugate the verbs: "He has to go" -&gt; "(el) Tiene que irse" "It has to go" -&gt; "(el) Tiene que irse"
You would be correct, however you would have to add that SQL everytime, look at in the context of code volume and work performed. You have a secure backend that parses your sql code because you wanted the flexibility to just write whatever. Now in every product you have, you have SQL bits all strewn about your application, in every product, lets assume something simple 1000 likes of SQL, not to bad considering joins, etc, etc. Every Product has similar needs, you want to query users, you have SQL blocks that you need to write to do this, or copy/paste. If you built an API then you only need to reference your API end point and handle authentication on your products side, also you can ship updates to the server without needing to update the product(s). In your example it might make sense for you, but just know its a terrible way to design applications. You will end up with more error prone code. You should always build with the future in mind, I know I have said it in the last 2 responses, but an api spec that you're comfortable with and have maybe as a starter repo for each future product would be such a nicer experience to work with overall.
That's close but I want that the "objects" are defined inside the template. In this case if the template was "your age is {{age}}", the schema would have no sense. My case of use is for pre made email templates. Some templates my need to enter a weight some, an age or some in the future my need a address field, I don't want to program everytime these change. I want an intelligent program that know what to ask extracting the variables directly from the template.
Yeah, that's exactly what I want to do!
`ncu -u` will even do it for you
Thats why I actually get my functions directly from my colombian supplier.
What do you mean with "all"? I don't get it :) . I had a good experience with graphql, I worked in a project that we use graphql in production with nodejs in a huge website with more than 33M of unique accesses by month and for us the graphql solved all our scenarios, did you saw any scenario that the graphql could not fit for you?
In-house framework over here.
Rube Goldberg tools / frameworks and workflows. I was at a JS conference recently, where some of the speakers spoke about issues related to "scale", and how the ever increasing "scale" that JS has been tackling has necessitated some of the tools, techniques and workflows that we see in the JS world (both front-end and server side). It's amusing really. All of this bullshit just to avoid Java and Swift, both of which in 2016 offer incredible tooling and a best-in-class development experience, far, far superior to what a solution like this can ever hope to offer. And that argument of having a single code-base targeting multiple platforms - possibly the most misleading lie propagated by these pseudo-unified platforms. Ready for all the downvotes, because..... JavaScript.
Interesting tidbit! In any case, I was talking about gender classified nouns, and you do have those in Spanish (with the *el* and *la* article). Btw, I feel kind of silly right now, arguing with a spaniard about his own language that I know almost nothing about. ;)
I thought this was NFL data :(
Thoroughly agree. In a lot of cases, if one would just stick to the basics, the fundamentals, they would save themselves more effort and time by just understanding what's going on instead of trying to piecemeal it all together and then they wind up with something they don't know how it works.
JavaScript is a good language to learn. It's a little funky especially in how it deals with objects. It was the first language I learned but I didn't fully appreciate how objects where supposed to work until I leaned C# later on. I think you will do fine starting with JavaScript just learn that Python or another less quirky language later to contrast the stage parts of JavaScript.
Here's my little project that utilizes this hack: https://github.com/xpl/stacktracey
Hapi is really nice for making RESTful services. We use Hapi for those and Express or Koa for websites. Take a look at joi as well to use in combination with Hapi.
FYI, I took all the feedback here and fleshed it out a bit. You can now easily add traditional REST API routes and disable the raw API, but still let the engine enforce authentication and permissions. Also added a feature to prevent a malicious user from doing custom queries with the the raw API enabled by essentially recording all the queries your front end uses during testing and disallowing new ones after flipping a switch.
Well that escalates quickly. Nice work!
I used this project once to split up a python repo - http://furius.ca/snakefood/
Express is still a very solid and popular framework despite Koa, and it's very easy to build RESTful API servers with it. I'm not worried about its future. All my API projects use express, and lately with a swagger layer to define the API.
Seconded for hapi if you're building an API for the app. It's far simpler than Express to implement, so if you don't need everything Express does, it'll pay you back in the lack of complexity. 
i guess it makes more sense to use popular sports. popular around the world. *zing
Ah now I understand! Thanks
Former UI Architect of a unicorn startup here. Use whichever one you understand best and feel most productive in. Any major web framework that has a decent amount of community support can suit your needs. Basically, use whichever one you want, because they all suck, because the web sucks. /burnedout
he was asking for suggestions, don't be so fucking pedantic.
Do you need a hug?
Yes.
I'm confused why you have all of these modules published on npm. Are you hoping for community support and adoption of your modules? Are you using them on other projects / teams?
[nfldb-dump](https://raw.githubusercontent.com/BurntSushi/nfldb/master/scripts/nfldb-dump) will dump the data into fairly simple SQL scripts. If you need further help, /u/mcsballer, set up the database on heroku and leave me a comment/PM and I'll get it figured out.
There is a whole command line app that I love that is very similar to this https://github.com/architv/soccer-cli 
[Golden Layout](https://golden-layout.com/)?
These are parts of a big messy opensource framework, which are more meaningful as separate projects. They are more helpful when separated. Each module has its own documentation page (`README.md`) and a unit test (runs with `npm test`). And you should also think about reducing module's dependencies, to keep things small and minimalistic; avoiding things like polluting global namespace or extending builtin types; etc etc. So its a way of achieving better code quality. When you work with monolithic proprietary stuff, code is usually a mess — because it's easy to write a mess. And no one will see it. But when you take "small public modules" strategy, it automatically implies hard constraints on code quality. So it's soft of a self discipline :)
Former express user. Jumped to Hapi because the future was uncertain. Swagger addition is nice. They even have Lab test suite and Code assertion testing library. It's more of a complete package. I personally love type checking. And hence use typescript with Hapi. No issues with type definitions. 
It seems like they could be built as separated modules without being published on npm - simply have them in separate directories, with their tests along side them. Especially if you don't see the individual modules being useful on their own, and the project is being updated in lock step with its dependencies... this seems like a lot of work for not a lot of gain. I agree that thinking of parts of a project as discrete modules is very useful, I just question the wisdom of having them all published and managed by npm - which seems to be the root of your problem.
I see no reason not to make them public if they're quality product. It's a crime not to publish them in such case ;) They could be re-used by other people.
I'm trying to solve two problems with Node.js development that left me feeling overwhelmed at the start: * the Coke vs Pepsi problem: you shouldn't need to do in depth research on frameworks, modules, and other tools in order to get started. Most of them will do the job just fine and few are 10x better than the other. I recommend one and only one choice in the playbook * the Discovery problem: there is excellent documentation on developing with Node.js ... in a hundred different places. I'm taking the most important important bits and putting them in a playbook to make them easy to find in one place. Please let me know how I can make this better for you!
how is it pedantic, he wanted a low lvl language and you recommend [python](http://i.imgur.com/lB5wmMp.png)
Haha! I agree with you wholeheartedly. I wish I was in the room when the decision to use Node.js was made, because I would have definitely advocated to use Java. I have a feeling, due to the way "AWS" is thrown around with such reverence, that "Node" was decided due to trendiness and not due to any technical reasons. I'm simply a lowly dev who happens to be the "JavaScript Expert(tm)" on the team and want to try and suggest to my team a way to ease the impact of this decision (which I assume involved business/management input as well).
Wholeheartedly agree!
If you install either locally or globally or even both you will always be able to use the package and cli tools. 'Local' and 'global' npm package installs just change where it goes. For a local install the package will end up in the node_modules folder with you application. The reason many people suggest installing packages that come with CLI tools globally is because your OS is configured to search the global install directory for cli commands. If you install locally you can still access them though as I stated './node_modules/.bin/babel' for example. The reason I advocate to install locally is because if you have multiple projects on the same machine, or you work with others, then global installs can lead to version conflicts between the projects. E.g a project uses webpack 1 but a different project uses webpack 2. You'd have to uninstall and reinstall the correct version when switching between projects. Annoying. Local installs allow you to scope the package and version to its specific project. I suggest you read up more on how npm works :)
i like turtles
This is some great information! Thanks!
At the moment probably not much, slightly different syntax. Obviously chancejs is way more mature and feature rich. I'm just interested in doing this because it allows me to learn and mess with different types of data such as the GPS mentioned above.
At my company we have historically used Java (Grails) for our applications. In the last year we have added capabilities to use NodeJS. From what I can tell, most of us (we have ~40 developers) prefer NodeJS. One of the main things we like is that the NodeJS applications can start up a lot quicker and the unit tests run a lot quicker. That makes test driven development a much more pleasurable experience.
&gt; "AWS" is thrown around with such reverence My organization has been going through an AWS push this year. After putting a number of months into it, my current preference is to avoid any service on AWS that isn't directly tied EC2 or S3. I've attempted to adopt a dozen services or so and have never once felt like I saved time or effort in the process. To the contrary, things I thought would solve my problem have turned out to either solve a different problem or to solve it only after a considerable amount of tweaking and shuffling the problem around to fit the service. As for your specific question, my preferred node framework is the Hapi stack but any of the major ones would work fine. The integration with Joi for input validation is very nice and the stack fits together nicely even if it does have annoyingly bizarre names. I managed to get it running in full on Lambda using the unit testing framework in order to bypass the dumpster fire that is API Gateway** and it's the one thing in that project that went well. Unfortunately the AWS js sdk wound up losing permissions on requests to Dynamo randomly and rather than debug it, I rewrote the entire thing in Python (because boto3 works) and it's been running fine on ec2 since. I'll also second the recommendation of sticking with a JVM language given your team's background. If you do wind up going with node, introducing Flow/Typescript once the prototype is out will probably save you time and effort. I say after because I think dynamic languages are good for getting started and static ones are good for keeping things maintained. A gradual type system lets you have your cake and eat it too. Good luck. ** Pattern match the path like `/`, `/{p1}`, `/{p1}/{p2}`, capture all the headers, then in your handler func rebuild the path and inject it with the headers into Hapi. Your handler also has to string serialize and base64 encode all non-200 responses ensuring the response code is the first param and then APIG can string match on the base64 encoded prefix, correctly set the response code, and send the decoded body. Annoying but after that's set up, you never have to deal with API Gateway again and you can actually have an API that behaves correctly in the presence of errors. Unfortunately, it won't save you from the random 2s pauses that you'll encounter when hitting a cold Lambda function. Yes, I am pretty bitter about all this.
i would just select by class: `document.querySelector('.game-score')` -- its literally the same thing as using `game.score` which you will now have to maintain.
No I don't want to control it through CSS. I want to put proper dimensions
you shouldn't really be doing that. but if you need to for some unknown reason just do `$(img).attr('width', '300px');`
Also, if you have any feature requests or things you think might improve it, please let me know. Thanks!
If you ever have to use a string more than once, yes absolutely it's good practice. I can't tell you how many times I've been bit in the ass by code that used string literals all over the place instead of storing it in one place.
This can hurt readability in the future but it's good practice when done right. In your file, wrapping your module like so can help: return (function(){ return { fun1: fun1, fun2: fun2 }; function fun1(){} function fun2(){} })(); This fixes namespacing, and shows future coders what is in the module right at the top in the return statement. ALWAYS name your api functions, this makes it very easy to debug during runtime. Non-named functions fail with output like "anonymous function", where your named functions will fail with a searchable function name.
Love and agree with your point about the gradual type system. It's my new happy place.
Is it because React doesn't use Web Components?
I'm in agreement about the future of Express. It was taken over by StrongLoop which was in turn taken over by IBM, after which point it was taken on as a top-priorety project at the Node Foundation. More info on that on Node Foundation's [blog](https://nodejs.org/en/blog/announcements/foundation-express-news/). I can say with a fair degree of confidence that Express won't be disappearing any time soon. That said, I've recently been working a lot with Koa, and I really like it. Using generators and yielding promises as opposed to using `.then(...)` or callbacks is actually much more intuitive than it sounds. In my experience with Koa, it's lent itself to much cleaner design patterns that are both minimalistic and easy to reason about. If you're interested in learning Koa, first check out the [README for co](https://github.com/tj/co), the library that Koa is built upon. However, for your purposes /u/lilactown, I think Hapi might be your best bet. I haven't used it, but it seems to have the most straightforward syntax for developing a RESTful interface. Best of luck to you and your team!
Like everyone else, at first I thought he was just being pedantic about the word "pure." But as I read through it, it just reminded me of why I'm not 100% sold on JS and would love to have some type of safer environment (WASM?). Consider the security implications of what he mentions. You can overwrite, and make crazy, any function call(incl. prototypes) available to the global scope. I mean this is stuff that any JS programmer knows, but doesn't want to think too deeply about. It is most certainly the type of vector that any XSS could use to do all sorts of nasty stuff. You could write all your code correctly, avoid the global scope like the plague, sanitize inputs, and still someone could use what he is describing here to inject an undesirable function directly into the middle of your code... Just because you assumed a string literal was safe -- to read. (I know... Why was foreign JS allowed in the first place? That is another issue... [Chrome extension, social engineering, JS console, etc?])
why dont you just add width and height the same exact way you are adding imageposition?
Thanks! I hope you mean `e.target` instead of this `this` :P. This makes everything a bit more consistent, and easier to modularize, especially if there are a lot of actions involved after something is "outclicked". The biggest advantage for me personally, is having exceptions to the outclick event, i.e. buttons or spaces on the document that don't initiate an outclick event. It prevents me from having a really long boolean in my onclick function. e.g. document.body.onclick=function(e){ if(_MENU_NODE != this &amp;&amp; EXCEPTION_ONE != this &amp;&amp; EXCEPTION_TWO != this ....and so on) do(something); } 
How about async/await? I'm using it with babel-register + express and it's been great.
If it's your own stuff, sure this is fine... whatever works. If you intend to distribute this for others to use - no one likes having a bunch of stuff exposed on `window` which this does Typically people will have one export they add to window - e.g., `MyLib` and all the functions go on that. You can do this in multiple files if you like - but if you don't you use some kind of module builder or concat everything into one file you'll wind up with some boiler plate. // file-1.js (function (exports) { if (!exports.MyLib) { exports.MyLib = {}) MyLib.DoThing = function (prms) { ...etc... } })(window) // file2 (function (exports) { if (!exports.MyLib) { exports.MyLib = {}) MyLib.LibMainFucntion = function (prms) { ...etc... } })(window) Of course, if you bring in a build step, you can concatenate a bunch of files into one, so you'll have a main.js or whatever and each lib gets sliced in // main (function (exports) { if (!exports.MyLib) { exports.MyLib = {}) // @include file1.js // @include file1.js })(window) // file1 MyLib.DoThing = function (params) {} // file2 MyLib.LibMainFucntion = function (params) {} You build step would need to look for `@include`, load the file and include its contents - output the results to a dist folder or something and use that. Now, the thing is - there's a new way of thinking for a lot of this stuff and its the idea that everything is a module and each file exports things that others can consume. There are a lot of solutions that will do this kind of thing for you - [browserify](http://browserify.org/), [systemjs](https://github.com/systemjs/systemjs) and [webpack](https://webpack.github.io/) are a few of them. You would put this at the top of files needing your library: import * as MyLib from './my-lib' MyLib.DoThing // function MyLib.LibMainFucntion // function and inside `my-lib.js` you might see something like this: export function DoThing (params) {} export function LibMainFucntion (params) {} These module bundlers knows how to deal with this and will typically create one file for you with everything hooked up properly.
Hapi
This guy is just an annoying jerk. I don't understand why anyone would want to watch this crap. I don't want people with this attitude being shared around in our community. I don't just say that cause he gets all whiney about Babel and I've worked on Babel since the early days. I say it because he has an awful attitude and talks shit about things before he's even figured out what they are.
FYI would-be viewers, it's another standard "bread, white bread, wholemeal bread, sourdough bread, toast, french toast, fried eggs, scrambled eggs, poached eggs, boiled eggs, butter, marmalade, jam, chocolate spread, milk, orange juice, apple juice, plain bowl, stripy bowl, don't even get me *started* on cereal, WHY IS BREAKFAST SO HARD?" rant.
I have little server-side JS experience, but I'm having a great time learning with Hapi. The documentation is great! 
What the fuck is this?
Do the elements persist through the lifecycle of the page? If so then just keep a reference to the elements themselves. Not repeating the IDs is a good DRY practice *but* if you're calling ```document.getElementById()``` more than once you're not having the browser do a look up for that ID each time. So instead just store the element itself. Just don't forget to axe the reference to the element later should they not always be around on the page's lifecycle :) (don't want any pesky memory leaks)
Well done! Currently trying to find some more time for mine!
then i think, am not getting this react thing yet, do you mind explaining, how i can do that?
Many developers see the problems of JavaScript and just think we use it because we don't know better (even when a lot of us also developed in C, C++, Lisp, etc. before and are also coding in Go and Rust). They don't realize that JavaScript is, today, one of the convenient tools we use. It's flawed, of course, but most tools that are less flawed are also less powerful. And there's also those kids who think they can look cool by dismissing a language and mock JavaScript because *"NaN isn't even equal to NaN"* or *"a string can be equal to a number, JavaScript is retarded"*. And yes, there's a little too much bullshit in our community, with too many frameworks or libs being instantaneously famous mostly because they have a cool web page.
Something like this: http://jsbin.com/jozewokeno/edit?js Each component has its own internal state, so you can't change the state of App directly from ButtonForm. Instead you pass a function into ButtonForm as a prop, which allows you to change the state of App.
Yeah... I read the blog post - not the HN thread - and kept wondering where the hate is that he's talking about? The only real point he mentioned from the HN thread was this valid one.
Great example of a welcoming member of the JS community ;)
&gt; Many developers see the problems of JavaScript and just think we use it because we don't know better god damn this is so spot on. Fuckers, I know all those other languages and I get why people go gaga over the current hottest lisp (seriously writing in clojure is pretty awesome, check it out). I *choose* to use JavaScript for a number of reasons. How purely it was designed isn't very high up there.
Hi /u/ISchrodingerscat, it looks like you're new to /r/javascript, welcome! Thanks for the submissions, but please make sure you read our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `nitinprabhakar.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [blog.nitinprabhakar.com](/search?q=%28and+site%3A%27blog.nitinprabhakar.com%27+author%3A%27ISchrodingerscat%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|7|100% 
Feel free to report crap like this.
- Express is still great and I think the drama has been resolved. - koa is a little bit lower level then express it's more similar to connect which express is based on, I would probably not use that without an explicit reason - sails, this is more of a orm framework, i'd avoid this as that sort of this is usually great to start but as soon as you get to advance stuff it can be tricky to do that stuff within the framework - hapi, this is a similar to express but coming from a very different direction while I have no experience with it I have heard some very good things from people who I respect especially from more enterprise-y people so you probably won't go wrong with this
I'm trying to solve two problems with Node.js development that left me feeling overwhelmed at the start: * the Coke vs Pepsi problem: you shouldn't need to do in depth research on frameworks, modules, and other tools in order to get started. Most of them will do the job just fine and few are 10x better than the other. I recommend one and only one choice in the playbook * the Discovery problem: there is excellent documentation on developing with Node.js ... in a hundred different places. I'm taking the most important important bits and putting them in a playbook to make them easy to find in one place. Please let me know how I can make this better for you! *I [submitted this yesterday](https://www.reddit.com/r/javascript/comments/500sd4/nodejs_playbook_a_guide_to_getting_started_fast/?st=isg29jhz&amp;sh=f69f5e8c), but I think the timing must have been bad so I'm giving it another shot. Lemme know if this is against subreddit rules please (didn't see anything against it!).*
There's an incredible amount of sloppiness permissible by JavaScript, which gives teams incredible amounts of rope to hang themselves with, which is why there's so much iteration on libraries and frameworks. It's like if people had been forced to make huge apps in Perl. I might personally have the discipline to not write awful, unreadable spaghetti, but if my organization as a whole doesn't, it's going to be a mess. With tight deadlines, it's super tempting for people to relax some of that discipline, too. Frameworks don't just organize my code. They provide glue and conventions that allow me to more easily work with other people without having to fight them on every stupid detail. You can write good vanilla JS, but there are a lot of ways to do the same thing. i.e. Perl's motto TMTOWTDI (There's More Than One Way To Do It). Just because you have experience and received mentoring, the sloppiness doesn't have to come from your code, but it can come from how your code clashes with someone else's, who had different experience and different mentoring, where one isn't necessarily any more valid than the other. JS might provide 5 different ways to do something, but a framework might reduce it to one obvious way. Good frameworks will provide an escape, in case one of the 5 is clearly better for your situation. To get a team working together on a big project with a language like JS basically requires a framework. If it's not someone else's, you're deciding on a bunch of conventions internally and effectively rolling your own framework. When you have a lot of freedom, figuring out how to constrain it, to allow a team to mesh, and to what degree to constrain it isn't some simple thing. It's a really hard problem. Struggling with it doesn't make devs amateurish. It's not trivial bullshit.
This is fantastic. While I think the organinc tree expansion is annoying (I see it everywhere) this is a great example of what I want. However the main thing I want is not the dependencies among other modules, but the ES6 import dependency tree within the module. I think I'm failing to find something close enough, making me excited to author one myself as a good exercise. =)
For atom I'd recommend having command line code to run, commented with what each extension does. I would also add in GitLab as a VCS, and have links to each. Not finished reading yet, will update later with more recommendations. Can also submit a PR in about 8hrs. Thanks for doing this! Good read. I consider myself just past beginner in Node.js right now. 
I actually agree with him 100%, except for his pronunciation of "baybel" :)
The `this` keyword in events will always be the element that the event is attached (unless you are using arrow or bound functions).
I reviewed them all. There are ~10,000 react libraries / components on npm. The list contains 385 entries. So no, 3% is far from "fucking everything"
Hi /u/lucasmajer, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `hecodes.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [hecodes.com](/search?q=%28and+site%3A%27hecodes.com%27+author%3A%27lucasmajer%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|16|100%
Yes, that was what I was saying - the example wasn't mine :)
Don't use global dependencies, can't it pick up the local eslint? 
Nooo. I think GitHub should still be the goto, simply because its the most ubiquitous. Recruiters look there, everyone knows of it, most open source projects are there. However, GitLab is cheaper and has some cooler features. I added some issues to the github page. I was thinking more of listing pros/cons of each, and recommending github overall. I think you should only have these main 3 tho. Ill get my atom stuff together and submit a PR later. Added issues with my suggestions to the repo.
Move the connection logic to its own module, and expose a function that wraps the connection pooling logic in a promise or something. That should do the trick. 
Took some reading, but that was perfect. Thankyou!
I would also recommend x-posting to /r/programming. Its a bigger community. If you want to wait until its more complete that'd be understandable, but posting there may get you more contributors. 
Okay, let me rephrase to "everything remotely considerable in a production environment". My point is that "curated" seems to imply opinionated, but you apparently don't have one. A list of 385 items is fucking useless. I'd get to what I want quicker just using Google.
Thanks, looking forward to the PR! I'm going to limit the playbook to one recommendation for the moment, because the overall goal is to reduce decision making in getting started. Maybe there should be a second tool that lists other options when you're ready to explore. And thanks for adding those issues! 
&gt; Lemme know if this is against subreddit rules please (didn't see anything against it!). Nothing specific in our guidelines, but it's generally advised against in reddit's guidelines, because it comes across as spammy. As long as you don't make a habit of it, no problem :)
Sounds like you're in the early learning stages. Got something that you may find useful. I keep a big list of links to high-quality tutorials and articles on React and related topics, at https://github.com/markerikson/react-redux-links . It's specifically intended to be a great starting point for anyone trying to learn the ecosystem. In particular, there's a whole page full of [React tutorials](https://github.com/markerikson/react-redux-links/blob/master/react-tutorials.md) that ought to help you.
I just finished my music visualizer, that I'm building for study. Now I would like to increment this demo, creating alternatives to apply real-time effects to the sound. Do you guys know any libs that could help me? or maybe I could try to do something from sketch.
Last year, I wrote a bot that checks Steam status and posts changes to a Discord channel. It's pretty hacked together, but it might help: https://bitbucket.org/s992/discord-steam-notifier/overview If I recall correctly, I already had an account created and joined to the appropriate server and channel, so the bot just connects and starts updating that channel. There's no readme or anything because I never intended to release it, but feel free to reply here if you have any questions.
Thanks! I figured that bad post timing was a good justification :). I think the content is pretty valuable.
Thanks. Feels great to see so much enthusiasm from contributors! 
It looks like it can under certain circumstances, but I'm not sure what those are. It probably can if you setup a project with the same root as your node_modules folder. All I could find were issues about edge cases where it didn't work. - https://github.com/roadhump/SublimeLinter-eslint/issues/108 - https://github.com/roadhump/SublimeLinter-eslint/issues/116 
Yeah... zloirock, or his real name Denis, is an extremely active contributor to the community who has dedicated his time to open source even when he was out of work. Who the hell is he? He's someone who's actually done shit, he's someone who contributes something to the world. Unlike the person in this video who just spouts negativity hoping for someone to care People have no idea how hard open source is. People like Denis deserve respect.
Right so museums only curate one piece and are mostly empty. I'd rather see a *curated* list well organized than Google for fucking hours only to find a bunch of well marketed/poorly coded shit.
Ok point taken. Thanks. I've removed all occurrences of the word "curated". It's now "Catalog of React Components". As for Google, are you really happy with Google to find your programming libraries? E.g., good luck finding the list of React UI frameworks. Thanks to this catalog, this becomes trivial: https://github.com/brillout/awesome-react-components#ui-frameworks
Find an API that gives results you want, and then make an HTTP call, then sendMessage back to the channel that requested it. I don't know anything about stock APIs, though, but the actual code part is pretty simple. When I wrote my discord bot, I looked at current projects to sorta see what other people were doing, and I also heavily used their documentation (https://discordjs.readthedocs.io/en/latest/)
Just beat it by 1, `a=&gt;({1:'I',4:'IV',1500:'MD'})[a]||'MCMLXXXVI'` As well as beating N Parameters by 6 `a=&gt;[0,2,6,,,,600][a&amp;7]` More tests are definitely needed. EDIT: Beat that by 5, I love binary AND, `x=&gt;x&amp;1?'I':x&amp;9?'MD':x&amp;2?'MCMLXXXVI':'IV'`
Probably because that was the first comment they got... i dunno still feels curated to me. /Shrug
Yeah, I'll write more, and put some edge cases in too, thanks!
Check out the speed of Node.js + Cosmic JS https://developers.google.com/speed/pagespeed/insights/?url=http%3A%2F%2Freal-estate.cosmicapp.co%2F
Rules are rules but if he posts quality content like this and enriches the sub as a result I don't mind at all. I come here to find posts like this and would not have otherwise.
Thanks! Let's just assume I'm particularly clueless 5 year old here. :P To output that in my page, which happens to be in php but I doubt that's necessary, can I just enclose the above in a "&lt;script&gt;"? I tried that and it's not doing anything. Or can I put your line in the script in the head, and then use php to echo the total? I'm seriously at sea here. I really appreciate your help. :)
Why would you want to use float64s instead of ints? If your goal is to store binary data, ints seem more standard and easier to work with ... right?
GreenSock might work for you. Checkout these CodePens: http://codepen.io/GreenSock/pens/popular [This one](http://codepen.io/GreenSock/pen/HxzEl) has a relevant animation.
Zooming will rely heavily on the content inside. There isn't really a "zoom" style so you would likely need to adjust all elements inside the viewport to a certain perspective. I think the features you are looking for are all exemplified in Google Maps. You may even be able to use [that API](https://developers.google.com/maps/) to recreate a similar, customized interaction.
r/javascript is about the coding language, javascript (and related components like frameworks/tools/web development/etc), so with that in mind, are you planning on actually writing code/developing the website yourself or are you using a CMS like wordpress to build your site? If it's the ladder, I would check out wordpress forums/etc for help on a gallery-layout plugin that may be able to give you what you're looking for. Writing a custom-animation function from scratch can be a difficult challenge for brand new developers &amp; something that quite honestly can't be done without a lot of hand-holding. If you do take the coding approach, you could look into some jquery plugins like bootstrap image gallery.
I'm writing it myself. I've familiarized myself with HTML and CSS and now I'm trying to dive into the deep end with javascript. My portfolio site is sort of my learning project. I've heard mentions of Jquery, I'll check it out. Thank you.
It doesn't, except for NaNs. The IEEE behavior may be surprising depending on your background, is all. As for NaNs, you shouldn't assume the bit pattern will be stable under any operation, though in practice copying a value from one var to another will be stable. But e.g. writing a NaN to a regular array in v8 will destroy its bit pattern.
Thanks for the feedback, I should definitely add some kind of `removeEventListener` function. In terms of iterating through all the custom handlers, there's not much more I can do, perhaps I could use `setTimeout` to clear up the stack a bit. You can do something similar with :hover in CSS, maybe that's what you're referring to? Nevertheless, thanks for the constructive criticism!
lol, yea it's a bit odd but it's standard
This is awesome. I'll be keeping an eye on it. Looking at the upcoming recommendations, what are the advantages of using throng over node's cluster module?
Thanks, and please let me know how I can make this more useful! Throng itself uses the cluster module. But more importantly it fits the goals of the playbook: it gets you started fast with minimal learning or work.
If you want to brush up on JavaScript basics, you can check out my book “[Speaking JavaScript](http://speakingjs.com/es5/)”. Start with this chapter to find out whether you like my style: http://speakingjs.com/es5/ch01.html
many thanks!
I see what you're doing here - but wouldn't this be more performant if implemented via CSS? Maybe creating classes for the images with a wrapper? Just playing devil's advocate.
Here's another performance [article](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers) direct from the bluebird devs. It's specific to v8 but I bet some of the tips translate to other engines. 
Hi /u/metacage, we're going to need to see the code. Either inline (if it's not much), or preferably, on jsfiddle.net or codepen.io. What you're describing non-sensical, so perhaps if we could see the problem in action we can help. Just reply to this comment when you update your post with code. Thanks!
Sorry my post doesn't make much sense because I said button instead of link. Basically, I have a bunch of links and I want clicking on a link to go to another page in my website and then immediately change the h1 of that new page depending on which link was clicked. Does this make more sense? Cheers
I wouldn't recommend vim or Sublime to new users. vim takes time to learn, and new users can get frustrated easily if they have to learn a whole new thing before even starting to learn the thing they signed up for. Sublime costs a decent chunk of money and has some significant problems (major bugs that have gone unfixed for years, many plugin developers switching to Atom and abandoning projects, lack of tooling for newer things, etc). I personally would stick with Atom as the best-supported choice or Visual Studio Code if that's too slow and clunky for you. VS Code is free, much faster than Atom, and has really excellent JavaScript support. Students can get WebStorm for free but I would recommend that they stick with Atom or VS Code at first, because WebStorm like vim can be overwhelming for newcomers.
&gt; in depth research on frameworks, modules, and other tools in order to get started for a novice project you are correct, but as a professional/sr. level dev you should always research every aspect of your project or it will own you. 
$70 is not a lot for a professional tool. My time alone costs that much to my organization PER HOUR. 
I would not recommend Vim to beginners either, but good luck editing any file over a MB in Atom.
Yes, it's not a lot for a professional tool. But the people asking for help figuring out what editor to use aren't professionals. A lot of them are students and teenagers, for whom US$70 is a decent chunk of change. And a lot of them are from places where US$70 can be multiple days' work, we get a lot of Indians and Eastern Europeans in #learnprogramming. So it's a factor that matters.
100% agreed. The playbook itself states: &gt; * This is **not the only way** to develop with Node.js. Use this playbook to get started, then use other choices when applicable &gt; * This is **not the best way** to develop with Node.js. It is *a way* that is good enough to get started without a lot of learning overhead
If you have that kind of size for your code, the may I suggest that you are doing something really wrong? Because that's a hell of a lot for just some text 
Webstorm
When was the last time you used Atom? It was buggy in beta but it's been rock solid for a while now. I haven't had any issues loading large files (unless they're huge, but if you're trying to hand-edit a 50,000 line JSON file with syntax highlighting, you should reconsider your approach to begin with...)
This is hilarious. 
As someone learning node the past few months and trying to navigate the ecosystem and make sense of everything, thank you for making this. I'll be following the repo closely and look forward to contributing.
You're exactly the audience I had in mind. You're welcome! Let me know the playbook doesn't address any problem you face as you learn Node.js
Maybe its an SQL or XML data dump?
Awesome thanks for the help! Is this info clearly stated somewhere like on developer.mozilla.org?
/u/SachaGreif This has wrong set of images. Update: images have been corrected.
Oh you're right! I hadn't realized that the dataset for the graphs was linked to the previous article… Let me fix it. 
&gt; As a contributor to Babel, Babel will not make you more productive. That was never the intention of the project, we never once said it was. The people saying it will make you more productive are fooling themselves. I'm sure yourself along with the other Babel folks have not said that. Having said that every single JavaScript developer I know who uses Babel claims it makes them far more productive because of the new ES6 syntax. Every single one of them. I see this constantly repeated on the internet all over the place. So maybe Babel isn't saying it but it's most certainly a narrative that's very common. &gt; But people better stop going around crying that Babel is now a requirement for all JavaScript. I agree. I'm glad I did not do that *at all* :). But many people *are* making it a requirement to use *their* JavaScript which I think is the wrong way to use Babel but I digress. (Judging by the downvotes on my comment it seems people *think* I said this; perhaps they should go back and re-read my post. Oh well) &gt; So stop being cranky, it's even less productive. Meh, it only took a couple of minutes to write. Not losing any productivity here. Now i've run into a lot of code that went from "yeah just grab my lib, it works great!" to "oh yeah and include Babel and these other 6 dependencies just to build it". In my own, personal experience it's splintering JavaScript. Fortunately once ES6 is more, natively available it won't be an issue but right now it can be downright annoying / problematic.
Ded gaem
I think it's just general convention adopted from UNIX man pages. I have no idea where it's explicitly spelled out anymore tbh
I feel like it adds complexity to a project without much benefit. Sure you can save a few strokes in a bunch of places but it requires learning a new syntax. I think the adoption of ES6 influenced this with its new features and guarantee of universal adoption.
[Scoping rules that are completely broken and unlike any other language.](http://lucumr.pocoo.org/2011/12/22/implicit-scoping-in-coffeescript/) Seriously, being bitten by that was enough to make me never want to use the language again, as nice as it made some things. And since Babel, there's really no reason to use it.
Wow! Taking that survey on mobile was so nasty!
This is cool but I have absolutely no idea what's going on - A short guide would go a long way.
Very interesting read, thanks! Now a warning for all the little boys and girls reading this: Don't do this at work! Seriously, this should be nobody's default way of writing JavaScript. Once you start doing such optimizations, you should be very aware of their implications. Some of the tips from this post will make debugging more difficult and increase your maintenance burden. So unless you're writing performance-critical code where profiling has shown such measures have measurable impact, please refrain from doing this :)
Thx, for feedback. I will add a guide :) For start there is some information about game mechanics: http://epoh.io/rules.html
I think you're reading a bit too much into it. It's just a way to get stats on how many developers have adopted the new features introduced by ES6, or are interested by them. 
**Your first turn:** Click on your base. Base actions will appear at the bottom of the screen. There is one worker garrisoned in the base. You can ungarrison it by clicking ungarrison action and destination tile. All units move only by one tile so you can only ungarrison worker next to the base. Select base again, you can build a new worker by selecting 'worker' action and destination tile. Worker costs 100 iron. You can see your current resources in bottom left of the screen in format [resource amount]/[max storage] income. **Discover resources &amp; build a mine:** Move workers around the map to discover resources on map tiles. Resource type is indicated by small circle on tile. Also tile &amp; unit stats can be visible while hovering on tile in the top right section of the map. When you discover resource on tile with a worker you can build mine on it. To build a mine select worker and destination tile. Each building requires resources and you will not be allowed to build if you don't have enought of them. Building a mine on a tile with resource will increase your income of that resource. Building bigmine will allso increase storage capacity. You can see how much resources each building/unit costs by hoving on their build action image. **Build units:** Select base to build units. Your combat units can fight enemy units &amp; takover enemy structures (except rover). **Special worker buildings:** Build amplifier to expand territory. Build teleport for fast unit transportation between tiles. Build powerplants on gas, oil or coal when you run out of power.
I'm going to take a step away from language features here -- I hate reading CoffeeScript written by other people. It's almost always guaranteed difficult to grok without re-reading multiple times, in fact I have come back to CoffeeScript code written by myself and I have a hard time reading it. The language itself has warts (like every language) but the way people use it makes me very uncomfortable.
*Vanilla* JavaScript, *Coffee*Script… I'm just sayin'
Added some code to my original post - hope it helps
&gt;why TypeScript? Yeah, why? And why in /r/javascript and not in /r/typescript?
Does this obscure the application sources? 
because TypeScript is compiled to JavaScript. Will repost on /r/typescript...Thanks!
Undoutably: if everything is wrapped up in a single file then the source will be obscured from the casual observer. But this is highly unlikely to be done in a manner that is not easily reversed by a less casual observer (i.e. another developer rather than a user). The code needs to be in a stage that node can run it from so even if it is encoded in some manner within the resulting file it will need to be decoded to run so the decoding code (and any keys required if the encoding is an attempt at encryption rather than just escaping and compression) must be present in the executable too. Do another dev could easily extract that code that would be passed to node. To try get around this you would need to try obscure your code a bit first, via minification and/or similar which can make it harder to read the code (but still ultimately doesn't hide its function from anything more than a casual user).
&gt; I want the code to generate (total records/number of records per page) number of buttons, then I want to take the value of that button and pass it into already existing code to grab the right section of the data table. I understand you need this part: http://codepen.io/Linuxdirk/pen/KgPgvZ?editors=1010
Arguably it's the docs fault for doing it that way. I think it may be better if it showed the actual function declaration. `client.auth(password, callback=null);` or the like
That's like driving a car &amp; finding it sad that the next model can't fly
Of course the example given in "minimize function object allocation" is potentially optimising for speed over code clarity, as you are now defining the inner functions in a wider scope. A valid optimisation in the context of performance being a high priority, especially in tight loops, but this is an optimisation that you shouldn't design in from scratch because if you don't need it you are better keeping the code clarity for maintainability. Make it work, then make it work correctly, only then worry about making it work fast (if it isn't fast enough already).
What exactly are these user strings going to be used for?
Every time I've thought about doing this securely, I give up and find a way not to use eval() :)
Isn't that something new on ES6?
&gt;One thing that distinguishes JavaScript from other programming languages is that JavaScript isn’t just one language Very first line and you know there's no reason to read further.
Im a new node learner. Can you recommend an alternative resource for getting started with developing a new node project? 
I don't know much about Elm or ClojureScript but don't they compile to JS? A flavor would be more of a subset/superset, think Typescript A language that compiles down to X is a different language, otherwise Scala, Clojure, Kotlin are just flavors of Java (don't tell any engineers that they will chop your head off lol)
&gt; for I highly value ES5's paradigm What paradigm, and how is it different from ES6's? And why would Node be a reason for liking ES6?
The main reason are not language-specific characteristics, it's that it's a compile-to-Javascript language with no hope of being implemented by browsers natively. Now that Javascript has adopted most of the features that made CS appealing, _while having_ buy-in from browser-vendors, there's not much reason to stick to a language that is dependent on a few developers maintaining it. Theoretically, WebAssembly might breathe new life into it if CS will ever be able to compile to that, but I think it'll have but disappeared by that time, and to not be different enough from Javascript (especially with ES6+ then being widely adopted) to actually have the appeal that a significantly different language like Elm has. tl;dr Long-term maintainability.
As I said [elsewhere](https://www.reddit.com/r/javascript/comments/508w6j/the_state_of_javascript_javascript_flavors/d72ih23): &gt; The main reason are not language-specific characteristics, it's that it's a compile-to-Javascript language with no hope of being implemented by browsers natively. Now that Javascript has adopted most of the features that made CS appealing, while having buy-in from browser-vendors, there's not much reason to stick to a language that is dependent on a few developers maintaining it. &gt; &gt;Theoretically, WebAssembly might breathe new life into it if CS will ever be able to compile to that, but I think it'll have but disappeared by that time, and to not be different enough from Javascript (especially with ES6+ then being widely adopted) to actually have the appeal that a significantly different language like Elm has. &gt; &gt; tl;dr Long-term maintainability.
A nice boost in GC. I'd be interested to know if there's a measurable difference in _overall_ performance.
I will have a look :)
Thanks! I am looking to make more improvements to the app itself as well as taking any feedback/ideas if you have any.
Kite looks exactly like what I'm looking for.. with even way more functionality. I'll keep an eye on that.
This was excellent, thank you for sharing!
The core of the question is "do you use the new features, Babel, and polyfills or do you go dependency-free?" There's still a market for minimal-build workflows, especially on basic static landing pages.
That's a bit shortsighted. It's just survey data, not an opinion piece.
"Sorry boss, our servers are hijacked again due to malicious JS injection because we don't have a proper sandbox and the script we cobbled together is still not capable of detecting any bad code that's stuffed into it!" - "Why the hell don't we have a proper sandbox?" - "For performance reasons ..."
By the time you sanitize to an equivalent level of security yours will be slower. It's not like they are peppering their code with calls to sleep(500)...
That's his statement of fact. Not opinion.
Okay so it can't be done then - thank you for answering my question :) 
I have been working on this app (https://github.com/vutran/dext) for the past few weeks. It is a smart launcher and is a very early build. Based in Alfred and Spotlight for Mac, I'm looking to grow the app and be extendable for custom themes and plugins. Feedback, ideas, and contributions are welcomed. :)
Considering BTTF had flying cars in 2015, I think my sadness is justified.
As they do on Blogger and Tumblr.
Which form you guys use and if there are some other considerations which we missed
I thought the point of it all was a pun, since Java and Coffee are beverages.
The subject is Medium. Medium used to be a respectable place to get published but it hasn't been for a long time and reddit hasn't figured that out yet.
Dude you're reading way too much into things. Get over it. EDIT: just looked at your post history. LOL
Most likely a joke.
Because it's crap. I used it in a project for 2 years, and it's 97% useless and a crutch for people who don't know what they're doing in JS. 
I think everyone will have their preferences, but there's also specific behaviors that different function formats have that could influence your choice for any particular use case. You list out some of the differences, but there are many more, most if not all should be [documented on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions). For your particular case, it doesn't really matter. That function is simple enough that any function format will do. Most people will likely prefer the arrow function if using ES6 for the inline case for its brevity. Other than that it can be anything.
Usually, one of the first lines of the function/method would be something like callback = callback || null; or you'll just ask if callback is defined before using it.
I've seen a project which uses ['notevil'](https://www.npmjs.com/package/notevil) to parse user land JS.
 var sanitized = JSON.stringify(userString); var code = 'var foo = '+sanitized+'; console.log(foo);'; eval(code); If you were talking about users supplying actual code (not just text strings to be embedded into _your_ code), all bets are off. You can't tell if code is malicious without running it. So sandboxing would be the only way to protect the user.
If you have to use eval(), at the very least make sure you're sandboxed in a web worker.
Apologies if I sound stupid here but how do I pull the data in json form? I tried this and it didn't work curl https://github.com/openfootball/football.json/blob/master/2016-17/at.1.clubs.json Looks like an awesome job you've done, I'm inspired now that I don't have to spend 30+ a month minimum.
About fucking time.. Another year before RTM though... /s
Many features doesn't break old code, why aren't they included in typescript 1?
Because backporting is hard and not often worth it. This happens all over the place. For example, you don't expect non-breaking features from node 4.0 to appear in node 0.10.
Some time last week.
Then what's the problem?
Tagged unions look nice, but I'm sad that they decided to use the word `kind`, since that already has an established meaning in type theory: https://en.wikipedia.org/wiki/Kind_(type_theory)
Btw, this is the kind of knowledge that you should never need unless you are maintaining a hard-core library and you REALLY needs it. Otherwise, the code of your project was probably touched by a legion of wannabes that love using complex stuff to show off and ensure a single job for life. Interesting nevertheless.
Certainly, but an official blog has used the word `kind`, placing it as a blessed term and it will quickly disseminate through the community.
I'm sorry, do I hear you bitching about FOSS? Why don't you just make your own, surely it'll be done faster? Great work @typescriptteam, you guys are awesome.
/u/zachrip didn't imply anything like that by using the term FOSS. They were pointing out that you didn't pay for it nor did you contribute to it so you have no right to complain. 
Guess what you're gonna have to do to get this done securely... 
Yes, makes sense! I also prefer to extract extensive functionality to stand alone function also for readability reasons.
The users create mini-games, so the strings would be for messages popping up on the screen. They'll also provide numbers which will be used as arguments to functions. I can probably just `/0-9*/` that but there might be encoding tricks to get around it that I don't know about, but that some good library captures. 
Don't think this will work. :( Web workers don't share memory with the rest of the app and the eval'd code needs to interact with a PIXI.js instance at 60fps.
Did you try searching? * [How do you obfuscate (protect) your closed-source JavaScript code?](https://www.reddit.com/r/javascript/comments/2oj35b/how_do_you_obfuscate_protect_your_closedsource/) * [Obfuscation libraries for JS?](https://www.reddit.com/r/javascript/comments/4oum8k/obfuscation_libraries_for_js/) * [How do you guys obfuscate nowadays?](https://www.reddit.com/r/javascript/comments/4c6vd8/how_do_you_guys_obfuscate_nowadays/)
How I wished we had that option. We could compile our graphical objects to another language, and parse and execute that ourselves, but it'd be just as inefficient as using JS Interpreter.
First, if it's in the client side, you must consider that it will *always* be in the open; it doesn't matter if it's a SPA, JavaScript, native mobile client or desktop client -- if someone is willing to retrieve your code, they will. The only thing you can do is to make it harder to see the code, but not leaving it open. Basically, you don't have any control over the client side and, thus, anything can happen, including unauthorized access to the code. If it is really sensitive, you must put it on a server and run only there; if offline mode is a must, then you must be ready for someone to, eventually, get your code.
&gt; I don't know that I agree. I mean, a single blog post can influence a community, but I don't think that is often the case (even for official blogs). Sorry about the confusion. This is definitely something I did consider, but the other common term would've been `type` which is common in the Redux community (as far as I could tell). My feeling was that people would be even *more* confused for the reason you mentioned if I'd used the name `type`. Arguably, fewer people know what a kind is when it comes to type theory. I'm at least glad you pointed it out so that people can read our exchange.
https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes 2.0 looks to have some pretty strong breaking changes in it. Previous versions had breaking changes but they were pretty minor on the whole of things. 2.0 contains actual syntax and language changes. Also, how can 2.0 be a backport when it is the future and will be the current version? That doesn't make any sense. Backporting refers to the process of taking changes present on newer versions of code and applying it to older versions of code. It would be forwardporting if you are talking about moving something from a previous version to a newer version, but that usually indicates that you are doing something horrible if you have to do that.
Will `lib.dom.d.ts` be updated to use discriminated unions for the `Node.nodeType` field? Or will that mess with the current types too much? It feels like, if `Node.nodeType` is still a `number`, then `Element.nodeType` can't be a numeric literal since that would violate `Element extends Node`. `Node` would have to be rewritten to be a union type instead of an interface.
Anything on the client is insecure. Accept it, get over it, and build your application accordingly. 
Short answer: you can not. Client side code is impossible to hide, just curious, why do you want this? Stuff like handling passwords should not be client side anyway.
That's not what I'm implying at all and I don't know how you can say that. There are tons of FOSS projects managed by companies and I don't see how that matters.
The instanceof operator tests whether an object has in its prototype chain the prototype property of a constructor. [Source](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof?redirectlocale=en-US&amp;redirectslug=JavaScript/Reference/Operators/instanceof#Summary) When a function object is used as a constructor, a new object will be created and the new object will have its internal Prototype initialized with this prototype property. function Test() {} Test.prototype.Reddit = function(){console.log("Reddit")}; console.log(Object.getPrototypeOf(new Test()) === Test.prototype); # true **Edit:** I realize my screwup, sorry. I thought OP was asking the question
Server-Side: https://github.com/seejamescode/see-james-code/blob/master/server.js#L39 Client-Side: https://github.com/seejamescode/see-james-code/blob/master/src/Api.js#L14
lol "FOSS" . More like embrace,extend,extinguish as usual .
I see nothing in there that is wrong. What I see, though, is a lot of things which could break just about any code base. They changed syntax and semantics in a significant way. I wouldn't recommend that anyone stay with Typescript 1.x. You should update and fix your code to handle these problems. However, if you are relying on any of the behavior listed, I could see it being a significant amount of work to correct the code. In particular "Getters with no setters are automatically inferred to be readonly properties" This guy looks like it could cause a lot of headaches introducing new parameters and finding/fixing everywhere that depended on the old parameters. "TemplateStringsArray is now immutable" This one would suck royally if you depended on them being mutable. You would likely have to rewrite a significant chunk of code to make it work.
Does that mean I can never criticize any of the companies on their release cadence? That's off the table for some reason?
Yeah I am aware, not sure if there is any way of perhaps interpreting it once (slow) and making sure it isnt using any non-whitelisted functions and then evaling once its known its secure. Although JS being dynamic makes that incredibly difficult to do. 
&gt; Oh my god, no! It doesn't work the way you think it does. *[Because many existing USB devices have exploitable bugs], a USB device can define a set of origins that are allowed to connect to it. This is similar to the CORS mechanism in HTTP. In other words, WebUSB devices are associated with a web origin and can only be accessed from a page from the same origin.*
Still worth having the comment :)
&gt; "Getters with no setters are automatically inferred to be readonly properties" &gt; This guy looks like it could cause a lot of headaches introducing new parameters and finding/fixing everywhere that depended on the old parameters. I seriously doubt it is a problem for anyone. Is it even possible to make a property which has no setter but isn't effectively readonly? Without a setter someone could write directly to `myObject.myProp`, but you couldn't write a getter which read the member `this.myProp` directly, it would just call itself. &gt; "TemplateStringsArray is now immutable" &gt; This one would suck royally if you depended on them being mutable. You would likely have to rewrite a significant chunk of code to make it work. This only affects people who have written ES2015 template functions *and* thought that mutating a parameter was a good idea. A very small group, and easy enough to fix. Copy the array. 
Define "sensitive".
Then just make the code that you generate return a function that takes arguments, then invoke the function with the user provided strings 
You first said &gt; They let anybody write anything on Medium Which is true, but kind of irrelevant to point out. I'm not disagreeing with this statement, but what (I assume) your intent was on saying it. Then you said: &gt; Medium used to be a respectable place to get published With this one I directly disagree, without saying the same thing thing as you. I don't think publishing platforms where anyone can sign up can be classified as “respectable” in any way. People and content are respectable, but the blogging platforms are not.
sounds good. we have a problem that we need to verify the user using a fingerprint sensor connected using USB. today we use an installed component to solve the problem but it makes many other problems especially with maintenance. hope it will solve that 
Are you using a transpiler?
When Medium first came out, there was an editorial review and policy in place which kept garbage out. Then, one day, all that went out the window and that's when things went downhill. &gt;kind of irrelevant to point out I don't see what elephants have to do with this.
If I'm understanding correctly, it sounds like your program compiles into JavaScript on the user's browser. I am assuming then that these programs are shared between clients as some AST structure or something? You should not have JavaScript code compiled on one client and having that same JavaScript code served to another client even as one of those supplied strings. You should not use eval on strings concatenated with user text. Instead of using eval, I recommend using the [function constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function). I would use a javascript object to then pass the strings into the function after constructing it, if you are putting the string on the dom, make sure you use a Text node to avoid html injection. Doing it this way means that the browser never runs the JavaScript interpreter over the contents of the user strings. It would look something like this. var compiledProgram = new Function("strings","console.log(strings[0]+' '+strings[1])"); var strings = ['hello','world']; compiledProgram(strings); EDIT: as cspotcode as explained, you do not need to worry about escaping the strings if you insert them into text nodes 
Isn't that a requirement to write ES6?
Good news: you can still learn 1.8 and move to 2.0 without any major changes.
Sorry, I have to start with 1.0 to avoid spoilers.
Felt compelled to write at atom plugin at work for a direly needed task, learned I needed to learn coffeescript. Another project dead...
"Why" is such a silly word.
Ah, got it. Never considered that an app could be Chrome-only (or Webkit/Electron I guess?)
Concatting sanitized string with source code would have been the naive solution that I was wondering if I could improve on. This looks like a good improvement over that, thanks! Re your first paragraph: Your assumptions are correct. I will indeed ensure that compiled JS stays on the client and isn't shared with other client. One client will never need to trust JS from another client, because such trust would be ill founded as you say.
Does that mean var is not recommended to be used at all in a 2016 application that uses a transpiler?
Consider it punishment for using IE7-
Style guides like Airbnb's disallow `var`. ESLint, TSLint, and so on also all have a rule for this which is enabled by default in some cases. Don't use `var` in new code.
Based on the comments, particularly /u/Redundant_Randy's suggestion, it sounds like you don't need to execute any user-supplied code. You can execute code generated by your app and pass it user-supplied values, which is no different than running .js scripts from your webserver and passing them user-supplied values. ...but, if you *do* need to securely sandbox user-supplied JS code, you should check out Google Caja.
If there's style that's coming through a file that is overriding other styles, you could always try applying the !important attribute to your own css file. e.g. let's say your e-mail file came with a CSS like this: div { border: solid; } And now, you obviously don't want the border solid. So, go to your CSS and simply use: div { border: none !important; } Now your divs will always have no border, unless a more specific selector was used, but all things considered equal you'll be fine. This brings me to my next point/question though, why not just get the text of the html you're importing and just display the raw text? Seems like it would be a manual nightmare to constantly account for all the unpredictable css you're importing. Good luck!
What cases can you put forward where `let` is superior to `var`? The only case I ever see is for loops and a map or forEach is almost always a better solution (as is creating a dedicated function that the JIT will then inline).
Ha, it never occurred to me to display it as raw text. but using an iframe does it, and it looks pretty good. thanks.
Well, are you paying MS to be timely?
The problem here, in my opinion, is that you give a lot of ressources but you actually don't do anything more than that. This, to me is not really helping, actually I think it's quite the opposite. Let's say I am willing to try carpentry, and I go for your "carpentry playbook to getting started fast!". Fine, someone helped me get started. But all I see is : - You can buy A at general store. - Learning to use the different variants of B are a waste of time, just go to a random store and buy B", which is the variant I like - Don't ever try to understand how to use a chainsaw safely, just buy model C from general store 'whatever', and get down to business, it'll be fun - Etc... Etc... Applied to this context, I think you can see that following that playbook would be a very, very bad idea. Not to say that the intentions of the playbook are bad, but the content or lack of it thereof may be quite harmful. To me it is the same thing here with nodejs. Yes, it can be hard some times, and yes it takes time to understand. But nobody is asking you to know how the internals of node work, just what you need to get the job done, and nobody is asking you to be an expert before you get started. But working on something without having a clue about how things work is just a bad thing :/ I don't know how to phrase it differently, and I'm sorry if this seems to be rude, it is not the intent. This way of doing has been what led us to people building pages just by copy-pasting whatever they could find on the internet and that seemed to get the job done, and that we see here and there asking for help because they have no idea what they are doing. In the end it is a loss of time for every party involved. You seem to be into helping others get started, well then maybe write some kind of tutorial about the basics of node, and the tools/modules you are advocating. It doesn't have to be super extensive, and I think that it would be a way better thing to share than just giving this list of things. 
- Learn Javascript, if you don't already know the language - Just start The node core API should be more than enough to get you started : You can - Interact with the file system - Handle http requests - Perform http requests You don't really need more than that to get started, really. Yes, it'll be a bit annoying, it'll take time to have something running (not even that much actually, but it won't be as "cool") but you'll understand better how to properly use nodejs. In under a few hours of coding, you could then look at some modules to refactor your code. I'm thinking maybe Expressjs, instead of handling http requests yourself, and stuff like that. But in any case, don't throw 20 new modules you don't know in your project just because they look cool. If you need something, you'll find plenty of information here and there on the internet. I bet you can find some pretty decent node tutorials quite easily. And if you're stuck, then come ask for help because it is what the community is for :) But by any means, understand what you're doing because that'll save you a tooon of time in the long run.
Thank you. This is a step in the right direction. I'm probably in a minority here, but if you want wider adoption of Node as a platform, someone has to step up with a heavy hand and say: "Yes, there's a billion million ways to make a node app. There's a bajillion different frameworks and plugins. But this is how I/we are going to do it, because it is simple, these frameworks/plugins/editors have the most documentation and support, and this way provides the longest shelf life." 
You're welcome! I hope you'll contribute to the playbook. There is so much to add! &gt; But this is how I/we are going to do it I would correct that to: "this is all that most projects will need at the beginning". The playbook *must not* replace the hard work of figuring out the limitations of whatever you're using. I expect that as your needs grow you will find more sophisticated alternatives. For example, suppose for a particular need you have five choices: A, B, C, D, and E. D and E may not be good choices, but any of A, B, and C will do the job. So the playbook would recommend A. This *does not* mean that you shouldn't keep an open mind for B and C. You should be naturally curious about the differences and always be learning. The playbook is *just a way to get started* - it should not set your learning trajectory. I should probably add that to the playbook eh. Cheers!
 if (...) { let ... } Locality is a good thing. Only the block it's defined in matters. Also, most programmers are familiar with block scope. forEach is rarely any good. If you chain some array functions and put a forEach at the end, fine. Other than that, you're probably better off using for-of or maybe you actually want to use map there. Anyhow, let's try it the other way around: Are there any cases where `var` would be better in any shape or form than `let` and `const`? Well, there isn't. No one who stopped using it misses it.
Yup. I also trust MS to create much better developer tooling than FB, so removing gaps between typescript and flow is a big plus in my book.
What's wrong with that line? Honest question. To me it seems the fact that JavaScript has so many "flavors" (for lack of a better word) is pretty distinctive. I'm not aware of similar alternatives for languages like Ruby, Python, etc.
Im sure I had to post this at /r/node/ don't I?
TypeScript does sort of offer some "opt-in" features, this is where the `any` type comes in handy. You can also enable in `tsconfig` the ability to parse Javascript and slowly port over to TypeScript. There are definitely options. I don't work on a large team of developers, but we use TypeScript and once you have it integrated into your codebase, you realise the benefits it offers are for any size team.
you shouldn't be doing this because it's an extra HTML request which isnt necessary. Instead use a build process nodeJS + Gulp + nunjucks and pre-render your pages.
JavaScript is JavaScript. Everything else is built on top of JavaScript or compiles/interprets to it. Eventually it all boils down to JavaScript. It's only one language.
Check out "no_change" test cases at the bottom (it is a test for pure render/diff overhead that doesn't trigger any changes in DOM): https://cdn.rawgit.com/localvoid/6715c4b23eadc460112e671b4add3710/raw/907901966dd0473f1026d1ff25e244a022eb5ab1/uibench_results.html Try Inferno, it has a really small overhead and has almost the same API as React.
I can't disagree with that. Hopefully most other people were able to understand the actual meaning of what I was trying to say, without getting caught up on the "one language" part. 
The polyfills on MDN are often not production-ready, rather, they're a PoC. 
Yeah I enjoy flow for the fact I can apply it gradually, and it kinda goes ontop of traditional JS instead of being more of its own thing. But the tooling is lacking. Even though I setup my react component with typed props, using that component incorrectly causes no errors.
Out of curiosity, have you seen https://github.com/ProjectSeptemberInc/gl-react ?
10-4 will update in a minute I'm obviously an idiot with this stuff... I really appreciate the help 
Whoopsies should I delete my comment train?? I'm gonna update in a minute somehow
If you absolutely must do it yourself (and I would stress that I think it's a terrible idea), parse with [esprima](http://esprima.org/). Traverse the tree and edit any questionable nodes, add your wrapper function to contain it, then put it back together with [escodegen](https://github.com/estools/escodegen). There's probably a bit of startup time while the parsing, transform, and codegen takes place, but once it's inserted into a script tag, performance should be normal. You'd be faster than the interpreter, but would run a higher risk. Another solution would be a web worker. Everything they send to the main thread must be strings or JSON, so no functions will leak through accidentally. Most APIs should be available to them. Just add access to your proprietary ones as needed via wrappers and make sure they know that all your external interfaces return promises (because the message passing is async).
&gt; I see very little JS code where you actually want a local inside an if statement. I see a lot of code where you want to declare some variable on first use. for (let name of entryNames) { let extension = name.split('.').pop() || '?'; let decoder = this.decoders[extension]; if (decoder) { promises.push(decoder(entries[name], this.mimes[extension])); } else { promises.push(Promise.resolve(entries[name])); } } Do you think I want to clutter up the rest of my function's scope with those 3 temporary variables? Things are easier if they don't exist outside this loop. &gt; for..of is generally bad because it has extremely bad performance There isn't anything inherently slow about it. Dart's for-in (which is kinda like JS' for-of) is just as fast as a regular loop. All that iterator fluff is optimized away. &gt; sparse arrays Just don't use them if you want speed.
Actually, for you pastebin would be the best. http://pastebin.com/ Also be sure to remove any sensitive information.
I'll try but I'm apparently extra super special with this stuff on mobile... Here is a link to the code pen http://codepen.io/Pickengrin36/pen/BLBAyg I'll go to pastebin and update
Bro I have no idea what's sensitive and what's not 
http://pastebin.com/rZhffi7Q This is actually really neat... I'm gonna paste all kinds of random codes just to see what generates in code pen. Edit: i meant to put this on the code pen comment - not this one. I'm not doing myself any favours right now :/
You can apply TypeScript gradually as well with the `--allowJs` flag. TypeScript will be able to compile ES6+ down to earlier versions, and that'll allow you to convert files at your own pace.
First article I clicked was riddled with typos: https://mythbusters.js.org/date/timestamp.html Nice domain though.
Hi /u/1244124214, please use a service like [Codepen](http://codepen.io/pen/) or [JSFiddle](http://jsfiddle.net/) to share your code. Please reply to this comment once you have done so. Thanks!
r/webdev *I am a bot; I link the subreddits mentioned in the title for easy navigation*
It's alright! Got it solved in webdev. A div that contained the content was becoming hidden and as a result hiding it. I'm a fool, but it's fixed now.
Hey /u/DanielRosenwasser Assuming no big bugs are found, when can we expect a 2.0 final? Are we talking in 1 month time? a couple weeks? 
No, no... You must watch it in the [Machete Order](http://www.nomachetejuggling.com/2011/11/11/the-star-wars-saga-suggested-viewing-order/).
I guess you are right, you do not need to explicitly escape the strings as long as you are inserting the string into a text. I'll update my answer.
convert the data to JS, paste it in a file. see how big that file is if its ~1mb or less you can just stick it in the page. if it loads fast enough you can just stick it in the page. if not you can write a backend api (db or just in a file again, in memory), or use a free online DB `google firebase alternatives`, that you can query with ajax. again if the file is small enough you can just store it in memory, millions of entries probably want a db, but sometimes can get away with in memory but test the loading speed! its just a few lines of code imo using a framework like `express.js`. good orm(db) libraries are like nodeorm-2 `google best node orm` try 1: paste it as js array of objects on the client side (`appdata.js`) try 2: store as json on the server, `mydb = require('mydata.json'); response.write(to_json(mydb.filter(blah=&gt;blah.foo==123)))` try 3: store in firebase or db and serve api `express.route('/myapi/fetch/:id', (id)=&gt; response.write(to_Json(doDatabaseStuff(id))))` 
Thank you for your input :)
backend usually means engine, so in your case (Data) it would be webserver+database and optionally an API (ex: `mysite.com/dataAPI/get/id/123` and `mysite.com/dataApi/add {foo:bar, baz: 123}` `REST api, nodejs server/client, simple php/node backend, nodejs and database, expressJS, nodejs api router` are all good search terms what type of backend the easiest to write. so whatever language fits you most and google `api` youtube also has some nice tutorials `tutorial simple api in languageX`
Webstorm has also been good for typescript in my experience
Thanks for clarifying. **Re: providing a link and nothing more** This is purposeful. There are great resources out there that give you tutorials and sample code. I'm not going to duplicate that. I leave finding that to the reader as an exercise. They have to do some legwork to learn. I do however point them in a useful direction. **Re: stifling learning** I think you're interpreting this playbook way differently than most people, because this is not what I'm hearing from the feedback I'm getting. For most readers it's pretty clear that this is a starting point for their learning, and that as they develop they will explore and learn on their own. Nowhere does it say to "**never** learn alternatives". I've tried to make that clearer here: https://github.com/HiFaraz/node-playbook#how-to-use-this-playbook. Also no one has time to make thoughtful decisions about every aspect of their project. Your project will have unique needs in a few key areas, and 60-80% of your project will be and should be using standard parts. Anything else is too much mental load. **Re: copy/pasting** This is all up to individual attitude and will happen with or without a playbook I'm always up for making the playbook better, but I'm very clear on what the playbook is trying to accomplish: reduce decision making fatigue and help people discover new things they can do with Node.js. And hey, everyone likes to learn differently. I'm sensing you want something more in depth. Maybe I'll develop a more in depth version of this in the future! Cheers,
I've got a div with an id="pictures". When the button that has the rel="pictures" attached to it is clicked, jquery adds a # infront of the target so that it ends up reading $('#pictures').toggleFade(); and it shows that div. That's what I'm doing at least.
i've gotten this far in life (20+ years programming) w/o needing typing (perl, php, ruby, javascript). I don't think I'll ever need it.
For any reason other than speed? (Curious why I might want to switch.)
So the project is broken by management?
I want to run the whole script four times, but in one window. If I would paste the script 4 times then this program does not work properly. 
I use IDEA ultimate - never even touched vscode - the ts integration is very fluid and fast. Maybe it's the same way in vscode, but in idea: my ts files have a little arrow that lets me expand them like a folder to see the js and map files. The compiler is "live", and i can put the ts and js side-by-side. This helps me spot would-be errors (eg: i see as i type the ts that the object it's creating in js is assigning properties before instantiating). It IS fast, though - i see js coming out just as quick as i type ts, and i type code fairly quick. 
could you export it as a module then have a script that runs 4 instaces of the module
but i think /u/Zeludon answer is better
I still have no fucking clue what is this stuff.
And WebStorm now gets Flow support in the current EAP (beta) for 2016.3. I'm going with Flow, I don't want different code, just the types for static checks. My issue with MS is that given enough time all their stuff ends up *huge* and complex. Just try Visual Studio... I fear Visual Studio Code or even TypeScript won't remain relatively lean.
Interesting, but riddled with false statements or suboptimal solutions. &gt; Lookup tables `switch` statement with fixed `case` statements is as fast as lookup object and less error prone and requires less memory. &gt; Memoization Usually overlooked. Object without prototype(`Object.create(null)`) is more reliable than normal object. `Map` and `WeakSet` doesn't coerce your keys to strings. &gt; Setup the correct variables scope. It's preferred to always use `const` - `let` is less performant than `var` due to TDZ. Engine will eventually find out that variable isn't reassigned, but it helps developer to write better code. &gt; reverse iteration Usually it doesn't improve speed of JITed code, but only interpreted. However, speedup is visible only if cost of loop body is insignificant. &gt; Hidden Class It isn't V8-specific - SpiderMonkey use the same mechanism under the hood. &gt; Monomorphic over Polymorphic types Too restrictive - V8 differs small polymorphic and megamorphic types. Small polymorphic is fast enough for 99.9% of cases. &gt; Freeing memory by assigning null It's code smell - properly written code don't need to do such things. &gt; Preallocation Setting `.length=0` is very slow. `while(arr.length) arr.pop()` is faster. Though, using new array is probably preferred way as it improves readability and maintainability of code. &gt; To remove the returned item without re-addressing the array and invalidating all references to it, shift requires moving the entire array around. False (though `.pop` is faster than `.shift`, but it isn't implemented in such naive manner). &gt; arguments is special Outdated and AFAIR V8-centric. &gt; Avoid try/catch &gt; A good approach for supporting optimization with throweable code is to return an Error and later and check the type. No, it isn't. Just don't catch if you don't have to. &gt; new agnostic It isn't good practice - you should either always use `new` or never use `new`. Your code should run in strict mode to enforce it. 
But... why?
write a scenario, what do you want to happen? 4 users? 1 user? do you want it to track the same game for all users? do you want it to only track a game when one user logs in? are you wanting to track time on all users for one game? give a use case and a flow of what you want to happen from start to finish. 1) start script 2) 4 different accounts log in? 3) track the same game for all users, at the same time?
I think a lot of people hyped it, and then it was used for the wrong applications, and then those people blogged about what a terrible database it was. I guess the lesson is do your research beforehand, know how you're going to use it and decide based on that whether it's the right choice for your application.
While fun, this approach in my opinion is not very practical for real life projects. It adds another layer of abstraction (composition, piping, and other fun[ctional] goodies) to what is already abstract to the point of absolute simplicity - markup. There is no complex representation logic here, so these tools seem out of place. Once the project grows more than a couple of simple pure components, you will find yourself in an awkward refactoring spot, both because of the lack of lifecycle methods on functional components and due to lack of syntax sugar for the functional paradigm in JS which makes the whole thing a bit noisy. Simple tasks would become a puzzle. 
You could try TypeScript. TS 2.0 comes with non-nullable types, which really helps with avoiding most null/undefined issues. &gt; I would love it if I could tell Chrome or node to throw an exception when I try to access a property that isn't there. Strong mode did that. Too bad that that experiment didn't go anywhere. I really liked it.
The speed improvements I would say are pretty minor. It's not like using Sublime. There are features I just tend to like. The built in git/source control integration, the autocomplete even on vanilla JS is pretty nice. Having auto completes in Go has been pretty handy as well. I haven't used it very much yet, but I like the idea of having a built in debugger as well.
I uh, think you should learn a bit more about node/javascript if this stumps you.
http://canipush.today/--force
The MongoDB is an excellent database if you use it correctly. The nature of is structure his ideal for document based data types, not for relational ones. Always verify which database is the best for your data's type ;-)
Impossible to say. Best way to test is to apply to jobs and see.
That code doesn't look fine. Try this stuff: https://developers.google.com/web/fundamentals/primers/service-worker/update-a-service-worker?hl=en
There are 3 files. Each about 30Mb. I imagine I would have to use a db, right?
I've worked both with relational databases (Mysql, PostgreSQL) and NoSQL (mongoDB). The biggest problem right now with mongoDB is that joins/associations/relations are a pain to work with. Becauce mongoDB isn't build for those use cases So if you plan to build to large app, I wouldn't recommend mongodb 
Go for it right now. The most important is to get the job. You'll learn most of the stuff in there anyway. When I started with JS, I knew only basics. Some experience with Angular, React and Browserify. Got into new job and had to learn Webpack, hot reloading, ...
Same here. Sorry man. Maybe another font or name change is in order?
if you know your way around the DOM, can do some AJAX stuff and know some basic JS-patterns to structure your code (object literal, module pattern, basic prototype stuff) then you should be able to find a junior position as a fontend-developer easily. Of course you should also be fairly familiar with HTML and CSS. 
Fixed :)
Thanks for sharing those reasons, sounds useful indeed.
Hi /u/akaspi21, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
&gt;its slower than mysql (arguably?) While I agree with your other points, *generally* this should not be true. Also on the syntax note, it feels really nice not having to leave JS to query/update your DB and translate the results into native objects. I still don't use MongoDB, but I think a lot of the hate for NoSQL and Document Stores in general is rooted in the fact that folks who never really needed anything outside of a relational DB decided not to use a relational DB, for the first time ever, in production. OP, if you don't need highly distributed data stores, large scale search, or fancy caching, you probably don't need to ever look beyond relational DBs
It's funny because in both cases (everyone recommending it, and everyone not recommending it), the root problem is people blindly buying into trends of others when making tech decisions.
Here is the stupid part about applying for jobs: 1. They claim to want somebody with 5-8 years of experience and experts in Angular, React, Dojo, Ember, and every other framework that you don't need. In other industries this is a blanket qualification called a master's degree. 2. The perfect (at least how they perceive it) JavaScript developer doesn't exist.... so instead of waiting for hell to freeze over they hire somebody who is marginally better at understanding basic programming principles than simply copy/pasting code. This person is a dud they pay peanuts and expect very little from and treat like a high school drop out child when it comes to actual engineering efforts. 3. When number 2 doesn't pan out they give all the JavaScript work to a Java developer with 0 training in JavaScript. The Java developer doesn't want to write JavaScript but attempts to write Java in JavaScript and then blames the language for their failings. This is fucking stupid and everybody knows it. Just apply to the job and indicate you have tremendous potential and passion. You are willing to take market rate (low pay) to get your foot in the door. If you are enthusiastic enough during the interview you have a 50% chance of nailing the job depending upon whether the company has a mentoring culture or is desperate for somebody to do this work. I remember when I was hiring for my replacement back in the hayday of jQuery. I had to leave work for a year as my name came up for a military deployment. I needed somebody who could walk the DOM, so I phone screened all the applications before wasting their time to come for a face to face. I only read resumes just enough to get a name and phone number. 4 or 5 of the applications immediately dropped when I mentioned via email that jQuery wasn't an option. More than half the rest completely fumbled the phone screening. This was really simple shit like navigate to a paragraph on the page and make its background red in the browser console. There were only 4 who passed the phone screening. The first one, and most gifted, failed out because the company couldn't get his visa sponsorship in order before he interviewed elsewhere for a better offer. A second one got a better offer while interviewing with me, and only two made it to the face to face.
three.js is awesome, go with it. As for "better" options, I think it's the best option for the level of abstraction it offers. It's up to you, OP, to decide if that level of abstraction is right for you. Personally, I think three.js is just low-level enough that you can infinitely experiment and have well-performing code, while high-level enough to not have to put up with browser-specific headaches. Three.js targets WebGL (and several other renderers). Instead of Three.js, you can use WebGL directly. If you want to focus on working with animation and graphics conceptually, focus on Three.js. If you want to learn about the graphics pipeline and how graphics interacts with hardware, focus on WebGL. You're bound to lose focus and fail if you try to learn too many things at one time, and from the post it sounds like three.js offers the level of abstraction you're looking for. You can generally be safe assuming the code will work on other browsers, but even in the rare cases when it doesn't, you should probably just focus on mastering animation and implementing whatever it is you want to implement. Browser compatibility is a distraction that you can easily take care of in the future.
does anyone else find this quote odd... &gt;But most importantly this will make USB safer and easier to use by bringing it to the Web. has bringing anything to the web ever made it safer?
&gt;Ulterius is an open-source, free software utility
This should work: opentype.load('fonts/Roboto-Black.ttf',function(err, font){ resolve(font); });
to have the exp of a 1-2yr exp JS engineer, make the following apps: a one page app, a form, an ajax form, a form with input validation/error highlighting (and optionally tooltips or tour), an app that polls an api. something with animation (tween/transitions/css3 are 3 completly different ways to animate). convert your app to jquery or vanilla and then to angular or react. that will give you exp greater than equal to a 1-2yr exp dev. `each app can be done in a day 3-5 hrs so its totally easy` and read one JS book front to back, know all the concepts. 
yea if the data isnt gonna change though: you could just load it in memory for a nodejs dedicated server, 30mb is nothing, u can even do it for free on cloud9 or heroku. firebase or `google free firebase alternatives` may be a really good option also.
the problem is its almost school time and I'm sure I won't have time for that, by the way I don't want to learn a whole new language just to run a few steam accounts.
It's a fantastic option and like the other poster said, low-level enough that you can manipulate it in creative ways and not be annoyed by WebGL. I'd recommend [PixiJS](http://www.pixijs.com/) though if three.js seems too complicated at first. It's higher-level but from what I've used of it, it feels easier to comprehend than three.js. Edit: Fair warning, Pixi is a 2D solution. three.js is still the best option for 3D.
Don't use jQuery fades. Use CSS transitions and opacity.
3, when I turn on the program it logs in to the account and starts playing the games I want. Example, if I want to run Team Fortress 2 I can find its ID by going to its store page and looking at the link "http://store.steampowered.com/app/440/" so I'm using ID 440 to run Team Fortress 2. And I want to do that for 4 accounts. I'm already doing it, but then my dekstop gets crowded with windows of CMD's so I want to run all four of accounts that would farm hours on games at the same time not using 4 CMD's. I want to use only 1 CMD for all 4 of the accounts.
Hey thanks man, I'll definitely start applying. 
You need to resolve the promise in the callback of the `opentype.load` function. There also *should be* an error happening, it's just getting swallowed by the promise, I believe (`font` should throw a reference error since it is not declared in the scope you're trying to use it in). Since it looks like you're already using ES2015 via `Promise`, you can tidy your code by using arrow functions: let p = new Promise((resolve, reject) =&gt; { opentype.load('fonts/Roboto-Black.ttf', (err, font) =&gt; resolve(font)) }); p.then(response =&gt; { finalModel.models[0] = new makerjs.models.Text(response, 'Hello', 100*i, false); document.getElementById('div1').innerHTML = makerjs.exporter.toSVG(finalModel); });
You're right... I totally forgot about ads. Woops
Of course I read the page. Two people spent almost a year working on a fairly stable and polished web application so I'm curious _why_. Are they just dedicated devs who are passionate about a server control app? Are they funded by a larger company? Do they plan on adding advertisements or maybe a cloud hosted version? Or do they just love software and do it as a hobby? Like it or not "open source" is a successful business model: https://techcrunch.com/2016/02/09/the-money-in-open-source-software/
I don't know what ES2015 is, but I got errors due to declaration with `let` and also `=&gt;` I did this, but didn't work (Guess this is the same thing suggested by @wFakerr) var p = new Promise(function(resolve, reject) { opentype.load('fonts/Roboto-Black.ttf', function(err, font) { if (err) { reject('error') } else { resolve(font) } }); }); p.then(function (response) { finalModel.models[0] = new makerjs.models.Text(response, 'Hello', 100*i, false); document.getElementById('div1').innerHTML = makerjs.exporter.toSVG(finalModel); })
I'm probably the worst person to ask for a code review, but one thing I noticed is you use **$scope**. It's best to reference the controller name directly. For example you could do: const someCntrl = this; //or const someCntrl = $scope; That way you can always see what the $scope is referencing/attached to. 
These days anytime I read an article that completely praises one piece of tech, while shitting on another I immediately disregard it. 
Thanks. I like the structuring a lot. Need to figure out who he did it though. 
Are you saying something along the lines of var MyControllerScope = $scope And then continue like usual? ^(and use MyControllerScope instead everywhere) 
Never. I would use mongoDB for this ! 
where are you running this code, and what version? Do you have a `Promise` polyfill loaded, or is it just native? ES2015 is essentially synonymous with ES6, the newest spec for javascript. It introduced keywords like `let`, arrow functions `() =&gt; {}`, and the new `Promise` object. The code you just shared should also work. For more info on promises, check this page https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise
I would recommend (anim8js)[github.com/ClickerMonkey/anim8js] to handle the animation side of things
I am running the code on safari 9.1.1 I have added this library `&lt;script src="https://www.promisejs.org/polyfills/promise-7.0.4.min.js"&gt;&lt;/script&gt;`
Or paid support, or pro features/dual licensing
Well yeah, but what if for everything else you want to use a relational db. For example, I was working on a personal app that I stopped working on, everything was normal Postgres, but for "profile info" I decided to just store JSON blobs in Text columns until I figured out what I wanted to be included. You see any flaws in that approach? 
Using that polyfill I was able to get it to work in this codepen (I faked the async call with setTimeout, but the code is nearly identical) http://codepen.io/jfurfaro/pen/wzwNRO I'm running Safari 9.1.2
I'm the creator - I would love to hear what people think of what's presented - and also if it could be presented in a better way. Thanks! reply
Yeah, I was totally bummed when I found out microsoft wanted me to put EACH ts file in the tsconfig.json, but I've found a couple things that make me like it: - the main.ts file, kind of like sass, that can import whatever I want (so I really only need one file in tsconfig) - Intellij has only a couple of options in its config panel for ts, but it can read a tsconfig file from the directory the ts are in. That's been sort of priceless. 
Safari 9 doesn't support `let`, but 10 will. Safari Tech Preview is currently at 100% coverage AFAIK
mongo, imho, has a very specific use case. that is to say of your data can be modeled in a very flat way with limited to no relations to other datasets.... then mongo works perfectly. The instant you have a relation to another table you're better off using something designed for that purpose (read: a relational database - i.e. something not mongo)
Sorry I just used the title I used on server forums, indeed its a two man project as I mentioned in the blog. Here is his twitter https://twitter.com/frobthebuilder
Great to hear!
Have you tried Preact? https://github.com/developit/preact/ It adopts the same API as React so migrating over is very simple.
This looks promising. I'll take a gander at this tomorrow. Thanks for the tip. (^ _^ ) 
"Umbilicus"
I should start by saying I appreciate the time you've taken to explain your views and how patient you are. &gt; but it basically glues on some other tools that jut out to the side of it, and don't follow in the same model or expand upon it So what makes it difficult to follow you is that there's a lot of explaining, but no concrete examples. So let me give one. By minimalist, do you mean "small amount of code needed to do a lot"? Because if so, how is const squaredThenSummed = [1, 3, 3, 7] .map(x =&gt; x*x) .reduce((acc, v) =&gt; acc + v); Not more minimalist than const squaredThenSummed = [1, 3, 3, 7] .map(function(x){ return x*x; }) .reduce(function(acc, v){ return acc + v; }); ? &gt; ode seemed to have the same philosophy of neglecting the paradigm of JS and just seeing it as nothing more than a blunt vessel for events. Can you write a line of code in Node that disregards Javascript's paradigm? &gt; How many times have you seen that using `this` is bad practice because it's confusing Never, really... &gt; Node and ES6 both treat JS as if it were what people misunderstood it to be. I don't really know about the ideas of the Node developers, but as far as I'm aware, many of those who work on the ES spec see Javascript as a language that handles functional concepts relatively well (especially for a widely used language!) but is also flexible enough to lend itself to other paradigms. That in itself is a pretty nice paradigm, IMHO.
Fallopium
Keep in mind I don't know Angular very well, so don't assume what you see are best practices. I just wanted to point out an alternative to scope. 
Show something with disk/db/network IO, maybe throw in concurrent and/or chained IO to demonstrate your knowledge of handling async events in JS, that will be mostly what you would be doing for most web-apps anyway.
Short gameplay guide **Your first turn:** Click on your base. Base actions will appear at the bottom of the screen. There is one worker garrisoned in the base. You can ungarrison it by clicking ungarrison action and destination tile. All units move only by one tile so you can only ungarrison worker next to the base. Select base again, you can build a new worker by selecting 'worker' action and destination tile. Worker costs 100 iron. You can see your current resources in bottom left of the screen in format [resource amount]/[max storage] income. **Discover resources &amp; build a mine:** Move workers around the map to discover resources on map tiles. Resource type is indicated by small circle on tile. Also tile &amp; unit stats can be visible while hovering on tile in the top right section of the map. When you discover resource on tile with a worker you can build mine on it. To build a mine select worker and destination tile. Each building requires resources and you will not be allowed to build if you don't have enought of them. Building a mine on a tile with resource will increase your income of that resource. Building bigmine will allso increase storage capacity. You can see how much resources each building/unit costs by hoving on their build action image. **Build units:** Select base to build units. Your combat units can fight enemy units &amp; takover enemy structures (except rover). **Special worker buildings:** Build amplifier to expand territory. Build teleport for fast unit transportation between tiles. Build powerplants on gas, oil or coal when you run out of power.
Not him, but Pixi.js is awesome. I've been developing a client's website with it over the past ~4 months, using the newest dev commits as they they get pushed to github. The best thing about it other than general performance is that 95% of what you code will work with a canvas fallback if WebGL isn't available on a browser, which makes compatibility super simple. It's also fairly easy to debug and adapt to.
Hi /u/iagesmart1, this post was removed because /r/javascript is not a job board.
Sorry if something I did in the past upset, I'll be the first to admit I was a very egocentric and rude. The last year has been a very big wake-up call however and I'm trying to focus more on positive contributions to the communities I partake in. My DM's on Twitter and email are always open to chatting. My humor is still very dry though, its a bit flattering you made a new reddit acocunt to call me a tool.
Thank you that was great!
Thanks! Figured it out
You probably noticed that you can now use globs in your tsconfig.json, so you don't need to list each ts file anymore.
Write a file archive utility. The one NPM uses has had a checkered past and nobody else has written one in JavaScript. The maintainer of this utility at NPM has expressed openness for something better and this work will not be added to Node.js core. It is sorely needed. If you really want to demonstrate how much of a badass you are then work on this.
That's cool - a really solid start. The camera movement is in dire need of being freely controlled instead of clicking about to warp the point of view though. Where's the source? EDIT: Doh, missed the github ribbon at the start.
Pretty cool. It could use some minor UI tweak to make easier to tell what's going on at a glance.
That is odd! I just checked Postman and had success with: Get: https://medium.com/@seejamescode/latest Headers: Accept - application/json
This turns up on every thread about this, but the reference is constant, not the object 
Minesweeper
Weird works for me now. I was looking at using [medium-nodejs-sdk](https://github.com/Medium/medium-sdk-nodejs) but i don't need it now just to read posts. Thanks. By the way your site looks good. 
Just tried it out and got an error. Here is what I did for the setup: * Installed on server * Forwarded ports on router to the server (22006,22007,22008,22009) * In IIS i set up a website using a subdomain for the binding (server.example.com) and forwarded the requests to 22006. * Attached my wildcard cert to that url binding * Navigate to https://server.example.com and the page comes up correctly * Click connect with server.example.com and port 22007 in the connection info boxes Chrome gives the following error: &gt; Mixed Content: The page at 'https://server.example.com/#/?_k=j4drbp' was loaded over HTTPS, but attempted to connect to the insecure WebSocket endpoint 'ws://server.example.com:22007/'. This request has been blocked; this endpoint must be available over WSS. &gt; &gt; n.connect @ bundle.js:37 &gt; connect @ bundle.js:59 &gt; l @ bundle.js:3 &gt; i @ bundle.js:3 &gt; o @ bundle.js:3 &gt; p @ bundle.js:3 &gt; d @ bundle.js:3 &gt; t @ bundle.js:3 &gt; processEventQueue @ bundle.js:3 &gt; l @ bundle.js:17 &gt; handleTopLevel @ bundle.js:17 &gt; u @ bundle.js:19 &gt; perform @ bundle.js:3 &gt; batchedUpdates @ bundle.js:19 &gt; u @ bundle.js:3 &gt; dispatchEvent @ bundle.js:19 &gt; &gt; Failed to connect. bundle.js:37 Thoughts?
Alright, thanks. Where could I go an configure it? (Or is it compiled in and not an accessible via the configuration file)
Give me a bit, I'll add the option into the server to load a certificate. 
I will admit that there was a time when MongoDB was just horrendous back in its early incarnation. It suffered from poor write performance and the hacks implemented to make writes basically just involved removing any checks. So you had instances where you weren't even sure the data you were writing was being written, akin to throwing spaghetti against a wall and seeing what sticks to it. Then there were issues with scaling, that caused a lot of controversy. There was even a time when MongoDB didn't support atomicity, so the concept of transactions like you get in MySQL, etc did not exist (they do now). Having said that, a lot of the blog posts you will encounter about issues in MongoDB are dated back from around 2012 through to 2014. The one post that got the most attention is Sarah Mei's post titled [Why You Should Never Use MongoDB](http://www.sarahmei.com/blog/2013/11/11/why-you-should-never-use-mongodb/) dated back in 2013. While MongoDB was definitely not good in 2013, in this particular case the Diaspora team were trying to use MongoDB which is a non-relational document store as a relational database and encountered issues, eventually switching to MySQL. A case of choosing the wrong tool for the job. I had experience working with a video startup in 2014/2015, they were using MongoDB, but I believe they were using it correctly for video metadata and analytics. A lot of the issues that people encounter with MongoDB (as highlighted in that linked post) are the result of using it incorrectly. Having said that, most of the companies/startups that do use it, end up paying for support because sometimes not even the documentation can save you. For simple needs, it can do the job, but the time and cost it can take to get it working in a production environment sometimes outweighs its limited advantages. Just because a tool is being abused and misused, trying to fit a square peg in a round hole: doesn't make it bad. Having said that, I find there are very few situations where a database like PostgreSQL wouldn't do the job for you. MongoDB besides its simplicity in how data is stored has no advantage over a traditional RDBMS. I wouldn't pick MongoDB in 2016, if I needed a key-value document store, I would choose something like RethinkDB instead.
I did NOT notice that. I just started MAYBE a week ago - is that in the newest release? I saw a node package that allows it, but I think the main.ts that just pulls in others fits my needs better. I've sort of carved out a workflow that works really well for me: I already have a gulpfile that I'm very happy, so i give a custom out dir to my tsconfig, and pass that dir to the usual dist task for min and things like that. 
I need help because the button is not working. 
What I've seen is at the top of the function scope something like: if(cb === undefined){ cb = options } for the arguments `fn(x, options, cb)` or the like.
It sounds like you want `getName` to *always* return a Promise. In that case, consider wrapping the entire body of your `getName` function within `new Promise`. After all, you need to construct a promise no matter what, so you can do it right at the top. Your success callback cannot possibly be passed a promise. This is because the Promise spec detects when a promise is resolved with another promise and unwraps it. Calling `resolve(anotherPromise)` means "Resolve with the resolution value of this other promise. Wait for anotherPromise to resolve, get its value, and resolve to that." It's technically possible for a rejection value to be a promise, but that's not happening in your example. I think this is what you want to do: var getName = function(person) { return new Promise(function(resolve, reject) { if (!person) { reject(); } else { if (true) { // Async task resolve({person: person}); } else { reject({error: 'person not available'}); } } }); };
To add to the noise, I'd say there are generally 2 categories of MongoDB complaints: Complaints general to NoSQL Databases, and those specific to Mongo. For the NoSQL complaints, most run along the lines of NoSQL DBs being valid for some use cases, but because they're superficially easier to get started with than a typical SQL DB, a lot of developers have started using them for everything, which is a problem However, there are a lot of complaints about Mongo specifically. There is a consistent claim about it being unreliable, to the point that under certain conditions, it won't return all valid responses to a query. I'm far from an expert on the topic, but the advice I've been given over and over is that even for a valid NoSQL scenario, Mongo is rarely the best option.
Here's how I'd do it: http://codepen.io/anon/pen/vXBoAK?editors=0010 The logic for checking the bounds starts on line 32.
Thanks! Can't believe I could not get help with the code review though.
Curl. Regex. :)
You can use a plugin fro browserify to split out the polyfills: http://stackoverflow.com/a/27751223 For my usage, we don't really use them, or if we do, it's so small we just inline them in the js or the page.
Something involving streams. RxJS. They'll either be aware of it and impressed that you are too, or they'll be wondering where you've been all their life.
Plus you'll have 450 lines of code to spare
I have a few questions: 1) Is there a plugin architecture? Can someone add to their own instance? Say i want to build a media center remote, or be part of my home IoT hub, or monitor services running on the machine. Would it be hard to build those things as external pieces of code? 2) The site looks great on a desktop, but what about mobile? Is there plans to support mobile? 3) What does the security model for this look like? Are people responsible for fronting the webapp with a SSL terminating reverse proxy? Does the login integrate with any user management systems? 4) How can we get involved? What do you need help with? Are you ready to start taking contributions from the public?
I didn't realize RDP had a command line, process management, webcam streaming, and file system access support. I guess I need to get caught up in my IT tech. 
Firstly - in future, upload code to jsfiddle or any other code sites, don't use google docs as it doesn't do syntax highlighting and makes it hard to read. Next, on this line gender = prompt ("letter =="b" || letter == "B"))?"boy":"girl"; You have two closing parenthesis )) - that's wrong as you only opened one (. 
Plugins are currently supported, as as it stands you can write c# plugins that are loaded at runtime, these plugins have a two events, Setup and Start, you can execute the plugin api from the client which will run a plugin, data can be returned from it. I am finishing up the ping system so a plugin can let the main api know it has new data for the client. I will update the wiki with all the relevant information soon. We have a volunteer working on the Android application and we're looking for someone to help with iOS. The server uses AES/RSA to encrypt traffic, nothing is in plaintext. It uses a similar handshake to TLS. Instructions for installing a certificate will be on the wiki very soon. It might be easier to just use a reverse proxy to terminal SSL however. The login currently supports local and domain account authentication. There are plans to make it extendable into custom methods of validation (say by your own api) Pull request are accepted on any of the repos, we will have roadmaps for each repo up before the end of the week. If you see an improvement that can be made feel free to contribute. The client maintainer is the one who signs off on client contributions but he can always use the extra hand. Off the top of my head I know we could use a lot of help with browser compatiablity and making the design more responsive. 
UPNP is enabled so you shouldn't have to forward them, however I can introduce TCP hole punching pretty easily if needed. I'll go ahead and add it to the roadmap 
That would be much better than UPNP! You have a product you can sell then. I'll buy it. So what I'd want is a website to go to where I can see all the connected clients and when I click on them, I get in. If you could organize them by company and maybe have a way for a particular company to be able to install the client themselves from a link you give them...kind of like screen connect then people will pay for this. Make it cheap as hell and crush the market. 
Considering I'll have to setup a traversal server it might be a paid feature, i'll see how i can mange it. 
The per machines thing is the same model the industry uses. It kinda blows but if you come in cheaper than everyone else, that'll be nice. If you can get away with going per server you install it on, I'd do that. You're going to have trouble competing in the space with the big boys. Maybe I'm asking too much there. Maybe 20 bucks per machine for upgrades and patches for 2.5 years. Now if it's 20 bucks per machine forever with no recurring then yeah....that'd be awesome. In fact, that might be better. You'd get a lot of people that way. Anyhow, good luck but connecting without having to open ports or rely on upnp is a must. 
Yes, it does, since all those things are available through the OS. Is there some actual advantage here that I'm missing? Other than only needing a web browser instead of an rdp client? Also, if you still use Windows routinely in this day and age, then yes, you really need to get caught up.
It calls items.length number of async function calls in a synchronous loop thereby running them in parallel. Its basically Promise.all without the promises.
Yep, I did exactly the same... 'Uterus' - Maybe needs a name change...
Quickly wired it up from another project to visualize custom schemas. Thanks to the wonderful JS community, I was able to add a few good libraries right away. It supports JSON references ('$ref's ) including external ones and does not crash if the schema is circular, but might act weird. Will be rewriting soon, we depend on schemas heavily, and ours are quite complex. 
One of the main parts is going to be the server I have to login to to see all my clients. That's the server part I was talking about. If I have to manage all my clients without having a central console/server, it's not worth it.
This isn't *parallelism*, it's *concurrency*. https://blog.golang.org/concurrency-is-not-parallelism It's a talk about Go, but it's not very Go specific so the language shouldn't matter.
I'm not sure in what way this is better than Promise.all tbh, nice exercise but I think it's not so useful in the scheme of things 
Node with Request and Cheerio. Here's a great video on how to do it step by step: https://www.youtube.com/watch?v=LJHpm0J688Y Request is for simplifying HTTP requests with Node and Cheerio let's you use JQuery syntax on the server side to target elements
Correct - there are many things wrong with this entire file. Ternaries should be kept inside the parenthesis, which this certainly is not
Ah, thanks a ton!
Nevermind I'm an idiot, the DIV it loads into is set as hidden until an item is added...
You can always do this var genderPrompt = prompt ("Enter gender: "); gender = genderPrompt.toLowerCase() === "b" ? "boy":"girl"; Edit: I think this should help you out. If you don't understand the code, do ask ok function startGame() { var gender = "boy"; //default value of gender var numYears = prompt("Enter a number of years greater than 0: "); var genderPrompt = prompt ("Enter gender: "); gender = genderPrompt.toLowerCase() === "b" ? "boy":"girl"; // to get the first character/letter from gender var letter = gender[0]; var pronoun = gender === "boy"?"he":"she"; var name = prompt("Enter the hero's name: "); var city = prompt("Enter the name of a city: "); var monster = prompt("Enter a type of monster: "); var food = prompt("Enter a good you like: "); var drink = prompt("Enter a drinki you like: "); /*Insert the remaining code below*/ } For more info, read this : https://developer.mozilla.org/en-US/docs/Web/API/Window/prompt
Doing something like that is already simple enough. let promises = things.map(thing =&gt; returnPromise(thing)); let results = await Promise.all(promises);
It's the function definition. myFunc(1, 2, function(str) { myOtherFunc(str, myLastFunc); }); It simply passes the function definition expression (which is the function's reference) as the argument of `myFunc`. It works same as: var fn = function(str) { myOtherFunc(str, myLastFunc); }; myFunc(1, 2, fn); 
It's an anonymous function, but could be done like this: function adapterFunction(str) { myOtherFunc(str, myLastFunc); } myFunc(1, 2, adapterFunction); However this means that myLastFunc is now hard coded as the second argument passed to myOtherFunc. I think the crux for you to understand is that by adding the brackets to a function name cause it to be executed, so: myFunc(1, 2, adapterFunction); // The 3rd argument is a reference to a function myFunc(1, 2, adapterFunction(str)); // The 3rd argument is the result of calling the function, in this case null
Then again, you can do the same (and much much more) easily with webkitgtk on linux :)
&gt;[**JavaScript Callback Functions Explained [9:33]**](http://youtu.be/y1SEuJmS9nw) &gt; [*^Theodore ^Anderson*](https://www.youtube.com/channel/UCFhC3Z6_9zjsxfBADZ-CEEg) ^in ^Science ^&amp; ^Technology &gt;*^1,318 ^views ^since ^Jan ^2016* [^bot ^info](http://www.reddit.com/r/youtubefactsbot/wiki/index)
Its as parallel as it is asynchronous - its all dependent on the target operation. This each function itself isn't either, but it allows for both.
You would have to either set an id or class for the element(s) you want to target, or alternatively use an onMouseOver attribute. &lt;div id="my-div-id" class="my-class"&gt;[your content here]&lt;/div&gt; Then you could do something like this: // We create a new HTML5 audio element, and name it "hoverAudio" var hoverAudio = new Audio('myfile.mp3'); // If it's just one element, we only need to set up an event listener for that specific elemnt var myElement = document.getElementById('my-div-id'); myElement.onMouseOver = function(){ hoverAudio.play(); } myElement.onMouseOut = function(){ hoverAudio.stop(); } // However, if it's for multiple elements, we have to add an event listener to all those elements var myElements = document.getElementsByClassName('my-class'); // We iterate over all the elements in the array, and set up event listeners for(var i = 0; i&lt; myElements.length; i++) { myElements[i].onMouseOver = function(){ hoverAudio.play(); } myElements[i].onMouseOut = function(){ hoverAudio.stop(); } } Notice that in this example, only one audio element is playing the sound. This is good performance wise, but if you need to be able to play multiple sounds at once, you will have to create and delete audio elements dynamically when needed. Shouldn't be too hard to tweak this example to do this. You could also simplify this even more, by using a library, like JQuery or others, instead of the native JS way of targetting elements. 
damn you're smooth....
It's a bad idea to [parse HTML with a regex](https://stackoverflow.com/a/1732454/3671921).
I thought this as well.
Install npm via nvm and tip #7 is not needed.
I've been using cesium at work to visualize ballistic trajectories. Its really cool. 
npm uninstall module-name --save ...?
Why do you need a tutorial? The documentation is quite complete...
A cordova implementation? I love Vue, but Evan's said himself the framework isn't trying to tackle mobile. Doing so with the cordova way is not what mobile developers need/want.
`nvm alias node default` Save yourself a lot of time.
I've thought about doing this (schema-less data as JSON in a blob) and wait until the schema is full defined. Would really be nice to have more opinions about this strategy.
Too true
I use async all the time. I am not sure what this lib does.
love the interface ! nice work :)
This seems very complicated. Wouldn't this work just as well: function asyncSequence(arr, promiseFn) { return arr.reduce((p, v) =&gt; p.then(() =&gt; promiseFn(v)), Promise.resolve()); } [CodePen](http://codepen.io/FullR/pen/dpypqo?editors=0010)
You could write a wrapper function to do that or use arrow functions or bind your functions: function wrap(fn, ...args) { return () =&gt; fn(...args); } function wait(ms) { return new Promise((resolve) =&gt; setTimeout(resolve, ms)); } // with wrapper function wait(500) .then(wrap(wait, 1000)) .then(wrap(wait, 2000)); // with arrow functions wait(500) .then(() =&gt; wait(1000)) .then(() =&gt; wait(2000)); // with Function.prototype.bind wait(500) .then(wait.bind(null, 1000)) .then(wait.bind(null, 2000)); I don't believe there is a way to have `wait` work both ways implicitly because the function has no way of knowing whether or not its return value is being passed to `then`.
Evan didn't say he was tackling mobile, and Alibaba is trying to do a Vue-native thing, but since Vue is small and fast, why not use it in Cordova? For the basic CRUD app, it's fine.
that's way longer, and you have to find out which modules aren't int he package.json.
"With the new architecture, there are even more possibilities to explore - for example, rendering to native interfaces on mobile. Currently, we are exploring a port of Vue.js 2.0 that uses weex as a native rendering backend, a project maintained by engineers at Alibaba Group, the biggest tech enterprise of China. It is also technically feasible to adapt Vue 2.0’s virtual-DOM to run inside ReactNative. We are excited to see how it goes!" https://vuejs.org/2016/04/27/announcing-2.0/ 
I was always interested if a service as such does exist. It would be extremely useful when dabbing into unexplored fields, such as in your case, a new scripting language.
Find a recruiter in your area, maybe Robert Half or just post a resume on Dice.com - tell them your skills and what you are looking for. They will find you a job.
Anyone is allowed to write their own libraries/frameworks and publish them. Many of them never pick up steam or are abandoned. I wouldn't worry too much about keeping up with new frameworks though. Just be aware of them. Learn a couple of popular frameworks and some less popular frameworks if they seem interesting. When I first started learning, I jumped between a bunch of frameworks never really becoming comfortable with one. This resulted in me constantly trying to figure out how my problems fit into new frameworks (which can be a major headache). In the end, frameworks are just tools; you won't ever find the perfect fit for your application, so just pick one that's good enough and start building.
[Relevant xkcd](https://xkcd.com/927/)
 // clever hack from stack overflow: a function with a 'then' method const wait = function(t){ var w = () =&gt; new Promise(resolve =&gt; setTimeout((resolve,t)) w.then = (...args) =&gt; w().then(...args) return w }
many times developers get angry about APIs so in javascript each time it happens the developer say: "I can do it better". As a result of the simplicity of javaScript language and all its beauty he just do it. you can find more info about Dojo frameworks here: http://www.discoversdk.com/products/dojo-toolkit#/product-analysis 
women are not objects, stop using them as props in your examples.
Lol. Those are just images dude.
Why?
Beware cross platform issues with that. fsevents is a popular package that is only needed on macs and if you shrinkwrap it then run npm install on a linux machine (like say, your CI server or production if you use npm in production) then it will try to install fsevents and then fail.
Because `import` and `export` have been reserved words for a long time.
In my experience it is not automatic. When I start a new session I do need to run `nvm use &lt;version&gt;` without this directive setup. After this step, I never have to run that directive.
I love your app clones in react native. Thanks for doing them! 👍
Anytime homie! Hit me up if you need help with whatever
https://caolan.github.io/async/docs.html
It would work if you have a static array of promises/calls you want to make up front. The point of my code is to create and return a proxy function which can be used in place of the original function at any rate you like, and the proxy will ensure that it gets queued and only called one at a time.
you can also achieve this by from Module1 import callNameFunc And when I typed `from Module1`, the editor should be able to give me a reasonable suggestion about what I want to import
You're missing out. You can set an index based on keys in the JSON datatype.
I don't see any problem with how you're doing things. I do the same thing except it's `import "babel-polyfill"`. Why would you want to use a separate script tag? Isn't that a step backwards? Is there some problem being created by requiring the polyfills at the start of your app?
He's a Master Ninja Guru
1. "Expert ... Guru" ... really? 2. The video is 4.5 years old. Since you didn't provide any additional commentary, I can't tell if your post is intentionally trying to troll, or if it's a genuine attempt at sharing relevant content that failed miserably. Although not explicitly called out in our guidelines, posting "troll" material is frowned upon. I'm going to give you the benefit of the doubt, but please, use a little more consideration (and/or research) before posting such content again.
How does something like this get upvoted? Practically no original content. You're better off reading the official guide, or even better yet not using Angular 2
I think I understand where you're coming from. I use my entry module to do any bootstrapping for my application then just require my app. That way there's a clear separation between setup and application code. For example, here's the `entry.js` for one of my apps: import "babel-polyfill"; import {isCordova} from "util/detect-platform"; require("./index.html"); // Forces webpack to include our html file require("../images/favicon.ico"); function startApp() { require("./app"); } if(isCordova()) { document.addEventListener("deviceready", startApp, false); } else { window.onload = startApp; }
I figured it was made to mimic the ordering of "var foo = require('foo-lib');"
npm prune removes the extraneous packages it doesn't just list them
Try [pnpm](http://ricostacruz.com/pnpm). Super fast.
It might be a good idea to tell which timezone you're in. There might be plenty of people willing to help, but not so many willing to stay up late for a skype class. In the meantime I would recommend watching any javascript related talks on Youtube by Douglas Crockford. He's a guy that truly understands the language. Another thing to know is that Mozilla Developer Network (MDN) is your best friend. It's among the best, if not THE best API documentation I've seen. There's also Webplatform, which was trying to do the same thing MDN does but for all web APIs, but to me it looks like they've stopped. Can be useful checking with them if MDN doesn't provide enough information. Good luck with learning JavaScript! Edit: Oh yeah, also watch funfunfunction
What's wrong with `let promises = things.map(returnPromise)` ?
Whatever you pick, do not pick Hackerrank! The site has a lot of bugs and confusing UI. Hacker rank can only help you find whichever candidate is most familiar with Hackerrank, or has practiced hackerrank the most. Codewars is good unlike hacker rank you will know if a candidate got the answer wrong because they couldn't solve it, and not because of unfamiliarity with the site (knowing Hackerrank in itself is a skill). Also Codility is pretty good, unlike hacker rank you can't practice question types over and over again to learn "How to Win", and answers are based on correctness(or the number of tests passed). I mean you know Hackerrank is silly when problems like "Dynamic Arrays" have Javascript and Ruby as a possible language. &gt;Implement a dynamic Array able to store these Primitive Data Types: Boolean, Int, Long, float, float, char, string. * Selects Ruby DynamicArray = [] 
I have an IDE shortcut that generates something like this `import {$2} from "$1"` (it allows to type in $1 and then jump to $2). It's only good for certain scenarios of named exports, but it works for me.
No. import { a, b, // c, d } from 'abcd' No way to autocomplete this, in fact a lot of the times you get a linting error until you type the module name... which is at the end of the line. Which module is it? I don't know. Which things can I import? I don't know, I need to know the module name. &gt; Vim doesn't have any issues auto-completing paths and modules for import statements with the current import syntax. So uh, how exactly does vim do this? It sees into the future and can tell you what module you're importing? &gt; I don't even care how the syntax goes, but they reason you gave seems really silly IMO. It may seem silly to you but lack of forward thinking is the bane of javascript's existence. I mean we are just now getting iterators that are all unbounded. I can't tell what the size of an iterator is even when it comes from something with a definite size like a string. A simple inclusion of a length field (with a default of -1 for unbounded types) would have been great, but apparently that wasn't thought of. It's stuff like this littered around the entire language. No static typing from the get go, the v8 team even tried to implement optional types but they failed miserably because of having to maintain two codebases. Classes which are just prototypes with makeup that took us 20 years to get. The entire concept of even having truthy and falsy, etc.
&gt; Why would this have any impact on an IDE being able to do better auto-completion? Really, just think about how the IDE would work. If you haven't typed the source yet, how can it possibly know what source to look in to find a possible entity to suggest to you? On the other hand, if you type `from &lt;source&gt; import &lt;thing&gt;`, then the IDE can better guess what `&lt;thing&gt;` should be, since you've already narrowed the scope for it, and it can look at what's being exported by `&lt;source&gt;`. &gt; And why would you think it would be right to design a language feature in anticipation of IDE support? Because all things being equal, why not? If there's literally zero technical difference between `import &lt;thing&gt; from &lt;source&gt;` and `from &lt;source&gt; import &lt;thing&gt;`, then I would say better IDE support is more important than any other arbitrary "aesthetic" reason that may have been chosen. There could very well be a good technical reason for why it was done that way, but if not, then it was a silly decision given the benefits of the alternative.
Honestly this kind of code makes me cringe in the JS world. Why would someone want to mix this code with imperative style JS code. If you are going to do this go ahead and use https://github.com/ocsigen/js_of_ocaml and just change languages at that point. I'd prefer a more functional approach than a pattern matching one with lodash...something like what @atubofsoup posted with the range function e.g, ```_.range( 50 ).map( createUser )``` As an aside, I personally like CLJS and lisp + immutable datastructures which is da bomb diggity :P ``` (map create-user (range how-many-times)) ``` 
&gt;Personally, even learning and using just one of these tricks (npm prune, which is #4) saved me from getting rid of unused modules manually by deleting node_modules and re-installing everything with npm install. As you can probably imagine, that was insanely stressful.
"A lot of functional libraries are imperative under the hood because its usually better on performance." So I'm confused again about imperative vs. declarative. I had settled on an understanding that declarative is an abstraction on top of imperative functions, and no matter what, at some level it's imperative. Ie. somewhere, there's imperative code that implements foo.doMyBar What's an example of a functional library that isn't imperative under the hood?
Shift+Enter
[My script does not show up in the sources list in debugger](http://imgur.com/a/qQoJB). Same problem for Chrome. This post is 6 years old and the posted answer is obsolete. AFAIK firebug is nothing more than a theme nowadays. I'll give firebug a shot, but I don't have high hopes of success. 
Please use /r/learnjavascript for these beginner questions
Uh, how so? Because you type the module name first? Not to be a dick, but do you need autocomplete that much? I usually find that if I need to add an import statement, I know both the symbol I need to import and the package it's coming from beforehand.
Frankly, almost everything about this sounds like a bad idea. Why are you "removing things to make the component smaller? Why are you doing it by stringifying the component? Why are you "setting state in chunks? There _may_ be something about the actual use case that makes all this necessary, but at a first glance, none of this seems like it should be necessary.
This was one of the reasons React was invented. DOM observation has proven to be slower than tracking and diffing changes to your own in-memory tree (which React handles for you).
Vue has better performance than most, why not use it with Cordova? There are countless hybrid apps made with Angular 1 (or even Ionic) which is way more resource hungry than Vue.
[Node School](http://nodeschool.io) [Async You](https://github.com/balkan/async-you#async-you)
Is excessive use of generators a bad idea? I saw that they were on the list of things that V8 is not able to optimize. "Yield" in https://github.com/vhf/v8-bailout-reasons/blob/master/README.md
Pardon my ignorance but what sort of problem did this cause?
I feel that pain of scale in a few OSS projects I work on, can't even imagine how it would be with npm. Insane at least.
I like scala's method. `import some.library.{ all as everything, the, things }` or just `import some.library._`
'strUser = "A"' needs to be 'strUser == "A"' Also why repeat so much. Make a function to write a hidden variables HTML if you want to send things that way.
What about SpiderMonkey or Chakra? You can use a transpiler to convert generators into non-generator functions. And if you're already using a transpiler, you can skip the generators and write async /await functions, which is even better.
work backwards maybe, start by dividing by a number, what number? It must be between 0-100 
But there must be a way to retrieve which number is being generated by the function each time it is called in the loop. I can't seem to figure out how. 
I know how to get the number through math, but what I mean is how can I get the number in the code and display each new number in the console, the same way I am printing out the result.
You mean something like num = nums[i]; rand = makeRandomNum(100); console.log(num, rand, num*rand); ?
isn't it ridiculous that we constantly need to do shit like that?
I dunno, at least it is better then pypi/pip.
Thanks for the reply
You totally can! I'm on my phone so you'll have to excuse the brevity, but here is how it might be setup: server: app.post('/account/update', (req, res) =&gt; { let changes = res.body // Do the updating with what you received }) That looks really simple, but it is exactly how I'd do it. The object you post to this route contains *only* changes made. Not the whole deal. You just get to parse the keys and act accordingly! I'll reply a bit later once I've gotten to my pc and give you a real-world example.
¯\\\_(ツ)\_/¯
I just pushed update, now guest users will be able to add new benchmarks
the problem is that a lot of projects have listed this trash package as dependency. Those projects will break if this package is not available. the fact that *the pakage is irrelevant* is irrelvant
My socks?
then you shouldn’t have commented only based on the header. see /u/esotericizm’s reply for the short explanation
I would take the advice a few gave you and programmatically go through the class and methods and prune accordingly. I think that'll give you a clearer picture of what you can regex out of it, if possible
I'm learning react native just now actually, what resources did you use? 
&gt; this apparently completely useless package in our build, used exactly one time, for readFileSync() -- which Node's built in fs does just fine. That's exactly the point. The **fs** NPM package only serves as a **placeholder** for people who think they have to install this module through NPM, while this is a built-in module. As far as I know, that means that you **can't** use this NPM module. It does not contain any code. So when you state that he used `readFileSync()`, this is wrong, because he used the built-in module. When you use `require('fs')` it will use the built-in module, regardless of you installed the fs NPM module or not.
There is already a large (+1500 online user at any time) javascript community in Freenode thats been active for 10+ years.
Check out https://polyfill.io/
Erm...I think I might be one of those people - thanks! 
My first advice is to not do this, and I would instead question your premise. Your app is likely slow because of other reasons and doing this will not help - eval is far more expensive than react's diffing. Firstly, never use eval. No matter how much you think you need to use eval. You don't. Especially when you are writing react code which is transpiled, it will lead to very strange behavior. Transpiling changes many of the variable names and doing this will have very unusual consequences. Anything that would require eval is better written as a babel plugin, which generates your intended code. (Note you definitely don't need to do this). Especially, don't regex replace code in runtime. It will make it nearly impossible to debug. The next person that comes along will have to rewrite the entire thing from scratch. If your component really is slow because of a large object in the state. To avoid having react diff your object itself. You can call this.setState({ yourObject: obj }); as normal, and then implement a function named shouldComponentUpdate() on your component which returns true or false to tell react whether it has to update the component or not. https://facebook.github.io/react/docs/component-specs.html#updating-shouldcomponentupdate Another alternative would be to attach the object to the component directly rather than in the state. And just increment a version number, whenever you change it. this.yourObject = obj; this.setState({ someVersionNumber: this.state.someVersionNumber + 1 }); 
I definitely agree that we're exploiting people on the other side of the world and that that's not a good thing - I just never linked that to paradigm shifts in Javascript :P I'll be on the lookout for what you come up with, good luck with that!
I think this is because JavaScript, contrary to other programming languages, doesn't really have a STDLib of sorts. So if a new developer comes and sees that he must `npm install` everything, I can see the reasoning behind doing `npm install --save fs`
In order to compare the asynchronous behavior has created a sample code , including the promise, yield and observable. https://github.com/nigayo/javascript-async
It annoys me that it's a WARN instead of an INFO or something, it's a totally unnecessary message. One of these days they might do something about it: https://github.com/npm/npm/issues/11632
Syntax Error: Unexpected then
Indeed, but I don't think that would be possibe right now. Also, if a core npm library in the future has the same name as an existing package, how do you solve this ? I don't think that going ES6-route with reserved names is possible, as NPM is starting to be used a lot for non-node projects already (think react &amp; the bunch)
Hasn't Java had this for 20 years with *? I don't know Scala's syntax so not sure if it's doing something different.
Yeah, I thought about that and I guess I really don't know what the hell it was doing in package.json at all. Except breaking stuff
It's usually bad practice because `map` pass extra parameters that might not be compatible with most functions you'd like to use. For example, if your returnPromise function takes an optional `options` object, it won't work.
I was wondering how it would override the built-in from Node...
Use https://github.com/substack/webworkify
https://developers.google.com/google-apps/calendar/quickstart/nodejs there is an actual api for google calendar, you could use this, these docs are horrible though.
Well reddit, if we're gonna change the language my vote is for "using"..."as", not "import"..."from": using someLib.someClass as myAlias;
Yeah, because voice chat would be relevant for coding related content.
That's really stupid. If that was the intention, how hard would be for NPM to reply with a user friendly message, something like: "The package you've requested is already included in your default Node.js runtime"
Read it synchronously instead, it's easier 
That's what I meant with redundant. I just wanted to have some small arrow function there to make it look a bit more like real-world code.
This is my code, which opens the file in a new tab. var myBtn = document.getElementById('save-btn'); myBtn.addEventListener("click", function() { var blob = new Blob(["HelloWorld"], {type: "text/plain;charset=utf-8"}); saveAs(blob, "test.dxf"); });
It used to be very difficult with native code. It is very limited in standard features (compared to npm). The requirements format is very limited, it lacks the expressiveness of a `package.json` and you'll need a bunch of other tools for things like shrinkwrapping, keeping track of core dependencies vs sub-dependencies, and production vs dev dependencies (which leads to fragmentation/threshold) and a lot of smaller things. And less important but still part of the experience: just like everything in python it feels.. oldish and sort of utilitarian? Like pypi compared to npm.org. I use both npm and pip daily or at least weekly for years now and it is just not the same. Also npm seems to evolve a lot faster then pip (maybe because there is a company behind it).
Thanks for the answer. This trial function is a function inside a library. So, I want to somehow use the output of the async function and return it from the library's function So, `libraryName.trial()` should be able to give me the `x1` with the value of `x2`, which is the value returned from the callback of the async function.
Thank you. Opening an issue is a good idea, did so! Will also look into download.js // EDIT download.js also acts the same
The best/only thing you can do is continue returning the promise to the caller. If anyone wants the value inside the promise they will also have to call `.then()` on that promise. You will never be able to synchronously access/return the resolved value of a promise.
I don't know what should I write insted of `text/plain` to try the generic binary format. What is it?
I don't know why you are getting downvoted, this is more of a google the answer question, or codeacademy documentation question. It's not a javascript question at all.
To expand on this answer: // Convert your function to return the promise chain. function trial() { return new Promise(resolve =&gt; { // I don't know how you got the x2 value, but assuming you have it... resolve(x2); }); } // now someone using your code could do trial().then(x2 =&gt; { console.log(`the x2 value is ${x2}`); }); 
 octet/stream
Didn't work. Now the new tab shows no content // EDIT Using `application/octet-stream` worked well on Safari. However, it does not returns the defined file name and just tries to save it with the name of **Unknown** without the extension. Also realised that `text/plain` works just fine on chrome and saves the file with the defined name and extension.
One level of qualification would solve a lot of NPM issues, like the name-squatting and the high value of popular packages. Nobody would accidentally install it if this module was `boobsbr/fs`. NPM does now have scoped names, but it's weakened by how it's optional. I've never encountered one in the wild. This is something http://package.elm-lang.org/ got right.
Polyfill.io is great for patching older browsers, but it's a little behind the curve when it comes to patching modern JS feature support.
I see... What I was expecting is to find a way to return the value of the promise once it is available. 
There is. Look into `yield`/`async`.
this is an essential read for any open source dev. 
Because it wasn't posted yet in /r/javascript.
This is all the context I could find: https://twitter.com/nexxylove/status/771503661956501504 I'm *really* not a fan of Crockford, and I actually want to see him less at conferences, but this is a bad move uninviting him. In the name of inclusivity, they excluded him because he thinks differently.
What the actual fuck. The PC feminazies are infiltrating everywhere.... This is JUST like the time the feminazi linux usb subsystem maintainer got her panties in a twist because the linux community is too direct for her sensitive emotions. 
How is this better/different than [Howler](https://github.com/goldfire/howler.js)?
&gt; “the talks as the day went on just got stupider and stupider.” He said. &gt; &gt; “mmm.” I replied. I found myself angry, my teeth clenched. Why on earth would he feel the need to say that, and now? &gt; I’ve never dealt with Crockford in a way that I felt pleasant afterward. He is rude, unrepentant, and completely (one could argue willingly) oblivious to the meaning of his statements. Is this really what got him banned? Calling some of the talks at a conference "stupid"?
&gt; The latest was ForwardJS: besides his keynote in which he slut-shames the audience Makes that statement, with no actual example or source... One thing I've found regarding people who talk about "diversity and safety" is that they're ***hyper***sensitive to words/statements that seem to violate it. Thus I cannot take an interpretation from some random person at face value without seeing first hand what they are talking about. 9/10 times it turns out it's really *their* problem, and they just need to grow a thicker skin. I'm happy to agree with whoever the hell Mx Kas Perch is if I can see what they're complaining about first hand, but until then, my default position remains they are too thin skinned, and it's a shame they've taken *their* problem, and made it someone else's. Edit, yep, knew it: http://atom-morgan.github.io/in-defense-of-douglas-crockford
YUI team?
Being a grouchy old coot isn't harassment. Is he chasing people down and prodding them when they ask him to go away? No, it sounds like they just don't like the way he speaks. And rather than speak to him about it, they'd rather avoid him and hope the community shuts then out.
&gt;To do this, there has to be a while loop inside the origin function that listens to any changes to the global variable, so that if knows when there is data that can be processed. I like the "there has to be", like it's something that ever worked. You're doing it completely wrong. You should not "side-step" callbacks, you *need* to learn how to use them. If there's a piece of asynchronous code that needs to happen, you need to learn how to connect the rest of your code to it. I know [nodeschool](http://nodeschool.io/) has some interactive lessons about asynchronous code, not sure if trying node is an overkill for you at this point, but maybe it can help.
&gt;As best I can tell it's a couple of people on Twitter labelling him "unsafe" because he had the temerity to call things he disagrees with "stupid". Oof. I hope these people never run into Linus Torvalds. 
Yes I want to always return a promise. The code that you posted works with ES6 but what can I do when I am using third party libraries like reqwest or $http from Angular.js? 
because anyone can do anything in npm for better or for worse
I love promises, but it's too early for this guy, he needs round wheels on his car before putting in a fuel-injector.
I don't know if the instance of him saying "stupid" you are talking about is the same as the one I'm thinking about, but in one of the other comments here the context was given for why he was referring to the other speeches getting stupider, and it was because it was in reference to booze that had been getting served for awhile.