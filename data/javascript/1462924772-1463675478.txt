Or you could use the `Number` function. `Number('10foo')` will return `NaN`. I honestly can't think of any situation where I'd use `parseFloat` over `Number`.
I've never used tampermonkey, but I'm guessing the document idle event and react are probably not connected in any way. It's probably when the browser is done loading and processing the html page (which is also when react would start the render process). So you are probably right that the email input hasn't been rendered yet. Might be a bit hacky but you could try setting a global variable and then loading that in your react component. Is there no way to access tampermonkey from the react component?
I understand what type coercion is but I'm arguing that the benefits do not outweigh the ambiguity caused by it. Also like you said the above example wouldn't be used in real code and I think that an operation like that should cause an error, not try to coerce the types to try to make something meaningful out of it. But in the end neither you or I are going to change our opinions about it. 
&gt;I understand what type coercion is but I'm arguing that the benefits do not outweigh the ambiguity caused by it. There's no ambiguity in javascript's type coercion. It works exactly as it should, and it follows very strict rules. It does not give inconsistent results given consistent input. It's also pretty easy to reason about if you know how it works. Maybe dynamic typed languages just aren't for you? If that's the case, then maybe don't come to /r/javascript to show us how ignorant you are? 
I didn't really look into the code, but if this is any better than `nodemon` in speed/size see if you can merge with `nodemon`, that way people who have `nodemon` can just update `nodemon` and boom their using your script
No but you could do if (isFinite(parseFloat(x)) and that will basically tell you if you have a number or not, really easily. you cant do it if parseFloat needs to be wrapped in try/catch There are some functions you know can throw Exceptions in JS when parsing, such as JSON.parse. I always wrap my JSON.parse calls in try/catch blocks just in case the input is bad. But this isn't great for functional code, and especially doing something as trivial as parsing a string into a number. You could always have a function like isFiniteOrZero to convert your NaN results, or handle NaN however you wish....
Add a listener to DOMSubtreeModified and check if a element with id "email" exist before changing that value
Just found http://stackoverflow.com/questions/3894048/what-is-the-best-way-to-initialize-a-javascript-date-to-midnight new Date().setHours(0,0,0,0) By far the minimalist solution. Playing with the timezone offset kept rolling the buckets at 8PM. Should have paid a little closer attention to your post.
ParseFloat is really used mostly in the scenerio where you want to convert string values which contain units (e.g. px, em, %, etc etc) into its number representation quite easily. I don't use ParseFloat on things other than really these situations. If I am not converting something with units to a number and instead just want to parse a number, i use Number. Both will return "NaN" when the input cannot be converted to a number. I don't see a problem with this handling in my code. Sometimes I don't care if it is NaN, and I don't want to throw exceptions at all. For instance, let's say we are accepting user input on the fly and trying to convert each character as they type into a number and perform some addition. If they enter an invalid character, it isn't "unexpected input" because they could really be inputting anything into the textbox and we just want to parse out the number. Okay, great. But say now instead of writing some code, I instead had to write an "expression" and later had to parse the expression. Say in there I wanted to explicitly convert something to a number in my expression. I use lodash _.parseInt functionality in my expression, and it can be used as-is. No special handling is required. If you want a function that will throw an error with unexpected input by all means you can make one. Part of knowing JS is knowing the functions and how they behave. You can write your own damn functions. They choose for this one not to throw exceptions, that was a good choice for many of us functional programmer types. JS is a better functional language than a procedural one or an OOP one, so it makes sense functional style is preferred in its design. 
Comparing a list of instructions or a mathematical equation to something actually beautiful like a sunset, or your girlfriend's face is really anthropomorphizing it to the point of absurdity. When you call programming code "beautiful" it diminishes things that are actually beautiful. Code can be clever, well written, robust, and well organized, but beautiful is a big stretch. Elegant might even be a stretch when describing a list of instructions, and that is all code really is. At the end of the day it's a tool, not something any reasonable person would frame and hang on a wall or have strong feelings for. If you're fetishizing code to that degree then it's probably not healthy. 
&gt; In both examples, this is set to the global/root object because it is inside a function rather than a method You actually don't know what `this` is set to until the function is called. `someFunction` might be attached and called on an object later, it might be bound to something, called explicitly on something, etc. Yeah, it reads *as if* the intent was a bare call, but this is JavaScript so anything could happen :)
 function Color( red, green, blue ) { this.red = red; this.green = green; this.blue = blue; } Color.prototype.getRgb = function() { return "rgb(" + this.red + ',' + this.green + ',' + this.blue + ')'; }; // I'm not sure, but there's probably a way to convert from RGB to HSL/HSV? // otherwise just save it all in the object Color.prototype.getHsl = function() { }; Color.prototype.getHsv = function() { }; // now you create color objects with the colors you want var colors = []; colors.push( new Color( 255, 0, 0 ) ); // example of loop for (var a = 0 ; a &lt; colors.length ; a++) { var color = colors[ a ]; htmlElement.style.backgroundColor = color.getRgb(); }
I'd say unit tests can be forgiven if organized that way. Integration and/or functional tests are a big No No 
My day job is for .NET web development, so I have experience with C# in a few settings (private, small company, enterprise), as well as F# and a few other .NET languages here and there. I also have experience with languages that have a much more powerful typing model than typescript, such as haskell and scala. Haskell and F# in particular are much better for strongly-typing, since you usually don't even *need* to annotate your code (anywhere) to still benefit from types. I don't desire types in scripting languages such as python, ruby, javascript. I can understand why some would, but the largest benefit I've seen from them is realized in larger team settings. However, typescript wasn't always around, and people somehow managed to write and maintain large javascript applications without it. I don't appreciate the behavior of people not understanding javascript, trying to force idioms from other languages onto it, and saying that it's only "finally" usable now that some sugar has been added to placate their sweet tooth. Classes were already expressible --- usually in *less* lines than ES6 ones. Modules were already expressible. Anders was incorrect to speak as he did, and alienates the javascript community in doing so.
I didn't know Redux was a derivative of Elm. I thought it's similar but grew organically out of the complexity of Flux? 
Make it into a repo, that I can download and download on npm with some easy to read, well explained docs, then you got me (bcz I don't even use nodemon :) )
It's at least a little awkward on a desktop device as well. You would usually expect a dropdown on such to appear right under the select you click, but instead this appears like a modal, requiring your mouse to move all of the way to select, then all of the way back. Definitely feels like fashion over form to me, unfortunately. 
Even if you wait and tamper with the value later, depending on how you set up your react project, the input field is likely to be reset to the original value if you do anything that causes a rerender (if the field is 'managed').
I think the redux design was "borrowed" from "re-frame" a cljs framework. The concepts almost map identically and some of the docs in redux match the re-frame docs which came out first :P but who knows.
 function permute(arr, memo) { var cur, memo = memo || []; ಠ_ಠ
Ok, you just ran into a pretty weird browser quirk, lol. Add the attribute `type="button"` to the Add button.
Basically it acts like a submit button and tries to submit the form if you don't add `type="button"`
You might be interested in [InstaClick](http://instantclick.io/).
This line confused me at first too but it looks like it is first declaring cur as a variable, then assigning memo to itself if memo is given as a parameter, or a blank array if it is not assigned an original value, clever really
Yes, it passes the spliced copy into the recursion, but it also repairs itself before the iteration with "arr.splice(I, 0, cur[0])". Without that line OP would be correct in his assumption that splicing the array would screw up future iterations.
No that much is fine, and I use that idiom myself all the time. The problem is that it doesn't (appear to) do anything to declare it though. I think maybe they were trying to avoid assigning to function arguments, but it doesn't have that effect, at least in Node: (function (x) { var x = x; x = 'argument assigned!'; return arguments[0]; })('argument unassigned') --&gt; 'argument assigned!' Here we see that even with the `var x = x`, the actual argument got overwritten. So the three problems here are: 1. There's no real reason not to just reassign function arguments ([unless you also mention `arguments`](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#31-reassigning-a-defined-parameter-while-also-mentioning-arguments-in-the-body-in-sloppy-mode-only-typical-example)). 2. Even if you did need to avoid reassigning arguments, this doesn't accomplish that. 3. Even if it did, it's a poor choice for readability. Don't give me two variables in the same exact scope that have the same name. That's just crazy.
If you approach the button, it appends the green box. Move the mouse out and approach again. You get another append. Rinse and repeat.
Instead of callbacks, you use "observables" which are sort of like streams of events. Except, these streams can be `map`ed, `filtered`ed, `merge`d, and more, much like arrays. If you wire up all of your application with observables, it's functional and reactive.
&gt; So JavaScript still doesn't support modules. *cough^(npm)cough*
Just add a event.preventDefault(); To the button or to the submit event handler. One advantage of using a form with submit is that you don't need another event listener for the enter key. 
so frp means "add and remove pieces of code(read: async functions) as if they are variables and executing the result in a typical async js environment"? this kinda sounds like meta programming up to eleven. 
New Form of ddos :) 
I did Dev Bootcamp two years ago. One of, if not the biggest mistakes I've ever made.
Thanks a lot!
Or ConditionerJS, see last two examples, http://conditionerjs.com/examples/conditions/
Yeah space junk indeed is a real problem. Fortunately there is research and testing going on how to solve this problem. Eg. Aalto University's Aalto-1 satellite is testing a plasma break http://www.kirj.ee/public/proceedings_pdf/2014/issue_2S/Proc-2014-2S-258-266.pdf which is essentially a accelerated deorbiting device. If some technology like that could be standardised and be and obligatory part of CubeSats it would mitigate the problem. Nano satellites in LEO-orbits will also naturally burn in atmosphere after some years depending on the orbit. 
Hi, this is Teijo from the team. The goal of the apps is to allow easy composability of the capabilities of the satellite. Priority is to help keep the apps simple, and let the "platform", i.e. rest of the system, worry about the stability. In a sense it's up to the owner of the app to determine how much effort to put into assuring the application is valid and functions within the provided constraints. If it doesn't work, you can just upload a new version.
What about componentDidMount property (https://facebook.github.io/react/docs/component-specs#mounting-componentdidmount) in your React Form Component? That property runs code inside when component completly loaded and rendered. May be you can insert your code there? Or trigger some event in componentDidMount, and handle it in your code.
The third one is the most important imho, unless you're working on a home project for yourself. But anyway, getting used to write the code in a proper way is extremely beneficial.
You're right, it was just for the inflight entertainment (IFE) system. Previously the entertainment systems were developed through a very thorough development process where the hardware supplier evaluated the changes. That made the development process really slow. Having the certified node.js server available in the plane's entertainment system makes it easy to deploy new changes because they don't have to go through the verification process and that lowers the barrier for changing the IFE systems. Here's a more detailed write up about that: https://reaktor.com/blog/aircraft-customer-experience-on-a-new-level/
for private repos, bitbucket works just fine
Yes, exactly. That's how it used to be. But cubesats change that. Launching a cubesat is relatively cheap (100k vs 10-100M). If you can get the developments costs down, the barrier is a lot lower. And that's what we're trying to prove.
I don't have a clue, sorry. I have no idea how much formal verification is used with space related software development and I don't have a clue on how applicable formal verification is with javascript / node.js. Juho wrote about the technical details related to the how they plan to ensure that the satellite stays operational in space: https://www.reddit.com/r/javascript/comments/4iogzk/nodejs_on_a_satellite_means_anyone_can_be_a_space/d307tf3
Anybody else prefers Gitlab over Github and Bitbucket?
Parse is now open source and you can setup your own parse server. https://github.com/ParsePlatform
Yes I know that. But don't want to use parse.
/r/typescript is over there
Good luck, you will need it.
scrolling on iOS chrome scrolls the background behind the modal
Are you sure that isn't just a default setting you can change? https://gitlab.com/gitlab-org/gitlab-ce/issues/1129
You also don't have to worry about how many users you give access to the repo, bitbucket has a max of 5 for a free account 
Yup. It's great for private projects. I still use github for public stuff though.
Good luck with your FactoryMetaFactoryControllerDecorator!
Nothing about this library is "user input prediction". Proximity calculation is not equal to probability based prediction based on previous user input (which is what prediction would be).
This is a great deal if you like paying money and hate gitlab for not looking like a bootstrap 2 website.
Hey, thanks for your points, they are all valid! Most of these learning came from the past years of working on big Node.js projects. These points are of course not silver bullets, but for beginners they can help a lot.
I was really confused by this but try and remove the access token bit and just get a client ID
Been using Bitbucket for private free. Gitlab looks amazing. Learned something today!
I'm using Beanstalk which handles both svn and git. I pay for it, but basically all repositories are private. When I want to generate a public one I put it on GitHub.
Here's an example from RxJs github page: const source = getAsyncStockData(); source .filter(quote =&gt; quote.price &gt; 30) .map(quote =&gt; quote.price) .forEach(price =&gt; console.log(`Prices higher than $30: ${price}`); Here, source returns a list of some kind. We then do what's called projection to change one kind of list to another kind - in this case, a list of objects to a list of numbers &gt; 30. This kind of data projection is useful for describing *what* you want instead of *how*, it's declarative. "give me prices over 30", instead of "if the price is over 30, append to array x". FRP expands this idea to events, instead of just arrays and lists. const source = getAsyncStockData(); const subscription = source .filter(quote =&gt; quote.price &gt; 30) .map(quote =&gt; quote.price) .subscribe( price =&gt; console.log(`Prices higher than $30: ${price}`), err =&gt; console.log(`Something went wrong: ${err.message}`); ); Now, instead of returning a list, it returns what's called an *Observable stream*. Unlike the list example, this does not evaluate immediately. Instead, it sets up a code path for all new events to be followed through. Ultimately the data can come from anywhere, such as a websocket. However, instead of just being one request which we can await on and then evaluate synchronously, we can receive any number of events. Just like with the list, we describe, declaratively, what we want from it. When we are done receiving events, we can remove our subscription with `subscription.dispose()`. Ultimately, this idea doesn't appear to be very intuitive to a lot of people, hence the decision by elm to stop using it. I don't blame them. 
I plop this out whenever someone asks about framework choice. --- Javascript frameworks tend to be in one of three camps: 1. Kitchen Sink * These are opinionated and have an idea about how you should do things from A-Z. Their opinions tend to cover how you should organize your app, how you should write your files, etc. * [Meteor](https://www.meteor.com/) * [Angular](https://angularjs.org/) * [Ember](http://emberjs.com/) * [DoneJs](https://donejs.com/) * [Aurelia](http://aurelia.io/) 2. Batteries included * These have less opinions about how you should structure things, and tend to be much smaller overall. You'll make more architecture decisions, but there will still be some ideas provided. You'll typically still have things like a router here. * [Mithril](http://mithril.js.org/) * [Riot](http://riotjs.com/) * [Knockback](http://kmalakoff.github.io/knockback/) * [CanJs](https://canjs.com/) 3. BYOA (bring your own architecture) * These do one thing, and only one thing. Typically, that's the V part of MVC. The rest is up to you, from routing, to validation, etc. * [React](https://facebook.github.io/react/) * [Vue](http://vuejs.org/) * [Rivets](http://rivetsjs.com/) * [Polymer](https://www.polymer-project.org/1.0/) * [Knockout](http://knockoutjs.com/) * [Backbone](http://backbonejs.org/) None of them are "best", and yes, there really are this many of them (this is a curated list, too). Powering a list is not really that unique of a requirement, and working on mobiles is more of a styling thing than a JS framework thing. Group 1 is the most opinionated about how you organize and layout your code; group 3 is the least. I suggest picking a few of them, following some tutorials, and see what jives best for you and your team. Then, I would very strongly not recommend doing a whole rewrite, but doing it piecemeal, or only for new code. I would say it's probably not worth still improving your hand-rolled, particularly if your company is looking to hire or otherwise expand.
Was wondering how long it'd be until I started seeing some creative use of tagged templates. Looks like a lot of the architecture is based on redux philosophy. Do you think people who are comfortable with redux wouldn't already be using react, mithril, or other vdoms? I can definitely see some objections pop up to going back to *string* views.
On principle. Github wants me to give them my source code, but they won't give theirs.
This mentions "the new router" but it's far from fully usable if you ask me. Major changes are still happening to it, and it was never officially released either, for use in angular 1. My team has already done all of the refactors mentioned in this article, but the router isn't feasible yet imo.
Hi /u/jasonswett, it looks like you're new to /r/javascript, welcome! Thanks for the submissions, but please make sure you read our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `angularonrails.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [angularonrails.com](/search?q=%28and+site%3A%27angularonrails.com%27+author%3A%27jasonswett%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|7|78%
Our organization was on the Fermium plan at $855 per month. We have 8 members. So our costs look like they will drop from around $10,500 per year to under $2,000.
To be fair $200 for 100 users works out at $2 per user. It's cheap.
If you think code is beautiful, you need to get out of your basement more often.
If all you look at is code all day, then sure you might start to think some code is beautiful because you lack frame of reference. I can assure you there are many things in the world exponentially more beautiful than code, no matter how you define it to yourself.
My apologizes about the formatting of my above post, I have never posted code in a reddit post before. =/
Turn a web app you develop into a desktop app. It bundles node and chrome together to do it. I haven't done much with it but so far it works really well.
Seriously... I just went to their website and I'm sure I could get the idea by reading through the docs, but why isn't there a simple "what is Electron" part of the site? It seems like the entire site operates under the assumption that you already know what Electron is.
It's a subatomic particle with a negative charge. 
Bit confused by this bit: &gt;Any developer that uses this, needs to have the same alias for the same hostname in ~/.ssh/config. Assuming you're 1) not using the default identity, 2) isn't this how any use of ssh would work with a different private key? Presumably if you use ssh for downloading your stuff, you would know how to configure it.
So it's an in-memory ORM that uses ES5 getters and setters? Observables are a stated benefit of this, but you certainly don't need a full ORM just to handle that. Two-way data binding is also probably not going to be that popular with how much redux is gaining traction. However, still neat.
well. . . The front page says: "Build cross platform desktop apps with JavaScript, HTML, and CSS" Then if you scroll down it goes into a little more detail. Even has a video that explains it.
True. I am playing with the concept at the moment. Using the approach that you are suggesting would in effect require to have two webpack config files and run `webpack build --config ...` against all of them. The problem with this approach is: * Duplication of unaffected asset compilation * Handling assets that have hash in them (assets.json is overwritten). One more option is to write a program that run webpack against multiple bundles and then produces a collective assets.json. This is all in concept stage at the moment.
There's really no 'simple' code; you'd have to shift through all your targeted cells, deal with potentially incorrect inputs (e.g. error handling) and then also build a stack that sorts values accordingly. It's always best to stick to a proven library - why reinvent the wheel?
I agree... I've just been stuck on it for a while so I am trying anything at this point. I added class="tablesorter" to the table and I am using. I am using this $("#milestonesTable").tablesorter({ sortList: [[2, 0]] }); to sort the third column ascending but it's not working. I've also tried $("#milestonesTable").tablesorter({ headers: { 2: { sortInitialOrder: 'asc' } } });
You don't necessarily need multiple configuration files or a special command. I have *no idea* if it's documented anywhere, but your webpack config's exports [can be an array](http://stackoverflow.com/questions/29640996/webpack-with-an-array-provided-as-config), which will cause webpack to do multiple builds without any more special configuration. Conceivably, you could also have another build for things which are "shared" and just configure the other two to assume them.
Thank you so much, this is exactly what I was looking for! Just a question though, why is the browser able to understand enlarge(image), is it because the event is inside of a image tag?
Rather than having to reproduce the onclick method in each img you generate, you can just target the group specifically in your script and addlisteners to each one. e.g. var imgElements = document.querySelectorAll('img'); Array.prototype.forEach.call(imgElements, function(element) { element.style.width = element.style.width || '200px'; element.style.height = element.style.height || '200px'; element.addEventListener('click', function() { switch(element.style.width) { case '200px': element.style.width = '400px'; element.style.height = '400px'; break; case '400px': element.style.width = '200px'; element.style.height = '200px'; break; default: element.style.width = element.style.width || '200px'; element.style.height = element.style.height || '200px'; break; } }) });
I used NW.js on a project a year ago. Both Electron and NW.JS have had many updates. Looking at the github stars they are at an equilibrium both having 28k star. Which one should I use and why?
Ehh, thanks for the help, but I'd still be hours away from getting that working. What goes in package.json? How do I invoke the bundler? Why can't webpack resolve src/index.js? etc. I'd be bouncing back and forth between babel, browserify, babelify and webpack docs, none of which take on the responsibility of providing documentation for a complete build system. I gave it another quick try but it just makes me realize how much easier the TypeScript ecosystem is. Not to mention having types, for which I'd be content to work with ES5 if I had to. Being behind Babel's bleeding edge ES20* features by a few months is pretty inconsequential to me.
If you want help provide your full source or at least a working codepen/fiddle example. There's too many variables for me to simply say 'here's what's wrong'. There's a simple example right under the tablesorter docs that shows exactly how to structure your HTML &amp; JS - I'd start there first and make sure you're following the standards accordingly.
and 1. it has native APIs for most desktop things (notifications, dialogs, menus, tray, …) 2. you can call subprocesses and into native libraries and so on.
damn..... I just figured it out. I didn't have the thead tags in my table. /cry
No, but it could probably be enhanced to keep track of accurate predications and only prefetch specific high-traffic areas. What would be cool is if you could define "workflows" in your app that are commonly performed and prefetch things that are part of that workflow.
Well least you got it figured out :). Main thing to do when working with any new library is to always start with a simple example or two from their documentation and then start to build on it further in your own projects/implementations.
Thanks
You're talking about Bitbucket. I don't have much of an issue with their pricing. Github is now $25/5 + $9/1. So if you have a normal team of 20, then you have 50 freelancers that all need access to the project, but maybe don't all work at the same time (but it changes enough that it's just a huge PITA to micromanage the team list), you're looking at `$25 + $9(20-5) + $9(30) = $430/mo`when you could have been paying $25/mo before. I'm not 100% against this, it does allow increased flexibility in that you no longer have to micromanage *repos*, it's easier / more mindless to spin up a repo for a test project, but it could definitely cost more in a number of cases (ours, in particular)
Don't forget that $200 is the unlimited deal from which on you don't have to pay for further people. Also for one I'm sure you can remove users from the organization if they don't work at the company anymore. But even if that's not the case, it may be that the same issue applies to Github too.
You could use ssh with the identity flag ssh -i myPemFile.pem &lt;user&gt;@&lt;hostname&gt; Specifying private keys on a per-command basis. I've seen some developers use this method a lot, especially if not using the ssh command on a regular basis. What I was trying to communicate is that *the team* would need to have the same alias per host, since you'd be sharing the package.json file, so that it can resolve to the same url. But yeah, each dev could point to their private keys in the IdentityFile parameter.
[Here's a big ol' blog comparing 'em](http://tangiblejs.com/posts/nw-js-and-electron-compared-2016-edition)
&gt; Industry-grade programming has traditionally been very complicated and expensive, requiring unique programming languages and skills. Buying an industrial robot is not difficult, but programming it to do something useful without it breaking things can take weeks or months – starting from finding a developer with the right programming skills. With you so far... &gt; This is where the Reaktor Hello World satellite is changing everything. If your industrial machinery, robots or satellites could understand popular languages, such as JavaScript, you would have no trouble finding programmers. You would not need to understand the low-level implementation of a robot or satellite for it to be productive. Hmmm.. &gt; If a satellite was running Node.js, programmers and developers could use all the familiar tools they have utilized before. There would be no need for a special rocket scientist toolkit. This combination is quite literally a programmer’s universal driver’s license. It lets you program cell phone towers or airplane entertainment systems – projects where we have used JavaScript successfully before. Sire, i cannot fathom if you are jesting..
Hey guys! At the company I work for, we've been building Angular 1 apps for quite some time now and I had to think about the future of our front-end stack. Moving from Angular 1 to React would have a lot of consequences, I am taking it really seriously and wrote about the whys. Angular does a lot of things that React don't so I started to gather resources to fill the gaps there: [wizbii/react-redux](https://github.com/wizbii/react-redux). Any feedback appreciated :)
Because there's node, do I have access to all the things I would expect? Like with sudo + python I can do just about anything. Is the same true these days with Node via. electron?
Can I package my existing apps inside of it? Or is this a framework?
of course. you can have sandboxed website containers, but by default, you have access to the whole OS, like every desktop application.
Maybe it's good news for your company, but for companies with more than a few dozen developers [this means a serious price hike](https://www.squrb.com/blog/2016/5/11/githubs-new-pricing-structure-a-perfect-time-to-migrate-to-bitbucket-and-save-a-lot-of-money).
yeah, it’s pretty easy to get started!
First off, I want to thank you for taking the time out to have a dialog, and I hope that you take no offense to any of my strong opinions on this matter. I too have been with TS since about 0.8-0.9ish... And from everything I heard is that it was *not* node friendly at the time. But it's like it was meant for Node now to the point where NPM might end up being where you check-in/get your declaration files. I wouldn't consider myself a Node developer, but I've been using TS and Node together for fun personal projects and its a dream. I couldn't imagine coding without some help from an IDE (I use WebStorm) or some compiler assertions. I'm not writing 5 minute apps, I'm writing complex architectures that benefit from 'interface first' design. Not something you can do with JS alone. Familiar to C# and Java... Hmm.. Yes and no. The types are the familiar part, but modules are not. This is where JS is cool, but TS is even cooler. Simply stated, if you try to explain how to write complex exports using plain old ES5-JS, you will give someone an aneurysm. If you show them how it's do ES6ish or TS, it starts to make sense quickly. Sure, you could just use Babel, or Traceur, or whatever, but TBH, TS is not only simpler to use, but also includes all the type support. :| Exporting a 'class', you gain all the type information that you normally wouldn't get with just JS and that happens even if you don't annotate your code with types! All of these things you are referring to, "flow, clojure, dart, coffeescript, ..." (the LIST is longer than any other language) is because JavaScript SUCKS. It sucks at it's core and instead of writing it, there is an incredibly long list of transpilers and other means of *not writing JavaScript* in order to write JavaScript. There is no other mid to high level language in history that this is more true for than JS. Now that said, JS doesn't suck because it's loosely typed. I used to love the loosely typed nature of it. It sucks because it's evolution has been so slow and instead of fixing the underlying issues the community has had to effectively 'patch' it while creating a level of fragmentation that is painful. :/ Here's where we might agree: JavaScript has never been taken seriously (at least not for the most part). And that is probably due to the fact that creating a useful IDE for a typed language is much easier than a non-typed one. IntelliJ and WebStorm have had superior level JS intellisense for years, but without types, there's a limit to understanding code intention (human or computer). So here we are, JS is finally getting the attention it should, and it IS growing up. ES6 is that first step in the right direction. IMO, TS is far better that JS alone regardless of ES version or how you like to code. Here's where I take a stand and probably frustrate a few people: I've been there. I've been in that space where I felt like JS actually made me a better coder. It made me a better coder because it forced me to think harder about what I was doing. I effectively had to build my own internal compiler in my head to prevent me from making simple mistakes. I had to inherit good coding practices that compilers would normally enforce. So in the end, I AM a better programmer, engineer because of JS. But I never ever looked a JS as a serious language. It was always something needed 'patching' or had to use a third party library, or had to write my own. And no matter how you slice it, that extra effort you put into figuring out *those bugs that simply DO NOT HAPPEN* in a compiled/typed language, is a waste OF YOUR LIFE. Yes, I'm saying GROW UP. It sounds condescending, but seriously, those still stuck with JS and Sublime Text only, are WASTING THEIR LIVES. There are not only better tools available but simply better way to do things today AND it's getting better by the minute. I would be just as happy to see someone coming from ES5 to using ES6 with Babel than I would for someone using ES6 to TS. For me, either are an improvement. But to sit back and think the status quo is okay goes against exactly why JS is even viable! Because someone said, *"this isn't good enough."*
**atom .**?
Thanks for the feedback! :) Yeah Angular 1 is really great at a lot of things, too bad Angular 2 is not that promising :/
&gt;if you try to explain how to write complex exports using plain old ES5-JS, you will give someone an aneurysm. If you show them how it's do ES6ish or TS, In the early days, we didn't use modules at all, but did what typescript did - namespaces. This is just sticking an object on another object. Exporting a complex object in AMD is not that difficult (you literally just `return`), and CommonJS is *very* similar to ES6, so I don't think I agree here. Also, for almost all of typescript's lifetime, the way to manage larger apps was namespaces, not modules. Modules are very recent, and typescript still struggles with them a bit (though it is improving with flags like `syntheticExport`). Namespaces provide a very familiar way to organize applications to C#/Java developers, and was really more of what I was talking about. &gt;All of these things you are referring to, "flow, clojure, dart, coffeescript, ..." (the LIST is longer than any other language) is because JavaScript SUCKS. Javascript is unique because it has an unusual monopoly. Even in areas without such a monopoly, you still find a diversity of languages to fill different roles. I would say that it shows javascript is a lot more powerful than people think if it can serve as a compilation target for languages as varied and wide as haskell, C#, clojure, and C++. Javascript is also *really, really* popular. The more popular it is, the harder it is to please everyone - and you're seeing other extremely popular languages like java start to fragment into other communities, like for scala, groovy, and some others. &gt;And no matter how you slice it, that extra effort you put into figuring out those bugs that simply DO NOT HAPPEN in a compiled/typed language, is a waste OF YOUR LIFE. The problem I have with this argument is you can make it for basically any typing model that isn't as strong as you want. People make this from a position of typed languages against untyped ones. People make this argument for higher-kinded-types against ones that don't. People make this argument for dependent times against languages that only have HKT. People make this argument against languages with a full turing complete type system versus those that don't. It's endless. &gt; Here's where I take a stand and probably frustrate a few people: I've been there. I want to phrase this as politely as possible but nothing is really coming to mind, so please don't be offended when I say that this, pure and simple, projection. Just because you have had this experience does not mean everyone else ("a moral majority") is in equal suffering, and trying to proselytize people aren't indicating they're receptive to it is, at best, extremely annoying, and at worst, hurts the effort that you're attempting to promote. You know the biggest problem with haskell and clojure? The community. Both groups are so incessant that they have found the nirvana of programming and drive it so aggressively to other communities, that both languages end up with a bad reputation - even in circles which are otherwise quite similar. Lispers look at the clojure community and see a borg collective, wanting to assimilate everything. MLers see haskellers and see people too busy talking about very abstract math-y concepts to even do anything useful. They were trying, perhaps earnestly, do what they felt was best for programming as a whole, but ended up just leaving their communities more isolated and with a worse reputation than when they started. I don't want that to happen to typescript, so I will forever push back any attempts to portray javascript as worse than it is. Things could always be better, and there's still a lot of room for improvement in javascript, but we don't need to outright lie and say that javascript couldn't do things like modules and classes before your programming jesus came to save the day. That doesn't help anyone, it alienates the people who care, and creates this fracturing that I don't want to see.
Initialize your message with display:none in the CSS.
You can read the docs on the website, usually a good place to start seeing as they provide a Quick Start section
Thank you very much! I also have the feeling that developing React+Redux apps taught me a lot about how to laid out a component oriented architecture with a one-way data flow. It then became much clearer how useful Angular's `.component` can be. Anyway, I am glad to learn about you guys' perspective and concerns, really interesting.
work uses bitbucket. At least 1 major outage a month since september/october, october being extremely bad. http://status.bitbucket.org/history
I've connected multiple browsers on the same computer with sockets to the same node instance with no problems. Whatever the problem is, it's probably in your code, not something inherent to socket.io.
For most people "docs" = detailed documentation. I won't even click on "docs" until I know the thing I'm looking at does what I want it to do.
Ever want to use node.js, js, css, and html to make a desktop app? That's what Electron (and nw.js) does. Ever use Atom or Visual Studio Code? They use Electron.
It depends on your app if you need to make code changes. If your app is 100% client side, you'll have to write a package.json file (like 10 words over 4 lines), a simple app.js (basically copy-paste it from their site, it sets behavior like opening a window, what to do when closing a window, etc), and then the rest of your code stays the same. If you used nw.js instead of electron, you'd only have to write the package.json. If your app talks to a server, it depends on your app and your implementation. Think of Electron as a web browser and node server that you can bundle with your code to make a self-contained desktop app.
on same computer - ok but from same ip on other device its not connecting, some people have problem with sockets on my site cause it, i set maxconnectionslimit socket.setMaxListeners(0); http.setMaxListeners(0); app.setMaxListeners(0); But some people cant connect to my socket on port 3000
This is awesome great to see this.
Look up how to put an image in your div. Then just assign it a custom id and put that id in the click handler
&gt;the magic link between the arguments object and named arguments does not exist in strict mode: Good to know. What a massive fuck-up it was to put that link in the language.
Without seeing the JS/HTML you used, there's no accurate way to suggest a solution
It's a custom chrome browser with no adress bar and no tabs that displays a predefind page. this page also has access to the whole node js framework, so your site can read/write files via the nodejs api, talk directly to any database via a nodejs database driver or call any endpoint without worrying about the same origin policy. tldr, write linux/windows/mac apps with html and js
This amuses me: &gt; The blazing fast, **batteries-included** ES2015 compiler. Then just below the meme image: &gt; You'll also need to bring your own polyfill (e.g. es6-shim). You have been warned!
Can somebody explain why browser UI data/state has to be polled or observed? Doesn't the data change after some sort of interaction, either between the client and the user or the client and the server. Why not invoke state redraws as a part of the the event/request handler?
I guess the misconception is that Babel is an ES6+ Transpilier, it's just an engine for parsing things with an AST tree and transpiling it to something else. I'm pretty sure you could build plugins for transpiling Dart to ES5 in it. This is why it doesn't come with anything default, it doesn't assume anything, but ultimately if doing this is too much work then you have other problems: npm install --save-dev babel-preset-es2015 And in .babelrc or the JSON dump you stuff in your build pipeline: presets: ["es2015"] 
It's no mystery - it's the bitwise not operator and is found in many languages. The thing to remember about all bitwise operators in JS is that the value they operate on is coerced to an Int32, hence some of the behaviors listed in the blog. The best reason to use it is when doing bitwise operations of course. Lots of people like the ~arr.indexOf(...) trick but personally I think it's too opaque to be a good pattern.
One thing I don't understand about the Javascript community as a whole is why everyone feels like it is either Angular or React, like they're the only two solid choices. I moved on from Angular 1.x about two years ago now, coincidentally over to React+Flux for a bit. I have since moved on from React to Aurelia. Angular and React are not the only two choices. We have Ember, Vue.js and my personal favourite: Aurelia. Honestly, Angular was good for its time, but there wasn't really anything else out there that rivalled it in my opinion. In 2016 developers are spoiled for choice, too much choice some would argue. I tried looking at Angular 2 with an open mind, but they ignored everyone's concerns about learning curve and abstract concepts that were said about Angular 1. In my opinion, Angular 2 shouldn't be on your radar unless you work for a company that still believes Angular 2 is supported by Google (they devote resources, but offer no public/enterprise support). I hope to see one day as Javascript grows more powerful with each yearly specification release that we won't need to use frameworks one day to achieve basic applications.
JSCS and JShint are good
Do NOT use this... it's not big and it's not smart. Unless you are doing bitwise operations, the tilde obscures what you're trying to achieve 100% of the time. Always aim for clarity in the code that you write, there are post processing minifiers for writing obfuscated code with obfuscated logic which is what you end up with by using ~ for any use other than it's intended one. 
Can you elaborate?
Sorry I didn't want to put the website because I didn't want it to feel like a self-promotion.
BitBucket is the gateway drug into the rest of Atlassian's product line. They are almost certainly losing money on BitBucket, and that's part of their plan. Git hosting pretty much is GitHub's entire business, so pricing below cost won't work out for them.
It's a framework, but if you could package an app inside a browser window as is, you can probably package it inside electron without much difficulty. It's just an application framework built on node.js and chromium. Think like Chromium Embedded Framework, but specifically for javascript. IIRC github made a sort of glue between chromium's content api and node.js code, to allow people to create whole apps on top of chromium. Github uses Electron to make the Atom text editor. http://electron.atom.io/docs/tutorial/quick-start/ You can also use other node.js packages or any other library in an electron app.
I'm using show / hide in this case because the selects are empty and populated by Ajax calls after previous selection. I'm not sure if my method is the best or to have some other way of showing it. The problem becomes worse when you have 3 or 4 selects in a row you can't put in every one "please select 1,2,3 first" etc... 
The big difference is that electron is handled as a process which can spawn windows and can use IPC to communicate between them. NW.js behaves more like a web browser would and no IPC is needed to communicate between windows. But this leads to limitations on what you can do once windows are closed (while with electron all windows can be closed and the process can still be alive).
Hmm that's unfortunate to hear. Do you feel like it's getting better? I ask because I am currently testing the atlassian suite of tools and really like how it integrates with jira and hipchat.
[Here's a very simplified version](http://www.webpackbin.com/VJUKfAhZZ) using observables. The idea is that you map click events to state via a reduce like function (`fold` in this case.. called `scan` in RxJS), and a stream listener handles view logic based on what the current state is. In libraries like [cycle.js](http://cycle.js.org/) your stream listener would return virtual dom nodes, which is a nicer, more declarative way of mapping user interaction to screen output. I would look into it as it exactly answers your overall question using some very best practices.
Writing good, maintainable code isn't something that can be offered as a bite-sized response. There are a few parts to writing javascript - it has layers. You might be really good at MVC libraries but not so hot on things like closures. You'll want to identify your weak spots to know what to improve upon, and the easiest way I know of to do that is just to start a new side project and see what you actually know. 
+~-2
Typescript involves lots of change to the files, from `.js` to `.ts`, and generally implementing it is easier from the start of a project. With flowtype, just set it up with your `.flowconfig` and put the `/* @flow */` comment at the top of the page and you can incrementally add types to your codebase... not forgetting ofcourse the strip-flow-types babel plugin to rip them back out when transpiling your code. I think the learning curve is steeper with TypeScript, I've definitely spent some time bashing my head against the screen with TypeScript and it's opinionated ways to do things, whereas flow seems more natural to me... just write your js, annotate everything with `: type` and off you go. 
I'm not sure if you're using the term "code smell" correctly, it sounds like you're using it to simply say "it sucks"....you wouldn't be wrong, but that's also not entirely accurate either. https://en.wikipedia.org/wiki/Code_smell Basically, a _code smell_ is a symptom of a larger problem, but necessarily a problem itself. The repetition that you mention could be a smell, but it's hard to say without seeing the code. Anyways, don't want to get hung-up on whether or not you're using the term correctly, because it sounds like you're simply just trying to improve your codebase. So there are 2 main concerns here: 1. Cleaning up any bad code that's already present 2. Preventing new bad code from coming in For #1, this is the crux of _refactoring_, rewriting code to [hopefully] improve it in some way. This is a whole topic unto itself, which includes all kinds of books and whatnot, but I think the most important thing to do is to first write tests to cover the old code. The tests may be ugly, and they may not cover everything you need to, but they will go a long ways in making sure that the new code produces the same result, or perhaps a better result, as the old code. Once you have tests, then you start refactoring small chunks at a time, making sure that the old tests still pass while also writing new tests that are more specific to the new code. You may even want to do additional refactorings once you get it to a more manageable state -- point is, try not to make any big changes, just a series of smaller, less risky changes. For #2, that is where tools others have mentioned will come in handy; ESLint/JSHint, etc will help to ensure that on a basic level, new code isn't too bad. For more complex things that linters can't catch, you should be doing code reviews (ideally in a github-workflow style with PR's). Just remember that the people you're reviewing are human, and that if you make them think everything they write is bad, then they're going to give up on the system and/or get upset with you.
Flow's syntax is pretty largely compatible with typescript. The big difference is in nullability, type compatibility with generics, and how much they infer types. Typescript also allows you to incrementally add types, and is probably *better* at this than flow is, imo, since it won't attempt to infer types in a lot of cases that flow would, and will instead more readily assign the `any` type until you specify one. This largely means that untyped code compiles and runs exactly under typescript as it would under javascript, even if you're doing something weird that would violate type safety. 
Why was it a mistake? What would you have chosen at the time in hindsight?
I have a function that is encoding a string (salted hash) and I want to find a strong password in that string. If a strong password isn't found then I want to reencode again until a strong password is generated. Basically I take the domain and salt it with a master password to generate a unique password for every site, but you only have to remember your master password. This way there isn't a database of all your passwords, just an algorithm. 
It's not considered bad practice if you follow the rules, I guess. For example, if you own the server-side piece (if you are sending requests to a server API that you have control over) simply include this HTTP response header, and XHR / AJAX will just work, even cross-domain: Access-Control-Allow-Origin: * If you don't own the server-side, and the API you are trying to hit doesn't include that header, then you are left with a few options. If the API supports JSONP output, then you can inject a SCRIPT tag into your page, which works cross-domain. Or, you can write a server-side proxy script that you host on the same domain as the page, which makes a server-to-server request to the remote API endpoint, and returns the results back to your page. The browser then sees it as first party, and thus works with XHR / AJAX. I wouldn't consider any of these "bad practice" per se, however the proxy script is definitely a bit dirty.
Great to hear. We're actively using it in a rather large project and will continue to update.
Thanks for checking it out. You can use Transis.Object and Transis.Array for observables without the ORM (Transis.Model). The array functionality is especially interesting because it behaves very similarly to a native array (Using [] to access items at indexes).
The proxy script is easily handled through nginx reverse proxies. location /api/thing/ { proxy_pass http://otherdomain.com/api/thing; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; }
I really, really need to look into docker..
&gt; it's something people wouldn't source on npm) - those two combined are awesome, simple, both fit on a $5 server, can be hosted in 2 lines with docker, not bad. lol I'm also part of a beta test of hosting service where you just ue the local command line to run docker containers that are instantly spun up on a server, and you only pay for as long as it's up, so like.. you can just turn it on a few seconds, or hours, and then turn it off. I haven't done much with it, and they charge $1 a month for having a permanent ip address so I've used $2 of the $20 they gave me free for testing.
Anyone knows why the Gulp 4 release is taking so long?
If you're going to use an operator to coerce to a Number -- at least use `+num`, or `num|0` for an integer. No need to abuse esoteric operators -- follow the asm spec for concise type coercion.
You can also use Meteor with Electron -- here's a demo that shows how MixMax is using them together for their desktop app: https://youtu.be/W6SyBU24S7A?t=51s
I'm not sure. My boss says to find the but and fix it. I'm not even sure there is One here. Might be a trick question
Thanks mate!
Also, aside from what has already been said, unless the finished product is going to do some kind of visual trickery that jQuery is great for, I would tend to use just straight up javascript. I do this when necessary after a recent jQuery-heavy project in which converting a number of functions to pure Javascript reduced the page load speed by a considerable amount.
&gt; How do you get home otherwise? To actually go there I just type `cd&lt;enter&gt;`. Home is in my ~~head~~ `$CDPATH`, so 99% of the time to go somewhere inside it I just type e.g. `cd D&lt;tab&gt;&lt;enter&gt;` to go to `~/Downloads`. For other times I find it faster and easier to type `$HOME` than the gymnastics routine I have to go through to type `~`.
Good job :)
^^ This. I use .disabled and .hidden all the time. Also, you can use .visible to make it less confusing (e.g. to hide something, do element.hidden() or to show it to element.visible()). If .disabled still doesn't work, you can also use CSS "pointer-events: none;" - not sure what browsers are/aren't compatible with it.
I feel like this is the answer I'm looking for but I don't fully understand it. Can you point me in the right direction how I would implement my example in the way you speak of? 
Yea, this is a tiny excerpt of what I have to do. Jquery is pretty much a necessity for given the scale and complexity of the complete app. 
Have you heared about closures in for loops?
how would that relate?
I usually just take the bus. Why do you ask?
I strongly recommend [Vue.js](http://vuejs.org). There are many exciting reasons to choose it and the community is growing steadily and rapidly. However, my main concern is OSS by companies, and how it overrules critical issues. **Angular 2** I have experimented with Angular 2 even though it isn't out yet! It's an over-engineered solution that delivers no more than simpler tools like Vue.js can. I don't see any worthwhile benefits from Angular 2. It's scary to think how over-engineered the solution is... which is extremely evident. Around than [1,500 open issues](https://github.com/angular/angular/issues), it continues to grow at an exponential rate. If Angular 2 does get released, it will have many many iterations. I do believe even if a release is delivered soon, the API will likely constantly adapt and change through the iteration cycles that it will need. How can I or anyone trust a tool that tries to meet every need? It will most certainly get more complicated as it resolves others concerns, which may not always be mine. TypeScript fan? Sure you are sorted! Not a fan? Inferior development experience. Not great! Plus this adds another learning curve. **React?** I have used React - I still do... I like React and I believe that itself has changed the way of Front End development for the better. As a developer, I can only recommend Vue over React and choose to avoid React where possible. React may be a lot simpler than Angular, but it involves more work. It also sometimes makes application code the responsible reason for why it's over engineered. Although I like React, it makes application code sometimes difficult to reason with. Not because i'm a bad developer (I hope not), but because to form a reasonable code base a team has to adopt everyones individual flavours. It also has way too many options, without making any preferences. I'm not a fan of libraries that are full of opinions, but there needs to be a fair guidance. React is also one of the heaviest libraries that implement VDOM as a View, this indicates some complexity. (I've read the source code, and it's very complex, especially to achieve what it does). As React was one of the main turning stones, it has current known issues. To fix the core needs to adapt heavily. This means the API may change. It's not as worrying as Angular 2, but this leads on to my next section. **Built by a major company!** One of the main reasons I really like Vue.js is it's not actually built by a company. However by the community... You may say 'why this is a good point?' One of the reasons React or Angular is somewhat over-engineered either by design or complexity. It tries to meet the need of an organisation. We are not all the same company... We don't want to be and we shouldn't be. We should strive to make the web better, and we do that by focusing on solving problems, and in most cases in the simplest way possible. What happens, when you get extremely clever developers competing to put their stamp on a tool at an organisational level? Most cases footprints to the tool, that you could do without. Backbone.js was created by individuals and the community, not to solve a company’s need but to solve a problem at the time of creation. For the many Backbone was a successful tool. It may not have been the best but it actually strived to solve the problem it intended. I actually still quite like it, even though I don’t use it anymore. This proves alike for many things; languages, tools, concepts, and patterns. Those that are dedicated to a company don’t always serve the best needs of the many. Placing their requirements onto others and companies, tend to lead to over engineering the solution to match theirs and others ambitions and goals. This doesn't apply to everything, Ruby on Rails is a great example. It's clear that sometimes a leader can make all the difference. I don't want to say that big companies shouldn't be followed, however it's evident that you should consider the your reasonings not on who makes it but what it delivers. Vue.js is following a mixture of this. It is adopted by many companies and individuals across the globe. It may not adopt everyones concerns, however it is much more clear on the ideologies that Vue.js tries to deliver. Who knows what Angular's true ambitions are, what about Polymer, both made by google. What will happen if Polymer takes more focus by Google. Will angular become less of a worry??? I don't honestly know what would happen... but it could lead to another 1 to 2 migration. **Some Vue.js Resources (For those interested)** * [Vue.js - Guide, API and examples](http://vuejs.org) * [Vue 2.0 Announcment](https://medium.com/the-vue-point/announcing-vue-js-2-0-8af1bde7ab9) * [Awesome Vue](https://github.com/vuejs/awesome-vue) * [Vue Redux Vuex](https://www.youtube.com/watch?v=l1KHL-TX3qs) * [Vue.js: A simple and great choice](https://www.youtube.com/watch?v=n1Xm6xjjlio) (My own talk, it’s a little rusty but it deserves a watch) * [Live Q&amp;A with Evan You](https://www.youtube.com/watch?v=Dk6ihSclKYY) ***NOTE: edited for more focus***
I chose: Vue.js. Backbone. Ampersand. why a mistake: Angular does not help to separate clearly your data from the dom (your model if you prefer). it was then not futureproof. I am using Vue since 0.10x and it is better in this aspect. Also we knew that the 2.0 will be coming, and that it will use nothing of the v1 (kind of a proof it was a mistake). and ..did I say it was poor regarding perfs?
Does it do deep comparisons into the props and state?
Thank you very much for taking the time to share your point of view! I am definitely going to give a try to Vue.js and see how it compares to React. I am a little concerned about how easy it's going to find complex examples/articles/tutorials/integrations/tools and if the community will continue to support it so extensively. Some time ago I've seen a lot of people speaking of mithril so I gave it a try but there's now much less people sharing about it. So I am afraid it goes that way for Vue.js too, will it still be that great in a month? Two months? A year? What's your feeling on that?
It uses lodash's [`isEqual`](https://lodash.com/docs#isEqual) for comparison, so yes.
Way too whiny post. Turned me off from the framework.
https://github.com/garbles/why-did-you-update Also worth a look
Neat, but why? Example benefit? 
It's also used in C#. It makes sense.
Well mostly I was just meaning that it's a built-in feature of `JSON.stringify()` that some people don't know about and it's kinda useful sometimes. But reasons for readability itself, or non-minification? Ok... I'll try, * greping lines is now easier (I guess) * always having readable json without having to pipe through json_pp * sadly many text editors named Atom have problems with 1MB+ text files with all the characters on a single line... the text editor freezes so you can't even use the pretty print JSON plugins for ten seconds while the CPU churns, so why not just avoid that bug by always pretty printing? * other approaches won't increase the wear on your ssd with unnecessarily wasted diskspace
Given what you've posted, the bug is a missing `}`.
No decent UXer will outright defend something without user testing (or having some useful data) beforehand.
People do this? Shit.
I used to use this when I was first learning js and trying to do the most clever and fast solution for every problem. Don't use bitwise math for anything other than intended bitwise math. You pretty much have to explain the intent of the code to anyone that has to work on it, and it has unintended consequences if your number happens to be larger than a 32 bit int.
github had huge outages in february, and multiple in april and march. We're committing about 18 hours a day so if there's an outage we usually hit it.
Crap, good point. That would be a good idea for an expansion.
&gt; The worst thing about Catberry &gt; &gt; It’s the size of the community, of course. That’s the main reason why people reject using it in their project. Who did you ask? If you asked me I'd tell you that I'm not using it because it doesn't solve any problems (for me) that weren't solved years ago by React and other libraries.
bitwise not &gt; x = 0xffffffff 4294967295 &gt; x.toString(2) '11111111111111111111111111111111' &gt; x = ~x 0 &gt; x.toString(2) '0' looks to me like the real issue is that javascript always interprets a number as signed even if you just want to do unsigned bitwise operations so its a little harder to look at the output of ~ and interpret what the bits are. 
Depends on how complicated stuff you want to build. If you just want to build a small tool with a web window and node.js backing, just go for NW.JS, and you'll be done in no time. Want to do a more complicated app with multi process, different windows, background threads and stuff then go for electron. But it's a hassle to use if you don't need the extra complexity. Mainly since you cant do a lot of node.js stuff (like use the 'fs' module) from the web thread.
Relevant username.
It does in English, too, hence the "jokes aside" bit in the title.
I'd definitely keep an eye on Mithril. It's used by some really high traffic sites like Guild Wars 2 and Lichess.org. Pat Cavit (lead dev on the Guild Wars 2 team) says they don't even need to use subtree:retain (the equivalent of shouldComponentUpdate, that React devs seem to spend so much effort on). Lichess is the second largest chess site in the world, with a record of more than 100 million games played, and it uses Mithril heavily on its mobile app. It handles [bullet chess tournaments](https://www.youtube.com/watch?v=KEJ9uS380UM) without breaking a sweat... And this is all with the *stable release*, which is not nearly as fast as than the upcoming 1.0. The upcoming release is not only faster but currently even smaller than stable(!), and it addresses pretty much all the concerns that people have raised over the years. The community has also been pitching in to make it more robust than ever. Speaking of which, the signal to noise ratio for community projects is very good. Projects like Polythene (material design) and Mithril Query (view testing) are super pragmatic and actively maintained. There are even [Mithril jobs](https://github.com/lhorie/mithril.js/wiki/JOBS) that you can apply for, even though that's considered a somewhat ironic thing within the Mithril community. As one user puts it, there's so little magic that "to find a Mithril developer, you search for Javascript developer"[1](https://github.com/lhorie/mithril.js/issues/1026#issuecomment-215991045).
&gt; Way too whiny post Which part?
I would call that a de-optimization. He's saying store your data in a readable way even if it costs you performance. I suppose for small personal projects that could work ok. For anything else, there are better solutions (which have already been mentioned).
Parse the JSON using JSON.parse(), add the property to the object that comes out of JSON.parse(), then serialize that object back to JSON using JSON.stringify().
But why would you store your data in a readable format at all? The only time you'd care is if you wanted to look at it (e.g., grep) and you can pipe it through a formatter prior to doing that. In other words -- if you never looked at a file you created to be "readable", you have prematurely optimized for that situation.
[removed]
I'd propose that angular wasn't even good for it's time. There already were solutions for modules without using angular's terrible dep injection scheme. It brought back java struts like JSP templating system which encourages embedding logic in templates. 
first code sample fail
i feel like the bitbucket platform has been pretty good lately in terms of uptime, hipchat on the other hand isn't so reliable sometimes. jira works well.
And all you need is a circumcision.
Generators can be used for much more than just promises. You can actually use them for any monadic type - promises just happen to be one. 
&gt;So pretty much called me stupid for liking React. Not that good of a start. It sounds like some kind of misunderstanding here. My point is that people are trying to use React everywhere they possibly can without any research because it's on hype. IMO React is very bad in server-side rendering but people are still trying to build isomorphic apps using it. When I ask them why and point to the drawbacks they can't explain why they've chosen React. They say something like "everyone works with React now and want too". It does not sound like a good way of engineering. I think React is good for small single page applications and prototyping but not for big web-sites. I had a big project in Catberry and now I have a much smaller project in React, and I can say that navigating through the project in React is more confusing to me. &gt;Even if it is your opinion why does it exist in a post about a comparison between React and Catberry? Because it's not a bare comparison, it's also about my thoughts regarding the comparison. Why I can't write it in my post on my own blog page? &gt;Which is not true in my experience. If people are new to react it does not matter what stack you choose and if they have used react before it won't be very different even if you select a different flux implementation. I have a different experience. There are plenty of data layers for React including Redux which became very popular and requires a completely different approach. Also, I know a team which has been choosing tools for React for 2 weeks already. &gt;What I got from the post was more of a rant towards the people liking React ending with a statement that only reason people should chose anything else than Catberry is because it has a small community. The point of the post is to show that Catberry does some things much better and you should consider it as an option especially if you're building an isomorphic/universal web-site. &gt;Perhaps some code examples where you do one thing in Catberry and the same thing in React? It would not be informative IMO and it would not show the whole picture, for sure. It would show how you can write the code using the frameworks but it would not show how good they work inside. Anyway, thank you for the detailed feedback, it's more informative this time.
Thank you! I have updated code examples today and made a mistake when updating this one.
Ok, then they market it far too complex, or I must have missed something. Thanks!
This will not work in the browser. You need to run your code in Node.
Penis stack coming soon? 
If anyone is using this sort of stack, what ORM do you use? I've tried sequelize but I find that it lacks support for the jsonb features added in Postgres 9.5
How is this unusual or unintended behaviour? It's not often applicable to a scripting language that is mostly used to manipulate DOM, but bitwise NOT is a completely usual and intended operator.
impressive ternary I think I would break that up into a bunch of well named functions so that a person could tell what the heck was going on.
4 space indentation ftw ;) /me runs away from the pending holy war.
It is literally tossed away. Once you through the examples, I recommend reading http://exploringjs.com/es6/ch_generators.html which goes into even more detail.
Oh c'mon. `var`? In 2016? r-
Do you have to install anything besides the app on each client?
http://imgur.com/MMpizy0
Between a pretty json browser extension and text editor json formatting, this seems like a fucking stupid thing to pollute your code with. 
How is the extra one a bug tho
The argument that null is in tells the stringify function to do no changes to the object. You can toss a function in there instead to change the object while being stringified. The 2 is how many spaces for the indentation. 
While I understand what you're trying to say ("wouldn't it be optimal if my data were easy to read?") don't use the word optimization to convey that in a computer science context. It has a [specific meaning](https://en.wikipedia.org/wiki/Program_optimization) and you're going to confuse people (or look ill-informed). EDIT: Or are you trying to say that he's "optimizing" the data to perform well with his development tools? That makes even less sense. But then again so does this entire thread so maybe that was your way of pointing that out! 
If you ever intend to cache your AJAX calls through a CDN such as CloudFront, CORS is essential.
That's... kind of amazing. How did you know that?
I also have some if you run out.
Please include me in the list. 
I'd like one please :)
Awesome Bentlegen! We (The guys at Noders) created a github repo to keep information on the talks organized. We'll add the Videos ASAP, Thanks https://github.com/noders/jsconfuy
So in your example the trigger would be bound to the data is that correct? I guess I thought by binding them to the selects, I can reuse them wherever I need chained inputs like this. Regardless if it's a select, or input or radio, as long as it has a value, enable the next element. Would what you suggest also be easy to reuse? Also, what do you recommend to show, if the next input is empty w/o the first's value? Or if there are several in a chain? I can't make them enabled, because they'll just sit there empty, and I can't keep putting "please select so and so first". Or maybe I could pull in that info by reading the previous label I suppose. Maybe that's an option. 
I'm saying they've released their app for both windows and Mac, but not Linux. Which is a strange decision because electron makes it easy to publish to all 3. 
You can use npm packages in the browser using browserify http://browserify.org/ in the terminal install browserify globally `npm install -g browserify` then install the package `npm install --save soundcloud-nodejs-api-wrapper` then bundle, replacing main.js with your js file `browserify main.js -o bundle.js` finally add the bundle.js file to your html with a script tag `&lt;script src="bundle.js"&gt;&lt;/script&gt;` If this doesn't work then I would recommend using the Soundcloud SDK CDN `&lt;script src="https://connect.soundcloud.com/sdk/sdk-3.0.0.js"&gt;&lt;/script&gt;` hope this helps!
I am a noob apparently, I didn't know you could do that. Thanks random stranger!
Me too, please! ✋
&gt; Regardless if it's a select, or input or radio, as long as it has a value, enable the next element. Well, that's what I'm talking about. The enabling code is all of the way at the bottom, and you see it does checks like `firstName()` instead of trying to fish for a select, input, or whatever. Only we're not worrying about what the "next element" is, because that's pretty hard to scale out. &gt;Also, what do you recommend to show, if the next input is empty w/o the first's value? Or if there are several in a chain? The usual way of doing this is: present everything by default. Show what fields are required by a star. Keep the submit button enabled. Let the user do their thing - if they try to submit without completing it, show a validation error to show what's gone wrong. 
http://moviecode.tumblr.com/
You can use `x.includes` rather than the much less readable `~x.indexOf` now
I use PEEP (Postgres, Elixir, Ember, Phoenix).
what? Why you being rude?
yeah, came here to say anyone on my team submitting a ternary like that for code review would get beaten with a stick.
PEE: Postgres, Elixir and Elm. (I wish...)
ermahgerd, stahp peeping mah pern
Definitely take one if there's some left :)
Exit animations are one of the things that are getting fixed in 1.0. Here's a working example: http://cdn.rawgit.com/lhorie/mithril.js/rewrite/examples/animation/mosaic.html v1.0 is all about addressing issues that have been historically difficult to fix. When it's ready to for release, I'll probably post here and on Hacker News. If you want to stay in the loop, definitely come hang out in the gitter chat. We get really interesting js discussions there :)
Sure I'll take one!
Yes please. I've been interested in that for a while and don't really get why it is invite only.
I'm on the PAW stack. Postgres, Aurelia, Web API
I have some invitations that won't otherwise be used. I can send a few out if the OP is unable to meet demand.
wow, my first negative karma comment ever! Is it because I didn't add a smiley face? It was meant to be a joke :)
Maybe node?
nice :)
Express is slowly dying. You should look into Hapi. It makes me happy.
This looks more like you've implemented Markov chains, at least after a brief skimming. Sorry if there is more that I missed. I have a baby sleeping on top of me.
Could you go into more detail of what a dynamic include would look like or an example?
Thank you for your input. I'm familiar with JSX, but I might have to look further into hyperscript :-)
Thanks for the feedback! DOM identify management? :-) Do you mean tracking of template usage throughout the page that has been rendered or do you mean something else? Currently I have the parsing/rendering aspects down pretty nicely, I'm just not too familiar with what other features would go good with a frontend template library. The library is meant to be used strictly on the frontend rather than the backend. Also, I'm undecided whether I want to add DOM dif or not yet either
from parent.pug I can include child.pug inside and it will compile the child.pug. However, I have to type *include child.pug* I can't do *include exampleVariable + ".pug"*. I have to render the child in a separate pug process and add the plain html result to a variable within the parent

While people tend to hate on W3 for a complete beginner it is an easy to understand starting point. [Here's their quick reference.](http://www.w3schools.com/jsref/met_select_add.asp) The process you want is like this: Type input, then press button which grabs text from input, creates a new option element, adds the input text to the option element &amp; finally adds that option element to the select element. I wrote a codepen for you with comments on how it works: http://codepen.io/JesusVKilmer/pen/KzYVRb
Postgres, Exixir, Phoenix, Elm PEPE :O
Thank you for the example and confirmation that Express will work for what I want to do. I was concerned I wrote this script, and it wouldn't work for what we want. Do you recommend any specific learning material on using Express? 
Oops in my example I mixed GET requests with POST requests... the link at the bottom wouldn't turn it on as it is using a GET request (aka the query string is found in the url not the body like in POST). Anyway, that was the first thing I was going to recommend. It's pretty important to have some familiarity with HTTP first. [Here's an introduction.](https://www.jmarshall.com/easy/http/) As for Express, if you find the official docs too difficult, just follow a youtuber doing a recent introductory video at least 30min long so things are explained properly. Following along helps.
I'd love one!
Now dump node and express and use C#, .NET and ASP.NET.
I'm good, thanks!
You gotta use the windows 95 version to edit the page. Also get a real browser like Netscape Navigator or Opera.
Came here to say what Cuel said, but then realised that maybe I might come across wrong. Although, I remember when I first started out I was using Frontpage, and Dreamweaver and eventually graduated to an editor without the visual help. It is easy to say as an experienced developer not to use something, but most of us forget how we started. I don't think there is anything wrong with Dreamweaver, it is great for beginners and if you hang around long enough, you eventually realise that it isn't what developers out in the field use. You would be surprised how editors like Dreamweaver are still being recommended at university/colleges and tertiary education institutes for students. My advice to you Topless, is to keep using what you feel comfortable with. But just know that eventually you will outgrow Dreamweaver, it is inevitable. As for writing and opening Javascript files, it's the same as opening any other file. Admittedly I haven't used Dreamweaver since the Macromedia days, but I assume it is simply a matter of opening it. There are plenty of learning resources online, I have heard good things about [Treehouse](https://teamtreehouse.com/learn/javascript). A popular free one is [Codeacademy](https://www.codecademy.com/learn/javascript) which is very highly regarded.
Are you using a monospaced font in your editor?
Doesn't surprise me, there is very little actually there and the styling itself looks like shit. But hopefully you can sell some books buddy.
Some interesting points made here, but ultimately you probably shouldn't be using something like React to do 60fps animation...
Seems like it should be more stateful - objects are superposed until you observe them, at which point they collapse into a defined value and *always return that value* until you call `superpose()` on them again. You could also add operators, so that a superposed object + a decohered object = a combined decohered object (a + [b,c] = ab or ac) but two superposed objects interacting yeild a new superposed object that represents all possible states of *both* original objects combined (eg, [a,b] + [c,d] = [ac,ad,bc,bd].
lol people bringing up redux, observables, MVC, etc. But no one mentioned code quality. I've simplified your code a bit. https://jsfiddle.net/rLk49cav/ The biggest improvement you can make is to try to separate your functionality into readable functions, avoid unnecessary calls to the jQuery function and learn the APIs you're using, learn the language and take advantage of it. Lots of small but big errors, declaring arguments, then not using them, confusing use of scope, creating functions within a loop, lots of stuff. Frameworks will not help you to think logically about how to separate parts of your application into pieces that make sense, nor will they improve the quality of your javascript in general. My advice would be do to some serious woodshedding with vanilla JS, learn the hell out of it. Read through React.js, Backbone, or jQuery's source. Lots of great tricks to pick up and you'll find some really interesting patterns and you'll start to pick up on how functionality should be separated on both small and large scales (except React, that repo is a fucking mess. but some of the code is nice). Ok I'm done rambling now. Hopefully the refactor I did helps. Good luck!
What is the exact minute this shows up? Thanks!
The rarest stack!
&gt; And keep in mind that React is just a small rendering library, *you can't build an app using React only.* And yet I do that all the time... &gt; Just a few things came to my mind which Catberry has for solving problems not covered by React: &gt; &gt; Progressive Rendering – I don't want to wait for the whole page is built in the server's buffer, I wanna see the content ASAP I don't do server side rendering, so I wouldn't know anything about that. I find it to be a total waste of mine and the user's time. * I don't send a giant blob of HTML so the data is smaller and loads faster * I don't render a giant page of crap the user can't possibly see at startup (if ever) so the page loads even faster * search engines, social networks, etc. have supported things like microdata, json-ld, etc. for years already and more recently Google has been able to render JS so seo isn't an issue either &gt; Small size of the bundle, it's really lightweight in comparison Not really interesting to me. The difference just isn't big enough for it to matter, sorry. &gt; Complete solution for building an app out of the box, In some cases this is good, but in most, it means that I have to twist and mangle my code to fit into your framework, which is IMO, worse than any benefit it had to begin with &gt; you don't need to find a data layer, a builder and other stuff I'm not sure what that means. I don't *have to* do any of that with React &gt; Strict architecture – onboarding process for new developers is much easier Much easier after they've learned the whole framework, yeah. &gt; Support for any template engine (official support for Handlebars, Jade, Dust). I know enough people who don't like JSX I left *template engines* behind years ago. These days, if it can't provide any static guarantees that it's not going to blow up at runtime, then I don't even bother looking at it... not the mention how their inflexibility usually lead to bad code because instead of just writing simple JS code I have to jump through hoops. &gt; It does not mix markup and source code, you can work with designers in parallel. I don't understand this one either. If you're saying it's better to have to write code in two or more files at once just to make something work, then that's a negative for me all day long. Besides, I don't see how JSX prevents you from separating *markup* and *source code*. It's Javascript afterall, why not use it like the real programming language that it is? 
We are open to improving the look and feel. If you are a UI expert, please feel free to open a pull request on the GitHub repo.
Because we need to make room for *another* framework of course. 
Don't use Dreamweaver, you won't learn anything. Use Sublime or Atom.
/r/typescript is over there
I was on the verge of looking into Koa. If I may ask, why do you prefer Hapi over Koa?
Thank you for this. I'm trying to understand what $.prototype.every does in this case? 
Oh my god, you don't even know how long I've been looking for this, thank you so much!
Thanks that's a pretty nice tip. Meanwhile in Ruby you can do require 'json' JSON.pretty_generate({...}) #instead of {...}.to_json
It's not a false positive. You are never reassigning `foo`, so it can be a `const`, which is exactly what `prefer-const` is intended to check. `foo.bar = 123` does *not* change what is assigned to `foo`, it only alters it, which is perfectly fine with `const`.
I mean for example you have a list of data var users = [{name: "John", user: "Mary"}] Now if your template did this: {{for user of users}} &lt;button&gt;Delete {{user.name}}&lt;/button&gt; {{endfor}} If the user presses the button for John, you want to remove the first `&lt;button&gt;` tag, not remove the last and change the contents of the first. In this particular case it matters because you want the focus to go away when you press the first button. If it doesn't, the button for Mary will be focused after you click the button for John. There are other situations where this is important, for example lists containing inputs or stateful jquery plugins. re: DOM diffing - it you're aiming to release something production-level, it's kind of a requirement these days, unless you have some novel idea. There are many good libraries out there already, and many minimalist ones too (and often they're both). Of the ones I've been paying attention to, FRZR.js is the only one without a modern diff algorithm that still manages to have decent performance (at the expense of making application-space code harder to write in a way that somewhat resembles Backbone). Od is another interesting library in that space (it draws inspiration for Knockout). Now if you're just writing a library to learn or for fun, that's cool too. Don't feel discouraged.
+1 for jq (cli). You can get a taste of it at jqplay.org
I never understood the love for Handlebars or Mustache. They limit the developer immensely. When I want to do a simple loop, I probably also want an `if () {} else if () {} else {}` kind of structure in there. And I don't want to bother with "helpers" and other such bullshit. The "separation of concerns" thing is an ancient and outdated concept (IMO), we don't need the templates separated from the controllers anymore. I want full control over everything because I know what I'm doing, and my team mates know it too. TL;DR: Be limitless. Not limited. Honestly, I loved the good ol' days where we had to transform XML with XSLT stylesheets. Remember that? `&lt;xsl:for-each&gt;` And `&lt;xsl:if&gt;` and `&lt;xsl:choose&gt;` and `&lt;xsl:template&gt;` and so much more! Fully capable of templating the shit out of any set of data. Loved that. Just required too much typing.
Have you thought about node-red? It's an express app that can handle use cases like this on the pi. http://nodered.org/docs/hardware/raspberrypi
Bad article. Lots of text showing that the author doesn't understand what it is ("this algorithm", obscure use-cases). And then there's only finally mentioned in an addon that it is the bitwise negation operator, which is perfectly useful and necessary if you are working with bits/bytes (e.g. in binary encodings, with node.js Buffer objects or ArrayBuffers, ...).
Thanks for the suggestions, I'll do some more research and add some changes today! Question though, if you've got a moment. Once we stop observing something wouldn't it return to a superposition until being observed again? Or once we observe an objects state does that become a constant? (speaking about quantum mechanics, not what the script does at the moment)
Just out of curiosity what's the bad press you're hearing? I liked Aurelia when I tried it out but at that point (mid-last year) it seemed pretty bloated. I wound up choosing Vue as my go-to template-based MVVM which I think was the right call.
Not much you can do with RVNK (Rethink, Vue, Node, Koa). :( I need to get a vowel in there somewhere.
Because the company that bought it alienated its main contributor and the fundamental design would need to be reworked to support HTTP 2.
No, for [actual reasons](https://www.reddit.com/r/javascript/comments/4j0vs9/slug/d33x9rp) this tine
The RRRRR stack for statistical visualizations: R, React, Redux, React Router
https://github.com/sequelize/sequelize-auto It's awesome! I don't like to generate models in any language, mostly because it's easier to generate relations and such using pure SQL.
Not in ECMAScript specs. So, you can only use hacks.
/r/learnjavascript seems like a better spot for this IMHO. 
hm... I can't recall the last time I saw an AMD module in the wild.
Just wrote a comment that explains how this algorithm works in kivi :) https://github.com/localvoid/kivi/blob/569ba49acd7d5c8809cfc621eb02ec6206f0d3c9/lib/reconciler.ts#L410-L641
Change in preferences -&gt; settings-&gt;user. Find the fields you want to change in .... settings -&gt; default (you may have to create the JSON object in the file the first time you go in). If I remember, you just need to change tabs_to_spaces to true, and that should clear up your github formatting. (I also changed my tab size to 2 spaces there). Also, you can check out the keyBindings in preferences, and set up custom hot keys. Same thing as above, find the defaults in preferences-&gt; keyBindings -&gt; default and change the JSON in ... keyBindings -&gt; users. When sublime updates, default settings will get reset, but user sertings will be saved. Same for keyBindings.
Thanks for your reply, I have seen a reply saying about using Atom and decided that looked good, In terms of learning I found a cool little puzzle game called http://play.elevatorsaga.com/ and another called http://www.jsdares.com/. I also signed up to Codeacademy.
You essential want UMD (Universal Module Definition). You can check it out here: https://github.com/umdjs/umd Basically it's a small snippet of code that wraps your module in a factory function and takes that factory and determines how to export it based on the environment it's in. Here's a small snippet: (function (root, factory) { if (typeof define === 'function' &amp;&amp; define.amd) { // AMD. Register as an anonymous module. define([], factory); } else if (typeof module === 'object' &amp;&amp; module.exports) { // Node. Does not work with strict CommonJS, but // only CommonJS-like environments that support module.exports, // like Node. module.exports = factory(); } else { // Browser globals (root is window) root.MyModule = factory(); } }(this, function myModuleFactory() { // Just return a value to define the module export. // This example returns an object, but the module // can return a function as the exported value. return {}; }));
So... Xnternationalization?
This is the correct way.
I would give Brackets a try, it's made by Adobe. It's open-source so you can download a lot of useful plugins and it also has live preview. It's worth a shot.
[Codepen](http://codepen.io/) helped me a lot in learning HTML, CSS, and JavaScript. It allows you to make mistakes and learn from them faster and more obviously than with Dreamweaver (or most editors). 
nope check out the link if you can.
Its usually not a great idea to add prototypes to anything involving the DOM, but that's what he did to be able to call the every function on the jquery object. An easier way would have been to just use [].every.call(this, hasVal)
Thanks for the help, but it looks like I got the answer I was looking for here https://www.reddit.com/r/Meteor/comments/4j6sxp/newbie_question_what_gets_passed_as_this_to/d3474c9
It's not adding anything to a native prototype, it's adding to the jQuery prototype which is perfectly fine. In fact, that's how jQuery plugins are created. To answer OP's question, it's calling Array.prototype.every on a jquery object. Array.prototype.every iterates over an array (or in this case a jQuery object) and runs a function over each item, if the function returns false, it will break and return false, else if every element passes your 'test' then it will return true. It's just a simpler way of writing: var allSelectsHaveValue = true; $(selects).each(function() { if (!$(this).val()) { allSelectsHaveValue = false; return false; } });
&gt; Once we stop observing something wouldn't it return to a superposition until being observed again? I'm no expert on Quantum Mechanics, but I don't believe so - at least not that quickly/deterministically. Quantum decoherence is quite a fragile state - you have to carefully insulate a system from any/all outside interactions and then wait for it to reachieve superposition. It's not like you can measure the spin of a particle twice in quick succession and get different results because it's instantaneously reachieved superposition in the mean-time
Also, once you've learned the basics through codeacademy/tree house and the games you found (Codecombat is great too, if I recall) if you want to learn a bit more than just the basics of javascript (understand it more, learn jQuery...) I'd recommend Master Time and Space with Javascript from Noel Rappin (the first book is free and It's great)
Thanks for the reply. I'll give this a read when I get off work. I wasn't aware this existed!
It's okay, it still helped me understand some basic principles that I was missing. I'll check out some videos ASAP.
Thanks, that's awesome. Would this work for "ES6 Modules" for example using System.js to load modules for an Angular2 app. Spent a little time with SystemJS but finding it's quite fussy. I can load RequireJS modules if I load RequireJS there ends up being conflicts with the "exports" and "modules" keywords if I have mixed module types.
Looks good, but I'm not going to try to get one while having to close modal pop-ups on every page...
Awesome, keep up the good work. Does it not use es6 template-strings with hyperx? Or are you supplying a polyfill for them?
I really wish people would provide a bit of a sales pitch when they duplicate existing solutions. so, how does this compare to using the ICU message format along with a compatible JS library like https://github.com/SlexAxton/messageformat.js/ (not my project, but the linked icu-converter tool at the bottom of the readme is mine which is why I thought of this off the top of my head)
There are several decisions with the ui that are confusing to say the least, affordances and constraints are severely lacking. But the one decision that I cannot understand is the single letter modal letter input.
does the pluralization only support '1' and 'n'? A lot of languages have more complex rules (such as arabic). 
`const` being immutable is a "common misconception" (https://mathiasbynens.be/notes/es6-const). I wish it *were* immutable though. 
That code is "minified" which is optimized for payload size at the expense of readability, debuggability, and basically everything else. Even if you formatted it the variable names would still be nonsense. If you want to make changes (or otherwise examine the source code) you should download the non-minified version.
As others have said, you're looking at the "minnified" code, which as close to "compiled" code as Javascript gets. Your best option by far is to obtain the original un-minnified source code. ... but, if that's not possible, there are programs you can use to "un-minnify" code. Of course you'll still lose a lot (if the minnifier converted a "foo" variable to "x", there's no way for the un-minnifier to know that the original name was "foo", so it will leave it as "x"), but if you can't get the original source then it's the best you can do. The simplest/easiest way to "un-minnify" is already there in your browser, or at least it is if you're using Chrome. Simply open up the developer tools (CTRL + SHIFT + i), switch to the "Sources" tab, and open up the minnified file (either with CTRL + g or by using the left-panel). Now, click the "{}" icon in the lower left corner of the source code frame. Chrome will do its best to create a readable version of that code, and you can view it without installing any special programs. You can even do all the usual debugging stuff (eg. add breakpoints, watch expressions, etc.) as you use the site and make your way through the code.
If your library has no side-effects (e.g. automatic initialization, modifying DOM without it be passed in), you can just write it for CommonJS, and there are a bunch of compilers would compile your code into ES6/CommonJS/AMD/UMD for you. For example in Browserify, if you specify `--standalone` it would bundle it into an UMD module that could interop with any of the above. I am pretty sure Babel and Webpack can do the same thing. You can write your module in ES6 module too, however, if you do multiple export, it would make it harder to use by ES5 users. 
You answered your own question: &gt;Is this problem because youtube just don't let me grab the video? [It sure is.](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS)
Goddamnit reddit... for once I thought I might have a shot at posting something nobody else thought of... &gt;_&lt;
I've just been using babels website since it's one file and easy enough :P (I know, I'm lazy) You'll need the `transform-object-rest-spread` transformer https://babeljs.io/docs/plugins/transform-object-rest-spread/
Yes, because you created a completely new object ({}!=={}) 
I love this. The visualizations are really nice and the sounds are hilarious. I think merge sort is my personal favorite to watch/listen to. Well done!
Ahh there is. "Timer off" That is super not obvious. I suggest maybe "Start" or "Run" with a prominent color.
Nr. 4 (classes) is not a fix but a step in the wrong direction. JavaScript still doesn't have proper classes (neither does it need them). The ES2015 classes are counterfeit syntactic sugar over prototypical OOP. While seemingly friendly to people used to Java/C# OOP all it really does is obfuscate the prototypical OOP underneath.
It supports constants and 'n' to catch everything else. Is that enough for Arabic (e.g.) or what else would be needed?
Yea that sounds like a good idea, I will make that happen tomorrow. Thanks for the suggestion.
You can use them to implement [coroutines](https://github.com/tj/co). Various uses as coroutines have pretty much covered all the real world uses I've had to write generators, both in js and in Python. I've *used* library generators for number ranges and prime sequences a lot more times than I've written them.
Hahaha you and me both, hence starting an entire friggin business around them :P
It made me take a three year academic detour because I wanted to keep programming as a fun hobby. In the end I realized that it was a stupid way to think. Now I work with something I enjoy and I can still enjoy hobby projects (that are not too similar to my work ;-)) 
http://stackoverflow.com/a/262511/179609
One easy option would be to write the module using ES6 module syntax, then use Browserify and Babel to generate a UMD version of the file, so you'd have two versions of your module, one with ES6 module syntax, and one with UMD.
People have been doing "classes" in JS for a long time, ES6 just makes the syntax a bit nicer.
But really shouldn't libraries be namespaced? You really shouldn't need too many global variables.
All of that sweet comment karma could have been yours!
imo, it's useful for making it easier to set up prototype chains. I've seen ... probably 3 or 4 ways to do that, and they all have slightly different problems/effects.
ES6 generators are actually more powerful than generators in some other languages. Because they can feed values back into the generator (and errors), you can basically implement things like haskell-style `do` syntax for monadic constructs. Putting it another way, generators are good for when you have a series of steps you need to do, but you have some boilerplate you need to do between each step - such as error handling, checking for failed results (like validation), or chaining on a promise. Of course, you can also use them for lazy generation of values.
take a look at the link palrepa posted to get an idea of how crazy things can get. the messageformat libraries (eg https://github.com/yahoo/intl-messageformat) handle it by making the plural rules a mapping function. That is, `n` goes in, and a string value such as 'one', 'two', 'few', or 'many' comes out the other end. This is in addition to being able to match directly on `n`. Something like that would help. It also supports an offset value so that you can construct strings like 'you and 28 others upvoted this' 
Per of JS: It works nearly everywhere. 
I never understood the need for everything to be in a class. Once you understand the power of prototypes, the idea of using classes suddenly drifts away. I find that developers often want to shoehorn something into a language simply because they do not understand how to work to its strengths. 
Hello! I do kernel and backend dev and recently switched to frontend (React, Redux, etc) and it is crazy complex and I have no idea what you're talking about by implying it's trivial. No-one's a dummy, chill out.
I think it's a symptom of a deeper problem. Modern software platforms are unreasonably complex, all in the name of making things "easy". Unfortunately the design decisions for these "easy" platforms represent the best ideas 1990s enterprise software development had to offer. These frameworks have gained in popularity as an attempt to reclaim some simplicity and being us back down to earth as programmers, but the platform always rears its ugly head. The demon always eats. We're all just witch doctors throwing incantations at our dark gods, the browsers, hoping that this incantation won't displease the current incarnation we have set out to appease. I don't think the programmers are the problem.
&gt; Regarding functions in loops, I believe it's considered a bad practise (JSHint shows warnings about it as well). It *used to be* a bad practice because "var" didn't have block scope (one of the bad parts). But ES6 and "let" changes that, and JSHint will have to update itself accordingly.
&gt;Per Perk?
redux-saga is a great example of using generators in real-world apps. [redux-saga](http://yelouafi.github.io/redux-saga/index.html)
I don't like this much. Why? Because now you get 2 very similar yet slightly different ways of doing something (`var` vs. `let`, `function` vs. `=&gt;`) that are different in rather subtle ways. The net result is a bigger and more confusing language. 
Once upon a time, ActionScript 3 made the choice to have instance methods implicitly bound to the instance (back in the ES4 days), which is indeed what you want 99.3% of the time, but I guess that was perhaps too radical of a change for the Ecmascript committee. As things stand, I find my teammates write code that either looks like `this.listenTo(model, "change", (e) =&gt; this.reactToChange(e));` or sometimes they just add this in the constructor: `_.bindAll(this, "reactToChange", "laundry", "list", "of", "methods");` I think I like the first approach better. It's effectively a nested function/closure, and you can use that with classes happily enough. It's not an either/or. If one was so inclined, they could write some kind of base class that'd loop over all methods and auto-bind them on each instance. I'd be instinctively scared of adding gratuitous loops on every object construction in the off chance they may be useful, but it's probably not unreasonable in many cases. Fwiw, typescript gives you visibility modifiers, so you can flag members/methods as protected or private. As usual, this means nothing at runtime, but it expresses intent in your source, and the compiler will catch benign attempts to ignore them. 
I'm curious about what's gotten you so riled up. It sounds like you're mainly complaining about today's code sharing technology. Github and package managers for web languages/platforms are simple and common place now. It's much easier to host code and have others install it, whether you're still writing PHP, working with JS, Python or dabbling with Go. But really, there's always been code sharing; libs that developers pull in because they're stable, trusted, tested, active. People will always use libs. You could even take your argument further and rant about high level languages vs assembly. *C++ is turning developers into* **dummies** *because there's a language feature every problem or ready-made algorithm that you just* **plug in** *to some code!*. As for robust frameworks, there are some projects that are frequent and not very complicated but take some time to put together - sites that boil down to CRUD for example. It makes sense to use frameworks for these types of projects so that you can minimise what is essentially application boilerplate and speed things up, keeping stuff structured while you do. Sometimes these frameworks are desired by employers (particularly HR people or recruiters that are just looking at the buzz words) so developers cater to that in order to get noticed, but any good interviewer will always be more interested in core skills. Frameworks come and go, but core skills are forever, and they help developers understand new frameworks or even libraries when they appear (especially in a fast moving industry). Also, in JavaScript specifically, people are *constantly* complaining about "JavaScript fatigue" and that front end is so fast moving and complex. People are saying this because developers go away and try to (re)implement their own libraries, frameworks or, yes, even plugins. Developers are constantly writing code that solves problems; it may just be that you're not finding yourself in that position at the moment, but then came up against a problem that a plugin or the framework wouldn't let you solve easily, and have no idea how to approach it because the parts you're using are somewhat complex.
Nothing to be confused. In short, use "let" and "const" instead of "var" and use "=&gt;" instead of function to get most bang for buck. You can also use "class" syntax as it's a bit simpler. Babel will take care of adding "use strict" and doing the transpiling to ES5. Of course, you can use all the other ES6' features.
Remember, It's just a syntactic sugar. Everything is still prototypical inheritance. This is just to make new comers and those who don't understand "call", "prototype" etc happy.
`co` is a fantastic real-world example of using generators for application flow. It's basically `async/await` before those key word are technically available. Shameless self plug for a [library](https://github.com/dvlsg/iterablejs) I wrote which uses generators to lazily handle functional transformers like `map` and `filter` on top of iterable items (anything with `Symbol.iterator` on it), similarly to how linq works in C# with `IEnumerable` (at least for the objects flavor of linq, anyways).
[removed]
[removed]
Is ES6 supposed to be "some other, better, programming language"?
It's meant to be good for future generations of js programmers, and I'm sure old school js devs can handle the change. Given the need for backward compatibility, there was no other way to improve the language.
basically I was on academic probation for most of my time in college as a literature major because I was spending so much time coding, stuck it out to earn my bachelor of arts degree and went to work as a software engineer.
This is the best implementation I've seen in the last, what, 30 years? God, I am so old. :( 
Wait, arrow functions, const, and let make ES6 *more difficult to read* for you? Arrows are a *huge* improvement in legibility to me. 
Conway's game of life. It's frequently used by comp sci academics to demonstrate how complexity can emerge from simplicity. The rules of the "game" are very basic. But some very interesting things happen in this game- or more appropriately, simulation. Btw- you don't interact with it in the sense we think of games today.
Are people seriously complaining because it's too confusing? It's incredibly simple: block scope Vs. Hoisting and function scope for let/const Vs var. Fat arrow Vs function is as simple as always binding this at time of declaration to your function, which is what you want 99% of the time you declare a function. I honestly can't see how anyone could be confused by this. 
 =&gt; is too close to &lt;= and &gt;= which are used pervasively as comparison operators. It makes little sense to pollute the long-established syntax with a pictograph because someone *thought they were being clever*. There are two types of programmers - the ones who think they are clever, and the ones who can reason. 
&gt;There are two types of programmers - the ones who think they are clever, and the ones who can reason. Does this not sound a little unfair to you? Just because someone likes syntax you don't doesn't suddenly mean they *can't reason*. It just means that they have different life and programming experiences, such that they don't confuse `=&gt;` with comparison operators, and immediately read it like any other programming language with lightweight lambda syntax. 
Just because you haven't seen the reason to use something doesn't mean people who do use it do so just because it's "new and shiny"
It's more "powerful" since it can express a "classful" inheritance model, but it is not as easy to go the other way around. I also find it interesting since it's possible to express both type classes and that "classful" inheritance with it. It's true that it doesn't support some things, like private state, but JS isn't alone in that, either. 
What exactly are we not doing?
&gt;It just means that they have different life and programming experiences You can speculate about the lives of the subset of programmers that fit your argument, or you can talk about the decision to introduce pictographs into a language that has never done that in 20 years. Javascript is not Ecmascript. Javascript is dead, long live Javascript. 
It's still a bad practice in ES2015. While you're semi-correct about the reasoning, the major reason it's a bad practice is because you'll cause the interpreter to create multiple function instances. Since functions are just a standard object, the interpreter can't assume that no properties of the function will change with each iteration so it has no other solution than to keep recreating new instances of the function. This is a core bit of the JavaScript language and unless ecma262 decides to make functions no longer objects, which would be terrible if they did, then this will always be a performance issue.
&gt; This is just to make new comers and those who don't understand "call", "prototype" etc happy. I _really_ dislike this reasoning because I think the use of the `class` keyword just makes things more confusing and obtuse to newcomers. It seems like a good 3/4 of developers I talk to about ES6 just assume that prototypes are gone and JavaScript has "finally" gone to using classical inheritance. From a programming languages standpoint using `class` as the keyword makes sense, but from a usability standpoint I think it would have made better sense to use something like `prototype` since that differentiates it from a classical inheritance model.
If you'd rather not be learning ES6 on a thread ostensibly about an article of that subject, then what are you here for? To complain? :) If you want to go learn 3d graphics, or whatever, I'm totally not going to stop you. I just think it's helpful to remind people that being confused about new ideas is a natural part of being a programmer - but that it doesn't end at being confused. 
This [Stack Overflow post on the benefits of prototypal inheritance](http://stackoverflow.com/questions/2800964/benefits-of-prototypal-inheritance-over-classical) is probably the best written explanation you can find on the internet. Shah (the author of the post) goes into heavy details but it can basically be summed up as this: Prototypes allow for the quick and flexible composition of new objects. You can delegate a new prototype from an existing one, and pick and choose what properties you want from many different prototypes. This allows JavaScript to completely avoid the diamond problem.
&gt;If you'd rather not be learning ES6 on a thread ostensibly about an article of that subject, then what are you here for? To complain? :) Don't try to change the subject, or focus the discussion on me personally - that's a troll tactic. I'm not confused at all. But you are right, some people are confused and think they need to use ES6 because it's a buzzword. I've suffered through a lot of that already with various companies that feel like their code is somehow superior or better because they added =&gt;, because now they're using ES6 and suddenly their code is awesome and beautiful and shoots rainbows out its ass. It's completely bogus, but they still think that way. 
Chrome Dev Tools has an emulator to test your website on all screen sizes, by simply dragging to expand. Check it out, the view option is called 'responsive'. I would do that at the very least, obviously testing on a real phone/tablet is better, but that will suffice. Media queries are your friend, if your doing mobile first designing!
Poor handlebars :( That's what I use.
Hi /u/harismahmood89, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
OP's user name...
It might be worth noting that Async/Await uses generators underneath: https://tc39.github.io/ecmascript-asyncawait/#desugaring
That's completely inane, the diamond problem is an MI issue, js does not have MI, that's how it avoids the diamond problem, same as Ruby or Java. And that essay is just plain sad, most of the comparisons between prototypal and class-based OO are just dishonest heaps of FUD. That bloke's basically taking java, drive-by nailing a few additional concept legs to that poor dog and holding that strawman as the representative of class-based OO, facing JS as representative of prototypal OO on Javascript's turf. Which is just sad for both OO schools, Java is not representative of class-based OO itself (only on its specific statically-typed take on it) and JS is just a sorry sack, it uses prototypal OO because that was a quick and easy way to get an OO language turned in under two weeks, not because it wanted to be a good prototypal language (it's not).
I wish you could write c++ or c# instead of Javascript :) 
Ty, much appris the feedback.
Mostly people want namespacing. Also Javascript's implementation of prototypes leaves a lot to be desired compared to say the Io Language. To me, Javascripts' implementation of prototypes is as limited and ill done as Java 1.0's implementation of class-based types.
I want to give Javascript a little more credit here. `let` makes it so that variables can only be used in their scope. How it was with earlier versions, and you always had to keep your eye on this, is that some prankster could come along, declare a variable with the same name and your whole code was broken. Lexically binding this is way more useful when using callbacks within classes. When you need to mutate a class variable, you would be screwed if you didn't have arrow functions, because you would have to declare a variable called `self` or `that` that would have the scope of the class. It feels really clunky. `const` is really handy, not going argue with that. I mostly use constants when exporting variables in files (I use Node.js mostly). Just a quick note to /u/leptons: lambda is not a pictograph. It is an operator. Just like any of your `+ - / *, etc`. It shortens a lot of your code and if you have ever used C#, you will see their use.
=&gt; is called "fat arrow". It is absolutely a pictograph of an arrow. It's a combination of two mathematical operators = and &gt; combined to form a pictograph of an arrow. Sorry, it's not a good design decision and I don't care how many other languages use it - it's too similar to &lt;= which is not a fat arrow even though it looks similar. It's confusing to the eye. It's not something I like to see in javascript code. 
&gt; So if I were to post anything, it'd all be to my own blog... would that be bad? Yes – Reddit itself even forbids that. It’s not an issue of the subreddits, but reddit itself.
I haven't given any away yet (derp) but i have 9 and there's 15 requests, so at the moment I only have enough for half
I would love to know what you're trying to say.
Indeed. Nary a cogent sentence therein.
First of all I would like to say that I would be very interested to watch a video series where someone explains how to build fancy widgets in React from scratch. &amp;nbsp; Having said that, I found your video rather disappointing... &amp;nbsp; First of all, the whole concept of your video is about building a drop down menu, but in the end all you build is a small component which has 1 boolean value in it's state ("open") and that just shows or hides some other HTML depending on whether it's true or false. &amp;nbsp; A large part of building a dropdown-menu is actually the CSS, but you're abstracting it all away by using bootstrap. In this example, you could have just had a button that shows some &lt;span&gt; element on click, and removes it again on the same click. &amp;nbsp; That leads me to my second point: this example was way too easy for anyone who already has had exposure to React. There's really nothing new or exciting here. But if you'd show this video to people who are new to React, They would be really confused as you skip over a lot of concepts (e.g. using .bind(this) in your event handler etc). &amp;nbsp; I think the code is really messy. In your `_handleDropDown` function the `this.setState()` has incorrect indentation. There are no empty lines between functions. I'm not a fan of your use of whitespacing, but that's a personal choice. Also you kept everything in 1 component, but if I'd build this I'd use 3 components: 1 for the button, 1 for the menu, and 1 for the menu items. &amp;nbsp; Finally, if you'd like to focus on more experienced developers, it would be really awesome to see how to add tests as well. I think this part is still missing the most from React tutorials, that people just code things but don't explain how to test them. &amp;nbsp; I hope I'm not being too harsh, I just wanted to give you honest feedback. I think you need to choose your audience target: &amp;nbsp; * Mid-level React Experience: More complex examples, write CSS from scratch, add tests * Junior devs learning React: Take it a bit slower, explain some concepts more in depth, keep simple examples &amp;nbsp; I hope you don't give up making videos and can use this feedback to improve. I find it very brave that people are putting themselves out there for everyone to see, something that I personally am still too shy to do... :)
What you've written is mostly incoherent, but it seems like you're trying to describe some kind of process that takes input, runs it though a series of processing steps and then displays the output. This is possible. function process(input) { var a = encodeStepA(input); var b = encodeStepB(a); var c = encodeStepC(b); var d = encodeStepD(c); return d; } You'll have to define what each of the encoding steps are. Obtaining the input and displaying the output are left to you.
CouchDB seems suitable for your requirements. Try it out. It has features for dealing with concurrency issues. Couch has always seemed superior to other "NoSql" databases, it's robust, easy to use, and has a good feature set. I'm not sure why it's not more popular.
I've just started a test app with Firebase. It looks good, but they provide the hosting too, so the free account service is limited. I'll try CouchDB, thanks!
Webpack has a UMD output type that does what you want.
C'mon man... you're the one who brought it up. &gt;I'd rather be spending my time learning 3d graphics, cartographic programming, encryption, DSP programing, and a million other things that have nothing to do with obsessing over syntax fetish. I just found it amusing that you would openly talk about how you didn't want to learn ES6 on a thread about that. Now that you're gaslighting me and being defensive, though, it's much less amusing. &gt;I've suffered through a lot of that already with various companies that feel like their code is somehow superior or better because they added =&gt;, Would it not be reasonable here to assume that these people and companies would do this with any, in your own words, "shiny new things"? It seems like your problem here is fad chasers who over-inflate the value of novelty, not with ES6 itself.
You can also make array of functors: function step1( value ) { return ... }; function step2( value ) { return ... }; var steps = [ step1 , step2 , step3 , step4 ]; var value = 555; steps.forEach( function( f ) { value = f( value ); };
I use it for bookmarking projects I could use later on. 360 stars at the moment :D
Since Github stars are often used to indicate a library's popularity, I basically star anything I want to support in that sense. It can help get the word out if a module has a mess of Github stars.
I have a script that clones any projects I have starred (along with my own projects and organization projects) for backup purposes. That way if anyone rage quits and deletes their repos, I'll have a copy.
I started making some ng2 components: * https://github.com/seiyria/ng2-ace * https://github.com/seiyria/ng2-sweetalert2 * https://github.com/seiyria/ng2-fontawesome I think they're cool!
You're missing the point, it's not that specific languages are verboten, it's that you're either comparing languages or paradigms, and if you're comparing paradigms and want to provide real-world examples then you should at the very least pick languages similar in principles and intent as your representative, not pick languages completely dissimilar in their intents and purpose. So if you want to compare a class-based language to javascript, you pick a lightweight dynamically typed language like Smalltalk or Ruby or Python (though the latter is MI), you don't pick an enterprisey statically typed strawman mixing Java and C# with some C++ bullshit thrown in for good measure because you've heard of the diamond problem but it doesn't exist in Java or C# and you still want to take one more pot-shot. It also helps if you're honest about the bullshit you peddle (especially when it's limitations of the language not the model) e.g. you can't claim both that prototypal inheritance can do MI via concatenative inheritance[0] and that an advantage of prototypal inheritance is you can modify the prototype afterwards[1][2]. [0] it doesn't, incidentally, *javascript* does. Self and Io have first-class prototypal MI, no concatenative hacks necessary [1] since that doesn't work under concatenative inheritance [2] and neither class-based nor prototype-based OO assert that property, or lack thereof. It's trivial to add new methods to Ruby classes, or swap the class of a Python instance at runtime, hell Smalltalk even lets you swap out object references so you can replace an object with an other completely unrelated one throughout the system with a single message
https://news.ycombinator.com/item?id=11695904
This is pretty much it. If I'm really interested in the library I'll additionally watch it. One time someone pm'd me to exchange stars on our github projects as some kind of mutual benefit kind of thing - I guess github stars matter to some extent? - anyway I thought his project was interesting so why not. Then again, a lot of joke libraries get thousands of stars - so I wouldn't rely on star count too much. I use twitter as a kind of bookmark to tweet good blog posts or tutorials and such - that way I can always find them again later. Plus it shows the author that I like his work so that's a bonus.
&gt; Now that you're gaslighting me and being defensive, though, it's much less amusing. You're trolling. Fuck off Troll. "The main tool of the troll is accusation" "Trolls will quickly move from serious discussion about an issue to a sustained personal assault." http://www.peorian.com/technology/technology-news/trolls-cyberbullies/1079-how-to-identify-and-defeat-an-internet-troll 
Not that it matters much to me, but the fact that you call it "5 minutes" but it's really 7:44 is deceptive, and I'm sure that brought on some automatic downvotes. Other points: * Logo effects in the beginning are overdone, keep in mind your audience are developers, not 14 year old gamers * Not clear how advanced your audience is supposed to be (you use `this._handleDropDown.bind(this)` , without even commenting on it, which isn't very friendly to beginners. * Voice is very low / hard to hear at times * Could use better organization (even adding something as basic as an outline of what you're going to cover would help tremendously, especially since this is close to 10 mins)
Although you can do it in js if allowed, it maybe beneficial to do it in the language you are interviewing for.
haha i like how people always complain about how bad a language is that is basically running every single website :D it is like complaining about english https://twitter.com/notch/status/654712791895400449 
Heard of require('http').createServe ? For simple routing 
Typically, interviewers will let you solve it in whatever language you're most comfortable with. They want to see your problem solving skills and understanding of CS fundamentals first and foremost. As far as using native array methods to implement a queue, remember that shift is O(n), and for a queue, you want constant time for both enqueue and dequeue. So, it would be much better to implement it using a linked list. That shows the interviewer you have a solid grasp of these data structures, and you know how to use them together, or build one with another, to meet the criteria.
It landed me a job before I finished college. I never ended up finishing, but I never ended up needing the paper either. 
I'm not sure I can give any more firm guidance other than what's linked in my above comment, but it all boils down to: &gt; "It's perfectly fine to be a redditor with a website, it's not okay to be a website with a reddit account." - Confucius Taken from the [wiki page about self-promotion](https://www.reddit.com/wiki/selfpromotion). Over time, it's usually obvious what poster's motivations are. For OP of this thread, if you look at their comment history, a vast majority of their comments take place only in their own posts. So they mostly only post their own content, and their only other participation on reddit is to support their own posts, so it's obvious that they're here solely to promote their content. They're a website with a reddit account. Looking at your history, you look like a normal redditor. edit: Forgot to add, but users are encouraged to post as much of their own content as they wish in our weekly [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts -- we almost called it "Self-Promotion Saturday", but thought "Showoff Saturday" might be more inclusive. One of the goals in starting that series was to give content creators an outlet to self-promote without worrying about running afoul of self-promotion guidelines.
I ended up going the CIS route instead of CS because I wasn't sure if I would want to programmer for my entire career. The additional business classes were fairly easy but I did miss out on some of the more traditional CS knowledge because CIS they didn't get as close to the metal (and generally only use C# instead of Java or C). Sometimes I regret that, but other times it is nice to be able to see the bigger picture from the business stand point. That said, the tech industry is really more about what you can do rather than where you went to school (some places not withstanding). I think there are three key things most places will look for: 1) Design patterns and when to use which one 2) A true understanding of JavaScript (assuming that is the route you're going) 3) The ability to take something from concept to MVP (can you actually build what you're talking about?)
Read [SAS files](https://en.wikipedia.org/wiki/SAS_%28software%29) in JavaScript: https://github.com/dumbmatter/sas7bdat-js I know, it's a horrifying concept :)
That's a fair point. I was curious if Python would have the same function-in-loop issue that we try to protect against in JS, and it does... nums = [] for i in range(0, 11): nums.append(lambda j: i + j) print(nums[0](2)) # prints 12 instead of 2 My best **guess** is that Python folks are less likely to use lambdas and closures than JS folks.
Does the script back up itself?
No, it would not be a problem. The main issue new users (or users who mostly post from their own material) is it's not totally on topic (e.g. _5 Reasons to Adopt Functional Programming in your Code_, and all the examples are written in Haskell) or new information (e.g. _Why I Switched to Sublime Text and So Should You_).
Thanks. Cool!
By Ajax I assume you mean HTTP requests. Most use cases I would urge you to see if you even need a library, why not just use vanilla js? http://stackoverflow.com/questions/247483/http-get-request-in-javascript
&gt; the major reason it's a bad practice is because you'll cause the interpreter to create multiple function instances. I've honestly never heard anyone cite that as a reason, much less the major reason. The [JSHint options](http://jshint.com/docs/options/#loopfunc) explicitly talk about the unintuitive (buggy) behavior of closures and function scope in a loop. And the same from [ESLint](http://eslint.org/docs/rules/no-loop-func). "This error is raised to highlight a piece of code that may not work as you expect." The performance of creating multiple functions has never been the concern of this particular rule.
[removed]
Mithril?
Sorry didn't know I was so fucking vague. I meant that you type something, and it goes through a specific process. So you got like a sentence. The sentence will be translated to hex. The sentence that's hex now will be translated to another code. And that will happen 5 times. I would like a script of this sort so I can bring up solutions to puzzles. EDIT: didn't know u can't even understand a bit. Retard. KappaRage
Prototypal inheritance is more powerful for the very simple reason of easy multiple inheritance - concatenate your prototypes and generate all your inherited objects with `Object.create`, done. Now try doing it with `class` ;) 
Any suggestion how to improve it?
Yeah. I get no errors, but I also get no output either. 
https://github.com/github/fetch This is the perfect solution.
This is the correct way to approach the problem.
So ES6 helps people who don't know JavaScript write better JavaScript. Awesome. But for people who know JavaScript, what are the main selling points of es6? More built in functions?
Looks awesome. I'd love to see a followup post on how to compose / sequence actions using zip and combine 
I use it too 
I forced myself to in a few projects in the early days of ES6, but at the end of the day the standard error class works best for me. The biggest con is serialization. An error is just an object, so you'll always end up with a stringified object that you'll have to parse back into an error. Instead, I'd rather pass a string that contains a very specific error message &amp; then parse that into a new error message object. 1 less thing. From a data point of view, the only reason for error classes is to solidify the 1-to-many relationship between classes and messages. For example `InvalidCredentialsError` might have a `bad password` or `bad username` error message. I get the value of grouping errors, i really do, but I have found it easier to do something like a standard error &amp; then have a message like `Invalid Credentials: Bad Password`. It also forces you to be more exact on your unit tests-- listening for a specific message instead of a type. Call it magic stringy, but it's a lot cleaner IMO.
I look for quality ASCII art in the README.
This is exactly what I was looking for! Thanks!
That'll work. Thanks!
fetch
because they are jealous that JS is becoming so popular and their main language is not. They feel like their values are getting depreciated while js devs are demanded more than ever To downvoters: the most used language at Google and Facebook is JS, the two best software companies at the moment. Source: I have friends at both companies.
Const and let are FAR better than var. Don't think of it as two ways to do things. Just never use var. Ever. There's no reason to. Put it in your linter. Done.
477 stars, I clearly spend too much time on Reddit and HN
Yes, that's what I was getting at, JS arrays are more like a collection class in another language, e.g. ArrayList in Java. So tradeoffs for time vs space. And of course you can do a['foo'] = 12; which is just ... wat?
&gt;And of course you can do a['foo'] = 12; which is just ... wat? I think that's basically a good thing. Because arrays are "just objects", we can add things to their prototype, for shimming etc.
I've tried many, many commands from loads of examples and none of them appear to work. Do you have a working example I can try on my setup?
That....didn't make much sense to me. How would CORS prevent PhantomJS from accessing any source, as it works happily on a standard website. Also how would that tie in with PhantomJS which (for me at least) is headless.
AJAX really is a terrible name. Asynchronous Javascript And XML. Is the usage of XMLHttpRequests to request actual XML greater or less than one percent do you think?
https://github.com/mzabriskie/axios seems trendy
&gt; Where? Check the links in my OP, YCombinator, SE, and others. 
&gt; Still, your codebase has grown to the point to where JavaScript's limitations (lack of typing, weak support for objects, nonexistent support for namespacing and concurrency) have caused problems that you've had to mitigate. (And if you spend some time thinking about each of these limitations you can probably identify how you've worked around them.) Thanks! It just seems like even if I were to move to a different language, I would still need to implement those types of systems though. For example, if I were to switch to GoLang, I would need to utilize channels and GoRoutines within my code. If I were to move to elixir, I would still need to utilize their processes `spawn` feature. It just seems like wherever I have attempted to move to, It's still not solving the multiple process issue. Their respective languages might be more powerful, but it's not worth the trade off, I believe anyways. But I guess, this is only true in my case since I have invested so much time already in JavaScript? 
Using it makes sense as it's gonna be the standard way within a year or two
https://jsfiddle.net/n4a661b2/1/ You were calling the function, which immediately set the color, instead of returning a function to be called that would set the color.
When you do `f_test(i)`, you're calling the `f_test` function (which returns `undefined`). `addEventListener` expects to be passed a function, but happily ignores the `undefined` that `f_test(i)` returned.
1) Star it if it seems like something I'll maybe use later for something. 2) Star it if it's a hilarious joke (i.e. [volkswagen](https://github.com/auchenberg/volkswagen))
And this happens with most popular languages. PHP has tons of newbie coders, so people treat it like its worthless, and will point to horrible codebase as an example of why the language is terrible... It's a self fulfilling prophecy for them. I've just started walking away from a conversation about programming languages the second it steers away from "languages are tools" to "X is a bad language"
Wow, couldn't agree more with your points there. Really surprised you didn't receive that much backlash from YCombinator. 
Personally I hate it. Objects with integer keys and different iteration semantics? Ugh. I can wrap an array in another object if I need to make a complex class...
Haters gonna hate. Ainters gonna aint.
Yes, you have to solve the same kinds of problems in any environment (OS + language + framework/platform/toolkit). Each has different tradeoffs, and there's a difference in the help you'll get from each environment; and the software architecture you end up with is going to be influenced by that environment. So for scaling JavaScript you end up with a bunch of Node/Redis instances, whereas if you were using Clojure or Erlang you'd find that the language provides quite a bit of direct support for scaling (parallelism). Starting from a clean slate, it's valuable to consider your options and choose a toolchain that will help reduce your costs. But you already have a considerable investment in your existing solution, and the "not worth the tradeoff" question, as you surmise, is about whether the (possible) gain of a rewrite in a different language is worth the cost -- the investment of time in rewriting, during which you'd essentially not be creating new features. Usually, rewrites are only worth it when the pain (cost) of sticking with an existing solution is clearly so high that adopting a new language/OS/database/etc. is going to be worthwhile. Ultimately, if you aren't finding yourself highly limited or restricted by the choices you've made with JavaScript+Node+Redis, then it's working for you and probably not worth a rewrite. It's worthwhile though to try out other languages/tools enough that you get a feel for them and where they provide an advantage/benefit. 
Down with the aristocracy! Viva JS!
Speaking as someone who does not care for Javascript, let me give you three points off the top of my head as to why I have a knee-jerk negative reaction to it. The first is a problem with JS itself, the other two are more contextual. 1. **Prototypical inheritance.** It's a perfectly valid way to do inheritance. If JS had been written 30 years earlier, maybe it would be the dominant form of class hierarchies. As it stands, prototypical inheritance is *weird and different*. Have a look at this [random index](http://www.tiobe.com/tiobe_index) of the top 20 most used programming languages. Go ahead and count how many of those use prototypes by default. It's a major roadblock when trying to shift back and forth between writing JS and basically any other language. 2. **Browsers**. Fuck Internet Explorer. And Safari. And Firefox. And Chrome. Both individually and collectively for a multitude of reasons. I'm sure I'd say fuck node's JS engine if I ever interacted with it at all. It's like someone looked at the madness of C compilers in the 80s and found the whole situation compelling. I found out yesterday that only Chrome and Firefox *have fucking stack traces in their fucking exceptions*. Then I found out that stack traces in exceptions aren't even a feature in any version of EMCAscript! Wildly, horribly, unforgivably frustrating. Fuck. 3. **User Interfaces**. I really, really, really don't like writing user interfaces. The only thing I ever use Javascript for (and what some might argue is its raison d'etre) is writing user interfaces. They are -- by nature -- event based and non-linear code is always finicky. Just do not care for it at all. tl;dr; Javascript has some technical decisions that I don't agree with, and it also sits at a nexus of things that I dislike in web development and programming in general. 
I mean Python gets an absolutely minuscule of hate compared to JS. (Relatively speaking, 1e20 * 1e-15 is still 1e5), despite it being more popular (not by a huge amount, but TIOBE and similar put it a decent percentage ahead of JS). JS gets the job done, but it really is not a good language.
JavaScript is a badly designed language, but it still gets the job done. So if it working for you absolutely do not even consider switching languages half way through a project. You can get JS to do most tasks (except for things that are REALLY performance dependent, then you need AT LEAST Java / C# / Haskell / OCaml etc., if not C++ / C etc.), it just might be more painful to do so and it might take longer and have a few more bugs, but it still can absolutely be done. Also if you know what you are doing you can avoid running into a substantial percentage of JS's faults.
Fair enough, but honestly.. When I am developing my game I never, ever think about these things. I have written far too much code in JS now and maybe I am oblivious, but what cycles through the mind is: for loops, arrays, objects, if, elses, switches, functions, arrow functions, and then promises for interacting with redis/mysql.. It's like a subconscious thing, it's hard to explain. User Interfaces, the entire "Prototype Inheritance" thing, just don't ever come up. But I do agree with your point about the browser dependency issues. Luckily for me, I am using Electron where I never have to worry about that. But it definitely is an issue I can agree with you on.
Block level scoping is available by using the "let" keyword instead of "var". Use strict mode and there's no more implicit global variables by accident.
"They hate us because they ain't us" lol
&gt; Fair enough, but honestly.. When I am developing my game I never, ever think about these things. Fair enough, but honestly..most people using Node/JS aren't developing games. OPs points are very valid for what JS/Node are most commonly used for. Just because an issue isn't an issue for you, doesn't mean it's not an issue.
&gt; Just because an issue isn't an issue for you, doesn't mean it's not an issue. Fair enough, but honestly..Prototypal inheritance can be viewed as a non-issue though. That's subjective. A large majority of people actually view it as a positive. You are NOT forced or required to use it when creating a game / app. 
&gt; What's most surprising is that how you feel about a language is determined by fashion and other people's opinion. I still love JavaScript though. I'm just curious where all the hatred stems from.
Because people are using it in situations where it is not the best tool for the job and these are quite easy to bash. There are however many great applications of node + js, they just don't get highlighted by the detractors.
[suitcss](https://github.com/suitcss/suit/blob/master/doc/naming-conventions.md) naming conventions are pretty good.
&gt; For a language that was essentially designed in 10 days, that is utterly amazing. Every other modern language in popular use took years to design. 20 years later, JavaScript has block scoping, and it's not a default. It took 20 years to design, spec, and implement this feature, and it must be explicitly used.
Ridiculous.
amortized O(1) copy ;D.. however, given that this is JS, is that even really necessary?
&gt; Fuck ... Chrome &gt; I'm sure I'd say fuck node's JS engine [They are one and the same](https://developers.google.com/v8/). &gt; Then I found out that stack traces in exceptions aren't even a feature in any version of EMCAscript! Wildly, horribly, unforgivably frustrating. Fuck. It's not really up to a language specification to dictate how runtimes work (See, for example, the C# spec), though TC39 is sort of smashing runtime behavior and language specification together because they're insane, so I'm not really sure what to say about this anymore.
Most people began by learning imperative or OO languages and fundamentals. To them, it is difficult to "understand" functional programming. I learnt to ignore the haters long ago, by silently judging them and their stupidity. The fact that I understand the principles and concepts behind what makes JS, and that I can make full, complex applications with it, is enough for me. Javascript ROCKS. EDIT: Also, tell them that if they hate JS they should stop using the internet. Without JS the internet would not have evolved into what we have today.
Yeah literally. It makes sense that languages with the most users will have some people who don't like it. Just think if you've ever heard a negative thing about: C, C++, C#, Java, or Ruby.. a yep.
Javascript is loosely typed for a reason. If you want to program Javascript but also want strong typing, try [TypeScript](https://www.typescriptlang.org/).
Well that is more fair. But I would still say generally people don't criticize Python as intensely and as frequently as they do JS. Usually when people discuss JS at least some point someone will shit on it, but with Python it seems more occasional.
It becomes very useful when working with promises that need to "return" early. Because you can't really stop a promise chain, the only way to prevent it from continuing to the next promise is to throw an error. This is where custom errors become useful. let x = getRecords() .then(res =&gt; { if (res.done) { throw new CustomError(); } }) .then(res =&gt; { // do something else with res }) .catch(err =&gt; { if (err instanceof CustomError) { // handle gracefully } }); You can't return from the first promise because it will just proceed to the second. And you could always throw an error with a custom error number / message, but I find this to be the most clean solution. 
BestUsernameLeft in his comment above demonstrates one reason for the hate: ignorance of JavaScript's capabilities. For example, he says that lack of typing is a limitation. It is and it isn't. Its an advantage because once you've got your code written correctly and if you are using good identifiers, the code is cleaner because it has less clutter in terms of types. It does make it harder to code in a way because you need lots of unit tests etc. or more debugging to catch typos and other errors that static type checking would catch for you. Another thing, ES6 has been around for quite awhile now, and it has great support for objects and classes. As far as namespacing: the way this is handled with modules in Node is superior to many platforms. For example, Java code with long chains of namespaces in giant frameworks is outdated compared to nicely decoupled modules and imports. One thing most Node developers aren't aware of is that in fact you have been able to use threads in Node for quite awhile as well via the `webworker-threads` module. Yes, you have to pass messages in and out, but that also eliminates a ton of software engineering problems and in most cases is a better solution than locking and shared memory. Also, you _do_ have built-in concurrency via cluster (again with message passing). If you need things like locks then there are plenty of modules for that such as `lock-lock`. Cases where its really necessary to have multiple threads or processes working on shared state at the exact time or where you have too much data to pass back and forth are not that frequent really.
ES6 has been around for awhile and classes work great. Especially if you do them like this: class Test extends EventEmitter { constructor(a) { super(a); } foo = (x, y) =&gt; { this.data = x * y; } } Yes, Internet Explorer is a piece of shit, I agree with you there. As far as avoiding user interface programming in JavaScript, there are more than 270,000 modules on `npm` now, so quiet a few people must have been doing things other than writing UIs with it.
I don't mind it because it's consistent (except for the numeric keys and iteration) with the rest of the language. The one other thing I *do* wish they'd make inconsistent about it is that length should not be a property. It should be something you can set on any object, but it should be a special case. The reason is that many libraries detect "array-like" by checking for a length property (e.g. underscore), and this can cause subtle bugs if you use objects as hash tables for arbitrary string keys.
I use camelCase for ids and hypens for class-names. Makes it clear what something is.
Java is so damn verbose and takes so much code to get anything done there are took like Spring that simplify writing it. From what I've seen, the JavaScript tools do a similar thing ... they make using the language easier.
usually i star something that i want to use/try later but don't want to forget about it. or in the event i use it right away and like it, i will star it.
Under what scenarios do you have to serialize an error and then deserialize it? I can't think of a single one. Second, the reason magic strings are bad are because (a) if the string changes you have to change it in 2 places or (b) if the string is dynamic or (c) if you have to support multiple languages or (d) if you need to use it in multiple places or (e) do I need to keep going?
Here is good article on the subject and more: https://medium.com/javascript-scene/common-misconceptions-about-inheritance-in-javascript-d5d9bab29b0a#.nn2fvtsb0
They hate us cause they anus.
This is a silly reason. I have EXTENSIVE knowledge of JS and I'd prefer never to touch it. The fact that I have to, because of its blessed position in the most ubiquitous software platform in history, is a more likely source of angst.
&gt;JS gets the job done, but it really is not a good language. It's a fine language. It has its warts, but it also has some real beauty. And if you want meta-programming, it doesn't get much easier than in JS.
&gt; Prototypical inheritance Besides the fact that prototypical inheritance is actually the more flexible model, this is pretty much irrelevant in modern JS. If you don't want to deal with prototypes, just use ES6 classes.
JavaScript is cool yo. Quit hating hater.
It is at least worth pointing out that *smart* companies don't hire based on specific language experience. If I'm worried that a candidate won't be able to pick up a new language quickly, I'm going to have other reservations about hiring them.
Some seriously huge warts, and the metaprogramming isn't bad, but it is worse than LISP's and no better than Pythons. Also Python generally seems to be a much more beautiful language, and Haskell even more so than Python.
This is like arguing that French is better than Spanish. Who cares. It's what you write with it that counts and js has proven itself rather useful and flexible over the past decade.
I would love to see some really good docs/tutorials/discussion on effectively abstracting canvas for use in gaming. My sense is that you have all the primitives required to do some really awesome stuff with canvas if you do it well. One issue I would like to see foremost would be how to maintain canvas performance when interacting with slow javascript. ie. batching updates, making canvas do the heavy lifting when possible, generally knowing what's fast and what isn't.
There should not be a specification for how runtimes should work. As long as the runtime accepts input and outputs the output in the language specification, then it's working exactly as required. If you specify how runtimes need to work, then there's no longer the possibility of having multiple runtimes, and there is no creative freedom to do things like, e.g., implementing a faster, but non-standard, algorithm for something.
GIL
There's a lot of hate for JavaScript because it's a shitty LISP dressed in C's clothing that people are forced to use due to momentum.
Problem with that is that if index is 0.
I am interested too!
R/programming is the worst I have seen
Yes, but static Java/C# types != static ML-style types. If you're not leaning on class abstractions, Java style static typing is pretty useless for a functional paradigm. Because functions are small and we avoid random mutation, it's just a lot harder to pass an argument incorrectly and a lot easier to infer what the implied type of a function is. Type annotations would provide great self documentation and would make it easier to dive back into a codebase, but they definitely aren't needed for functional dynamic programming. Errors might still happen, but they are significantly fewer than a crazy dynamic duck typing OO paradigm.
There are two kinds of languages. Languages people hate on, and there are languages people dont use.
I loved jQuery, then I loved React for a moment, now I love Mithril. Vue 2nd I don't think the JS community is going to form a single favorite honestly. There's too many frameworks and libraries that work their magic for each case. I don't know what's the deal with React, the patent literally scares me (in combination with all this hype).
It's over hyped. Its type system is crap. []+[] = "" {} + [] = 0 []-{} = NaN []+{} = "[object Object]" {a:5}+[6] = 6 "1" == true = true require('left-pad') Honestly, I don't really hate JS, but it has it's shitty stuff and shitty people 
Well, "worse than LISP's" is kind of like saying "colder than the Sun". I disagree that Python's metaprogramming is better, but to be fair, I have less experience with it than JS. The thing that I really love about JS's metaprogramming is that for the most part, it's not a special case. Prototypical inheritance means that you're *already* building your "classes" by hand, just by building up objects. A lot of metaprogramming power comes in when you realize you don't have to stick to the "normal" idioms when building up those objects, and you can write helpers that simplify the process. Again, there's nothing *special* about this. The other point I'd raise about Python vs JS is that anonymous functions lend themselves very well to writing higher order functions, which are another useful avenue for metaprogramming. &gt; Also Python generally seems to be a much more beautiful language, and Haskell even more so than Python. I never claimed it was the *most* beautiful language. And "less beautiful than Haskell", well again, colder than the Sun. What I like about JS is where it strikes a balance between beauty and getting shit done.
`undefined` and `{}` are coerced to `NaN` for numbers even though one is falsey (and similar to `null`) while the other is truthy (and similar to `[]`). Testing in the Chrome console, if you create an object with a toString/valueOf that returns `''` it will also coerce to `0`: var x = []; x.toString = () =&gt; ''; +x &gt; 0
thats exactly who i wanted to quote but i fucked it up.
RemindMe! 6 Months
I will be messaging you on [**2016-11-15 07:48:57 UTC**](http://www.wolframalpha.com/input/?i=2016-11-15 07:48:57 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/javascript/comments/4jeol3/i_intend_to_create_an_online_course_on_making/d364bqw) [**7 OTHERS CLICKED THIS LINK**](http://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/javascript/comments/4jeol3/i_intend_to_create_an_online_course_on_making/d364bqw]%0A%0ARemindMe! 6 Months) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! d364c50) _____ |[^([FAQs])](http://www.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^([Custom])](http://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^([Your Reminders])](http://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^([Feedback])](http://www.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^([Code])](https://github.com/SIlver--/remindmebot-reddit) |-|-|-|-|-|
&gt; 0.05000000000000003 Not just a js problem though: http://0.30000000000000004.com/
&gt;Isn't that a pyramid of function calls? Yes, but I'm not sure what your point is. Function calls in modern JS engines are pretty cheap.
Bloop! Hey! I'm a time traveling bot from the future! It is already the future in the future, and to save time so I don't have to do it later, here's your reminder now! 
&gt; And to be honest, every time I see that type of negativity it really hurts. Hurts? You read some discussions on the internet about a programming language and you are getting emotional about it? I think there are some personality related issues at play here. In my opinion this is comparable to being hurt that there were no yellow m&amp;ms left in the jar. 
HN is just as hate filled, but it comes out as more dismissive and condescending vs /r/programming's anger and vitriol.
This. Consider: if (index != null &amp;&amp; index &gt; -1) { Typically strict equality/inequality is better, but for null-checks this guards you against both null and undefined (undefined being the only value that can coerce to null).
I will say that JS can be much more technical than go can be. Go is stupid simple, and that makes it great for large teams or "lightly maintained" software, and JS really shines with strict tooling or smaller teams. But they both are wonderful in their areas.
Having written in languages from asm to c/c++ i like the so called shortcomings that are attributed to Javascript, though years ago when each browser would interpret it differently i had my troubles with it. Evergreen browsers and instant npm polyfills solve it today. I do like the flexibility that comes with it, i like prototypes more than classes and interfaces, *i enjoy writing without types* and it doesn't lead to the troubles that some people say are unavoidable. I love how rapidly i can set up prototypes or ideas. The community is large and helpful. Everything seems to constantly evolve, which puts some people off but i find it exciting. These are among the reasons i enjoy my work right now, probably more than i ever have with straighjacket-throwing you into the pit of success-style languages.
IMHO it doesn't matter how many people complain. Obviously, your technology stack gets its job done. And what is more important than the language itself is the community around it and the tools/libraries they provide. JavaScript has a great community and a bright future!
Typical projects to learn are to-do lists or a blogging engine. (the advantage of the blogging thing is that you can wrote blog articles while you develop new features.)
Game of Life is actually a really good case for FRP. You've got state transitions defined as pure functions of state, you have events coming in from the UI, and maybe you've got to keep track of history...
This is the most important comment in this thread, wish I could upvote more. If it solves the problem you're trying to solve, then it was the right tool. That said, Javascript really does feel like a monoculture slowly reinventing a lot of things that were solved decades ago in other ecosystems, often making the same mistakes all over again. When people criticise Javascript, they are often criticising limitations that their own platform of choice has solved in a better way. It's important to branch out and learn other languages as well instead of just sticking with "Good enough". If JS solves your problem and works for you, then keep using it, but play around with other tools as well (even if only to learn different ways of solving things that you can potentially apply back to your main language, JS or not). 
Well, if it's just compatability with newer browsers then it all comes down to how much JS there is on the site and if it's using any plugins (java, flash, activeX and so on). If there is a lot of JS then rewriting that for modern browsers can be a PITA, but thankfully most older sites did not usually have that much logic in JS, it was more usual to have that logic server-side (JS used to be used mostly for form validation and so on those days). So basically walk through the code, checking MDN for deprecated/obsolete practices and fixing errors/bugs as you go. Or do a full rewrite, which can actually be faster sometimes.
Those are issues related to the quality of moderation where you are posting. Stackoverflow is a great community for that kind of thing. Knowing *why* the sentiment exists is not going to solve that problem for you, is it? This post seems to be a support group type post where OP wants validation from his peers. 
No, jQuery was so widely used because back in the day it was useful on basically any site that had any client-side logic at all. React is not useful for very, very many sites simply because most small/medium business sites simply don't need a client-side MVC or framework.
It's nice that you've never had to work with a changing API, but the real world doesn't really work that way. Also, clients have extra requests as the project evolves. That's always going to happen. Or do you just stick to waterfall? 
Sometimes I start watching repositories that I'd like to take part in but soon enough I'm too flooded by the activity and leave. Aren't you facing the same issue? How are you dealing with it?
Haha nice! I'll think about it next time I have to write some documentation :P
That's nice, thank you very much for sharing!
And you never star a project that you don't plan to use? It happens that I star repositories in other languages than the one I am interested by because I think they're bringing something interesting/useful. Thanks for reminding that awesome volkswagen project :P
I don't agree that it's as black and white as this. Refactoring HTTP requests logic will end up a nightmare, as I stated before. And using superagent, which is specifically made for this purpose, to begin with, has little to no downside. &gt; Building something based on possible future requirements will only land you in trouble. Yes, it can. But keeping in mind the realities of software development as you pick your tools is also important. What lands you in trouble is overengineering because you got caught up in possible future requirements. `npm install superagent` is not overengineering anything. See, this is the problem. I agree with you in theory, but like many people in this field, you don't leave any room for intepretation. Any rule or design philosophy has to be adhered to like it's the fucking bible. 
I don't see any real hatred in the SO post you linked. Reddit is a nice accessible place to talk about programming, but I would hardly considering it a good representation of the programming community. Let's just say /r/programming is going to inherit some of the flaws of Reddit in general. I guess I was downvoted for being too terse, but my point is that there might not be "so much hatred for JS" at all. You're being exposed to a vocal minority, in platforms that promote that sort of discussion. In addition, you may be mistaking "hatred" for "emotional discussion about technologies in a field that people clearly have a passion for". 
Its funny that you use mixins as an example. Because as of a while ago (not sure when I last heavily worked on JS, probably best part of a year), multiple inheritance was much easier in Python than in JavaScript. And really the whole single line restriction for Python lambdas is not that big of a deal, for big multiline functions just name it real quick. It's annoying sure, but not that big of a deal.
[3kb library with react API](https://github.com/developit/preact) &gt; most small/medium business sites simply don't need a client-side MVC or framework Very disputable.
ahh, im not sure what that is, but i suspected maybe there had to be something else going on. i will look into it!
As this is IE5/IE6 site I believe it is not an SPA application :) So it probably comes as several subpages, right? Then just put modern build tools like webpack, sass, etc and just fix site by rewriting pages, one by one. Keep old ones connected to old js,css,html and new one using modern tools. I'd propose to not convert anything, instead just recreate page by page from blank document so you will use modern css techniques and refactor code on the fly as well.
Sorry for not sounding serious, but this will help you: https://www.youtube.com/watch?v=qEqdoMdCxdY
JavaScript seems to be getting a lot of hate at the moment since it's going through a huge transition, especially in the front end world. The technical barrier for entry has got a lot of higher but for a good reason - a load of jquery in a single file that just kind of gets stuff done wasn't going to cut it for modern web apps. A lot of people don't seem willing to put the work in to keep up, so they hate on it instead.
As others have mentioned, it could be a huge task to update the existing code. I'd imagine quite a bit of it comes from a server side language, as js was a client-side feature for a long time. In IE5-6 era, the average resources for a PC were nowhere near today's specs, so you had to be careful what JS you ran and the resources the scripting used. The landscape of JS has also changed dramatically since (I'm assuming) this program was written. Honestly, if it isn't over 1500 lines of code I'd probably just rewrite from "scratch". Good code isn't going to change too much in the sense of business logic. I'd make a skeleton and go from there. You can copy/paste sections of the old code into new.. you can streamline changes incompatible parts of the code by moving a such a part to a function and replacing existing references/instances of outdated code. It really just depends on how comfortable you are with programming and how much you're willing to work on this for free.
Tips? Abandon it, it will be easier to start again from scratch.
It should be scrapped and redone completely. You can't build a house on a broken foundation. &gt;So before I begin this endless journey (doing it on my own time) **DO NOT** do this "on your own time." If the company wants it done, do it on company time. If no one is asking for it, or no one is authorizing the project, **do not** spend your personal time on it.
I did start with that, I used a Polyfill to add IE6 only JS functions which reduced the number of errors, I've also rewrote some of the broken functions, however there's endless broken things that needs to be fixed, I thought maybe someone would have ideas how to automate some of the fixing.
Where I work, people complain about python more than JS. Mainly because it's white space delimited.
No no no no no non no. FSS listen to the guy above. You will accomplish nothing, get paid nothing and end up being pissed off. If your company doesnt want to pay to have their shit upgraded THEN DONT UPGRADE IT. There is no easy or fast way, you arent talking about something simple here and there is no way to half ass it which is what you are contemplating. Either gain the skills to do it right and make a plan to show why or give up and move on, dont dwell on it and dont waste your own time. Sharpening skills is one thing, but based on your comments I would say you simply do not have the skillset or know how to accomplish what you want. Then you end up with something build badly that doesn't meet the needs of the company, then they dont use it and you get to feel like shit. Fuck all that noise, if they want to pay you (properly) then do it right, otherwise just do your job till you can find a better environment.
ok
&gt; fixing this portal as it would speed things up and make my life much easier Make this the company's problem. If this portal is slowing you down, then in your timesheet or progress reports or project estimates or whatever, include the amount of time you waste dealing with the portal. If they question it, just tell them honestly "well, every time I have to do X, I have to go through the portal and it takes a minimum 15 minutes assuming that it doesn't crash my browser. And I do X 4 times a day." If enough people do this, they might start getting the hint. Then they'll replace it with another monstrosity that *also* doesn't work, but at least someone gave the appearance of doing something. Also what /u/mallcart said.
&gt;you won't need any background in design or programming or anything. This same garbage post was made in /r/html a few days ago. 
&gt;built many years ago for Internet Explorer 6 (Document mode 5) More proof that one should always target web standards and not browsers. Those who let Microsoft lead them around by the nose, both years ago and today, are now paying the price.
When I said "back in the day it was useful on basically any site" I meant that it used to be that interacting with the dom in a crossbrowser compatible way was a real pain in the ass. Nowadays I think that most small/low-interaction sites would be better just using normal js, without any framework. So basically I'm saying that in many situations you don't need either.
Alright, with this I agree. Still, jquery gets rid of lots of inconsistencies even nowadays. But using no DOM library has become accepted, indeed. The decision that is left is whether one wished to bring declarative UI handling to the app. In that view libraries like react and vue can still be a good idea even for websites with little client side logic.
The first bit is a good idea, the second bit not so much. Learning about how to organize a game in an object oriented way, state machines etc would be more than enough. 
It must be nice to be able to make blind assumptions about someone's experience based on two sentences. Or maybe we just have a different interpretation on what the word **reasonable** means. Managing change is just as important as which tools you pick, more important in some respects. Understanding the requirements is a key aspect of this, no matter what methodology you adhere to. You think that just because you adhere to an "Agile" methodology that a client request can't call for a major code overhaul? That's foolish! You said it yourself in a different response: &gt; What lands you in trouble is overengineering because you got caught up in possible future requirements. It sounds like over engineering is exactly what your calling for in order to bee able to respond to any potential client change request.
You could prolly take a look at the pixijs source code to see what they do. IIRC from when I've dove into that code to debug, they keep a list of all sprites/textures currently displayed (visible) and then update them all every frame (this is probably tied to requestAnimationFrame). I've found pixijs to be very performant. On top of it however since my game has a very large map I had to write code to render the background into large singular textures and then on top of that write an algorithm to effectively chunk the map into large squares that get hidden/shown based on where the camera is.
So good advice that has helped me reduce stress about programming: You are not your code. Extending this, you are definitely not other people's code. Even Brendan Eich says there a problems with JS, so I wouldn't worry about it too much. I hope that helps. 
RemindMe! 1 month
Including https://modernizr.com/ at the start of every page should fix some errors right off the bat.
Duuude why did you summon me I was literally this close to a perfect speedrun of Ocarina of Time, fuck man, now I gotta start over, fuck you and your dumb reminder
RemindMe! 6 Months
&gt; this is on one of the many development environments, But you're doing production work there? You're running production in development?
Lots of backend devs hate node because of the weird code stucture, because it is weird and a lot of it doesn't make sense to them. Others claim that larger node projects are not optimal in terms of speed, while others claim that because it is a newer tech, there will be more newer devs using it meaning bad code. However none of it really matters if your code works optimally and you can get the work done efficiently. So don't listen to anyone...if it works, it works. 
Mainly it is untested in many situations and the language itself is bizarre compared to other backend languages.
I got your request! I'll remind you about "removing Buzz Lightyear toy from anus" in 12 hours.
I prefer index !== -1 Your index will never be a lower value
Lodash or underscore both have deep equal functions (maybe jquery too? ) if you want to test it out. 
Alternatively you could create a key for your objects that you can specify when you compare. 
https://en.wikipedia.org/wiki/Betteridge%27s_law_of_headlines
Cool! Desperately needs a demo though; put something up on github pages!
Please don't do this. Don't try to write Java in JavaScript. 
Dough :). Guilty as charged. And I even knew about that law beforehand (had read about it in John Gruber). I think I was just trying to make the title a bit less controversial by putting it in a question form. That should teach me.
This post is so stupid it hurts my brain. Classes are incredibly useful. There are a lot of stupid JavaScript haters, but don't pretend like some complaints aren't valid.
I only follow a few (aside from my own ofc) - sure sometimes if there's a new issue that's actively discussed you can get "spammed" a bit - but if it's a project i'm really interested in development wise i'd want to read the latest discussion surrounding the issue anyway. So watch conservatively, I guess? :V
`[]` by itself is falsy, not truthy
When trying to come up with side project ideas, I always look at what is bugging me in my life. What is a problem I have and could be solved with an algorithm or a clever app? There's really no easier way to spark the inspiration.
Ah, the toString explains the `[]` behavior perfectly. This is emergent rather than a specific choice.
Incorrect.
Looks very interesting. They should add more demos.
I like the idea, but having talked to a lot of people who use gaming to learn programming, the gap isn't in the programming and design, it's in all the other stuff that you need to know to build a website. I know people who learned programming through Khan, and then didn't know how to actually use it - getting a dev server up and running, choosing an editor, knowing what an IDE actually does, deploying to a production server, managing domains, etc. The gap between these beginner tutorials and how to *actually* apply them is pretty real. Maybe a different problem than you're trying to solve, but I assume you'll need to include some of that. 
I beg to differ with the "less memory" comment. Compared to a compiled language like C or Rust, even one that comes with GC like Go and D, javascript is a PIG memory wise. In many cases this is a non-problem, but please don't deny it.
So for the most part at my company (I work at a digital agency) when we have formal code reviews, they happen in the afternoon with some sort of alcohol. It doesn't necessarily relieve the boredom of code reviews, but it does make things a little more bearable. I think they could be more "fun" if the pull requests you're reviewing are smaller. On the projects that don't have formal reviews, we review pull requests on github. That keeps them from being too time consuming. A review is required before you can merge the code, and this way, you get a variety of people reviewing your code. Management also accepts this as part of the set of tasks any one developer has to handle every day, so they're not too annoyed about how having time to review takes away from writing new code. 
If it ain't broke, don't fix it. That said, here are my two complaints with JS 1) comparison. This is covered extensively in "the good parts". 2) callbacks. they suck. Promises. they suck slightly less. await/async still sucks though somewhat less still. I understand the intent to prevent having to context switch to the OS when the thread of execution changes. However there have been great techniques for that from since before JS was invented. So callbacks are necessary for UI ( after say, a button click) when there is no previous stream of execution. However every time, I see a callback used to continue a stream of execution (say after a file read, an http get, etc), I realize that a design mistake was made. Continuations would have been much much much better. 
That works well for `null`, but recall that `typeof(NaN) === "number"` so this is not a catch all. ES6 introduces [Number.isFinite](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite) which seems to fit all of the "is it a number" use cases.
&gt; any tips Rewrite completely.
That and it's only slightly more visually appealing than perl 
actually i find ES6 to be pretty "beautiful", but that's a pretty subjective thing. Perl is such a mess to read because of the stupid number of operators.
Sure thing: http://pastebin.com/hUrppCfn It's based on this: http://dean.edwards.name/moz-behaviors/ Which has got some updates since 2005. Keep in mind that it was written in 2005 and that the original author meant for this to act as an "IE Emulator for Firefox", so you might find stuff like: // For sniffers // ------------ navigator.__defineGetter__("appName", function() { return "Microsoft Internet Explorer"; }); var $appVersion = navigator.appVersion; navigator.__defineGetter__("appVersion", function() { return $appVersion + " (compatible; MSIE 6.0;)"; }); var $userAgent = navigator.userAgent; navigator.__defineGetter__("userAgent", function() { return $userAgent + " (compatible; MSIE 6.0;)"; }); But overall its quite decent, covers a lot of the IE6 only functions.
Is JavaScript the new Java? Is functional programming the new OOP? Is unidirectional the new MVC? I can go all day long
My assumption is based on intuition. It wouldn't be the first case it is wrong. It wouldn't be the first time that native browser implementation is slower than user implementation. It is a reasonable assumption though.
If you are looking for something relative simply to start, there is no project known to me on NPM that would allow to create data objects with picosecond proximity. This is very useful in modern HFT trading. I am going to do it myself if no one does, but if you are looking for open source ideas, thats one thats lacking in the market now and it is relatively simple to make.
Small libraries are great projects. It's particularly cool because there's a chance you can get other people using your code. But they also don't have to be super useful. They can be blue-sky experimental ideas too.
I cannot imagine this scaling in a large application though. This sounds good in theory. But in practise, it most often the case that the priority of the tasks is usually the same as the order in which they appear in the control flow. Therefore, you'd rarely set a priority of anything to 2 or more.
I have a feeling this is why IE is sluggish when visiting the site and Chrome seems fine -- this is a lot of processing to do, and Chrome is probably dying to a TypeError before it runs any of it :)
this references the data context from where the event is triggered. Your event selector is '.player' and the data context of the list element is 'player' from your foreach loop. I would recommend reading the meteor docs, they describe this much more thoroughly http://docs.meteor.com/#/full/eventmaps. Meteor is weird, you shouldnt feel bad about being confused by it. I would take a look at https://github.com/mattkrick/meatier if you want to solve the same problems in a less monolithic way.
This is sometimes needed, but in most cases these values compare the way you want. 1. `NaN` compared with anything is false. 2. `NEGATIVE_INFINITY` is less than all finites and `POSITIVE_INFINITY`. 3. `POSITIVE_INFINITY` is greater than all finites and `NEGATIVE_INFINITY`.
 &gt; [] == true false &gt; if([]){ console.log('truthy'); } else { console.log('falsey'); } truthy undefined Depends on how you test it.
Yes, code reviews can be fun. I recently joined a company where pull request reviews are required before merging into the master branch. The review culture had been put into place very recently by a new Engineering director. As someone who puts up a review, my peers are eager to point out typos, design questions, and even language shortcuts, which I've found to be most helpful. This is a chance to learn from my peers. As a reviewer, I get the chance to understand a new feature being added into the code base, as well as provide any technical insights I have found interested and would suggest. Another set of eyes on feature work is very helpful.
Came here to say this
"Fun" may not be the appropriate term, but I think _enjoyable_ might be a better fit. I, too, enjoy seeing how others approach problems, learning from their techniques, etc. It helps both of us grow to ask insightful questions, and the code will be better for it. It's enjoyable to me to ship good, well thought-out code. With that said, at a prior gig, code reviews weren't enjoyable at all, and certainly not fun. It was already a fairly toxic environment, and when code reviews were introduced, most of the other devs were very defensive about their code, and took it personally if you questioned their technique or offered advice. It quickly discourages devs from caring about shipping quality code, to simply rubber-stamping reviews so as not to create additional drama and ill-will. So the moral of the story is that the participating devs have to enjoy their work, be willing to grow, and be open to constructive criticism.
Canvas has 2 types of rendering contexts: 3D (webgl) and 2D, which is a browser-implemented abstraction that uses a mix of CPU and GPU rendering. WebGL will almost always beat the pants off the 2D drawing context, but using WebGL directly is more difficult. Libraries like pixi and phaser provide an abstraction layer that uses webgl when available. It's a whole lot easier than writing a webgl layer yourself (and in most cases, still easier than using the 2D canvas API directly.) In simple terms, bitmaps are fast, curved shapes and SVGs are slow - or at least more difficult to make fast.
The Question Stated : "Have a function ArrayAdditionI(arr) take the array of numbers stored in arr and return the string true if any combination of numbers in the array can be added up to equal the largest number in the array, otherwise return the string false. For example: if arr contains [4, 6, 23, 10, 1, 3] the output should return true because 4 + 6 + 10 + 3 = 23. The array will not be empty, will not contain all the same elements, and may contain negative numbers." I guess what i dont understand is how a hash table could be useful/better here than just using the nested loop.
Thanks for sharing. That's a really good jumping off point. 
I will just up vote in acknowledgment.
`parseInt(alpha) &gt; parseInt(bravo)` Will result in a NaN, and NaN is neither greater nor less than any value, so you’ll get false. 
thanks! yeah i actually just edited this post with my solution, and have been looking into this stuff a bit more. i have been using javascript for a while, but never once ran into this issue, so it was a learning experience. I thought i drank too much cough syrup
I suspect because it used to work, due to so-called hoisting.
Fuss? I don't see many people fussing over it. This is a distinction `let` has from `var`. `var` is hoisted: console.log(year); // undefined var year = 2016; console.log(year); // 2016 `var` is clearly kinda weird, but it's our only option without ES2015. We needed a way to describe (one of) the difference(s) between `let` and `var`, and that description was "temporal dead zone". In two years, the term "temporal dead zone" won't be used, just as people won't use `var`. (hopefully, anyways)
Well if you want loose typing make sure to be aware of its pitfalls. Perhaps you're expecting `index` to behave the same way as `array.length`? But without making sure that it will always be a number in the first place. I would change the whole logic to not compare index &gt; -1 altogether.
saying it was designed in 10 days is extremely disingenuous. Literally nobody is using the javascript that was "designed in 10 days", even the first time it was used (in netscape in 97) was 2 years and several revisions after it's "10 day" design period. Even the shitstack that is pre-ES3 went through multiple revisions in a live assembly with a standards body.
Typical script kiddie.
&gt; Lie #1 JavaScript is the most misunderstood programming language in the world. I don't think that's a lie per se, but I do think it's an outdated statement. I still remember Crockford's "Advanced JavaScript" video from 2006 (10 years ago now). At that time, the community was largely unaware of prototypes and closures. Whereas today, tutorials on prototypes and closures seem to pop up everywhere. &gt; Lie #2 Asynchronous programming is a key strength of JavaScript. I think that's a fair comment. The reason we use async programming so much in JavaScript *isn't* because it's simpler than synchronous programming (it isn't). Rather, we use async everywhere because we have no other choice, because JavaScript is strictly single-threaded, so if we do too much synchronous programming, then the GUI locks up. &gt; Lie #3 JavaScript is the most popular programming language in the world. The OP's point here is that "widely used" isn't quite the same thing as "popular". And to be fair, I think we all have to admit that JavaScript's success, more than anything else, is due to being in the right place at the right time. The Web exploded in popularity and usefulness, and JavaScript was the language of the Web.
A combination of things like hoisting, as well as old bizarro const behavior, and also error catching. Remember javascript is _not_ C, your example C does not /compile/ it isn't valid C, whereas printf(year) var year = 2015 is valid JS, and will run. In your example you use /let/, which has behaviour more in line with every other language that has ever existed. It's only a runtime error because JS is dynamic so by the time your code runs another piece of code may have defined /year/. For example: "use strict" foo(); log(year); let year = 2015; if foo is: function foo(){ log("foo"); } Your output should be something along the lines of: foo ReferenceError If instead you define function foo(){ log("foo"); year = 2014; } Then your output will be foo 2014 Note, this is not the TDZ effect, this is the more sane scoping you get with let. TDZ kicks in cases like: let foo; if (bar) foo = "derp"; log(foo) If bar is true the output is "derp" if it's false the output should be an exception, the exception is the TDZ. In C the output of equivalent code is undefined (or is it unspecified in this case?) behaviour. You get similarly odd behaviour with const: const x; if (bar) x=5; log(x) x = 6; log(x) Which is actually kind of valid in some very absurd ways, and depending on strictness vs. non-strictness the output can be: bar is truthy: 5, 5 bar is falsey: undefined, 6; or error //strict mode with TDZ A better way of thinking of the TDZ is as "not yet assigned to" -- it's only TDZ because those are the names you get when you get a lot of PL specialists in a room with too much coffee. 
Nice! That's a really usable encapsulation of the battery API. A couple of trivial comments: * computed functions are always readonly * you don't need to give `supported` an initialization function, you could just say `value: SUPPORTED`.
Yeah javascript has type coersion. Most of the operators can be used to created unexpected behavior, part of learning JS is learning how type coersion works (see [Spec](http://www.ecma-international.org/publications/standards/Ecma-262.htm)). You can check if null &gt; number and it will coerce null into a 0. Just one of those annoying things in the language that you have to deal with. It's super easy to avoid if you're aware of how the operators/coersion work.
I disagree that you should *never* use that, however I do think it's a poor idea in this case. At the very least, it should immediately be followed by a null check. In point of fact, it's never a boolean. Sometimes it's null and sometimes it's a number.
You understand arrays, right? Often indexed with an integer, like the following: var people = [{name: "Joe", age: 15}, {name: "Bob", age: 30}, {name: "Steve": age: 22}]; console.log(people[1].name); // will output "Bob" (I believe JavaScript will let you put other things as the index besides integers, like "people['some string']" but just hold off there for a moment; in many languages you can only do integers.) So far so good, right? So let's say you have thousands and thousands of people in that array, and you're looking specifically for Steve. What option do you have? You can loop over the array and test each object to see if its "name" attribute is set to "Steve". However, that's not very efficient. Maybe Steve is the 5000th object in that array, so you'd have to iterate over 4999 other people objects before you find him. If only we could just say "people['Steve']" and jump right to that object. (Again, I know this is standard in JavaScript, just hold your horses there pal.) *WELL THERE IS, FRIEND, IT'S CALLED A HASH TABLE AND HERE'S HOW IT WORKS!* Under the hood, a hash table is just a normal array like the one we have above. All of the indexes are still numbers. What we do is we take a different unique identifier for each object, and convert it into a number. This is done via a "hashing function." The hashing function takes your unique identifier and returns a number. That number is used for the array. Let's pretend you wrote a hashing function called "hash". We might use it like this: var people = Array(10); // initialize an array of length 10 var steve = {name: "Steve", age: 15}; var index = hash("Steve"); // this returns an integer people[index] = steve; ...or when you're looking for the Steve object: var index = hash("Steve"); var steve = people[index]; That's the basic concept. As you can see, it's important that the hash() function always return the same number for the same input. (The term for this is that it must be "idempotent.") So what's in the hashing function? Well that's not set in stone. All it needs to do is take some input (in our case, a string) and return an integer. Let's say that our hashing function is super simple: It just returns the number of characters in the string. (I know, this is not a realistic hashing function. Hit google if you want to find more realistic ones.) So for "Steve" it'll return the number 5 each time. You may see two obvious problems with this. **FIRST PROBLEM**: You might have two people with the same number of letters in their name. What about Joe and Bob? Running either of their names through the hashing function will return the number 3. They can't both be set to the 3rd index of the array! When this happens, it's called a "collision". And for this reason, often times, the array at the heart of your hash table isn't actually just a simple array. It's an *array of arrays*. (Or, OK, probably an array of linked lists, or some other data structure beyond the scope here. Don't hit "reply" nitpickers.) So if we do Joe first, he'll be set to "people[3][0]", and then Bob will be set to "people[3][1]". And Sue will be "people[3][2]", and so on. I'll mention at this point that a hash table is usually said to have "buckets". So in our case of Joe, Bob, and Sue, they're all in bucket #3. And when it comes time to look for some of these people with three-letter names, we have to iterate over all of them. *The assumption here is that collisions will be rare enough that it's OK to iterate over everything in a single bucket.* **SECOND PROBLEM**: You also might have noticed that the array we declared only has 10 elements. (Again, running out of array elements isn't really a problem in JavaScript so you're going to have to use your imagination here, but in other languages, if you declare an array with 10 elements, then *you get 10 elements and no more*.) So what happens if we have a person whose name is longer than 10 characters? Let's say someone is named Fletchinder. Our hashing function would return "11" but trying to set him to "people[11]" won't work. The simple answer is that our hashing function would have to return something else. Maybe it can be smart enough to see if the string is over 10 characters and, if so, subtract 10 from the final result, returning 1 instead of 11. This will of course result in *even more collisions*. So it goes. It's hopefully clear by now that a hashing function expects unique input, but does not necessarily return a unique result. This means you can only go *one direction* when hashing; you can go from "Steve" to 5, but you can never work backwards and go from 5 to "Steve". You've probably seen a lot of download sites that provide an "MD5 hash" of a file, to ensure that what you downloaded is correct. Same idea. You can start with a file and come up with an MD5 hash, but you can't start with an MD5 hash and produce the file. In this case, "MD5" is the hashing function (and it's quite a bit more complex than our simple hashing function.) OK, so that's how it all works at its core. Usually, in languages which don't support hash tables natively, you might see this all wrapped up into a class or functions so that one can easily make use of it without having to go through those steps every time; something like this: var person = {name: "Steve"; age: 30}; hashTableStore("Steve", steve); // and later, to get the object back out var person = hashTableGet("Steve"); For languages which do support hash tables natively (which a lot of them do, including JavaScript) you can usually do it much the same way you'd do a normal array: var person = {name: "Steve"; age: 30}; people["Steve"] = person; //and later... var person = people["Steve"]; In fact, in some language (JavaScript maybe? Not sure. PHP for sure.) *every goddam thing* is actually a hash table. You can start off with this: $people = []; $people[0] = $steve; $people[1] = $bob; ...and change your mind half way through and switch to this: $people["Steve"] = $steve Kinda confusing, isn't it? In reality the "0" and the "1" which we started with in that example were *not array indexes at all* but were *actually hashed* and used as keys in the hash table because, like I just said, *every goddam thing* is actually a hash table in PHP (and I think other languages). OK anyways that's a hash table. How does that relate to your situation? First of all, the people you're talking to *probably* don't specifically give a shit if you use a hash table or not. They are probably suggesting you use (what's often called) a *dictionary* or a *map* or an *associative array* (those terms are used kinda interchangeably). What's the difference? OK, so remember JavaScript hides all the details of the hash table from us, so we can just access our data like this: var person = people["Steve"]; OK, well, but, how do you know JavaScript is *actually* using a hash table under the hood there, and not some other kind of trickery to accomplish the same end result? The answer is, you don't know that! (OK, you could easily google it and find out. But stay with me here.) In reality, the hash table is just one of several approaches to accomplish this kind of key/value lookup. There is also the "binary tree" and the "red black tree" and probably others I'm forgetting. We know how the hash table works now, right? These ones work differently but accomplish the same thing: They let you quickly store or retrieve data with a key of your choice, such as the string "Steve". So how do you know JavaScript is using a hash table and not a binary tree? It depends on what the runtime creators chose. Google's V8 engine which powers Chrome and node might one thing, Microsoft's engine (whatever it's called) might use another. Etc. This is getting into the difference between an *interface* and an *implementation*. In JavaScript, this is the interface: var person = people["Steve"]; That kind of interface is often called a "dictionary" or a "map" or an "associative array." Unfortunately the world can not agree on a single term for it. The implementation might be a hash table. Might be a binary tree. Might be one when your code runs in one browser, and another when it runs in a different browser. (Yes nitpickers I know you can easily Google this and maybe they are all in fact hash tables but that is *tangential to the point I am trying to illustrate*.) It is totally possible for application developers to never know (or care) if the dictionary provided by their language or framework is implemented as a hash table or binary tree or whatever. This is why it would be *very weird* if your interviewers specifically wanted you to use a *hash table*. Probably they are suggesting you use a *dictionary*. 
Nothing happens on iOS either way.
depends on what arr is. Literally could wind up as any falsy value. 
Always returns a function that returns Transform Stream, using through2. You can customize the stream by passing options to `through2`.
That's the point I'm making.
The appropriate way to handle that is not to return null from your functions. If a function is supposed to return a number, it should always return a number or you end up with situations like this. You can also do: if (index !== -1) Which is cleaner and more explicit anyway. 
Code reviews became mandatory about a year ago at my work. We try for "review early, review often." It helps clarify the code changes and lets us make suggestions early. We've had difficulty with the idea that **a defect is any question**, not just something that is wrong. If i have a question, there might be a problem. It's easy to close or delete a defect if it isn't needed. People will make comments and even suggest changes, but not open defects, so we miss out on improvements. On the flip side, we can argue a defect is out of scope. This is important when maintaining older code as there are always things to fix. When new devs join the team they will say things like, "I figured he knew something I didn't." We don't want that. We repeat that nobody is a rockstar-ninja-guru. Everyone makes mistakes. Everyone has ideas. I *want* to come back and have to explain myself because I should add better comments or fix my code because I didn't consider that edge case. We still have some tension around it. If I open several defects for another developer, sometimes he hunts for bugs in my code. **Which is fine.** That way we all produce better, more consistent code.
Some highlights: - "promisify" synchronous and asynchronous functions - no breaking changes between switching APIs - from callbacks to promises - thin wrapper around [relike](https://github.com/hybridables/relike) to add support for both promise and callback-style API - only using [bluebird](https://github.com/petkaantonov/bluebird), if not other Promise constructor provided through `.Promise` property - [Bluebird](https://github.com/petkaantonov/bluebird) or the custom constructor is used only on environments that don't have support for native Promise - works on any nodejs version - from `v0.10.x` to latest `v6+` [Node.js](https://nodejs.org) - accept and works with javascript internal functions like `JSON.stringify` and `JSON.parse` Year, later after the latest release, finally we are here - finally, at v2. Year of total decoupling of absolutely any part and aspect of hybrids to separate very small, very centric modules - ~50 packages are behind the hybrids philosophy. With up to "200%" coverage, there's tons of use- and edge-cases handled, tons of tests. The most important packages are `handle-arguments`, `is-async-function`, `native-promise` and `native-or-another`.
There are some valid use cases, but it's a sign of sloppy coding overall to be returning null often. Many times the only case I see being defended against is a missing argument or some other function that might return null. Rather than redesign some code to work properly in all situations, people just return null because it's easy. Now everyone has to add null checks or risk running into silly bugs like the one OP saw. 
Saying it shouldn't happen often doesn't really fit into this discussion though. We have no clue what the context is, so it's useless to say, "ah just don't let that happen."
I think I'd be interested in this.
What you're seeing with the result of `[] == true` has nothing to do with the truthiness of `[]`, it has everything to do with type coercion. They're two distinct concepts. A value is either truthy or falsy with no qualification possible.
Yea, I understand it is really coercion and that in different situations, things are coerced differently, giving different results. I was just trying to show that it is possible to get mixed/contradicting results of whether something resolves to true or false or compares to true or false.
Well this is awkward. :)
Well, if you use [cluster](https://nodejs.org/api/cluster.html) or put your server behind nginx, I think that solves the problems you mentioned, and you get the best of both worlds. I've used cluster before, and it creates like 8 processes and more as they are needed, but before cluster, the amount of requests that could be handled was definitely limited as you say. I've been told nginx does the same thing, although I don't understand exactly how it works.
Promises really shine when using async functions. Using babel your code could look something like this: const readline = require('readline') const rl = readline.createInterface({ input: process.stdin, output: process.stdout }) function ask (question) { return new Promise(resolve =&gt; { rl.question(question, resolve) }) } async function main() { const name = await ask('What is your name? '); const age = await ask('What is your age? '); const color = await ask('What is your color? '); console.log(`Name: ${name}, Age: ${age}, Color: ${color}`) rl.close() } main();
I don't understand the +x or &gt; 0 part. Also, why do this, x.toString = () =&gt; ''; when x.toString() already returns ''? 
Thank you for posting. Have you tested this against any offerings by companies offering NLP as a service: API.ai, wit.ai, Watson?
You're right that `x.toString()` already results in `''` without needing to override the default implementation. Perhaps a better example could have been chosen. ~~The `+x` coerces a value into a number by first coercing it into a string~~. The `&gt; 0` is just the result of that statement. The result is `0`. EDIT: The [unary plus operator](http://www.ecma-international.org/ecma-262/5.1/#sec-11.4.6) is much more complicated than I thought.
You don't have to use Java to write an Android app, nor Objective-C/Swift to write an iOS app. You can use JavaScript or, as I've done, use Amber Smalltalk, which transpiles to JavaScript. I understand you can also use Python with Kivy, or C# with Xamarin, to write for mobile. You definitely have choice here. I stand by my position: JavaScript is absolutely unique in being tied to the web browser. You have no language choice at all (except for transpiled languages).
It's bad practice to do that, and also bad practice to use eval. It makes your code hard to understand and maintain. Why don't you use common JS modules and something like webpack or browserify to package them up for your browser?
Here's a more enlightening difference: C++: auto x = 42; auto f() { cout &lt;&lt; x; // 42; global x auto x = 7; cout &lt;&lt; x; // 7; local x } JS: let x = 42; function f() { console.log(x); // reference error let x = 7; console.log(x); // 7 } The gist is names in JavaScript can be... half... in scope. It doesn't just matter whether a name *has been* declared, but also whether a name *will be* declared later. Fun times with JS. ;-)
Do you think there's some ECMAScript police that will come arrest the Node core contributors if they implement the module spec in such a way that `import React from 'react'` has an implicit reference to `./node_modules`? What a stupid question.
npm doesn't really control how modules are loaded. Depending on what you use to bundle your applications, you'll use different methods. Assuming though you mean node, I'm sure they will support both methods. 
actually it's only 1 slider that would be repeated (different instances) with a progress to next level bar that would be slightly different. If you are familiar with object oriented javascript then not difficult at all.
It was exceptionally fast on Chrome though, much more so than the non-leopard example.
Yup, to be honest the reason I placed SUPPORTED in a function was to keep it consistent with how Polymer's own elements do it. As for the read-only, that's true but I wasn't sure if the documentation generator would pick that up. 
I think the most common reason why people hate code reviews is a mismatch between team member skill levels. Code reviews are supposed to catch typos and minor mistakes. If you have to teach other team members how to program and follow the architecture already in place, you will hate them. These things need a certain degree of experience and ability to discuss things you are unsure about with the team before you end up doing the whole thing wrong.
Beautiful and systematic book with examples.
You need to call the function that builds the table again. Now you just call the new data but don't do anything that would update the table values. Make a callback function that cleans and rebuilds the table when your AJAX call has finished. You could also look into Angular, to bind your table to your array, but that could be a bit overkill. I also don't really see the point of using id's on your &lt;script&gt; tags?
And most of these ninja tricks amount to nothing once you enable compression. There are some good suggestions, like extracting only the parts that actually change from your conditionals, or not copy-pasting the same code when what you want is iteration over a collection. But please, don't make it about symbol count. Using `me` vs `this` does not matter once compression kicks in, only serves to confuse others. And even if you serve uncompressed (yet minified?) javascript, including or skipping one image file matters far more than all the code-writing tips combined.
I was wondering about that myself. I hope there's something in the making or we'll be tied to build tools again.
var someVar = !!email;
What's wrong with this approach. I mean what's annoying you, it's too long, not clear?
This is pretty concise IMHO
A clearer way to do it would be: var someVar = Boolean(email);
something like this maybe? cb = () =&gt; console.log(New Date) accurateTime(n,cb) =&gt; setInterval(() =&gt; { var last = JSON.parse(window.localStorage.mytimer) || 0 var now = (new Date).getTime() if (now - last &gt; n) cb() window.localStorage.mytimer=JSON.stringify(now) }, 1000) accurateTime(3000,cb) 
It depends how/where are you going to use it.
Exactly. While /u/mc_hammerd's solution might work, it's accurate to a second only. (Actually code has few errors). Using 1ms intervals could be too much. Personally, without knowing more details I would pick requestAnimationFrame. &amp;nbsp; As for errors in code: `accurateTime(n,cb) =&gt; ` should be `const accurateTime = (n, cb) =&gt;` &amp;nbsp; setInterval(1000, () =&gt; { ... }) should be setInterval(() =&gt; { ... }, 1000) &amp;nbsp; `window.localStorage=JSON.stringify(now)` should be `window.localStorage['mytimer']=JSON.stringify(now)` 
I can see your point of view here but just curious since aurelia is not backed by Google nor Facebook nor have 10 million in funding like meteor do you think rob and the team should work for free? Gotta make money somehow to pay the bills little buddy. I love how most people with this criticism are the ones who complain because every feature isn't finished yet so they can put their new app in production that they get paid well over 100k to make. Kinda funny
I also don't like that Aurelia has a team of evangelists that sit on Reddit and bloat up their posts and downvote people who disagree. I see it every time something about Aurelia is posted. Check out this person's comment history: http://i.imgur.com/MbgUqCV.jpg Also, you're making claims about me that have no basis in anything I said.
Any resource that is `curl`able should get this header. See [CORS 101](https://annevankesteren.nl/2012/12/cors-101).
How did this get so many upvotes? &gt; The user-generated content only has access to the parent's `window` if they're in the same origin. This is false. Only some properties are protected by CORS, but e.g. `window.location` isn’t. Did you read the article?
Almost everything that is implemented in ES6 could be implemented using ES5. ES6 just makes it more elegant and in many cases with less code. The problem of JavaScript is not the "Bad" parts that were fixed, but the lack of raw knowledge about the language itself. The right direction should be taken: to propagate posts with knowledge and detailed explanations about the language. I'm an active StackOverflow user and I see how many developers have gaps with scope, context and prototypal inheritance. For example ES 6 introduces arrow function `=&gt;` for an easier context access, but people are starting to use it everywhere, even if it's not necessary. In the end this creates even more confusion, all because developer doesn't know how `this` works. ES6 makes JavaScript more elegant, however it doesn't make it more understandable. 
I see you're an Aurelia guru :) If you have checked out Angular 2 can you share your opinions about Angular 2, what do you dislike about it? Why is Aurelia much more relevant for you?
That's not true at all. In your [getting started guide](http://aurelia.io/docs.html#/aurelia/framework/1.0.0-beta.1.2.4/doc/article/getting-started), you have both inline javascript (to initialize jspm in index.html) and a custom event handler with inline javascript (in app.html, there's a `&lt;form submit.trigger="submit()"&gt;`). It later interpolates even more js code, e.g. `&lt;li repeat.for="row of router.navigation" class="${row.isActive ? 'active' : ''}"&gt;` How's that not putting javascript in html?
Yes, this helps tremendously. You want to ensure that you don't have too many processes because you'd prefer to have each process "stick" to a particular CPU ( so that you don't churn through caches ). for (var i = 0; i &lt; numCPUs; i++) { cluster.fork(); } And each process has an entire set of the memory usage and generally will not share much with the others. This is less efficient memory wise than the JVM technique of doing essentially the same thing with threads. But it's still WAY ahead of the Ruby/python/php model where each process can only handle a single request/connection.
What exactly did you mean by this?
`map` isn't a higher order function? News to me.
That's not true. 1st: You're not defining context, you're enforcing it. 2nd: This is a classic JavaScript reference issue. If you pass the function as a "prop" to another component, your context is lost. Traditionally, Function.bind is used, but in this case we can use Arrow functions.
Thanks! I got the same answer on SO: http://pt.stackoverflow.com/a/128727/45436
And what does that have to do with strategies? you just wanted to throw in some big words?
Just found this on twitter from /u/wesbos, looks pretty good.
 &gt; I need to create a .click() function with jquery that creates a div that is an object and the values of the object will be the individual values and buttons on the div? Can you restate the question in a different way? Maybe provide some pseudocode for how you imagine this would look? 
I have only looked at ng2 never used it so anything I say is an assumption. I like aurelia more for my projects because it's cleaner and easier for teams to work on together without having to understand code that is written in a highly opinionated but unconventional way. 
ahh ok, that approach makes a lot of sense. I'll give that a try. Thank you! I'm trying to make a clone of twitter, so with every tweet in a div, that div having a delette button , like button, etc.
The best way to get through a code review is to put on your straw skirt, grab your bamboo rifle, and pray along with everyone else for the planes to come and bring you chocolate. Trust me when I say this, but if your code reviewers are helping you write better code, be more productive, less error prone, then you will inevitably have fun. At least it will be a lot more fun than getting a company-wide email at 2am saying that your code change brought down the whole system and somebody needs to revert it in a hotfix right away. But, at other times, you will not think it so much fun if ou spent 16 hours waiting on a review only to get some grammar/spelling errors pointed out to you in your commit message, end up having to take 4 hours out of your day to rename all your variables to someone else's liking, and in the end get that email at 2AM anyway. 
Hi /u/rossta77, it looks like you're new to /r/javascript, welcome! Thanks for the submissions, but please make sure you read our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `rossta.net`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [rossta.net](/search?q=%28and+site%3A%27rossta.net%27+author%3A%27rossta77%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|15|83% [self.rails](/r/rails/search?q=%28and+author%3A%27rossta77%27+is_self%3A1+%29&amp;restrict_sr=on&amp;sort=new&amp;feature=legacy_search)|2|11% (I included `self.rails` since both of those posts are also promoting your site)
what you are looking for is the `.on()` function from jquery, along with event bubbling. these are two very important concepts to jQuery. http://api.jquery.com/on/ . here is a super simple ex: https://jsfiddle.net/ku92x544/1/ you can extend this much much further, but try to get the basics of events down first.
thank you for your help!
Check out reveal.js. I think it is probably the most popular. I think it can already handle all three of your use cases. http://lab.hakim.se/reveal-js
&gt; I don't think there is anyway with JS to know when a GIF loops. Hrm ok - do you mean that it doesn't know so as to reloop or just that it would have a slide setting for say `3` seconds and cut to the next slide whether the gif had finished or not? That makes sense though actually, I'm not sure how it would have worked... &gt; You'd need to unpack the gif and use a backend to provide you info about the &gt; gif using imagemagick and sending that to the JS someone (through &gt; attributes/AJAX-Data/inline-JSON). So splice the Gif into a tonne of JPEGs (or whatever, images) and then recreate the GIF from the images in JS? &gt; attributes/AJAX-Data/inline-JSON For now this can just be run on local machine, don't worry about server or what not. &gt; You'd be best to use a sprite sheet and animate that. This is for the gifs? Is this meaning that the Gif would be recreated in JS (as said above?) thanks! 
This slideshow would be to run and leave, like a background kinda thing rather than a presentation. Also did you see the points that /u/bigorangemachine made re the Gif displaying? cheers
I personally feel like in React you are writing your HTML in JavaScript and not the other way around.
For fuck sake dude, are you being intentionally obtuse? Can you not connect the dots on your own?
+1 for i18next, their documentation for the xhr-backend could improve but overall, it's been a straight-forward solution for my front-end translations.
HTTP compression will have a huge impact on how many bytes actually need to go over the wire, even with minification. For example, my vendor.js file is 497KB minified, but goes all the way down to 150KB with HTTP compression. That makes it hard to place a value on the size of the code vs readability.
Ah ok... &gt; I was saying if you wanted to use a GIF you could use something like &gt; ImageMagick to give you the information Ok cool... do you think you'd go for this or the sprite sheet? Sprite sheet might be a bit more granular I guess. &gt; a server-side language (like nodejs/PHP/Python) can provide this info, but the &gt; JS browser cannot get this information (unless you can unpack binary yourself) I'm not sure what you mean by unpack binary here? I certainly can't do that, I'm not sure if you're talking about the system that's running it or me though :P Python could work I guess (I'm more familiar with Python at least). The machines that would run the animation probably wouldn't have the libraries or rights to install them, but If all I was doing was using python to dictate the timing of things then this could just be hardcoded into the project and pulled down as a file in the repo (i think?). &gt; gifv apparently it's imaginary :S [link](http://superuser.com/a/835123/401930). But I could use something like [this](http://unix.stackexchange.com/a/140813/88280) to convert the gif to an MP4, I'm not sure if having it as MP4 would be a problem / better than doing the sprite thing atm. cheers 
Wes is the man. Pumped to watch this.
&gt; Ok cool... do you think you'd go for this or the sprite sheet? Sprite sheet might be a bit more granular I guess. I would use ImageMagick to provide data yes. &gt; I'm not sure what you mean by unpack binary here? I certainly can't do that, I'm not sure if you're talking about the system that's running it or me though :P Ya this is beyond either one of us. Some people understand whats going on with binary files (you'd open using HTMLcanvas or fileApi) &gt; Python could work I guess (I'm more familiar with Python at least). The machines that would run the animation probably wouldn't have the libraries or rights to install them, but If all I was doing was using python to dictate the timing of things then this could just be hardcoded into the project and pulled down as a file in the repo (i think?). Yea a python solution would be 'Python providing a RESTful service file files on this computer'. Not javascript exposed to local python but python as a localhost server. Either way my point is that a server side language is needed to look inside the gif to get the properties of it. Good luck!
There is only a relation between what is good and what you prefer, right, /u/needsTimeMachine?
Cool cool, well I have a lot to process and I'll make another post when I have more detail. Thank you :) 
It's not just about IE. It's about about most of your user base's browsers. ES6 is not supported in most browsers and older versions of Chrome. You can use a transpiler like Babel to convert ES6 to ES5 and then you won't have to worry about browser compatibility as much. What I wrote will work in nearly all browsers without the additional step of a transpiler. I was just trying to keep it simple for a new enthusiast. I do recommend using a modern build system like Webpack with Babel and ES6. 
Or this: https://github.com/ggreer/the_silver_searcher Better than Ack, which is already better than Grep. And it uses .gitignore instead of hardcoded exceptions.
Cool thanks! Been wanting to get into something like this. Need some actual experience other than writing small programs. I'll take a look at the git code and start learning and understanding it. Can't say I'll have anything to contribute; but we shall see. 
Fine Uploader is no longer commercially licensed. As of 5.9.0 - it's MIT-licensed open source software. There are live demos w/ code at http://fineuploader.com/demos.html and an extensive documentation site at http://docs.fineuploader.com.
The issues with your code is located here =&gt; ask('What is your name? ').then(name =&gt; { ask('What is your age? ').then(age =&gt; { ask('What is your favorite color? ').then(color =&gt; { console.log(`Name: ${name}, Age: ${age}, Color: ${color}`) rl.close() }) }) }) In order to maintain syncronus behavior in your promises and get rid of nesting callbacks, your 'then' callbacks should return promises. This is called creating a promise chain. The correct way of setting up your promises the way you had it above is: ask('What is your name? ') .then( name =&gt; ask('What is your age? ') ) .then( age =&gt; ask('What is your favorite color? ') ) .then( color =&gt; !console.log(`Name: ${name}, Age: ${age}, Color: ${color}`) &amp;&amp; rl.close() ); However this to will prove troublesome as name and age will be undefined in the final statement ( argument variables are local to their functions ). So lets define them outside of the scope of their individual functions. let name = '', age = '', color = ''; ask('What is your name? ') .then( chosenName =&gt; { name = chosenName; return ask('What is your age? '); } ) .then( chosenAge =&gt; { age = chosenAge; return ask('What is your color? '); } ) .then( chosenColor =&gt; { color = chosenColor; console.log(`Name: ${name}, Age: ${age}, Color: ${color}`); rl.close(); } ) Now the above is all well and good, however, if it breaks? No error; not good. To solve that issue simply add a catch to the end of the promise chain. let name = '', age = '', color = ''; ask('What is your name? ') .then( chosenName =&gt; { name = chosenName; return ask('What is your age? '); } ) .then( chosenAge =&gt; { age = chosenAge; return ask('What is your color? '); } ) .then( chosenColor =&gt; { color = chosenColor; console.log(`Name: ${name}, Age: ${age}, Color: ${color}`); rl.close(); } ) .catch( error =&gt; { // console.error( error ) // build.errors.push( error ) // you get the idea throw error; } ) Hope this helped!
&gt; You can place a GIF in the slide no problem Yeah but the problem is having the slide *know* when the gif finishes so that it would move onto the next one or reloop etc... I think having it so that it just knew when the loop was up would be enough, and maybe it could just be copy pasted for any repetitions. So something like slide.thing() slide.thing() slide.thing() slide.nextthing() would play `slide.thing()` three times, idk :P &gt; Check out the autoslide configuration option on the reveal.js readme: Thanks for the link, I'll have a look &gt; It is also possible to set a timer for each slide using data-autoslide &gt; attribute on the slides &lt;section&gt; tag OK cool, I think that some would have to be longer than others here. At the moment there would be three types of slide 1) Text info 2) Animated Gifs 3) Animated (running some kinda JS animation, maybe Processing or something IDK) And it would be neat if the text information [slide (1)] could have animated elements to them as well. I guess i need to break things up a bit tho. 
I see, I thought most browsers now had classes available to it, but I didn't think about how new the feature is that it's probably not ready to be used.
best response ever. ;o
No. I'm wrong often enough, and I'm certainly not dictating anything here. If your org wants to use a language, by all means, use it. Personally, I use that information as a factor as to weather I will accept a job or not. The same applies to eng and code review practices. I'm not aware of any studies, but I can anecdotally profess that certain languages are a drain on code quality, readability, and maintainability. That is all I'm communicating here. If you wish to refute my argument, do that instead of making a personal attack. I'll stick to things I find efficient and safe, and continue to recommended them to collages as part of my professional (albeit fallible) opinion. You do you. 
Stop the spam, please. :) Stop this madness. If you are serious - Earth will die if you not use always-stream, that's my answer :)
That's BS. No Python programmer complains about that.
You know, take heart in the fact I came here thinking that was an good idea idea and wanted to use it. If it wasn't for you I would likely haven't seen the silver searcher for a while (if at all... given its been around 3 years)
All source code should be under version control. ```git grep``` is a life saver (since time is the stuff life is made of). It uses similar options as grep so it's easy to use and see all lines that contain certain variables, etc. Of course, if you're not using git then /u/tofagerl's advice seems good.
class is syntactic sugar for a prototypical class similar to what I posted.
What's your experience with JavaScript and canvas?
We assume email is a string, and someVar will store whether an email was provided or not.
proof that when you think you found all the ways, there's another you missed.
There's a lot of fixes needed on the code examples.
Mosaic.
I did his "react for beginners" course and thought that was great. Looking forward to getting started on this. The redux.js.org tutorial was okay at best. 
The way you phrased this question makes it appear like you haven't taken the first step of even attempting to understand this on your own. It's nice that /u/kevinkace responded to point you in the right direction, but you should understand first and foremost there are a million resources out there to help you begin and learn web development - utilize them :)! Good luck.
Looks pretty cool. I'll take a look at the codebase. I've been meaning to take a look at Phaser but haven't yet - this will be a good reason to do so!
To be fair, every team has their evangelists. It's not like Tom Dale does much more than post about Ember. On the other hand, if the evangelists are downvoting disagreement that's another matter. 
I get that but after watching the comment sections for a few months now, the Aurelia ones are especially rabid. It's almost cult-like. 
Why are there so many resources on "learning redux"? It's a library that's under 100 lines of code (without comments) and braindead simple. Not trying to be elitist here, just want to understand where the difficulty is coming from.
Sounds like it was written by my 7 year old daughter.
What about assets you don't want leechers to hotlink? Like fonts and JS libs?
Vodka makes me feel brilliant. Doesn't make it so. I think Angular's problems stem from the fact that the current dev cycle has taken far too long, and is less evolutionary and more of a moonshot. It was a big, risky wager. But I think that now it's finally at RCx, it has reached the point where it can be regarded as minimalist, too. An angular 2.x app can be coded as something that is a small fraction of what it would take in 1.x. Just wanted to get that in. I like React, too. 
&gt; So the moral of the story is that the participating devs have to enjoy their work, be willing to grow, and be open to constructive criticism. This is what I'm beginning to learn too.
Thank you. I'll add that to my reading list.
Great concept, I definitely cut my teeth programming a lot of my math classes away (it's why I have no idea how to do any calc but am great at converting equations to programs). That said, poking at it I'd say you have on gigantic problem: Your deriver doesn't derive! Looks to me from the README and the code you guys got sidetracked playing with tools (git, jQuery, Bootstrap, karma, etc) and dealing with parsing text and got sidetracked from the main goal. As to general suggestions: **Less Testing** You guys have probably got some great dev experience playing with the testing tools, and I'd never want to discourage testing in general, but... It's likely distracting you from hacking at the code, which can oftentimes be more useful while you're learning. That said, you might want to try a more TDD (**T**est **D**riven **D**evelopment) like approach, where you write specs for how you _want_ the code to work (eg: this in -&gt; that out) and make that work. This can be fun to do as a team, where you can architect the project a bit by writing tests. **Simple Interface** UI/UX (**U**ser **I**nterface/**U**ser e**X**perience) is an important part of an app for sure, but it's got little to do with your core functionality at this stage. You've played with parsing enough to know you can convert whatever input into the format you want, so don't stress about the interface. When you have `derive('2x^2 - 16x + 35')` returning `'4x-16'` you can start messing with jQuery, Angular, React, Vue, whatever floats your boat to make it pretty and usable. **Github Pages** You'll probably get more replies reposting this with the thing itself online, it's a lot of work to pull/clone/install/load a web page. Make a new branch called `gh-pages`, make it just contain `app/` and either move jquery/bootstrap or link to their CDNs (somebody liked playing with NPM scripts, this process is more typical of a build script and would get dumped in a separate folder for dumping on a server). Push the new branch to Github and your app will be live at https://jasonawalker.github.io/deriver (maybe you have to turn on gh pages first?)! **JS Stuff** The `strings.js` helper is nifty, but you extend `Number` in there too. Most of what you're doing in those extended functions is simply treating the string as an array, though -- maybe you should `.split('')` and simply work along the characters. The `Storage` object is just a loose wrapper that doesn't wrap quite right - check remove. Good concept to abstract out the storage method, though. Might want to peak at classes, particularly Javascript's prototypical inheritance model, and consider how you might want to construct it even more generically as a learning exercise. The Tree's naming and usage (ie: with TreePattern) is super inconsistent and skimming down some of the functions there may be some subtle differences from what you intend (clone caught my eye). Also, your "Tree" has quite a bit of logic specific to your application with generic names that makes it a bit difficult for someone unfamiliar (ie: me) to read, where I'd expect it to behave like a generic CS tree. **Programming Stuff** KISS everything. **K**eep **I**t **S**imple, **S**tupid. From a cursory reading it seems like the whole `TreePattern` thing is mostly obfuscation over checking string/character values. You've reimplemented or modified built-in functions in a few places. We all do it when you're learning and hacking stuff together. Never be afraid to step back and say "Ok, this works, but I didn't look at it for 2 days and I'm totally lost. Let's try it again, but better." Or, now that you know what needs to happen where from some trial-and-error, go back to the top (of the input rolling in) and think about how you want XYZ to happen now. I honestly don't remember the derivative process well enough to comment on whether a tree lines up well, but it's certainly leaving you with another problem of expanded expressions (the flatString result of my previous example is `4 * x ^ 1 - 16 - 0` - and you had `return r` instead of `res` so initially it was just an error in the console). Recursive parsers/solvers/etc are sweet and I definitely encourage you to keep it up, but you may also want to consider different approaches. Earlier I suggested working across the input string as an array of characters. From here, you can read _across_ the string more similarly to how a person might read the expression. This introduces the notion of a "pass" over the input, where you can either try to do it in one movement or many (single vs multiple passes). If you'd like I can draw some ASCII/link you and flesh that concept out, but I think I've written enough for now! Hope that helps, if you'd like I'll prob have some free time later this week to make some of those little changes (like `gh-pages`) or could scroll through files and leave annotations or something on a fork or a PR. Great job getting going!
I don't use react much, so maybe I'm just wrong, but looks like this is a typo: React.render(HelloWorld, **doment**.body)
Probably the concept itself. And possibly reducers to those who are new to functional programming that Dan likes to use. 
Hah that's awesome! I'm also working on a game in react (though it's 2D). Curious how you handle state. I made the decision to not do any pathing or collision detection in order to make the state problem simpler, so I just have an object which gets updated by the server, triggering a re-render of the entire scene at once.
http://i.imgur.com/vwMin.gif
Holy shit, src/objects.cc is *only* 18302 LOC.
Fair enough; I think after the Dart fan club disappeared into the woodwork it's been much more difficult for any particular team to ruffle my feathers. 
This is for Safari Technology Preview
Nitro (actually JavascriptCore) is part of Webkit http://trac.webkit.org/wiki/JavaScriptCore
&gt; aren't valid html Of course it isn't.. it's JavaScript code. The markup the functions generate are html compliant, however.
Separate languages does not make separate concerns. So instead of putting a known language in HTML, you put some made up stuff in HTML: `&lt;yes-or-no question="Are you leaving?" answer.two-way="sayGoodbye"&gt;&lt;/yes-or-no&gt;` `&lt;say-goodbye if.bind="sayGoodbye" name.bind="name"&gt;&lt;/say-goodbye&gt;` It's all a matter of taste I suppose, but I can't fathom why anyone thinks this is better. Now to use your framework I need to know Javascript, HTML and the Aurelia Markup Language. 
TIL. Thanks for the info.
You're right. My mistake. I looked up the current statistics and as of April classes are supported in roughly 75% browsers being currently used.
Yes. Got a link?
Meh. The GCC C parser is [close to that](https://github.com/gcc-mirror/gcc/blob/master/gcc/c/c-parser.c), while GCC itself was around 7.3 million in 2012.
The problem is that you're missing a closing parenthesis. The `=&gt;` operator defines an [arrow function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions).
This is a simple arrow function. It was introduced with ES6. You can use a regular function instead.
In addition to `git-grep`, you can use `git ls-files` to list out all files in your repository. This can be used with `grep`, `sed`, `awk`, or whatever you fancy. Here's an example of replacing all `a` with `b` in all `.js` files (excluding `node_modules` and `bower_components`): ``` git ls-files | grep '.js' | xargs sed 's/a/b/g' --in-place ``` 
My biggest question is will I again need to write components specifically for Angular 2 like we had to to for Angular 1 since DOM rendering was a separate process which the controller could not access when loading a route. Aurelia seems to have a hook for onRender meaning I can just use any external plugin for whatever which I can initialise inside this function (I haven't built much with either so I'm not sure about external plugins and such). In fact I find it fucking irritating that React doesn't have this either. I'm forced to use framework-specific plugins in Angular 1 and was pissed when React has the same problem. Looking at Aurelia, this problem is absent making it VERY desirable. I'm also finding that Angular template syntax is absolutely pathetic. I couldn't care less about standard compliance but the templates are horrifically difficult to grok easily and I'm forced to use proper case when writing them. This seems like such an unnecessary step. Who had the bright idea to use different bracket types to differentiate bindings? Seriously?
&gt; little buddy What the... how condescending are the Aurelia Devs? Jebus.
Seeing as you are seemingly spot on you understanding of the shitty-ness of frameworks out there already (havent used them, just looking at syntax), I thought you might like to see something that I built from a web app built by creating my own [custom framework](https://groupup.me). Im not saying all sites/apps need a custom framework, but I think the JS community seems to default to and very strongly advocate for using frameworks. Ive even seen many articles that highly discourage new programmers to create their own and just use one thats already been built. Seems kinda crazy to me, honestly. Anywho, yeah I havent really released this yet and there is still a lot more i want to do but there should be enough there to check it out. Happy exploring :) Oh and if you would like, i can make you an access code if you would like to create an account so you can start saving/sharing links. You can check out [my profile page](https://groupup.me/ekko/saved/) to see what you could do with that. And although they are old (will be updating in next couple days) if you make it this far, you can check out some [walkthru videos](https://groupup.me/home/features/). 
&gt; I personally feel like in React you are writing your **HTML** in JavaScript and not the other way around. Except it's not HTML at all. It's XML.
It sure is fun and it's constantly getting even more so. Hope you had a good vacation, feel free to drop by the chatroom anytime and say hi, I could guide you and even point you to specific issues if you want to help out as well.
Module loading isn't, no. The spec only defines what the syntax should look like, not how they should be loaded.
It was painful to read.
Story of my life
Thanks, it's a nice engine, been using it on a few game jams so far and will most likely keep using it. Feel free to drop by the chatroom and let us know if you have any questions. If you feel like contributing, I can even point you to specific issues.
I recently published Skookum JS: a JavaScript runtime. Code [here](https://github.com/saghul/sjs)
Great! Feel free to drop by the chatroom and we'll try to answer any question you have. Also, when you feel like getting productive, I can even point you to some specific issues :)
**Over engineering (copy-paste from /u/wisepresident)**: --- just look at the template markup for angular: &lt;li *ngFor="let hero of heroes" [class.selected]="hero === selectedHero" (click)="onSelect(hero)"&gt; &lt;span class="badge"&gt;{{hero.id}}&lt;/span&gt; {{hero.name}} &lt;/li&gt; aurelia: &lt;li repeat.for="row of router.navigation" class="${row.isActive ? 'active' : ''}"&gt; &lt;a href.bind="row.href"&gt;${row.title}&lt;/a&gt; &lt;/li&gt; &lt;input type="text" value.bind="firstName"&gt; &lt;input type="text" value.two-way="lastName"&gt; --- **Scope creep** Angular 2 "provides": - native rendering - support for desktop installed apps - universal (server side) rendering - code splitting router and there are other [angular 2's features](https://angular.io/features.html) which i have not posted. but I believe you can see that angular 2 is way too *ambitious* for a framework which is not even ~~1.0~~ production ready. Also the features I have mentioned are not exactly *required* everywhere. They are just features which are good to have, but somehow became the must-have features. On other hand, Aurelia Team has decided to tackle server side rendering and all the other issues after 1.0 release. 
Well, you can check the video uploaded yesterday in [funfunfunctions](https://www.youtube.com/watch?v=6sQDTgOqh-I) One thing to bare in mind is that, contrary to funtions, arrow functions have "this" bound to them. Example: (x) =&gt; x*2 Same as: function(x) { return x*2 }.bind(this)
The 'static' rendering with react involves running node.js on the server, and piping requests through that. Every request gets the result of first rendering pass by react, done on the server. Then, if client supports JS, react takes over there and modifies this initial html as necessary. The biggest challenge will come in structuring your app so that every link / button / what have you logic still performs as expected when JS is off. Just please, don't put snapshots of static pages in your codebase. Things will change, you will forget to update the static version, and due to low usage rates bugs and incompatibilities will sit there for a long time.
Something like that. Technically it's far easier to install a go binary if you're on a non-standard OS, but that requires go to be installable on your non-standard OS, so it's a little like digging a well instead of walking to the stream if all you want is a glass of water. If you're on one of the three normal OSes the result will be the same. 
was using rivets.js recently, not disappointed at all. yet many 2-way binding concerns apply here as well.
The last thing I want is for copy/paste to happen. The goal is to have everyone understand what the code does so each individual can realise their own ideas. Perhaps we could talk a little more as the course development progresses so I have a better idea where you're coming from and how to work things out for you =)
You can implement parallaxes in CSS, which is made easier with the new [viewport size units](http://caniuse.com/viewport-units); modern browsers can optimise such animations. Keith Clark has written a [great post](http://keithclark.co.uk/articles/pure-css-parallax-websites/) on achieving this.
Hi all! I have a similar issue. This is VERY important to me and I desperately need help as it is for a job application to my dream job. I am not a developper, but I am willing to learn. If there is any good soul who is willing to make a difference in my life by lending a bit of help, he will be handsomely rewarded. PM me if you want to help me solve a coding puzzle for my dream job. Any help is welcome!!! 
yes. Also implementing the parallax effect with CSS's transform is much smoother and permanent than changing the background-position value which is how most of them are done
I'm not sure this definition of closures is accurate. They are not just "a function within a function". The key detail is that the inner function needs to be passed to somewhere outside of the parent function, either by having the parent function return it, or assign it somewhere.
I done that. But unfortunately, it doesn't explain me how I should apply it into the website...
Congrats on your browser choice, your an inspiration to us all
No. You need to know how to create an HTML page, and you need to know how to use JavaScript in an HTML page. Do you know how to do that?
what is the actual statement of puzzle? &gt;try application/json *that* is possible to use if we have some data to apply it.
More compact way would be `var someVar = (email != false);` but I prefer your way over this one.
It does define some certain things beyond syntax, like: * how imported variables are live bound * what ModuleNamespaceObjects are (`import * as this_is_a_module_namespace from "...";`) * self referencial imports by throwing errors * and evaluation order of dependency tree 
Do you have a link to what you read?
``` Object.freeze(global) ```
After two months, I have to say... mobiledoc-kit is actually in a usable state. The internal JSON representation is well documented and understandable, so you can write your own renders for your custom layouts. It's much easier to use overall. ProseMirror on the otherhand has a lot of built in functionality. DraftJS is easy to integrate into a React project and create React plugins for. However the core of any rich-text editor is exporting to HTML, and that's not really setup... at all (although there's some third party plugins for basic HTML). The basic feedback I've been getting is that you should just use draftJS internal format, and render in Javascript directly.
hit ctrl+shift+c and click on the network tab, reload the page and look if the site downloads any JSON files to your computer. right click and open it to see if there is anything in it.
That seemed to work.
I used tranform...
The concept of a closure is fairly abstract, but isn't hard to understand if you take the time to sit down and think about it. As /u/jml26 alluded to, closures are often explained as just being a function within a function. While this is correct, it doesn't really explain the full scope of what a closure is. Imagine that I have a function that returns a random string of characters, we'll call it randomString() var charSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'; var id = ''; function randomString(len) { for ( var i = 0; i &lt; len; i++ ) { var pos = Math.floor(Math.random() * charSet.length); id += charSet.substring(pos,pos+1); } return id; } var generatedString = randomString(10); generatedString(); // logs =&gt; "FGoPpQifNd" This is a pretty simple function. The variables 'charSet' and 'id' are defined outside of the function. This is all fine and dandy, but we can run into problems if we have a large JavaScript file with many functions. You could very easily mutate the variables with another function in your code without even knowing it. Your other function may work fine, but it may completely alter what is returned by the randomString function. This is not good. Especially if you were relying on the output of the randomString function to generate secure keys, for example. The easiest way to get around this is by wrapping everything in an enclosing function. function init() { var charSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'; // charSet is a local variable created by init() var id = ''; // id is a local variable created by init() function randomString(len) { // randomString() is the inner function, the closure for ( var i = 0; i &lt; len; i++ ) { var pos = Math.floor(Math.random() * charSet.length); // use variables declared id += charSet.substring(pos,pos+1); } return id; } var generatedString = randomString(10); generatedString(); // logs =&gt; "FGoPpQifNd" } init(); The inner function (the closure) has access to the parent functions variables, however there is no chance for any functions outside of the parent function to mutate either of our variables, keeping the output of out randomString function intact. Using closures is a way of writing *safer* code in JavaScript. I hope that example helps. Also, if you have the time, go ahead and read through the MDN article on closures. It goes into a lot more detail: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures MDN is a fantastic resource for any questions you might have.
I don't disagree with anything you said. Where my problem lies, is the implication that something like JSX, which does merge HTML and JavaScript somehow violates this list. Whether the syntax is "nice" is a bit subjective, and frankly I find the syntax of Aurelia perfectly fine. Where we fundamentally disagree is that the reason it's nice is because it uses a control flow not named JavaScript.
&gt; https://github.com/toxicFork/react-three-renderer You could use something like redux for collision detection, if you store positions and then compare you could decide if something is colliding or not. 
I tried requesting the page with the content type application/json and it returned me the same HTML. EDIT: Realised my mistake, forgot to set Accept in my haste.
Congrats on you're browser choice, your an inspiration to us all
Hmm, right. Still, all of those are things Webkit can't implement yet, right?
Stamps aren't really a new pattern. They do the same job as classes, so you could conceivably use them anywhere you would use a class. const a = stampit().init(function() { const priv = 'a'; this.getA = () =&gt; { return priv; }; }); var myA = a(); // Object myA.getA(); // "a" ---- class A { constructor() { this._priv = 'a'; } getA() { return this._priv; } } var myA = new A(); // Object myA.getA(); // "a" But stamps are not widely used, as you've noticed documentation is sparse, and the library itself may not hold up to real world use.
Correct, there is no spec to fully load modules, even if they implement the grammar, you can't do anything w/ it except see if a string is parsed / what the import/exports are (at the C++ layer, this stuff is not exposed to JS user code).
Thanks for the response and pardon my delayed response. I spent an entire day yesterday trying to identify differences in Chrome's and Safari's handling of HTTP requests in the app. Apparently, Charles doesn't record/identify routes qualified thus: https://www.mysite.com/donkies/#/reset-password?reset_password_token=F3a_cy3i-js32ha4ti5g823
Thank you for the input on inheritance, I have replaced them with a locally aliased base class. Regarding static section, those are "descriptions" of the patterns, I am not aware of specific names for those patterns beyond descriptions. Both patterns are object-oriented. The static-type OOP is a style of OOP that does not mutate the class/type, juxtaposing from dynamic-typed OOP (e.g. mixin). In the "static method" case, it is invoking a static method (`console.log`) from a static method. In the "static invocation from method" case, it is invoking a static method from a class method. 
What exactly is your problem there? Basically you would need to do this: - find all text nodes - change text - write back text to text node The first step would maybe be the most complicated. Maybe those links help: http://stackoverflow.com/questions/10730309/find-all-text-nodes-in-html-page http://stackoverflow.com/questions/9178174/find-all-text-nodes string replacement would be simple enough: var str = "some text with cow"; var res = str.replace("cow", "horse"); 
Should have been more clear. I don't know much JS. Only html and css. It's presentation for a career choice. So my question is more like "do you know where I can find this code". I just want to show what certain languages can do.
I plan to do a longer writeup on how I handle state. Basically I have one immutable "gamestate" object that I update in my game loop with a series of reducer functions. My game loop looks something like newState = playerMoveReducer( physicsReducer( animaitonReducer( oldState ) ) ); dispatch( 'set game state', newState ); I chose to do it this way so I didn't have to create full redux boilerplate for every single thing the game can do. Instead I just return a new immutable object from each reducer with its own updated state, then fire **one** redux action per loop which puts gameState in the store, then all components can re-render from it.
Ah, that means that you can't load that URL from a website that is not that address, I browsed to that page, then opened the console on that page and it works :). And don't worry about thanking me, you already have. Everything crossed for you with the job, I hope you get it and it you enjoy it! Let me know if you want any more help after that first step, if you go through it it should give you enough understanding as to what you had to do. Maybe tell them you and a friend cracked it, I think it shows initiative asking for help. I'll leave it up to you though, you know more about the company than I do :)
Stampit is not a pattern, it is a library created by Eric Elliott to illustrate Prototypal Inheritance in his book "Programming JavaScript Applications" (O'Reilly). If you want to understand the Stampit library and when to use it, try to understand the Prototypal Inheritance, there is a lot material about it. Here are some good articles to read: Eric Elliott's article about Prototypal Inheritance (He talks about Stampit): https://medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3#.51r2e7j78 Go deeper: http://www.ibm.com/developerworks/library/wa-protoop/ https://davidwalsh.name/javascript-objects The largest article, but complete: http://steve-yegge.blogspot.com.br/2008/10/universal-design-pattern.html?cm_mc_uid=19715744058014619467459&amp;cm_mc_sid_50200000=1462370923
For JS libs included via `&lt;script src=url&gt;&lt;/script&gt;`, `Access-Control-Allow-Origin:*` doesn’t matter.
For #2, you don't need to do that for standard sessions, either. The token given to the client is used to pull data from whatever session storage you have, and you're done. It could be a database, flat file, Redis, or whatever. For NodeJS, it could just be in memory even, with no need for long-term storage. It could be a benefit in some situations, I'll admit. You don't actually need a "separate secret for every user in the database", only every concurrent user. Though I'll admit that not having to worry about collisions *at all* is nice. Thanks for the info, though. It's definitely something to think about.
Thanks for the info. Looking into it, I think the only issue is the sorting - it seems that if you add a header row in a list, it sorts that row as well, which seems a bit odd. Otherwise it seems to work great, will keep it in mind for other projects.
I'll keep an eye on it, but for now no jQuery with this project.
React has a `shouldComponentUpdate` hook which by default returns `true`. For large component trees, it's essential to write a custom `shouldComponentUpdate` hook if you want to achieve great performance.
It seems to only work with table structures, looking for something that will work with both tables and lists. Thanks for the information though!
Great thread, it was very informative thank you. It also is probably a great answer for OP's question.
For comparision, tj/co is 101 codes of line.
Proper tail call is actually not faster in JavaScript. In fact, it will most likely be somewhat slower (one of the reasons there is pushback from most implementers). The short version is that because the callee doesn't know how many arguments the caller passed (unlike other languages which do tail call), extra work needs to be done to compensate. You will use less stack, but this doesn't matter unless you are very heavily recursive.
My friend Craig recently completed his personal project - thought I'd share it with reddit. It's a fun way to actually interact with a "feed forward" neural network. He utilizes actual handwriting (and corresponding data) and gives an interesting perspective into the learning process by allowing us to actually scroll through the different learning stages ("epochs" as he refers to them).
Huh that's pretty interesting read, and crazy if it works reliably!
The [demo](http://keithclark.co.uk/articles/pure-css-parallax-websites/demo3/) on that post looks jerky on Edge, while OP's code scrolls smoothly.
So, basically Firebase..except: * It's built on RethinkDB, rather than MongoDB * It comes with a "Horizon-Server" that can encapsulate any of your complex business logic or server-side functionality that isn't covered by the bare Horizon API. * It doesn't come with free, out-of-the-box hosting. Seems interesting. May check it out for future prototypes.
Edge just threw up support for es6 modules. This is an exciting time to live in! 
But there is new purple Safari Development Preview on OS X, which is frequently updated. Maybe some day, iOS will also get purple Safari. 
You should write that it doesn't matter :-). A team / developer shouldn't be so fixated on one technology over another, if the team knows it inside out, they'll build what's needed to get the job done. In the end it all boils down to the strength &amp; skills of the team / individuals, no framework is going to save you from making mistakes. Personally I still like angular 1.X for example, because that's what I can develop faster in, but Aurelia looked interesting &amp; gets away with some of the boilerplate code you get into with angular 1.X when switching to ES2015. (But so does Ember.js, ...) 
thanks! there was a +x missing.
I'll assume you have jasmine installed globally for simplicity. If you have a directory called *specs* with all of your test files, create a file *specs/jasmine.json* with the below content { "spec_dir": "specs", "spec_files": [ "*[sS]pec.js" ] } Now, any file that ends with spec.js or Spec.js in the specs directory is considered a test by jasmine. Create a file called simpleSpec.js in the specs directory, here is the total content: describe('simpleSpec', function () { it('runs tests', function (done) { expect(true).toBe(false); done(); }); }); Now run the following command from the top level of your project jasmine JASMINE_CONFIG_PATH=specs/jasmine.json This will run (and fail) the test we added above. The only trick is that JASMINE_CONFIG_PATH is the relative path from whatever directory you are in. I personally use a custom (5 line) gulp task rather than the command line; but I wanted to give you the simplest set up possible. Let me know if you're still having problems. 
A closure is *that pattern to keep a variable private*, right?
Ok, but what does "boost" mean? In one of React's early talks, Peter Hunt talked about how rendering speed doesn't really matter as long a single render is under ~16 ms (for a smooth 60 fps without skipping frames). Do you have to proactively do this to every component because you've actually seen a measurable need to do it from past experiences in non-trivial codebases, or is this a case of premature optimization just-because-we-can?
I know this one was for fun and highlights potential security risks, but in most cases if you can access the page, just... Math.random = () =&gt; 1; Math.random() // =&gt; 1 Math.random() // =&gt; 1 Math.random() // =&gt; 1 Edit: Update fat arrow
that sort of works but it starts to stream in all the strings, not one at a time, how can I make it do one at a time with sort of like check if the task is done?
Safari is the new IE. Seriosuly, it's become a clusterfuck of browser bugs.
Why. Have people forgotten how to code? Who am I kidding, I'm on /r/javascript.
There seem to be some significant differences. For example, this logs nothing: run(function*(){ try { yield Promise.reject(new Error('Oh no!')); } catch (e) { console.log(e.message); } console.log('Hi'); }); Check out [this article](https://davidwalsh.name/es6-generators-dive) for some ideas on how to get it closer to tj's implementation.
https://github.com/tj/co
Oh wait I was under the impression that Webit was also used by Chrome. I must've gotten lost in the news of the past few years.
Nightmare uses promises. You should just be able to return `dosome` from `dosomething` and be set.
I am not sure how to use the the promise functions in nightmarejs.
How does this: https://blogs.windows.com/msedgedev/2016/05/17/es6-modules-and-beyond/ fall into the mix? Isn't this an implementation of the loader spec?
This may sound stupid, but what exactly is the point of `co`? The [repo](https://github.com/tj/co) says it allows you to write async code in a nice way, but it seems to make it more complicated? I believe this is an example on how to use it: co(function * () { const user = yield getUserFromDB('john') return user }).then(user =&gt; { console.log(user) }, err =&gt; { console.error(err.stack) }) I'm sure I'm misunderstanding something, but why would you not want to just do it this way? getUserFromDB('john').then(user =&gt; { console.log(user) }, err =&gt; { console.error(err.stack) })
Google will have to implement their own version, V8 is completely different codebase from JSCore. AFAIK Google only ever used the rendering engine of WebKit (which they forked and now call Blink), so JSCore was never part of Chrome.
Lots of tools for client side JavaScript are written with nodejs in mind, so a passing familiarity with it would be a boon.
So this is why for actual secure randomnes crypto.getRandomValues is the way to go 
But... I like building backend code :(
No, it says "last week’s Windows Insider Preview build 14342 brings more ES6 capabilities including modules, default parameters, and destructuring". Then it says "Edge also supports all ES2016 (aka ES7) proposals – the exponentiation operator and Array.prototype.includes – as well as future ECMAScript proposals such as Async Functions and utility methods like Object.values/entries and String.prototype.padStart/padEnd." Then it goes on to refer to modules as ES6 modules. I read the whole thing. No where does it say that module loading is part of ES7.
the guy who wrote this is wicked smart
Well, as you said: they are the same language, but how you use it is different. On Node.js you will probably use JS to make your server-side logic: reading files, connecting to databases, making routes, templating and so on. On client-side JS you will probably use it more for Ajax, jQuery and DOM manipulation. At the end, it may help you or not, depending on what is the kind of help you need: do you need help with the DOM? Because Node.js will not help you with DOM at all; do you need help with getting used to the JS syntax? Then yes, it will help you.
I believe meteor is getting rid of their free hosting services.
They already have, but I was comparing it to firebase.
8.64 million tries for the curious 
What's the difference?
I agree that there is no need for a lot of the new ES6 syntax sugar. It drives me crazy as well but I don't think that is a reason to stay away from the language, especially when they aren't forcing you to use any of it. I'm curious what language you prefer in place of JavaScript? 
This is great. Thanks to Edge I can use modules in a browser now. Unfortunately due to Internet Explorer, I won't be able to use modules in the browser for... a long, long time.
I don't know how frontend developers could do JS development without node 
Just calculate the distance between the center of the ball and the corner of the rectangle using Pythagoras theorem. If it's the less than or equal to the ball radius, it's a collision.
But does it support css3 like every other browser? Or will that come with ES600?
HTTP 2.0 works fine already and is implemented by the recent versions of the important browsers. What's holding you back?
I'd guess that they implemented the unfinished loader spec. But the specification is still changing. So you probably can't rely on this implementation in edge. Edit: I think this is the spec http://whatwg.github.io/loader/
First of all - server error. Second - so what? Edge being on bleeding edge of standard doesn't mean anything. It's not cross platform, there is no chakra usage like nodejs etc. Pointless. Just to show internet that they can do it.
Why all the downvotes?
Have you considered that the guys working on Chakra might not be the same guys working on CSS support?
How about servers? HTTP2 needs full support on both server-side and browser-side. I'll go out on a limb and say you can't use server push in all the important servers today. I'll go further out on the limb and assert that the HTTP2's server push feature isn't ready for widespread adoption. I've read there are still major edits coming for HTTP2's server push feature, to avoid needlessly pushing already-cached assets everywhere. Right now, as far as I know, if you are using HTTP2 and your browser has 20 assets cached for a page already, the server has no way of knowing that and will still try to push those 20 assets, wasting time/bandwidth.
No, check out MY Webpack
Edge is a pretty good browser. What issues were you having specifically with it?
Under the hood, edge is just IE12. CSS3 support, only about 75% of chrome and firefox with only about 6% better than IE11 - with some extremely disappointing omissions like the picture element for responsive images, partial support for a subset of srcset, partial support for grid layout specification and for an older spec, browser prefix nightmare. CSS filters? Nop. etc, etc, etc... How about extensions? Nop. Almost all of the niceties are for the end user while completely ignoring the developer. Microsoft Edge, if it has a future, will be used mostly like IE was, to download a real browser...
There's lots of physics engines written in JavaScript for ideas, you could look at those. I've never done anything like this but my immediate thought was to just think of the corners as really tiny balls. So that if you've got ball to ball collision you could just reuse that.
You can detect the user's approximate location based on their ip, using Maxmind GeoIP db (http://dev.maxmind.com/geoip/geoip2/geolite2/) for example (on the backend).
You could make [GeoIP API calls](http://dev.maxmind.com/geoip/geoip2/javascript/) but it won't have the same acuracy and will eventually give you bogus results (e.g when the user is behind a proxy or roaming).
* Rent a cheap-ish Linux/FreeBSD machine * Slap nginx as proxy on it * Cache, for example all your JS-dist-directory to reduce load on the IIS Congratulations! You now support a big chunk of what makes HTTP2 great!
Not to mention Chakra isn't the same thing as EdgeHTML, which is responsible for conformance to HTML5 and CSS specs? if /u/UI_Design could mention standards that Edge has failed to support, they could at least cross reference them with https://developer.microsoft.com/en-us/microsoft-edge/platform/status/
https://html5test.com/compare/browser/ie-Edge 13/chrome-44/firefox-40/opera-31.html I'd say Edge's HTML5/CSS3 support is pretty much on par with the other browsers. Stop spreading turd shit around. Also, CSS Filters are a Working Draft ( https://www.w3.org/TR/filter-effects-1/ ) - that means that including support for it would be extremely risky, as the spec could change at any time. So yeah, basically you're just a hater. Everyone's entitled to his/her opinion, but making false claims is not an opinion, it's just being a dick.
[Srcset is supported.](https://developer.microsoft.com/en-us/microsoft-edge/platform/status/?filter=f3f0000bf&amp;search=srcset) [Picture is supported.](https://developer.microsoft.com/en-us/microsoft-edge/platform/status/pictureelement?filter=f3f0000bf&amp;search=picture) [Grid layout is prefixed](https://developer.microsoft.com/en-us/microsoft-edge/platform/status/grid?filter=f3f0000bf&amp;search=grid), every other browser has it behind a flag, and it's Microsoft's spec anyway. [Filters are supported.](https://developer.microsoft.com/en-us/microsoft-edge/platform/status/filters?filter=f3f0000bf&amp;search=filters) [Extensions are supported.](https://blogs.windows.com/msedgedev/2016/03/17/preview-extensions/)
They're actively working on cross-platform support, and Chakra can run on NodeJS: https://github.com/Microsoft/ChakraCore/wiki/Roadmap
Can we learn some proper reddit [formatting](https://developer.microsoft.com/en-us/microsoft-edge/platform/status/?filter=f3f0000bf&amp;search=srcset) first? [picture tag](https://developer.microsoft.com/en-us/microsoft-edge/platform/status/pictureelement) be considerate when you post links for pete sake. 
We've been working on this complete rework of react-boilerplate for several months. Based on the combined experiences of tons of collaborators, we've created the strongest foundation to build your next React.js application with. The biggest changes are: 1. Revamped architecture: Following a bunch of incredible discussions (thanks everybody for sharing your thoughts!), we now have a weapons-grade, domain-driven application architecture. 2. Scaffolding: Generate components, routes and more parts of your application directly from the command line, skipping all the boilerplate writing! 3. Performance: We've got the best code splitting setup currently possible, giving you the leanest, meanest payload. (The fastest code is the one you don't load!) 4. JS utilities: We now include redux-saga, ImmutableJS, reselect and react-router-redux to make sure your application scales to the size it needs. 5. CSS improvements: We use CSS modules for truly modular and reusable styles, code split your styling based on the page the user is on and make sure your code style is in order automatically! I believe this is by far the best boilerplate available, both for starting your next project and for simply getting inspired by what's currently possible. Let me know what you think everybody, I'm beyond excited to finally share this with the world!
I love the look of this from a purely technical one. How does this fair in SEO world? Is it flat rendered first and then picked up by React? I've not had time to check the code yet, but a little note like that might help. Also, and this is a minor criticism, it feels a bit overhyped which puts me off a tiny bit. I will still use it because I can see the effort and passion behind it, but I had to dig to find that. It's very subjective though. EDIT: Looked at the code and project in a bit more depth. It's possibly the best boilerplate I've personally seen, and I love the way it's organised. Brilliant job.
Webpack is exactly for that. Plenty of large sites use it in production. Webpack is _not_ just for development, not sure where you got that info.
Welcome to Ember.js, the pet project of literally 2 people. Nobody cares.
The template syntax makes any self respecting web developer never want to have anything to do with the framework. Ever. &gt; (click)="onSelect(hero)" Fuck you. This is not 1991.
You did not get my point. Webpack does not make it possible for the browser to use modules. Webpack (and other similar tools) makes it possible to use it during development and then it bundles it together for production. What people here are talking about is not having to use that build step.
Not yet, server-side rendering is the highest feature on our roadmap. v3 was the first step on that way, it won't be long now! (Also, Google picks up JS rendered sites, [possible source](http://searchengineland.com/tested-googlebot-crawls-javascript-heres-learned-220157)) &gt; It's possibly the best boilerplate I've personally seen, and I love the way it's organised. Brilliant job. Thanks so so much for the kind words, there's a lot of love in this project!
Seems like a great way to showcase some cool new tech. Reminds me a lot of deployd a few years back. Not sure why it's so important to downplay backends in today's JS. You really can't, and Horizon is no exception. There's still complex &amp; unfamiliar TOML that has to be created to effectively cover what REST endpoints would. I'd much rather have an abstracted front-end. I can monetize APIs, not a &lt;table/&gt;
&gt; Webpack does not make it possible for the *browser* to *use modules*. This is an irrelevant distinction. Forget the implementation or how it's done, Webpack brings module support to browsers. It may be prebundled to fake it, but it is a polyfil that does the same thing as real modules.
I have tried NVM-like scripts a couple of months ago, but now I'm just happy I don't need to have multiple versions on project :)
I don't see how it will be feasible if you use 3rd party node modules with lots of dependencies.
Lol, I didn't realize you spoke for all of us.
As far as I was aware...Webpack does not polyfil module behaviour...it bundles dependencies like Browserify would, into one file (or many depending on your setup). I only use Browserify so I wouldn't 100% know about Webpack, but that's my guess.
I agree it suites them more, but small files are equally ripe for caching, and the waste would still be present. It's an example of something holding people back, is all. Hopefully it'll be ready by the time System.import is supported, and I can remove the concat step in all my projects.
Polyfills are "irrelevant distinctions"? Oh frontend developers...
Well, CloudFront doesn't support it yet, for one.
The problem is w/ cache and number of requests, you still are following old HTTP/1.1 workflows (which are less than ideal and more costly than a single concat bundle) unless your server does PUSH (preferably w/ interleaving) and CACHE_DIGEST (not yet standard). https://docs.google.com/presentation/d/17JX15-Kq_5DGd7ALoa2qqdbEAGSnuF7dsg_7kBKHJKY/edit#slide=id.p might explain some, but that solution was using cookies / is before CACHE_DIGEST ( https://mnot.github.io/I-D/h2-cache-digest/ ) was ready.
see https://www.reddit.com/r/javascript/comments/4jtrpq/microsoft_edge_supports_es6_modules/d3a5zlq
Because the ball could be moving too fast and there may never be a frame where it is on the corner
Alright, thanks!
Without `shouldComponentUpdate` sometimes it's hard to achieve 16ms render time. Few days ago there was `medium.com` post showing how powerful and useful it's (going from noticeable render time down to sub-16ms)
Hi /u/cloudgentleman, this post was removed; I don't see any relation to JS. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Hi /u/bendy_straw_ftw, I'm removing this since it doesn't appear to be an actual JS problem. For help with the reddit API, you might try asking for help in /r/redditdev. Here's some additional info you might find useful: * [Reddit API docs](https://www.reddit.com/dev/api) * [Reddit API wiki](https://www.reddit.com/wiki/api)
I don't want to brag, but I have been loading raw es6 modules with systemjs into IE and every other browser for almost two years now.
GeoIP calls will sometimes be very accurate, and sometimes be only good for perhaps an entire state. And they don't give you any indication how accurate it is. http://fusion.net/story/287592/internet-mapping-glitch-kansas-farm/ I have one friend who attempted to find the GeoIP location in the "center" of each state, and use then he got that results, he knew that it was inaccurate.
Or just use a CDN?
This is why it's called 'raw'. It's just small initial config, all the rest is up to you.
As a beginner, I understand the syntax and what's going on. But when and where to use them, I don't know...
As a developer, when I write my code (aside from build steps), why does it matter.
Try visual studio code, I like it a lot. At least for normal size files (not tried open log files in it)
Hey now. Lets not have your generalist talk here.
Okay, I've just posted the course outline. It's not final yet so things can still change.
 angular.forEach($scope.multiCheckbox.checked, (checkbox, index) =&gt; { if (checkbox) { $scope.model[opts.key].push(to.options[index][to.valueProp || 'value']); } }); // &lt;-- missing parenthesis without es6 arrow functions your code would look like this angular.forEach($scope.multiCheckbox.checked, function(checkbox, index) { if (checkbox) { $scope.model[opts.key].push(to.options[index][to.valueProp || 'value']); } }); // &lt;--- missing parenthesis 
Agreed. I didn't even know VSC is an electron app until recently. I'm using it on 10 year old hardware and it runs fine.
You could use ray tracing. Basically, check if the ball's velocity vector intersects the rectangle. This will tell you if the ball will pass through the rectangle even if it's moving too fast
 &gt;Who the hell uses a browser without ad blockers in 2016? I do. 
Shh. Don't tell /r/java
I don't get it. Are the modules loaded synchronous? Will it block until the module is loaded? Can someone clarify?
It was certainly cringe worthy to read
You nailed it. I started this react and redux malarkey about 3 weeks ago, separating the react and redux parts as concepts can be quite difficult when you're learning them at the concurrently. I was implementing helper utils like combineReducers before I even understood the purpose of a reducer.
Awesome, thanks! I'll keep that in mind. 
source maps solve that nicely, and all recent browsers support them.
I agree, far and away the best boilerplate available. Thanks for putting in the time and energy!
\* SLAMS DOWN GAMERFUEL *
Isn't ES5 already valid ES6? I'm confused
It is, but I'm sure you got the point. It actually modernizes your code!
Sugar-syntax.
What a lot of discussions about these technologies tend to miss is that what these technologies allowed us to do was to almost entirely eliminate browser plugins. This new way of doing things isn't without its privacy and security issues, but those problems are *way* worse with proprietary plugins.
None of these features sound like something you want until someone does something really cool with them.
Myrtille provides a simple way to connect Windows based remote desktops from a web browser. As a web UI, it’s device and OS independant. Server side, it uses the .NET (C#) framework, IIS and the RDP protocol through an HTTP(S) gateway. Its particularity relies in the use of the .NET/C# framework to offer a better integration with Windows (equivalent solutions, Guacamole to name just one, are running on Linux/Apache/Java). It supports HTML4 (one of the few to do that), HTML5, file transfer and WebP compression (in addition to PNG and JPEG). It's primarily aimed at system or network admins and devs but everyone can use it. I hope you'll enjoy it! feedback is welcome :) Thanks!
You have dozens of unnecessary requests, you're transpiling all your code in-browser before running it, and you're downloading hundreds of KB of bloat? Don't worry, that's nothing to brag about.
Native modules are superior to bundles because they don't just bundle your code, they download each module separately. That means you can always load exactly the intersection of modules you need and modules you haven't loaded; it means you can cache each module individually and change a module without making people re-download anything else. That's a fundamentally different approach from bundles, and one that's a lot faster (coupled with HTTP/2 to tolerate the large number of requests) and more powerful. Also, Webpack is by definition not a polyfill: Webpack has its own API, polyfills don't. The point of polyfills is that your code never knows it's using them—you haven't added a dependency—and Webpack certainly does not accomplish that.
Sorry, maybe I'm not seeing the right thing, but it looks like your form is still using the input id="email"
I see great potential in CSP but not that much of a buy in. I'm evaluating using js-csp over Redux for my React components. Could you share your thoughts on this matter? Also provide few use cases for choosing async-csp over js-csp?
So I get what it does, but why would I want to use it when we all know browser support is lacking? Maybe in the near future it will be useful for updating old code?
This looks like the issue to me.
I've determined one key distinction: my machine is no longer authorized to deploy my app :D
Your code still doesn't contain any mention of setTimeout. Do you want it such that when you click the button, the slideshow is restarted? If so, set `counter` to 0 and don't cancel the setInterval.
I'd use it to transform legacy code into es6 for consistency with new development paradigm
Yeah i changed it again. I'm looking for a way to make it work. I coded such a simple good photoslider. My goal is to press the button, cycle through the array of photos. Put the timer on 0. And after a while let it start again. But sometimes when you click the button it jumps to quick. The goal has been met. But i want a perfect piece of code. * Edit, your proposal doesn't do the job neither. If you set it to 0 it starts at 0, and the slide makes weird jumps because of the interval. 
Can someone hook up this and babel in a cycle and run it a bunch of times to see how much jpg their code acquires 
That sounds great.
You can't just open a JS file in browser, needs to be inside a .HTML file. Example: &lt;html&gt;&lt;script&gt;alert('hello!');&lt;/script&gt;&lt;/html&gt; 
Uh, put it in a script tag
&lt;html&gt; tags should only have &lt;body&gt; and/or &lt;head&gt; as immediate children, so it should look something like this: &lt;html&gt; &lt;head&gt; &lt;script&gt;alert('hello!');&lt;/script&gt; &lt;/head&gt; &lt;/html&gt; Won't break anything in the browser to have it the other way, this will just stop that error from showing up!
So you can get in on the awesome Babel-transpiling game, man! But no in all seriousness I think you're exactly right. When a company is ready to refactor an existing ES5 code base this could help save some time.
For those interested, here's the chakra repo under nodejs: https://github.com/nodejs/node-chakracore And the original PR for adding chakra as an option to nodejs: https://github.com/nodejs/node/pull/4765 FWIW, I really hope nodejs gets platform independence - running node on more devices unsupported by v8 would be a huge win.
All you've shown is the front-end stuff.... check the network tab in the browser when you press submit and verify the AJAX post looks OK. From there, verify the PHP is pulling out the post variables properly and inserting them into the correct database fields.
Node isn't only used in backend development. It's used heavily in frontend development
I actually think it's useful now. I have a lot of ES5 code that's in-use with ES6 code, and it's all run through babel. It would be nice to run this on my ES5 code so that at least everything is written the same in source, even if it's going to be run *back* through babel to deploy. Also node.js code has pretty good ES6 support at this point, still missing some stuff but it does a lot already. 
Especially if you were, say China.
I don't even think it would be that hard, just link to an asset from the website with an image tag and use spam bots to embed it across several articles in high traffic websites. For websites susceptible to image hotlinking, it should be fairly easy to overwhelm their servers and drive their hosting costs up too.
Use Lebab to transpile in ES2015, then Babel to transpile back in ES5 to get more lines of codes doing same amount of work.
I've been wondering when something like this would come out. Great work!
Hotloading is nice but TDD is available in PHP as well through things like PHPUnit. For many things running locally using the built in web server can also be a great quality of life improvement at development time.
As a rule of thumb, prefer showing feedback (eg a big red "you need to fix this" box) over trying to fix input as it's typed. Your way used to be more common, but we slowly learned that virtually every attempt at it ends up obstructing the user in some cases. For example, try inputting a range of "2015-05-10" to "2015-05-18", then changing the end date to "2015-05-19". You will probably start by deleting the "8", which causes your code to mess up the start date. That aggravates people fast.
At least before there was a nice big simple switch I could throw to make my browser just a HTML viewer again.
&gt;I am not even going to talk about the hours spent getting composer up and running simply to get the API, that taught me to really appreciate npm. Something is seriously wrong on your end.
Serious question: Do you program in any other languages? To me, running javascript without a browser doesn't feel magical at all... It just feels wrong. It just feels like *another* compromise to add to the long line of compromises I have already made *because* I have been developing in javascript. Also... what's so magical about including an entire execution engine with your build? 
Okay cool thanks! I like the approach, I'll show it to people at work tomorrow.
I present to you: **[glossolalia](https://www.npmjs.com/package/glossolalia)**. If you run it against itself, babel crashes and burns here (line 55) after the 2nd pass through lebab: export var default = { transform: function transform(code, userOptions) { const options = userOptions ? _merge2.default.recursive({}, DEFAULTS, userOptions) : (0, _merge2.default)({}, DEFAULTS); On trivial code, the transpiling train seems like it can go on forever, although the results stabilize after a few passes and are, for the most part, not very interesting. I'm curious how more complicated code will hold up to the abuse. Let me know if you find any interesting results :)
Or dragging for that matter...
Non-responsive mobile-only site in {currentYear}? What the fuck
People always find reason to complain.
The reason behind use XML instead JSON was for make it easier to everybody and not only for developers. At the moment the XML files are done manually, I hope very soon build a friendly user interface. The idea of this project is create simple animations in a short period of time, I’m not thinking about videogames just animations. Working in this project was quite fun and I have to admit that I did it just for the pleasure of learning :) 
Do you truly mean complex? Or are you asking about the largest system we've developed? Because those are totally different questions, and overly complex JS apps aren't something I'm proud of.
What does "glossolalia" mean?
Maybe [PhantomJS](http://phantomjs.org/)? It's actually a headless browser, but it's built on top of WebKit, so it has all those years of optimization baked in.
Speaking in tongues 
...why not?
What's the point of this? I've seen inversify mentioned before, but I can't really think of a use case. It looks overcomplicated.
I realize this isn't the same thing, but I've used the [webpack-livereload-plugin](https://www.npmjs.com/package/webpack-livereload-plugin) with great success in this situation. Works well enough.
This for TypeScript, not Javascript.
I used this once. It's pretty cool, but it does delete some comments from your source which sucks.
I suspect that while my interviewer said "complex", he really meant "sophisticated".
diagram the state machine of states and events (timeouts,clicks) then it might be easier to reason about the code
IIRC Polymer's decision to move from an *Object.observe*-based data-binding to its current system was one of the reasons why Object.observe was deprecated by Chrome (probably due to Polymer being the official web platform library of Chrome).
Not necessarily. It just keeps the variables accessible to the local environment of the wrapping functions. It's more for immutability from outside functions
Putting /u/toqy's literal request in there results in the following: Once again, the cycle jpg hook code takes the Babel.
Still not clear what it actually does. What is the point of IOC in this case?
That is just an awful idea for such a simple task. Cheerio is already a HTML parser with a jQuery interface, maybe OP should just work with the project to fix the memory leaks he found.
It's widely accepted that 57% is the magic number.
Perhaps for /u/Higgenbottoms, but at least for me, what makes a number cryptographically secure?
[This should be of some help](http://www.w3schools.com/googleapi/)
Although Microsoft has been making a lot of headway I don't see the point in faffing about to make it work for me. Why wouldn't I just use some linux flavor?
I appreciate the offer /u/claird, but I think I'll manage. I'm at work atm so I can't try out your response or any of the other responses in this thread. I'll keep you updated though! 
Oh my, this tutorial is AMAZING. I'm definitely going to go through it. Thanks!!!!!!!!!!!