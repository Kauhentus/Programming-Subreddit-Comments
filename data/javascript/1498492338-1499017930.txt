You mean 10 years. The application has to accumulate some cruft. Comparing some green-field app with a legacy app is pretty pointless. Of course the older one will look uglier, but it will probably also handle lots of weird edge cases.
I just wish we could all be happy that people are building things. Like Sebastian said, I think we need to stop making software this competitive world. If you don't like something, don't use it. 
haha, i was literally selecting text as i read this. Medium drives me up a wall...
Found this via https://ponyfoo.com/articles/tc39-ecmascript-proposals-future-of-javascript, thought you might find it interesting
You're in the minority
&gt; What if my impostor syndrome isn't just in my head, and I really am terrible at my job? What if you suck, and you never get to find out (and thus improve) My career has been of continuous discovery and improvement. And improvement means that you used to be not as good as you are now. What if you never find out that you suck, and then can't improve? I'd rather have a healthy ego, accept my shortcomings and face my defects so I can improve them.
&gt; for fear of those differences Funny how you criticize their lack of open-mindedness while simultaneously implying that there couldn't possibly be any legitimate reasons. All languages suck and JavaScript is no exception. JS doesn't scale with the size of the team and the size of the project. That's why the Closure compiler, Flow, TypeScript, and so forth were created. They are all about this very real time/money wasting problem.
Doesn't Node.js let you write Java on the server-side?
50+ database tables per system. One had over 300.
Probably true. I just draw upon the breath of my career.
Just had a look. It's the usual offenders like constant layout trashing (even if you don't do anything) and fixed background images.
&gt; In the real world dynamic types are taking over. Try a language with gradual typing and type inference. You can get all the tooling and documentation benefits with very little extra work. You also won't need any mindless coverage-bumping unit tests. The analyzer will tell you if things don't fit together. There is no need to exercise a broken line to produce some sort of (hopefully visible) runtime error. Try TypeScript with noImplicitAny and strictNullChecks. It's pretty neat. They do some pretty smart flow analysis to make sure to not bug you with that null stuff if you already took care of it. I also really like working with Dart (strong mode). It's terse and feels pretty solid. And you can do SIMD stuff on Android/iOS which I personally really enjoy.
You laugh and yet at a fortune 500 company that is the raw truth. Laughing won't save you from being obsolete.
The raw truth is that "type errors simply don't happen"? Passing the wrong type around is still an error in JavaScript. If you're lucky, you get some kind of runtime error. If you're unlucky, the error is silently swallowed and you get some NaN which is further passed around. &gt; Laughing won't save you from being obsolete. I'm neither Java nor do I use it.
I didn't say they are impossible, they are just a non issue so far as bugs counts go. It's certainly vastly less effort to deal with a few type errors that may crop up than to invest all the upfront overhead of building classes. That's why the nextgen teams are smaller yet seem to get so much more done.
I think this is a symptom of the internet, though...we just get to see the dozen or so (out of thousands and thousands) people that don't know how to be diplomatic/constructive with criticism. Over time, I hope that these people's voices get pushed to the back so good devs don't feel attacked.
What about Babel/yarn do you consider for non-developers? Hope that didn't come off aggressively, I really want to understand how a transpilation (and more) tool and a package manager aren't targeted at devs.
There is nothing wrong with this code. The most important thing when writing code is that it is clear and understandable to anyone who may need to interact with it. If it's a solo project and you can follow what you wrote and it's easy for you to update and manage, that's all that's needed.
Meh. I search job boards regularly in Nottinghamshire and Derbyshire and I can tell you with certainty that Knockout and Backbone jobs are a rarity. Ember is close behind. Vue and React has plenty of jobs. Source: I'm a front end developer. 
I agree those projects are for developers. What I'm saying is that he made those tools, got exhausted from the critical comments from developers, but during his regular job has found other, closed source, projects/products to work on that others are enjoying without the toxicity. (Again I'm kind of deriving this from his attitude about closed source, but I think clearly there's *something* not open source he's enjoying working on and it doesn't sound like its for developers if I had to make a guess) Many people love yarn/babel but developers are so damn critical and he's clearly fed up with the attacks. Sorry my reply wasn't clear! D:
Thanks man, yeah I totally agree, what would be the best approach to fix these issues?
JavaScript engines doesn't care about function names as long as they are valid.
No biggie! I was just confused.
If you rely on auto complete then your programming language or libraries are excessively verbose. A sufficiently terse programming language with a good libraru set has little to no value to gain from autocompletion or overly fat ides. And since you have to write unit tests anyway, there is not really any value in the formal typing. People who think types replace units are pretty infamous bug generators. For those reasons I see typescript as a kind of retro buggy whip technology. If you whip your car's fender it doesn't go faster. At least it's optional. The trend is towards more functional and type independent programming, even in c++, not just scripting langs, as the template system expands metaprogramming. Static Types are dying.
&gt; If you rely on auto complete then your programming language or libraries are excessively verbose. A sufficiently terse programming language with a good libraru Haha. Yea, good thing you'd never make any typos, eh? &gt; People who think types replace units are pretty infamous bug generators. With types, you don't need tests which merely exercise lines for the sake of exercising them all. Those dumb bugs are immediately identified. &gt; Static Types are dying. There's zero indication for that. Gradual typing is becoming more popular, though.
Which editor you use? And how did you do that?
If you guys enjoy a more desktop experience, [here you go ](https://github.com/egoist/devdocs-desktop). It's a fantastic desktop app for Devdocs.io
Happy to hear that my efforts over the past 4 years haven't gone unnoticed :) (I make DevDocs)
Yes, I think his point is more of a readability issue, ie make it obvious to the programmer when the DOM updates.
IMO, this is very typical JS code, and it is very bad. Every single function here does nothing but side effects. They just manipulate god objects. That is the stuff of noodles. Some guidelines to help you denoodle it: * Completely separate DOM updates from your pure JS stuff. You can identify code smell when you see a "$(whatever)" inside of your business logic. They should ONLY ever occur inside of your DOM manipulation functions * Go so far as to prepend your DOM manipulation functions with a $ to make it clear it is a view function. See Hungarian notation for the precedence for such prefixes. * Functions should never mutate stuff. They should take in all the values they need, and return either via a value (in the synchronous case) or via a Promise (in the asynchronous case), the value they are computing. The "setting" of the computed value should occur outside the function. * The variable "this" should only ever be used inside of your public facing API functions and event callbacks. "this" should never be used inside of a nested call stack. * To this end, get the stuff you need out of "this" at the top of your call stack, and pass the relevant bits into any functions you will be calling from then on in. Only your public facing API should be setting things in "this". Any other time it is equivalent to accessing and manipulating global variables. 
Hey, appreciate your input however I'm having a hard time applying some of these principles to my example. Could you maybe give a practical example based on my code above?
There's still all the guides and code examples in the world that use var. (I recently shot myself in the foot by having a function that looped over var i - and called another function that also looped over var i. Fixed by using let)
Yeah, I was disagreeing. :)
Ah ok, but Sebastian's main message was that if more people think the way you did, then people like him would be less inclined to write open source. So I'm not sure there's another clear way forward, who is going to build these end-to-end tools? 
Almost. But to be fair you have to subtract Eclipse which is a slow slow filthy filthy code editor. You can also subtract the inheritance pattern which locks you in an architecture where you have to predict the future just like would do the fortune teller next door. On the other hand you must add the incredibly rich, vibrant, fast and handy package manager, the ability to run without virtual machine on every browsers, servers, mobiles, desktops, the non verbose coding style (compared to Java), the native asynchronous nature of JavaScript to perform non blocking operations. It's almost Java but to be fair it's roughly 100x better. Plot twist: Java and JavaScript are totally different languages. Almost.
A linter can help if you simply outlaw "var"
Another option is template substitution, which usually looks something like: console.log(sub("Hi, I am {name}", { name : "Josh" })); (you'd need to implement or find a template sub function) Or template literals: console.log(`Hi, I am ${name}`)
All the time, I love it. 
\&gt;Calling someone a pussy in 2017
MSDN is completely fragmented from the rest of the organization for some reason. There is an MSDN team who makes docs, and they barely speak to the product teams for some reason... And product teams trying to get docs changed takes ages because MSDN says they don't have time... It is a beautiful example of why organizational structure matters...
C has types and so does C++. I have no idea what point you're trying to make.
Can the RemindMe bot remind me that it reminded you?
Did you view the source for the above example you included? var dialCenter = [129,124]; var needleCenter = [ 13, 121.5 ]; var dial = new Image, needle = new Image; window.onload = function(){ var c = document.getElementsByTagName('canvas')[0]; var ctx = c.getContext('2d'); setInterval(function(){ ctx.save(); ctx.clearRect( 0, 0, c.width, c.height ); // Center the dial on the canvas. ctx.translate( c.width/2 , c.height/2 ); ctx.drawImage( dial, -dialCenter[0], -dialCenter[1]); // Center the needle on the canvas. ctx.rotate( 2.3*Math.sin( (new Date)*1/1000 ) - 0.15 ); ctx.drawImage( needle, -needleCenter[0], -needleCenter[1] ); ctx.restore(); },50); }; dial.src = 'dial.png'; needle.src = 'needle.png';
Omg current year!!!!!
but you don't know why it's doing that for "Hi, I am", name; ?
As a specific example, let's take your calculatePricings. It takes in the god object bookingData and updates bookingData.costs. No. Have it compute and return an object of {days,extra,total}. Outside, you set bookingData.costs = calculatePricings(...) Now let's talk about what you pass into it. You pass in bookingData. No. Pass in the exact variables you need to compute the price and nothing more: nDays, dailyPrice, extraPrice. Lastly, remove the call to updateDOM from there and move it outside. Again, pass in only what you need to actually update the DOM. Notice also the use of Hungarian notation. *n*Days, for number of days. I'm assuming that's what your dates.days is. Hungarian notation is extremely useful in dynamically types languages because it gives you a valuable hint at the variable type and purpose. Use it a lot! This one example covers nearly all of the bullet points I listed before. Try to apply it to the remainder of your code structure. Good luck!
Yes, I am thinking like this: var name = "Josh"; console.log("Hi, I am", name); console.log("HI, I am " + name); So for some reason I'm guessing this works different for return? (Btw, those two versions output the same)
It's behaving like that because in that context it's a [comma operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator), and comma operator returns the last thing in a "list", instead of combining things like plus operator does, i.e.: return "Hi, I am", name; // same as return ("Hi, I am", name); // (roughly) same as "Hi, I am"; return name; 
Oh I think you've made the most sense to me /u/i_am_smurfing You're saying for the return function, it doesn't behave like this: var name = "Josh"; console.log("Hi, I am", name); console.log("HI, I am " + name); which does output the same edit: generally speaking then, do you think it's just safer to stick with plus signs as opposed to commas?
To your edit: it's not really that big of deal in practice — you'll get hang of the syntax after you've used it for a while, and distinguishing whether comma in a specific case is operator or just separator for a list of things will feel pretty intuitive. I would definitely recommend being mindful of comma operator, because almost always it's use is not idiomatic way of writing JS code, meaning most programmers will have a "WTF" moment reading that piece of code. With plus operator, one thing you need to remember that it works only with numbers and strings, and not all of your functions will return values of those types. If you need to return several things from a function, you can return them in an [Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array). Plus, in a new JS standard (ES2015) that all _modern_ browsers have implemented, you can use a [spread operator](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator) in places where you need old fashioned comma-separated "list", so it's even easier to work with.
The best thing I have found for stopping the complaints and aggression is to simply say "if you have a solution please send me a pull request. I'd love the help." Complainers disappear like magic if they have to put their own effort in. 
&gt; I'm guessing this works different for return? Right. `Return` evaluates an expression. In the case of `"Hi, I am", name;`, the comma operator is evaluating each side as separate expressions, and ultimately returning the last one: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator
&gt; Don't even get me started on documentation. Even some of the least good JS documentation beats the crap out of what ever the C# ecosystem has to offer. My GOD this is what I like the most about the JS world. All documentation is practical and to the point, there's a lot of code snippets and examples, there are tips for the common use cases/issues... it is written so you can get productive right away. I've been doing Java for work and all pieces of documentation I stumble upon seem to have been written by someone who *absolutely hates programming*. Look at this snippet from the [Spring Boot reference docs on unit testing](http://docs.spring.io/spring-boot/docs/1.5.4.RELEASE/reference/htmlsingle/#boot-features-testing): &gt; A Spring Boot application is just a Spring ApplicationContext, so nothing very special has to be done to test it beyond what you would normally do with a vanilla Spring context. One thing to watch out for though is that the external properties, logging and other features of Spring Boot are only installed in the context by default if you use SpringApplication to create it. It says nothing on the first sentence, and the second one does not give *any details* on the syntax to use `SpringApplication` to add stuff to your app context.
First let's start out by debunking the myth that JavaScript and Java are related. They are not. They share the first 4 letters and that's about it. Calling it "JavaScript", iirc, was a marketing thing. The original name was going to be "LiveScript." JavaScript, like Java, has a lot of C-similar structures, like the traditional "for(let i = 0;i &gt; 10;i++)" loops, and do . . . while and while(). Variable declaration is similar, but simpler, as JS only has three types, let, const and the obsolete var keyword, rather than int and float and all the others Java has. JavaScript does not require a main function, nor is it required that everything in JavaScript be members of a class like they are in Java (though JS is pretty object oriented, as you would expect for a language focused on DOM manipulation.) Still, there are some simularities, like using the dot notation (which is pretty standard in OOP languages anyways) and the keyword "new" for constructing objects. There are syntactical differences to be sure, but knowing Java will at least give you an idea as to the basics of JavaScript, or any other language really, even Python. Because pretty much every language has variables, control structures and functions. Now maybe Python doesn't have curly bracers or JavaScript doesn't have strict typing but knowing the overall idea really helps you quickly learn the differences between languages. Knowing Java is a start, because you now know what a programming language is and what to expect. The rest is learning the differences and recognizing that, despite the name, Java is not JavaScript's big brother, or related to it in any way.
A lot of contentious issues come from conflicts with the creators' design goals. "Your project should have this specific default to make it easy for my use-case; other use-cases are secondary." The problem isn't getting someone to do it: it would be trivial for someone to implement the request exactly as requested. A possibly relevant example could be how Babel doesn't come with any transforms enabled by default. The creators may want to avoid privileging one specific use-case, or may want to hold out for a more general solution to a problem.
I can see what you're saying. Often that's a great case to create an extension module which provides for the use case the user is interested in. I feel like the Clojure community is a great example of how this kind of thing can work. It could definitely be frustrating when users want a general library to cater to their specific needs. 
&gt; So for some reason I'm guessing this works different for return? `return` can only ever return a single value. So when you do `"Hi, I am " + name`, you are creating a single value of `"Hi, I am Josh"` that gets returned. When you do `"Hi, I am ", name`, you are finding a weird quirk about JS and commas. I can't recall the spec or why but basically JS will resolve each value in the comma-chain but will only return/use the last value. 
Seems incredible that people working in browsers and tc39 complained about babel when is exactly the solution to bring the new standard (what tc39 is pushing) to all browsers. So i find them a bunch of ungrateful people sincerely. So many hours of work in probably one of the most important projects javascript HAS EVER HAD and they are only capable of saying "babel is done by incompetents". They are literally doing their job for free! Are the browsers which should be on the edge supporting the new standard!
And what, you could make that alternative? Seb helped to usher JS out of the dark ages and all you can do is offer negativity. You're the exact audience in OSS that makes hard-working, brilliant engineers want to stop contributing to OSS, thus making my life a hell of a lot harder.
Already posted to /r/webdev a day ago. https://www.reddit.com/r/webdev/comments/6jdymh/impressions_after_vue_conf_2017/
Obvious troll. Don't feel him. 😉
2005 Troll definition: Someone who purposefully baits people into argument to create chaos / prick inflated egos / or for fun. 2017: Someone with a different opinion and is not a leftist / corporate lickspittle who can still call his mind his own.
2005 definition applies nicely to the fella I was referring to. Don't be so salty.
I didn't phrase that right. A real troll's purpose is mainly chaos. That's obviously not mine here--so the word is abused--which is a shame because it has a purpose.
What does that even mean?
Thank you very much!
&gt; just making it that way immediately would cause problems But JS has a goal of maintaining backward compatibility, so if it's not enforced with a special syntax, it's never going to be default. That would mean we're stuck with the `use private` pragma forever. There is no way to transition to `_` meaning private automatically. &gt; an absolute shitstorm of # marks all over the place That's what I don't understand I guess. In normal code you get a ton of `this._`, and in this you get a bunch of `#`. This is certainly _different_, but it's actually even shorter than the alternative. I don't see why a special character for it is an issue when it's very much a special new behavior.
The risk is that babel could implement something slightly different than the spec, or make an early version of a spec popular, causing code to be incompatible with environments that implement the spec correctly. It would cause a situation similar to IE in the aughts and early '10s.
what do you mean there is no react, Vue, Angular, etc? I'm using the same stack and react. If you want to use react, then include it in your project and go to town. C# and the .net ecosystem is doing nothing to stop you.
Heck ya, it's awesome.
Who the fuck hates the Babel developer? Not many years back, people felt shitty about anything new, as they couldn't use it in any real project for the foreseeable future thanks to browser incompatibility. Now we can write JavaScript based on language *proposals* if we want and have it work in production with Internet Explorer. I the past me knew this was coming, he'd be super happy. Cross-browser issue has become "oh, I guess I need to add this Babel plugin" and it's resolved in a few seconds. I've been in the industry for 8 years now and the work of this dude was a massive QOL improvement, I'd even say Babel has accelerated the work on the ECMAScript language itself, as developers actually get to try and give feedback on the proposals, instead of few people discussing them on a theoretical level.
Are you looking to do a web app, a client/server setup, or a desktop app? 
Jesus Christ people it was a joke lmao
You can't return multiple values from a function in Javascript, although you can wrap them in an array: function nameString(name) { return ["Hi, I am", name]; } And then [spread](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator) the array into function arguments: console.log(...nameString("Josh")); But in this case you will be better off just using template literals or concatenation.
If you make a backwards selection, it may be long enough that you won't see the final part in your viewport. In that case, the popover would appear out of the viewport as well. The best one can do is to reposition it with the `onOpen` callback.
Web app i guess
Do you have browserify or webpack up and going on this? (Can you use modules?)
DevDocs is awesome! I use it about every day, it much better than the official docs for everything because of the easy and fast search that searches across multiple documentations at once. Your work is very appreciated :) PS. The only documentations missing for me is MongoDB, can you please add it to DevDocs?
React + Typescrit is also fine for enterprise-y devs coming from Java / C#. It's just a matter of picking up some simple functional programming concepts during a week or so.
I don't see how a prefix makes Javascript a compile target
No worries! It's a ton of stuff to get familiar with. I was going to suggest writing some tests, but it's a lot of upfront work to get it set up... Hmmm. I bet you could use `console.assert` Do what u/ugwe43to874nf4 said and at the bottom add some stuff like let costs = calculatePricings(1,2,3) console.assert(costs.days === 42) console.assert(costs.total === 13) //etc then you can mess around and experiment and **quickly** see if you're still getting the right answer or not. Other people have mentioned it, but the trick is keep the dom stuff away from the other stuff and otherwise write functions that return things. (Please take .selectors out of bookingData)
What they (I think) are saying is that for JS you have many, many choices on what you want to use. For C# MVC (as an example) you have the (appropriately named as it's essentially the only one) MVC library from MS.
Being dynamic doesn't mean that there aren't types. &gt; Skipping them always backfires, so in the end there isn't much payoff for type-ing You need fewer unit tests to reach the same level of confidence. Types also act as documentation. JSDoc comments, for example, are a way more verbose option to document the types of parameters, return values, and so on.
If You want a more reliable screen position it is better to rely on the event objects properties instead. So if your context menu is absolutely positioned then you would use event object.pageX and event object.pageY While if Your element is fixed position (which for this case actually makes more sense) then You would rely on eventObject.clientX and event object.clientY `page` refers to the position within the entire document including hidden scroll space `client` refers to the position just inside the visible window Both are in relation to the upper left corner starting at 0,0 If Your context is positioned absolutely it may also be a parent element who's x,y is not relative to the upper left corner as that is where the screens x,y starts at 0,0. Then you need to also take into account parent element offsets for true positioning. If you rely on fixed position and clientX/Y You should be fine though.
Hey there, I updated the code based on your feedback, please check the updated Post above and let me know if I got your feedback right.
Thanks for your feedback! I updated the code in the post above, I think it should be more suitable for tests now, is that right?
how to add packages? when i add a dependency in package.json and run `npm install` it doesn't install the new package. I think it doesn't install because new package is not in package-lock. should i be using `npm install &lt;package&gt; --save` ?
I love the smell of the &gt; You are a young developer who want to take part of a commercial project for free [...]
&lt;3 &lt;3 &lt;3 &lt;3 
why ? did i dosomething wrong ?? 
Coming from a typed language you would probably like [typescript](https://www.typescriptlang.org). It's a superset of Javascript that adds static typing. It also works really well with various editors like vscode by allowing much better intellisense.
&gt; how `NaN` is `NaN` but _is not equal to_ `NaN` Oh good grief. Not this again. `NaN !== NaN` is not a quirk of JavaScript. It's standard behavior in IEEE 754 floating point arithmetic. Every language that uses IEEE 754 floating point will do the same thing. Don't take my word for it. Try it in Python: C:\&gt;py Python 3.6.1 (v3.6.1:69c0db5, Mar 21 2017, 18:41:36) [MSC v.1900 64 bit (AMD64)] on win32 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; float('NaN') != float('NaN') True &gt;&gt;&gt; Or Ruby: strato@wsl~$ irb irb(main):001:0&gt; Float::NAN != Float::NAN =&gt; true irb(main):002:0&gt; Pick your language, if it uses IEEE 754 it's going to work this way.
java has been declared dead for the past 10 years
console.log() is your best friend for debugging. 
the [debugger](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger) keyword is very helpful as well
They lock in the versions of each dependency and make the package management deterministic. The reason you would want this is so you get a consistent setup on all computers. When you commit the lock-files to the repo, you are ensured to have the same output regardless of which computer you build/compile on. There's more info on this subject here: https://yarnpkg.com/blog/2016/11/24/lockfiles-for-all/
console.trace is also useful
What I prefer over `console.log` and `debugger` is Chrome DevTools as it allow for setting breakpoints and running step by step.
isn't there some truth in this though?
So? That was merely a joke I used to lighten the mood when the presentation started.
Debug as you write it. Say you have a button that should trigger an Ajax call, which should put the data in bunch of LIs in a UL when it comes back. * Write the event listener for the button, console log in the handler. Click button, see console log. Don't move on til you see the console log. * Write the Ajax call. Click button, see Ajax call in network tab, make sure it's got a 200 response. Don't move on ok you see that 200. * Look at the response data while you're in there to see its structure. Write a loop in the Ajax done function that console logs the bit of data you need to pull out. Click button, see data in console. Don't move on til you see the right data. And so on. So frustrating when you see a newbie trying to guess at which of 200 lines they wrote has an error. Edit: formatting
Misleading title
 //first of all read about pure function and why this is good //it better to read this code from main function //it better to use class instead of function //because class can handle internal state which is very useful in out situation //but if you target to es5 you may have to use some transpiler to es5 (babel, webpack etc) or just stick with prototypical objects //http://2ality.com/2015/02/es6-classes-final.html //https://www.w3schools.com/js/js_object_prototypes.asp class Booking{ constructor(startDate, endDate, pricePerDay, extra){ this.dates = {}; this.dates.start = startDate, this.dates.end = endDate, this.pricePerDay = pricePerDay; this.extra = extra; } //read more about getters and setters in es6 classes get daysAmount(){ //some logic here const daysAmount = this.dates.end - this.dates.start //roughly return daysAmount; } get dayCost(){ return this.pricePerDay * this.daysAmount; } get totalCost(){ return this.dayCost + this.extra; } toJSON(){ //function that takes responsibility for json representation //https://docs.microsoft.com/en-us/scripting/javascript/reference/tojson-method-date-javascript return { prices: { perDay: this.pricePerDay, extra: this.extra, }, costs: { day: this.dayCost, total: this.totalCost, }, dates: { start: this.startDate, end: this.endDate, amount: this.daysAmount, } } } } function getSelectors(){ return { dayCost: $('#cost-days'), dayAmount: $('#amount-days'), extraCost: $('#cost-extra'), totalCost: $('#cost-total'), hiddenInput: $('#booking') }; } function getDates(){ //here we retrieve our startDate and endDate somehow, for example by parsing some json return { start: "some Date here", end: "some Date here", } } function getPrices(){ //maybe retrieved from outer source such as json return { perDay: 500, extra: 100, }; } function updateDom(selectors, booking) { selectors.dayAmount.text(booking.daysAmount); selectors.dayCost.text(booking.dayCost); selectors.extraCost.text(booking.extra); selectors.totalCost.text(booking.totalCost); selectors.hiddenInput.val(JSON.stringify(booking)); } function main(){ const selectors = getSelectors(); const prices = getPrices(); const dates = getDates(); const booking = new Booking(dates.start, dates.end, prices.perDay, prices.extra); updateDom(selectors, booking); }
Thanks! Unfortunately the MongoDB documentation is released under a restrictive [license](https://docs.mongodb.com/manual/#licensing) (CC BY-NC-SA) which is not compatible with DevDocs (and which goes against the spirit of open-source in general).
 avoid transpilers (at least when prototyping) ok people don't downvote me. 
Use source maps &gt;ok people don't downvote me You can't control me, mum
i use chrome devtools (and i have debugged everything under the sun), i use other browser debuggers and operating systems as needed. I don't server side javascript fwiw, because that is stupid, constantly having to hype how "fast" it is because it is really slow and immature.
Here's a debugging tip I learned a while back, to insert `console.log`s without having to edit the source and refresh the page. (for Chrome) What you do is add a breakpoint where you want the console.log, then right-click and select "Edit breakpoint". Chrome will say "The breakpoint on line X will stop only if this expression is true". If you want a `console.log` here but don't want to actually break, just use the expression `console.log(whatever)`. When the expression is evaluated, it will call `console.log` as a side effect, and since it returns `undefined` it won't actually stop at the breakpoint. But you get your `console.log`. Edit: removed `&amp;&amp; false` after suggestion by /u/pertheusual
Chrome dev tools. Learn it. You won't regret it, it's the most under utilized tool by many devs. If you can master it, you'll be ahead of the curve. 
[removed]
This is a lot more a shameful
The problem as I see it is that NaN is taking on two meanings here - the sentence 'Not a Number' and the object NaN. So 'A' is Not a Number, but it isn't equal to the *object* NaN
It was a bandaid fix, just patched up the immediate problem. Look, YHWH clearly wasn't into long-term/root-cause fixes at the time or that whole flood soft-reset thing wouldn't have happened.
That seems like terrible advice. It's almost always better to use breakpoints in a debugger like Chrome Dev Tools, which will let you halt execution and look around at what different variables are set to. There are a few exceptions, like if the thing you're debugging is so closely coupled to the mouse/keyboard that the debugger itself can affect the behaviour (eg, you're trying to debug an onFocus function, but hitting a breakpoint affects where your browser is focused), but the vast majority of the time it's better to use a real debugger than to litter your code with console.log statements.
[removed]
I can't get out of the console log habit. Every time I try to use breakpoints, I'm not able to figure out the bug. Am I just not used to it?
People tend to down vote when something doesn't fit the down voters bias. Just try posting anything jquery-related, because it isn't like anyone here has to support existing applications that use jquery and they might actually find something jquery-related applicable to some task they have or upgrade in the pipe.
Lol, r/javascript is primarily for haters who come here to pump non JS alternatives. Actually liking js is a good way to get downvoted.
I'm using Atom too, so I'm gonna use it from now on. Thank you :)
Element itself is a port of Alibaba's [ant.design](https://ant.design/docs/react/introduce) for React. The more the merrier i guess but looking over it ant seems to have more components. Are there any highlights that speak for Element in particular?
This. Plus- if you use chrome, you can set breakpoints in your js code from within the Dev tool. 
Just to add to this, if you're using Yarn, then it would be... `yarn add &lt;package&gt;` Which in my view is a lot simpler.
it's also `npm install &lt;package&gt;` in npm5
Thank you, I didn't know that. Glad npm has made it simpler and more readable.
Thank you, I will try to do that.
Thank you very much, I will think about it.
Hey there /u/kenman! I just took a look at the guidelines. I cross-posted this to a bunch of different subreddits since it uses a ton of technologies under the hood. Apologies, I certainly didn't mean to trigger your spam radar! I'll be watching all posts closely and responding to any comments or question as soon as they come up.
Hilariously written (though potentially offensive) statement. Gave me a chuckle.
&gt;Sorry, but I have no idea what you're trying to do here, so it's hard for me to say if it's a good way to go about it. This says it all. It shouldn't be done. Maybe if it was super critical to performance or something, but generally probably a bad idea.
Because javascript is just one of many widely adopted, powerful and practical programming languages. Pi on the other hand is a marvel, it's one of the most basic and unchanging building blocks of mathematics, which as you know is at the heart of everything.
Personally I use console.logs uptill I get lost. If Im jumping into the unknown or I see extremely wierd behavior Ill do the debugger to "look around". It depends on the app or site. I like console because I can pass it functions to create side effects to copy information to higher scopes and then run repel'd anyasis on it.
Oh, good point. That makes it a little more straightforward.
What do you mean? The OP said: &gt; **my progress speed up by quite a margin when i linked my .js file to a html file** and ran code line by line using chrome devtools. That clearly implies he *wasn't* writing an UI-specific code, because otherwise he'd necessarily have an HTML page already open and linked to the JS file. Conversely, u/chrissilich's advice presupposes that the developer already has "a button", "LIs", "a UL", etc, and is already working in a browser. The OP is asking whether there's a better way to test code that *isn't* UI-dependent than using `console.log` or hooking up their code to a browser/UI and using the Chrome debugger. The previous poster basically responded with "for heavily UI-focused code I just use `console.log` and the Chrome debugger", which isn't really an answer to his question. The OP wasn't asking for advice on how frequently to test - he was asking for advice on *how* best to test - which tools to use.
I'm seeing a lot of staunch Debugging fans in this thread, which is fine. Do whatever you feel most productive doing. I think the point that "debug all the things" misses is that with log statements you can log at multiple different places and see the statements next to each other in the console. Debugging only lets you see the values at one specific point and time. To compare values you end up having to memorize the previous value. However, another argument is articulated well in “The Practice of Programming”: &gt; ... As personal choice, we tend not to use debuggers beyond getting a stack trace or the value of a variable or two. One reason is that it is easy to get lost in details of complicated data structures and control flow; we find stepping through a program less productive than thinking harder and adding output statements and self-checking code at critical places. Clicking over statements takes longer than scanning the output of judiciously-placed displays. It takes less time to decide where to put print statements than to single-step to the critical section of code, even assuming we know where that is. More important, debugging statements stay with the program; debugging sessions are transient. ... Lastly, while this is a JS discussion, I think it is worth pointing out that you don't have a nice debugger in some languages. So, being an effective logger is a universally applicable skill regardless of programming language.
debugger keyword is very usefull. An other thing I like to do is putting a global try catch on my app and console.log the err.stack in the catch section.
This is not a call for help and the reduces missing the second argument is intentional. If the initializer is not specified, the first list item is used. Also the code was simplified and sanitized from meaningful names to obscure the original intent, which would belong to my company and not me. (Although at this level it was probably wholly unnecessary.) Unfortunately that does quite completely obscure what I "achieved" with this. Sorry about that. I guess I'll need to answer at the end here...
Hi /u/ATKS, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Yes, generally if you want to share it with multiple subs, you just submit it multiple times as if it's a new post. It's also common to note in the title "xpost from /r/{whatever}", but that's not a requirement. If you use the same URL for each, there'll be a "other discussions" tab at the top which will show each of them, but you're also free to mention as a comment the other postings if you think those discussions are relevant.
/u/Gh0st1y was saying that /u/chrissilich's example was, in fact, an example. Whether the actual code involves DOM manipulation is irrelevant.
Hi /u/adilbaaj, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `sicara.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [blog.sicara.com](/search?q=%28and+site%3A%27blog.sicara.com%27+author%3A%27adilbaaj%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|8|89% [self.learnprogramming](/r/learnprogramming/search?q=%28and+author%3A%27adilbaaj%27+is_self%3A1+%29&amp;restrict_sr=on&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search) (also `sicara.com`)|1|11% 
Because we spend every other day cursing it :P
Just speaking from my experience coding a lot of Angular, I can say that Jetbrains/PyCharm/PHPStorm + Karma (unit testing) is pretty freaking amazing. Breakpoints right inside of the IDE, in my tests and my scripts... pretty amazing. It's taken me a little while to really get comfortable with it, but I now find myself to be really productive. But for everything else I just use Firefox's console, log statements, the usual tricks others have already covered. I haven't really messed with any testing of jQuery/etc, does anyone have some good recommendations?
Agreed. I don't know why we wouldn't just do what Typescript does and use `private`, it's already a reserved keyword in JS.
I love VS Code's debug tool - it's super easy to set up and super powerful. Chrome's debugger is fine for small things, but if working with a framework a native debugger is totally necessary.
Writing good automated tests, seriously. Once you get good at it, it will save you so much time over the course of a project. There's a bit of an upfront investment, but the payoff later in the project is massive. Combine that with a good debugger (Vs code has one I really like) and you're in business.
Plus the current version of node has an --inspect flag that let's you use chrome dev tools to debug.
Got it all. Thanks! 👍
It just assumes the code can run, there is no transpile, and no way to pass additional flags to the underlying code. Maybe use newer Node version that includes ES6?
Whenever I want to print a variable's value to the console, with ES6 you can just write the following: console.log({ foo }); Handy when you're logging a bunch of different variables out and you want them labelled.
console.dir is also an awesome tool.
Sure, but his advice presupposes you're already running code in the browser and have access to Chrome's dev tools. The OP's question was - by implication - "how do you debug when you aren't in the browser and don't already have access to Chrome's dev tools - do you just go out of your way to dump your code into the browser and use the Chrome Dev tools or is there another way?". In response u/chrissilich basically just said "I'm already in the browser, so I just use Chrome's dev tools". That's perfectly reasonable as a statement, but it's not an answer to the OP's question.
Unless I'm missing something that's going to make a new interval per call to the tokeniser: let a = tokeniser(); If the tokeniser is a singleton I guess that's OK but I think instead I would be checking the staleness of the token inside the while loop every time a token is requested with a.next(). Assuming that fetching the token is blocking the yield statement that should fix your issue with the token not existing for the first 200ms as the generator shouldn't return until the token does.
Yes
&gt; But after that I just get confused with talks about pooling, queuing and so on. Don't even worry about that stuff until you need to -- hopefully never. You're just writing a small program so KISS.
But that's the thing, I can't find simple instructions, all of it seems to have ridiculous amounts of information I don't need.
Same can be done with whatever you're talking about. If you need to make a MEAN app that, you go install node. Check to see if node runs. Don't move on til it does. Make an app.js file with a console log. Run it in node. Look for the console log. Don't move on til you see it. Etc etc. 
I think you're on the right track. I wouldn't think about it as code-golf, but rather as a more functional approach. I would just work on the naming a little bit. Using objects is nice, because the keys tell you exactly what you're looking at.
Exactly. He's talking about methodologies, but the OP is taking about technologies and tools. The OP is asking how best to get his code *into* some sort of debugger, whereas the earlier poster is talking about how best to *use* a debugger that he's already got his code into. See the difference?
&gt; Tooling is far less important than what you are testing. You're not wrong, but that's not the question that the OP asked. Go back and reread his initial post if you don't believe me. &gt; how slow the learning progress was when you had to guess what was happening in your code and had countless **console.logs**?... my progress speed up by quite a margin when **i linked my .js file to a html file and ran code line by line using chrome devtools**. **Is this the best way** to uncover what your coding is doing (or not doing)? **How do you guys debug** if you want to understand what a piece of code does? [Implied: code that already exists, not code that you're currently writing] Ask the advice you're giving is excellent, but the OP is talking about tools and techniques for debugging, not methodologies.
This is incremental coding. The smaller your increments are, the easier they are to debug and you will achieve your desired result faster. This might seem counter intuitive to newbies until they learn even the most simple lines of code can break and one should never assume a line of code works until it is proven that it works.
I just got into this whole Babel thing a few months ago, and honestly, it's nothing less than utterly amazing. Yes, the whole Webpack/Babel/whatever thing can be quite complicated. But once you got it set up (probably with the help of some open-source dude who made a starter kit or setting up tutorial for free), you can make amazing pieces of software almost effortless - in the browser, available to anyone in the world who has an internet connection (and a somewhat modern browser, of which you by the way don't have to have sleepless nights over anymore because of Babel and stuff). The whole (open source) JS community is just really great. Just look at us (feel free to be offended if you don't think this applies to you), a few years ago we were all in awe of jQuery AJAX requests or a simple slide-down (with just a few lines of code). Now everyone is able to build complex web applications in about the same amount of time, all thanks to open source (people like Sebastian). All of this makes it even worse that insecure devs who spent way too much time bashing on Github and way too little times actually producing anything can have such a big impact on guys like Sebastian. That's terrible.
Something that hasn't been mentioned is the 'pause on exceptions' option in the Chrome devtools (may also be available in other debuggers). You can pause on only caught or all exceptions.
wow, I'm maniac of console.log but didn't think about using destructuring, I log usually like this: `console.log('FOO', foo);`
breakpoints are useful when you need a lot of information about your software that that current state. sometimes, you don't need that, and so console.log() is faster and more obvious. &gt; litter your code with console.log statements. this is a non-issue. Either you use your text editor to find and remove them, you use grep to find and remove them, you use a linter to stop builds if they are there, or you use some kind of browserify/webpack middleware to strip them out.
I think both console.logs and debugger have its own places. Debugger forces you to stop the program, which is sometimes impossible or not practical (e.g. when debugging games, GUI interactions or complicated control flow). It such situations console.log is better. On the other hand `debugger` statement allow you for stop the program and look closely on the app at one point of time (or using step debugger for advancing time) 
Aww men, they are really nice and i just got started with react semantic ui. This one appear to have maybe less suppport ? idk.. why do they keep poping up right after i make a choice !
Seems that he meant to do: `.map((team) =&gt; { return {...team, school: team.school.toUpperCase()} })`
Lets get nitpicking out of the way: technique and methodology literally mean the same thing, especially in this context. That being done with, &gt; Is this the best way to uncover what your coding is doing (or not doing)? How do you guys debug if you want to understand what a piece of code does? Answer: write modular code, keep functions small, limit their side effects, and debug as you write. /u/letrasett is clearly new to programming in general, so its perfectly reasonable to suggest that they should rewrite it well. Notice, /u/shaper_pmp, what OP wrote in their three line post (which you so needlessly butchered quoting, by the way): they described where they were at learning programming, described what they have been doing, then asked for "**the best way** to uncover what your code is doing (or not doing)?" as well as asking "**how** do you guys debug if you want to understand what a piece of code does?". This last question doesn't necessitate that OP wrote that code themselves, while the former specifically does, but either way the answer is to learn how to write good code that isn't impossible to debug (because that's the best way to learn how to read code, even code that's written in an almost impossible to debug manner). Notice also, that ** *nowhere* ** in either question does OP mention that they are asking specifically about tooling. You deciding this is the hill you want to die on is detrimental to their learning. Tooling should *not* be the focus of this discussion, because while good tools are certainly essential, they are non-standard and not necessarily ubiquitous across the industry. Teaching good coding habits means less debugging is necessary overall, and **that** is the *best* way to know what your code is actually doing. edit: switched "that" to "which" in a sentence and a bold to an italic.
Because A isn't a number.
Did you try using different waveforms? Square waves don't have even numbered partials. That could account for some of the distortion you hear. Also, you may wish to reduce the overall gain. You may be clipping.
Too many times I follow a link to an announcement about a new release of a library/tool/etc and it just launches straight into whats new without any explanation of what the library actually is. Really nice to see a brief `If you haven’t yet heard of TypeScript...`right at the start.
Here's an example of how to point an object at another using Pythagorean Theorem: https://codepen.io/lemmin/pen/mWNWmo
I've tried different waveforms - the issues were present with sawtooths, triangles, and sines too. I haven't tried reducing the overall gain, though.
Yeah. I would definitely try that. As it is right now, I don't see in your code where you adjust gain based on the number of voices. So each one is playing at full volume. The more I think about it, the more I think this is the issue. 
Heads up, if you use rxjs 5, [don't upgrade](https://github.com/Microsoft/TypeScript/issues/16593), your build will break. Found that one out the hard way.
While it's not yet fully released, you should be able to use RxJS 6.0 &amp; TS 2.4 without problems. **Edit:** Alternatively, just run with the `noStrictGenericChecks` flag.
Updated my note to say rxjs 5, because that's what did it for me.
From the description of the license it seems that you can ask for permission from MongoDB to get an exception to the license terms. Maybe they'll give you a permission, because DevDocs can help their costumers.
How do I install v6 via NPM?
I enjoyed learning and using [Sequelize](http://docs.sequelizejs.com/) (which supports Postgres) for a simple project before I decided to go serverless. They have some good docs you can follow along with. If Postgres gives you trouble, consider trying MySQL. I'm unclear on why SQLite won't work for you: it seems to support transactions...
`npm install rxjs@6.0.0-alpha.0` I should admit I haven't gotten the chance to try this yet - I've only been keeping an eye on the issue tracker.
&gt; when you make a generic algorithm you don't have to worry about types so you can think more abstractly. Your algorithm will only work with the correct types. If it expects an array of numbers, passing a string won't work. Anyhow, have you ever used a language with gradual typing? You can add types at a later point. It's not something you have to do right away. For example, here is a stupid little demo I threw together a few days ago: https://jsfiddle.net/1wv57yye/ Here is what you have to add to make it fully typed: https://i.imgur.com/rdqv2mq.png Everything else can be inferred. Note: The first two casts aren't actually needed. I have strict null checks enabled and you have to put those casts there if you want to ignore the cases where either might be null. Without casting it to `&lt;HTMLCanvasElement&gt;`, the inferred type of `canvas` would be `&lt;HTMLCanvasElement | null&gt;`. Same thing with `ctx`. Note2: Annotation #4 could be omitted as well. That `loadImage`'s return type is `Promise&lt;HTMLImageElement&gt;` can be inferred. However, I prefer to put the types on function signatures. So, this example is actually slightly "over-typed".
Using logging is the single best way to understand program flow. You can debug using only logging. The debugger is merely an enhancement (at least for JS). Expression breakpoints slow things down. Personally I think decorators might be a useful thing to explore for easily adding debug logging and removing it. I am sure there are more brute force ways to strip out old logs too
Here's a chart to compare those charting libraries by daily download count on npm http://npmcharts.com/compare/chartjs,chartist,react-google-charts,zingchart,plotly.js,highcharts (disclaimer - I made this chart ^ )
u/enkideridu Wow! This is awesome! I didn't know this tool existed, it would have saved me a lot of time! Did you code it yourself? What charting library did you use? And by the way I am curious about why Highcharts is being so popular!
The RC was released a few weeks ago. This is the full/RTW release.
Works fine in that demo I wrote for you which you didn't seem to care about. :P https://jsfiddle.net/1wv57yye/
? The OP is commending them for having that paragraph in to post 
It's down there on the link :)
Woops, you are correct. Forgive me OP, saw the ellipsis near the end and must have mentally interpreted sarcasm where it didn't exist.
Oh cool I wrote [an article](https://medium.com/appifycanada/quick-and-dirty-tricks-for-debugging-javascript-d0e911c3afa) on this :D Here are a few snippets that may help with figuring out.. #What is this? const print = (param) =&gt; { console.log(param); return param; }; Now you can wrap `print` around any variable you're trying to figure out the value of If you prefer to tag the logs with an identifier const tag = (tag, param) =&gt; { console.log(tag, param); return param; }; Now you can wrap that around whatever you're trying to debug the values of const foobar = tag('foobar', tag('foo', 100 * tag('bar', 500))); will result in this being logged out: //&gt;&gt; bar 500 //&gt;&gt; foo 50000 //&gt;&gt; foobar 50000 //&gt;&gt; foobar is: 50000 # What’s calling this? Sometimes you're trying to figure out where are all the places that call a function, and you can't rewrite the function to throw a console.trace inside of it (e.g. it's not your function but a library function, or if you're debugging something in production). Here's how to deal with that: const traceFn = (fn, context) =&gt; function () { console.trace(`${fn.name} called with arguments: `, arguments); return fn.apply(context || this, arguments); } Let's try that on console.log console.log = traceFn(console.log); console.log('foo'); //&gt;&gt; log called with arguments: ["foo"] //&gt;&gt; (anonymous) @ VM98:2 //&gt;&gt; (anonymous) @ VM138:2 # What’s setting/overwriting this? If you have a value that's somehow getting overwritten (I've on multiple occasions have had to deal with different versions of Lodash and Underscore overwriting each other) const traceProperty = (object, property) =&gt; { let value = object[property]; Object.defineProperty(object, property, { get () { console.trace(`${property} requested`); return value; }, set (newValue) { console.trace(`setting ${property} to `, newValue); value = newValue; }, }) }; Let’s try overwriting _ traceProperty(window, '_'); window._ = 3; //&gt;&gt; VM2109:9 setting _ to 3 //&gt;&gt; set @ VM2109:9 //&gt;&gt; (anonymous) @ VM2213:1 Full article here - [Quick and dirty tricks for debugging Javascript 🕵](https://medium.com/appifycanada/quick-and-dirty-tricks-for-debugging-javascript-d0e911c3afa), more context, better formatted :D
All good! No sarcasm, just a thumbs up for a great way to start the release notes. :-)
It is low level, as much as Javascript. You can't possibly map high level terms using those. Edit: Oh, you didn't took into account what I said about trees BTW.
The simplest solution would be to wrap your script in a function and call that function when choice1 === choice2. On load, you can call the same function: https://jsfiddle.net/p9gj96mm/ Also, instead of doing multiple if to assign a value to your Math.floor, you instead use a simple array: https://jsfiddle.net/vmg0s2mL/ 
Have you not heard of node and the node ecosystem? While I don't prefer vanilla JavaScript, it's nothing like programming in assembly.
Do the TypeScript developers hope that parts of the superset language will eventually be incorporated into JavaScript standards? This is unrelated to this particular update, but I'm curious. 
I'd love to see a "use types"; syntax similar to "use strict"; with typescript like typing. 
Only need to read the last 7 lines of that article.
Pretty much 
I think in 5 years time we'll be seeing everyone claiming WebAssembly is the new King of the Hill, and in 10 years JS will look quaint, as everyone looks back on it and says "thank god we don't have to live like savages anymore". 
Dynamic typing is generics and interfaces and polymorphism and more, all at once. Have you ever studied lambda calculus ? You are really hung up on autocompletion... it's a crutch. It's never necessary or valuable outside of deficient languages. If you think I'm uninformed then you are sorely misguided. 
typescript is for people who just need more compile time for coffee
oh wow thanks! that's really useful
&gt; Dynamic typing is generics and interfaces and polymorphism and more, all at once. No. &gt; You are really hung up on autocompletion Yes, having to press fewer keys is pretty neat. Also, things which are auto-completed have a known type. &gt; If you think I'm uninformed Well, you don't appear to know what you're talking about. Which other languages have you used? I already know that you haven't used a language with gradual typing before.
I normally setup a `console.log()` shortcut (vs code one is below). So when I type `1 + tab` I get the line number and log. eg. `console.log(34, event)` even `console.log(34)` can be helpful. // vs code "Print to console": { "prefix": "1", "body": [ "console.log(${TM_LINE_NUMBER}, '$1');", "$2" ], "description": "Log output to console" },
There are 3 tricky bits: 1. `['rock', 'paper', 'scissors']` is in a specific order. Rock &lt; paper, paper &lt; scissors, scissors &lt; ... well it's rock if we wrap around. 2. `| 0` is truncation. For positive numbers, it's the same as Math.foor. `Math.floor(Math.random() * 3)` would do the same thing. 3. `(other + 1) % 3 === mine` - If the CPU chose an index which is smaller by one than the one I chose (with wrapping), I win. E.g. I click "rock", `mine` is 0. If the the CPU chose 2 (="scissors"), you get `(2+1)%3` which is 0, which means I won. % operator: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Remainder_()
If you mean debugging 3rd part libraries there are almost always unminified version of them.
No, rather I mean, stepping-through code after a breakpoint can get messy when you use libraries. Consider: [1, 2, 3].map(item =&gt; { debugger return item + 1 }) vs _.map([1, 2, 3], function(item) { debugger return item + 1 }) The former is a breeze and does not change context on you when stepping over, whereas the latter you're going to end up in some internal utility functions of lodash. A nice feature would be "Step to next call in this file/my code"
I've seen quite a few comparisons of Redux side effects approaches out there. This is certainly the most amusing one I've seen thus far. Fairly well written, although like a lot of comparisons it winds up judging the two based on relatively small snippets - basically the side effects equivalent of a Todo app, complexity-wise. Probably the best comparison I've seen thus far is [What is the right way to do asynchronous operations in Redux?](https://decembersoft.com/posts/what-is-the-right-way-to-do-asynchronous-operations-in-redux/), and [Redux 4 Ways](https://medium.com/react-native-training/redux-4-ways-95a130da0cdc) is also pretty good. Beyond that, I've got links to several other similar articles in the [Redux Side Effects#Side Effect Approach Comparisons](https://github.com/markerikson/react-redux-links/blob/master/redux-side-effects.md#side-effect-approach-comparisons) section of my [React/Redux links list](https://github.com/markerikson/react-redux-links). (This article will probably get added to that section in my next update.)
I am not a fan of questions that ask CS fundamentals. I have never had to implement BinarySearchTree as part of my job. It has no value and doesn't indicate anything about the candidate being able to perform his/her job except remembering what they did in college The best question on this is: &gt; My website is slow. Walk me through diagnosing and fixing it. What are some performance optimizations people use, and when should they be used? Otherwise not sure the value of memorizing how to implement quickSort or MergeSort will help you be a valued front-end member of the team. What I would prefer to see as questions asked: * Can you explain how eventing works in node / JS? * Can you build an event emitter? * Can you explain the difference between declarative programming vs. imperative programming? Can you give an example? * I have an error in this code sample.. can you go through and fix the problem? How would you approach fixing the problem? What tools would you use? * How would you refactor this code piece? What are some code smells? What would you do about testing? * If you are hitting an API and all of a sudden you get an error. What do you do? What if the errorcode is a 500? 404? 429? * JavaScript has class syntax from es6 onward. Why would you use it? What is JS compiler actually doing when you write a class syntax? What is prototypical inheritance? What write methods on the prototype? * CSS questions? Flexbox? Grid? Box Model? BEM? 
I'm not 100% sure but as far as I remember current version od DevTools allows for setting breakpoints every instruction. Or I don't fully understand the problem :)
*TypeScript compilation complete: 2.75s for 104 TypeScript files*
/u/holloway has the correct answer. Just be sure to consider whether or not you care about the edge case where the button is clicked twice. Should the timer reset? That depends on your app, of course, but it's something to consider as you craft your solution.
How, how exactly is "I must keep track of every resource I use in order to not blow this thing up" comparable to working with objects that are at a high level of abstraction? 
You're not doing recursion properly, because you're not propagating the return value through the recursive invocation, which is why you get `undefined`. Even if you fix it, it's not a very good use of recursion because of that global variable. Get rid of the recursion and the global variable and see what you can come up with. Note: later Project Euler questions require numerical precision that exceeds what is available in stock JavaScript. You'll need to use a bignum/bigint/arbitrary precision math library for those problems. Any problem can be solved in any (Turing-complete) language, given enough effort.
I had problem with typescript with angular 1.6. Couldn’t recognize component method and $scope childs are not typable
Is that using --watch? Anyway, it sounds little too big, I suppose it's something like Angular2?
u/broken_symlink I am also currently using plotly the same way ;) I think it is very good but the way they handle graphs sizing is not as good
&gt; HLol, the voice of presumptuous ignorance. I've used [50+ languages] including your little fad ts. Nice retconning there, bro. Anyhow, your only handwavy argument is that optional types are "pure overhead" because one should use a dumb editor without an analyzer, which can't do context-sensitive auto-complete, show call-tips, and things like that. That's all you've got. Well, even if you use Notepad or whatever, type annotations are still much terser than JSDoc comments. And there still would be the compiler which would tell you were you've made mistakes. &gt; if you want to be less of a newbie cookie cutter ms jscript dev. I actually prefer Dart. It's terse, can be AOT-compiled, and there is some fun stuff like operator overloading (which is nice for vector math) and SIMD.
Why?
A bit over the top, but using generators you can write this very concisely. First of define fibonacci as a generator function: function* fibonacci() { let a = 1; let b = 2; yield a; yield b; while (true) { const c = a + b; yield c; a = b; b = c; } } Then, with the help of some small utility-functions you can write: const fibLess = takeWhile(fibonacci(), (val) =&gt; val &lt; 4000001); const fibEven = filter(fibLess, (val) =&gt; val % 2 === 0); const sum = reduce(fibEven, (a, b) =&gt; a + b, 0); console.log(sum); Generators are fun. :D
Super cool, no classes, no hierarchies, no privates, just perfect and classic javascript (and jsx).. thanks
Did someone try Hyperapp and Typescript together ?
People like you are the reason websites are so slow
If I'm going to be honest. I wouldn't expect any candidates I interview to know many of the algorithmic questions unless they are full stack. I'm also not a big fan of 'explain X, Y' you don't get the best idea of what a candidate is capable of, alluding to issues so explanations can be contextual is much better. E.g. instead of can you explain the event loop I would prefer to ask 'Why does setTimeout(0, cb); often fix rendering issues when trying to interact with the DOM?' That gives me so much more insight into a candidate. Have they encountered this problem in the wild? What was it? Why do they think it solved it? Asking outright questions can sometimes cause good candidates to stumble.
If both languages are Turing Complete and if you can solve the problem in one language, then you can solve the problem in the other language. C++ is Turing Complete and JavaScript is Turing Complete too, so if you can solve in C++, then you can also solve in JavaScript also.
Updated from 2.3. The type checker got a lot smarter. Found a bunch of bugs. Great release. 
TyperApp confirmed
I've heard people done it talk about it on the Slack channel. Flow is another option I am more familiar with. Here's a [hyperapp + flow boilerplate](https://github.com/kingdaro/hyperapp-flow-skeleton).
Looks really great. I'll have to give it a try. Thanks!
As /u/inu-no-policemen noted, optional types would probably make that unnecessary. You could just use them when you wish. I think the challenge would come with backwards compatibility - placing a colon and a type after a variable identifier would be considered invalid syntax, so far as I understand. Although, eventually, this problem would fade away with standards adoption, and transpilers could fill the gap, as TypeScript already does. I'd certainly like to see optional typing in standard JavaScript.
Thanks for the insight. It seems to be going very well so far, but I wish you the best of luck in any case.
[removed]
JSON is a data structure stored in a string based upon hash maps, arrays, and primitive types as defined in JavaScript. It is an open standard published as an RFC.
This is a shit list. Most of these are CS questions that have nothing specifically to do with JS or even front end coding. 
Someone should give Doug a nudge then. http://www.json.org/license.html
Oh God Why? Using a screwdriver to bash a hammer to hit a nail.
So, in all cases, jQuery was just building something atop of a browser's function, essentially polyfilling it to work with the same API on all platforms/browsers. The thing with not using jQuery is that you'll get to explore and use the browser's API's yourself. In all cases where you had progress information (real progress information, and not something fake) it must have come from the browser. Now without jQuery, you'll need to tap it yourself. See for example this article: http://christopher5106.github.io/web/2015/12/13/HTML5-file-image-upload-and-resizing-javascript-with-progress-bar.html It showcases the API's you can use (essentially the events you can subscribe to in the DOM) to get notified about progress. It's not hard, you can see, but still, I bet you can pick any AJAX lib from here if you don't use jQuery anymore to leverage on your efforts: http://andrewhfarmer.com/ajax-libraries/ 
You can easily get your hands on it in China. 
I did inquit jqueryUI locally, but it still didn't work. Will try resizable.
Beautiful. Exactly what I was describing. Cheers 
I think it's interesting that the template "variables" are able to be indexed like an array. 
Awesome! Thanks. We're all learning this together. I'll probably try a few other tools, soon. MobX State tree is getting my attention.
&gt; TyperApp One of yours ? https://github.com/elbow-jason/typerapp
You have to make an Add-In (XML Manifest file, HTML Pages, JS Libraries). [Excel JavaScript API programming overview ](https://dev.office.com/docs/add-ins/excel/excel-add-ins-javascript-programming-overview) [JavaScript API for Office reference ](https://dev.office.com/reference/add-ins/javascript-api-for-office)
Some of these numbers don't make sense to me. For example, a 1000-node singly linked list in Kotlin uses 9 kb. Assuming we're storing doubles (8 bytes) and using 64-bit pointers (8 bytes), shouldn't the absolute minimum be 16000 bytes (16kb)? Similarly, the RacketScript Array stores 1000 elements in 1kb, which seems impossible if each elem is a double. What am I missing? Do these charts just show additional memory overhead above some baseline or the absolute memory usage?
The author wrote a rationale here: https://medium.com/@angustweets/just-a12d54221f65 Basically, it's designed with a strong focus on supporting slow 2G connections in the best way possible. We are using it as part of a bigger effort to improve web app performance at Uber because of mobile in emerging markets. You can read more about the engineering that went into optimizing the m.uber.com web app here: https://eng.uber.com/m-uber/ 
TypeError: $( ".draggable" ).draggable is not a function. (In '$( ".draggable" ).draggable()', '$( ".draggable" ).draggable' is undefined)
Oh, and I wondered about something: Will you stop using JavaScript when it gets optional types?
Is that supposed to be a joke?
I take that on board but I don't think it's relevant to know the algorithms in depth for an interview. I'm aware of them and I know what they're used for but I don't know more than that, when I need, I just look them up. I think it's because I'm very against testing memory and more about testing understanding and this does sort of fall into the memory category. I agree with the event loop questioning, I like to try and get them to explain it rather than be prompted though. I find this method shows someone with a thorough understanding vs having learnt things in isolatation to answer questions. I think this comes from me being burnt. Roughly 3 years ago I hired two people who, on the surface, seemed to know what they were on about. They knew the event loop when asked, knew about lexical scoping, ticked all the right boxes. Could they write JS? no. They didn't know it in practice. 
https://www.reddit.com/r/javascript/comments/6j8bsg/choosing_a_frontend_framework_in_2017/djidgdb/?st=j4h7daj2&amp;sh=cff115fa &gt; Other high-level languages like Java don't have tree constructs Because that wasn't the domain Java was intended to deal with. Javascript on the other hand was created for the sole purpose to interface with the DOM. Which is in fact a tree, and the language doesn't provide anything to work with at that level. Just your typical generic low level construct which are not suitable for anything beyond C. 
It sounds to me like you know how to install Node, install things using NPM, and use NPM scripts - Not really Node.js knowledge if you ask me. 
You could use a json web token that contains all of that info for you. https://jwt.io/
You were clearly fascinated with executing functions without parentheses, but to be honest I think that misses the point of tagged templates, and I think it only makes their existence confusing, hence the other replies here. Normally a template is evaluated right away. let name = "World!"; `Hello ${name}` // evaluated right away and results in "Hello World!" But a tagged template doesn't evaluate the template. Instead, it *parses* the template to break it into its component parts -- hardcoded strings and placeholder expressions. So, for example... showTemplateParts`One ${1+1} three ${2+2}`; function showTemplateParts(hardcodedStrings, ...placeholderExpressions) { console.log("Hardcoded strings:"); hardcodedStrings.forEach(str =&gt; console.log(str)); console.log("Placeholder expressions:"); placeholderExpressions.forEach(str =&gt; console.log(str)); } This will spit out... Hardcoded strings: One three Placeholder expressions: 2 4 This gives us the opportunity to manipulate the template's rendering process. We could conditionally insert, remove, or change any of the component parts. Here's an example from MDN where they replace a numerical placeholder expression with a string word. var person = 'Mike'; var age = 28; myTag`that ${ person } is a ${ age }` // that Mike is a youngster function myTag(strings, ...expressions) { // Replace numerical age with word var ageStr; if (expressions[1] &gt; 99){ ageStr = 'centenarian'; } else { ageStr = 'youngster'; } return strings[0] + expressions[0] + strings[1] + ageStr; } ---- /u/burnninator
The page is unusable on mobile 
&gt; I think it's because I'm very against testing memory and more about testing understanding and this does sort of fall into the memory category. Agreed completely. No need to memorize this stuff, but you should be able to implement it given an API and an explanation/spec for how the algorithm works. &gt; Could they write JS? no. They didn't know it in practice. I've had similar experiences. The best question I've found is asking candidates to live-debug code. It can be nerve-wracking for them, but if you're patient and helpful, it can be a fantastic signal for performance.
I'm not 100% sure I follow what this article is saying. Wouldn't this solve the problem in the shortest amount of time: const highestNumber = list.reduce((highest, num) =&gt; Math.max(highest, num)) without any of the thinking?
Actually I've just checked, Racket benchmark wasn't right. 1000 items vector takes 10428 bytes (~10KB).
If the core decides to become typescript then you can be sure there will be a fork that avoids the baggage. I'm skeptical this will come to pass however.
No, I understand your point. You're using the wrong terminology. High-level and low-level refer to distance from machine code for encoding logic. You missed my point though. Shit like trees and graphs are not language features. They are standard library features. You are arguing that vanilla JavaScript is missing STANDARD LIBRARY features. Which could be a valid point. Languages do not provide functionality for high-level data structure or algorithms as LANGUAGE features. They are STANDARD LIBRARY features. I'll say it again. The STANDARD LIBRARY is what you are talking about. Of course, you are wrong anyway because JavaScript's standard library has multiple classes explicitly for working with trees and the DOM in a pretty easy way. [Read](https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker) [the](https://developer.mozilla.org/en-US/docs/Web/API/NodeIterator) [fucking](https://docs.microsoft.com/en-us/scripting/javascript/advanced/recursion-javascript) [manual](https://developer.mozilla.org/en-US/docs/Web/API/NodeList). Show me a language that has a better standard library for working with the DOM as a tree. (Oh wait, you can't because there isn't one.) Frameworks don't provide any functionality you can not achieve in normal JavaScript. They merely wrap it in a more syntactically convenient method. You're just lazy. That doesn't mean JavaScript is low-level. On that point, you are wrong. Low-level is not an opinionated term. It is a [well-defined](https://en.wikipedia.org/wiki/Low-level_programming_language) term.
Not sure what exactly you don't understand, but it's basically a comparison of how much memory (your computer's RAM) in the browser is consumed by different data structures in different languages that could be compiled into JavaScript. For example number `1` in JavaScript takes 8 bytes of memory. Empty JavaScript object takes 56 bytes and empty array takes 32 bytes. A data structure such as HashMap in a language that compiles to JavaScript would be constructed out of many JS arrays and objects where each of them takes some amount of memory. When summed together you can see how much memory this particular data structure takes.
I'm not sure localStorage is what you want here. It is device specific. So, if a user accesses your site from say, a desktop, they could have different notification settings from when they access it on a phone. If this is what you want then store the notification settings in an object. Then use ```JSON.stringify``` on the object when calling ```localStorage.setItem```. When you retrieve the data by calling ```localStorage.getItem```, call ```JSON.parse``` on the string it returns.
Node.JS requires you to know how to interact as a backend developer such as using Express or MongoDB or some sort of SQL driver that you can drive your front end projects with back end code. 
What you're saying is that JS is for the DOM what assembly is for the hardware?
I think the labels on the chart are misleading and the data is outdated. If you check out the [source](https://github.com/roman01la/js-memory-usage/blob/master/src/kotlin/) used to generate the data for the chart, you can see that Kotlin is using an ArrayList not a LinkedList (and then 9Kb makes more sense). The data presented in the README of that repo is also more realistic I think. For example, 1.5Kb for 100 items in GopherJS Array vs the OP's link showing 6Kb to store 1000 items.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [roman01la/js-memory-usage/.../**** (master → 664a508)](https://github.com/roman01la/js-memory-usage/blob/664a508a333c482983a103ea1a3302faa719ab88/src/kotlin/) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply djiq8fj.)^.
This benchmark will likely get skewed by the underlying JavaScript engine optimisations applied. I know that V8 has a bunch of optimisations for arrays (fast inline property access) and there's also the cost of having an inline cache for properties (along with their hidden classes for different shapes).
Not him, but nobody's making simple websites with angular/react, trust me, if they did, they'd actually be fast. Websites are slow because of piles and piles of ads, telemetry/statistics libraries that they are loading to track your sorry ass.
Nope
The reason why people use hardware description languages (DSLs) to you know ... describe hardware.
&gt; Static code analysis and unit test solve those problems. Types enable much better static code analysis. Without types, the things an analyzer can do are limited. Languages with gradual typing illustrate this nicely. As you add types, the analyzer can identify more issues. And yes, as I mentioned, you can of course also bump the unit test coverage with mindless tests to catch these runtime errors. However, types are less work and more useful when you write and maintain the code.
There won't be a fork. You can just not use those *optional* types. Creating a fork would be completely pointless. Well, it already almost happened in the past with ES4. Nowadays, browser vendors are much less afraid to start supporting new syntax. Two of the vendors (Microsoft and Google) have also shown lots of interest in typed alternatives and supersets. Apple probably won't show interest in this since they seem to prioritize their app store. A more capable web kinda conflicts with their interest. Same deal with WebM, Opus, etc. They own H264 and AAC related patents.
I don't know why you're calling people "script-kiddies" when you can't even write a filter function.
use WebRTC data channels and SimplePeer
*Fewer* tests, not no tests.
Welcome to the internet friend, this is what one would call a joke.
Another library I'd recommend is [Primus](https://github.com/primus/primus). It has both client and server libraries, and can swap out frameworks by changing a single configuration option. It also has a plugin system with official plugins for things like sessions, validation, multiplexing, etc. 
Allowing arbitrarily complex expressions in destructuring assignments in function signatures also didn't cause a fork and that's some hilariously terrible feature. Optional types won't cause a pointless fork. &gt; There is no serious proposal to add optional types to js Yes, but that topic came up multiple times. There is a fairly high chance that they will be added in a few years. For the time being, TypeScript is used to experiment with this and for gathering some real-world feedback. **Edit:** Clojure is a modern Lisp, but it's getting gradual typing. Oh no! :&gt;
I'm saying no fewer
They all use websockets protocol so you are stuck with TCP connections which sadly are non optimal for most games. In terms of performance for real time applications (like a lot of games) the websockets implementation is not really the problem compared to the inherent problems with TCP. With that being said I prefer to use "pure" implementations over something like socket.io because websocket is a standard that has implementations in basically every programming language. While in the case of socket.io you need some specific client code, sure it works great in javascript but maybe one day you will need to create a new gameclient in some weird language that doesn't support socket.io but it will probably have some sort of websocket implementation. Also raw websockets are faster (citation needed?). For real time games something like WebRTC would be better if you are targeting web browsers, however WebRTC is a clusterfuck and we still don't have good interfaces to deal with it for games (or general data) that I know of. To answer your question, I'm currently using ws for a real time game (albeit not a really fast paced one) and it works okay. 
Have a look at socketcluster: http://socketcluster.io
&gt; Types are another one: very popular in academia but much less so out in the real world. What "real world" do you live in? Most code written today uses types. Most new somewhat popular programming languages have types.
All runtime errors which will be always produced when a particular line is executed. Aka the stupid shit an analyzer can spot if it has some type information available.
Those are insignificant. 
The picture in the Github README is what I was referring to, but I see now it actually has the 2Kb label twice, instead of 1Kb and 2Kb.
Love the documentation. &lt;3
What is your point? You won't recover the time you spend dealing with types, and you won't have to write any fewer unit tests. It's a wet security blanket with a real cost. 
http://nginx.org/en/docs/http/ngx_http_auth_request_module.html would be a solution in nginx. Basically you can call another url in a subrequest (like a route for your webapp) and if that returns a 200 then the request is allowed.
&gt; You won't recover the time you spend dealing with types I do quite easily, actually. I'm significantly more productive with optional types. &gt; you won't have to write any fewer unit tests You do need fewer unit tests to reach the same level of confidence.
Anyhow, you might want to head over to this thread and tell everyone how super wrong they all are: https://www.reddit.com/r/programming/comments/6jz9ki/5_programming_languages_you_should_really_try/
How are you gonna build the frontend? I built a multiplayer game using node.js and socket.io for some of the data. I quickly realized that the performance of socket.io was not near good enough to handle multiple messages per second, per client. The json parsing just takes too much time. I now use a plain tcp socket for the performance critical socket, but I still use a socket.io socket for some other communication because of its support for rooms etcetera. My game is built with unity, if you're planning on a web based game built with html + javascript, a tcp socket is not an option for you. 
I would have them access an artificial file, the file actually dynamically returns the script.js contents or nothing based upon the referrer data. Index the customer domains in your database, then lookup based upon the value of document.referrer.split('/')[2]. if(inDB){ var jsFile = fs.readFileSync('./script.js'); res.writeHead(200, {'Content-Type': 'text/javascript' }); res.end(jsFile, 'binary'); }else{ res.status(404) .send('Not found'); }
&gt; and c for optimizing But C has types. &gt; Maybe you should go there. I don't mind that those languages have types.
&gt; But isn't this already solved by type systems like flow and typescript? To some extent yes, but having this functionality available in vanilla JS is pretty nice for all those people not using flow/ts.
&gt; I just got into this whole Babel thing a few months ago, and honestly, it's nothing less than utterly amazing. I can't find a source for some reason, but Seb actually wrote it at age 14 IIRC, when he was bored in high school. Now it's being used practically everywhere React is, and then some; he's now working at Facebook, naturally for someone that gifted.
Referrer can't be trusted either.
Sorry about that. The `--noStrictGenericChecks` flag will help get around this until RxJS 6.0 is out.
I totally understand why you built this but I am still downvoting because IMO there is better ways to solve this-maybe instead of writing so much redux boilerplate for each component you could try cut that down by using an easier state management library.
Call me crazy, but I just use localStorage and I don't have any problems. It is extremely fast, a web standard, and holds 5mb of string data per domain.
book ( $ 19 ) now for free
I agree what you are saying here but what is relayed on the site doesn't give that impression. &gt; being able to interpret a spec, implement algorithms, reason about Big O and tradeoffs between different data structures, all of that is very useful This would be awesome. Have a problem that has a visual design spec, implement it. EventEmitter class is fundamental for understanding event triggers in DOM, electron, node and really anything that is event driven. Frameworks that exist in Legacy apps like BackboneJS, jQuery (whoever uses it still) is based on events.
You used a native function. The basis was to NOT use a native function. You should have 'thought' actually.
Yes. Thank you. I have to deal with an asshole architect that touts that his apis are always restful... and I always point out that 1) the testing is never completely done, 2) you're exposing endpoints we never use, 3) "yeah man, that should have been done three weeks ago."
I think its great. Some head scratching moments but good to have type safety on some level. I'm now leaning towards typescript in my home projects (even though I was pretty against TS at the start). It's much tighter and although annoying at times, overall works out better. My colleague has been noticing flow memory leaks a lot on Ubuntu, I've not seen them on OSX but the github issues seem to be flooded with people reporting the same thing. No real comment or commitment to fix or investigate from the maintainers though. I know I know, open source means that I could contribute but I know next to nothing about oCaml despite reading through the codebase. Someday... 
Wait I need to know some articles about this, please share!
[Almost ready to start writing code!](https://imgur.com/gallery/3BjKE)
Get Shit Done is a good attitude for an internal API, that doesn't need to provide BC for a decade and is not consumed by a range of clients. The trick is not to dismiss any architecture style outright, but to apply the right solution to the right problem. The vast majority doesn't need REST, but that doesn't meant there's lots of good use-cases. The actual reality is that people never actually have moved on from true RESTful design to cobbling HTTP services together such as yourself, this has actually been the reality right from the moment RESTful design became popularized. I'd say that the biggest catalyst for REST was flickr around 2006(ish?), but their api (which hasn't really changed since) is a farcry from what people consider REST today. It doesn't even use HTTP methods correctly. I can't actually think of a single time where actual REST was popular. Talking about REST certainly was though!
Thanks for the reply. So in this case it is what I want because it is for a project that asks for it. One thing about it still confuses me. I will just copy/paste my reply from the above post: Thanks. One thing still confuses me though. I am supposed to save the state of a settings section - essentially a bunch of toggle switches that I will probably change to checkboxes. I am not sure how to store how a user sets those switches in an object.
REST is not a ground-breaking idea that takes plenty of books to implement. It literally just covers some basic principles that any good design has anyway. Things like: - You have objects (resources). - You can have references to objects (URLs). - You can call methods on objects (HTTP methods). - Those methods and their parameters (headers, body) may implement a common interface (i.e. GET = safe, Cache-Control = caching), which intermediaries can use without knowing the full object API. That's it. Everything else is bullshit that contributes nothing. And in practice the only useful method distinction is "GET vs. non-GET" as the idempotency of PUT and DELETE is simply not *that* useful to intermediaries, despite the *theoretical advantage*, and the distinction between POST and PATCH is literally meaningless to intermediaries. The road to good API design for HTTP is "model according to your domain, not according to what blogs tell you, and just use what you need from the HTTP spec (and you don't need most of it) without breaking it". No books required, just the reference handy. Regarding the "providing BC for a decade", that just requires common sense and practices from software design in general. Nothing specific to "REST". And teaching your clients to learn to update to version NEXT is better than promising them 10 years of BC. Long-term BC is a trap full of technical debt and inability to adapt to changing requirements. Slap a "v2" on that URL and move on.
Take a look at http://lance.gg, it could be a good option.
This all seems fairly short sighted, and also entirely an incomplete definition of REST. Your bullet points seem correct, but 'everything else is bullshit that contributes nothing' is not really a great start to having a conversation about this.
You are running jquery UI code before it is loaded, try running your code inside the $(document).ready function, I tried that in your codepen and got it working.
The most valuable resources are IETF, WHATWG and W3C, as you will be frequently needing to see the intent behind a specific part of a given specification you'll be implementing. Everything else is practice, Googling and also I can recommend the #web #webdev channels on Freenode and any channels related to the languages you code in. Don't get caught up in blog snobbery telling you what's wrong and what's right "just because". Seek the reasons behind a given rule, and if the reasons are poor, ignore it. If the reasons are good, follow it. 
RESTful is important but certainly not so complex has to require 35 sources
You mostly summed it up, more concise than I did. To clarify your last two points: &gt; very incomplete definition of REST These are just two smallish things, but I don't think you can't really talk about REST without also talking about transferring full resource state, or hypermedia. &gt; I was hoping you'd share what some of those good ideas are. One example here might be that it might be good for someone starting out with this to use OAuth2 instead of rolling their own auth. But if you want a list, maybe you should just read some more books about building good APIs ;) (please take that last sentence as tongue in cheek, not looking for a fight!)
RESTful design: 1839 must-read books, after which you still won't have any idea what RESTful means.
"do your post and get routes like this" THE END
He should really pass buttons as children components instead of button props
I'm not annoyed, I was just hoping there's some substance behind your critique, so we can all learn. I guess we'll remain ignorant on the topic.
Use the arrow keys on the DOM itself in the element inspector
Nope &gt; The original derivation of the name Babel (also the Hebrew name for Babylon) is uncertain, but it may come from bab-ilum, meaning "gate of God."[11] According to the Bible, the city received the name "Babel" from the Hebrew word balal, meaning to jumble or to confuse.
 class A {} class B extends A { constructor(...args) { var _temp; return _temp = super(...args), this.b = 5, _temp; } } See `return _temp = super(...args), this.b = 5, _temp;` ? It returns last element - `_temp`, not `super()`
The short cut is Ctrl+Shift+C (I think? It's in the context menu) to automatically switch to the "inspect element" mode. Whatever you click on after that will be focused in the element inspector. Saves a click. 
You possibly didn't get the subtext of my post. How is Crockery able to license json, when it's a expression of javascript already. Is he claiming he owns it?
Wpf is that supposed to mean
Use this for inspect mode: https://i.imgur.com/zmkXwE6.png
I'm saying babble comes frome Babel not the other way around. The hebrew word is pronounced the same.
I love me some REST-ful, HATEOS compliant APIs. I ended up with an information degree so I enjoy semantic and machine readable APIs. But I will definitely echo the sentiment on GraphQL and Falcor. Virtual JSON graphs are the shit for read-only APIs! You have practically a natural language protocol between client and server, "Give me some data that looks like this: {...}." and the server understands, giving you exactly what you want. And since the data is read only, you can distribute your endpoints like a CDN for crazy performance. Yes the implementations are in flux right now but distributed read is solid.
I think GraphQL is the future for rapid dev internally when your front end and back end teams are separate. It makes it a lot easier for the client side coders to just craft the representation they want, rather then having the backend team extend the internal API or make numerous calls. I don't think it's super suitable for publicly consumable APIs. It seems too clunky to do CRUD to me and it's difficult to get a sense of the full depth of what the API can do. I'm still with REST on that one. But I've been meaning to take a closer look at GitHub's public GraphQL API. If anyone can sort out the quirks I hope it would be them. 
Awesome! Thank you Crowesco, MWrathDev and cdtinney!
Yup, but the last element `_temp` is value returned from super `_temp = super(...args)`. The same as statement `return 1,2,3;` will return 3;
Yeah, it's good for performance as well (no need to query elements after creating them). RE:DOM performs really well: https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts-results/table.html Still waiting for PR to turn that 'remove row' to green as well! https://github.com/krausest/js-framework-benchmark/pull/197 Another benchmark: http://mathieuancelin.github.io/js-repaint-perfs/ Also waiting PR to get even better results: https://github.com/mathieuancelin/js-repaint-perfs/pull/118
What does that mean? We can use babel for conmpiling typescript?
Step into super and take a look it will make more sense. Basically super returns this. So we call super, modify this, then return this.
This is great news! I hope this is the first step towards getting TypeScript becoming an integral part of the JS community, including being able to use ESLint with TypeScript rather than having to use TSLint. I'm heavily invested in Babel (even got some custom plugins to deal with specific parts of our codebase) and we use ESLint across all our projects. Switching all our tooling to adopt TS is just not an option. The divide between the TS ecosystem and Babel's already had me eyeing TS' comment syntax as a possible way to be able to use both (and no, transpiling through both in serial would be unacceptable from a performance perspective), but this could also open up a lot of opportunities.
If you don't need this doesn't mean that no one else would not need it. In my project this combination is used extensively for project's tasks e.g. release/tag, creating components, managing and generating configs (dev, test, prod), api mocking etc.
Published! Also, Typescript and Flow do offer tagged unions, but: * They have this weird associated-constant-on-a-plain-union syntax, and are generally not as ergonomic as I'd like them to be. * They are statically typed, which is fine, but not for my use case. * I prefer to keep the knowledge needed to read the code minimal, so I try to avoid languages other than JavaScript as much as possible on the front-end.
Could you provide a good resource for integrating flow with react/redux ? There are many blog posts on the internet (including in flow documentation) for simple examples, but there are almost none, for complex examples (like typing for redux connect components, or bindactionCreators). perhaps you have a linkedin, email you could share, as I am extremely interested in this topic.
Not quite _that_ simple...
The first step in fighting the "FE Fatigue" is to stop banging on about it. It doesn't exist, FE is as complicated as any other field of development.
Modern JavaScript with optional type definitions compiled to old JavaScript. 
JavaScript with static types. Transpiles to any version JavaScript
Not sure why you'd call anything in Angular2 proprietary. It's all web apis naturally. But yeah, you can achieve everything in all of them. The answer to which is better is "it depends"
If it means that one day a babel plugin can evaluate TS types instead of TS taking over the buildsystem and insisting to carry out tasks that other tools would be better at, then that would be fantastic. 
[Wikipedia has an answer](https://en.m.wikipedia.org/wiki/TypeScript) 
**TypeScript** TypeScript is a free and open-source programming language developed and maintained by Microsoft. It is a strict syntactical superset of JavaScript, and adds optional static typing to the language. Anders Hejlsberg, lead architect of C# and creator of Delphi and Turbo Pascal, has worked on the development of TypeScript. TypeScript may be used to develop JavaScript applications for client-side or server-side (Node.js) execution. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/javascript/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
I don't see any mention of raising an issue in reactstrap about the webpack configuration issue, what's that all about?
The only resource you need is the HTTP spec and, helpfully, Fielding's thesis. Anything else likely is wrong.
Great! Maybe I can get jscodeshift to work with TS then. Might even work our of the box now.
React is a big enough mess already. This is sheer madness. 
I wouldn't exactly say option type definitions. Unless you're considering 'any' to be optional, but if you're using that heavily, why bother to use TS?
I am using viz https://github.com/mdaines/viz.js 
Well, they do have a history of ignoring the community. Remember when TS blocked npm because they made their resolver work differently? Today it interferes with several tools. As for latest features, it takes Microsoft at least 2 years longer than Babel and TS is overall pretty much always behind the language and its many drafts. Async and spread were commonplace for instance 2/3 years ago, TS only got it recently and still struggles with spread edge cases. Nothing against types or supersets, but it kind of does cause fragmentation when a specific tool begins to take over things it shouldn't be involved in. 
Pretty much all over the internet. I don't want to curb your enthusiasm, but you need to stop looking for the perfect tutorial for you, you won't find it before you lose your enthusiasm. Instead, focus on a result you'd love. For example a puzzle game, a to do app, an online recipe list. Once you decide, you just google for a tutorial and do it. Don't look for the bestest most perfectest simple tutorial for the sake of doing a tutorial, because it will kill your appetite for doing things. 
&gt; because it breaks a fundamental rule of programming - the separation of concerns. It does not do this at all and i think there is a misunderstanding on your part. React was *made* to separate concerns. You are referring to presentational logic: conditions and loops. Angular has it disguised as mark up code and ternary look-alikes, or else you couldn't dynamically structure your component. React can use Javascript naturally, that's the only difference in that regard. In React a view is literally a function of state `v = f(s)`, it is a simple and elegant approach and separates concerns in a way that isn't possible in previous paradigms, [because state flows into the component in a unidirectional, ordered way, which is the opposite of how previous patterns have dealt with state](http://iweave.com/assets/blog/mvc_v_flux.png). 
~~It doesn't matter what is returned from a class constructor. When you `new` a class constructor you will always get an instance of that class back.~~ Edit: why am I getting down voted? Edit 2: I'm totally wrong. Ignore me.
To be fair I'd much rather have a diversity than homogenity. Especially since it's a pretty big community, there should be more than enough room for some diversity
[removed]
such a good article but one snafu; the shot out to typescript. If you look at the graphs in his own you can easily see that only dynamic languages are growing. All the languages burdened with static types are slowly receding. I see no call for JS to join the receding static legions. 
But these logical operations are not disguised as markup at all. They are written in the markup as *ngIf or *ngFor - very clearly marked out as Angular structural directives, and beautifully simple to use. Nor does React use Javascript naturally. It uses JSX. 
I enjoyed this article. Gave an overview of JS frameworks over the years.
I really, really wish I understood what you mean. I feel I'm missing out on so much in life. Are you just showing your appreciation of IIFE or is there a punchline to this I'm missing. My world is such a mess right now thanks to you. 
&gt; Angular is the industry standard. that might have been true for angular 1. Angular 2 is not by any metric an industry standard. Many more corporations use react than angular 2/4. A lot of those still running on angular 1 will migrate their apps to react. Angular 2/4 already lost.
These features still aren't as stable as what Babel's delivered two years ago. The argument doesn't hold water because sometimes they do pick newer drafts, sometimes they don't. The reality is probably closer to Babel having a larger community to build, use and reiterate upon those features. There's also a close relationship between Babel and TC39. The real problem comes with Microsoft playing gate-keeper for the Javascript language. Flow proves without a shadow of doubt that you can solve types without hijacking the buildsystem.
&gt; Angular uses a runtime parser to interpret presentational logic, and it is inherently problematic because it is non-standard, always changing and very limited How many times has the parser changed and what exactly are it's limitations? 
4/10 shitpost?
javascript.info 
To apply you must build! Glad to see you made a calculator, try something else now like tic tac toe or a twitter bot
cold boot is approx 3.5min, watch is 10 to 90sec, it's vuejs-1 and yes, it is "kinda big" :)
Yeah I just looked through that quick and they definitely are skipping some steps.. But the reason that login() isn't working is because you aren't exporting login, you are exporting the Auth class. So it would be more like this import Auth from '../../Auth/Auth.js'; ... Auth.login(); And as far as them calling this.props.auth.login() later, they're just assuming that you'll be importing the Auth class in a top level component and passing auth down as props.
Stop comparing React and Angular. React is a library, Angular is a framework.
I'm also new to JS, and recently found this. Especially coming from the Moz network, a good tutorial: https://developer.mozilla.org/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript
Yes. Why it wouldn't?
Is the instance not needed? import Auth let auth = new Auth() auth.login() if not why bother with class here at all its just confusing for no reason
https://scrimba.com/ I don't recall where I stumbled upon this website, but it's quite neat. You may benefit from it. In a nutshell, it's an audiofile that is synced to a recording of the presenter's interaction with a JS sandbox as he/she talks. The unique aspect of Scrimba is that it's a live demo of actual HTML elements; you can pause the playback at any time, fiddle around with what the presentation has made so far, test that out, then hit play and it will resume in the state it was in before you stopped playback.
What? Flow is [built right into Babel](https://github.com/Microsoft/TypeScript/issues/11441#issuecomment-252231866).
Good article
[removed]
Can we please stop calling class properties, decorators, and object spread "ES7"? ES6 was released in 2015, ES7 was released in 2016, and ES8 was released _yesterday_. None of them include class properties.
Yeah it seems most "rest" APIs never get past the second level in terms of the maturity measure. In most cases it's just RPC type calls and not even resources.
Basically just start building whatever you want and when you have troubles ask a friend, here or stackoverflow. This is the fastest way to get into programming. For example you want to create a TO-DO app. You start by searching how to create a single text box, when how to add input field, then how to make the button submit the value of text box and so on. When you learn the basics, start reading/contributing to open source projects in Github for example.
Articles like this do nothing other than to elevate inflated opinions.
Oh snap! You are correct. I'm sorry.
&gt; 3 out of the top 5 teach Angular 2 That could also prove, Angular needs more training and/or its more complicated than the rest :) Correlation doesnt mean causality ;) Also, 15 react courses to angular 2 12 here: * https://egghead.io/technologies/react * https://egghead.io/technologies/angular2 And this * https://github.com/angular/angular 23 000 stars * https://github.com/facebook/react 69 000 stars * https://github.com/vuejs/vue 58 000 stars * https://github.com/emberjs/ember.js/ 18 000 stars
FWIW - I interview Node.js devs pretty often and I don't believe I've ever noticed or asked about a cert. Wouldn't interest me.
I think you might be (mostly) wrong. But like, in a good way! If this parser support is spitting out the same AST nodes, merely augmented with the type annotation information, then the code emitters can be none the wiser and work like normal. The only exceptions I can think of are namespaces and enumerations which can be avoided in your codebase.
It calls `_curry1` with a _function_ that takes a _b. Where that function goes, I don't want to trace any further. The ramda internals are... complex. How long did it take you to find where this function is actually defined? 😂 
FYI you can already use TypeScript to do your transpilation instead of Babel.
ES-latest instead maybe?
When waiting data from remote, use this to improve visual experience.
This is why I like Aurelia, its much lighter in terms of speed and amount of code, while still being a fully flared framework like Angular. Sure theres React/Redux Vue/Vuex but why do that setup when you can literally go `au new` hit enter about 4 times and your app is ready to code and build. 
Ya seriously, I don't see many Bachelor's theses. The writing isn't bad.
Makes sense, I can see how that might cause some problems. The good news is that Flow has a very active issues page, so maybe you can raise this concern there?
Good points. Although I would say that Flow and Typescript are *not* different languages. They just add types to Javascript.
What are the advantages of using Babel after TSC?
If you want to stand above the average *crappy* JavaScript developer learn these things: * walk the DOM. Yes, it is absolutely still a valued skill. http://prettydiff.com/guide/unrelated_dom.xhtml * write a static analysis tool. This could be a lint tool, a code beautifier, or some kind of niche reporting tool. Doing this will teach you how to parse code and so you will learn about all the features of the code you are parsing. * get confident with micro-data. Storing, retrieving, serving over a wire, transforming, and encapsulating the data in various formats. * write a recursive file-system utility for Node.js. You will learn a bit about Node and its file system library, but more importantly you will learn about managing asynchronous event driven execution and how to untangle problems when that code runs recursively. If you are happily waiting around for a magic open source tool to arrive to do many of these tasks for you then you aren't a strong developer.
They are competing within the same domain in the technology stack.
The best is just to call them ECMAScript proposals. "ES-latest" still implies that they have landed in the latest version of the specification. Until they land in a spec, they are free to change and break people's code, and many people play way too fast and loose with that.
To compare React to Angular, you have to define what exactly is the React stack and there's lots of choices at every single layer. Do you use Redux or MobX or just setState calls? Are your objects immutable or not? Do you use sagas and thunks? Which router do you use? Do you practice HoC or do you use subclassing? React has a lot of options and that's its strength, but if you are an adherent to one of the options (e.g. Redux/React Router/Falcour) then you may not be an expert in another (e.g. MobX/CrossRoads/GraphQL). Angular on the other hand is prescriptive.
Meh, I still use Knockout.js... does everything I need.
&gt; Articles like this are are kind of like identity politics for programmers. 100% this (and that is the vast majority of development/programming articles). The value comes in discovering views/perspectives that might differ from yours, i.e., even if you don't agree with an article, you still might learn something from it or have some takeaway. And it might not be from the article itself, it could be from an insightful comment from people discussing the article. &gt;At this point, I don't think it's especially likely that a project will fail because you chose Angular over React, or vice versa. From my experience, projects fail because of what no one ever mentions or reads about in identity politics project failure articles.....Projects fail because they don't have any success criteria identified.
Seems like this is done by [babel-plugin-transform-class-properties](https://github.com/babel/babel/tree/master/packages/babel-plugin-transform-class-properties). You're right in that calling `super()` gives you the correct `this` context and it's normally implicitly returned, this just happens to be done explicitely. You'll see that if you [add your own constructor](https://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=false&amp;presets=stage-2&amp;targets=&amp;browsers=&amp;builtIns=false&amp;debug=false&amp;code_lz=MYGwhgzhAECC0G9oF8BQrSRgIWgUwA8AXPAOwBMZ4FVpoAjaAXmgFYBuW6L4Ae1IhEATgFdgRXkIAUASkRc6EEQAc80mZzp0iACwCWEAHRhm0AEyaUqNBn4ReIPIZC8A5lNJ4A7tGyzjADTQnj5-Mob0GkA) makes it output something a bit more expected, so it's only in the case that you don't provide a constructor. I guess [this part](https://github.com/babel/babel/blob/master/packages/babel-plugin-transform-class-properties/src/index.js#L94) of the Babel plugin is responsible for giving you that funky transpiled code.
Your knowledge, experience, and portfolio are vastly superior than a certificate. Spend your money and time on learning resources to further improve your knowledge and skills.
A pat on the back and the ability to actually answer interview questions and do good work, I suppose.
With tools like Babel it isn't much of a problem at all, the worst that will happen is you may have to do some refactoring to bring your code back in line with the spec, and that's only if the feature gets completely canned. Once a feature has made it to stage 2 the standards committee expects it to become a standard, that's also the point at which syntax gets decided too. Facebook ships React Native with some stage 2 proposals working by default, this gives me a lot of confidence when using stage 2 proposals. Generally stage 2 is when you can consider using a feature.
lol, leave it to a web dev to SASS someone out of style ;)
you can try wrapping `connection.play` in a `try { ... } catch` block. try { connection.play(stream + filename + mp3); } catch (e) { console.error(e); }
I'm not saying don't use them, by all means do, my concern is purely that making it sound like part of the standard is a mistake. Sure, there is a good chance of things making it, but it isn't a guarantee, and it might not have the identical behavior. Decorators are a great example. The community has built tons of tooling around the current implementation via Babel and Typescript, and now the spec is stage 2, but the version everyone is using is the old one. How many average users will know that the syntax they are using isn't the stage 2 spec? When the spec does actually land, how many people are going to be confused out of their minds by all the tutorials out there written for the old version? Aggressive adoption of things that haven't officially been accepted into the spec is a risk. If it is a risk you want to take for improved readability, go for it, but we shouldn't pretend that things are part of the spec when they aren't.
Looks like it can't find the file. ¯\\\_(ツ)_/¯ Are you sure you're executing the script in the same dir that `./data` exists in?
The best way for you to prove your skills is to showcase something you built with node
it is as if node developers don't know/care about security.
pwnd
Can you post all the relevant HTML so that it can be reproduced? You say the placeholder text "does not appear," but what *does* appear instead?
Keep building stuff is the best method. Calculators, small games, a tool that you would like to have or make. Make sure you understand concepts like: - Closures - Hoisting - Callbacks - Event loop - Promises - "this" Just try to understand them one at the time, make a second and a third calculator if need be focusing on one of those above that you feel you don't have a grasp yet. Focus on one since some can be overwhelming. Do a project using a public API like the ones [here](https://github.com/toddmotto/public-apis) You can also solve some katas (challenges) like this ones: [Coding game](https://www.codingame.com/) [Code wars](https://www.codewars.com/) And go back to your older projects from time to time, go to the code of that first calculator a week from now after practising and try to make it better with your new found knowledge, that gives you insight and a sense of progress.
Or here is a live link: https://jasonbwelsh.github.io/web-app-dashboard/
This is really cool but you need more text explaining wtf is hold. Took me a while to get it. I usually call this a loading state
in webpack you can use tsc as a fast typechecker during dev, then bolt on babel in a prod build to take care of browser coverage.
Hahahahhaha, my SO just cleaned the house before I filmed the video :D
To put things in perspective, we have a semi large project and it has 3300 files. If the compilation time growth is linear, that would equate to 18s before we see a reload. This *is* unacceptable from a performance perspective. 
Just as as a heads up, TypeScript now supports types in `.js` files using JSDoc comments if you're interested in that. Just add a `// @ts-check` comment to the top of your `.js` file and TypeScript can work with it (or add `allowJs` &amp; `checkJs` to your `tsconfig.json`).
You get a certificate of completion though which you could put on your LinkedIn
Ok that makes sense. I am not sure how to load the value though. Could I store a reference to the select options as a node list in a variable and then set timeZone.value = option[0] or something like that? 
I think this is all you need to do: // time zone select box var timeZone = JSON.parse(localStorage.getItem('timeZone')); if (timeZone) { document.getElementById('timeZone').value = timeZone; }
I think the issue is that most certs are either outdated or easily gamed by studying for the test rather than knowing the material. I have been a VP at a large company and worked in several startups When hiring I never once looked for certifications; in fact if someone had little experience but a ton of certs, I would ask where their portfolio was. Showing me you can build something rather than showing me you can pass a test has been a better indicator for job quality, at least in my experience. 
Being able to leverage Babel's rich ecosystem. Nothing like babel-preset-env exists for Typescript for example.
You could comment this on the article itself ☺. Thanks for reading
&gt; Remember when TS blocked npm because they made their resolver work differently? Nope, I don't remember this, and I'm on the team. What are you referring to?
Wtf is the point of a certificate? Build something cool and useful. That's the best certificate to have.
While I totally agree certs don't prove everything, portfolio is incredibly limiting as well. If someone works primarily for others, their portfolio can be proprietary. Or, it was part of a team and you can't tell if the pixel perfection was their doing or the good guy that stayed on the team. Honestly, my favorite way to find a candidate has been standard interview for any scary marks, then move to a contract-to-hire position. That is like an extended interview for both parties, where both people get value from it. It is also easy to bail early (on both sides) if you feel the person isn't keeping up.
I'm sorry but you're going to have to figure that part on your own. Javascript Allongé is a great intro to JS: https://leanpub.com/javascriptallongesix/read
You can either: * Use [Babel](https://babeljs.io/) to transpile the code. * Use [TypeScript](http://www.typescriptlang.org/) instead of JavaScript. * Wait for [Node to support `import`/`export`](http://2ality.com/2017/05/es-module-specifiers.html).
What will you do with your files then? Concatenate them? You kinda need a module system if you don't want your file to pollute each other scopes. Webpack 3 does scope hoisting to get around that, but I don't you'll be able to get rid of the runtime altogether.
checkout my nodejs boilerplate https://github.com/francishero/my-nodejs-boilerplate Maybe you can use it as an example
But that would save me from repeating it. I think thats good. A few mutations isn't the end of the world. What do you think of removing lodash and implementing the countBy function? Is that worth it or just nitpicky? 
Hey it could be worse... he could have suggested you use Zend. - Former PHP developer #657 x10^12
Just create the function on the component and output to an array. If you need to use it in multiple components, abstract the function to a helper service. I don't understand what is difficult about this. 
Well in general I think you should know at least one programming language to a beginner-intermediate level before tackling a framework-ish library like this. Preferably javascript, because it is p5`js`. If you're dedicated you'll learn as you go anyways. But honestly there's only one way to find out, so if you want to do it then go ahead. 
Well put. One more benefit of jsx over custom markup is in tooling. This may not be true in earlier days of React, when jsx is not supported by most tools. However, these days you have babel, eslint, prettier etc that analyzes, checks and formats your code at "compile" time, facilitating a very pleasant dev workflow. For example: class ComponentWitTypo extends Component { } class SomeOtherComponent extends Component { render() { return &lt;ComponentWithTypo /&gt; } } This can be caught at build/compile time by eslint, as ComponentWithTypo is just a undeclared variable in React.createElement(ComponentWithTypo, ..) calls. Compared with angular, @Directive({ selector: 'component-wit-typo' }) class ComponentWitTypo { } // in template &lt;component-with-typo&gt;..&lt;/component-with-typo&gt; The selector used to connect markup and js world is a fragile string, and error will only be caught at runtime. Similarly, any custom directive used in templates are just random strings that most js based tools don't and cannot understand. Angular team may ship custom tools to assist static analysis - but these tools are inherently tied to angular internal apis and will not be able to take advantage of any javascript based tooling. In general, jsx is much stricter than overly forgiving HTML or any markup - and syntax errors are caught much sooner; when it transpiles, you are at least confident your render methods are syntactically valid javascript. With Angular templates, it's just blobs of strings that may or may not fail bootstrap process when your app starts running in the browser. In addition, react components / elements being just javascript values help tremendously in testing. Your can run all your unit tests in a nodejs environment - very easy to integrate into your CI setup (see enzyme shallow rendering, jest snapshot testing etc). With angular, you need karma / headless browsers to do any serious testing on templates and ui: both more complex and time consuming. Furthermore, angular being java-like, uses mutable objects, DI and stateful servies heavily; these things typically needs mocking and wiring to properly unit test. In a typical react/redux setup, most of the heavy lifting is done using pure functions, from state management to declarative views. You never need complex setup / teardown, mocking nor do you need to worry what zones you code is running in. 
Have you looked at browserify-hmr? Also budo as a local dev server. I have [an example](https://github.com/spacejack/mithril-browserify-ts-budo).
Yup. I can honestly say that on all the dev teams I've worked on, certificates won't help a candidate. It's great that you have them and won't necessarily hurt you, but most shops would rather see code you've written, do a code kata, etc to get a feel for who you are as a dev.
1.) Teaches mongo/ose as a solution to anything (it isn't). 2.) Teaches socket.io as the end all be all of websockets (it isn't). 3.) Teaches JWT as an alternative to sessions (it isn't AND you're adding an attack vector.) This is why boot camps are bad, kids. 
Rails propelled ruby until other languages caught up. PHP is just bad, but it was early to the scene. But yes, python and JS are on a streak right now. It will be interesting to see how it goes. Personally, I think individuals and enterprises are simply realizing the benefits of full-stack RAD, and not thinking too deeply about philosophy. I know one startup that was less pragmatic and highly philosophical and went with haskell. Of all the startups Ive ever observed, they spent the most time fighting their tools of any. Every second discussion wasnt about business problems but about haskell problems. Its not verbosity; its typosity that kills, imo.
In this case `connection` follow's Node's standard `EventEmitter` pattern and emits an `error` event, so you need to add connection.on("error", function(err){ // Do something about the error maybe? }); By adding the callback, it will stop throwing the exception. Whether you actually do something in the callback is up to you.
so you strongly recommend learning React over Ember or Angular 2 today in 2017 ?
Touché
&gt; A certificate will carry more weight with a fortune 50 company [No it won't](https://www.quora.com/Are-certifications-for-software-engineers-worth-it) &gt;The "elite" software companies -- Microsoft, Google, Amazon, etc -- are generally not neutral about certifications for software engineers; they're actually negative. Yes, that's right. If you have a certification and you're applying to one of those companies, just don't list it on your resume.
I am neither a php dev nor did I work with laravel, but I am a bit confused. Why should a framework mess with your SPA? If I understand you right you are doing REST anyway, so you can easily split your backend and frontend into two completely separate apps and repositories.
In my experience, yes, it really freaking gets in the way of everything. Their idea of how to build Vue templates is literal insanity from what I can tell. If there's any way you can set your stuff up completely separately and then consume the laravel stuff as an api that's what I would do.
So you just configured your .babelrc and it worked?
I have 2 independent files. One of them is applied to all pages, but the second is loaded just in one specific page. These files doesn't have module dependencies because the libraries are loaded from CDNs and are not expressed in modules (for that I don't need the module system). Or I should convert it into modules? If I do that, I have to add one additional file to require the modules and call the unique function in each of them. That's strange (I mean, I can just justify and concatenate in this case).
I'm not sure how this is special. 
If you add your email to the `.gitconfig` on your local machine your commits would be attributed to you on your profile/repos!
In Firefox 53.0.2 (64-bit) it was faster with a service worker. With: 34342 ms. Without: 35266 ms.
This has really been bugging me, thanks for the tip!
Laravel is Rails inspired, so it comes with its own asset processing pipeline. The previous version used one built on top of Gulp, while the new version uses Webpack to support Vue components. In my experience the integration with the framework is nice, but the pipeline is generally less flexible than the build system it is built on top of, which leads to problem like the OP is complaining about. The complaint is a little misguided though IMO - the Vue integration is meant for traditional web apps that want to drop Vue components into the page without going full SPA. 
Hi, I have updated the readme file to explaining what is hold. 
Same. I assume you typically put node behind nginx, terminate SSL there or your load balancer anyway? I've never run node in production.
Looks and feels great on mobile! Will try on desktop later. The animation shutter revealing the correct answers was slick as well. Not too fond of the button:focus boxes around the social media and info buttons, looks strange around the circular buttons. If either omit, or make them circular as well. Also, when clicking a social media button, all three increase opacity. Is this intended?
It doesn't seem like you need to bundle your files, so if you don't want the webpack runtime a straightforward solution is to not use webpack. I know it is not what you asked for but bundling and tracking dependencies is what webpack does so if you don't have any there is not much for webpack to do here. You can use uglifyjs directly if this is all you need. If you're dead set on using webpack, as it does have many perks indeed, you can try to write a bash script that will strip the runtime before shipping. The first thing to do would be to put most if it in its own file using code-splitting. Then in the output file containing your code you can try to remove the outer closure with some text-processing commands. It's hackish though.
Thank you that worked.
Me neither! I've just set it up to test some build stuff out in the wild and get my head around how it's all deployed. Learn by breaking. :D Nginx deploy looks like a one clicker, I think the cert goes with it but there also appears to be a global set up for one - I'd guess that's the load balancer side of it? Only logged in for first time today... loads to explore. Looks like there goes my weekend. :D 
Which keyboard does Avi use?
Try this: Var d = (!!x)?new Date(x): new Date();
Just look up The Coding Train on YouTube and start watching his p5.js stuff :) He'll teach you from the ground up.
I'm relatively sure you're talking about Node-style module resolution. If so, I understand the frustration, but keep in mind that relatively nacent technologies don't always have a strategy in mind for package management. It was especially not as clear-cut early on as to what the challenges would be in the problem space, and what direction the community was moving towards. There definitely was friction with tsd and typings and the like - I was typically the guy helping a lot of users with this over Gitter, and it wasn't pretty. The current `@types` system works a lot better and has served users really well. Obviously with the benefit of hindsight, we would've jumped on the issue *way* earlier on given a second chance.
The notion that "Java wasn't intended to deal with trees", one of the most versatile and pervasive data structures, is kind of cute. &gt; Javascript on the other hand was created for the sole purpose to interface with the DOM. Which is in fact a tree, and the language doesn't provide anything to work with at that level. How about objects with string addressable keys? That is a high level concept that definitely simplifies dealing with arbitrary tree structures. Same with reference counting and garbage collection; it simplifies working with tree structures. For reference, here's code to create a simple tree structure with mixed arity, arbitrary keyed nodes and number leaves in JS: var tree = { c1: {a: 10, b: 20}, c2: {x: 60} }; In C, from the top of my head: struct node; union pdata { struct node *children; int value; }; struct node { char *name; union pdata *content; int nchildren; }; main(void) { struct node tree; tree.name = "tree"; tree.nchildren = 2; tree.content.children = calloc(2, sizeof (struct node)); tree.content.children[0].name = "c1"; tree.content.children[0].nchildren = 2; tree.content.children[0].content.children = calloc(2, sizeof (struct node)); tree.content.children[0].content.children[0].name = "a"; tree.content.children[0].content.children[0].nchildren = 0; tree.content.children[0].content.children[0].content.value = 10; tree.content.children[0].content.children[1].name = "b"; tree.content.children[0].content.children[1].nchildren = 0; tree.content.children[0].content.children[1].content.value = 20; tree.content.children[1].name = "c2"; tree.content.children[1].nchildren = 1; tree.content.children[1].content.children = calloc(1, sizeof (struct node)); tree.content.children[1].content.children[0].name = "x"; tree.content.children[1].content.children[0].nchildren = 0; tree.content.children[1].content.children[0].content.value = 60; } Let's traverse the tree to a given leaf! JS: var value = tree.c1.b; C: int traverse(struct node *tree, char **path) { int i; if (tree-&gt;nchildren == 0) return tree-&gt;content.value; for (i = 0; i &lt; tree-&gt;nchildren) { if (0 == strcmp(path[0], tree-&gt;content.children[i]) return traverse(tree-&gt;content.children[i], &amp;(path[1])); } return MAX_INT; // not found } ... char *path[2] = {"c1", "b"}; traverse(&amp;tree, path); Let's free the tree! JS: // You just don't refer to it C (assuming it's all heap allocated): void tree_free(struct node *tree) { for(i = 0; i &lt; tree-&gt;nchildren; i++) tree_free(tree-&gt;content.children[i]); free(tree-&gt;name); free(tree); } ... tree_free(tree); So in conclusion you have to be pretty fucking dense to believe that with regards to dealing with tree structures, Javascript only has "your typical generic low level construct which are not suitable for anything beyond C". It's a ridiculous statement which can only be rooted in ignorance. I assume you aren't an idiot and that you just haven't used C ever in your life. That might explain why you have no idea what "low level" means in computer science.
 new Date(...(x ? [x] : []));
Nope there is webpack there. First run webpack
The !! are actually not necessary.
Babel has a minimal Node example project that does exactly what you are asking for [https://github.com/babel/example-node-server](https://github.com/babel/example-node-server). 
Really like this. Is this fully decentralised or reliant upon any third parties? Thought about some sort of Alexa/Home/similar integration?
It's decentralized. It only relies on my ISP to not kill my internet :D
&gt; The Software shall be used for Good, not Evil. Hm kay, so I have to use BENCODE instead then.
'' is falsy, so you could just do d = x ? new Date(x) : new Date()
Could you care to explain what you mean regarding "slots" and why they are needed for builtin types like Array or Set etc? Or explain what exactly is happening regarding the Set error you posted with ES5
Step-by-step instructions for Sublime Text 3
&gt; And Arduino micros are even less expensive Sometimes people value their time and want to get shit done. Spending a few extra bucks for a platform with the tools you are familiar with to do a hobby project is a sound choice, versus learning a different set of tools just to save a few bucks. If I wanted to do some DIY home automation project for fun and my choices were a *free* microcontroller and a Raspberry Pi for $80, I think I'd still go for the latter, because I enjoy working with the latter more. &gt; with enough power to do the same. How big of a difference do you think it makes in his power bill? &gt; No, he won't be mass producing this. Yeah, that's what I said. He isn't pitching a new home automation platform, it's a DIY project. Efficiency is important, but sometimes you gotta look at project goals and resources, instead of blindly attempting to create the most efficient solution to everything.
Not everyone has developed embedded systems since forever.
meh, i can't find it, that's why i ask here.
https://12factor.net
IE has several functions that only work in their browser - apart from the ActiveX calls, there's things like .all (above) that I can't map exactly to non-IE functions (not saying NOBODY can do that - I just mean *I* can't do it). The code absolutely needs a total re-write. But at this time, it's not an option.
Definite thumbs up. Like I said, felt quick and snappy, and looked great!
&gt; I know its popular to see verbosity as the problem but I think there is a distinct possibility its not that at all. Consider basic operators. In JavaScript comparisons are made with `==` and `===`. WTF? Every school child knows from math that comparisons are made with `=`. If languages were less verbose, in all respects, then developers would have less of an excuse to dick around with conventions and design patterns. When you take all the bullshit out, remove the things known to be broken, and remove all the opportunities for holy war conversations you are left with actual work to do. At that point it becomes far more clear who does real work and solves real problems versus imposters who are simply spinning their wheels. My thinking is that less is more, and that doesn't just apply to syntax, types, or inheritance. There is a saying that if you give a stupid person too much string they will hang themselves with it. If you give people too little string only the competent people will make it work.
And you proved my point. Not Javascript nor C are suitable for working with tree shaped data structures (not even close to work as something specialized, e.g the DOM). All you did was to resort to domain unrelated abstractions and cruft (structs, functions, temporaries, etc) for an ad-hoc runtime implementation of tree constructs. Now, let start with you implementing pattern matching as a linguistic abstraction in C or JS. Oh, wait... you can't.
Fair point, I will change the icon for the selected answer so it does not look like it is a correct answer. Thanks for checking it out.
That was python's maxim as well; make it so there is only "one way to do it" and it would automatically be the right way. Even they gave up on combining assignment and equality tests, You have to go pure functional for that, and pure functional is much harder for the average person to grok... Personally, I think the problem is the other direction; languages hide too much. Even C provides certain helpers, such as "gethostbyname" which i think shove too much down too low and results in poor code. One of the reasons Ive always liked JS is because it shoved async in the programmers face rather than try to hide it under the covers. While people gripe about it, they also end up getting very good results sometimes without realizing why. JS really the first language to do so that I'm aware of; there is very little if any blocking functionality out of the box. So while i agree giving pointless features is negative, at the same time the biggest problem is hiding some things which need to be surfaced. Yes they can be a little tougher to understand at first, but the benefits are clear. Anyway, clearly you disagree, so best of luck in your quest.
https://facebook.github.io/react-native/
&gt; the arguments passed to the function spell out i, s, o, g, r, a, m, is a “term for a word or phrase without a repeating letter” This is the only interesting thing about this and it misses the point. Obviously, any list of arguments to a function has to consist of unique, non-repeating items.
yep, you may be right. I will ask them :) Thanks for your help.
It does the job requested up to spec. Everything else is secondary. You can stay in your caves for now embedded system developers, well call on your services when we need real embedded software. Alternatively, maybe you should not read content from /r/javascript.
Hrm, so far it looke more verbose than js in every way?? Store["modifyType"]((){ let(myFunction: &lt;sample: "string"&gt; { return sample.slice(0, 3); }); return myFunction; }, "short string factory"); vs str =&gt; str.slice(0,3)
You need to install [node](https://nodejs.org/en/) first and foremost. Install the latest. A nice editor would be helpful as well, probably along the lines of Atom, Visual Studio Code or Sublime. Now that you have node you should be able to access the `npm` command in your terminal, javascripts package manager. get [create-react-native-app](https://github.com/react-community/create-react-native-app) next and go through all the steps. You should see your first react native app running on your phone now. You can already play around, change values, etc. If you have that running i would suggest [egghead as a learning resource for react-native](https://egghead.io/courses/react-native-fundamentals). If you haven't used react at all before, [take the lessons for generic react first](https://egghead.io/courses/react-fundamentals). As for Javascript in general, it's not much different then what you already know. [There are good egghead lessons](https://egghead.io/courses/learn-es6-ecmascript-2015) for that as well. The difference is that javascript depends heavily on build tools and meta programming, things that seem pretty crazy if you come from other languages. That's going to be the tough thing to swallow, not the language itself.
Why recursive?
The first part looked interesting but I don't get the second part. With regards to your example: constructor(){ // accessing "this" here before `super()` will throw because it doesn't exist yet super(); // calls parent, which allocates and initializes "this" // Now here "this" is initialized with whatever object the parent class created. return this; // or return value from super(), basically these are the same. Babel plugin is doing this, but it shouldn't be necessary while es6 classes implicitly return this at the end of constructor } 
Yea really disappointing click bait, oh the google script executes itself after it downloads? Fascinating 
&gt; Man, it's gonna be fun following your goal posts as you move them about! You may realize my point didn't change a bit since my first posts. &gt; You seem to have the idea that Javascript is a low-level language because it does not map perfectly to the problem domain. Yes! Is a low level language which doesn't map to many domains, one of them being working with the DOM. &gt; Level-ness is a matter of how much the language is abstracted from the code the machine actually ends up executing. And why the domain don't belong on this expansion, again? You are abstracting the code to a higher level that detach itself from the executing code. In a higher level Javascript and C just become IRs. &gt; Not the problem domain. It is, there is not higher level than that.
Excellent effort! Almost there, but missing a piece. The problem is that it only seems to replace first occurrences. For example, when I do "triplets", we get: ["driplets", "triblets", "driplets", "tripletc"] But we're missing words like: ["tripleds", "dripleds"] and so forth. Any idea how to tweak that?
The issue is this looks like a homework assignment and most people don't want to do homework for someone else. But a lot of people are willing to answer specific questions and help if you show that you've made an effort and are just having problems instead of just trying to get someone else to do the work for you from scratch.
It's fun to solve the problem and all, but you shouldn't do someone else's work for them, especially when it seems like a homework problem.
Spoken like a true redditor who comments on things he hasn't a clue what he's talking about.
www.javascript.info A very nice introduction.
Ah, I understand your question now. For "abcdab", and translations {a-&gt;x, x-&gt;y}, I'd want to get: ["abcdab", "xbcdab", "abcdxb", etc] We wouldn't be translating x-&gt;y as a second step. We'd only be operating on the original string. Does that answer make sense relative to your question?
What do you get for with SW vs. without SW when re-loading from cache?
Awesome, I can give that a go and see if it simplifies things! Thanks!
For simple Node projects I always use https://zeit.co/now, but for the past few months I've been building a larger Node app. - Development happens locally inside a Docker container - Push local work to feature branches on GitHub - Push triggers CircleCI builds which run continuous integration tests against the container - Deployment starts with merging a feature branch into master, then making a fresh build of the Docker container, which gets uploaded to AWS' Elastic Container Service and rotated onto one of our servers So far, so good. 
&gt; C might work No, better a hardware description language. &gt; With a macro assembler, I can even create a macro that given the desired motor setting and time will generate the correct sequence of instructions. So you are creating a DSL that map to some higher level domain to be compiled in a lower level representation... sounds familiar. This language is higher level for that domain, assembly isn't. 
&gt; If you have to pick just one tool released over the last few years, what would it be? For me, it’s Prettier. Ah ha ha ha ha! No. It's Babel.
function called swapped takes three args one string, fromChar, toChar returns string function called toSwapString takes two args one string, a array or arrays where the sub array is just two args of from and to chars. Seed ret as an array. Loop the len of toSwapString-&gt;arrayofarrays passing the string and from and to values to swapped and arraypush ret into ret array if it's a string else error/catch.
thanks!
I've been meaning to try out Electron 
Yes. I don't have to but i actually have to know for my job, as i said i like it even complicated, i will be better in time, i hope but what i want to say that things webpack does should be easly done or i could thing, in future, it will be easier. I dont think it will be easier in future, for now. Things are getting complicated over time in web development. We are making it complicated so we can make it easier also.
I always use `create-react-app` but i need to learn webpack. Yes webpack does tons of things but should be easier to work with. But web getting harder over time. By the way thanks for redux link. I need that.
It's extensible and powerful, and the work it does is non-trivial. We aren't making anything too complicated, applications are complex. That's the reality these days. 
&gt; I am arguing against that point, but for whatever reason, you ignore my rebuttal and instead bring up an entirely different point. It wasn't ignored, but classified as irrelevant since Javascript do not provide any meaningful language feature that deal with trees at a higher level (C as well). And your code didn't show otherwise.
Looks great! Only thing I found, on mobile the option font sizes weren't fluid and the text got cut off a bit on question 2. http://i.imgur.com/IhS4Kii.jpg 
According to comments on MSDN, Element.prototype.all is like calling that elements getElementsByTagName method with "*" as argument. However, that returns an HTMLCollection and adding a "src" property to that won't do anything by itself. I recommend to use IE's debugger to figure out what's going on. You'll probably need IE8 or something to run that ancient code. I guess that it only returns a single element (or null) if a string argument (an id) is provided. If this guess is correct, you could replace: var oImage = entity.childNodes[0].all("image"); with: var oImage = entity.childNodes[0].querySelector('#image');
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [prettier/prettier/.../**tests** (master → 3f6a232)](https://github.com/prettier/prettier/tree/3f6a232cea56f60f1ba50cbae2d56f78b36a7699/tests) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply djlzgtq.)^.
QSA returns a NodeList. querySelectorAll("#image")**[0]** would have worked. You were very close indeed. :)
&gt; Why we are making web too complicated? I remember the time before webpack and ast analysis: climbing recursively through folders, regexp contents for script tags, copy stuff to the fs, run more tools over it, replace tags with result, all in very specific order or it would break. It was a hell basically. Before that all of it had to be done manually. I think webpacks loaders are pretty digestible, in your case for instance it's not more than this: { test: /\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] } I've suffered more through quirky edge cases, hot-module-reload, aliases and such things. 
Now it is special!!! You can install it globally with all the plugins and use `eslint -v`
Wowee! This does an excellent job of answering my question. I hadn't considered breaking the problem down in this way. My approach was to generate all combinations with replacements first, but I was getting stuck on the next set of replacements, and the next and so on. Thanks so much for laying this out for me. Separate from my business work, I'm building a free translation app for my local community and this code helps me upgrade its usefulness. You're great Andrew and you should feel great.
Hahahahahahahahahaha... no. Not even close. In fact, I would probably pass on you for that reason alone.
How do you do to have your own prettified format ?
I would not advise getting any W3 schools certificate. The biggest reason is they have a terrible reputation, and it doesn't seem like that will ever change.
No one cares about a certificate. They care about what experience you have. Spend $95 on additional learning material.
\#Standard4Lyfe But in all seriousness, as long as you are using something that enforces a consistent style across your codebase, you are good.
Solid advice. Thank you.
&gt; If you have to pick just one tool released over the last few years, what would it be? &gt; Prettier has been around for less than 6 months JavaScript in a nutshell 
You make it sound like SystemJS, RequireJS, Dojo, browserify, and more didn't exist and webpack was the first to work this way. We haven't done what you're talking about manually in almost a decade.
was expecting this to be more than just `&lt;strong&gt;0&lt;/strong&gt;` :/
Speak for yourself. Unfortunately my work still hasn't even reached the stage of using something like Gulp. But that's fine since we don't minify/concatenate files or use es2015 :-(
Sorry for maybe a dumb question but I'm new to .js. Is prettier and eslint the same type of thing?
needs more web scale: const span = document.createElement('span'); span.style.fontWeight = '700'; span.textContent = '0'; document.body.insertBefore(span, document.body.firstChild);
It's a nth * mth dimension recursion where n is the number of unique characters you want to replace and m is the frequency of that character in the input string. It's horribly inefficient so processing time is going to be ridiculous for any nontrivial set of data. Basically each level n of recursion needs to be called m times for each other n*m pair.
&gt; For this case, I like better the unformatted code. But, frankly, I don’t care, I’ll get used to it. What the author needs is an automated copy editor. That was a painful read with all the mistakes and bad sentence structure.
The web archive has some older copies of w3fools.com if you're interested in why people have mixed feelings about w3schools. Here's an entry point: https://web.archive.org/web/20131221061634/http://www.w3fools.com/
how awesome would everything be if this number was 7,000! /s
Didn't realize you were writing in a foreign language. I don't have the chance to go over it again now, but I may later this evening. I'll DM you what corrections I see. :)
I am curious how they keep track
[This explains it quite well](https://engineering.hexacta.com/why-arent-you-using-prettier-4fe0a77713e8#c490)
ok got it thanks
really? defaulting to FaaS? kind of a shitpost if you ask me, but it doesn't seem satirical.
Hey Reddit, We built Maji Config to give developers a way to host their configuration and allow their applications to dynamically update when config values change. This was borne out of our frustrations with needing to change code, go through code review, and redeploy multiple applications when a single configuration value changed. Now we just update it once and we're all set. We'd love to hear what you think of it!
Make cool shit. Put it on github. That's your cert. 
I did such deconstruction a few weeks ago and was thinking about using something similar in my project, but found even cleaner solution, which is to pass configuration to the script through data attributes, so that it looks like &lt;script src="url" data-param="value"&gt;&lt;/script&gt;. The only issue with my approach is that the script can not be loaded async in IE.
Idk, Webstorm auto formatting works for me...
99% sure it’s just a hard-coded 0.
The amount of keystrokes Prettier saves is unbelievable. Not to mention it gets rid of all the opinionated debates around code formatted. 
At least it's consistent
have you checked in different browsers? ;)
http://floating-point-gui.de/
Chrome and IE are consistent, don't know about anything else, though I imagine Edge would be exactly like IE in every way
Because of https://en.wikipedia.org/wiki/IEEE_754 Affects any language/runtime that uses this standard. see: https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html TL;DR: numbers are hard.
Yep, because people keep asking the same questions, and I've gathered up the info that answers those questions :) It's basically a case of [XKCD's "Today's 10,000"](https://xkcd.com/1053/) in action - odds are the person asking the question doesn't know that these resources exist yet. Also, I've gotten enough positive feedback about the list to show that people appreciate the work I've done on it. Examples: &gt; FYI, your list is awesome. I've been working my way through it not only learning redux but leveling up on ES6 as well. I mean, I thought I knew ES6 pretty well, but after going through part of your list I've found myself going "I didn't know you could do that!" more than once. ([link](https://www.reddit.com/r/reactjs/comments/6jmsgm/how_to_manage_ui_state_with_redux_mark_muskardin/djgqiu0/)) &gt; Your list has been absolutely instrumental in my path towards mastering react/redux. A big thank you for all the hard work. You are multiplying the communities knowledge and we're all improving because of it. ([link](https://news.ycombinator.com/item?id=14602384)) &gt; You made quite an impressive list right there. It will take some time to read it through but I think you’re doing a great service to the React-Redux community. ([link](https://medium.com/@stjepan.golemac/you-made-quite-an-impressive-list-right-there-e729ac374866))
pretty shitty, we would have no innovation and be stuck with jQuery.
OT: That emptyArray function in the header seems kinda useless. I mean, yea, you can now run map or whatever over that array (this doesn't work if there are only slots), but if you do that kind of thing you probably want a generate function instead. function emptyArray(size) { return Array.from(new Array(size)); } console.log(emptyArray(5).map((_, i) =&gt; 2 ** i)); // [1, 2, 4, 8, 16] function generateArray(size, fn) { return Array.from({length: size}, (_, i) =&gt; fn(i)); } console.log(generateArray(5, i =&gt; 2 ** i)); // [1, 2, 4, 8, 16]
That hasn't been my experience at all. 
Pretty good article with a fair comparison between Flow and TypeScript. I currently use Flow but I hope one day the Flow/TypeScript communities can merge together somehow or maybe types can get added to the official spec and be usable under a `'use types'` pragma or something.
Damn, could this have the potential to make cheats? 
lambda is webscale
The joke is good, but god damn that's some fuck-ugly HTML. I mean it's technically valid, but it's still unnecessarily gross.
Oh come on, everyone knows it should be NaN
Since the types are optional, a pragma won't be needed. Pragmas also don't work if you introduce new syntax. They can be only used for opting into different semantics, but that's rather hairy, too. The 'use strict' one isn't needed anymore since modules and classes are always in strict mode. However, there won't be a chance to do that kind of thing again. It's highly unlikely that we'll ever see another pragma. A checked mode (à la Dart) where all the types are actually checked at runtime would be really handy, though. But that's something you'd just enable in the dev tools. E.g. there could be an option for enabling checked mode when the dev tools are open (similar to that option for automatically disabling the cache).
no prob 👌
Flow ftw hard
Kind of a disappointingly thin article. They prefer Flow until the end when they choose TypeScript for community and bindings ([Flow has bindings too, in FlowTyped](https://github.com/flowtype/flow-typed))
Yes.
That's what I wanted to hear. Thanks.
Go ahead and compare the number of bindings flow-typed has compared to definitely-typed. The difference is substantial.
Yes, that's why I made it, to port a hack over to JS and make a nice interface with Electron
Assuming you're using Webpack to build a JS app and not purely CSS, the way I usually structure my apps is by having my main CSS file with generic styles imported in the root JS file (as you have done here), and then for each component I may import a CSS file specific to that component from within that component's JS file. This allows you to keep component specific CSS within the same folder as the actual component while keeping your site-wide styles in a dedicated CSS directory. E.g.: App/ components/ component/ css/ style.scss component.js css root.css other/ css/ folders/ With `component.js` having a `import './css/style.scss';` declaration at the top of the file.
no docker? waste of time.
One problem: The article cites a variance issue here, implying `Animal` shouldn't be allowed to be added because it's not a subtype of `Bird`. class Animal {} class Bird extends Animal {} const foo: Array&lt;Bird&gt; = [] foo.push(new Animal()) This is because TypeScript's typing relies more on structure than names in hierarchies. If you add a method or property to `Bird`, [the code will throw a type error as expected.](http://www.typescriptlang.org/play/index.html#src=class%20Animal%20%7B%20%7D%0D%0A%0D%0Aclass%20Bird%20extends%20Animal%20%7B%0D%0A%20%20%20%20name%3A%20string%0D%0A%7D%0D%0A%0D%0Aconst%20foo%3A%20Array%3CBird%3E%20%3D%20%5B%5D%0D%0Afoo.push(new%20Animal(%29%29%0D%0A) What this also means is that, say, bird has a `name: string` property. [That means the array will be able to accept any object with that same property as well.](http://www.typescriptlang.org/play/index.html#src=class%20Bird%20%7B%0D%0A%20%20%20%20name%3A%20string%0D%0A%7D%0D%0A%0D%0Aconst%20foo%3A%20Array%3CBird%3E%20%3D%20%5B%5D%0D%0Afoo.push(%7B%20name%3A%20'steve'%20%7D%29%0D%0A) In JS, when working with an object, you won't care what the object is or where it came from, only that it has the properties and methods on it that you want. In taking this approach, TypeScript aligns much more with the workflow of typeless JS, which I think is a really big plus.
&gt; The only way I can find to avoid this is to not go down the path in the first place — don’t use ImmutableJS, immutable data structures, immutable data as a concept in Redux/React, or ramda, or lodash. Basically, write Javascript without functional programming techniques. THOSE ARE NOT EQUIVALENT STATEMENTS I think the author is actually griping about the React ecosystem, not functional programming. You can use functional style without ImmutableJS, React, Redux, Ramda, or lodash.
Very cool! Game hacking with Node.js it's quite original, haven't see much of it.
[removed]
 ,
I just want a jsfmt, with ;'s.
How to effectively split your components while grouping JS and CSS? I'll use an example with Sass because it shows how to share variables across split styles too... App.js // imports base.scss, Header.js and SearchBox.js Base.scss // imports Variables.scss but doesn't import Header.scss or SearchBox.scss _Variables.scss // just Sass variables, no selectors, so importing doesn't cause any style generation. Header/ Header.js // imports Header.scss and not Base.scss Header.scss // imports _Variables.scss but nothing else SearchBox/ SearchBox.js // imports SearchBox.scss SearchBox.scss // imports _Variables.scss but nothing else This way when you split at Header.js or SearchBox.js and that bundle will have the relevant CSS included too. If you were to @import everything from a Base.scss then Webpack can't effectively split bundles that include CSS. Header.js and SearchBox.js are allowed to use classes from Base.scss. That's an implied dependency. 
Thanks for this. Is there some advantage to only importing specific CSS files that I need to the components themselves, versus just doing what I showed in my OP where I import every CSS file into one main CSS file?
Just reproducing the code from the ASI isn't flexible enough in my opinion. You need to associate the complete set of lexer tokens with the appropriate AST nodes including whitespace. This gives you the most overall flexibility, and allows the user to preserve some formatting decisions such as adding line breaks for clarity.
Thanks for the detailed response!
Previously discussed on Reddit in [/js](https://www.reddit.com/r/javascript/comments/6i7isb/functional_programming_in_javascript_is_an/), [/clojure](https://www.reddit.com/r/Clojure/comments/6i8py3/functional_programming_in_javascript_is_an/), and [/programming](https://www.reddit.com/r/programming/comments/6i7e02/functional_programming_in_javascript_is_an/), and on [HN as well](https://news.ycombinator.com/item?id=14642395). General conclusion is that the author shouldn't be trying to use four different ways of handling immutable updates in one application.
[You can also dynamically import all of your stylesheets if you like](https://webpack.js.org/guides/dependency-management/#context-module-api), which is nice so you don't have to remember to update `main.css` whenever you add a new stylesheet. Following the guide, you'd end up with something like this: function importAll(r) { r.keys().forEach(r) } importAll(require.context('../css/'))
D3.js has some force simulation, but I don't think it offers much more than that in the way of physics.
Laravel's asset pipeline is totally optional
Also confused as to the method signature. Why is it structured the way it is? Granted, it all compiles the same, but the readability really suffers. // From Article const emptyArray: (size: number) =&gt; void[] = size =&gt; { return Array.from(Array(size)); } // What I would expect const emptyArray = (size: number): void[] =&gt; { return Array.from(Array(size)); } // What I'd really do const emptyArray = (size: number): void[] =&gt; Array.from(Array(size));
eslint --fix is enough for me. The only thing I'd want from Prettier is the automatic line splitting, but it hasn't been nearly enough of a problem to add something to my toolchain. 
Maybe an approach similar to asm.js would work here, where the emitted code is still valid as standard JavaScript but gains additional semantics when the pragma is supported. Like how e.g. `var n = 1337|0` is just a more efficient alternative to `var n = Math.floor(1337)` in standard JS but gets parsed as `int n = 1337` when `'use asm'` is supported. I don't know how well that general approach could be applied to a more complex type system like Flow/TypeScript, but it'd be pretty cool if it could be made to work.
Could not have said it better myself.
You mean the lack of container element, being minified or all the meta tags? It looks minimalistically beautiful to me.... except for all the meta tags, but such is life.
I'd just use a function declaration for declaring my function. function emptyArray&lt;T&gt;(size: number): T[] { return Array.from(Array(size)); } TSC will complain if I'd try to redeclare it. Using some const here really does nothing meaningful. And that other thing with some generics thrown in: function generate&lt;T&gt;(size: number, fn: (i: number) =&gt; T): T[] { return Array.from({length: size}, (_, i) =&gt; fn(i)); } let foo = generate&lt;number&gt;(5, i =&gt; 'nope'); // error - you've to return a number IMO that stuff looks complicated enough as it is. Adding more punctuation really isn't a good idea. I still have no idea why assigning arrow functions to consts became so popular. I mean, I get that everyone likes consts and arrow functions, but that doesn't mean that one must use them for everything.
&gt; Like how e.g. var n = 1337|0 is just a more efficient alternative to var n = Math.floor(1337) `| 0` is like floor for positive numbers if the result fits nicely into a signed 32-bit int: &gt; 0x7fffffff | 0 2147483647 &gt; 0x7fffffff + 1 | 0 -2147483648 // whoops &gt; Math.floor(-1.2) -2 &gt; -1.2 | 0 -1 It truncates. Math.trunc does that properly for larger numbers as well: &gt; Math.trunc(-1.2) -1 Math.trunc(0x7fffffff + 1) 2147483648 &gt; where the emitted code is still valid as standard JavaScript Well, if type annotations are added to the standard, it's standard JS either way. There could be CC-like type annotations which use comments, but those are *amazingly* annoying to write. I also generally don't like the idea of having comments actually doing something. Being text which has no effect on the program is the one and only thing comments are meant to be.
We are using Objection which is an ORM layer on top of Knex. It's awesome.
Vue CLI
I'm sorry. Is there a way to phrase this post better so that it won't be removed?
&gt;`| 0` is like floor for positive numbers if the result fits nicely into a signed 32-bit int Right, yeah, that is an important distinction. (I certainly wouldn't want anyone to take away from this thread that arbitrarily find/replacing `Math.floor` with `| 0` is a remotely good idea, even ignoring the standard "premature optimisation" spiel.) re: comments, completely agreed. Type annotation comments as already implemented by Flow and TypeScript are probably the most obvious way to make this work, but treating comments as code at run-time just viscerally strikes me as a bad idea. As a long-term solution, when WebAssembly eventually supports GC and a large enough subset of the standard browser APIs that it becomes a viable compile target for TypeScript (and/or untyped JavaScript), that seems like it'll be a natural place for run-time type checking. Until then, there's some pretty interesting experimental work going on: * [AssemblyScript](https://github.com/dcodeIO/AssemblyScript), a subset of TypeScript that compiles to wasm (basically an equivalent to Cython) * [ts-runtime](https://github.com/fabiandev/ts-runtime), an extension to TypeScript that inserts [flow-runtime](https://codemix.github.io/flow-runtime) assertions into the emitted code
Thanks for this clarification. The article almost makes it sound like flow is much better typechecker which is untrue.
Yes. The thing to keep in mind is, global-style CSS processes vs component specific CSS processes both boil down to the same thing.. when they actually are referenced/utilized on your HTML/page (e.g. In the browser or native device), they are style sheets that target your rendered HTML. Just like we use future JS syntax and processes, ultimately it is loaded on the page via a simple script tag. So with all this in mind, the advantages are you can write CSS that for sure will specifically target your components and also not worry about targeting other components on accident (for example maybe you introduce a unique hash to be applied on your CSS classes that ensures even similar names classes are only targeted to the components you want, modules like postcss-loader help with these concepts).
I was all for typescript until I tried to find the type definition file for node 8 so I could use async/await. But I could only find the d.ts file for node 7.x.x. Also had issues when I tried to use sqlite3 in my project. Typescript threw pages and pages of errors into the terminal on build for any ts file that dared to reference sqlite 3. Also, how am I supposed to import npm packages? node syntax, es6 syntax? The whole thing seems to be a mess.
Which is better? iPhone or Android? Windows or Mac? burger or sandwich? If the answer were simple the other wouldn't exist. 
Flow IS a better typechecker. It aims soundness and typescript is not.
The way it is written in the article explicitly states the type of emptyArray. I think it's actually clearer. const emptyArray: (size: number) =&gt; void[] vs just const emptyArray 
Box2D ported to JavaScript/WebAssembly: https://github.com/kripken/box2d.js
It would be nice if they had a link to what the new framework is. 
What it seems like is that you haven't really invested much into learning Typescript and are complaining because it doesn't work when you don't know how to use it?
You either didn't use async/await over the last 3 years or you were messing with two setups. 
I was referring to grunt/gulp, which didn't know ast and relied on globs, whitelists, order and such things. Before that i guess you used command line, we did at least. Before that fully manual. The tools you named came after task runners and already started to do things differently. They were still problematic and complex (requirejs taking the crown here). Webpack is quite a leap from those but sure enough took lots of inspiration from it.
[removed]
Very smart my friend, up-voted for visibility
As always for such tasks I'm suggesting to try [Vanilla.js](http://vanilla-js.com/) framework. It's pretty good in such things (and even more).
&gt; You mean the lack of container element Yes - the lack of html, head or body tags specifically, and trying to save a couple of bytes by not quoting HTML attributes, etc. Although now you mention it, if you're trying to save space to the point you'll not quote attributes and leave out html/head/body to save a handful of bytes, why on earth would you then waste a hundred times as many absolutely stuffing the markup with more than 10 almost-useless meta tags like msapplication-tap-highlight and apple-mobile-web-app-status-bar-style? Nothing about that markup makes any sense.
How did it not show otherwise? With Javascript, I could use nested object literals to create the tree. This took no effort, three lines and is very readable. With C, I needed to implement a node structure, a means of storing either a leaf value or a list of references to other nodes via a union.
&gt; No, better a hardware description language. *Better* is a different quality than *might work*. I wonder how someone so seemingly lacking in higher brain functions can be interested at all in programming. &gt; So you are creating a DSL that map to some higher level domain to be compiled in a lower level representation... sounds familiar. &gt; This language is higher level for that domain, assembly isn't. Writing a properly factored program is the same thing as writing a DSL. You implement subroutines or functions, or in this case macros, that model the problem and its solution, and then you use those to build higher order subroutines or functions that bring you closer and closer to an exact description of the solution in terms of domain specific constructs. This is true whether you are writing C, Javascript, ML or whatever. Maybe you have the idea that you somehow can't write a DSL without metaprogramming? You're wrong. And no, your macro assembler DSL is not going to be a high-level language. That is of course if you use the commonly accepted definition. If you insist on using your own home cooked definition, whoop-dee-doo, you're always gonna be right. Exactly like you want it, retard.
Compile to ES2015. Run through Babel. Boom, problem solved. I don't see what's so hard about that. 
I don't understand a word you're saying, or you don't understand mine. Does this link clarify it for you? https://stackoverflow.com/questions/30801857/is-it-possible-to-use-typescript-and-babel-together TS couldn't handle these features and in order to have them you would now chain transpilation setups in specific order with new problems that arose because of it. Most TS devs that i know and knew did not chain babel. They used what Microsoft gave them, and if that meant no spread for instance they'd pass on redux while the whole world adopted it around them. And if that meant no async they created promise chains instead. And in the earlier times when it meant being cut off from npm they dealt with nuget. You make it seem like TS is and was easy to combine with other tools when it clearly never was. Therefore my hope is that one day TS could behave like Flow, a tool that does a specific thing well without interfering in other things that don't concern it.
You Don't Know JS series by Kyle Simpson
Can you give an example?
exactly what i was looking for right now! thanks very much
Cause reddit is all about bandwagons so they jumped on it like redditors do.
Maybe I won't answer your question but I'll share anyway. By definition printed books or ebooks will be out of date. I learn modern js stuff from MDN with the help of online cheatsheets. For basics and the always dependable core I have "JavaScript - The Good Parts" on my desk.
That font is fucking obnoxious.
I can also recommend the You Don Know Javascript series of books the one im reading at the moment is Your Dont Know JS ES6 and Beyond =&gt; https://github.com/getify/You-Dont-Know-JS/blob/master/es6%20&amp;%20beyond/README.md#you-dont-know-js-es6--beyond
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [getify/You-Dont-Know-JS/.../**README.md#you-dont-know-js-es6--beyond** (master → 77225d4)](https://github.com/getify/You-Dont-Know-JS/blob/77225d489b45749f832878afb697c5b3895f19f1/es6%20&amp;%20beyond/README.md#you-dont-know-js-es6--beyond) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply djn5jyi.)^.
This is very reasonable, although it's a bit of a gotcha because the way the article explains it is the way most people would expect it to work.
https://www.reddit.com/r/javascript/comments/6kjnti/why_we_chose_typescript/djmoqw8/
In my company we are switching to Flow in these weeks, I already converted a 50+ components codebase in less than a working day. I had to add very few annotations, most of them were automatically converted from React PropTypes. With TypeScript I should have added annotations to every piece of code and the end result wouldn't have been a 100% type errors safe code because of the unsoundness of TypeScript...
There are tools to convert TS bindings to Flow tho 🙄
Better explain why they chose to use that ugly italic font in the header... My eyes....
SPOILER ALERT
Is it the best best with what you're using, yes, is there a better way, most certainly, but not without leaving the imperative dom behind. All declarative libraries do this cheaply and for free. For what do you need it?
Strict typing, classes, etc. are for developers who are too lazy to learn actual javascript. LEARN JS. Learn prototypal inheritance. Learn the difference between a module and a namespace. Stop trying to turn JS into C# or Java or Python, good lord. TBH pretty disappointed by this industry trend. It highlights a severe lack of adaptability on the part of most software engineers. 
&gt; This is true whether you are writing C, Javascript, ML or whatever Yet, no macros in any of the mentioned (C ones are horrible). Interpreted DSLs suck, sorry. &gt; Maybe you have the idea that you somehow can't write a DSL without metaprogramming? Maybe, but anything else is useless, slow and brings a lot of cruft. BTW, why you are being so hostile? I don't mind but I am a little curious. What is happening there? 
The question is why would you want to. Unless you are forced to by angular or something, ts is a wasted opportunity to use a dynamic language.
Personally, I love operator mono. It's nice to on the eyes, imo
All of these transpiled javascript languages look like shit.
I could not agree more.
&gt; I was all for typescript until I tried to find the type definition file for node 8 so I could use async/await. [Definitions were added two weeks ago.](https://github.com/DefinitelyTyped/DefinitelyTyped/pull/17027) &gt; Also had issues when I tried to use sqlite3 in my project. Typescript threw pages and pages of errors into the terminal on build for any ts file that dared to reference sqlite 3. [Install the type definitions.](https://www.typescriptlang.org/docs/handbook/declaration-files/consumption.html) &gt; Also, how am I supposed to import npm packages? node syntax, es6 syntax? Node syntax is allowed, but [you should use ES6 syntax](https://stackoverflow.com/questions/35706164/typescript-import-as-vs-import-require), similar to Babel.
Because duck typing https://img.devrant.io/devrant/rant/r_101773_NBeRd.jpg
TypeScript is as dynamic as JS is. It has the `any` type for a reason.
While I agree with you, i've started to shift my way of thinking and use ES6 and Typescript in most of my projects these days. Not because I agree that javascript should be class based instead of prototypal, but as a javascript developer, I gain no positive career benefits from going against the path the community has chosen. You can sit back and complain it's not what it used to be, and there is validity in that argument.. But at the end of the day the community opted to go with an opinion that you simply just don't hold.
If only you could eliminate the other type annotations, and make "any" automatic...
To say that typescript doesn't aim for soundness isn't quite true, because it obviously does. It's the _level_ of soundness that TS specifically aims for, in order to strike a balance between correctness and productivity. It gives some leeway in type checking to not get in the way of the developer through redundant type errors. TS trusts the dev that they'll know what they're doing to some extent. With that in mind, that wouldn't make flow the "better" type checker because of that. Sure it's more sound, but sometimes you just wanna get stuff done.
Why are arguments for dynamic types often spattered with machismo and no true Scotsman fallacies?
That's completely false. 
Fair, but the point of prettier is to save time, letting the computer do the formatting so you can do the coding. It might not always give you the output you want, but it's easier to accept that and move on than waste time yourself trying to make it look as pretty as possible.
That... isn't true at all. Typescript notations are optional.
There's not inference in TS, so if you miss a notation you lose type coverage. For instance, here without annotations TS doesn't throw any error: https://www.typescriptlang.org/play/#src=function%20smth(a)%20%7B%0D%0A%20%20%20%20return%20a%20*%201%3B%0D%0A%7D%0D%0A%0D%0Asmth('asd')%3B%0D%0A Flow, on the other hand, properly detects the problem: https://flow.org/try/#0PQKgBAAgZgNg9gdzCYAoVUCuA7AxgFwEs5swBnAW3wAsAKAQwEowBvVMDsAJwFN9MupesjABGANyoAvuko1aAcnpkAJgsaSgA
&gt;Im looking for a way to enhance my forms and static pages with two way databinding but I don't want to create a SPA. In other words, its jQuery or Vue.
https://medium.com/@deathmood/how-to-write-your-own-virtual-dom-ee74acc13060
&gt; Strict typing, classes, etc. are for developers who are too lazy to learn actual javascript. "Actual JavaScript" has classes. `class` has been a reserved keyword since the very beginning. &gt; Learn the difference between a module [...] Wait... why are modules/import okay? That too makes it more like C# or Java. **Edit:** How about let/const, arrow functions, and async/await? Those make JS more like C#, too.
How do you deal with Flow's unsoundness? const functionNotClass = (input) =&gt; true; (functionNotClass: Class&lt;any&gt;); // no errors from Flow const gonnaTrustFlow = new functionNotClass() // runtime Uncaught TypeError: functionNotClass is not a constructor class ClassNotFunction extends Error {} (ClassNotFunction: () =&gt; Error); // no errors from Flow const gonnaTrustFlowAgain : Error = ClassNotFunction() // runtime Uncaught TypeError: Class constructor ClassNotFunction cannot be invoked without 'new' [Try flow](https://flow.org/try/#0MYewdgzgLgBAZgVzMKBLcA5EUDCAbAQwghgF4YAKVMABwSgEoyA+GKAJwQFMBuAKAqJkaTNnxEIALhjjiAHgJgAnswY8YAeg0wwIGF3bsQ7EnCMBbGADE8IAO59QkWAHNwYAgBVO0G-bI6XHbwSCjoYFi4hMQUDHxaMJxgaOZcMACqyAQILgAWsJ5KNFwAoobG0kJholESMKgkurAEME7QnCjGfI7RJLIQkVahImD6AB5QXGAAJiRlRuwwAN4AvgL9g8Ph0rEsMPPGaprauvrlJvAW1rYOba7uXj5QfnYAgi4E1DDSB4vkG9ghsJwrF4tokik0plgNk8gUiqVztJ+q1wO0EJ1FgDnltwK1FE0YAAjNLUABuIAA1lxpjA7KgoLkQPQYAByMBBVlAA)
Perhaps the best place to start is just in the browser console. If you are a Windows or Linux user press the F12 key. If you are a Mac user press command+option+i. Perhaps the best browser to start with is MS Edge, because its console can transition to a multiline editor with a single immediately available button. Firefox provides an internal tool to investigate code called *Scratchpad*. In these environments you can experiment with basic code and execute it safely. When you are ready you can also play around with webpage interaction. Using query strings or learning the old DOM methods.
Anything wrong with doing the below for quick results apart from optimizations in the screencast code? (Asking as a noob) &gt; const sortedWord1 = word1.split('').sort().join(''); &gt; const sortedWord2 = word2.split('').sort().join(''); &gt; if(sortedWord1 == sortedWord2) { &gt; return "Tie!"; &gt; } &gt; return word1 &lt; word2 ? word2 : word1; 
My list: beginner to advanced https://glebbahmutov.com/blog/javascript-books/ 
Yeah, and im thinking about buying a book in my language do you think its needed? People say, dont learn from the internet learn from books etc.
The standard (and fast) way to go about this is to create a document fragment and modify this fragment as much as you need before attaching it to the document. * https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment * https://developer.mozilla.org/en-US/docs/Web/API/Document/createDocumentFragment The reasoning behind a document fragment is that it is a DOM document island resident in memory, which still gives you the full power of DOM manipulation. This has performance boosts for two reasons. 1. Since the fragment exists outside the document object it can be accessed asynchronously and separately from the document object. In areas of extremely rapid access (sub 5ms) large requests to the document object can slow down and queue up even though the DOM asynchronous from the primary JavaScript thread. 2. The slowest part about the DOM isn't even the code, at least not in the past 7-8 years. The slowest part is the visual rendering of artifacts to the screen (painting). This limitation is completely absent from document fragments.
Personally, I find I learn best from books but only for two narrow facets: theory and reference. The books everybody recommends are: * Eloquent JavaScript - http://eloquentjavascript.net/ * JavaScript: The Good Parts - https://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742 That first one can be read online. Once you get past the *how do I write code* basic literacy stuff and really want to step up into architecture you might want to get a little bit of Lisp and Scheme. The fundamental concept to learn in this language is **scope**. In my experience computer science grads tend to learn things like C++ and Java or C# and work really hard to get really good at OOP. Those techniques of inheritance aren't quite so helpful in this language if you never learn this language's scope model. If you fall in love with the scope model you might find you don't need the OOP/inheritance stuff. When you are ready to interact with the web here is a quick guide I wrote to teach DOM access: http://prettydiff.com/guide/unrelated_dom.xhtml Could you let me know where this guide fails you so that I can improve it for other people?
[removed]
Run away while you still can! 😶
I think the best place to start is https://www.freecodecamp.org. It's interactive, with a huge community you can ask for advice and awesome content to learn more.
I have started with teamtreehouse.com. The tutor on there is really good. 
Did you actually see my examples of what I would expect it to look like?
But in cursive?
If you're into books, I learnt a lot of things in Sam's 24h. He does these for all sorts of languages/frameworks. If video is more your thing, I recommend watching the Net Ninja on YouTube. He really does well to cover a lot of JavaScript frameworks, as well as some fun Node.js stuff. 
I'll tell you if this works or where it failed, thank you for the imformation :)
These lists are always chock full of useless CS trivia that should absolutely never be used in an interview. This one seems moderately less so than most, but still very much guilty. 4/10 5/10 with rice
I'm going for python thank you lol!
I'm gonna take a look at it so i can decide whats the best for me.
I've seen the commecials but i havent tried it yet and i think you need to pay for it, i dont want to pay for now.
jsforcats.com
I can do both, nice to learn anyway.
I understand that this is very basic, i think i can learn the basics from here or remember my knowings. Thank you :)
Yeah, fair enough. I never pay for learning as there is so many free ways of doing it. But after the free trial, I really loved the format and decided to go for it! 
It's automatic by default until you add type annotations.
No....there is definitely type inference. 
Show me please? My sample codes are quite clear on the missing inference of TS, or at least, if it have it, it's pretty weak in it
The complexity of your algorithm. Time and/or space
This was posted before and I had issue with it then, and still do now. A lot of this is testing a persons memory and not their understanding. This is the sort of knowledge the vast majority don't carry around in their head but know of and where it's applied. So can look it up. 
I went to each one of those links, and did not see that as the general conclusion.
A bit, yeah. Works really well in practice, though. It's an intuitive and flexible way of doing things.
Do you want to learn programming or do you want to learn web page tricks? Most people assume you want to play with web pages, and that means you are learning the DOM of web browsers more than anything specific about javascript. Find dev tools in your browser and play around. If you want to do something more like programming computer science, you can get a node.js + npm setup going and learn programming concepts, algorithms, closures, etc. You'll want to know basic programming stuff first, like bash, git, editing source code, etc 
So the best way to use TS is not to ever add any type annotations.
In case anyone is interested, I have a gist with my notes on getting ESLint and prettier working together. I use the VSCode ESLint extension. https://gist.github.com/strothj/96bdce87aaf486d49968f34b42434eca
Hopefully not to variables that often, but you'll need them in function signatures to get any benefit.
My point is that the supposed benefit is actually a hindrance.
How so?
Still good to learn 'older' JavaScript, since WHEN (not if) you look at older code, you can read it. But I'm also looking to 'learn from scratch current best pratices'. Axel is a JS genius, though not everything is in 1 book, at least the older-new JS is in 1: http://exploringjs.com
I need to know when my element is added and removed from the dom. What's are some examples of better ways? &gt; All declarative libraries do this cheaply and for free Though this is only because they're declarative, right? In the background they must be employing some JavaScript, perhaps even Mutation Observers, to accomplish this?
https://vimeo.com/74354480
... but Typescript *is* dynamic, that's why there's *any*.
If you dont use the type annotations, it is.
So it's the best of both worlds, really
Before Angular and React was the Backbone era. That was the first solid framework that really piloted the JS world imo. 
No, it adds an unneeded transpiling step. Which is especially useless on the server side, and it lags behind pure JS transpiliers like babel on the browser side. So its really not best of anything, more like "crap of one world needlessly dumped into another perfectly fine world for a dumb reason". 
Ok
Simply dismissing the possibility that there might be actual reasons is a convenient mental escape hatch for when you don't feel like challenging your views. While that's somewhat socially acceptable for religious opinions, it doesn't mesh very well with technical or scientific topics. It's better to assume that you do not know everything (because chances are you don't) and to reconsider your views and opinions whenever new information becomes available. Gradually typed languages are becoming more popular because there are many who think that the pros outweigh the cons. I think so, too. In my experience, it's an extremely favorable trade-off. You get so much in return for adding a few annotations here and there. I highly recommend to give it a try with a somewhat larger (500+ LoC) project.
JS was written in the mid 90s. I dont remember anything major until YUI, Dojo and jQuery came along after but client side MVC/MVVM wasn't a thing. This was pre XmlHttpRequest so everything was done server side with perl, then PHP or cold fusion for the most part. I distinctly remember starting with little alerts, then JS hovers and dropdown menus on my sweet GeoCities page thinking I was pretty hot shit. Eventually you could grab a DHTML script somewhere to do similar but it was still mostly just vanilla JS and the browser wars were very real. It's crazy to look back and think about how JS is adopted en mass now. Crazy but awesome.
Yes, that starter covers the points explained in the article. Although I wanted to focus it on the existing check Vue templates and to instruct how can you integrate it in your already existing project.
Your example works because typescript is permissive. This is by design. If you don't type a parameter it is auto assigned to the any type. The reason it doesn't show immediately as an error is because since javascript supports implicit conversion the typescript compiler can't guarantee that what you are passing in is an error. For all typescript knows that string you passed in is a result of a string from an input box that is already guaranteed to actually be all numerical digits. The typescript team made a decision that these sorts of inferences are left weak because javascript by nature is so permissive and they wanted typescript to be as close to javascript as possible. This is all clearly laid out by the typescript team if you ever bother to read about their design decisions. If you pay attention at all typescript does infer that the return type of the function smth is of type number because it knows that the result of a * operation in javascript is always a number (including NaN since it is a special value). That is what type inference is. What your example shows is the permissiveness of the type system which is not the same. Heck this stuff is literally in the article this post is about. The author mentioned that typescript doesn't follow the same strict covariance - contravariance rules that flow does. Once again, this is by design. If you want to get rid of these *potential* problems then just turn implicitAny off in the typescript config. Then your initial function that doesn't type the parameters would throw an error because the parameter isn't typed. But you could still do something like: var x = smth("1"); And typescript wouldn't have an issue with no type specified for x here because it inferes that x is a number since smth returns a number.
Obviously. You defined the type of the function, not the variable on the left side. In this case it doesn't matter, since it's a const, but if you wanted a mutable variable it would make a difference. So I see the case for making the syntax consistent in both those cases by always explicitly defining the type of the variable. 
v3.0.0 of a command line todo application with desktop notification https://github.com/zombieleet/duty
Server side rendering was the big thing, with various snippets of JS for niceties. The good thing about those days was that you could block browser scripting and most things still worked... unless you happened upon one of those all flash abominations. 
Not sure who downvoted you, but I remember those days well :) YUI and Ext and Mootools and JQuery.. then backbone came along, and despite all the issues it had with memory leaks and IE6 support it took over. Then Ember, Angular, React, and everything else. Worth mentioning Silverlight too - it doesn't get the credit it deserves, and was way ahead of its time. Think Isomorphic rendering ala NextJS plus GraphQL style query language.
&gt;:) I am happy that you are happy. Spread the happiness around. [This doggo demands it.](https://i0.wp.com/s4.favim.com/orig/50/boo-cute-dog-pomeranian-Favim.com-452643.jpg)
It's funny, I wrote the code for my blog site from scratch a few months back, then realized I was slowing everything down for no reason by shipping React + Lodash to the client. I even had to introduce HTTP2 push to keep everything fast, since I had so many resources. I switched to server rendered React, and am shipping just HTML and CSS to the client now, which loads in a few hundred ms. Sometimes I feel like we take a step backward for no good reason.
&gt; Not sure who downvoted you Probably a millennial
&gt; It's better to assume that you do not know everything (because chances are you don't) I agree. &gt;Gradually typed languages are becoming more popular because there are many who think that the pros outweigh the cons. Which brings us back to what I initially said.
&gt; Which brings us back to what I initially said. Does it? You implied that there aren't any valid reasons whatsoever. You claimed that they are only following a fad.
Reddit is a good barometer, or litmus test, for that.
It looks like you're defining all of your modules using what is supposed to be a compatibility wrapper for commonJS modules that don't translate well to AMD. This relies on using `Function.prototype.toString()` and regex to search for dependencies (see [lines 2078-2100](https://github.com/requirejs/requirejs/blob/master/require.js#L2078) of require.js). This is nowhere near as reliable as explicitly defining your dependencies. You should really only be using that syntax when refactoring a pre-existing module to AMD is impossible or more of a headache than it's worth. For example the module in `game.js` is currently structured like this: define(function(require) { var Board = require("snake/board"), Constants = require("snake/constants"), Snake = require("snake/snake"); function Game() { // ... } // ... return Game; }); To make it a proper AMD module you'd change it to something like this: define([ "snake/board", "snake/constants", "snake/snake" ], function( Board, Constants, Snake ) { function Game() { // ... } // ... return Game; }); Other than that I'd suggest looking into using ES6 language features like classes, arrow functions, `const`/`let` instead of `var`, etc. Using `game.js` as an example again, you could write it like this: const scoreNode = document.getElementById("score"); const rateNode = document.getElementById("rate"); class Game { constructor() { this.snake = new Snake(); this.board = new Board(); this.direction = Constants.DIRECTION_NORTH; this.state = Constants.GAME_STATE_PLAYING; this.score = 0; this.directionKeyRegistered = false; } start() { this.board.render(); scoreNode.innerHTML = this.score; rateNode.innerHTML = this.nodeRate(); this.spawnSnake(); this.generateFood(); this.tick(); } // ... tick() { setTimeout(() =&gt; { if (this.state == Constants.GAME_STATE_PAUSED || this.state == Constants.GAME_STATE_DONE) { return; } this.moveOne(); this.tick(); }, this.tickInterval()); } // ... }; return Game; Note the use of `const` instead of `var`, and the ability to use `this` inside the arrow function in `Game.tick`.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [requirejs/requirejs/.../**require.js#L2078** (master → 0720795)](https://github.com/requirejs/requirejs/blob/0720795d9a4e1bb1b47befc8548b61afe6f72dfc/require.js#L2078) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply djno2pa.)^.
Everyone always forgets about Knockout :(
[removed]
Knockout isn't that old. ember, knockout, &amp; backbone were created around the same time (&gt;= 2010)
Most people on Reddit are vaccinated. Guess that means that it's just a fad, too. Well, this discussion is pointless since you don't have any arguments. Not even superficial ones like "the syntax is ugly" or something like that.
One day I'll understand what I can do with Relay and GraphQL, but until then I'll just keep hitting my API like a simple boy. 
i feel u. it seems great but i still cant find a simple explanation of the db requirements and how to get it set up.
https://github.com/picodom/picodom https://redom.js.org/ https://github.com/snabbdom/snabbdom
I'd rather just create a route and write sql
just dropping by to suggest bcrypt or scrypt as alternatives to pbkdf2+sha512
I never used or even looked that much into the tech, but it seems analogous to a true Data Mapper model. Like the graphql query can represent any entity, but can be easily made up of data from varying sources. I imagine a user's data coming from sql, while her likes come from redis, or her network comes from neo4j, etc. and in graphql you simply request all of those independent components as one response. 
When I started in 09~ it was jQuery, Ember, Backbone, or Angular to pick from mainly in in the majority school of thought, or atleast that's how I saw it and how I proceeded to choose to educate myself. YUI and Dojo were dying-ish and Ember looked to be dying, React was FBXML or something? I picked jQuery and native JS, correct choice.
I didn't see anything about SEO which is interesting since it's probably a massive issue for a publisher when doing client side rendering. 
Good point on explicitly defining dependancies. I saw examples of both ways, the way I originally did and what you just explained but wasn't aware of the pros or cons to either of them. Just picked one and went with it. Should be an easy refactor. Great feedback, grinde! 
&gt; Worth mentioning Silverlight too - it doesn't get the credit it deserves in all honesty: wasn't it just a microsoft clone of flash?
Pushing logic to to client or the server (and the other way around) is this pattern that comes in waves, ever since thin clients connected to main frames. That said I don't think this is purely tech hype driven: consumers like apps and want their websites just as realtime / interactive and flashy. You can't do that with HTML and CSS, but that doesn't mean you should start writing all your blogs (=static webpages) in react..
This guy codes
No. 
Frameworks comes and goes... It has always been the same for the past 25 years. It s a question of marketing and support from their genitors. Angular is going down because facebook is better at pushing react to dev. Frameworks are just shortcuts supposedly aiming for a faster codeproduction time but at the end it s always the same story of rewritting it with another "up to date" framework ecosystem. Stick to pure es6. Faster, strong, lighter. Once you master it, you will realize all those framework are totaly useless.
Es6 has everything you need already. Just check at w3c.
 var virtualDom = document.createDocumentFragment() 
I'm working on a front-end view layer solution similar to Vue.js and React which uses proxy magic to make some amazing code possible. https://github.com/SaulDoesCode/rot.js
&gt; What is Big O notation, and why is it useful? I never formally learned this. I don't have a CS degree, but 7 years of experience (3 of them training). I can make an educated guess for answering this, but I'm certain I'd get it wrong. Unless "A measure / notation of complexity" is an acceptable answer, but if that's acceptable, the question is trivial and should be left out. &gt; What is the DOM? You should clarify: Do you mean the browser DOM, or the general concept of a DOM? &gt; What is the event loop? Interna of the JS engine might be useful to know, and knowing how to implement an event handling system yourself is also useful. But this is not critical or terribly relevant for frontend stuff. I'm concerned with the events themselves, not how the browser manages them. &gt; What is event bubbling and how does it work? (this is also a bad question IMO, but a lot of people like to ask it too) That is actually more down to earth than the previous question. &gt; Describe a few ways to communicate between a server and a client. Describe how a few network protocols work at a high level (IP, TCP, HTTP/S/2, UDP, RTC, DNS, etc.) Holy shit. Is that an interview or a final exam? It's basic stuff, but the question is super broad and arguably out of scope for a front-end developer. I never had to worry about lower level protocols since my final exam. (Sidenote: What is RTC?) &gt; My website is slow. Walk me through diagnosing and fixing it. What are some performance optimizations people use, and when should they be used? What the fuck is that question? What kind of website? What frameworks? What browser? What kind of "slow" (slow loading, unresponsive, slow rendering, ...)? &gt; What frameworks have you used? What are the pros and cons of each? Why do people use frameworks? This answer can get quite long, without giving you reasonable insight, if you ask the wrong people. &gt; What kinds of problems do frameworks solve? Literally all of them, unless you specify your question.
jQuery always supported XHR and didn't predate it (2006). No mention of JavaScriptMVC or dojo. Module pattern existed and worked well with a concat build step. Most of us just built our own build chains though. I helped work on Grunt and Backbone early on (but Backbone existed well before I started using it) as they both really resonated with what I wanted in a build system (later turned into Backbone Boilerplate). AMD/CommonJS were both instrumental plus r.js/browerify for bundling your apps. You could come up with pretty decent patterns purely by leverging the module scope and get code splitting done (but it usually wasn't easy unlike today).
**Coding** &gt; reverse That is a non-trivial task you should not ask in an interview. See here for the reasons: https://github.com/mathiasbynens/esrever &gt; isPalindrome Non-trivial for the same reasons ```reverse``` is non-trivial. &gt; sort - Implement the sort function to sort an array of numbers in O(N×log(N)) time. That is not "intermediate", unless you have the various sorting algorithms already memorized. Which most people probably don't. &gt; Implement a LinkedList class without using JavaScript’s built-in arrays ([]) Why would you used arrays in a linked list anyway? Also, this is not "harder", just time consuming. 
Seems like the post is mostly focused on the GraphQL part, mostly ignoring the frontend specifics. Plus React can be rendered server side. I would be interested to see if that's what they do.
This is why I like flow. You can write plain old ES5 without type annotations and still get a lot out of it. Then you can incorporate it into your es2015+ code and buy in for only as much as you want. 
Do you know the exact code for hiding a section when another is clicked? That's what I can't seem to figure out, I'm not too good with Javascript.
I work on diffHTML that may work for you. Has server-side rendering and works with HTML as well as JSX. https://diffhtml.org
Haven't seen them mentioned yet but between the jquery and the react/angular age (besides backbone) we also had knockout and durandal. 
I initially removed it due to "Posts must be inclusive to all". With 113k subs, it will only be useful to 2 (you and whoever)... but I'm having second thoughts, so feel free to repost (if I unfilter this one now it'll probably be off the front page). Sorry for the hassle.
Yeah sorry I meant pre jQuery no XHR. I don't think IE supported it until then but I could be wrong.
I've never used Flash, but Silverlight shipped with both a backend and frontend. 
typescript's entire codegen story leaves a lot to be desired (cf baseUrl/paths interop, use strict pragma duplication, header file generation, etc). i'm guessing it's gonna keep being that way for a long time too, since maturing the type system and language server seems to be the priority over competing directly with babel's usecase. in fact, i'd say how tsx support is implemented proves typescript itself imagines you deferring to babel for more heavy-duty transforms.
it's a shame that perfectly good tools with strong records of open source accountability have to bear the shame of MS's hideous past. i for one take the stance that it doesn't matter which company is behind a tool, because they're all shady to the core; the only thing you can hang your hat on is if it helps you get the job done better &amp; can reasonably survive the company losing interest. typescript passes those checks for me with flying colors.
async/await doesn't need any node typings at all to work and if you found the typings for node 7 but not for node 8, you must tried really hard to not find them.
Thing is, Google is executing JavaScript before evaluating the page for search, so SEO should be unaffected.
[The same thing happens if you use interfaces in Flow instead of classes.](https://flow.org/try/#0PQKgBAAgZgNg9gdzCYAoVBLAdgFwKYBOUAhgMZ5gCCWGAtsTGAN4C+muhJ5YAQhgQBMweAB74sAgM5Ua9Rq3QC8pGMQIUAbmrDFZDAFwy6DANypScLJJxgocOIcoECxAJ4AePoIB8YALxgANoAumaodnAAdAAOAK6SABYAFLrGMACUJkA)
Amen to that
Are they not rendering on the server-side? I assumed they were but there is no mention in the article...
No love for [Apollo](http://dev.apollodata.com/)?
Article pages will have server side rendering. 
Yeah I know that but I haven't ever checked it works as expected. Has anyone noticed any gotchas with this?
It's not actually that scary - you can probably pick it up with just a few hours reading. 
Cool. We solved the problem a few years back with prerender.io. 
Surely you're aware that JS class !== OOP classes, right? It's just sugar around prototypal inheritance. It's not really classes. And I'm not a fan of that addition, and the others you listed, because it's a concession that solely exists to satisfy developers from other languages, not developers who actually know JS. It doesn't improve the language, it makes a "hurr durr I only know Java" guy feel more comfortable. All I said was learn the difference between modules and namespaces. Ive noticed devs coming from other languages conflate the two. You don't need imports in JS, Its just sugar. Dependency injection works perfectly well. Async await is no better than promises. Constants are still mutatable (ie object properties) because they're not ACTUAL constants. It's sugar. 
*fist bump* finally someone ITT with some sanity 
&gt; Surely you're aware that JS class !== OOP classes, right? It's just sugar around prototypal inheritance. It's not really classes. They are as real as Python's classes are. By the way, engines like V8 have been using hidden classes to stamp out instances since the ES5 days. In a way, they are more real than the prototype stuff. The prototype chains aren't actually followed if it can be avoided. Anyhow, check the definition of "class": https://en.wikipedia.org/wiki/Class_(computer_programming) &gt; It doesn't improve the language, it makes a "hurr durr I only know Java" guy feel more comfortable. Ah, right. So you aren't using let/const, arrow functions, Promises, async/await, etc? How about try/catch? Also, you are aware that JS was supposed to look appealing to Java developers from day 1, right? That's why it uses C-like syntax and that's why they put "Java" in the name. &gt; Async await is no better than promises. It makes the code much easier to follow. That makes it very useful in my book. &gt; Constants are still mutatable (ie object properties) because they're not ACTUAL constants. It's sugar. The binding is constant. And no, this can't be categorized as syntactic sugar, because this isn't something you were able to express before.
**Class (computer programming)** In object-oriented programming, a class is an extensible program-code-template for creating objects, providing initial values for state (member variables) and implementations of behavior (member functions or methods). In many languages, the class name is used as the name for the class (the template itself), the name for the default constructor of the class (a subroutine that creates objects), and as the type of objects generated by instantiating the class; these distinct concepts are easily conflated. When an object is created by a constructor of the class, the resulting object is called an instance of the class, and the member variables specific to the object are called instance variables, to contrast with the class variables shared across the class. In some languages, classes are only a compile-time feature (new classes cannot be declared at runtime), while in other languages classes are first-class citizens, and are generally themselves objects (typically of type Class or similar). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/javascript/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
"versus the near absence of type errors in real world systems built in Python, Ruby and Clojure" Well, yes, at the end, type errors will be nearly absent. But that doesn't mean that you didn't waste any time with them. You did of course encounter lots of runtime errors which you had to fix.
&gt; The question is why would you want to. Because you can heavily rely on type inference. You need very few annotations to get all the tooling benefits. Furthermore, type annotations are much terser than JSDoc comments.
Maybe consider setting it up on github pages?
Watch the video; it attempts to quantify the time spent fixing such bugs vs the time spent defining types apriori. I would love to see a new scientific study comparing hybrid type languages and inferred type languages to fully dynamic/static ones. I'm only a fan of dynamic because of the science. 
&gt; much terser than JSDoc comments. If you use jsdoc just to note the types i'd say you are doing it wrong. Its supposed to help explain intention, not types.
[removed]
[removed]
JSDoc: /** * Foos the bar. * @param {number} x * @param {number} y * @returns {boolean} */ foo(x, y) {...} TS: /** Foos the bar. */ foo(x: number, y: number): boolean {...} Dart: /// Foos the bar. bool foo(num x, num y) {...} &gt; Its supposed to help explain intention, not types. Types do document the intent as well. The type + name is usually enough to tell the user what that parameter is all about. E.g. a "color" might be an int or a Color instance, "source" could be a file or a rectangle, etc. Getting the type shown in docs and call-tips really helps a lot.
Agreed. I'm sure if I were to read this a few times, maybe watch a tutorial, then maybe read it again, I'd have a much better understanding. :)
isn't apollo built on graphQL?
They mention SSR in this previous post that weighs up Apollo and Relay https://open.nytimes.com/a-look-at-apollo-from-a-relay-perspective-d89cf76c263c This is interesting &gt;We’re holding back on pulling the trigger to introduce a Redux layer into our app for as long as possible
I've written enough JS, Python, etc. Gradual typing wins hands down. It's much easier to work on larger projects, use libraries you're unfamiliar with, update libraries, add basic documentation, and things like that. I can auto-complete everything, get call-tips, etc. Callbacks, for example, are super annoying in JavaScript. You never know how their signature is supposed to look like. With Dart and TS, that information is right at your fingertips and the types of the arguments can be also inferred. Furthermore, it ensures that your callback returns the right thing. &gt; I'm only a fan of dynamic because of the science. https://danluu.com/empirical-pl/ *The speaker used data from Github to determine that approximately 2.7% of Python bugs are type errors. Python’s TypeError, AttributeError, and NameError were classified as type errors. The speaker rounded 2.7% down to 2% and claimed that 2% of errors were type related. The speaker mentioned that on a commercial codebase he worked with, 1% of errors were type related, but that could be rounded down from anything less than 2%. The speaker mentioned looking at the equivalent errors in Ruby, Clojure, and other dynamic languages, but didn’t present any data on those other languages.*
I still use backbone every day. The perfect amount of utility with few if any "opinions". 
Sadly moved on, but Backbone is still awesome! Backbone and Marionette will always have a place in my heart. 
&gt; Gradual typing wins hands down. I've written enough in nearly every major language. Dynamic types win hands down. (for speed, C/C++ for performance of the final product) &gt; Callbacks, for example, are super annoying in JavaScript. You should look at promises/RX. Utter non issue. &gt; he speaker rounded 2.7% down to 2% You could round both upwards and that wouldnt change the conclusion. Nice find, at least in breath, but sadly no new information. Its mostly obvious criticisms appended to existing studies from an admittedly biased observer. 
Yes, but GraphQL is just a protocol. Apollo can be an alternative to Relay.
Maybe https://github.com/tc39/proposals
&gt; Dynamic types win hands down. Dart and TS are dynamically typed languages, too. &gt; You should look at promises/RX. Utter non issue. Array.prototype.map, rAF etc. E.g. I have some renderToCanvas function which returns an image and it got 3 parameters: width, height, and a callback. Since that callback is annotated, my editor will tell me that it should have exactly one parameter which is a canvas instance. And the type can be inferred which means I can now auto-complete all that canvas stuff without having to annotate my callback's parameter. And this is really helpful since I'm not that familiar with Flutter's canvas API. Some of it's low-level batch-draw methods are fairly tricky to use.
Just a heads up, [there's already a decently popular rot.js](http://ondras.github.io/rot.js/hp/) - it's a library for creating roguelike games in JS that handles maintaining a simulated terminal in a `&lt;canvas&gt;`, map generation, pathfinding, lighting, etc. Your project looks cool!
&gt; balance between correctness and productivity It's not even productivity; it's trying to represent commonly-used paradigms found all over the JS world. TS would be fairly useless if we were unable to represent a significant amount of JS libraries using a d.ts definitions file. 
Personally, I can't stand the syntax. Although it's *kinda* similar to Python, equals signs belong in two places: assignments and comparisons. Also, I'm not a fan of the DOM interface either. EDIT: OK, I'm ignorant as heck. Sorry.
So basically you're a lazy hacker who thinks they never make mistakes. Don't ever apply to my company. You'll get laughed out of the door immediately. 
&gt; Dart and TS are dynamically typed languages, too. only if you completely avoid everything that makes them dart and TS. Took a look at flutter; man what a mess of types. Basically looks like java. &gt; class _ShoppingListState extends State&lt;ShoppingList&gt; Lol, ok man enjoy. Yeah, I wouldnt touch that without some lumbering IDE monstrosity either... looks like 90's style code. 
You missed the point so badly.. your company should think twice about keeping a dino priest like yourself around. The point is to make fewer errors and waste far fewer hours. Sticking to unfounded gut opinions about "the way its always been done" is not good for our industry.
Narcissism. People who rail against typed languages think they're incapable of making mistakes, and therefore they must show their dominance by proudly complaining that anyone who uses static type checking is inferior to their ubermensch brains. Unsurprisingly, these people are almost always the employee that literally everyone hates and wishes could just be fired. However they usually write incomprehensible code, leading to job security in the form of "We have no idea how this stupid fucking piece of shit that asshole wrote works because he obfuscated it intentionally. Keep him contained on that team and we can axe him when the sales dip"
You know when you think the entire world is insane, it's you who is the insane one, right? 
&gt; We wanted to add types because we wanted to move quickly. This sounds a bit antithetical to how many people view types, in that it adds overhead to development and therefore slows developers down. However, in moving quickly, it is much easier to introduce bugs. We looked to types to help keep our code correct even in the fast pace we were moving at. whatever helps you sleep at night, but you're one step closer to writing Java
saying the entire (JS) world is on board with typescript is a bit disingenuous, don't you think? 
&gt; only if you completely avoid everything that makes them dart and TS. The types are optional. You could, for example, annotate your method/function signatures but purely rely on type inference inside their bodies and leave the types of some things unknown. JS is dynamically typed, there aren't type annotations, and the types are about as weak as they can be. Anything goes. &gt; Basically looks like java. About as much as JavaScript or any other language with C-like syntax does. It supports operator overloading, arrows can be also used for function declarations &amp; methods, it got SIMD, there are constructor shorthands, there is the cascade notation, identifiers with a leading underscore are library-private, etc. Flutter is quite cool, though. It doesn't use a WebView and the runtime is about 6 MB in size. The applications are AOT compiled and start instantly. Performance on Android and iOS is pretty great. And there's live reload which is pretty damn cool. Basically, you can reload the changed parts within a few ms without destroying your app's state. You can immediately see the changes inside the emulator or on an actual device.
"To err is human" is a saying for a reason. It's all high and mighty to sit on your imaginary throne and proclaim loudly &gt;MAKE FEWER ERRORS! But you know what? To err is human. Humans will always make errors. You think you're perfect. You're far more fallible than you can possibly imagine. I've seen more narcissist "uberprogrammers" like yourself chewed up and spit out by the industry than I can count. It's people like you who are toxic to their companies; and you're the only type of people I've ever actually enjoyed firing. It's like a great weight is lifted. That psycho guy who blames everyone else for being inferior to him as the reason for why all his unit tests failed being gone just makes the team function so much more coherently, it's amazing. Anyway, kid, good luck. I'm out for the night. I know I haven't changed your mind. Your next few pink slips might, if you're half as smart as you proclaim. 
Not even close to what I said. But ok. 
Pretty sure this is 100%
YDKJS
Knowing that everything does at least theoretically fit together does indeed put you at ease. It makes updating libraries and refactoring a lot less stressful.
Prototype and Script.aculo.us had a 2y or so moment in the sun in the mid 2000s.
Yeah, one of the apps I work on is Backbone. Or, more specifically at this point, Marionette (item views with lifecycle methods, collection views) + Epoxy (data binding) + Ampersand-State (a better Backbone.Model). It's certainly far better than jQuery spaghetti, and it gave us a reasonable toolset to work with. That said, we added our latest couple features using React+Redux, and I'm sure we'll migrate features to React over time.
Same for me, starting out I found the use of slashes in not equals operators (\=) and lambdas too different from any other language I'd worked with. Reasonml was an easier migration for me as a JavaScript dev.
I haven't had the time to really use elm, yet, but I definitely want to. Its haskell-like syntax is very clean and I love the functional approach. Oh and the compiler is really nice - the hints it gives are often times amazing. I am not sure of how I like ports for external javascript and how often they are necessary in an actual production app, though.
Although there are some similarities you can not really compare python and elm. Elms syntax is more comparable to something like haskell.
1. WTF Backbone was not that long ago, and I feel it predates "peak fatigue" which I'm not sure we've passed yet. 2. Prototype and Scriptaculous baby, though I wouldn't call jQuery a framework. There were also Moo Tools, Dojo, YUI, some others. But jQuery still predates the era of hundreds of mediocre MVC frameworks. There were definitely far too many MVC frameworks, such that no clear winner was really obvious apart from Backbone, which was *very* minimal and offered no clear guidance on its use. The first ones to really try to be a full opinionated paradigm were probably Ember and Angular. I had done a lot of Cocoa, WinForms and Qt programming and didn't like either by comparison, and threw my hands in the air until React came along. And now a bunch of stuff has surpassed React IMO in terms of ease of use and safety. For me the biggest horror story was adopting Dojo on a large web app. Dojo provided the hundreds of widgets that the app needed, but no reasonable paradigm for binding the UI structure to data, so it was almost impossible to make UI's that manipulated said data in interesting ways. I didn't realize I also needed that until it was too late. Its MVC package makes no more sense to me the 20th time I've read the docs than the first, and the widgets throw utterly useless exceptions if you look at them funny. It uses AMD modules, but won't build with webpack. Its own custom build system is impossible to get working because the documentation has no complete working examples, but lots of meaningless essays on the true nature of a build tool. (I've wanted to vent about that for years now, but at the end of the day it's open source and I feel bad.)
Server rendering, next and nuxt. They are not in mainstream yet, but they will most likely be there soon.
For me these frameworks got me out of the mess that Angular 1 caused, it's much easier to structure frontend apps these days. What in particular is causing issues? Maybe a strongly typed compile to JS language like Elm or Reason is more your thing? Definitely not mainstream yet but this workflow could well catch on.
&gt; equals signs belong in two places: assignments and comparisons What are you referring to? I can't figure out where else in the Elm syntax `=` is used.
I'll wait for bug you've just created to be resolved. :) This looks more like a bug in Flow rather than intentional unsoundness. :)
I'm a CTO and I've managed automation and development teams in Ireland, Poland, China and Hong Kong. Instead of focusing on frameworks and programming languages, you can separate yourself from the crowd by working on the following: * Good communication skills * Teamwork (no skill or knowledge hoarding) * Writing technical specifications before writing code * Incorporating unit tests into your workflow * Learning and following best practices * Learning common design patterns And the most important for career growth: * Learn the politics game, and network whenever possible
Why would Restore be better than Redux?
They guy that does the web tools weekly newsletter has an ebook for dom/js tips and tricks: https://www.impressivewebs.com/javascript-dom-tips-tricks-techniques-ebook-2/
It will be effected. Seo isn't just the ability for Google to index your site. It's the ability for every other site (bots, social sites, sharing, bookmarking) to see your content, which in turn helps Google make better decisions about where to rank you. 
It's actually pretty easy with react-apollo and nextjs
Dunno if these are exaclty right for you, but in terms of discovery, maybe you could use: * WebBluetooth: https://github.com/WebBluetoothCG/web-bluetooth * Or maybe mdns/zeroconf * Or theres a new thing called flyweb by mozilla: https://hacks.mozilla.org/2016/09/flyweb-pure-web-cross-device-interaction/ 
Other way around... IE was actually the first to support XHR by way of the MSXML2.XMLHTTP COM control. That was first released for IE5 in 99. It was later reimplemented by the Gecko as `window.XMLHttpRequest` and the rest is history. https://en.wikipedia.org/wiki/XMLHttpRequest#History
**XMLHttpRequest: History** The concept behind the XMLHttpRequest object was originally created by the developers of Outlook Web Access (by Microsoft) for Microsoft Exchange Server 2000. An interface called IXMLHTTPRequest was developed and implemented into the second version of the MSXML library using this concept. The second version of the MSXML library was shipped with Internet Explorer 5. 0 in March 1999, allowing access, via ActiveX, to the IXMLHTTPRequest interface using the XMLHTTP wrapper of the MSXML library. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/javascript/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
None of that is useful in agile.
If you really think that's true I think we have a pretty good idea why your projects are a mess. Only writing technical specifications from that list wouldn't come under agile, the rest are very much recommended.
Restore aims to combine the best patterns from Redux (action dispatching) and MobX (observers) while greatly simplifying the interface of the store.
jQuery?
Learn C++ in case Web Assembly takes off
[removed]
I remember when Knockout.js was popular. It was the beginning of two way data binding being mainstream in JS (what Angular 1.x thrived on). It was okay but having to make variables observable everywhere was a pain. Also there was not that much best practices on how to organize ES5 js apps, var self = this; was your friend. This was around 4 years ago. Then we moved to Angular 1.x, it was amazing, Vue is what Angular 2 should've been based on v1.
It's okay, I have problably found some through r/learnjavascript. I mostly wanted to know in case these novices would stop replying, how I would best write a new post. I understand your position, and I wish I could teach all 113k, but that's hard. :( Next time I'll write on r/learnjavascript and cross-post to r/javascript, so if you or some other mod act on that rule (which I understand must exist), no big harm will be done.
**Here's a sneak peek of [/r/learnjavascript](https://np.reddit.com/r/learnjavascript) using the [top posts](https://np.reddit.com/r/learnjavascript/top/?sort=top&amp;t=year) of the year!** \#1: [The Entire JavaScript Language in a Single Image](https://fossbytes.com/wp-content/uploads/2015/09/infographic-the-entire-javascript-language-in-one-single-image-491250-2.jpg) | [29 comments](https://np.reddit.com/r/learnjavascript/comments/675fk4/the_entire_javascript_language_in_a_single_image/) \#2: [This pretty accurately describes my feelings on my JS learning journey so far.](http://imgur.com/zKJt5rb) | [6 comments](https://np.reddit.com/r/learnjavascript/comments/5k71cn/this_pretty_accurately_describes_my_feelings_on/) \#3: [Learn Modern JavaScript for Free (topics covered: webpack, nodejs, npm, es5, es6, esnext, &amp; rxjs, typescript)](http://courses.angularclass.com/courses/modern-javascript) | [29 comments](https://np.reddit.com/r/learnjavascript/comments/4vz5y6/learn_modern_javascript_for_free_topics_covered/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/5lveo6/blacklist/)
My experience is that it doesn't work at all. Using angular,Google keeps indexing the name of custom directives. 
Do you realize that what you have described is a weak type inference, that leads to a type coverage directly proportional to the number of annotations you manually type? http://thejameskyle.com/adopting-flow-and-typescript.html
The 90's was a very different era. I remember working for an ISP and early web host in 1998. I built a simple web builder in DHTML (client application before we talked about a web stack). I allowed the user to create a site from a template, then populate the template dynamically. There was a simple script in perl that we used to save the whole thing. XHR and Ajax wasn't available, so everything was handled through what Microsoft called a "postback." Everything was built from scratch and development was tricky. It was fun, though. I wouldn't want to return to the time when the tools we have today didn't exist, but it was definitely an interesting time. TL;DR client side frameworks are really new, and we still have a long way to go to sort everything out, but it's far better than the "bad old days." 
Do you realize that that article is a bunch of theoretical wankery that has nothing to do with real world usage? 
There definitely are gotchas. https://medium.com/@gajus/react-application-seen-as-a-blank-page-via-fetch-as-google-afb11dff8562
There are many tricks, such as the ones listed [here](https://stackoverflow.com/questions/40153206/detect-all-browser-console-open-or-not) that can be used. Just know that nothing is 100% reliable so it shouldn't be used as a "security system". &gt; Never trust the client.
Elm actually inherits from OCaml, so it's probably easiest to make sense of if you come from something like F#. If you're looking for something like Haskell, take a look at Purescript. 
In declarative systems you are the one that mounts children in place. If contents change, the component will be re-rendered. Dynamic children can get a key property which the renderer can treat as a keep-alive. You can also receive properties before the rendering stage and act on it, change contents, etc. I don't think these systems rely on mutation observers, they have a virtual dom that is easily managed.
[Ok](https://media.giphy.com/media/F3G8ymQkOkbII/giphy.gif)
All the languages you mention are ML derived languages, you'll spot similarities in all of them.
https://pastebin.com/GR5f4nM7 I made this hash with this code above, can anyone get the password? mweW8LQs650RgA4uqhw9qw$d5u/cZtc+ywJqkuDmtZDxGFcIq/WgYmvqEeIQuhfAfk
There's isn't an event you'd be able to listen to, and even the height approach relies on `resize` so unless you want to be polling all the time to check, I don't think you have any options to distinguish, and I'm not sure I'd want that? What are you hoping to use the distinction for?
Sure, but the OCaml (objective Caml) connection is important since it is the direct relative between Elm and F#. Purescript is a direct descendent of Haskell which has moved pretty far from any original ML relative. This is why I was so specific.
Usually React applications are single page applications with the routing logic handled client side by JavaScript with libraries like [react-router](https://github.com/ReactTraining/react-router). Your backend should only be an API server where you can grab your data from (with REST or with GraphQL) and the [fetch](https://developer.mozilla.org/en/docs/Web/API/Fetch_API) API. Logically you will also need an HTTP server to serve the static assets (JS, the index.html, images etc) generated by your bundler (webpack)
If you tell people how the salt is generated ( ex: $argon2d$v=19$m=1048576,t=5,p=3 ), can't someone just plug in the same thing into argon2 and just broot force the password field?
As long as that works for you, you're probably better off doing it like that. However, at the point where you start considering that you might want to embed related models into the models you're returning so that clients can query more efficiently without extra roundtrips, that's the moment you should take a step back and consider whether GraphQL might help you there. It probably will.
Ok thanks 
*Client-side Javascript web frameworks* aren't that old. 2010 is when most of the first generation of them first came out. In JavaScript-web-framework time that's practically prehistoric.
I'm sorry, but I don't understand either. I don't think the best part of Redux is the action dispatching, but immutability, which you seem to be throwing away. Immutability is what makes it cheap and transparent to decide which components need to rerender. But if I want to be using mutable state, then why would I choose this over MobX? What's preventing anyone from writing actions that modify MobX state? And it seems you're also taking a step backwards by having to manually decide which sections of your state are modified and thus which components need to rerender, which is all handled automatically by MobX.
Do not forget about knockout js, and the backbone bindings for it backbone js , awesome days :)
With the normal MVC based model the controller coordinates fetching all the data the views might need. With Relay the components (views) say what they need. A comment component might say "before I'm rendered I'll need the comment text, the author name, and their profile pic". Relay looks at all of the data requirements for your entire app and fetches the data efficiently. The result is less plumbing and boilerplate in your application code, and less wondering if you're fetching too much or too little data. This is especially useful if you have lots of developers contributing code to a single page (like the news feed on Facebook). 
That sounds really useful, actually! Thanks for the clear and concise explanation of what Relay is handy for, I may have a place for that in our architecture after all. 
&gt; I've always heard that the JavaScript world was overwhelmed by far too many frameworks before jQuery became a popular standard for browser consistency, and Angular and React were the big names for frameworks and libraries respectively. This isn't accurate - or at least your definitions/timing are off. Back in the beginning of the web in the 90s, everything was done server-side in static pages. Then with JavaScript (after 1995) devs could start sprinkling in some client-side scripting - rotating logos, accordions, etc... but browser inconsistencies were rife, si it was a huge ass-pain to support all major browsers. This was the era of (un-ironic!) "designed for Netscape Navigator/Internet Explorer" images on web-pages. The next big leap was Microsoft inventing the XMLHttpRequest object that permitted "true" client-side web apps. This first happened in 1999, but they didn't exactly shout about it, and it flew under pretty much everyone's radar until around the middle of the following decade. Next up devs started getting more serious about client-side scripting (especially given the possibilities XHR offered), and started writing **libraries** (not "frameworks" in the modern sense of a JS application framework) to abstract away browser differences and awkward browser APIs. This was the era of YUI, dojo, scriptaculous, prototype, and jQuery (that eventually beat all the others into a distant second place). This is likely what you're mistaking for "overwhelmed by far too many frameworks before jQuery became a popular standard", though technically these were more *libraries* or *UI widget* frameworks, not (application) frameworks as we use the term today. A combination of jQuery-like libraries and XHR (not to mention Microsoft beginning to lose control of the browser market, leading to a reigniting of the browser wars that started the trend of browsers and web APIs improving again) finally set the scene for real modern client-side web application frameworks somewhere around 2010 or so, with MVC/MVVM/etc frameworks like Backbone, Ember, Knockout, Angular, etc. Angular 1.x comprehensively won that battle, but limitations in its architecture started to show and Angular 2.x was a huge rewrite that caused a lot of controversy, directly seeing the scene for React+whatever (usually Redux, but not always) and even more recently Vue to start eyeing its crown.
/r/dankmemes
I develop on a major enterprise platform (SharePoint), and lately all of my webapps have been pure frontend. SharePoint has a powerful REST API where i get and populate the data of my webapp with. The beauty of React is that it really only cares about the view part of the application. The logic behind it is solely up to your choosing. That's not to say you can't USE React on the backend, [you can](http://redux.js.org/docs/recipes/ServerRendering.html), but you're going to need something else to drive the application logic.
Hmm feels weird that they would run fetch as google on phantomjs.. Their crawler doesnt use phantomjs right? I'd assume they would use chrome headless. I also had the same issue on a feature spec with phantomjs. I think it didn't support Array.prototype.bind.
Disclaimer: I don't know Elm, but I do know F#, both of which use the ML syntax. In F# (and i'm guessing most or all other ML languages) the `=` is used as a boolean comparison e.g. `expected = actual`
Express is perfectly fine for React..React doesn't really care what is on the backend..you can use a REST API or just query GraphQL ..both can be achieved in any backend programming language..so you select the one you are most comfortable with. That being said ...if you don't need a database you don't need a backend for example..if you just need user management you use a 3rd party service, you can use serverless architecture and so on
I agree on a strongly typed JS derivative. I quite like the way FlowType works. You can use it in your current projects without changing anything and gradually include more types. 
Totally agree. 'FlowType is the better typesystem but we chose TypeScript anyway because we "believe"..' I've tried both and maybe this has improved by now, but keeping track of definitely-typed definition files was hell to me, definitely did not improve my code/maintenance/productivity as fast as flowtype did.
&gt; Although it's kinda similar to Python, equals signs belong in two places: assignments and comparisons. Which are the two places they are used in Elm as well...
For me Elm is the logical consequence of taking the React/Redux approach to the end of the line. It has the same philosophy, but in a much cleaner way. I like a lot about Elm: * The succinct, crisp ML-like syntax. * Immutable values and stateless functions. * Focus on usability for the developer, where the core language is kept small and simple. However, I fear that the functional approach and the (to many) unfamiliar syntax will impede adoption. I would also like to see Elm used more as a general purpose language. As it is now it's tightly tied to the web and the Elm architecture. For now, I'm watching it with anticipation. 
In elm it's ==
I don't agree. Both OCaml and F# support object-oriented programming and mutability. Like Haskell, Elm has non of those. I'd say Elm is a simplified version of Haskell/Standard ML. Purescript is more of an expanded version of Haskell. 
&gt; BTW, why you are being so hostile? I don't mind but I am a little curious. What is happening there? Because you respond to half of my argument, and when you do, you respond as though you only read half of the words. Maybe English is a problem for you? You also ignore my initial argument. You say that Javascript has "just your typical generic low level construct which are not suitable for anything beyond C" and I show you how Javascript has a built in notation for defining trees while in C I have to roll my own underlying datastructures to be able to represent a tree at all. How does that not the Javascript syntax more suitable? We'll never know, because you're suddenly wanking over metaprogramming. I am hostile because it's like talking to a wall, and after a while you start throwing rocks at it to elicit a response and figure out what you are dealing with.
Since most of your react app will be static files, you can serve them with any web server (like nginx, apache etc). Express can also probably fill this role, but you might not want to use it, since other servers serve static content more efficiently. If you need server side rendering of your app you can likely use express for that part, and any necessary backend can be written with express aswell.
Is there a source for that? Syntactically and semantically Elm seems incredibly similar to Haskell, and not very similar to OCaml. Example: Elm enforces purity whereas OCaml is mutable by default.
&gt; I would also like to see Elm used more as a general purpose language. As it is now it's tightly tied to the web and the Elm architecture. Hear, hear. Elm almost seems like someone took Haskell and applied the Go philosophy to it, which is an exciting place for a language to be.
Blockchain
Elm really shines when your codebase starts to get bigger. And when the time comes for a bigger refactor / feature rework you simply cannot make mistakes because the compiler wont let you. The kind of mistakes are to some degree avoided by a robust test suite, but most often tests are not 100% or simply tests are also wrong after the actual refactor. Elms compiler makes sure you have the correct data structures and your logic flows correctly. Still, Elm is young and showing promise. I still think however the elm architecture is a blessing and a curse. A blessing because all your code is written in the same manner so if you know it its quite easy to start on a existing project. A curse because sometimes it feel like its not the right abstraction. Well, elm is still very bound to the web, and i would love to see it growing past that too. The ports system is a safer way to interact with pure JS, but sometimes it too requires unnecessary boilerplate code.
You building something and you dont want your users to cheat with the devtools right?
Here is a sample program: "use strict"; function foo(n) { if (n===0) { return "done" } else { return foo(n-1) } } console.log(foo(10000)); In Safari `"done"` is printed to the console. In Chrome I get a stack overflow. 
Use Express for a REST JSON backend, consume the API in the frontend. Pro: - Loosely coupled frontend and backend Con: - Slower initial page load, SEO You can overcome the disadvantages by rendering the initial view server-side, which is a bit difficult but certainly not impossible. 
DocumentFragments don't really offer any real advantages when building UIs today or UI libraries/frameworks (I did extensive experiments with them when working on Inferno and, recently, React). What you've described can be achieved from creating an element that isn't attached to the DOM and doing the same operations to it. It's fairly simple to roll your own virtual DOM and there are a few good articles around explaining how to go about it. I'd recommend also checking out the sourcecode for some of the popular lightweight virtual DOM libraries to see how they do it (Inferno, Preact, Snabbdom, Mithril etc).
React gives absolutely zero fucks about your backend, and how you get the data from said backend into your frontend. You bring in your data and it will *react* (see what I did there) to the data changes and make a nice pretty UI. &gt;are there webapps that are ONLY frontend? Yeah, think "offline" browser games, meaning no multiplayer or online features. Just load an app into the client, and away you go, no need for a backend. &gt;As far as i know react is a frontend framwork so what does it use for the backend? Whatever you want. Just fetch the data as you would normally and pass it into your components. Also, React isn't a framework. It's a library. &gt;How would it communicate with a local database? Exact same way any JavaScript app would. Remember that it's just a library, it changes nothing about the language you're writing and the environment you're working in. The way JS interfaces with browser APIs is exactly the same no matter what tools you use, unless of course those tools are an abstraction of the APIs. &gt;In the tutorials I've read so far I havent really seen the backend aspect mentioned. Because it's a purely frontend library the backend is of no concern to React at all. The backend could just be a black box that spews out JSON and nothing else, React couldn't care even if it wanted to.
Flash also had a backend, specifically for rich media (videos and such), called something like MacroMedia server.
Yes there are apps that are only frontend, but there are a lot of things which you can only do with a backend of some sorts: - persisting data (with high certainty + across multiple devices per user). - sharing data between multiple users. - doing anything with the data besides displaying it within the same app. So the things you can do with a webapp which does not have any backend are limited. Hence why almost every app has a backend in some way or another.
Baby steps :)
&gt; to be polling all the time to check You don't have to poll, just listen to the `onresize` event.
Imagine a new developer sits down and you're trying to describe all of the domain models in your large organization. You could make documentation but it is always out of date because people suck at documentation. You could give them swagger urls but you've got 10 APIs so that's going to suck to grok. How do I walk all of the data in all of the various micro services across a large org in a coherent manor? It actually requires a significant amount of cognitive overhead and training time from existing devs (which slows down their development). Additionally with REST, your front end tends to over fetch. If your page needs only one property off a given model, do most rest endpoints allow you to get this level of granularity? Nope, you get the firehose. Graphql works really well with REST actually because it lets REST apis just serve resources instead of caring about micro optimizations for various views in various apps. One thing to note. There should really only be one GraphQL API per company. It is the entry point that requests flow through on their way to various rest apis.
Remind me very much of the lovely Vue/Vuex. Everything ends up trending towards the same I guess.
Can you explain why you think immutability is being thrown away?
&gt; What you've described can be achieved from creating an element that isn't attached to the DOM and doing the same operations to it. Mostly, but not quite. The primary differentiation is whether or not you must access your DOM stuff through the `document` object. If you need superior static analysis than what the DOM methods provide you can use this handy-dandy library: https://github.com/prettydiff/getNodesByType/blob/master/getNodesByType.js
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [prettydiff/getNodesByType/.../**getNodesByType.js** (master → 774c241)](https://github.com/prettydiff/getNodesByType/blob/774c24130011cde7eca5d4c666226771d5b0aee2/getNodesByType.js) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply djojybd.)^.
Someone ought to create a new JavaScript framework based on Elm. 😉😏
Because in the example your update function seems to mutate the state directly (`state.text = newText`)?
The updater function is passed a copy of the state (or partial state) and returns an updated version of it. You don't have the ability to mutate the internal state from update.
First, learn the basic stuff then go for both, can i do this?
Excuse my stupid request. Can you go into more detail? Do you work with SP 2013 on-prem or o365? Do you write Apps or use Content Editor webparts and libs to provide the files? Do you use babel or process the code via Gulp and the like beforehand? Would really like to know more about this. I've been struggling a bit on how to properly approach React and SharePoint. I'd appreciate your input. Thanks!
Already done. It is called choo js
&gt; How does that not the Javascript syntax more suitable? For only defining generic trees? Still a very low level and generic notion. But I admit my statement above was a little bit wrong worded (still doesn't have pattern matching and other tree facilities, nor means to work with the DOM). Doesn't change the fact that is still low level and not too detached from the semantics of C. 
shameless plug, but take a look at https://github.com/leeoniya/domvm also evaluate: https://github.com/thysultan/dio.js https://github.com/hyperapp/hyperapp https://github.com/picodom/picodom https://redom.js.org/ https://mithril.js.org/ https://github.com/AFASSoftware/maquette
I happened to test tail calls on Node 7 where they are supported using the --harmony-tailcalls flag. In Node 8 and 9 support for tail calls were removed - and there is no flag. That means I need to find a version of Chrome that used the same version of V8 as Node 7 did. 
yes, React is a frontend framework. It has no components that run on the server and its interaction with the server backend is limited to ajax requests set out for data, most commonly a request made to fetch new data (from a JSON endpoint) for a frontend model, or to PUT/POST/DELETE back to the server to update the model. However, all of that stuff is outside the scope of what React does and will vary depending on your backend. You can, of course, make a React app without a dedicated server backend and handle persistence in different ways. [Firebase for storing JSON data](https://firebase.google.com/products/database/) is a pretty good way to persist stuff in a very simple and lightweight way. 
Isn't the equals sign a match operator in Elm?
Hey, I am an spdev, and although my tool of choice for front end is currently angular 1.6 (written in es6, using components etc, a pretty modern approach), it would be exactly the same if I used react. I work in a on prem environment mostly building SPAs on top of SharePoint. I usually deploy files directly into the site file system by mapping a network drive at the root of the site collection. That keeps end users from messing with therm. For dev, I use webpack and set the output directly to the mapped drive, so every rebuild goes directly into SharePoint. I just access the index page to run the app. You can even set up live reload on the page. You can also build SharePoint hosted add-ons in a similar fashion, but it is a bit more complex dealing with the visual studio solution, appwebs and so on. It's a very powerful, very underrated method for developing business applications. 
No. Maybe you are think about Elixir. In Elixir the following will compile: x = 1 1 = x That will not compile in Elm. In Elm the '=' is used for assignment only. The '==' sign is used for comparison.
I would suggest trying hyperapp or preact, both are really lightweight frameworks with great support. Unless you want to build your SPA just to learn how to do it. To be honest, if you plan on using this for production, the implementation built by a single person is not going to beat any framework built by a community (unless it's a really good one, like hyperapp).
React is a view library. There is no "correct" backend to pair with it. Views don't have opinions about web servers. Or at least they shouldn't. 
I see. But that means you have to make a deep copy, right? That seems quite inefficient, not just for the updaters themselves, but also for the components that no longer have a way to (quickly) detect whether any state relevant to them has changed...
I seem to like DomVM and ReDom. However, I was thinking about Riverts (http://rivetsjs.com/docs/guide/) or something like that + jQuery in EventEmitter - Listener pattern in functional programming flavour for refactoring simplicity.
Thank you! I've mostly been working with SP2010 or o365, so I don't have much experience with 2013 on-prem and Apps. Unfortunately my company seems to favor old-fashioned solutions, leaving our Devs only their own spare time to experiment with newer technologies and frameworks. It's always nice to hear about these things first hand. It's a shame that we're told not to use them because we don't have the experience and it's too risky; but can't learn without ever using them.
This is why targeting is useful to act against a small part of the overall state. Connected components will only rerender when a value they consume from the store is targeted by an update.
I guess functional programming just isn't my way of thinking. If it ever gets to the point where it's in any way necessary to learn for web development, I'd probably give it a second chance.
judging by your original post, it seems you're quite capable of evaluating what works best for you, so good luck!
I understand that part. But if you apply your targeting to a component that has a lot of child components, that component can no longer pass any state to the child components without forcing them all to re-render as well, because no instance within the state tree will ever be the same. So either you have to apply targeting for every component, no matter how low-level, or you just accept to sacrifice quite a bit of performance. Basically, it appears you have re-introduced the burden of manually balancing what part of your tree to rerender, which was a problem that was pretty successfully solved with MobX and which is easily solved with pure components in the case of Redux.
Your example requires data flow analysis. TS does type inference. E.g. if you write `let x = 5`, the type of x will be number. If you add two numbers, the result will be a number as well. Things like that. TS does some flow stuff for non-nullable types. Once you've determined that something isn't null/undefined, the analyzer will remember this. This is what makes using that feature as little annoying as possible. Here is a small fully typed example which relies on type inference: https://i.imgur.com/rdqv2mq.png The first two casts are for turning `Foo | null` into `Foo`. I didn't bother to handle the potential null cases (element not found &amp; Canvas API not supported) properly. Annotation #4 is superfluous. That `loadImage`'s return type is `Promise&lt;HTMLImageElement&gt;` can be inferred. However, I prefer to put the types on function signatures. So, this example is actually slightly "over-typed".
https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest Not supported in IE until 7
That's ridiculous. People still use Knockout. OP context was 90s - 00s which makes 2010 futuristic.
How on earth is Vue a "heavy" framework? A full-featured Vue project with Vuex + vue-router weights 30KB gzipped. 
Why would you want to do this? You'd be making your life really hard for no real reason.
[removed]
Not the OP but if one were to make this setup, since anyone could look at your frontend logic how would you secure the backend API if you wanted it to be closed to outside users? 
Job security perhaps ? /sarcasm
this is a really bad idea, there's no reason to not use a framework on a production SPA
As the other comments said: a typical SPA is backend-agnostic. Client-side code shouldn't care whether your backend is built with Express, Koa, Python, Java, .NET, whatever. Doesn't matter as long as it exposes APIs that the client can talk to. So, most tutorials just focus on building a React client-side app, and it's up to you to decide how you're going to build your backend. I just added a section on [React Deployment](https://github.com/markerikson/react-redux-links/blob/master/react-deployment.md) to my [React/Redux links list](https://github.com/markerikson/react-redux-links). To pick out a few relevant articles: - [React with Any Backend](http://andrewhfarmer.com/react-with-any-backend/) - [Understanding React Deployment](https://medium.com/@baphemot/understanding-react-deployment-5a717d4378fd) - [Deploying a React App Alongside an API Server](https://www.fullstackreact.com/articles/deploying-a-react-app-with-a-server/) - [Create-React-App with an Express Backend](https://daveceddia.com/create-react-app-express-backend/) and [Create-React-App with Express in Production](https://daveceddia.com/create-react-app-express-production/) Also, since you said you're new to React and frontend dev in general, here's my standard advice for learning React: The article "A Study Plan to Cure Javascript Fatigue" ( https://medium.freecodecamp.com/a-study-plan-to-cure-javascript-fatigue-8ad3a54f2eb1 ) is a great place to start. It gives an excellent series of steps for tackling modern Javascript concepts one piece at a time: Javascript, React, ES6, and state management. There's also a "Front-End Study Guide" based on that article that's very good, at https://github.com/grab/front-end-guide . On that note, definitely don't over-complicate the learning process by trying to learn many different things at once. Some people will say you should use a "boilerplate" to learn React, and they're wrong - boilerplate projects almost always come with too many pieces configured, and are confusing for beginners. Instead, the best advice is to focus on learning React itself first. Once you have a good understanding of how React works, you will better appreciate why a state management library like Redux can be useful, and you can learn about other tools later. You should start out by reading through the official React docs and tutorial at https://facebook.github.io/react/, and I'd encourage you to use the official Create-React-App tool ( https://github.com/facebookincubator/create-react-app ) for setting up projects. It creates a project with a solid build setup, with no configuration needed on your part. There's an excellent post called "Simple React Development in 2017" ( https://hackernoon.com/simple-react-development-in-2017-113bd563691f ) that gives some more specific instructions on the actual steps to follow. Past that, I keep a big list of links to high-quality tutorials and articles on React, Redux, and related topics, at https://github.com/markerikson/react-redux-links . Specifically intended to be a great starting point for anyone trying to learn the ecosystem, as well as a solid source of good info on more advanced topics. It includes links for learning core Javascript (ES5), modern Javascript (ES6+), React, and much more. I also published an "Intro to React (and Redux)" presentation at http://blog.isquaredsoftware.com/2017/02/presentation-react-redux-intro/ , which is a good overview of the basic concepts for both React and Redux. Finally, the Reactiflux chat channels on Discord are a great place to hang out, ask questions, and learn. The invite link is at https://www.reactiflux.com .
If you target 'a.b.c.d' and a connected component consumes 'a.b' and passes values down to it's children. You could use pure components so only the children passed values from 'a.b.c.d' would rerender.
Also this is from the next paragraph of your will reference: &gt; Internet Explorer versions 5 and 6 did not define the XMLHttpRequest object identifier in their scripting languages as the XMLHttpRequest identifier itself was not standard at the time of their releases. Access to active x through msmxl sounds like epitome of proprietary.
In node it's very easy to protect an endpoint with tokens. JWT does this very well.
Aah, okay. I thought ML was similar to Erlang/Elixir in this regard.
You can't access the backed API unless you integrate some CORS policy or token auth to expose it. This is no different then not using React. All of your assets React included get bundled into static assets served up by the express server. 
I was thinking the other way around: If your update function targets 'a.b' all components rendering 'a.b.c.d' will have to rerender, regardless of whether 'a.b.c.d' has been modified or not (maybe the updater was only modifying 'a.b.e' and 'a.b.f') and pure components cannot detect that anymore because of the deep copying.
First I would say if the update was only modifying 'a.b.e' and 'a.b.f' it should be two update calls targeting each. But yes, currently that's true and a trade off for never being able to accidentally mutate the state. In the future this could be solved by allowing the updater to return partial updates. I also just wanted to take a second to say thank you for the feedback, it's great to have another set of eyes and opinions.
To know exactly how everything works and not to have downtime on researching and debugging. Similar to custom PC builds. You have a choice to choose components (not stuck on some lame capped CPU for example). And if something breaks, you do not need to guess what is placed where how and with which screw with OEM. Also, you can throw in any aftermarket makes of the parts. Take custom build PC and All-in-one. What's easier to setup - All-in-one definitely, plug and play. What is more petfomant for same buck - custom build definitely. At least in cooling terms. What's easier to maintain - custom build again. 2 Pros vs 1 Con :) 
Haskell for front end? Doesn't this belong in the /r/softwaregore sub?
You're quite naive if you think forgoing a battle-tested framework with hundreds/thousands of contributors for something hand-rolled on your own is going to be more performant and easier to maintain in the future. Especially if you ever need to bring on more developers than just yourself.
Custom PC build is same as React+React-Router+Redux. What you want to do is same as making your own CPU, RAM, Motherboard and etc.
You're welcome :) But I'm afraid your suggested work-around wouldn't work because the way immutable data structures work: if you want to replace 'a.b.e', you have to replace 'a.b' and 'a' itself as well, otherwise 'a' and 'a.b' wouldn't be immutable. Now you can kinda pretend this effect isn't there, because your observer can simply not inform any components that are watching paths you know to be unaffected (such as 'a.b.c' in this case). But even then, when an action modifies 'a.b.e', you do need to rerender every component subscribed to 'a.b' and every component subscribed to 'a'.
Could you talk about what JWT is and how this is accomplished?
I think if you would have left it at you wanted to know how everything works under the hood, that would be understandable. The analogy you use really falls through though because putting a couple PC parts together is nothing like making your own framework. 
Right, I was using the solution of not notifying which does work. If 'a.b.e' is changed anything consuming 'a.b.e', 'a.b', 'a' should rerender, things consuming 'a.b.c' should not. That being said returning partial updates would work outside of targeting requirements. 
OP's trying to learn some basic programming skills. PHP's a pretty good language to do that in. I wasn't suggesting OP would want to make a career in Joomla development or anything. Joomla has good tutorials on its website for developing "hello, world!" type extensions. It has a pretty simple API for working with a database, and good documentation with examples for doing so. Learning programming is easiest when you can see results from your efforts quickly, especially when the results are interesting and feel substantial (imo). YMMV.
ESPECIALLY IF HE DOESNT KNOW WHATS GOING ON BEHIND THE SCENES IN ANY OF THOSE FRAMEWORKS. Sounds like he wants to learn how to build a framework and get paid while doing it. Oh honey, you don't get both.
You should give Polymer a try, it's a lightweight library build on top of the webcomponent specifications. It has everything you need and relies heavily on the web platform as it is instead of custom framework code (https://www.polymer-project.org) 
Awesome walkthrough
I'm learning Apollo right now because I've heard that Relay has a really steep learning curve. Is this true? 
My colleague has had bad experience with it. Things get wild when more components are thrown in. Plus, polymer incorporates material design, meanwhile in my case, I get very specific design requirements :)
My goal is not to make my own framework. My goal is to stack up libraries to have full control under the hood, and to have interchangeable parts.
&gt; Never trust the client. And the server. Because we have the rights to inspect everything that runs on our browser.
What's the difference between this and Gulp/Grunt/NPM scripts?
Read the source code of existing frameworks. Determine what you would do differently and why. Then start coding it.
And how would you classify this then? https://developer.mozilla.org/en-US/docs/Web/API
Why would I want to build a framework? To maintain the similar-to others opensource solution with zero users?
Basic/Medium level knowledge.
And React/Redux as Extreme level of knowledge?
I didn't mean to insinuate jQuery was a framework, I meant that it was "a popular standard for browser consistency", but I see how it reads like that. Otherwise, I was interested in knowing what was around between 1995 (when JS was released) and 2006 (when jQ came out). Most of the answers refer to Knockout and Backbone which both came out in 2010, so I guess it was a combination of "not much", server-side scripting, and DHTML.
It looks a lot like gulp in terms of setup. Hopp claims to be faster. I will give it a try tomorrow and see if it works. 
[removed]
lol
Say I have a small framework in the pipes ,how would I go on testing it's efficiency performance and all related parameters ? Do I have to make a demo project using it and take it from there ?
React/Redux still requires low to medium knowledge. It's basic stuff. Writing React from scratch however, takes some high-level knowledge, loads of testing, and etc.
&gt; Choo comes with a shared state object. This object can be mutated freely, and is passed into the view functions whenever 'render' is emitted. Doesn't sound like it to me. 🤔😂
Yes, it wasn't formally available as `XMLHttpRequest ` until IE7, but the same functionality was present in IE well before IE7. var xmlHttp = new ActiveXObject("Microsoft.XMLHTTP"); https://blogs.msdn.microsoft.com/ie/2006/01/23/native-xmlhttprequest-object/
MS invented AJAX, so it was definitely proprietary, but I'm not sure what you're getting it... that's just the way it was back then.
I agree with your last paragraph completely. That's why I suggest leaving Joomla alone. You're forgetting about the steep learning curve involved with spinning up a Joomla server (compared to opening an IDE and writing JavaScript).
&gt; sounds like the epitome of proprietary It was, yea.... but say you wanted to build something cool that fetched JSON data from some web service what other option do you have? None, really. This innovation is what made IE the most popular browser (that and various anti-competitive behaviours, see `United States v. Microsoft Corp`.... there was also one against the EU around '09.) -- at least version 4 was certainly the bees knees, 5 had this new ajax thing and was pretty cool too.... but, by the time 6/7 came out it was, as you likely remember it (if you do at all, I do) 
Generally speaking, you should be thinking in terms of solving problems. If you're trying to explore ways to organize your code better, I like a top-down development approach: basically, write code that uses an imaginary framework which exposes your dream API, then go and implement the API and corresponding tests. If your problem is that you feel you don't know as much as you should, then try to manually implement each feature yourself, using MDN or codebases for similar OSS projects as reference material. If your problem is that the current crop of frameworks don't fit your needs, then decide what are the things that do work and what are the things you would like to change, google for libraries that can help fill the gaps, and put those libraries together to achieve your goals. It *may* be the case that no OSS libraries exist for your particular use case, but more often than not, they do. In a team setting, being familiar with a wider breadth of the ecosystem is just as valuable as being able to re-implement a Promise polyfill from scratch. So research first. 
[removed]
I think it depends on the way you build your component architecture. Polymer is used in production by some big companies for big projects (Google is using it for both Google Earth and the new YouTube for example). It just requires some more thought then a framework which often pushes you towards a specific architecture. Regarding the Material Design, that is indeed embedded in the paper elements created by the Polymer team. Polymer itself however has nothing to do with material design, there are loads of elements which are not using material design you could use (take a look at webcomponents.org) 
React is merely a library that works well with other parts too. In fact, you mention you want to use page.js for router: I can recommend it, I use it too... with React.