Nothing against JQuery or fa√ßade patterns! I use both of them a lot! The point was something else.
Interesting. I thought that MVC woould never die, and now here we are using Flux and Components. I'll check out your library properly when I get a chance. It looks interesting.
Yes, tools like [Babel](https://babeljs.io/) and [Webpack](https://webpack.js.org/) are examples that transform JS programmatically for various purposes. You could do this yourself rather crudely with [String.prototype.replace](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace), [Prettier](https://prettier.io/) and [regular expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions). This would be fine for very narrow, specific use-cases, or one-off transformations. But it has limitations and isn't robust or safe for more general cases, where things like unexpected comments or formatting in the source files might result in broken transformations. A more robust easy to do this is by transforming first to an AST (abstract syntax tree). You then perform your transformation safely on that tree, and convert that back to source code. I'm glossing over the details here, because you can read more about them with a simple web search. But if videos are your thing, take a look at https://youtu.be/WO7H2NHmN18 Personally, I've used [jscodeshift](https://github.com/facebook/jscodeshift) which is what powers [react-codemod](https://github.com/reactjs/react-codemod) to help developers upgrade their codebases for latest versions of react.
Imho REST is only useful if you give explicit api access to your customers or 3rd parties. Because devs will know how to use them implicitly and you want to be in line with established practices. For everything else I think REST is pretty aweful, it sucks as a query language and having actions that are not CRUD implies you deviate from REST. I have done some work with a CQRS pattern using GraphQL as the query syntax exposed on a /query endpoint combined with an /actions endpoint where I send my redyx-style actions/events to. I find it really helps me keep a clean architecture as I don't spend time struggling to fit my application logic into a REST interface. And I get the added benefit of a bettery query syntax.
AngularJS will be around for a good few years yet. It's being used by banks, building societies and travel agents, and a lot of those folks are using $scope trees rather than components. It's not an easy upgrade path. Also, despite the bad rap it gets, AngularJS was quite nice. It didn't scale well, but for small apps it was luminous. You could wire together complex form interactions in minutes.
I'm not defending anyone or anything. I have 0 interest in this tech, this story, or these people. I just wish more tech folks internalised the fact that the internet is not an island, and it operates within IRL constructs, structures and laws. Then they might pay more attention to those constructs, perhaps paying as much attention to them as the tech things they actively care about - so they're not surprised when a "bad" thing happens, later on. Annoyed, maybe, if they **choose** not to mitigate the bad possibilities they've discovered, but "surprised" is the worst of all worlds. Being unprepared to learn isn't a hallmark of the awesome techies I work with. 
You guys seem to be hard at work on this, keep it up. I've been following your progress, hope to try it out in a project soon.
Automatic conversion was one of the routes we looked at. Unfortunately, rel-world code is more complex than that, and automatic conversion was harder than it sounds. Also, we have various legacy $rootScope and $scope stuff lying around, and things like ngDialogue receiving dynamic controller injections from services. We decided that it would most likely introduce a ton of bugs, so we chose a graceful sunset approach top the problem. Regarding big vendor files, yes, there is more JavaScript to download. We now have AngularJS and React. It's several hundred k. All told though, the speed boost we get by selectively rebuilding slow portions of the app in React more than makes up for the larger download.
Something would be extremely wrong if you had to "pay as much attention" to legal questions as technical ones as a developer. It's not even clear-cut that a trademark would have helped, but a domain name would have, by the company's own admission. Even if the legal rights were on the developer's side, enforcing them is very costly and inherently favors companies whith capital backing.
&gt;REST is the 800 lbs. gorilla Every king dies eventually. GraphQL will be the new pack leader. There's no other contender.
Most confusing explanation of closures ever.
I disagree. I've been transitioning our old restful API to GraphQL and I actually write much less code. There's less code because you don't have to define your routing. Resolvers are much more reusable across different frontend contexts IMHO. 
Was having this issue yesterday. Ended up switching to the more complex webpack build just because of this issue. Thanks for the fix!
&gt;Its language/framework agnostic graphql is language agnostic and there are quite good implementations for all major languages. If you're using some obscure language no one ever heard of you might need to write your own. &gt; REST is much more expressive and predictive than GQL Sorry can you elaborate? GraphQL is always much more predictive than REST in my experience. It exposes it's own schema, which cannot be said of REST. &gt;client query protocol(only contender *was* netflixes falcor) or something completely new. I don't expect any such protocol to even come close to the current mindshare of GQL. GQL train has left the station and the next station is "REST is obsolete" and it's coming up fast.
Let's keep this short: yes. yes. GraphQL.
Until the WebAssembler trampolining overhead is fixed, this is no better than doing it in JS.
&gt; Something would be extremely wrong if you had to "pay as much attention" to legal questions as technical ones as a developer The technical question here isn't "what're my day to day, tech choices about which library to use or which algo to implement?". It's a one-time "what name should I use?". That should have as much attention paid to it **at the time the decision was being made** as the legal question. Not on an ongoing basis, which I think is the implication behind your sentence. &gt; It's not even clear-cut that a trademark would have helped, but a domain name would have, by the company's own admission They are incorrect - it's exactly the other way around. Unless the company wanted to **use** substack.com but **call** themselves something utterly unrelated. As soon as they started calling themselves "substack", a trademark would have been (depending on the classes referenced by the mark's registration) the single thing needed to shut. that. down. Yes, the developer spending $15 on the .com would have been a de facto block on a company using it. But they could have bought .io, .co, .com.$TLD, .app, etc. The way to stop *those* things from happening and affecting you meaningfully is via trademarks.
Good start. Right off the bat, aside from using jQuery ( haha use whatever you want), I noticed that you declared everything using *let* instead of *const*. While this will work, it's not what the keywords were meant to do. Here's a post about the [general differences between let, const, and var.](https://medium.com/craft-academy/javascript-variables-should-you-use-let-var-or-const-394f7645c88f) 
Drove me nuts untill i recalled having this issue on another project, and looked there \^\^
Great job here, I love it
Who's incorrect, the company explaining the reason for their decision? Not sure what you're even trying to say. As far as armchair lawyering goes, a trademark has a limited scope, and it wouldn't even necessarily apply to an email company, while a domain name is universal. Secondly, as was pointed out in a different comment here, registration [isn't strictly necessary]. Thirdly, you get on a high horse about reality but have some mickey mouse ideas about how rights work. Rights need to be enforced, and the legal system clearly favors the side with more resources. [registration]: http://www.worldtrademarkreview.com/Magazine/Issue/54/Country-correspondents/Strong-rights-without-registration 
* https://stackoverflow.com/questions/17197084/difference-between-contentdocument-and-contentwindow-javascript-iframe-frame-acc * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else
You never understood scope*
üëç
I think it's a great concept, but only for the initial purpose, that was to progressively migrate a big app from one framework to another. I'm not sure if it's a good idea to permanently use this "technique". Currently, I started a new job at EdPuzzle, and just now They are in a middle of a big migration (Backbone to React) and are doing something similar. I must say that for me it was easy to start working on the project (I mostly focused on the React parts) without worrying about the legacy Backbone part that it's going to disappear at some point. If someone it's interested, there is one video explaining how we are doing: [https://www.youtube.com/watch?v=pV0zX84dZLo](https://www.youtube.com/watch?v=pV0zX84dZLo)
Looks nice. Would there be any performance benefits to using \`requestAnimationFrame\` instead of \`setTimeout\`?
[The Super Tiny Compiler](https://github.com/jamiebuilds/the-super-tiny-compiler) source code is a really good resource for getting started with transforming source code to an abstraction and then using that abstraction to generate the modified code.
I didn't mean for the comment to sound rude. Just felt like I was going to be reading about something different :)
Sounds about right. Can you be more specific about "But being nested they also have access to a lower level of variables as well."? Closures also don't necessarily require to exist in other functions. They're a combination of a function and referenced variables in outer scopes, and scopes can exist outside of functions. { let x = 2 let doubleX = () =&gt; x*2 // closure includes reference to block scope x console.log(doubleX()) //-&gt; 4 }
I think he was just making a facetious comment on the state of the JS ecosystem.
Thank you so much
looking really nice and elegant. is there something with similar design in React
[found this funny](https://gfycat.com/HomelyLivelyBlackpanther)
I haven't looked at GraphQL much, is it suited to perform non-data querying tasks as well? Like filesystem operations or other arbitrary tasks?
iOS 10 is the issue 11 is fine, but if that center was in iOS I could see it causing issues. As I said as well this was not an issue on an iPad running 10.3 so it must have been remedied in that version. 
Long winded and confusing, and when after you go through a bunch of steps and see: &gt; So our explanation above was all _wrong_ Well, that's just annoying :P Some other issues: There are places where there are references to the "calling scope" which suggests dynamic scoping which JavaScript does not support. Lexical scope is supported, which is based on where things are defined and not called. So seeing: &gt; So in this example, we need to remember that a function has access to variables that are defined in its calling context. The formal name of this phenomenon is the lexical scope. Seems completely off. The explanation for how closures work is through the backpack analogy where the backpack is the closure: &gt; Whenever you declare a new function and assign it to a variable, you store the function definition, as well as a closure. The closure contains all the variables that are in scope at the time of creation of the function. It is analogous to a backpack. But closures aren't something that are attached to functions; closures represent a combination of both the function and the "backpack". Functions don't have closures, they are closures. The closure example also talks about how the closure variable no longer exists: &gt; Returning the content of the `myFunction` variable. Local execution `context` is deleted. `myFunction` and `counter` no longer exist. This even though the whole point of the closure is to ensure that the `counter` variable does continue to exist. With this, the use of the backpack suggests that the values are copied into the backpack. This is also inaccurate because it's the original variables that get referenced, not copies that get attached to the function. If two functions reference the same variable in that scope as a closure variable, they'd both be referring to that same variable rather than their own individual copies. Going back to an earlier quote: &gt; ...The closure contains all the variables that are in scope... Technically this isn't true, at least not any more with every scope. I believe older runtimes always did this, and maybe there are still some that do it now, but generally what you'll see is that most cases only the variables referenced in the function are included in the closure. If the parent scope declared variables `x` and `y` and your function only refers to `x`, then `y` is omitted from the closure. Exceptions include the global scope which all functions have access to in it's entirety and (at least in Chrome) script and with scopes. This behavior most importantly affects other function/closure scopes since they're most likely to result in a memory leak when attempting to include everything.
Here is a video of the issue https://www.youtube.com/watch?v=6tAVIXEE1ek&amp;feature=youtu.be
sure. For example when using node.js any javascript function can be a graphQL resolver. So if you'd need to, you could create resolvers for each file system operation you need to perform. for example the query could look like: ``` {readFile(name: "readme.md") { content created_at updated_at size }} ``` same you could have a graphQL mutation to write a content of a file: ``` mutation { writeFile(name: "readme.md", content: "just a test") { created_at } } ``` Just be cautious about exposing this API to the public-you need to make sure people can't acces your whole filesystem via this API :D
Where did the name of the project originate?
That would be nice. Since it works on a complex set of nodes it may be hard to figure out which nodes offset your talking about. There's also mark.js that highlights specific words. 
What improvements would you like? 
The goal is to highlight one character at a time. If you really want to strictly enforce the exact duration of the animation, then animation frame would be better. 
Hi /u/deneb971, For javascript help, please visit /r/LearnJavascript. Thank you!
Not sure, but there is a possibility that Pixi.js does what you need. Basic demo for [filters](https://pixijs.io/examples/#/filters/filter.js). Documentation on [filters](http://pixijs.download/dev/docs/PIXI.filters.html) and [color matrix filters](http://pixijs.download/dev/docs/PIXI.filters.ColorMatrixFilter.html) (this is probably more what you are looking for). This may be way overkill for you, but I'd be surprised if you couldn't get the effect you were after. Plus it's wicked fast.
You may find this relevant: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/filter
Haven't really used Vue a lot, but this looks really amazing. Good work on this project. Will definitely use this once I get more into Vue!
And in terms of database performance? I heard or read somewhere that implementing a GraphQL backend means you end up with significantly more database queries for your API, because you cannot easily do aggregate queries since you don‚Äôt know what the request is going to be.... is that true?
Just a PSA: Micro services and Micro frontends aren't really aiming to address technical challenges. They're really patterns to address organizational challenges. I'm gonna argue that they're anti-patterns until you reach a certain number of engineers on a team. And by itself, micro services and micro frontends aren't really architecture patterns. Nothing's preventing you from creating a ball of mud with coupling problems just because you've split your frontend up into pieces. Just a reminder that it's a narrow solution to a narrow problem. 
No, like HTTP it's such a fundamental part of the web. However I think technologies like (g)RPC may become increasingly popular.
Thank you for sharing! Can you comment on performance when having to multiple frameworks onto the client during runtime?
Oh that's OK, you didn't sound rude. You are correct in that the pattern is component oriented, it's just another layer of components on top which gives us the benefits of an easy upgrade path between any and all frameworks. But yes, at heart, it is a component tree.
True. It's a pattern that becomes useful at a certain scale. We've grown from eight engineers to almost thirty in just over a year, and having everyone work on the same codebase was just not practical anymore. We ended up blocking each other's releases all the time. Micro-frontends give us several good things. They give us an easy upgrade path without compromising feature delivery or chucking away perfectly good code. They give us atomic deployment of features. And they give us scrum-team-level ownership of repositories. All of these are beneficial to us at this point in time. If we stopped being good though, it would be very easy to create a ball of mud.
That would be nice. Currently we getElementById and then just bootstrap apps into divs depending on the root. We also don't split the entire codebase along the vertical. Our app is a little more integrated than that, so all the front-ends can hit all the APIs to get the data they need. But yes, this is the general idea.
My comment probably seemed more negative than I intended. I do think it's a cool idea, and sharing the rationale, lessons from it are important!
I actually built a single, central ACL singleton for tokens and access control logic. It lives on window. Any app can require it, and it will instantiate itself into window if it doesn't already exist. If we need to pass small bits of data, we use the URL and routing. If we need to pass larger objects, we persist to the server, and then make an API call. This enforces separation between apps. We originally experimented with a global flux store, but we quickly realised interapp coupling was not such a good idea. So far, this approach has worked nicely.
You have good timing, I was just looking for something new for my next project.
Ask and you shall receive... 
It starts by telling 10 things he would have done differently, and then presents a new V8 Typescript runtime that fixes those issues, its called Deno - https://github.com/ry/deno 
Why the angry tone? Im not saying GQL is useless, just that it isn't a silver bullet replacement for REST. Using it for internal communication in a microservice environment would be fairly stupid since you'd have and extra library to keep updated and maybe even synced across services. GQL is not agnostic since need to setup a client i order to use it effortlessly. Two properly made REST API uses the exact same structure and can even expose a list of collections, all of which will have the exact same structure and commands for CRUD actions. That's fairly predictable to me. Falcor was pretty much the same as GQL, it's not really revolutionary, just a incrementally better way to do complicated queries from a client environment. GQL taking a good chunk of frontend client communication is a possibilty, but a full take over is virtually impossible, this isn't like when REST took over SOAP, there isn't a hatred of REST to help GQL here. GQL being controlled by Facebook is likely to make a lot of devs nervous and give the ones that used SOAP terrible flashbacks
[The slides.][1] [1]: http://tinyclouds.org/jsconf2018.pdf
I think bitcoin is a better example of proof of work than storj. 
Neither is an answer. 
that is kind true. In our case with GraphQL, we ended up with many more smaller resolvers than we've had koa route handlers previously. Each resolver typically does it's own DB query so I'd say it does tend to result in more DB queries. That's why you should usually use libs to get around this\-like [https://github.com/facebook/dataloader](https://github.com/facebook/dataloader) Keep in mind that this is not an inherent quality of GQL\-this is just consequence of the more fine grained structure your GQL APIs have.
Love the style, it's like a more modern material design. How'd you come up with the name?
Oh, lol! Works perfectly. Thank you :)
Eloquent javascript
Sweet ‚ù§Ô∏è
Call Kenny Loggins - because you are in the danger zone ;)
I don't do mobile apps, but I would think for most of them GraphQL would work great. It's a mechanism for requesting and receiving data from a server, so by nature it's independent of the front-end UI layer.
I've looked at my iPhone before and higlights didn't work. But now it seems like no problem.
HTP is *literally* the protocol for all web traffic (HTML, images, JS, CSS, etc.). You cannot do anything web-related without using HTTP. REST is design standard, a technique for organizing interaction points between a client and server; it's not even a specific (HTTP-using) technology, it's just an idea. The two seem pretty radically different to me.
I was merely correcting facts you got wrong. I wasn't too angry I think. &gt; GQL is not agnostic since need to setup a client i order to use it effortlessly. How do you use REST api's effortlessly? Yeah GET requests can be made easily just by pointing a browser to it, but as soon as you need anything more you need a tool. CLI or something like postman. Hell the browser itself is a tool primarily for making GET requests. &gt; Two properly made REST API uses the exact same structure No, sorry, I've seen to many "REST" apis in the wild to know REST isn't rigid enough to provide any kind of assurance of predictability. &gt; GQL taking a good chunk of frontend client communication is a possibilty, but a full take over is virtually impossible Why would it be impossible? For greenfield apps it's quite possible it will eventually replace REST in 10, 20 years. For the existing APIs for sure those won't be all refactored.
"Rokon" is the japanese name of the pokemon "Vuplix"
This looks really good except that its missing a good table component. That would be a total dealbreaker for me :/ 
It is working on that is also very important
Oh giddy goody those look nice! Any chance of having this adapted for React?
For now it is only for the time but once we have all the main components and it is 100% stable we have thought to add the support to react thank you very much
The thing is i dont need a tool to trial and error my way to a correct query after my REST call's unit test is passing, it just follows the design. And if i need to do that in GQL, Graphiql falls flat on its face when it comes to authenticated request anyways. Just like theres non compliant REST service, there's bad design in GQL and its libraries. Just take apollo for react where you have to dig into the source code to find out how to do a "query query" after component mount, not to mention the abitrary distinction between a "query query" and a "mutation query"... why only 2 types of queries, why the wierd naming of them? I just explained to you why a complete takeover is not very likely... im doubting you have enough experience to understand what im trying to explain to you, you haven't proven any my "wrong facts" false.
Articles by SEO experts are just painful to read. The crawl googlebot budget isn't some mysterious beast. Googlebot can crawl and index Javascript based websites with client-side rendering, not only can it do that but the crawl budget allotted would be exceeded by almost no website. https://webmasters.googleblog.com/2017/01/what-crawl-budget-means-for-googlebot.html
Thank you! I will try these things after work. Appreciate the help very much! 
Definitely reminds me of Semantic in that it looks genuinely modern, is not afraid to implement relatively complex functionality in an unopinionated way, but has an opinionated style. Definitely will consider this if I ever get into vue development.
"Segfaulty and no docs."
Right. I'm pretty sure the canvas filters exactly match CSS filters.
I came across CanopyTax single-spa a few days ago and scratched my head trying to think of a use case and then just wrote it off as a horrible idea. React and all the supporting build tools are complex enough. Why on earth would I add several frameworks to the same frontend! And now I see a great use case, thanks to your article. For all the folks thinking it is bad to have several framework skillsets on your frontend team, this is inevitable for any big company. Look at something like Twitter where they wrote the backend in Ruby. And then rewrote some of it in Scala. And then wrote some of it in Java. That's just the way it works at big companies. Because big companies have many competing goals, for example: 1. Maintain old software that is not worth rewriting. 2. Keep up with the latest and hopefully more advanced technology for writing new stuff. 3. Be able to hire the best talent (who have the luxury of refusing to work on yesterday's framework). This last point is what makes the approach from this article so interesting. You can maintain the ideal of a one language / one framework shop for a long time as a startup. That ideal is going to bump up against reality when you have a limited budget, time constraints, and want to keep top talent from moving to another company that is already using their new and preferred framework. One final observation that no one mentioned: this is huge opportunity for seeing the pro and cons of each framework and to allow frameworks to compete side by side in the same company. Devs fall in love with a new framework but you're not sure if it will become popular enough? Let them use it for a few small features as an experiment. See how it competes with the older frameworks. Didn't work out? No big deal, you've got three other framework skillsets in house that can rewrite those few small features. Meanwhile you kept your devs happy and tried a new framework in production and gained valuable information about that new framework without taking on the huge risk of a complete rewrite.
I'm just getting acquainted with React and since the world is short of Todo apps üòù, I tried and made one with my current knowledge of React/Redux. It's here ‚Äî [https://github.com/sangeeth96/sodot](https://github.com/sangeeth96/sodot) and I'd like to know what you think, maybe point out gotchas and improvements and where to go next. TIA! üòÑ
I'll give you my perspective as someone who's worked on a very long-lived codebase (10+ years) that used a variety of frameworks over the course of the years (Prototype.js, jQuery, Ext.js, Angular 1, Mithril.js) and who now works on a platform team (i.e. helping dozens of teams migrate from legacy is one of the things I do) Having multiple "mini-apps" definitely makes it _possible_ to migrate from what would be an otherwise intractable migration. You also get to work with refreshing new technology, and often you get to throw out old business logic assumptions and/or technical debt given you're essentially doing a rewrite (albeit in a smaller scale than it would take to migrate an entire codebase). There's however some problems. One is skill dilution. Inevitably, when your headcount starts to increase past a medium-size business (i.e. around a hundred devs total), you'll end up with a React guy, or an Angular guy or or a Ext.js guy, i.e. someone with high tribal knowledge about a specific framework and also high [bus factor](https://en.wikipedia.org/wiki/Bus_factor). You'll also inevitably end up with generalists that aren't particularly excellent at any of the frameworks (basically, people that are really good at jumping in, making a quick local fix and getting out, ninja style, without really understanding the grand scheme of things). The former is typically very hard (or flat out impossible) to replace for older technologies, and the latter takes a while to ramp up. What u/superluminary says about not being siloed in legacy isn't quite true. There are many times when it doesn't make sense to migrate something, and it's not necessarily uncommon that you end up helping maintain a large Ext.js subsystem or whatever because that's what you were assigned to when you joined and now have the most context on. One can argue that everyone can become effective enough on everything, but at some point, this just doesn't scale as well productivity-wise as dedicating people to certain subsystems (and therefore limiting the stacks they are exposed to). There may also be issues with politics, particularly surrounding new technology adoption. Resume padding is a real thing, and if you're not careful as a technical leader, there's a very real chance you'll end up with some learned-on-the-go redux+graphql+saga monstrosity that no sane developer will want to get near in two years. Once you get into large business territory (thousands of devs, hundreds of web projects), then the siloing issues become more prominent, since now standardizing on solutions for app health monitoring, metrics, security, tracing, internationalization, accessibility or other things you hadn't paid as much attention to before becomes a reinventing-the-wheel problem. At this scale, you'll want to have dedicated platform/infrastructure teams to maintain all intrinsically important plumbing aspects that all projects require but that aren't provided out-of-the-box by anyone in the exact way you need to integrate to the rest of your infrastructure. Having stack fragmentation at this stage is definitely not going to help with standardization efforts and it's going to lead to politicking, bureaucracy and duplication of work. At my company, we basically ended up stuck supporting both Go and Java on the backend, because there's sizable number of devs adamantly in favor of their respective stacks. On the frontend, we standardized on React, but even then there are difficulties with migrations. For example, we still have years old projects on Node 0.10 that haven't been touched in a while and are now essentially unbuildable due to a lack of lock files. We're undertaking migration of build tooling, and that involves a lot of tribal knowledge for a single framework _version_ that pretty much only one or two people in the team have context on. And even pouring a lot of effort into migration automation, there's still a bunch of manual work needed in each project when they deviate from the happy path. At google scale, you get to work with a single monorepo for the entire company, and you're responsible for migrating all downstreams when you make a breaking change. So, naturally, you'll want as few stacks as possible, and that's why, for example, they are famously so invested in Java and their proprietary tooling. 
Showed this to my coworker and we agreed that if we weren't stuck in React, we'd love to adopt it! Still, great to see some alternatives to Bootstrap and Material libraries.
Bot generated link bait
And we are still on npm 4.* because 5 was a shameless. 
Your attention to detail is an important trait for devs, but sometimes when you are writing it is more important to think about your audience. Let's take one sentence from the article: &gt; As time went by it become harder to find developers who would willingly choose AngularJS over React, Angular 5, Vue, Aurelia or Polymer. Now let's rewrite it using your names: &gt; As time went by it become harder to find developers who would willingly choose AngularJS over React, Angular, Vue, Aurelia or Polymer. The names might be correct, but this is worse *writing*. First of all it looks like a typo to anyone who doesn't know Angular version history. It just looks like he repeated and then even misspelled AngularJS! I lose trust in him as a writer. How could he make such a mistake? I'd better leave a comment to correct him... Using "Angular 5" made the *writing* clearer. Even to those who don't know anything Angular version history. "Ah, Angular 5 must be the most recent version of AngularJS". Let's make it even a little more challenging. Let's say their legacy app was written in Angular 2. How would write the sentence? Like this? &gt; As time went by it become harder to find developers who would willingly choose Angular over React, Angular, Vue, Aurelia or Polymer. ??? What would be wrong the following? &gt; As time went by it become harder to find developers who would willingly choose Angular 2 over React, Angular 5, Vue, Aurelia or Polymer. You are right about the names. But he relevant art here is *writing* for clarity. But if you have better ideas about how you would write the above sentences, I'm open to learning. 
Just another day in Node security
This could become something nice. Especially if it leads to first-class treatment of typescript in compilers to exploit type-information for performance benefits.
did you try it with vue-cli v3
Hey, this is neat! But I am skeptical about attaching handler functions to actions. It does make actions easy to scope to reducers - but it also means that those actions cannot be serialized. [Serializable actions are part of the Redux philosophy](https://redux.js.org/recipes/reducing-boilerplate). This made me think about another option: start with bare handler functions; then extract action creators, and build a reducer in two passes. It could work like this: interface LocationState { latitude?: number; longitude?: number; error?: string; } interface Geocode { latitude: number; longitude: number; } const initialState: LocationState = {} // Reducers and action creators are specified by a map of handlers, where each // handler function takes state and a payload and returns updated state. const locationHandlers = { clear() { return initialState }, set(state: LocationState, { latitude, longitude }: Geocode) { return { ...state, latitude, longitude } }, goWest(state: LocationState, distance: number) { return { ...state, longitude: state.longitude &amp;&amp; state.longitude - distance } } } const { actions, reducer } = reductser( () =&gt; initialState, locationHandlers, 'LOCATION' ) // reducer and action creators in action reducer(initialState, actions.clear()) reducer(initialState, actions.set({ latitude: 1, longitude: 2 })) The `actions` result is a map of action creators. It is a new object with the same keys as the handler map, where each value becomes a function that requires a payload argument of the appropriate type and produces an action with a `payload` property, and a `type` property based on the action creator's key. For example the `set` action creator that is generated looks like this: set(payload: Geocode) { return { payload, type: 'LOCATION/set' } } `reducer` is a reducer function that combines all of the handlers from the input handler map. `reducer` operates on any action created by an action creator in `actions`. This version of `reductser` has similar type-checking guarantees to the original: - Every handler in the handler map accepts and returns the same state type. - The reducer that is produced accepts and returns the same state type that the handlers do. - The payload argument to each action creator is assignable to the payload argument of the corresponding handler. - An action creator that corresponds to a handler that does not take a payload argument is a zero-argument function. - An action creator that corresponds to a handler that does take a payload argument requires a payload argument. Here is an implementation: // Extend Redux' base `Action` type to require a `payload` property interface ActionWithPayload&lt;P, T = any&gt; extends Action&lt;T&gt; { payload: P } // A handler is like a reducer for a single action, except that it accepts // a payload after the payload has been extracted from an action. type Handler&lt;S, P&gt; = (state: S, payload: P) =&gt; S type HandlerMap&lt;S&gt; = Record&lt;SerializableKey, Handler&lt;S, any&gt;&gt; // `Payload&lt;H&gt;` infers the payload type required by handler `H`. If the handler // does not take a payload argument then the type of `Payload&lt;H&gt;` is `undefined`. type Payload&lt;H&gt; = H extends (s: any) =&gt; any ? undefined : // `undefined` if handler does not take payload argument H extends Handler&lt;any, infer P&gt; ? P : never // produce an error if `H` is not a `Handler` // `ActionCreators&lt;HM&gt;` computes a type for an action creator map based on the // handler map `HM`. type ActionCreators&lt;HM extends HandlerMap&lt;any&gt;&gt; = { [K in keyof HM]: Payload&lt;HM[K]&gt; extends undefined ? () =&gt; ActionWithPayload&lt;undefined&gt; // zero arguments if payload type is `undefined` : (payload: Payload&lt;HM[K]&gt;) =&gt; ActionWithPayload&lt;Payload&lt;HM[K]&gt;&gt; } // `reductser` calls two other functions to compute an action creator map, and // a reducer. Actions produced by generated action creators have a `type` // property based on the map key of the handler / action creator. But short // handler names might not be unique in the application. So each `type` property // is prefixed with the given `prefix`, which should be unique to this module. function reductser&lt;S, HM extends HandlerMap&lt;S&gt;&gt;( getInitialState: () =&gt; S, handlers: HM, prefix: SerializableKey ): { actions: ActionCreators&lt;HM&gt;, reducer: Reducer&lt;S&gt; } { return { actions: extractActionCreators(handlers, prefix), reducer: extractReducer(getInitialState, handlers, prefix) } } function extractActionCreators&lt;HM extends HandlerMap&lt;any&gt;&gt;( handlers: HM, prefix: SerializableKey ): ActionCreators&lt;HM&gt; { const actionCreators: any = {} for (const k of Object.keys(handlers)) { const type = applyPrefix(prefix, k) actionCreators[k] = (payload: any) =&gt; ({ payload, type }) } return actionCreators } function extractReducer&lt;S, HM extends HandlerMap&lt;S&gt;&gt;( getInitialState: () =&gt; S, handlers: HM, prefix: SerializableKey ): Reducer&lt;S&gt; { return (state = getInitialState(), action) =&gt; { const type = removePrefix(prefix, action.type) const handler = handlers[type] if (handler) { return handler(state, action.payload) } return state } } function applyPrefix(prefix: SerializableKey, key: SerializableKey): SerializableKey { return String(prefix) + '/' + String(key) } function removePrefix(prefix: SerializableKey, type: SerializableKey): SerializableKey { return String(type).slice(String(prefix).length) } Unfortunately this does not get you down to zero strings. If you want to be able to serialize actions and replay them in a different instance of the app then the `prefix` argument to this version of `reductser` must be stable, which means that it should probably be explicitly provided by the user. But it does still get you down to one string! 
Nice, ignoring a critically important failure point until it gets pointed out.
Might be worth a look [https://www.youtube.com/watch?v=M3BM9TB\-8yA](https://www.youtube.com/watch?v=M3BM9TB-8yA)
i'm pretty damn amateur at JavaScript, so I'm expecting to get destroyed. I already have a lot of concerns with my code, especially since it was a few months ago and I have progressed a little bit, but I know there is a million more things I would not have even considered. Here is the repo : https://github.com/BLBaylis/Twitch-Tool and here is the actual page https://blbaylis.github.io/Twitch-Tool/. Brutal feedback appreciated!
This is a great little talk. Really looking forward to what Deno will become 
Just watched the talk, I agree with most of Ryan Dahl's points. Really like the new look at the module system, security and build system. However, I would've loved if he also would've improved the IO model by providing standard support for distributed systems. It's a lot to ask, I know, but it would make it a big player in the server world. But, what I'm most excited about is the fact that deno can be used as a library and that it is focused on being compatible with the browser.
I need to learn architecting and designing libraries. One of my first attempt [here](https://github.com/vivekimsit/exchange-rate). One of the important concern is to how to modify code to be able to add multiple providers?
Well, I mean, it kind of goes without saying, but you wouldn't let your codebase go to shit. You'd build an abstraction like idk maybe after the fourth time you were doing the same thing :D 
&gt; Since JS is prototypal is surely just an under the hood difference making JS OO too? Which I believe most people would disagree with would they not? I couldn't quite follow your question, but I think JS is OO (or, more specifically, it _supports_ OO, along with other paradigms), and I think most people would agree JS is OO. &gt; By traditional I was meaning to say the majority market players i.e. Java / C based languages (C#, C, C++). According to both [StackOverflow](https://insights.stackoverflow.com/survey/2018/#technology-programming-scripting-and-markup-languages) numbers and [Github](http://githut.info/) numbers, Java is used more than Python, and Python is used more than either C++ or C#. So the idea of mutable classes and delegation-based inheritance that's used in Python (and JavaScript) shouldn't be too foreign. And let's also not forget that not even JavaScript's objects, functions, or even local variables are implemented the same as in the Java / C-based languages, and we've never been concerned about that causing any confusion. Classes shouldn't be any different.
Oh no, not at all! It's right that we challenge one another. Code should be a rigorous intellectual exercise. 
It's also only been around for 1 month, so...
I updated some of the text so far, Im probably going to go with breaking it up like you suggested. Do you have any recommendations on a background image I should use to maintain the danny devito based theme? Thanks for the tips!
If intermidiate/advanced, I found Secrets of the Javascript Ninja excellent. Ignore the title.
I will definitely try it
You Don't Know JS
Thank you very much! You can sign up for the newsletter or follow me on social media, if you'd like not to miss anything :)
It‚Äôs unique and great, just please add dropfowns for both top menu links and buttons!! It‚Äùs a must! Thank you! 
You couldn't pay me enough to read someone else's webpack config, but ExtractTextPlugin is generally used to bundle your css into separate files - otherwise it is stored as javascript strings.
Not exactly a Webpack ninja, but I'm sure someone will correct me if I get something wrong. &gt; What is the need for the ExtractTextPlugin that Webpack isn't doing natively? So, the simplest way of loading css files is to use `['style-loader', 'css-loader']`. In this case, the file contents are first passed to `css-loader`, which resolves all dependencies (e.g. `@import`, `url()`). Then, the resulting "file" is passed to `style-loader`, which transform it into a js module that creates a `&lt;style&gt;` tag in `&lt;head&gt;` and dump all the contents into it. And that module in included in the bundle. Now, the `ExtractTextPlugin` extracts the result into a separate css file from the bundle, which Webpack can't do natively since it only emits js files. This isn't specific to css and sass. The `ExtractTextPlugin` can extract anything into a separate file. So, instead of a single `myApp.bundle.js`, Webpack emits a `myApp.bundle.js` and a `style.css` &gt; What is it doing with the loaders that are being passed in? Does the order matter? How are the scss/css files being compiled/bundled? When Webpack hit an .scss file, it uses the loader returned by `ExtractTextPlugin.extract` to load it. That loader, in turn, use the loaders that are passed in. That is, first use `sass-loader`, then pass its results to `postcss-loader`, then pass that result into `css-loader`. They are ordered the same way they are normally ordered. But, instead of making the contents "fall" into the js bundle, `ExtractTextPlugin` "catches" everything loaded by the `extract` loader, concatenates them and emits it as a separate `style.css`. &gt; Why is the plugin being run on the style.css file? The argument is [the file name being output](https://github.com/webpack-contrib/extract-text-webpack-plugin#options) 
Yeah I‚Äôm looking for intermediate level book! So this may be good. 
interesting he says Dart is a failure but Flutter thinks otherwise
Are you asking for a framework that does this or how to do it?
In the video, I explain the base structure of a blockchain, how crypto mining works, how the blockchain defend itself against tempering and a couple other things, it just flows so smoothly and naturally that it's hard to distinct one subject from the next but it is all in this one video. Hope you will find it useful, I sure had a lot of fun making it :D Fun Fact: An actual working Crypto Currency was created just for this tutorial to make sure the facts check out ;p In the coming videos, I might explore using Neural Networks to analysis trading data. 
Tested, worked great in v3.0.0\-beta.15
[https://github.com/getify/You\-Dont\-Know\-JS](https://github.com/getify/You-Dont-Know-JS)
First of all if it is even a wise thing to do. I have some sense of how it might work. And I don't wanna use any framework to do it for me \- so vanilla JS \+ any server\-side language
Node 2: Not Node and Not JavaScript by: The Guy Who Made Node
I apologise. Here is a free copy: https://www.dropbox.com/s/utyl6cxp5hyovru/AutomatingWithNodeJS.pdf?dl=0
Awesome and sad at the same time. Sorry to hear that.
Yeah my co-workers probably resent me. 
Here's the book for free: https://www.dropbox.com/s/utyl6cxp5hyovru/AutomatingWithNodeJS.pdf?dl=0
Sorry mate. Here is the book: https://www.dropbox.com/s/utyl6cxp5hyovru/AutomatingWithNodeJS.pdf?dl=0
I think you're kind of missing the point of TYPEScript.
[https://github.com/mattdiamond/fuckitjs](https://github.com/mattdiamond/fuckitjs)
This already exists. https://developer.mozilla.org/en-US/docs/Web/HTTP/Link_prefetching_FAQ https://developer.mozilla.org/en-US/docs/Web/HTML/Preloading_content 
Thanks for the reply. This clears things up enormously. 
I would consider this plugin instead, it‚Äôs what I use and it does the job perfectly fine. https://webpack.js.org/plugins/mini-css-extract-plugin/
I'm working off an older tutorial but the ExtractTextPlugin documentation specifically points to that plugin as a replacement.
I know, I actually started using it recently as well. It‚Äôs pretty straightforward, and I‚Äôm a true webpack noob.
The joke is that you can click some boxes and "generate" a library for download (similar to this: http://www.initializr.com/), and when you download it (no matter the configuration you chose), the file is empty (as javascript supports all those things natively).
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), ‚Äúnobody‚Äù starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
Don‚Äôt hold back! https://github.com/Atomic71/React-Redux-Demo
Hey, this is a very thoughtful and comprehensive response! It really helps clarify my understanding; I'll need plenty more practice to really grok it of course, but this is a great resource for to return to as I continue to study. Thanks so much!
Hi /u/Semirxbih, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/accountForStupidQs, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/yamiteru_xyz, For javascript help, please visit /r/LearnJavascript. Thank you!
It is definetly a joke. Though I like to send it to people who never wrote any JavaScript without third party libraries and therefore don't understand any native code.
I assumed you misspelled deprecated, because depreciation doesn't make sense in the context of a software framework. What do you mean by that?
I use vanilla-js, and agree with all the points made on the website. I think it uses humor to make a point.
Thank You
&gt; jQuery, Prototype JS, MooTools, YUI, and Google Web Toolkit Man that site is outdated!
Yes.
Why am I so hype for this
Yes what? Yed sir!! 
Deno = Node 2.0? Yes please! Reading through his list of regrets makes me very excited by the possibilities of Deno.
Thanks :) seems way cleaner than my code ... ill fiddle around with it
There‚Äôs no way Mike Judge didn‚Äôt base the Richard Hendriks character off this guy. 
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;div id="inputs"&gt; &lt;p&gt; Select bspmodel: &lt;select id=bspmodel&gt; &lt;option id=npc_jump1 value="colombia/npc_jump1"&gt;npc_jump1&lt;/option&gt; &lt;option id=fence01 value="generic/fence01"&gt;fence01&lt;/option&gt; &lt;option id=test_bridge value="test/bridge"&gt;test_bridge&lt;/option&gt; &lt;/select&gt; &lt;br&gt; origin x: &lt;input type="number" style="width: 60px" id="originx"&gt; y: &lt;input type="number" style="width: 60px" id="originy"&gt; z: &lt;input type="number" style="width: 60px" id="originz"&gt; &lt;br&gt; angles x:&lt;input type="number" style="width: 40px" id="anglex"&gt; y: &lt;input type="number" style="width: 40px" id="angley"&gt; z: &lt;input type="number" style="width: 40px" id="anglez"&gt; &lt;br&gt; Quantity: &lt;input type="number" style="width: 40px" id="quantity"&gt; Amount: &lt;input type="number" style="width: 40px" id="amount"&gt; Direction: &lt;select id="direction"&gt; &lt;option value=x&gt;x&lt;/option&gt; &lt;option value=y&gt;y&lt;/option&gt; &lt;option value=z&gt;z&lt;/option&gt; &lt;/select&gt; &lt;br&gt; &lt;input type="submit" value="Submit" onclick="calc();"&gt; &lt;/p&gt; &lt;/div&gt; &lt;br&gt; &lt;p id="output"&gt; &lt;/p&gt; &lt;script&gt; document.getElementById('originx').value = '100'; document.getElementById('originy').value = '100'; document.getElementById('originz').value = '100'; document.getElementById('anglex').value = '0'; document.getElementById('angley').value = '0'; document.getElementById('anglez').value = '0'; document.getElementById('quantity').value = '2'; document.getElementById('amount').value = '100'; function calc() { var instance = document.getElementById("bspmodel").value; var d = document.getElementById("direction").value; var a = parseInt(document.getElementById("amount").value); var q = parseInt(document.getElementById("quantity").value); var ox = parseInt(document.getElementById("originx").value); var oy = parseInt(document.getElementById("originy").value); var oz = parseInt(document.getElementById("originz").value); var ax = parseInt(document.getElementById("anglex").value); var ay = parseInt(document.getElementById("angley").value); var az = parseInt(document.getElementById("anglez").value); if (Math.sign(a) == (-1)) { var sum = -Math.abs(a * Math.abs(q)); } else { var sum = Math.abs(a * Math.abs(q)); } if (d == "x") { for (var i = ox; Math.abs(i) &lt;= Math.abs(ox + Math.abs(sum)); i += (a)) { document.write("{&lt;br&gt;\"classname\" \"misc_bsp\"&lt;br&gt;\"bspmodel\" \"instances/" + instance + "\"&lt;br&gt;\"origin\" \"" + i + " " + oy + " " + oz + "\"&lt;br&gt;\"angles\" \"" + ax + " " + ay + " " + az + "\"&lt;br&gt;}&lt;br&gt;") } } else if (d == "y") { for (var i = oy; Math.abs(i) &lt;= Math.abs(oy + Math.abs(sum)); i += (a)) { document.write("{&lt;br&gt;\"classname\" \"misc_bsp\"&lt;br&gt;\"bspmodel\" \"instances/" + instance + "\"&lt;br&gt;\"origin\" \"" + ox + " " + i + " " + oz + "\"&lt;br&gt;\"angles\" \"" + ax + " " + ay + " " + az + "\"&lt;br&gt;}&lt;br&gt;"); } } else { for (var i = oz; Math.abs(i) &lt;= Math.abs(oz + Math.abs(sum)); i += (a)) { document.write("{&lt;br&gt;\"classname\" \"misc_bsp\"&lt;br&gt;\"bspmodel\" \"instances/" + instance + "\"&lt;br&gt;\"origin\" \"" + ox + " " + oy + " " + i + "\"&lt;br&gt;\"angles\" \"" + ax + " " + ay + " " + az + "\"&lt;br&gt;}&lt;br&gt;"); } } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 
with this code for some reason when I put more than -100 in the x origin nothing happens... 
from the site: When you're ready to move your application to a production deployment, switch to the much faster method: That's right - no code at all. Vanilla JS is so popular that browsers have been automatically loading it for over a decade.
Ha, I just nailed one of my pet peeves. But yes, just because something is deprecated does not mean it isn't supported. In fact, it usually means it is supported. And not knocking anything just to be clear. If an app runs well enough why in the world would you migrate it unless you have nothing else better to do. 
well, it's typescript which is a superset of javascript
If you're talking about creating a utility library, MVC doesn't really fit - as there is no model, or view, or data flow to control. An approach I'm seeing grow in popularity is multiple export, in which you export each function individually (example here: https://github.com/mostjs/core/blob/master/packages/core/src/index.js) If there is a lot of complexity, you can piece each utility function into it's own file (example here: https://github.com/lodash/lodash?files=1) Or you could just keep it is all one file and export the pieces of functionality you want to expose. Your solution is completely fine, just do whatever makes sense to you. If, down the line, you feel it's becoming too complex, you can start to separate your functions into separate modules, or separate files, or separate packages. That's all part of the fun, finding patterns and splitting apart the logic as you go. It's unrealistic to think you could plan ahead for how your library might evolve. This all said, I'd definitely recommend using ES6 modules. they make structuring your application a lot easier.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [mostjs/core/.../**index.js** (master ‚Üí 0645473)](https://github.com/mostjs/core/blob/0645473605a2ad1b954045566ff0fbbd2469152e/packages/core/src/index.js) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e08lrhf.)
Is this better than Vuetify? I just deleted Vuetify from my project because it made so much bloat in my templates.
Hahahaha great call!
I was wondering if they were ever going to do this. It so much sense and will help improve Apple Maps.
&gt; Final size: **0 bytes** uncompressed, **25 bytes** gzipped. Show human-readable sizes da fuck? 
Data grids are so damn tedious to do well. Good luck. 
The Deno repo: [https://github.com/ry/deno](https://github.com/ry/deno) Interesting!
Yes, but it has a real message as well. Everyone is so quick to use React, Vue (or shudder, Angular) for everything when in some cases you don't need a framework or library. Developers have stopped letting the requirements dictate the tools/languages and frameworks, and instead let the tooling and frameworks dictate the requirements. Aside: I love how you tick all of the boxes and the uncompressed size is 0 bytes, but Gzipped it's 25 bytes.
Exactly this. It's almost like an alternative to WebAssembly, except if you can skip the end\-user compile step and let the VM handle that and optimise the types, it could make for something awesome that is in\-between and doesn't need to be compiled by the user: dynamic strongly typed Javascript.
In my opinion, 'Vanilla JS' is just a term used by developers who are trying to highlight the core aspects of JavaScript. Think of it just like writing simple functions in any other programming language like C or C++, without using any third party libraries or frameworks for the purpose. JavaScript has been embedded in the web browsers since the beginning of internet and since the release of Google's V8 engine, JavaScript has been taking a hit. Regarding the website you mentioned, I personally think it's a clearly pun intended website which is outdated and doesn't actually provide any valuable knowledge to the users. The demonstration examples and samples it has given to download, all will simply download a vanilla.js file in your system with 0byte file size!!!! :D :D :D
They include the script tags on the Jquery examples to make it look longer....
When you gzip an empty file, you now have the overhead of the gzip file format, which amounts to 25 bytes. That's tiny, and considering that a text file can usually be compressed to like 75% of it's original size ... that little bit of overhead is nothing usually.
Ah, thanks for the explanation it makes sense.
Professional JavaScript for Web Developers
Looks good! I‚Äôm currently using custom components with a Bulma base, and this has some of the same aesthetic I like about Bulma and SemanticUI. If it tree-shakes well, I might want to pull in the chip field element (an abstraction Bulma lacks, being CSS-only).
Javascript-The Definitive Guide, 6th edition. Probably one of the best books I've ever read about JavaScript. It's a bit outdated since it follows ECMA5 standards, but its worth reading. Next edition might come around soon!!!
Great job! I'm only at 011-Cloning but I gotta say its a good read. You know your stuff and explain it very well. 
Use search engine and you will get the answer
Yeah, that bit reads like an ad for jQuery. The thing I liked about [You Might Not Need jQuery](http://youmightnotneedjquery.com/) is how honest it was.
That snake cat is creepy as all hell...
Why even comment?
I want any design for Vue 
Open an issue! I‚Äôm sure he would be up for chatting about it. 
Textbook answer, kudos mate.
Obligitory [beware](https://www.reddit.com/r/javascript/comments/6q2lk0/why_composition_is_harder_with_classes/dku34cl/)^1 [referencing](https://www.reddit.com/r/javascript/comments/5c5lkq/what_eric_elliot_wants_to_say_can_somebody/d9u6tv3/)^2 or [learning](https://www.reddit.com/r/javascript/comments/837t82/who_are_some_of_your_favorite_speakers_educators/dvh0br6/)^3 from Eric Elliott.
This is a high quality example of a nerd art form called [ha ha only serious](http://www.catb.org/jargon/html/H/ha-ha-only-serious.html). There are three stages to understanding this site: 1. "Wow look at these amazing features. And it's so fast!" 1. "Wait. Wait, is this a joke?" 1. "... wait. are ... are ***frameworks*** the joke?" And then you remove jquery. 
I mean, hes right! the community is 90% starters who just refuse to think you have to go through all the materials listed above and more! you have to! there is no on bible to rule them all, so stop asking for one! sorry for the harsh love, keep it up!(get to work amazing things will happen!) 
&gt; 0 bytes uncompressed, 25 bytes gzipped Dammit gzip!
It does make a really good point and had me seriously wondering if I should switch to this cool new system, but then I saw the code examples, where the jQuery offerings are padded out with script tags. Vanilla wins at a lot of things but brevity and readability are not among them.
Yeah, especially with react and vue the trade-offs with vanilla are the simplicity and brevity of code vs the structural requirements they impose. The trick is to know when the added verbosity needed to meet the requirements of those languages is offset against the brevity.
Yes it's a complete joke. Vanilla js can do everything that all these tools can do. In fact these tools are written with vanilla js. Vanilla js is "plain" javascript.
VS code is just an editor.. Should be able to run a .js file through the built in terminal. Or what errors are you getting?
Depends on how you code with it!
[This animated cat just hits the spacebar](https://youtu.be/GKSoXiBlnZY)
Well, you're wrong about what it pokes fun at. It's actually taking shots at clunky frameworks and libraries.
deno 
‚úåÔ∏è 
Lol
Es6
Oh, nice. I was just wondering because it means relative (like family member) in Hungarian.
React and Vue - and, yes, Angular too - all have their uses and situations where the performance hit is so small and the benefits are so great, they're well worth using. We could all be writing code in Assembly or COBOL, and it would definitely be faster than a scripting language on top of a virtual machine on top of a browser on top of a rendering engine on top of a C++ executable on top of a bunch of libraries... but do you think the performance gains would be worth having to code like that?
There isn't a trendy alternative to jQuery. The platform has improved to the point where you can generally just write modern javascript and get it done in a reasonable amount of code. The people who like vanilla javascript put together micro libraries so you can look up those if you want something more coherent than the base DOM APIs. They're generally under 200 lines of code. I'll give a special mention to [put-selector](https://github.com/kriszyp/put-selector) since it's one of the few non-jQuery like libraries out there for doing DOM manipulation. If you're looking for something more trendy (i.e. component based), I think the next step up is [svelete](https://svelte.technology/), which is what I'd use if file size was the primary concern. [Preact](https://preactjs.com/) is more trendy and closer to the React paradigm but it doesn't offer controlled components so I use [Inferno](https://infernojs.org/) for my own projects. The [web component frameworks](https://www.polymer-project.org/) could also potentially be pretty small once you stop needing polyfills everywhere. None of these are a replacement for jQuery but raw DOM manipulation is out of style.
I feel bad for web devs. They spend so much time optimizing, squeezing out every bit. Then the ad-man throws on 40mb of ads onto the page, and there goes all of that work. 
He made it seem like it was just a thought experiment for a demo, not a project to be taken seriously. Might've misread into it though
What replaced these mainly?
Not sure why the down votes? \+1 for you sir.
Thank for the links! Some of his regrets are valid; Centralizing npm, and having to promisify all the code interfaces feels clunky. The rest are so minor they fall into the who cares bucket. I'm not sold on his all his new decisions. He bailed for Go a while back, not surprised he has brought go leftovers with him. At least I see he finally realized that Go kindof sucks, and he is ready to ditch it. Typescript isnt much better imo: if something really needs types, might as well switch to C++. Still the only static language that doesnt suck. 
React, Angular and Vue.
Nothing? It was a 99999999...% overhead
I can't tell if you're missing the joke or not..
I don't think node\_modules is something to glaze over. It's a problem when a singular folder can become so deep in nested dependencies. Part of that may be due to how easy it is to just bring in yet another module rather than "build it yourself", but that doesn't excuse it from its design. IMO that's one of the larger plagues of NodeJS projects \- too many bring on board too many dependencies
JQuery? Nothing. All the rest? React/Angular + Lodash/Ramda/Etc
the latest version builds a flatter hierarchy for the most part. And you arent forced to use any particular library. I read all the ones i require, so ones with a beehive of deps I just avoid. npm and automatically installing modules is one of the reasons node is popular in the first place. compared to using ruby gems or pip packages its far easier to get things working. I never want to deal with virtualenv again personally. So the main part I agree about is npm being too centralized. (esp with the npm team going into sjw hysterics in recent memory)
That's okay neither can I.
Basically a satire version of http://youmightnotneedjquery.com/
None.
I laughed and laughed and laughed when I kept ticking the boxes and it reloaded at the same size - I download it, opened it and it was empty and I laughed even louder...
Yes.
&gt; In my opinion, 'Vanilla JS' is just a term used by developers who are trying to highlight the core aspects of JavaScript. IIRC, Vanilla was coined because vanilla ice cream was the most basic ice cream, and to many it was flavorless (heresy, I love Vanilla Ice Cream). So people use it a lot in Programming and games to refer to the most basic version. A vanilla game is the basic version of the game. without mods and addons. Just like Vanilla JS is, well, JS without frameworks and libraries. And yes, it's just a pun to say that everything you can do with others libraries and frameworks can be done in plain Javascript. 
What a shame they killed SMIL. It was great for doing really simple but cool-looking animated infographic overlays like earthquake epicenters or routes taken by trucks laden with bombs. 
JavaScript without any libraries? Yes, that's a joke lol 
this guy read the slides
Hi /u/randomGuy4386, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
[fuck it](https://github.com/mattdiamond/fuckitjs)
What about the scenario where someone doesn't click further into the site? Then you'd just be spending more data for both them and you.
//@TODO: give a shit :D 
Yes.
there are node modules for google authenticator.
I would say Ext JS replaced YUI, since that was it‚Äôs origin.
My favorite dev humor site =&gt; http://howfuckedismydatabase.com/.
Just because you can doesn't mean you should. Brevity is generally the enemy of readability and trading fundamental syntactical behaviors for brevity is ALWAYS a bad thing, if you want other people to be able to read your code. You spend, or should spend, about 10x more time reading code than writing it. Optimize for reads not writes.
Only if you hate having options.
Frameworks do make things *much* easier in a lot of cases. I really like Vue. I have no idea how I'd do editable lists of things or tabs or anything like that without a framework, or a lot of ugly handwritten code that would take a while to write, or reinventing a mini-framework for the task. But if you see someone stacking ten frameworks and you can't figure out what any of them are there for, you should probably send them this link. And if the site is literally just a digital version of something that could be a paper book, then you should maybe visit https://thebestmotherfucking.website/ JS can still be useful on sites like that though, but maybe not 8MB of it.
Another note is that I don't even really understand the concept of "middleware". Is it just scripts that are automatically run with each request? That seems inefficient but who am I to judge. I have no idea what I'm doing.
In case anyone wonders what talk he was supposed to give instead of this (as he mentions in the beginning), it was about PropelML, a machine learning library for JavaScript, but it got overtaken by Tensorflow.js, and now it's re-positioning itself into something like Jypiter notebooks, as I understand it. Also, Ryan didn't just do Go when he was "away", he also interned at Google Brain and got into ML. 
I would say closer to infinity, since it was zero to something.
Does Bebel support things like namespace, module exports, etc..?
Made my day :DD
The amount of ‚ÄúI‚Äôm sorry‚Äù he says in that talk is node_modulesque
[removed]
Yeah that's my main concern.. So maybe computing some kvocient of probability and start preloading only if it exceeds certain point (like 0.5 or something).
Is ‚ÄúJavaScript fatigue‚Äù fatigue real? 
Yeah that's exactly what I was thinking about.
Is Vanilla JS really that much faster than those frameworks? 
Wow didn't know lodash was structured like this. I'll definitely look into ES6 modules. Thank you!
may i ask why didnt you mention Vue? whats the reason?
&gt;might as well switch to C++ I'd rather switch to another profession than work on, maintain or debug C++ code. üò∑
The joke is the javascript language itself and the joke is on you, my friend.
Ad-man, bad ma-an.. Ha-ha, charade you are!
Weird
&gt; usually
I initially thought this was the bait campaign that Madrobby (scriptaculous, zepto...) did about 10 years ago, but looks like that was vapour.js. https://github.com/madrobby/vapor.js 
Yes, reddit, now go back and have your daily laugh looking to the word "tits" in the dictionary. Will this community ever grow up a bit? I know, it's reddit, OK... still I find sad this is the best comment to a developer releasing his/her library open source.
Well Dart failed its original goal of beeing a javascript alternative, like typescript is nowadays. After realizing that, Dart 2 and Flutter are in a completely different domain now.
1. It‚Äôs still good, pretty detailed though. I‚Äôd suggest to read something about ES6+ then (e.g. Zakas‚Äô book) 2. It‚Äôs about any version when you don‚Äôt use frameworks/libraries. What to learn depends mostly on you: I prefer to know internals before I start doing something big, but knowing frameworks helps to make something faster. Sometimes it‚Äôs hard to keep learning while you don‚Äôt have any visible results therefore it can be helpful for motivation to start from frameworks and do something useful 
Is there a tldr for the issues?
Its not an alternative to jQuery
Yes
If you visit cnn.com now with ghostery enabled, it'll show that it uses around 28 trackers. It is absurd.
I wouldn't say that the word "replaced" is exactly appropriate though. Nothing has "replaced" vanilla JS. It's obviously not going anywhere.
I'm glad to hear that. I hope it helps.
I think it really depends on how big you expect the application is going to be. If you need something to create a quick demo, hapi or express should be good enough. If you have something that might have a huge code base and high complexity i suggest using a framework that uses a strongly typed language. If you are looking for it to be full stack JS i suggest next.js, it uses typescript. I currently use javascript in the backend with sails.js which uses ES6 and it's been a nightmare to maintain. I wish i knew much more about other frameworks but i don't, been full stack js since i started, wish you luck! 
I'm so exhausted from JS fatigue that the question of it is real or not seems silly. I question the existence of non-celiac gluten intolerance far more than the existence of JS fatigue.
So was Node.js at some point right?
Relax, it's a fucking joke
Well if i manicly add all the latest python packages etc i have python fatigue? Its simple: go with a set of core libs and just develop from there, then every 12-18months check for other solutions. Is the new solution worth the change? If not dont use it. No need the learn all the frameworks
If jquery works for you there is no reason to look for something trendy. But the trendiest JavaScript framework right now is react.js which was made by Facebook to facilitate super interactive websites. Once you learn that you can easily understand to react native which allows you to write native apps for iOS and android. Plus it will give you a good understanding to the new language features. I personally don‚Äôt recommend trying to learn less famous things like preact as you are just adding more steps along the way. React has some really good resources out there foremost among them their official tutorial React is optimized for writing single page application, where all your website/ app is written within one JavaScript structure and the HTML is one &lt;div&gt; to load the app into. If what you are creating is mostly static pages with little interaction then continue to use jquery but if you want to learn something as interactive Facebook then with react for sure 
Ok. Let's say JS is or at least capable of OO (differences aside). Considering ES6 has the "class" keyword. Would you consider ES6 as being class based OO? Or would you say it's not due to the class keyword mostly just being syntactical sugar?
Ermm, smart. I wonder how it works with multiple server calls (site is being load and has multiple requests to the server). If Cpyress wait for all of them to finish to load. I will give it a try! Thank you! :-)
Yes, Cypress waits until all responses from the server are in.
I'd go even a step further!
When you benchmark atomics, yes, in a real app - there is no way. Frameworks schedule read/writes to avoid layout thrashing, they diff and update the only parts that need to change, they manage state as opposed to dumping it into the dom, newer frameworks actually schedule, where some parts of the UI can be prioritized while others remain in their state in order to keep an even fps. If you would attempt to get all this done by yourself, you'd end up with a framework - which at least today isn't much more than a plain javascript pattern anyway. 
Native code ... \*chuckles\*
You know what I was talking about. xD
Looks and works perfectly! 
Generally, we would say that a framework provides _structure_. That is its _main_ purpose. So, when considering usage of a framework, this is probably the main question you should ask: Does it provide the structures I need to build my solutions on? This is **not** as simple a question as it seems. To answer it correctly, you need to have a good understanding of what those structures are, what problems they are designed to solve and why they were chosen and implemented that way. As a quick overview/comparison (you can find many, much more detailed comparisons by searching around a bit on the web) of what Express and HAPI are (yes, there are other frameworks out there, but I'm just going to pick these two as example), you could say that: - Express is aimed to be a more _generic_ framework. It tries to be flexible enough by providing a small API and then build lots of functionality on separate modules (I'll explain about "middleware" later). - HAPI is more focused on helping development of _services_ (REST-y services). It provides more out-of-the-box functionality _for this goal_. - Generally speaking, HAPI is aimed at _larger_ projects than Express. This is done by providing a more rigid structure (i.e. the framework keeps more control over the infrastructure) and by favouring configuration. - Meanwhile, Express can feel _more flexible_, because it provides a "simpler", more generic model where you (developer using it) can have more weight on the decisions about how to manage/organize certain stuff. Note, but just as a comment, that HAPI was developed in a big part as a response _against_ the _excess flexibility_ Express provides. That is, they had some frustration against Express because it allowed too much flexibility by simply not taking care of some responsibilities they thought a framework should take care of. In any case, you need to evaluate your own circumstances as well as the various frameworks when trying to choose one. This is probably the most important thing you should consider and it directly answers the question in the title. _How should you go about choosing a framework/library/tool?_ You should evaluate what it offers **and compare to your particular needs and circumstances**. --- As a way to compare things, let's ask: So, what is this _middleware_ Express talks about? Well, it's a generic concept. The approach Express uses to build web back-ends tries to be "simple" and uniform. That is, it provides mainly _one_ way to do things. [This is it](https://i.imgur.com/Fjrpkir.png). It presents the goal of processing a request and producing a response as a simple chain of processes or filters. You set up these functions and they are all similar: they get a request and a response, they can manipulate those, and they can decide to "continue with the next function in the chain" or not. This approach is not original. It's something that has been used on other platforms for some time. What's the reasoning behind it? What is it good for? Well, the best way to see this is thinking about a "real example". Say you are building a generic web or application of some sort. It has some various sections with different functionalities or whatever. As you go on your way building it, organically at first, just letting things grow, you'll most probably find that you start to have some common processes you do in all or many places. Say, user checking. I mean identifying the user and checking if they have the correct permission to access that part of the application. This one is pretty common, but there are others, e.g. input processing. Say that you have a lot of forms and many of them may include _attached files_ and you're always having to check if it's valid (size, type, etc), dump it to a proper file in the server, moving it somewhere giving it a name, etc. Or output formatting, producing HTML, JSON, XML, whatever, independently of the particular request. Or... many other concerns. These are actions that you'll do often, and thinking about it in a very abstract way (i.e. from a very high level, or with little level of detail), they all entail doing this sort of operation: 1. get something from the request (a cookie, a token, a piece of content) 2. operating on it to produce something else (a validated user, a local file reference) 3. decide whether to "go on with whatever comes next" or "interrupt and return some error". Many such concerns can be abstracted to this level of detail. And so, Express models this approach. This is what it calls _middleware_, the functions you build (or download from the internet) to handle the various concerns of your application. The strengths of this approach are the same as its weaknesses: It is a very flexible, generic structure. But, to better understand this, let's compare to HAPI. How does HAPI solve this problem. Note, first of all, that the first thing HAPI does is _define_ the problem in its own terms. The problem, seen in a more general way (i.e. not thinking about the solution, but about the problem), is that some operations or concerns emerge as common to the particular operation of each functionality. In other words that a route (such as `GET /user/:id`) has two types of concerns: a. its own specific concerns (reading the data from the DB, returning it), and b. general concerns (authentication, input checking, etc). So what HAPI does is approach the problem in this way: It identifies those cross-cut concerns and then provides help for those specific use cases. That is, instead of just letting you put all those "request processors" in the chain and letting you handle everything, it builds a "process life-cycle" where you have specific concerns reflected: First there's authentication, then input validation, then special input processing (files), then handling of the request itself, then there's output transformation into the appropriate format, then sending the output. And then, it solves the problem by: 1. managing the life-cycle on its own. 2. at the specific appropriate times, allowing you to _hook_ into that life-cycle to perform specific operations if you need to, but only those operations that are appropriate at that point in the life-cycle. This means that, in general terms, you do pretty much the same thing in Express and in HAPI (of course, input validation is needed regardless of what framework you're using), but you'll be doing it in different ways. In Express, you [insert a generic middleware](https://expressjs.com/en/guide/writing-middleware.html) that does your thing (You actually don't, of course; you download something from npm that does it for you). In HAPI, you have [a specific point where you declare validation](https://hapijs.com/tutorials/validation). And if you don't, then you have a specific way in which to create a plug-in and plug-ins have a specific API they have access to. Now that we have a rough but detailed enough idea of both approaches, you should evaluate which one _fits better_ into your needs and circumstances. Are you alone or in a team? Do you have a clear picture of your final needs or do you need to experiment as you go along? Do you appreciate being given a more rigid structure and having to conform to it or are you capable of making your own decisions? These are the things you need to think about, how well does each option fit with your own views and how well you fit into the framework's philosophy.
Thanks! What a encouraging comment! You can try to drag the window/dock icon around, right click the window title bar/dock icon, resize the window, and double click on the window title bar. This project is based on pure javascript without any dependency. I wrote draggable, resizable, sortable and about a dozen of base components from scratch. It turned out to be really hard to make every small things right.
I think it is real. It is somewhat frustrating how the language is so fragmented compared to others like python. Yes I understand it gives you a wide array of options however that in itself creates a work load to figure out which option is the best for one case and not the other. And then you start your project and a month in you see something new that seems to fit your need better and then you have to figure out how to switch to the new thing and after a week of work in that direction you realize may be your old way was better after all. One thing that makes it worse is that js developers revel in segmenting their code into tiny fragments, which has its advantages to be sure by then you have to collect every piece and figure out how they fit rather than having a comprehensive frame work. For example why doesn‚Äôt react come with built in router and global state management system. They added context API recently but that doesn‚Äôt replace the functionality of redux or mobx. Why does the array prototype missing methods that you can readily find built into other languages, which would make you install something like lodash and now you have a ton more functions that doesn‚Äôt need to be there. 
It looks pretty good and seems to work well, so good job. Only thing I noticed is that when you minimise a "window", it causes the scroll bar to appear on the parent and you can then scroll down a bit, so you might want to take a look at that. Just out of curiosity, what was the inspiration and/or use case in mind for this? I can't think of many applications for this within a web application but that might just be me being naive..
Thanks, It looks like it‚Äôs a bug. I will look at it and fix it. 
Thanks for the awesome reply! The line between framework and library is somewhat blurred but from your description it seems almost like express is more library\-ish and hapi is more framework\-ish. I think I might end up going with express based on what you said. I like flexibility and making my own decisions. The middleware pattern as you've described seems familiar to me. It kind of reminds me of gulp/webpack/etc where you take something and keep on transforming it and moving to the next task. Is that a decent analogy for what this is?
&gt; still the only static language that doesn't suck You tried Rust?
You don't access the dom any longer in any of the available frameworks, all the query fishing for dom nodes is dead. Cross browser hacks aren't needed any longer since babel took care of it. In other words, there is not a single use case for jquery other than aging legacy codebases and there's practically no replacement because you just don't write applications like that any longer. Vanilla-js, implying that you could build user facing applications with plain javascript and dom-api is nonsense, just learn and grasp javascript as is, especially es-6 and up. There is virtually nothing that javascript gives you out of the box that would solve common application related problems: how to handle state, performance, how to construct re-usable views, dealing with view updates and events, etc. Almost all "vanilla" UI's i have seen make up a framework from scratch. If there's any javascript interaction going on or if there's any view that could be componentized =&gt; use a framework. The framework that most people use is React.
The analogy is sort of ok, but there're are some differences. First in express all middleware gets the same thing (a request, a response, the next callback), wgile in a build system you don't necessarily do that. The second one is that in Express, the ‚Äúchain‚Äù or process is one and you can't really change that. In a build system you might build two different pipes for different things. There are also other, smaller differences. All in all, they do look similar to some extent, but there are differences. 
That‚Äôs not far enough!!
&gt; If you're looking for something more trendy (i.e. component based) ... Nor are Preact/Inferno/Webcomponents AFAIK
can you please elaborate? im still new to the js world
So this cat expects me to believe jest was too hard for him to configure so he built an entire testing framework from the ground up? Just say you built this tool and you think it‚Äôs better for these reasons... the way this is framed makes me think you‚Äôre either lying or not a strong enough dev for me to trust your product 
Nice job. On a mobile the controls could be just tidy bit larger? Just my personal reference. Very nice job
i'm okay with reddit
Did you say tits?
Then you might as well short-circuit. `&lt;label className={!inputData.length &amp;&amp; 'has-data'}&gt;` 
&gt;Yo dawg, I heard you liked encapsulation. So I encapsulated your encapsulation so you can write your code, without writing code.
Props to him for talking even though he was nervous. I always imagine being behind the stage of someone who isn't fond of speaking on stage and right as they stammer or lose the red thread just shout out insane instructions to them as "helpful guidelines". Like in those romance films when someone whispers poetry from a bush. Like "Be honest with them - tell them you're imagining them naked. But the chick with the tits is starting to distract you. They'll respect honesty."
The DOM kind of replaced jQuery. It improved directly from the what was learnt from jQuery. `document.querySelectorAll()`is the most obvious example. It implements the most useful feature from jQuery in the browser. 
Any app which needs to solve the same ux issue your OS does with windows. Different bits of functionality and such
I don't ask about Ninja Turtles. Disagreement _might_ arise... but it might not. Instead, I ask about the best giant robot ever and then answer ‚Äúwrong!‚Äù whatever they say, which does almost always produce conflict and sometimes even a fight. Which is, of course, a great way to get to know people really well. More seriously, I get your point and agree somewhat. But still I always do ask at least some technical questions, or, better, engage in technical conversation.
Unless there's a specific reason to switch to something new because it fits your use case better such as a feature which is outright not available in your original choice or huge performance differences, most developers wouldn't choose to jump ship until a rewrite or new version of their project. It's not that it doesn't ever happen, but that it's uncommon to see. We revel in segmenting code, sure. This is a boon and a curse depending upon how you write your code. It's possible to write code that is awfully difficult to follow through the project, and this is more of a problem when you have multiple files. However, this is a better solution for version control within large teams and cross-organization. Modular and segmented code that is written well is a dream to read and work with compared to 1 huge file. Written badly though, and you end up with downtime from understanding the codebase. This isn't exclusive to JS, and a general 'write concise code' rule applies globally. I somewhat agree that react (and express) should come with key libraries - as you mention state and routing, both of which I personally view as essential to development in the current times. It used to be the case that they were included, but to try and improve the delivery time of the projects, they were split out into separate repos. It's not a case of they needed to do it, but it means that the entire project isn't delayed by projected improvements to the other areas. I do feel that the frameworks themselves are sometimes too convoluted and achieving what should be an easy task turns into an Everest of a problem, but most of these situations are caused by lack of understanding or even simply writing poor code at an earlier point which then causes problems later on. If there were another JS-equivalent language in terms of browser support, I don't believe it wouldn't have the same issues. See, while NPM has grown to be huge and a single source of most serious JS libraries, frameworks and projects, it serves it's purpose exceptionally well. It has flaws (such as the times when purpose-built exploit libraries end up being included in with larger projects because the name is similar to a trusted package) but it eases development. If we have another language that is as supported as JS, I'm sure we'd have a library registry for it, and it too would have the same issues you mention.
Love that, pull it out every time some says "I need an access database...". 
So this for example https://www.npmjs.com/package/authenticator seems like it only can generate the other side of the auth. In my case I already have the QR code and I need to register a new service and get a code. Maybe I‚Äôm just missing something. 
The only people that are still in pain belong to the old guard, clinging to the webs archetypes. Going from manual html/css/js and script tags into modern app dev is a pain in the ass and i can relate to their frustration having to learn new tools, though i'm fairly certain these tools do make matters easier. As well as those that are betting on stacks that specifically cater to the dom (web-components, extending html, new syntax abstractions, forking javascript into a new accent, etc.), hoping that the ever-changing internals they battle with stop overthrowing their codebases once standards are in place. The dom won't come around, no vendor is going to help it, any standard or spec that's trying to press even more backward-compat high-level complexity into archetypes that are already fundamentally broken will only make it worse. How obvious can it be at this point. Most developers have realized this by now. That makes javascript fatigue a personal choice.
I kinda doubt this is possible with TypeScript, given that its type system is not sound (1). This means that a variable which is declared as having type A, might in reality contain type B (even when B is not a subtype of A). Even so, the program will happily keep running. But to get those static typing performance benefits, the compiler has to be able to reliably assume the type at compile time, lest the program would crash at runtime. 1) Soundness is explicitly a non-goal for the TypeScript project: https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals
Never said they we're, I was responding to ostamustafa.
&gt; You can make your own Array type in pure JavaScript by leveraging objects. This is not entirely true. For example: var array = []; // array.length === 0 array[0] = true; // array.length === 1 If the above quote were true, you could create your own class, say `MyArray`, that has the same behavior. I don't think you can, though.
jQuery main aim is to normalise how you interact with JavaScript across browsers and make life simpler doing things such as traversing the DOM or making Ajax requests. Vue is a framework for building the `View` layer of your application or website in a way that will allow you to encapsulate UI logic into defined components for easier reuse. Vue won't help you select all the `.blink` elements on page and toggle them on and off (although you could make a `&lt;blink/&gt;` component to do that if you like :) TLDR: jQuery can overlap with some concepts of Vue, but at it's heart jQuery is a utility library not a ui framework. 
Yes
thanks man for the elaboration, it really clears things up
Very important points. By the time you implement all of that in vanilla JavaScript yourself, what you end up with will be a framework.
If you created endless zero byte files on a computer, eventually the hard drive would fill up. Just because the contents of the file is zero bytes doesn't mean the entire file is effectively zero bytes, there is still meta data, the filename itself, and (on windows at least) cluster alignment or MFT overhead (for really small files).
Are you a coding god?
I've never done much more than a hello world in typescript but I've always assumed it provides proper static typing? Why specify type A if it can contain type B?
Quick rule of thumb for me is that if the features I need would take longer to wire together from disparate libraries or my own code than the configuration and overhead of setting up a framework, then I use the framework.
I wish interviews were like this. Not a fan of having to solve riddles to get an offer. Why can't it be like other jobs where you can just do a good interview and be fine?
And 100,000 lines of custom code to maintain that other developers would have to learn new to join your projects...
There's information to be learned there for sure, but ultimately the practical answer is to not rely on any of that ordering. For instance the result Test 1: Start, End, Promise 1, Promise 2, Settimeout 1, Settimeout 2 The only thing I would rely on there is that "Start, End" will come first, and all the others will come afterwards in some order. If I wanted to ensure that Settimeout 1 came after Promise 1 I wouldn't do it by adding them to different internal queues. 
And then I remember I have to support IE 9. *sobs in outdated version of JavaScript*
# VUE -&gt; TITS That escalated fast.
Question two wouldn't be viable for the reason you gave next to **. Which means there is basically 0 technical assessment... As long as the candidate has a favourite turtle they stand a good chance of passing. This isn't something I'd personally feel comfortable backing my reputation on when interviewing people.
That site is a parody on web developers who used jQuery or some other library for litterally everything.
The short answer: Because it's sometimes more practical to allow for some more loose types, especially given it's based on JavaScript. It does sometimes create some weird surprises however. See for example: https://www.earthli.com/news/view_article.php?id=3391
No matter what it doesn‚Äôt accept the expression as complete. It is always looking for a ‚Äú}‚Äù or ‚Äú)‚Äù 
Nice! This was really cool until I double tapped the title bar and saw it maximize. Then it was awesome.
JavaScript online community fatigue is real, because its always led by continuously replenishing front of newly minted hipster webdevs, like a hydra of punctilious haughty adolescent knowitalls.
No bro! it's real use propose, came on
Hi, you can use ES6 Proxies to do this! I can make a small demo after work.
Looks like a pretty great joke to me!!! Can't be faster than Vanilla JS
But what if they can't traverse a binary tree in postorder traversal without recursion?
the only issue with that though is that it's "taskbar" then hides behind the main taskbar
i managed to cause a similar issue by dragging the windows outside their main window.
Why dont the other windows collapse when I shake one? ^jk 
May I ask what you are using to make this? Is it valilla js?
*reeeeees internally*
Definitely not for rank beginners though. I‚Äôd start someone off with Javascript.info &gt; YDKJS &gt; Eloquent JS
Found a bug! If a window is shorter than the windows it contains and you then scroll down to bring the bottom of the contained windows in sight the "taskbar" wont stay fixed to the bottom. Here: blob:https://imgur.com/46bc73c8-ff6c-4dd8-8961-aa874ff35083
&gt; If an app runs well enough why in the world would you migrate it unless you have nothing else better to do. This exactly. There's usually nothing wrong with old code. If it runs fine, there is no need to chuck it in the bin. Micro-frontends address this by letting you keep your old code for as long as it is servicable while still letting you use new frameworks for greenfield features. It's a good solution to the legacy "problem".
Great effort though. It will definetely pay off to have all of it working without any dependancies at all. 
It's considerably larger than the libraries I did mention that do roughly the same thing.
I think, in JavaScript, the migration problem is a permanent one. There will always be a new thing, and you will most likely want to use it. I'll check out the video, it looks interesting.
For one thing, this works in a browser environment - Jest doesn't.
Oh, there's plenty all right! ```left``` is a global, that's only initialised and used within small for-scopes. Learn and use ```const``` and ```let``` instead of ```var```. Using promises, but still using ```XMLHttpRequest``` instead of ```fetch```. async function get(url) { try { jsonResult= await ((await fetch(url)).json()); } catch (e) { // handle errors here } } \^ works the same, but a tons more concise syntax. ```getJSONPromise``` has a second argument defined that's never user nor provided.
There is a performance hit. It's most notable with AngularJS. The more AngularJS apps we have running on the page, the less performant our code becomes. React seems fine. Multiple React apps sit side by side without a noticable slowdown since the Virtual DOM only manages the div that the app is instantiated inside of, so a smaller app has lower memory requirements. If you want raw speed, this is probably not the right solution, but I think there's always a tradoff between speed and feature delivery. It's more than fast enough for our needs at this time.
This is great stuff and I hope you keep working on it. Just a few comments below. Chrome 66.0.x / windows 7 * When moving a window where the bottom is below the task bar, then scrolling, the taskbar isn't docked to the bottom. * When maximizing a window, the sub-windows taskbar is hidden, and the main windows taskbar is displayed over the top. Possibly don't have windows maximize over the main task bar. * When moving a window off screen to the right or bottom it evokes a scroll bar, not for the top or left. * When dragging a window by it's title bar, if you drag outside of the parent sub-window, it sometimes does a select all on the contents of the window. * If I maximize a window, drag the sub window to the bottom, scroll down, the sub-window gets stuck and I can't drag it up.
I recommend Fine Uploader. It does precisely what you are explaining. It can upload the chunks concurrently too. It also has support for retrying, pausing, and multiple files. We upload files directly to Azure, the uploads are very fast. In your case you would have to write the backend for it. https://github.com/FineUploader/fine-uploader
It's interesting that you need Node.js to build Deno. If Deno won't be compatible with Node API, that means it'll always have a strong dependency on Node.js and NPM ecosystem (unless TypeScript is rewritten in Deno).
You totally hit the nail on the head with everything you said here :) This is exactly the stack and the culture that we would like to foster. Also, knowing a range of frameworks is highly beneficial to a developer. They all explain one another, it's liek having multiple viewpoints on a single problem. I think this is a training issue, and a case of hiring people who are curious. Having the right stack goes a long way towards making hiring easier.
Typescript is far from a static language when it's still far less effort to write with completely free typings that with typings.
GitHub repository?
&gt; engage in technical conversation This has always been my go-to when interviewing developers. I don't ask specifics about anything but rather just want to talk about the overall world we live in. If they can't hold a technical conversation then I'm not sure they can be productive on my teams.
If they can‚Äôt then there‚Äôs absolutely no way I want them working on my CRUD apps
I very much do not understand the popularity of tree traversal questions. 
[vanillaJS](http://vanilla-js.com/) The site may poke fun at thewhole idea but I increased the speed of my site by removing all the unecisary crap. Jquery size gziped is 70k I dont zip the library I made in Vanilla-js and its 1.2kb. 
As someone looking to get involved w this subject, I found this video informative and fun. Cheers
Oh, good point! I didn't consider that because it cannot be polyfilled on IE :(
Absolutely awesome, works great and I‚Äôve never seen something like this before. If you‚Äôre looking for ways to improve it I‚Äôd look into a slight problem I had on mobile: When using the arrow that transforms the window into a bar, it sometimes worked but sometimes it would show the white box around it but not transform the window. If you need me to clarify, let me know. And as I said, it was a very minor thing, otherwise, well done!
First off, this is so cool. Legitimately awesome. It's making me think about how cool the idea of an operating system inside a browser would be. Second, I'm super curious about your use case for this. What are you using it for if you don't mind me asking?
ES5 version: function MyArray () {} Object.defineProperty(MyArray.prototype, 'length', { get: function () { var len = 0; for (var prop in this) { if (this.hasOwnProperty(prop) &amp;&amp; !isNaN(prop)) { var propNum = parseInt(prop); if (propNum.toString() === prop) { var propLen = propNum + 1; if (len &lt; propLen) { len = propLen; } } } } return len; } }); var a = new MyArray(); console.log(a.length); // 0 a[0] = true; console.log(a.length); // 1
Probably because coming up with actually relevant questions is difficult.
I wonder if other devs would be keen on joining such project.
I agree that technical interviews for the most part are bullshit. However, with the questions you've provided, you are only checking the candidate's ability to talk/spoof, nothing else. In which case you'll only hire the candidates who talk a good game but cannot deliver. There's definitely room to ask better questions, and not have shitty puzzles that do not resemble the actual work.
Because it uses Puppeteer, which Jest can also do.
Generators are incredibly powerful. I think it's something we will start to see used more frequently in JS. Two of the best production\-quailty examples are Koa and Redux Saga
It's a fun joke site that's trying to make a point: Don't rely too heavily on ${insert\-brand}.js. People are relying too heavily on libraries, which takes away learnings from actual JavaScript operation knowledges.
Wish this was around last year. I had to roll my own solution, and it's significantly less nice than this!
Aside from the great insight, it was kind of nice to see his nervousness and other quirks. It was kind of cool to see someone so influential be humanizing.
I'm not seeing what that article claims when I copy those definitions in to the TS playground. `A2`, `A3`, and `A4` are all throwing errors on the definition of `f`.
Thanks for the insights! I agree, it's the balancing &amp; tradeoff and much of it has to do with the nature of the business (and goals). BTW great article and perspective :)
Exactly this. I thought the era of trying to replicate JAVA-esque interfaces inside of the browser was dead, with cssgrid or flexbox layouts on top of media queries and whatnot. It's not a UX that we want to promote as web devs... 
Oh, ok than. Thank you
What technique does utilize in order to do that? Does it eat up a lotta client's ram or cpu?
Nice job! Now *just* add some buttons and textboxes. Also, do you have a git repo for this?
There is **a ton** of information on `canvas` on the [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API), really a lot. Please, do search around a bit. You'l find information on [drawImage](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage), [getImageData](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/getImageData) and [putImageData](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/putImageData), toDataUrl and others. Not only that, but [also links to even more information and tutorials](https://www.html5canvastutorials.com/advanced/html5-canvas-save-drawing-as-an-image/) and [examples](https://codepen.io/search/pens?q=canvas&amp;page=1&amp;order=popularity&amp;depth=everything&amp;show_forks=false).
I might be missing something but it doesn't look like the click targets behave predictably, specifically when attempting to close windows. [video link](https://imgur.com/kvSRaMr)
Recruiters just need to cover their butts. If they hire somebody who doesn't last long, they need some widely accepted criterion to point to, and say "He passed the stupid test, so I have no idea why he didn't work out! What a baffling mystery!"
[removed]
What's up with the editorialization of the title? The ^TM doesn't appear anywhere in the article.
Super dope mate!
Checkout this Twitter thread https://twitter.com/joelatwar/status/1000455214728597504?s=19
Its more like JavaScript community fatigue. There is an endless supply of freshly minted egos blithering about new trending technologies.
great!
Awesome. Is it just my iPhone, or does it not rotate?
It really looks perfect and functional. I'll be waiting for the repo :)
Truth hurt.
Yeah, he was like that when first announcing node, I think he's a lot more comfortable now actually.
It‚Äôs such a shame about the syntax though. I will avoid redux sagas like the plague in any way I can because of this: foo.bar(); Becomes: yield call(‚Äòfoo‚Äô, ‚Äòfoo.bar‚Äô); Now imagine doing that for almost every statement you write. It gets old really fucking fast.
Hi /u/elgselgs, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_).
Excellent work!
Do you intend to make it available for free (github) or selling it as a plugin(codecanyon and such)?
Is it bad that I don't even understand the base example?
Doesn't look mobile friendly to me? Touch targets are small, tap events are not always registered... And the whole concept of "windows" perhaps is not best paradigm for working on mobile devices
&gt; Just because you can doesn't mean you should. What shouldn't I be doing? Writing this? Posting it here? Just because you can use it doesn't mean you have to. This package is more of an experiment with proxies and promises than anything else. I'm not using it in production, and I don't expect anyone else to either. 
Too bad the example doesn‚Äôt work for arrays of length 0.
Very nice :) However, moving a nested window select the parent content. (text is highlighted)
Why would you need a rule engine? It's much easier to simply write the business logic in plain JavaScript... (Sorry if that was a bad answer)
I think it would become yield call(foo.bar). But you don‚Äôt need to replace every single function call with ‚Äúyield call‚Äù. You‚Äôd really only need to do it if you‚Äôre calling something async (and even then you technically don‚Äôt have to). It also makes it so that you do not have to mock the function in tests. But if you‚Äôre okay with having to deal with the function in your tests and you are able to go ahead and call foo.bar() directly. 
Before ES6, you could use a getter, which is not _exactly_ the same (worse time complexity), but _the same enough_ to allow you write code in the same way.
This was actually in my original post. I think it's a good option! 
This also happens when a window is minimized: you can scroll the parent window down.
Just had a quick browse through since I'm at work but it seems there is jQuery code in the JS part. jQuery is a JavaScript library that has lost a lot of popularity. For learning purposes, I would strongly recommend staying away from jQuery as it can create lazy habits.
What would you recommend I look into while trying to create a BuzzFeed quiz style like site? That's my project for the summer.
&gt; Considering ES6 has the "class" keyword. Would you consider ES6 as being class based OO? Or would you say it's not due to the class keyword mostly just being syntactical sugar? I would say JS is not class-based, but not for the reason you gave. The distinction between prototype-based and class-based isn't about abstract blueprints vs runtime objects, nor is it about runtime delegation inheritance vs compile-time copy inheritance, since Python, Ruby, and Smalltalk are are all considered class-based yet implement their classes as runtime objects and their inheritance as runtime delegation. Rather, the distinction between prototype-based and class-based is that in class-based, instances must be spawned and inherit from a class, whereas in prototype-based, instances can be spawned ex-nilo and can inherit from any arbitrary object. The Python vs JS code sample I linked to earlier shows how both their classes are objects and both their inheritance is delegation, but here's something JS can do that Python can't: mycat.__proto__ = new Dog(); // ok // vs mycat.__class__ = Dog(); # TypeError: __class__ must be set to a class, not 'Dog' object In JS, instances can inherit from any arbitrary object, whereas in Python, instances can inherit _only_ from objects specially designated a class.
If you're new to JS, do it with vanilla JS. 
there are also lots of qr code reading modules on npm.
Yea but I‚Äôve not found any module that takes the data from the QR code and allowed me to get a token. 
Seems promising, will it be free software? I found a bug with the context menu (right click), if you click a greyed option it assumes that the menu was closed, so you can open a new context menu.
Yee wonder if the file size is lower now. Mobx was pretty big. 45k or something
I finally got a few jobs using vue. Time to recover.
Check out my newest project! I'd love to have it reviewed, and maybe have someone make something with it! [Libmoji](https://github.com/matthewnau/libmoji)
https://www.npmjs.com/package/jsqr
you should check https://github.com/os-js/OS.js out ;-)
Hey guys, I made this and would love your opinion on it. I spent a lot of time not just on the code itself, but on the documentation and supporting articles so that everything I was doing made sense. Please let me know if oyu have feedback or questions! I would love to see projects spawned off of this :)
Well, you never *needed* jQuery, it's just more readable, maintainable and compatible than vanilla. I still prefer using jQuery (when choosing between vanilla and jQuery), because it is still much nicer code and handles many browser quirks (looking at you, IE).
It's another API: [Google Places API](https://developers.google.com/places/)
the javascript looks for items on the page with particular names, css-classes or data-attributes.. e.g $('ul[data-quiz-question]') $('.quiz-answer') find('.quiz-answer.active') it uses the jQuery library to help with this, but it could be done without. A good exercise might be to convert each use of jQuery in this example to vanilla js. So it finds the checkboxes in the page and adds a function to be called when a checkbox is clicked.. $('.quiz-answer').on('click', function(){...} it compares the answer given with the hard coded correct answers in the javascript and keeps track of your score. At the end it changes the css on a hidden element to make it visible to show your score. 
I read your post with interest, it's interesting to see how a company might scale. I think it's probably important to modulate the degree of fragmentation. To pick up on your point: &gt; it's not necessarily uncommon that you end up helping maintain a large Ext.js subsystem or whatever because that's what you were assigned to when you joined and now have the most context on I think my perspective is that this is unfair to the developer. Decent developers will see the trap and jump ship, which leaves the juniors with stagnated careers. I've seen people who have become stuck in legacy without realising it. They become the expert in a particular thing. They get better and better at it, and their salary grows accordingly. After a few years, their salary becomes really very substantial. Then the company pulls the plug on the technology and they lose their house, because they never kept up. I call it the legacy cliff. It's a real thing. 
Probably not. The few times I've worked on teams with extensive homegrown application and UI toolkits, they were always lower quality and worse for productivity than learning a popular framework 'off the shelf'.
What part do you not get? `[...Array(totalNumSessions)]` returns an array of totalNumSessions length, with each item being undefined. It then gets mapped over so that your final array (what gets assigned to `cycles`) is the same length. Inside each cycles array item is an object with a key/value pair of `lift` and a string from the `lifts` array. Looking at `lifts[currentLiftIndex++ % lifts.length]`, `currentLiftIndex` is the index of the next lift. the `% lifts.length` is just a way of making the index "loop" back to the beginning of the array instead of going out of bounds. Try doing `0 % 4`, `1 % 4`, etc to see it in action
Adding to this, Koa, sagas, and friends the abuse of the generators to implement asynchronicity. Async eliminates that need.
Agreed, they're 24x24px on mobile, should be at least 44x44px. 
Ryan rightly warns about adding ‚Äúcute‚Äù and unnecessary features to projects. Then he goes and adds the ‚ÄúLoad module directly from a URL‚Äù feature with all its complexity to Deno. Ryan; kill that feature now. It‚Äôs not needed. It‚Äôs just cute.
xD
lmao
All that does is read me the QR code. It doesn't give me an authenticator token to use for 2FA. I know what the QR says, that's not the issue. Sorry not explaining that well.
&gt;The point is, any dev that is worth hiring will have the experience to back it up, and have a list of projects as proof. And unless you ask technical questions, you'll have no idea whether those years of experience were a progression of their skills, or just the same 1 year of junior experience over and over again. And you'll have no idea if they were contributing useful work to those projects, or coasting on the work of their colleagues. If we'd taken this advice, we'd have hired several senior developers with 10 years experience who nevertheless can't fix a simple bug caused by variable scope. &gt;You don't have to memorize the answers. They have no bearing whatsoever on the day\-to\-day working at your company. Baffled by this, honestly. You don't need to memorise the specifics of a language, you just answer in your own words off the top of your head because you understand the language properly. And whether you understand the language or not makes quite a big difference in a developer's day to day work. "How does \`this\` function in javascript" isn't some pointless arcane knowledge, it's the difference between just sitting down and writing working code, or spending all day on stack overflow, scratching your head and coding by trial and error.
You should use string.split and there's no need to use eval: function getSafe(v, path) { const items = path.split('.'); for (const p of items) { if (!v.hasOwnProperty(p)) { v = undefined; break; } v = v[p]; } return v; } 
I guess the one main question is why is there a spread operator in front of the blank sized array? Why would you create a blank sized array then fill it using the map function? Why wouldn't you just loop and push into []? If readability is important, that seems way more straightforward. Putting the generator that loops through the little array and calling its next is more readable than an index you already have for free? I don't agree at all. There is one syntax error, a missing ")" though I wouldn't have said anything if not for the weirdness of the array stuff. 
Koa/Saga do that because they predate async functions and async generators :P
So glad I never did web before this
I like the ES5 implementation, gets the point, but I made a minimal ES6 Array\-Like, which you can imagine being extended to work exactly like an array: [Gist](https://gist.github.com/MKRhere/b9cb63dad56432c85c14ebafdedff59d)
FWIW those 2 examples aren't great by modern standards. fetch() is one line
I guess the one main question is why is there a spread operator in front of the blank sized array? Why would you create a blank sized array then fill it using the map function? Why wouldn't you just loop for totalNumSessions and push into [] with the free index you get for free. If readability is important, that is way easier to understand. So you loop through a sized blank array, then call a generator that loops in steps through the little array, and that is good? There is also a missing end ) for the map function, I mean, run your code before you publish it.
The point is that TypeScript is nothing but syntactic sugar and tooling on top of plain js. The TypeScript compiler may throw errors from type mismatches but it still compiles down to JavaScript so the actual values at run time can be whatever
Brendan Eich (creator of JS) explains the context for the "cute" feature [twitter](https://twitter.com/brendaneich/status/1004462862880788480?s=12)
hey I've been looking for something like this for a while. I'm a software developer so I can help if needed, can you just release the code though so I can start testing with it?
I looked it up and I was originally incorrect. Array(n) return an array of n length with n empty slots, not n undefined values. I don't have time to test it but I would bet mapping over just the returned value of Array(totalNumSessions) wouldn't work
Looks mostly fine for a mini-jquery, but couple of issues caught my eyes: - if addClass and friends don't work in IE9, then claiming IE9 support is a stretch. - possible null reference exception in getAttr - why not map third arg of .on to corresponding param in addEventListener - fallback for addClass doesn't account for duped classes - .offset looks broken
That's correct.
I would not approve this PR.
The answer is that your solution would work just fine as well. The way it's coded now is a common solution to this problem, a generally accepted pattern. It's understandable that if you haven't seen it before it might look confusing/non intuitive. As far as the missing parenthesis for the map function, I would encourage you to let the author know! Little mistakes happen, but as long as they're mostly inconsequential (like this one), try not to let it detract from the bigger picture.
The example in the article doesn't seem to work (even after adding the missing ')' at the end of the map function).
Koa switched over to async/await though.
&gt; Interviewee: What stack would I be using here? &gt; Interviewer: What stack would you like to use? We probably have it. That's gotta be a powerful hiring tool.
This is some basic jQuery, which is a library of functions created in JS. jQuery is JS but JS isn't jQuery. The syntax may seem a bit confusing if you're unfamiliar with it. Here are some key concepts employed and some explanation of the syntax. 1. jQuery selectors i.e. `$('example-string')`. This is how the library identifies a DOM node. `.find()`, `.on()` are methods assigned to that DOM node. 2. The `this` keyword is how JS references the 'thing' that is referencing a particular method or property. 3. The `$` syntax is how you invoke the jQuery library. But it is also being used to imply a jQuery object is being passed as an argument such as in line 16. Devs like to do this because JS is loosely typed, which means the language doesn't require you to declare what things are when you are creating variables or arguments. So you don't forget it's a jQuery object, this dev has prefixed it with `$`. Its the same as any other string. 4. `this._something` The underscore here is another shorthand that devs employ to communicate a method that is intended to be private, i.e. used internally in the function and not to be accessed outside of it. In this example, however, it isn't actually private. You can call all of these methods directly. There are different patterns in JS for keeping certain properties and methods of objects private. The "revealing module pattern" is one of them. 
infinitely better, thank you!!!! 
That only matters if ts is actually transpiled. My point was that if compilers start to take in ts instead of js, then they do know about the times at compile time and can therefore produce faster machine code.
https://martinfowler.com/bliki/RulesEngine.html &gt;ll of these lead me to think that there's a lot to be said for avoiding rules engine products. The basic idea of production rules is very simple. In order to keep the implicit behavior under control you also need to limit the number of rules by keeping the rules within a narrow context. This would argue for a more domain specific approach to rules, where a team builds a limited rules engine that's only designed to work within that narrow context. Certainly if you're thinking of using a rules engine I'd suggest prototyping with both a product and a hand-rolled domain specific approach so you can get a good feel for how they would compare. Martin Fowler, programming god
I thought that said strip clubs at first.
So on the one hand I tend to use both in my projects. On the other hand ... who starts so many projects that they're better off finding a new plug-in, downloading and installing it, learning it, and then using it, vs. `npm i --save-dev eslint; npm i --save-dev mocha`?
It's not even cute, it's a stupid feature because he regrets npm. It might be the single most confusing way to share dependencies between developers. It also just looks plain ugly, what happens when the repo changes? You can't change it one place you have to change it in every place you used that library... There is a reason why dependency manifests exist in almost every major language, they create consistency where Ryan clearly sees that as a setback for _some_ reason.
Man that is a leap, if that's the only way to import external code I'm just cloning the dependency into a vendor directory and overriding the import loader.
I got your point, I was responding to something else, I think at least.
[removed]
Thanks, I don't want to drive this into the ground, but the spread operator I did not understand was the first one **...**[...Array(totalNumSessions)]
The most practical way to use generators is to avoid them completely. They were necessary for async/await, but actually using them in production code is a line you probably shouldn't cross if you want it to be maintainable.
What's wrong with jQuery? I try to get my javascript coding done as fast as possible because I hate JS. 
&gt; ‚ÄúCreate_x0020_Password_x003f_‚Äù == ‚ÄúYes‚Äù This will always evaluate to false since those strings are not the same.
&gt; This means if you are using Coffeescript or Typescript you will be out of luck right now. Or Flow, or dynamic imports or decorators or optional chaining operator... (all things I see in production codebases from teams who use testing configurations I maintain). Lack of configuration is great... until it isn't. &gt; Browser testing is built in and runs by default. This is a great start, but not enough in a lot of cases, unfortunately. You need to be able to test in IE, for example, if you're testing polyfills for example. To be fair, supporting cross-browser testing in one integrated solution is a hard problem. &gt; It supports comparisons to arrays and objects without having to use any custom syntax This is a **terrible terrible terrible** idea. What are the semantics? t.deepLooseEqual? Does it use `Object.is` on primitives? And what if I want different semantics? Also, considering this is probably done with static analysis, how does it possibly do the right thing on `assert(foo == gimmeArray())`? &gt; The tests for Luna are run by Luna Personally I've taken this approach before (with a test lib called ospec), but recently I've been finding it to be a bit of a pain if I have a monorepo setup and need to link packages. I've been experimenting with just having a super simple assertion collector (which itself can be fully tested with just a couple of vanilla if/throw statements)
Hi /u/seancuscus, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/trapkick, For javascript help, please visit /r/LearnJavascript. Thank you!
jQuery does waaaaaay more than serve as an element selector. That's just the best known feature since pretty much everything will always start with it.
ah cheers lad 
Take the mod of an unfixed hash value would be my best guess at limiting string length.
sha256 is always 64 characters.
And those things are better done in better, smaller, faster libraries.
How do you edit lists of things? If you have a v\-for over table rows or list elements, and you want to edit one of the elements, how do you reference it through binding?
This is hardly a criticall failure point. More like a minor performance thing to watch out. In most cases you won't have problem with this.
Why not use MD5? Or better yet, SHA2? Or Bcrypt?
I found generators very usefull to distribute a task over multiple frames. Task takes 10ms but we only have 16ms per frame and much more important things to work on? =&gt; Execute task for 1ms, then yield. Continue in next frame.
Technically, nothing. However, for someone that plans to learn JavaScript with the intent to build with JS technologies such as Node, or React, learning jQuery is a backwards step.
Doesn't Deno effectively clone the dependency for you anyway, locking it until you run ` --reload`? I can understand this approach since Ryan also considers manifests to be ‚Äúboilerplate noise‚Äù.
I understand your point, but there's nothing wrong with learning jQuery, it's still a very popular library
True. Another big part of jQuery was how it acted as a cross browser layer which handled and hid many of the incompatibilities which made web programming awful. Now that the major browsers are highly compatible on the DOM level, there is much less need for jQuery. 
‚ÄúFaced with the choice between changing one's mind and proving that there is no need to do so, almost everyone gets busy on the proof.‚Äù ‚Äî John Kenneth Galbraith It was so refreshing to see Ryan admit to faults in Node and propose something potentially better in Deno, even if it's early days for that project. I was at AmsterdamJS last week, where Douglas Crockford used the above quote and talked about how progress is made in science and tech ‚Äî normally a paradigm change requires a generation to die off first, because it's easy to get stuck in your ways. https://www.youtube.com/watch?v=OzWpYkLcwcQ It's great that a community leader like Ryan can stand up in front of peers and fans and say, ‚Äúall this stuff was a mistake ‚Äî let's build something better‚Äù.
Not saying that theres anything wrong with jQuery, or that it isn't a very popular library. Simply stating that if someone is new to a particular language, it would be EXTREMELY beneficial to learn to work with the actual language itself before learning to use the various libraries available. If you don't actually understand what jQuery is doing, I fail to see how someone could be productive with it. 
A couple observations: - You can absolutely make standard function calls in the middle of a saga. You only need to use `yield call()` when you want to pause the saga, ask the middleware to go off and do the work for you, and resume the saga when the result comes back (such as an AJAX call that returns a promise). - Your example has the wrong syntax. It should be `yield call(foo.bar, "arg1", "arg2")`. 
Because I wanna know how it works. 
https://en.wikipedia.org/wiki/MD5#Algorithm
What is the mod?
That and the fact that every junior that reads your code will copy paste it into oblivion throughout the project not understand _what_ only knowing _that dude that knows more than me does it so it's probably right_ ... When in reality, _you_ actually didn't need it in the first case. I learnt this the hard way.
No. You learn by first undertanding an implemntation like MD5, SHA, Scrypt, Bcrypt etc. Learn those then roll your own NEVER FOR PRODUCTION. - Local security guy
Wait is this mobx or redux saga
formatting is subjective
I have no idea how _good_ hashing algorithms work. But if you just want to conceptually understand how you might come up with a fixed length digest, I can invent a _bad_ hashing algorithm for you right now. 1. Take string 2. Convert string to string of char code integers 3. Adjust length: - if length is 8, you're done - if length is less than 8: * sum together last two characters to get new character * add to the end * repeat until you have length of 8 - if length is greater than 8: * replace last two characters with single character sum of those characters * repeat until you have a length of 8 Example with `'FOO'`: ``` FOO -&gt;707979 -&gt; 707979 + (7 + 9 = 16; 1 + 6 = 7) -&gt; 7079797 -&gt; 7079797 + (9 + 7 = 16; 1 + 6 = 7) -&gt; 70797979 ``` Example with `'foo'`: ``` foo -&gt;102111111 -&gt; 1021111 + (1 + 1 = 2) -&gt; 10211112 ```
'There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies, and the other way is to make it so complicated that there are no obvious deficiencies.'
For someone who wants to get learn and know more about mobx this format of a release blogpost really doesn't help. Sure it's funny but really doesn't give me any practical information. I can read the changelog sure, but i was really confused when i opened this post. A blog post detailing the reasons, struggles and things would be more helpful (like the one for [mobx 4](https://medium.com/@mweststrate/mobx-4-better-simpler-faster-smaller-c1fbc08008da)).
Oh nooo not another redux !!
[removed]
Wow, someone who got the joke. This sub is getting better. Thanks mate.
There is no way to answer this without knowing how your game is set up but it would be pretty easy to put a "member: true" or something on the Player/Account model
Yet jQuery is still one of the most popular JS libraries right now, even if it is waning in popularity. Nothing has usurped it - yet.
Hi /u/lvguowei, For javascript help, please visit /r/LearnJavascript. Thank you!
Can someone please tell me why there is a while(true) loop in the generator function? I don't understand it. 
Hi /u/psych0ticmonk, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/PandaDabPandaPanda, For javascript help, please visit /r/LearnJavascript. Thank you!
Sorry didn't know that existed :)
Sure, locally, but how does your dev who jumps onto the project a couple months later get the dependency you've been building with? What about the build systems?
What‚Äôs wrong with the public relation? You jalous?
4.3.1 was 49,3 KB, 5.0.0 is 40,6KB (17.5% less)
Could be used to generate some random numbers
also... https://github.com/franciscop/umbrella https://github.com/finom/balalaika https://github.com/finom/bala
I think that it‚Äôs what prevents this function/generator from reaching an end state.
Thanks for the help The last website was what i needed I already knew about the docs on mdn but it was kinda overwelming for me 
How familiar are you with generators in general? Here's a simplified example: function* foo() { i = 0; while (true) { yield i; i++; } } genObj = foo(); genObj.next(); // 0 genObj.next(); // 1 genObj.next(); // 2
You can use the flat library: https://github.com/hughsk/flat
love you &lt;3
I love you both
Thank you for such kind reply :D
mobx is even older than redux and it takes radically different approach
Don't forget to check out Rollup js as well. It is a simpler alternative to webpack. Less features though but the output is, IMHO, much better. 
The WebPack [Getting Started](https://webpack.js.org/guides/getting-started/) documentation does a decent job of walking you through the basics.
If remote dep URLs contain version info (as proposed in slide 23 at http://tinyclouds.org/jsconf2018.pdf), new devs and build systems can fetch the same deps you have just like they do now with npm, right? Only Deno fetches deps and caches them on the first load, rather than having to explicitly run `npm install`. The dependency and the version info just moves to the remote URL in the import instead of a manifest you need to maintain. That same slide even mentions, ‚ÄúVendoring can be done by specifying a non-default cache dir‚Äù, which sounds like what you were hoping for too. I'd love to better understand the drawbacks of this, but it feels elegant enough to me.
In addition to the other posters warning against using a rules engine, I would also echo Martin Fowler‚Äôs advice. That being said, I also frequently develop using Drools (what jBPM uses under the hood), and have bee eyeballing https://github.com/jruizgit/rules since it has bindings for Python, node, and ruby. I don‚Äôt have much experience with that library, but in case you hadn‚Äôt found it I thought I‚Äôd bring it to your attention.
It makes me sad Vue isn't really viable in the job market. It's really a joy to work with and I would be so happy to land a job that uses it. But React isn't so bad. Much more pleasant to work with than Angular imo.
[removed]
I just dont see the upside. Its like "nice language, with optional pain"
Yes, It has no async as far as I could tell, so no big performance hit. Its low enough level that it feels like an extra clunky C++, and I just dont understand why anyone uses it for anything... 
Yeah, it's annoying, I feel you on that. What I usually do is just use lodash get ([https://lodash.com/docs/4.17.10#get](https://lodash.com/docs/4.17.10#get)) because it lets you have a default value if the property doesn't exist. Just need to normalise your data a bit before using it
I highly recommend using [Lodash's get function](https://lodash.com/docs/4.17.10#get). e.g. const foo = _.get(someObject, 'some.deeply.nested.prop', false);
 object &amp;&amp; object.property Should work.
There are proposals for a [Null Propagation operator](https://ponyfoo.com/articles/null-propagation-operator), as well as a [Null Coalescing operator](https://github.com/tc39/proposal-nullish-coalescing).
usually people do checks like obj &amp;&amp; obj.nested &amp;&amp; obj.nested.property this expression returns the desired field, or undefined/null using the selectn module can also be handy. selectn needs an object, and a path string and does a lookup based on it also there is a proposal for the ?. operator that solves the very same problem 
`undefined` is its own special monster, but its roots are back in 1964 and the inventor of the `null` type. Nearly every language has this in some form or other and newer languages are attempting to avoid it in some ways (see Kotlin &amp; the elvis operator). Java introduced `Optional` as a way to mitigate it, but `Optional` has some controversy surrounding how it was implemented. [https://www.infoq.com/presentations/Null\-References\-The\-Billion\-Dollar\-Mistake\-Tony\-Hoare](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare) [https://www.lucidchart.com/techblog/2015/08/31/the\-worst\-mistake\-of\-computer\-science/](https://www.lucidchart.com/techblog/2015/08/31/the-worst-mistake-of-computer-science/)
I agree with you
A generator is basically a pause-able function so as long as you have a yield statement in the infinite loop it will never actually block (I know it looks totally weird!). It basically just allows you to constantly call genObj.next() infinitely like the other poster who responded to you described. The only thing I ever use generators for though is when using redux-saga for handling side effects. It let's you write code that looks and acts synchronously but is actually handled completely asynchronously ala: function* fetchData() { yield put(fetchDataRequestAction()); try { yield call(APIService.fetchData(parameters)); yield put(fetchDataSuccessAction()); } catch (e) { yield put(fetchDataErrorAction(e.message)); } } No more callback hell or infinitely chaining promises :) 
You're all talking about Koa 1. Koa 2 uses async/await and Koa 1 was never meant to be more than a beta (before async/await properly landed everywhere).
Well Koa has moved on to async/await, and redux-saga keeps using generators because they're a little more powerful.
and I guess I should mention how the infinite loop is helpful with the above code... redux-saga has a helper called `takeEvery` which can basically be implemented as this (I copy and pasted this from their docs btw): const takeEvery = (patternOrChannel, saga, ...args) =&gt; fork(function*() { while (true) { const action = yield take(patternOrChannel) yield fork(saga, ...args.concat(action)) } }) So now every single time the redux-saga middleware is alerted to a specific action, it basically forks (think similar to Unix processes) a new saga that triggers the above code.
I know I'm talking about Koa 1 :P Koa 2 is a godsend
The proposed [nullish coalescing](https://github.com/tc39/proposal-nullish-coalescing) operator, which you can use with Babel's @babel/plugin-proposal-nullish-coalescing-operator plugin, makes this sort of thing a lot easier. I'd recommend checking it out.
I used an async generator recently for fetching results from a paginated API. It helped make things cleaner IMO. Something like: async function *getItems() { const initialResponse = await getItems(); yield* initialResponse.data; let nextPage = initialResponse.pagination_token; while(nextPage) { const response = await getItems(nextPage); yield* response.data; nextPage = response.pagination_token; } } for await (const item of getItems()) { doSomething(item); }
So let‚Äôs clarify a few things first. When JavaScript engine is interpreting a code. It takes all the variables and create memory spaces for them that is initialized to undefined which is different from null. Then as it interprets the script and executes the functions in it it will fill in the values. Undefined is different from null. It means that the variable has been named but not filled. Undefined has no properties so it will give you an error. so if you have a situation where you may psd an undefined variable into a function you will have to check for that variable not being undefined first On a side note, it is not clear from your post what logic you added to ensure the async function executed, in my own experience those error happens when I don‚Äôt handle the promise correctly https://stackoverflow.com/questions/5515310/is-there-a-standard-function-to-check-for-null-undefined-or-blank-variables-in
npm is just a package manager `npm install jquery` now you can use react in your project. You can import it into your project with `import $ from "jquery"`. Now you can use it within the file you imported it, just like you could use it on a website with `&lt;script src="`[`https://code.jquery.com/jquery-3.3.1.min.js`](https://code.jquery.com/jquery-3.3.1.min.js)`"&gt;&lt;/script&gt;`. The difference this way is that the scope of jquery is restricted to the file you imported it into, instead the entire global scope like would happen if you used the script method. The problem is that not all browsers support importing modules, and none of them support npm. That's where webpack comes in. You bundle all your files using webpack, and it magically turns all of your files into a single js file so that they will run in the browser. Node just lets you execute js outside the browser. There are three special things about it, it supports modules, npm and it has some special libraries that communicate with the OS using C\+\+ but that's hidden behind the scenes and you don't need to worry about it. Learn the basics about node modules, and npm and you'll be ready to read the webpack docs. 
LOVE TRAIN
Intro.js?
I completely agree that order dependencies should be explicit. But I do find it interesting that the promise callbacks resolve before the timeouts. That implies that the promise implementation (in your browser at least) uses something like Node's `nextTick`. Thank you for posting the output. I was disappointed that Codepen did not provide an option to view console output on my mobile device.
Out of curiosity, why the constraint?
Is there a language where accessing or dereferencing something that doesn‚Äôt exist will NOT cause an error? And if so, what does it return?
I bought 10 javascript books that were the latest released dates on Amazon that had less than 300 pages each. I took 2 weeks off and read all ten books. If I didn't get something I just plowed through it, I didn't spend a lot of time re\-reading stuff, because the next book on my list probably would cover it better. Turned out pretty good.
Usually causes a compile error so you can‚Äôt even run until you fix it. Much better than finding it later.
From the man who made node, he now suggests parcel 
Although, pulling in Lodash for one simple function is unnecessary. Either learn to use Lodash, or recreate that function locally.
you have got to be trolling. 
"Well at least they implemented it correctly..." *checks again:* literal copypaste of my code no string literals changed. Me: this isn't boiler plate. Them: oh, yeah i couldn't figure that part out but i thought it was necessary. üòë
mod is the remainder of division so 10 % 2 = 0 because 10 / 2 = 5 with no remainder. 10 % 3 would be 1 because 10 / 3 = 3 remainder 1. You'll want to use bcrypt though, definitely do not use your own for actual purposes. These algos have been designed and tested by top encryption scientists for decades to validate their security. You will not create a safe algorithm, period.
Modulous
you're right. This was really easy
OPs logic doesn‚Äôt even do anything, if the object isn‚Äôt null it returns the object, or null if it is null You could literally just pass the object instead OP you have a lot to learn, and getting annoyed at what is/was very common amongst many languages is not a great start
The functions are exported as individual modules. `import get from 'lodash/get';`
It‚Äôs surprising to me that OP is annoyed by this when it‚Äôs such a common occurrence across standard languages 
AS2. undefined.
in my experience if I need to be doing object null checks all over the place, I've failed at an architectural level.
Sagas are cancelable and propagate cancelation downwards. Try doing that with async/await. 
Now everything is still in my computer. I will update here once a test version is release to Github.
Thanks for the suggestion. I will improve it.
Yep. Put me off in about three seconds.
Yes I‚Äôm aware of that. But it still gets npm installed as the entire library, doesn‚Äôt it? And eve if not, I don‚Äôt see the point in using npm just for a function that you can replicate. It is open source, after all.
Thank you for the feed back. I will check that.
That‚Äôs how you get bugs and variance of functionality across different browser. It‚Äôs not much inconvenience to pull in a helper function. And most likely, unless you‚Äôre app is a todo or hello world you‚Äôll need the helper functions to make development quicker. 
Use angular with its forgiving nature ha. What would you suggest the behavior to be. 
This might just be the worst hashing algorithm I've ever seen. Well done. 
I believe this is the Babel plugin you had in mind: https://www.npmjs.com/package/babel-plugin-transform-optional-chaining
I'm using Javascript and SCSS.
PHP
Thank you so much for the feedback.
Here's another way to do it function repeatArray(arr) { while (true) { yield* arr; } }
Did you mean shaking your phone?
Thank you so much for the kind words and the feedback!
That's really weird. What browser were you using?
It lives in the browser, so I think the windows should rotate with the browser.
Yes, because it's newer than webpack and therefore better!
Thank you. I'm so encouraged. Now it's still in the early stage. I will publish to Github and update here when it's ready.
I want to make it free.
Yes, that's a problem. Actually the border is very busy. There are dragging handles somehow overlapped with the tiny buttons on the mobile devices. That needs to be improved. Thank you for pointing it out.
Thank you. I will check that.
Sorry maybe I didn't understand it, or I cannot reproduce the problem.
Thank you. I will when it's ready. It's now still in early stage of development.
It might be useful for the touch screen laptops.
LOVE SHACK BAAYYBYYYYY
I'm literally flattered.
I will publish it to Github when it's ready.
Na it‚Äôs just easy for new people to join the ecosystem :^)
There's a TL;DR at the top and bottom of the article linking to [the actual changelog for mobx 5](https://github.com/mobxjs/mobx/blob/e17c47833d1812eee6d77914be890aa41e4b7908/CHANGELOG.md#500).
Hi /u/stevenmcstravog, this post was removed for 2 reasons: 1. Please post tutorial and learning content to /r/LearnJavascript (ES6 has been out for several years already). 2. If you're posting a link, use the "Submit a new link" button; to add additional commentary, leave a comment. Thanks for your understanding!
Hey, We have had a good amount of people interested. We have decided to build a git based note taking app in React, but have had talk of expanding to more projects as well. Go check out the slack channel. #announcements has a rundown of our plans so far. If you are interested, introduce your self in #introductions, and take a look at our issue board on GitLab https://join.slack.com/t/gitnotes/shared_invite/enQtMzc2MzMyNDg2MjkzLTU5OTg5NGUxYTQ3NWQxNzY2ZTdmMTc0M2MwOWY2ODFhMjM3M2RmNzUxM2I2ZWIyZjk4ODkzMDU4MjcyNTRjODI
Chrome, Version 66.0.3359.181 (Official Build) (64\-bit) Using mobile view in the dev tools
Not gonna lie. I kind of want to implement it now.
I see. When it‚Äôs in mobile mode, the invisible drag handler is wider, since our finger tip is bigger than the mouse pointer. The drag handler may have covered part of the small icons. This needs to be improved. Thank you!
Not sure what you mean. If you mean doing `npm install lodash` still gets the entire lodash library despite only needing one function from it, then you're over thinking it. It's not like we're talking about gigabytes of unused code sitting on disk. If it's that important then just do `npm install lodash.get`.
dawww
See the [Webpack Tutorials](https://github.com/markerikson/react-redux-links/blob/master/webpack-tutorials.md) section of my [React/Redux links list](https://github.com/markerikson/react-redux-links). Most of the articles there cover Webpack v2 or v3, but the vast majority of the content is still relevant for v4.
Use a strongly typed language with no null in main typespaces, such as Go, Haskell, TypeScript (only with strict enabled), Flow, or Elm.
I know you've solved you problem but I thought I'd throw out the alternative. A simple flatten function. They're quite fun and very simple. Just a bit of recursion. This one uses new syntax but the old fashioned syntax isn't much different. const flatten = (obj, prefix = "") =&gt; Object.keys(obj).reduce( (acc, key) =&gt; Object.assign( {}, acc, obj[key] === Object(obj[key]) ? flatten(obj[key], `${prefix}${key}.`) : { [`${prefix}${key}`]: obj[key] } ), {} ); Might save you adding another dependency to your project.
This is a band\-aid at best and a nightmare at worst. I got so mad at seeing this pattern all over a codebase I inherited that I wrote a blog post about it. [https://medium.com/@cvitullo/overly\-defensive\-programming\-e7a1b3d234c2](https://medium.com/@cvitullo/overly-defensive-programming-e7a1b3d234c2)
JavaScript is very weird compared to other programming languages. I think it requires a different kind of thinking from what you would do in python or java. 
start in the debugger console. making a class is fine. what is a calculator? it's the previous state and the previous operator, while also taking the next number. that's it. so, represent that - that's basically three variables - and pre-load it with a previous state of zero and a previous operator of `plus`. once you can use it in the debugger console, *then* it's time to make the user interface. stop tackling several problems at the same time. that makes things needlessly complicated.
start in the debugger console. making a class is fine. what is a calculator? it's the previous state and the previous operator, while also taking the next number. that's it. so, represent that - that's basically three variables - and pre-load it with a previous state of zero and a previous operator of `plus`. once you can use it in the debugger console, *then* it's time to make the user interface. using it in the debugger console means having methods on the class for each button. so you have a digit `9` button, not a "let's type in a number" method. stop tackling several problems at the same time. that makes things needlessly complicated. const calc = new Calculator(); calc.seven(); calc.plus(); calc.three(); calc.one(); calc.equals(); should echo something like "change display to `38`" once that's going, you're good to move on to the user interface
Okay, thank you. I was starting to have a bit of anxiety and question all knowledge I had in general.
Yeah, I suppose my biggest crux is always trying to tackle multiple problems at once, or thinking of the one problem in such a grand scheme without even understanding the grand scheme (lack of any planning in the first place)
Thanks for your reply. I had built a scaffolding cli tool before this, but that was not updated to webpack 4. like you said, people won't start project very frequently, it may not worth to use it. I would not like to update that tool. But there is another thing, I have eslint plugin installed. Every time I opened a javascript project, the plugin complains a config file. I can run a command to disable it, however, I decide to run a command to get a config file. That is why I made this plugin.
Is there a programming language that doesn‚Äôt do this? What‚Äôs supposed to happen? It just returns undefined for any chained properties if any piece of the chain is undefined? Other languages do have ‚ÄúSafe accessors‚Äù that act like that but it‚Äôs not the default at all. 
1) If you're just starting out and don't care about the book not having ES6, I would highly recommend* https://www.amazon.com/Head-First-HTML5-Programming-JavaScript/dp/1449390544 2) You're not going to find a book or course that teaches you introductory level stuff that also includes Typescript. You would be lost and clueless if you tried to learn a framework like React before learning vanilla Javascript, IMHO the best strategy is to find a learning resource that starts out with ES6. 3) You can use pretty much any language for back end and most of them will have helpful frameworks and libraries. Javascript is necessary for interacting with the DOM, so you have to use it for front end. *this is assuming that JS is your first language and that you're new to it.
If you're into video courses you might enjoy https://www.udemy.com/the-complete-junior-to-senior-web-developer-roadmap
Senocular? Like the flash god? 
Github, Twitter, YouTube 
If you're using Vue then just use a computed property with that logic in it: `return object ? object.property : null`. And reference the computed property instead. It will automatically update when the state it depends upon changes. This way you can just reference the computes property with `this.computedProp` or, if you are inside a template, `computedProp`. It might clean up your code, if you're referencing the same property a lot.
Are you making a Chrome extension? I don't think your background script will have access to the DOM directly \- you might have to send messages from a content script. (This article explains it well: [https://medium.com/@vanessajimenez\_85032/chrome\-extensions\-content\-scripts\-vs\-background\-scripts\-7bbd01f9dbe6](https://medium.com/@vanessajimenez_85032/chrome-extensions-content-scripts-vs-background-scripts-7bbd01f9dbe6))
If I remember correctly, background scripts for Chrome extensions don't have access to the DOM, so you can't do DOM manipulation there. You should be able to do this in a content script. https://groups.google.com/a/chromium.org/forum/#!topic/chromium-extensions/eFEw1Sfl7oc
I tried to write this but lost interest and gave up before I finished the inner function. I'm getting rusty.
_So. many. collisions._ Imagine a JS object/hashmap implementation built on this. 
I find them quite fun. Especially with the new syntax, default parameters, `Object.keys()`, `Object.assign()`, template literals, computed property names. This is slightly more annoying using just ES5 syntax and not nearly as fun.
Particularly a drawback is changing versions. You have to ensure you change the reference everywhere for every file you pull. You change a single line change in your package.json to potentially hundreds of files. The issue doesn't lie in the usage of a package cache on load it's the maintenance of code that uses external libraries.
I guess you could have used spread operator instead of object.assign too.
I've never worked with greasemonkey or FireFox extensions, so take this with a grain of salt if I'm wrong. * Your code refers to "hearth" and not "heart" (I assume English isn't your first language, no biggie.) * Maybe try to use ES6 declarations (let, const, etc) * Line 71: You can just use `count++` instead of `count = count+1` to increment. Aside from that, looks great!
I'm not sure, but as a non professional programmer it just seems like something that is much more of an annoyance than a convenience. I'd rather have it just return undefined rather than break everything. 
I can do that, just felt like there should be a less repetitive way. 
I'm not a professional programmer, but I just found myself checking for this so repetitively that I want the language to have a better way of taking care of it. 
This is a good point, and something I want to address. I haven't yet decided how I would - but storing references to the handlers in a map is definitely the approach I'm looking at.
Yeah, I actually used spread first but it was really cryptic: { ...acc, ...(obj[key] === Object(obj[key]) ? flatten(obj[key], `${prefix}${key}.`) : {[`${prefix}${key}`]: obj[key]} ) } You have to wrap the ternary in parenthesis and spread them, then return a new object to actually get spread when the condition evaluates. It was just impossible to read. 
This is the less repetitive way, you wrap any repeated functionality in a function of some description and use that instead. This only adds one line of code. You can't access references that don't exist sadly.
I want to walk on Mars. Please provide advice.
There are plenty of totp npms. Pick one.
Objective-C and derived languages do this by default (messaging nil typically returns nil, unless C structs are involved).
I think I‚Äôll try and have a play with this in the coming weeks. It looks fun :) Thank you for sharing your project!
If the thing you are trying to reference is undefined, execution probably \*should\* break.
u/ghostfacedcoder's example demonstrates to features: optional chaining (`.?`), and nullish coalescing (`??`). Both are stage 1. I think you are right that optional chaining is the most relevant proposal to the discussion here.
Yes I am. Thank you!!
Thank you!
It‚Äôs intentional, your app design should keep this from happening, rather than enter an unknown state by presuming a value Some languages have guards or other features, in JavaScript the usual way of guarding is `value &amp;&amp; value.prop`, using function selectors, deconstruction, or using tidy functions that help flatten an object into something more useful to your app (useful when you get an object from an API that‚Äôs rather large) In many JavaScript apps you‚Äôll simple catch errors and either allow them to throw or handle them gracefully with an error message Remember, it‚Äôs better to crash in some circumstances than it is to continue in a bad state
Wonder what the gzip value is? If that number is still double digits then I have a good reason to stick with Redux.
I write with a similar style, but I can‚Äôt stand in place ternaries for readability issues. I usually add a constant def named after the prop &amp; I drop it in as a property value shorthand, or in cases like this just spread an arbitrarily named const. const moarShit = obj[key] === Object(obj[key]) ? flatten(obj[key], `${prefix}${key}.`) : {[`${prefix}${key}`]: obj[key]} { ...acc, ...moarShit, } It may be a little pedantic, but I like to separate the work from the return for readability. Sorry to nerd snipe,‚Ä¶ just one of the things I like to waste my time obsessing over. 
I'm curious why you're doing this? If you need to access those values by path you could use something like https://www.npmjs.com/package/object-path
Javascript as a language isn't all that weird. It has some quirks, but it's converged a lot with Python. The DOM is weird and ugly, which is why almost no one tries to access it directly.
&gt; I basically spent maybe an hour trying to get the most basic function of a calculator to even work (and failing) ... and Python (It was my first and it's what I sometimes toy with when I have ideas) How would you write your calculator in Python? Let's start with something you know and then translate. &gt; What I was trying to do the whole time was put in a javascript file things like functions to get the sign in the buttons, and a class for the buttons and the calculator display. ... was I in the right to approach the problem like that from the start? Or is it possible that I need to find a new perspective to look at problems This isn't enough detail to answer that question. Can you be more specific or show some code?
And if you forget a semicolon, the language should insert one automatically, right? Lol! ...wait. 
[removed]
Wait a second, England is your city ? :) https://youtu.be/a-5VCZyAMz0
How's this relevant?
&gt; Instead it breaks the execution Then just catch it? function get(f) { try {return f()} catch (e) {} } get(() =&gt; object.property) 
If the API doesn't matter, here's a fun one: [http://thecatapi.com/docs.html](http://thecatapi.com/docs.html) You'll also need to learn about AJAX requests to talk to it: [https://developer.mozilla.org/en\-US/docs/Web/API/XMLHttpRequest/Using\_XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest) \-\-\- So here's a super\-simple tutorial: let's imagine that when you click a `&lt;button&gt;` , it'll display a photo of a random cat, from this API. So the HTML: &lt;button id="submit"&gt;get a cat!&lt;/button&gt; &lt;div id="image"&gt;&lt;/div&gt; Next, a click listener, which triggers a `function`: document.getElementById("submit").addEventListener("click", getCat) Let's use the code from the Mozilla docs: function getCat() { var apiRequest = new XMLHttpRequest() apiRequest.addEventListener("load", updateImage) apiRequest.open("GET", "https://thecatapi.com/api/images/get?format=html&amp;results_per_page=1") apiRequest.send() }) Above, I plugged in the API url with two options: the format, and the number of results. (The API itself has documentation for these options.) Finally, we need to put that image on the screen when the data loads: function updateImage() { document.getElementById("image").innerHTML = this.responseText } And that's it! Hopefully this shows you the basic pattern \- but every API is different, so you'll need to pick one and see how they let you do keyword search.
I've completed [https://www.howtographql.com/](https://www.howtographql.com/) and I can tell you that it is a great resource. It covers a lot of essential stuff with very nice examples. I haven't tried course from Stephen Grider but he is awesome tutor in general. He has 13 hour course that covers GraphQL (and React). Here's the link: [https://www.udemy.com/graphql\-with\-react\-course/](https://www.udemy.com/graphql-with-react-course/)
I have gone through the basics a bit. But when boiling down to the implementation side of things, I was overwhelmed by the number of options just to make a javascript server. Found no comparison of what works better in which scenario. Hence thought of asking everyone else
Probably, but why? There are specific CSS obfuscators that will mangle names, etc without having to do any sort of JS shenanigans. 
&gt;obj\[key\] === Object(obj\[key\]) I don't fully understand how this part works. If output of Object(obj\[key\]) is the same obj\[key\], then it is object? Could we use this check instead `typeof obj[key] === "object"`, or is there some catch to this?
Don‚Äôt bother with crap like this.
ES 6 is pretty straight forward.
You're totally right. I am currently struggling to decide which one to use on my personal projects too. There're too many options, and I think you can't really miss with either apollo or prisma. The good point is that the principles are the same, so even if your implementation fails you will always be able to migrate to another one without many problems.
Fetch it. fetch('API_URL').then( res =&gt; { return res.json(); }).then(data =&gt; { // Work with JSON data here console.log(data); }).catch(err =&gt; { // Do something for an error here });
I was just wondering if this was a known thing that people/companies do. Seems better than a straight up CSS obfuscator since presumably less people would know how to reverse engineer JS than CSS.
I'm not, purely theoretical question. I know that if someone wants to get your code, they will get it.
Technically Javascript is not a functional programming language, but it does have some aspects to it that allow you to work with it using an imperative, prototype based object oriented and functional style. Javascript is technically an prototype\-based object\-oriented language. I really like how Javascript allows you to program using different programming paradigms,
I just watched this video earlier today and thought it was great! https://youtu.be/nfmvexyoHX Plus, Scott the videos creator, explains things in a really great way. You might find his whole channel helpful! Good luck!
But why would you care if somebody could read your css??? We only use case minifiers to decrease file size.
You‚Äôd pay a runtime cost for this type of obfuscation, and I don‚Äôt think you‚Äôd really gain any more from it in the way of obscurity. Sucking out mangled names from a JS file might take someone an extra few minutes, and they‚Äôd still have the same set of mangled names as from one of the normal CSS obfuscators.
So is now Love that You guys are loving here, I love u, I love u up and down is it the correction that you guys are loving or the corrector... Lol... Just Joking... I love u too baby 
You Sir are a legend. Thanks!
You're the best! Thanks!!
Define "doesn't work". ``` let n = 0; let arr = []; n &amp;#37; 0 =\&gt; NaN arr\[NaN\] =\&gt; undefined ``` I'd say an receiving undefined is an acceptable value given an empty array. Another acceptable option is to assert the array has at least one item and throw otherwise. Another acceptable option is to check the length of the array in whatever code is using it an just not call the generator in the first place. None of these make the example any less correct.
What exactly would you achieve by obfuscating CSS? What kind of sensitive information do you put in there?? Please....
This is easier to understand at a glance as long as you know what `yield*` does, whereas even if you know what `yield` does, you still need to read the code carefully in OP and think about it for at least a brief moment to know what it does.
Finally someone who doesn't brag about not inventing my own algorithm when I clearly stated that I just wanna know how it works \+ I never said I wanted to actually use it somewhere. Thank you so much now I finally have an idea of how it might work.
I'm afraid my english and mathematics skills are not sufficient enough to understand it properly :( 
I know, I just wanna know how it works so I'm a bit smarter.. I'm not trying to implement my own process, at least not for a real stuff.
I use MD5 pretty often and several times I've put my hands on SHA too.
Ah, okay ‚Äî I can see that being less than fun. Thanks for the reply. Seems like there are ways to work around that if you're sharing deps between files a lot. (A `common.ts` file with remote imports that you include with a relative import in multiple files, for example. Or creating your own manifest by referencing remote imports via a single JS object.)
I'm dumb.. I know this but only in Czech (my mother language) Thank you
*I* don't care, but CSS manglers exist so someone must care? I was just thinking how pointless it is to mangle your css with how easy it is to recreate a layout from scratch using sass/grid/flex/whatever, and then i started thinking that surely if you wanted to hide your markup you would do it through fetch calls to something hidden on your back end and then rendering it all with template literal strings. take it easy guys.
I just wanna know how it works so I'm a bit smarter.. I'm not trying to implement my own process, at least not for a real stuff. 
No, I'm not. Why do you think I am?
Yeah I don't know what people are trying to protect by mangling their css. Realistically, it seems more paranoid than useful.
This is top quality dummy data :-P
As you become an experienced developer, you will wish more things would break immediately, rather than subtlety creating much harder to detect issues down the line because the language ‚Äútried to keep going.‚Äù
Are you using windows? Try having multiple windows open, grabbing one of them with your mouse and "shaking" it back and forth
Sadly, I made the mistake of just writing over my code rather than starting a new project. So I don't have the code I'd like to show.
&gt; Is "functional programming" just a matter of matter of being able to write functions that return values? Or is it something more than that? It's much more than that! Eric Elliot has [a great primer here on FP with examples in JavaScript](https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0?source=---------13----------------). JavaScript isn't a purely functional language in the same way that Haskell is, as it openly permits other programming paradigms, but it has a lot of the attributes of a functional language and can be actively used to solve problems when in a functional way when it makes sense to do so. Some great resources to learn more: - [Functional-Light JavaScript](https://leanpub.com/fljs) - [Awesome FP JS](https://github.com/stoeffel/awesome-fp-js) - [Professor Frisby Introduces Composable Functional JavaScript ](https://egghead.io/courses/professor-frisby-introduces-composable-functional-javascript)
in kotlin, 'object?.property' and 'object?.property?: 'no content' in js, i use a helper, getp(obj, property)
There are 35 languages in the wikipedia sidebar.
Hmm, all I am is a black screen with an exclamation point. Wrong link? 
I guess you could do it that way, by creating wrappers on wrappers but that doesn't make sense for modules like lodash or rambda. You'd have to reimplement the API to be able to use it cleanly.
Fair enough. The TS compiler has gotten stricter in multiple areas in recent versions. So a bad example, I guess, but that doesn't change that there are still situations where variables can have different types at runtime from what TS says they should have.
a changelog doesn't always give the necessary context as to why these changes were made what the benefits are and struggles during development. Usually blog posts cover these kind of things.
It‚Äôs both. OOP and functional. 
Yeah its more of a reactive approach, its fun to work with though!
I think there will probably be another one soon, this is more of an announcement post 
A bit off topic. I've done some web scraping on similar websites before and I noticed many elements have cryptic ids and classes, for example ```document.getElementsByClassName("v1Nh3 kIKUG _bz0w");``` I'm just curious how are these generated? Is it the work of a minifier that the developers use? Does it mean that every time the website is updated and build again, the ids will change and I'll have to edit my scraping scripts?
Czech version has only some basic information and is lacking the most important mart which is description of the algorithm itself
If he's missed the grunt/gulp train and writes jQuery - he will have no idea what a package manager is. Speaking from experience
Watch [this free series](https://laracasts.com/series/webpack-for-everyone), it helped me immensely wrapping my head around webpack configuration.
A functional programming language is any language where functions are first-order objects. That means that functions can be assigned to variables as you would a Number, String, or Boolean. JavaScript is therefore a functional programming language. 
The real questions are does it need to be 32 characters long, and if so, why? You also mention 'password' hashing. If this is for passwords or other sensitive data, it'd be better to look at a more secure function than MD5 - you'll still learn how they work but you won't fall prey to practices which are no longer secure or recommended. Always look to learn best current practices (or best future practices) rather than no-longer best practices. Do not EVER try to build your own hashing or encryption algorithms unless you're working towards winning the contest that decides the new de-facto standards every few years. With all that said, SHA256 produces a 32 character string (or 64 character if using hexadecimal due to the 4-bit vs 8-bit difference) since it's a 256-bit output. The following resources should give you insight into how they work; Spec: https://csrc.nist.gov/csrc/media/publications/fips/180/4/final/documents/fips180-4-draft-aug2014.pdf JS implementation library: https://github.com/emn178/js-sha256/blob/master/src/sha256.js Explain like I'm 5/ELI5 SHA256: https://www.reddit.com/r/explainlikeimfive/comments/1isiji/eli5_sha256_hashing/ Psuedocode: https://en.wikipedia.org/wiki/SHA-2#Pseudocode
I believe you're describing "purely functional" instead of "functional" languages
Functional programming is about *not being able to do things* that aren't function input/output or straight up expressions. So you're not allowed to use things that are statements eg. assigning a variable, mutating a variable, if/switch/for loop.
It's a hybrid language, like all mainstream languages have become. The only functional feature you don't get out of the box is lazy evaluation, and honestly even some "really" functional languages pass on that because it creates more problems than it solves.
That's pretty cool. I've been hiding things with adblock but will check your extension!
Probably not that much in your specific case. What do you want to get out of it? You pay for it in complexity and time, so is your return on it good? GraphQL is mostly useful for big relational or graph datasets that have to support many different kind of queries dynamically for various kinds of applications. So stuff like the Facebook social graph where it was designed for, with a million different highly evolving client apps. If you make apps where a Mongo type document store is sufficient you probably don't even have the need (or ability) to do the relational query stuff. GraphQL is just a standard, you still need something to make your api behave like that and run the queries. It might still be interesting if you have a framework that automates the request parsing and query building, so you can roll out dynamic api's really easily (and deliver more complex app because of it). But if you just serve your Mongo documents then why even bother. Some other things to consider: HTTP level caching isn't great if everything is a dynamic query, A simple REST api is far easier to make HTTP cache-friendly. If you want to optimize team member communication then you might consider a hypermedia REST variation like HATEOS (we use HAL+JSON). Then you can link everything right in the resources instead of writing API endpoint documentation. If you also link your input schema in the resources everything becomes self documenting (if you have a serialization library that can output itself as json-schema for example). 
To make it short JS is a multi\-paradigm programming language. A little bit of offtopic. For me personally it's a huge pain when I work with a dev who used to work with OOP and tries to apply the same approaches and practices in JS. It is sometimes so much counter intuitive and just doesn't fit JS, creates just unnecessary overhead in the code. Focus on the strong sides of the tool and use them.
As for documentation I love using Swagger and some nice HTML generator for it. Anyway, I think you made it pretty clear to me what problem GraphQL is trying to solve and I am very certain its not one I currently or ever had. It seems like something you would drop in when your project really starts taking off and you start hiring a bunch of people to work on it. Thanks for taking the time to elaborate on it
Old post but I was looking for stuff and I have answers to share. On my switch I launched the browser on google with a small "hack" (easy to find) then I googled my games and I tested them. So far it's 95% working, including gamepad inputs and touch screen. There is few issue like no sounds, some troubles with big games loading lot of files, but I assume this is kind of "browsers limitations" as you can find on iOS which are pain in the ass to deal with. But if we do a native app running an iframe or whatever, then these problems should be "minor probs". I will keep trying to push my games on Switch, few of them are really cool to play on this device, so I want (and will) succeed.
It can be. There's an O'Reilly book on the subject. 
Heya, looks like you‚Äôre doing okay with fetch requests and node, and probably don‚Äôt need graphql right now, which is nice because while setting up graphql in an application doesn‚Äôt have to be hard, it‚Äôs not like there aren‚Äôt things to learn. About it, basically you write a schema for your API (or use code generation for it, for larger projects,) then write (or generate) ‚Äúresolvers,‚Äù which are functions that resolve queries to pieces of data, across your database(s) and any other data sources your API relies on (which is where some of the magic is, it‚Äôll package all the data into one parcel to send over the network,) and then write the queries (and ‚Äúmutations‚Äù (and ‚Äúsubscriptions‚Äù)) on the client side. Which can be a real picnic. For my case, it‚Äôs totally useful, because I‚Äôm solo and building something more complicated than I have any business trying to code (please anyone, if you‚Äôre passionate about running and tech and want to join a startup, lol.) There are some tools from AWS (Appsync + S3 + DynamoDB) that jive with the tool from Apollo (Apollo Client) that make things a little easier if you‚Äôre okay being locked into the Amazon ecosystem, or you can go in a lot of other directions with it. A good place to start if you‚Äôre curious is definitely graphql.org/learn, and it is pretty interesting stuff. Best wishes!
Swagger is more of a practical enhancement to manage and generate information (like code, forms and HTML docs etc). HATEOS is more like a higher level of API design then basic REST, it communicates relations and actions and improves discoverability for clients. Hypermedia is very interesting to read about, google a bit, and find stuff like: https://stackoverflow.com/questions/36619122/should-you-combine-swagger-with-hateoas-hal-json-ld/36638986 (JSON LD is another standard like HAL)
&gt; it's fun to solve problems in a functional way with JS ~~when it makes sense to do so.~~ *...as often as possible because I'm not kidding about the fun part...* 
This is your moment :)
I understand that now. Thank you! That sounds like a good idea.
It is not especially in es6, tho it is implemented as functional by many people.
Some are even regenerated on pageload, it's better to use a library like jQuery and select based on element type and text content.
If you don't keep all your code in source control, you should get on that asap.
I think I actually even used that feature once or twice lol. Wouldnt say its essential though :)
Yea I didn‚Äôt put it together on how to use these with an existing code. But it was simple. You all are right. 
It's easier to grok when you consider FP as a subset of *declarative* programming, then ask yourself if you're matching that paradigm. I wouldn't say it's a "functional programming language", in that it's not intended to strictly only be FP, but it is a language you can do functional programming in. FP is often erroneously contrasted to OOP as its opposite. Really, it's declarative and imperative programming that live as opposites. While FP is defined as a subset of declarative, OOP is only _typically_ used to facilitate imperative programming, but it's not by definition an imperative approach. e.g. you can certainly define a class as one that creates purely immutable objects, and this is a pattern we see in some pretty popular libs (e.g. immutable.js). Such objects would make statements-based programming (in imperative code) impossible, and facilitate expressions-based approaches (in FP). e.g. `mutatedShopcart.add(pants);` vs `const updatedCart = immutableShopcart.add(pants)`. Even the backbone of FP in ecma -- the `Array` -- is a prototype-based class that provides methods. So for something to really be FP, ask yourself: am I running a series of statements to change a program's state (imperative -- **how** to do it), or am I expressing **what** it is (declarative) as a group of functions (functional programming). HTML, for example, is clearly a declarative language (since it only describes what your page is), though obviously not functional. The language is used by browsers to build the DOM. However, you could always use functions written in ecma to build your DOM, and if you do it declaratively, then that's FP. e.g. &lt;div class="foo"&gt; Hello, &lt;span class="bar"&gt;World!&lt;/span&gt; &lt;/div&gt; Is declarative, using the purely declarative language HTML. h('div', { className: 'foo' }, 'Hello, ', h('span', { className: 'bar' }, 'World!'), ), Is also declarative, using ecma, and functions defined to build the DOM. The end result of either is the same. Contrast with the above written in ecma using an imperative approach, and see how clunky an approach it feels like for something like building a basic DOM: const div = document.createElement('div'); div.classList.add('foo'); div.appendChild(document.createTextNode('Hello, ')); const span = document.createElement('span'); span.classList.add('bar'); span.appendChild(document.createTextNode('World!')); div.appendChild(span);
I would say that it at least doesn't use all the features that a fully functional programming language would have easily available, mainly stuff like static optimisation.
And this is why I feel like a stupid potato when I try to code in class-based OOP languages.
It's not that I don't have source control, it's just that with this particular little deal, I just straight up forgot to set up a repository. I blame being up til 8AM with no sleep. Speaking of which.
I feel you. I was planning on making a website with my own version of encryption and after getting through th e first chapter of Introduction to Modern Cryptography by Katz and Lindell, they flat out said not to do that for reasons of most people don't understand the security requirements to do so. But if you want a more in depth look at how encryption works, and you have a mature math background, that book would be the way to go. It really breaks down a lot of different encryption schemes. For the most part, a lot of them rely on the the bitwise XOR operator also called bitflipping. 
You'd be surprised how much of an issue going in the other direction is. Coming from an actual functional language to JS... I spend a lot of time wondering about all the blogs people write about "functional Javascript".
Agreed. I hopped on the Functional JS train for a minute, but I stopped when I realized I spent more time fighting against the language and making the lives of the people I worked with harder. Sure, functional concepts can be incredibly useful, but trying to force everything into [Ramda](https://ramdajs.com/) made everything suck.
There‚Äôs probably an algorithmic way to do this, but when I did it I gave up on that and created a big list of all the winning combinations (x) and kept track of the location of all of a players‚Äô pieces (y), running a loop through all of the winning combinations at the end of each turn with an ‚Äòif x[i] in y‚Äô test to see if they had a winner. It didn‚Äôt seem to slow the play down to do it that way. 
I write a lot of languages and I'm not having an easy time thinking of one where that doesn't apply.
I'm not smart enough/lazy to go for real "functional" languages. Though any time I stumble upon an article about them it fascinates me.
In math, 'Function' means something quite different to what it means in C, and it is this meaning that 'Functional Programming' intends... I think that is where you are getting confused.
&gt;To make it short JS is a multi\-paradigm programming language. I need to remember this, because it's a perfect way to describe it. I'm always grasping at things when interns or juniors ask me if JS is OOP.
This is a personal diary blog post that has no value on this subreddit.
If you create an object from an existing object it will be the same basically. Strings, Numbers, Booleans, NaN, null, undefined all fail this check. But you've made me realise that Arrays don't. Remember that typeof will return 'object' for object, arrays, and null. so we need to change our object check to account for arrays (I'm assuming the OP doesn't want to flatten arrays as well to `objkey.key.index: 'value'`). So we just need to check if that the constructor is not an array, instance of can be dangerous so we'll avoid that. obj[key] === Object(obj[key]) &amp;&amp; !Array.isArray(obj[key]) this is our new condition. We will make sure an object created with `obj[key]` is equal to `obj[key]`. Then we will make sure it isn't an array. This will prevent any array flattening, and leave them intact. 
Eh, callback hell prior to await has been harder to deal with than anything I've written in another language for me.
Yeah, ternaries are okay in simple cases but can get unreadable quickly. If/else blocks are definitely easier to scan. We're returning our work at several steps here though, we are returning the reduce, the assign and the inline ternary (kinda). None of which are explicit. You do need to understand how implicit return with arrow functions works to understand this (I personally prefer the implicit return), and the ternary doesn't exactly help. It is easy to see control flow in my example but it is definitely more difficult to read in general, I think this function is probably simple enough to get away with it, just. This is one of those examples where its 'clever' but not necessarily better (just like short circuiting) :P
I don't have the time to explain the code in detail right now, but here's the most efficient way to check if it's a winning move is the following. var boardSize = 4; // -1 is unplayed, 0 is player 1, 1 is player 2 var ttt = [ [-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1] ]; var checkIfWinningMove = function (rowInput, colInput, currPlayerIndex) { var col = 0, row = 0, dia = 0, rdia = 0; for (var i = 0; i &lt; boardSize; i++) { if (ttt[rowInput][i] == currPlayerIndex) { // Row row++; } if (ttt[i][colInput] == currPlayerIndex) { // Column col++; } if (ttt[i][i] == currPlayerIndex) { // Diagonal dia++; } if (ttt[i][2 - i] == currPlayerIndex) { // Right Diagonal rdia++; } } return (col == boardSize || row == boardSize || dia == boardSize || rdia == boardSize) ? 1 : 0; }; 
Sometimes, yes.... I've seen changes on Instagram classes twice, it is even commented on the code that this might happen. Anyway, I will try to update it as much as possible.
Yes, I'm brazilian haha Using var, let or const actually don't make diference, I just tryed to use the vanilla JS as possible. For some reason, count++ didn't work on GreaseMonkey... That's why I did this way.
JS doesn't have "classes" as used in most other OOP languages, it just has some sugar around its prototypical inheritance. When you write "child" in your OP, I think you mean "instance". Each instance does not get its own function for its methods, the same function is reused. The `this` pointer is assigned depending on how the function is called, so if you called `notifications[k].method()` then `this` inside the `method` invocation will be `notifications[k]` due to the way it was invoked, not because it has a different copy of the method for each instance. I would suggest you specifically read up on `this` in javascript, it doesn't work as you might expect coming from another language. 
+1
CSS media queries is what you want
Functional programming has many benefits. As such, seemingly all programming languages have added support for functional programming through lambda functions. This is a recent phenomenon--Java only added lambdas 4 years ago. C does not (and will not) add functional programming support, though it can be emulated with function pointers. 
No problem! I'm glad if people get use out of it!
Javascript in 2018 is more functional, than most of other languages. C has nothing to do with functional programming. It uses mostly procedures instead of functions. OOP with classes is not necessarily imperative, and it can be functional. It's just a way of structure programs. Modular functional programming has many similarities with OOP. In Scala they just merged both into one concept.
&gt;**5. i haven‚Äôt found sample projects or tutorials that match how i tend to work.** I found this one odd, given that our whole React codebase is built around Frost's atomic design principles! Before I read this I assumed Atomic Design was written specifically for React developers. So yeah, a lot of respect for Brad. Having said that though, I don't know how long HTML\-and\-CSS\-but\-no\-JS frontend people fill last. There are plenty of experts in HTML &amp; CSS that don't find JS difficult. Maybe at big companies where there's enough work to split out HTML into a separate role.
Holy shit I had a lot of crap on my home page. Thanks, man, I am giving it a spin!
https://imgflip.com/i/2bupka
JS is multi paradigm.
Count++ will work if you save the result to itself otherwise it's just a reference. A workaround would be ++count. It'll store to itself
Cool extension. In terms of source code repository, you should remove your IDE's .idea file from source.
Agreed! If you don't validate data at the IO boundary, you can end up with fields in objects you don't expect (or missing fields you are expecting) going through your code. 
Functional Programming is basically about programming following 2 simple rules: Use only immutable data structures (that is if you declare some variable, you never ever mutate it) Use only pure functions (that is, functions with no side-effects). Also the previous two rules are lies, but you don't need to think to worry about that now. Is Javascript a "functional Programming" language? A more correct to phrase that is: Does Javascript admits programming in a functional style? And the answer is, it depends. There are certain things that Javascript allows you to do in a functional style without much trouble: Lists That's basically it, just Lists (Arrays), Arrays in javascript are really powerful and their use in idiomatic javascript is pretty much functional, you have neat things built in like array.map, array.reduce and you can combine arrays easily two with +. However, there are also things that Javascript doesn't allow you to do easily on a functional programming style: Error Handling I/O (and we've failed TWICE at fixing this) Everything that requires proper type conditions. Every data structure that is not a list. Of course we could do all of those things on Javascript on a functional style, but it wouldn't be really idiomatic. 
You have all the capability to write functional JS, though the language doesn't really support you along the way. The lack of a decent type system and enforcement of pure values often contradicts with writing idiomatic JS. Being unable to rely on referential transparency gets in the way of thinking in a declarative and functional manner, although it can still occur through discipline. It's just that developers aren't typically known and heralded for their discipline. Check out some libraries like [Ramda](http://ramdajs.com/), [Sanctuary](https://sanctuary.js.org/), or the [Fantasy Land spec](https://github.com/fantasyland/fantasy-land) for some attempts to bridge that gap.
Java, for one
TLDR: You can do (some) functional programming in JS, but JS is not a functional language. ---------- As someone who used to write JavaScript professionally, and who currently writes Haskell and Scala professionally: No, it's not. The "minimal" feature you need to *do* functional programming is to be able to treat functions as data (i.e. assign them to variables, pass them as arguments, and return them as the results of other functions). However, virtually every language that exists today meets that definition. C/C++ can do that. Java can do that. Python and Ruby can do that. None of those are in danger of being called functional *languages*. Why? Because there's a difference between being able to *do* some form of FP, and actually working in a language that facilitates and supports you doing FP, and provides the sorts of features that let you use more than basic functional techniques. Here's an off-the-top-of-my-head list of features I look for in a functional programming language. **Sum Types** * These essentially let you say that something can be either one thing or another, *but not both*. You can think of it like an object with two fields, but with a constraint that exactly one of them must be set at any given time. (The idea scales to *n* different things, but two is the easiest to consider). * These are the bread-and-butter of FP in languages like Haskell and Scala. Virtually all non-trivial programs will make use of sum-types like Maybe/Option and Either. **A Strong Type System** There's a few things to look for here, such as: * Does every syntactically-valid expression have a type? * Does it have generics? * Does it have higher-kinded types? * Can I express something like 'A function which takes two arbitrary parameters, but the parameters must be of the same type'. * Can I put constraints on a function's arguments? e.g. 'The first argument must be a type that has an ordering defined for it'. * Can I put constraints on the *return* type of a function? * Can the compiler and/or run-time environment infer types? * Can it do inference on *return* types? * Can it catch most type errors before run-time? *Syntax* * Do I have a compose operator? * Can I define my own operators? * Are the in-built operators symbols, or language-level syntax? (e.g. can I say something like 'let x = +'). **Immutability** * Can I express that an identifier is immutable? * Is immutability the default behavior? * Can I make something that's on the *heap* immutable? All the way down? **Purity and Totality** * Does the language provide any guarantees or checks of function purity? * Does the language provide any guarantees of checks of function totality? (i.e. can it check if a function returns a non-error, non-null value for every input?) **Laziness** * Does the language provide a way declare that a value should only be computed if it is actually needed? **Currying** * Do I have a syntactically-nice way to do currying? (i.e. something better than nested 'return function()...' or the lambda equivalent). **Standard Library and/or "Standard" third-party libs** * Does it have the expected suite of higher-order functions (map, filter, fold, flatMap/bind, sequence, traverse, compose, etc). * Are these defined on *all* types they're valid for? * Does it have explicit types/classes for the usual category-theoretic concepts like Functors, Monads, Semigroups, Monoids, etc? **Ecosystem** * Do I have lenses and prisms? Are they syntactically concise enough to be worth the hassle? * Is there some nice formulation of Monad Transformers and/or Free Monads? * Do I have a good property-testing library? * Do I have good code-generation and/or templating tools? * Do most third-party libraries define the standard suite of higher-order functions for *their* data-types? ---------- Some of these are possible in JavaScript. Very few of them are *pleasant* or *elegant* in it. For that reason, I personally don't consider it a functional programming language.
This is an excellent question and I can‚Äôt wait for all the questions being answered completely.
I like you. 
Thanks dude.
No you shouldn't
Thanks for letting me know. It's gone.
Check out [lodash](https://lodash.com/docs/4.17.10) it's a very nice library for stuff like this myobj.someProp.imundefined.ohcool And say prop 'myundefined' might be undefined you can still retrieve 'ohcool' value safely with: _.get(myobj, 'someProp.imundefined.ohcool'); 
&gt; There are plenty of experts in HTML &amp; CSS that don't find JS difficult. JS is not difficult, it's as easy as any other programming language. What Brad meant here is how the React framework\* is hard to learn, as it brings along other new paradigms with it too (JSX, CSS-in-JS, ...), most of which are not standardized. React introduces all these things that it completely feels like a you are learning a new programming language. _\* I called React a framework here because you cannot do anything just by importing `react`, you have to also import other things that come with it like `react-dom`, JSX, router management, ..._
Personally, I use GraphQL for my pet projects. At work we use lots of REST and a bit of GraphQL. I use GraphQL for personal projects because I prefer the way it makes you think about your app. Due to the nested nature of relational data in GraphQL, i find it much easier to build the frontend when the data is presented in the way it is with GraphQL. Also GraphiQL is an amazing tool that rivals swagger, if you need a swagger replacement. I highly recommend using GraphiQL and also a package called graphql-faker. It's got a nice editor that I use to quickly get a prototype or design to prototype very quickly, can't recommend it enough
A nice answer to this question: https://www.youtube.com/watch?v=eetWam3nhoM
&gt; its all about getting stuff done ASAP. The don't - no need to complicate :).
Probably something like [CSS modules](https://github.com/css-modules/css-modules) which creates mappings on every build. So you'll likely see it change every time they release a new version/fix/etc. In general it's very risky to use it as selectors 
Stop. By saying that the only thing a language needs to be a functional language is first-class functions, you strip all meaning from what it means to be functional that it ceases to be a useful qualifier. 
&gt; I use GraphQL for personal projects because I prefer the way it makes you think about your app Are you refering to the tree like structure? I guess I already get that from using NoSQL databases. In terms of speed of development, would you say that you are benefitting from GraphQL overall? I feel like it would be much like TDD where in the long run you get massive benefits especially in huge projects but for finishing a project asap its just the wrong approach. Regarding caching, I havent yet built a project big enough to have ever needed caching but its good to know where its at. Thanks
In a tldr I guess my question would be "does graphql compilcate or simplify". So I guess I have my anwser now.. :)
You can actually block things which have any tag apart from "education". If you are using their api.
Please add a `package.json` so we can `npm install` the repository. Thanks in advance.
https://imgur.com/a/wWWpCUw Sorry
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/wPzfuW9.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20e0bqxws) 
Yes you should. Your Dev environment settings won't be the same as everyone else's.
&gt;Is GraphQL something I either use in every project or in none or does it also have its specific use cases? (To me it seemed like an all or nothing kind of deal, similiarly how you wouldnt switch source control software between projects but rather get used to one and stick with it) I agree with you there. I started experimenting with GQL last year and going forward I will always have bad feeling when doing a REST api. I mean I'll do it if someone pays good money for it, it's just not going to be very good feeling knowing that I can save a lot of work by switching to GQL. This does not mean you can't transition to it little by little. We currently do that for our production app and so far it works quite well. To you questions: 1. yes, it will validate your inputs, it will generate your documentation 2. yeah, but how do you resolve references to other collections? With GQL you can let FE request these and resolve them as needed. This works wonders in schemas where you have lots of references. 3. it is explicit. In REST you just hit \`/books\` and you get some unknown array of objects. Sure it can be documented, but it's extra work and it never stays in sync automatically. With GQL you define your query and it's very trivial to write a component which renders it, because you can exactly see which properties the book is going to have. 4. yes. For us it reduces the amount of big queries and instead we write more smaller queries. You should use Dataloader library or write your own "caching" mechanism. 5. if all you need is a simple GET ednpoint, then REST is slightly faster to implement. As soon as you start to implement POST and PUT request, you have to do much more work with REST than with GQL. 
That‚Äôs where you‚Äôre wrong
You obviously know that hash algorithms are used. So you question is not based on an ignorance of what algorithm it is, you even mentioned MD5. So why are you not reading any one of a hundred papers or tutorials or videos on how md5 or any simple hash works? This is like saying you want to know how to add but refuse to learn to count to ten. 
all hail the div xpath and attributes for web scrapping :D
Why obfuscate when a browser dev tool will parse it out.
Thanks for taking the time! 1. Does that come out of the box or is there another specification I must use? (like swagger) 2. What do you mean with "FE"? It seems like a life saver really, but I just have to ask about query performance, is that all up to me?Do I even have control over how GQL will query my db in certain situations like when a client is fetching data in a very weird way? 3. I see how that would benefit me. Seems pretty cool actually especially with automated documention 4. So you write a big query including ALL (or most) data and then GQL will smartly extract only the data the client is asking for in that particular request? 5. Its hard to see why, given that in GQL you have to do all the work necessary for REST anyway (db write/read commands)
Ok, thank you though! I was sure that jQuery is getting outdated, but I can't understand why! It's so nice and easy to use...
I have been looking for a youtube whitelist app... an app which lets me specifically choose what videos/channels can be watched on youtube. That would be immensely useful for kids on mobile devices.
Nice work! As far as minor feedback goes I recommend trying to keep your indentation levels lower to improve code readability. As a simple example you have: ``` function ttSetup(){ if(ttJson.showLoader === "true" &amp;&amp; ttJson.enabled === "true") { // do a bunch of stuff } } ``` Where you could have: ``` function ttSetup(){ if(ttJson.showLoader !== "true" || ttJson.enabled !== "true") { return; } // do a bunch of stuff } ``` You should also utilize helper functions if you find yourself getting indented too deeply. It takes some practice but usually results in easier to read code.
True to some extent. Promises allowed chaining ‚Äúthen‚Äù, the KoaJS framework used co library to make use of generator functions in a similar way to async/await. But these are relatively new things, generally callback hell was mainly introduced by poorly elaborated app design decisions. But again only to some extent, in the end one couldn‚Äôt avoid it completely. For me JS is the first proper programming language after 2 years of writing automation macroses on VBA for my financial department. Maybe that‚Äôs why it‚Äôs not as bad for me.
That makes sense, I can see this helping readability. I will definitely keep this in mind from now on.
If only for readability, this part should be moved into its own function. Btw would instanceof object &amp;&amp; !isarray work?
You mangle to make the size smaller, not to prevent it from being read. All frontend code is accessible by anyone viewing your site, so mangling is not a feasible security measure
But fundamentally, it is OOP language. Everything in JavaScript is an object. Even a function is an object of type `function`. It's just that thanks to C++ and Java people have a very narrow-minded idea what an OO programming language is today. Same thing is really an issue with people coming from Haskell or whatever. They have a preconceived notion that the only way to do FP is to ONLY DO FP which is not the case in any imperative language, be it JS or Python or whatever imperative language with FP features you pick.
I have been thinking of this while writing the extension, more for switching off entertainment channels the user is subscribed to, to allow the educational/whitelisted channels to rise to the top.
I Deno ¬Ø\(¬∫_o)/¬Ø 
This is what I reference for p5: https://www.youtube.com/user/shiffman/playlists?sort=dd&amp;view=50&amp;shelf_id=14
github: https://github.com/lusaxweb/vuesax Example: https://lusaxweb.github.io/vuesax/components/sideBar.html
Koa keeps claiming to be the future, so I really want to jump into it, but it just doesn't make sense to me on first glance like express did/does. What do I need to know to learn Koa? Why are there *no good resources* out there for it?
That's a very exclusivist way of defining a functional languages. Same like OOP definitions that exclude pretty much everything apart from Java, C# and perhaps C++. At the very least: * Standard library * Ecosystem * Your arbitrary definition of Currying which is possible and elegant in JS * Purity -- itself only really required for a "purely functional" language Etc. Heck, I doubt that Lisp or Scheme, the daddys of Functional languages would meet all your demands. Also I don't buy the requirements of Immutability and Strong Typing as baseline requirements for a FPL at all. While useful for today's mainstream FP programming style, there is absolutely no fundamental reason for them to be there any more than there is reason that an OO language supports inheritance. Don't get me wrong, while JavaScript is a language with functional features, I do agree it's not a FP. But the list is long, exaustive and arbitrarily excluding.
Slogan: I Deno! Logo: ¬Ø\\\_(„ÉÑ)_/¬Ø
That would be great üò±
Right, but that's something that can be explained after saying it's a multi-paradigm language. I've just never thought about just explaining it as a multi-paradigm before. I'm not sure why.
[removed]
Yeah, there is a lot that could be done with a function like this to improve readability. The problem with `instanceof` is that it can fail when you're passing objects from one context to another. Essentially `instanceof object` when run in the browser really means `instanceof Window.object` so if you're passing things from/to different contexts (like across frame/window boundaries in the browser) it will give unexpected results. For simple cases when you have full control/ knowledge of all of your references and contexts then it is a perfectly valid way of doing it. I tend to avoid it because I try not to make too many assumptions in my code about the execution context. Checking the type of something in JS can be really tricky, the simplest way is probably to check the constructor: Object.prototype.toString.call(anObj).indexOf('Object') &gt; -1; or anObj.constructor.toString() === Object().constructor.toString(); or anObj.constructor === Object ? true : false; These methods will essentially work for anything that has a prototype (so not for primitives).
To be clear, I don't think you need every one of those things to be a good FP language. Scala doesn't have everything on that list, and I'd certainly say it's a functional language (or at least, it can be used as one). I'm also not saying JS has none of them. Currying, as you point out, is actually fairly nice with fat-arrow syntax. (Compare, e.g. Python, where nested repeated lambdas are hideously ugly). However, the combination of all those features I mention (i.e. Haskell) is *incredibly* productive. At the company I work for we have a full team of devs writing Haskell, and we find a production bug maybe once every 3-6 *months*. And the degree to which the base library and the ecosystem are de-facto standardised means that once you get passed the initial learning curve, Haskell's a very collaborative, communicative, and concise language.
well sorry to break it to you but the new best practice is to use proper classes vs instantiable functions in js (at least if you're looking for something class-like and if you use babel or don't need a ton of legacy support, though I'm probably missing some reason one might still want to use instantiable functions)
1. out of the box. 2. FE as frontend. You can inspect the query before you run it and also while you're executing it at each resolver. You can reject it upon any arbitrary condition. Popular and simple approach is to limit the depth of GQL queries because it would be trivial to write huge query and DDOS you API. 3. this is a lifesaver for me personally. I have attention span of a kitten, so I need constant reminder of what I am working with so in this regard GQL is indispensable. 4. it's not very memory efficient 5. you're right it seems like similar amount of work. Only when using graphQL you write your schema and you're done. Anyone calling it will get nice validation messages in a standard format. With REST you need to write a JSON/joi/whatever schema and execute it manually on the endpoint payload. You also have to make sure your body parser middleware is plugged in. When the validation fails, you have to make sure you return the proper HTTP status. You have to form some response body. All of these things you do in REST are very well defined by default for GraphQL. All you have to do is plug it in.
&gt; I‚Äôm very excited about Ryan Dahl‚Äôs new project because it is a step in the right direction. Chasing the dragon of bleeding edge burgeoning web technology is a strange game. Its all hype. Frequently, it leads to sadness. I am reminded of the words of Joshua. The only winning move is not to play.
Seems like once the browser has decoded and interpreted it, the browser could just print out a new, clean CSS output.
The site looks very welcoming and comfortable to read!
Bootstrap is a handy tool for making the kind of responsive layout you describe. An example showing the menu behavior is here: https://getbootstrap.com/docs/4.1/examples/navbar-static/
Ah geez sorry, copy/paste fail. Fixed it!
&gt; A Strong Type System Sorry, no. this is just wrong. https://en.wikipedia.org/wiki/Functional_programming My criteria is that there is no type system. Therefore I dont consider haskell or scala viable for FP becuase they have too much type nonsense, and you end up having to write so much unreusable code.
Its fairly true, because functions have to be members of a class. They arent quite first class objections. In java, only objects are first class citizens.
i think non-hot observables work like somewhat lazy evaluation - at least they give the most important benefits of it without blocking. Completely lazy evaluation is a nightmare, imo. It makes it much hard to understand sections of code out of context.
&gt; at least if you're looking for something class-like I don't 
btw you can see the implementation of any of these algos if you look them up. Here is SHA256 in javascript: https://github.com/geraintluff/sha256/blob/gh-pages/sha256.js
&gt;prototype based object oriented and functional style Off\-Topic: thanks for stating that. I die a little every time somebody calls JS "not object oriented", because it uses a prototypal inheritance mechanic; those people are clearly confused about what being OO really means. Hell, JS even models booleans as objects with their own prototype.
I'd like to commend you, you realized a pain point in development and put in a lot of work to come up with a solution. Take the other comments not as negative criticism but as points you can improve upon.
I think it should be [3 - i] in the last if statement. But also OP wanted to be the winning condition for 3 in a row, not 4. So in that case I think the easiest way would be to just check the neighbouring fields of the last move and see if there is 3 in a row.
vue
Don't choose any!
What is redux's file size?
Coming from C\+\+ my main problem was weak types, the lack of OOP features. While it's improving, I hate the lack of feature and keywords, It feels like hacking and defilled when I try to create Interfaces and Abstracts, private variables, etc...
Just re-arrange node js into deno ts and use blue instead of green color while keeping the hexagonal style of the letters. I don't think there's a need for a new unfamiliar logo that doesn't relate to node in any way.
~2kb min + gzip. 
Arrow functions are not currying. I'm not really sure you truly understand what **currying** means. Currying is partial application, and is implemented using second order functions and/or `bind` keyword (for partial application on bound object, i.e. "escaping" object/state-bound form to a functional-seeming form where the prototype owning object is bound by partial application i.e. currying) in JavaScript.
Thank you! I will check that out.
https://www.flickr.com/photos/ramella/352882166/
So many long answers, so much wrong. At its core, functional programming is using pure mathematical transforms (functions) which operate only on their parameters (e.g. do not mutate external data or create side effects) and return a value. That's it. JavaScript is certainly a functional language. The rest of this thread is a giant No True Scotsman fallacy as far as I'm concerned. Many of the things listed here are not essential attributes of a FP programming language but common things that exist in many functional languages, and things that functional programmers will often benefit from.
Interfaces are not OO concept. Self doesn't have them. Smalltalk doesn't have them. Ditto Abstracts. You people are just bigotted. What you learned OO means is not what OO means. OO is about declaring actvie state objects and means of message passing between objects. This is in shor the base OO definition by people who invented it Classes and inheritance are not the requirement at all. https://en.wikipedia.org/wiki/Object-oriented_programming
You are right in the same way a stone axe and a gun are both weapons. I could compromise by saying *modern OOP*.
I think not being related to Node is the whole point of it (watched Ryan's talk)
Chrome extension maybe? Do you have access to the map data?
JSX is the smallest dsl of all the existing options. Because it is not a template or a new syntax --- it is merely a superset, like TS, only that it revolves around a single function signature that boils down to pure javascript. This makes React so easy to pick up, because it isn't a framework that you learn, you learn a small handful of semantics and get going with the knowledge you already have. I saw some posts on twitter where Brad didn't know what =&gt; meant, or a ..., or { [x]: yz }, thinking this is React. He is clearly not experienced in javascript. 
Let it choose you! 
The language has the OO features available if you're dumb enough to use them. That's different from saying its an "OO language". I'll never write OO again.
nedb
It‚Äôs not true in any meaningful sense. I can define a function and assign it to a function object. So it‚Äôs an object that‚Äôs a function. And you just said objects are first class citizens, so.
Very cool, when you gonna do for Firefox? 
This is the best reply in the thread... nice write up!
Looks great for the client. Is there a way to sync it with a server?
Working out some minor bugs right now. As soon as I work them out, I'll get it over to Firefox. 
Chrome extension as /u/krolyat mentioned, or a userscript using Tampermonkey or Greasemonkey. 
That's a matter of opinion. Many people find it confusing when return statements are not at the end of the function.
I had never heard of css manglers, so I doubt many use them. You could do stuff lik this, but don‚Äôt.
Not technically related, but related when it comes to the solution for a problem, they're both targeting the same audience. The talk gave the impression that deno is like a node done right, and you could translate this into the logo itself. If you design logos (or graphics for a product) it's usual to keep the audience in mind. Isn't the audience node users who want something similar without the pitfalls?
Considering he named the project deno... I disagree
&gt; Does javascript have math-like Functions - no. What do you mean by `math-like` functions? Wouldn't that just be _pure_ functions that perform some algebraic computation?
Yes
Let's break this down a little. What do we mean by `victory`? You say it perfectly: three of the same value either horizontally, vertically, or diagonally. So all we have to do is write some functions that check for each of those, given a board: const horizontalWin = board =&gt; { /* some logic */ } const verticalWin = board =&gt; { /* some logic */ } const diagonalWin = board =&gt; { /* some logic /* } Now, each time there is a move, we can do a check const horizontalWinner = horizontalWin(board) if (horizontalWinner) { /* we have a winner! */ } const verticalWinner = horizontalWin(board) if (verticalWinner) { /* we have a winner! */ } const diagonalWinner= horizontalWin(board) if (diagonalWinner) { /* we have a winner! */ } You can make it smarter if you want but those three should get you an answer with little overhead.
Then how is `f = x =&gt; x + 1` not a math-like function?
It is but you wouldn‚Äôt get an error, or a warning if you wrote f = x =&gt; f(x) because JavaScript is indifferent to whether you write pure functions, because javascript isn‚Äôt a Functional language. You may get Milliage from pretending it is. No one is saying you won‚Äôt, but it doesn‚Äôt want to make it so. I like to pretend it is Smalltalk.
I will try it out soon... For now, I tried Hopscotch and it worked quite well! pretty easy integration into my application and has fallback option if an element on a tutorial step isn't available.
If you find one please post to r/cheetsheet. Thanks!
Thanks for the detailed reply. I guess it means even more that this sort of test should go in a library somewhere (internal or external), as testing for isPlainObject is really a can of worms with non-obvious solutions.
That's not the only criteria for a functional language.
You could also start creating one... sounds like a great opportunity to shine!
Can you be more specific about what you're trying to accomplish?
Since comments below have devolved into an OOP vs FP debate, I'm just going to chime in my two cents. I tend to write JS as very declarative. Object literals (let abc = {}) and function variable are the code of what I put together. I generally prefer a functional solution (ie, Array.forEach() vs for-loop), however I will always use whatever approach best fits the situation. I will at times pull out the old OOP approach, building constructor functions and prototypes and setting up inheritance, but only when there is a genuine need for it. I tend to define a genuine need for if I'm instantiating the same object in multiple locations in my code, and I always really, REALLY need it to have the same signature. I find this helps reduce some errors. Overall, FP and OOP are neither the end all be all of programming. I prefer declarative coding over imperative, but that doesn't mean that there aren't situations where I'll take the imperative approach. It's always just about the right tool for the right job.
Yeah. Things like this are an ideal candidate for moving out into a helper funtion/ library.
Vue got the short stick here. This really sounds like it was written by someone who hasn't spent a ton of time with all of the frameworks being written about.
yeah well in lisp functions have to be a list. how functions are represented doesn't qualify or disqualify them as functions.
I‚Äôve only ever programmed for the web and have always wondered, is there a DOM equivalent for people who are creating regular desktop/mobile applications? 
new best practice = latest babel compiler whizbang
What happens when the array you are destructuring and the variables you want to get from them are not defined in the same place? This isn't really restructuring it's just squeezing multiple definitions into one line. The point is to be able to more easily set variables based on the indices in an **already created** array.
I use java8 closures and method references extensively. They are simply much more limited in what they can bind and how they can be called. for example: the lack a convenient generic way to store them without knowing their type or purpose, because they have to be materialized into an interface for declaration.
You aren't considering how this interacts with the rest of the language, you're only considering the variable definition case, specifically you're turning: const foo = [1,2,3] const [bar,,wibble] = foo into const foo = [const bar = 1, 2, const wibble = 3] (why did you use a picture rather than just text??) which only works in the least useful case for destructuring assignment: an array literal. If you try to manage a non-literal type what happens? Specifically take: const foo = someFunction() const [bar,,wibble] = foo You cannot use your new syntax for destruction in this case, so you're literally adding new syntax that can only be used in one place. There's also functionally the syntax you're requesting: const foo, bar, wibble; foo = [bar = 1, 2, wibble = 3] Which I hope also illustrates why this isn't useful as a "destructuring" syntax.
I'm saying you can make a global function. How would that get bugs with a variance of functionality? It's the exact same thing just without having to use the whole library.
Yes, I mean why bother installing an entire library locally when all you need is one function. Just put that function in your code.
Fair enough. I interpreted your statement as a general statement and not necessarily to this specific instance. 
FWIW I would much rather get my hands on it sooner while in early development... software is never finished so if your intent is to open source it why not just throw it up on github now?
There are some files in the idea folder that can be synced. Some gitignore generators have configs for the right files. 
Oh, I see. I think the better option is just to learn all of Lodash, because it's a great library though.
When creating a library and hoping for contributions this is true. Not so when you work with a team and would benefit from sharing the config. I check in the `.idea` directory most of the times 
Did you try looking around at anything? Or did you expect people to hold your hand all the way through. I'm sorry but this is just such a wide open ended vauge question. Themes are made in CSS, so you don't know what JS and CSS are it seems. Look it up on google, then youtube some tutorials on basics of how these work in the browser with HTML. Do you have a website? How did you make it? Because you'd have to use CSS &amp; JS/Php for that and then you'd already know what making a dark theme entails. I'm just really trying to understand what is it you want to know.
He might be wondering how one would allow the user to switch themes/stylesheets
I'd go about it by having a dark theme button on the page and every thing you want changed will have a class added to it through JS. Those added classes would have all the CSS they need already written and Tara. At the click of a button you can toggle between adding and removing the classes.
That way you'd download the dark theme too, I would change the stylesheet completely with JS and save the option with localstorage.
So I'm about a year in with JS and have built all of my websites (static) with html css and vanilla js but have yet to pick a framework. Am I holding myself back by not using a framework? 
Hi /u/Boosted_Edits, For javascript help, please visit /r/LearnJavascript. Thank you!
Change the classes using js on a button toggle; again it's so vague and open ended you'd also have to set a cookie or server side auth for keeping the dark theme in every page
Hi /u/CrazyCabster, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/Mbedner3420, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/Morganja95, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/hcir614, For javascript help, please visit /r/LearnJavascript. Thank you!
If you have IntelliJ generate a .gitignore for you it includes the .idea folder.
Hi /u/KingDionWaiters, For javascript help, please visit /r/LearnJavascript. Thank you!
tldr; use w/e you want, they're pretty neck &amp; neck as of npm5
i've got to admit vue at least got the most vocal supporters on reddit. if you only went by recommendations from reddit, vue would seem to be used by 90% of all js devs 
Hot-Tip: For android you can use NewPipe for shit-free youtube experience and play while your screen is off or you're in another app, instead of buying youtube red.
Yeah I've seen XOR in like every algorithm :D Thank you
But I don't wanna know the WHOLE GODDAMN ALGORITHM but just that tiny part of converting any given string to a fixed length one.. that's all.. I mentioned password hashing because that's the only case where I know this thing is used.
Thank you so much. I'll read all of it.
wait, Apple Maps is still a thing? haha.
Where‚Äôs the ‚ÄúReact is a library!!!!!‚Äù guy? 
Oh, I‚Äôm sorry, I‚Äôm not really benefiting from sharing my settings with the rest of the team. Why would you argue that I have to do it your way after I clearly stated its useful to me and my team?
You can just pad/truncate a string if you want it to be fixed length. You have submitted a series of questions in which you indicate you are afraid of learning how to do things correctly, and many of them on a cryptography related topic. You are either trolling, or about to do something truly horrific as you attempt to shortcut learning how to solve problems correctly. 
The write-up on Ember looks kinda generic as well. I'd be interested in knowing how many projects the author (s) completed in each framework
At this rate and trying to search for one, I'm considering it. I'll get back to you on that for the next week or two. :D
Hey hey hey 
You should probably read this https://medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3 Make sure you follow up on the other articles from that guy ;)
What settings are you trying to share that isn't covered by editorconfig?
What is wrong on wanting to learn just a part of the whole solution? Like for learning how let's say communication between server and client do I have to write an exact copy of facebook or study the whole code? Obviously not, I'd want to see for example AJAX snippet. The same thing applies to my formal question. I wanted to know how to know how to make a fixed length string. Not the whole crypto hashing algorithm. 
Because that is not even part of the solution.
I'm here too. Finding freecodecamp basic algorithm scripting extremely challenging. I'm moving forward but feels like a snails pace. 
&gt; So if I ever have "this" in the static function, I know it refers to another static function. Well, at least one person will know what you're doing... ie, don't use `this` in a `static` context because it will just confuse and likely piss someone else off. 
haha
Sorry I just realised how weird my question is. My website is made in HTML/CSS and I'd like to make an option (with a button or something) for a dark theme. Because the site is mostly white. I have no clue what I have to use though. 
Hey hey hey
did you just pretend people using iPhones and Ipads don't use maps? LOL
I only use Google maps on my iPad 
That initial release was so disastrous, the world at large still feels Apple Maps is useless. Is it? I wonder what benefits they have to offer here, other than "it's Apple's".
I think I got some extra points during a technical screening recently for pulling out the Symbol key approach, after the interviewer asked if I was familiar with the naming convention of leading with an underscore to indicate a property or method is private.
I just figured they had abandoned apples horrible maps program and moved on to Google's.
It's not just reddit. It seems to be the dark horse in the industry. It lacks big corporate backing like angular and react which limits it, but it grows in popularity .
‚ÄúMapKit JS beta provides a free daily limit of 250,000 map initializations and 25,000 service calls.‚Äù That‚Äôs pretty good...
oh, thank you! I didn't know about this subreddit.
People on iPhones and iPads use Apple Maps like people on Windows use Microsoft Edge.
Depends on how complicated what you are doing is. If you're just doing static websites without excessive dynamic content and no desire to make something like a Single Page App, then yeah you're good. For larger and more complex projects, they are really very useful. The main difference between Vanilla JS and JQuery, and the new frameworks, is the paradigm of how we code. The change is in two main ways: code structure, and DOM manipulation. For code structure, Vanilla JS and JQuery stick to the old style of large, monolithic HTML/JS files. Yes, you could choose to split it up if you really wanted to, but that would add some extra complications in how you write your code, dependency management hell, and would cause your page to have to make extra calls back to the server to load everything. With a framework, you're instead writing code in smaller components, which are then assembled into your production page by an extra compilation step. This leads to source code that is spread out across many small files, which makes it much easier to maintain overall. For the DOM, with Vanilla JS and JQuery you're doing manual DOM manipulation. Every change you want to make to the HTML, you are explicitly writing the JavaScript code to make each and every change. This can be very tedious, in fact I don't think you realize how much of your coding time you spend on this, until you try a framework and experience life without it. With frameworks, it's all about binding. Different frameworks approach the binding differently, but fundamentally it's about writing your HTML, and then linking it to the JavaScript. As you manipulate your JavaScript code, the HTML automatically updates. Not only is this easier on you, the developer, it is more efficient as the frameworks optimize the actual changes to the DOM. Anyway, this was a wall of text, way more than I planned to write. But this is a basic overview of why people use these frameworks.
Except for the little issue where npm was destroying servers and cross-platform incompatibility with package-lock.json. Other than that it's pretty even.
I totally get your point. I wrote this comment in the context of beginners. If you are a beginner then you can use Create React App to get a setup ready to go. However if you want to start your react project from a simple npm init then you are probably a pro. Also how is NPM a complex tool? I get it for Babel and Webpack. All I have used NPM is for npm install package-name. 
the latest ecmascript whizbang... not babel specific
that was only true prior to Java 8
semantics... everything higher than assembly is syntactic sugar to someone, and declaring instantiables as classes provides methods more suited to the usecase, restrictions to help keep you from shooting yourself in the foot, and generally distinguish between functions which are usually stateless and do a thing, and classes which are usually state full and ARE a thing instead of just DOING a thing 
purely functional != functional. It used to be a useful qualifier, but the utility of functional programming has brought first order functions to many languages.
Why do you say that? In my experience, the type system rarely forces you to duplicate anything. I actually end up writing more DRY code than most languages, because the types give me good guarantees on the safety of my genetic code.
Many people, but probably not experienced ones. There's a good reason why there's the saying "Return early, return often".
If you're not making reusable code in haskell, you're doing it wrong. Haskell has type classes for generics and supports the standard functional type-agnostic operations--map, filter, reduce, etc. Haskell is literally only functions, and therefore the most extreme FP language
The limits are much more generous than Google's.
I am suggesting this little script I wrote [https://github.com/webdev23/reddube](https://github.com/webdev23/reddube) But, does anyone maybe knows a way to load a new video in youtube by script? I already ask stackoveflow without succes :( [https://stackoverflow.com/questions/49138693/change\-youtube\-video\-id\-without\-page\-reloading](https://stackoverflow.com/questions/49138693/change-youtube-video-id-without-page-reloading) 
Most iPhone/iPad users use Google Maps. Aside from having a much worse database for "places of interest", Apple Maps' quality also dips much lower internationally, and I can't even voice search for places in my country, which matters when you drive. Apple Maps also is much slower to update itself internationally when a road is close, or a new one is opened etc. There is no up-to-date information on traffic conditions, road repair etc. I'm sure most of this doesn't matter if you're in a big city somewhere in a big country. There all the maps work fine. But most of the world isn't a big city in a big country.
https://bundlephobia.com/result?p=redux@4.0.0
I personally hate those programs that pollute my project folder. This include: git, vim.. 
Sure... but the primary value of having maps on your site is so people can tap the map and it opens their native app for this location. Which on Android is clearly Google Maps. On Windows is again the Google Maps site (as Microsoft's Maps app is kinda spotty) and on iOS devices... is again Google Maps as most iOS users use Google Maps.
Clearly, it can. But writing it this way is messy, and really does matter if your are working on a huge project with multiple developers. It apply to php as well, which is a beautiful language when we work alone on it, and horrible in team. This is why I like them both\^
[removed]
Scopes, as describes here. Custom tools. Jira integrations. Test runner configs. External libraries. Inspections. Custom templates. Code style. A person joining the team doesnt have to figure out all of this on their own. Its not a bad practice. Its just one that doesnt fit most of the situations, but it has its valid uses. 
Are they? Google Maps: - 2,000,000 free requests per day. - Queries per second (QPS) is unlimited. Apple Maps: - 250,000 map initializations / views per day. - 25,000 service requests.
I'm not going to try to convince you; those debates are endless because everyone has already made up their mind. I find that types are pure burden and baggage and add nothing but toil. (machine types in C or asm are fine) Let me just observe that haskell has 5 different types of string class, and that doesnt feel awful dry to me. I love FP, but hate and despise static type systems.
First of all, a first order function is just a normal function. Secondly, it makes sense not to call JS a functional language despite the fact that it can do a bit of FP. e.g I can can cook, but badly. I don't call myself a chef. I may call other people chef's, mainly because they're really good at cooking. 
This is excellent, thank you!
Google Maps only allows 100,000 instatiations per month on the free plan.
If the article is going to include the number of github stars, they should include numbers from Angularjs V1 and Angular the latest. The numbers are: 58.5K and 39K
To someone who only has a hammer everything looks like a nail.
I really have absolutely no idea why anyone would think that committing templates, test configurations, and external libraries into the .idea folder is anywhere close to a good idea. Honestly, if I joined a team that was doing that it would be a massive red flag that the team has no idea what they are doing and I'd probably quit on the spot. The .idea folder stores things like what files you have open, your navigation history, and your run and debug configurations. All of this stuff is really developer specific information. It's incredibly frustrating to me to have my set of open files change every time I pull changes from other developers.
I mainly develop on win10 and yarn sucks. I even bought a udemy course and the course was full of additions throughout for how to "fix" problems with yarn by using npm. Might possibly be a windows problem only because I can not get it to work properly for me without having to fall back to npm once in a while.
You sound like you haven't used Apple Maps since 2012.
You can, however, view the contents of a WeakMap using chrome devtools 
Yes, and focus to use it this way, because the language itself is now so complete, that we can do in 500 lines what required 300kb of libraries and 2000\+ lines! 
Obligitory [beware](https://www.reddit.com/r/javascript/comments/6q2lk0/why_composition_is_harder_with_classes/dku34cl/)^1 [referencing](https://www.reddit.com/r/javascript/comments/5c5lkq/what_eric_elliot_wants_to_say_can_somebody/d9u6tv3/)^2 or [learning](https://www.reddit.com/r/javascript/comments/837t82/who_are_some_of_your_favorite_speakers_educators/dvh0br6/)^3 from Eric Elliott.
Mapping data is fine, and mostly always has been. Business information and search is still far behind Google and probably always will be. The best stuff on Google Maps has search behind it and it‚Äôs kind of hard to compete with that. 
It's a technically ideal solution, but but in practice verbose and with lower performance... so you're better off using underscore, or something like TypeScript to track property visibility for you.
Uneducated dogmatic arrogant hyperbole.
thanks for catching the first part. However, I disagree with the second part. If you can cook, you're a cook, but that doesn't mean you're a professional chef or that you can only cook. Everything I have read, both in school and in wikipedia, make the distinction between functional and purely functional. A purely functional language is like a professional chef. C, and most mainstream languages a decade ago, can't even cook. Just because cooking has become popular doesn't change the definition of cooking.
I want to **kiss** whoever invent **querySelectorAll .** 
I've given up on formatting, and I've resigned myself to Prettier. It's been a good way to empty that part of my mind from development, even if I don't agree with all it's style choices
Oh hell, I'll agree with you on the String thing - that was a screw-ups on the language authors' part, and it's unfortunately too "legacy" to fix it now. To be fair though, the 4 "good" string types are all useful for different things.
Can't agree more than that. We don't need, only maybe for components, but certainly not a full fancy toolbox that can cook noodle too.
1. Doing web dev. 2 Not using *unix based system (yes this includes MacOS) Not to bash you /u/Lindenforest but to all engineers who aren‚Äôt writing priority M$ languages why stick to an OS you have to fight to complete the most basic of functions?
What do you want do? 
I am cooking noodles with idontneedit.js
Yes, plus I am pretty sure the number of queries per second is not unlimited, unless it is different than a year ago.
Currently, I would like to build a data-driven web app for a landscaping company. But ultimately, I would like to master JavaScript and transition from freelance into a full time full-stack position. I was of the mindset, it's better to master JavaScript first and then pick up a framework later but I'm second guessing this approach due to people telling/pressuring me that it's better to learn the framework first and then the language. 
Okay so, I wouldn't myself a cook, if I could cook. I think that's a word only reserved for people who can cook well. This may be where our disagreement over classification stems from. Secondly, I'd cite [this comment](https://www.reddit.com/r/javascript/comments/8phlen/comment/e0bn0zp?st=JI6JYYLQ&amp;sh=db1cd3b3) from this thread describing what a functional language is. There's a distinction between what the language forces you to do, what it can do *easily*, and how it is used. Like Haskell, forces you to do pure FP, can only do pure FP easily, and is thus used in a pure FP manner. Scala meanwhile, is multiparadigm, can do pure FP somewhat easily, and is used in a pure FP manner by a non-trivial portion of the community JS is multiparadigm, doesn't make pure FP easy, and is almost never used in a pure FP manner. Aren't the qualifiers I specified a more accurate description of what is and isn't FP? Just like it doesn't make sense to call every language high-level, sometimes definitions have to shift to account for modern language developments. 
Very buzzword, much trendy.
Java 8 added sugar around creating objects that represent functions, but I definitely wouldn't call java a "functional" language.
http://kintojs.readthedocs.io/en/latest/
This is not even destructuring. Const declarations as expressions. I would really like JS to be more expression oriented, but it's not happening soon enough.
Just a hype driven community. Waiting them to cool down and stick with react.
1. Because for most of my work (at least the one that pays the bills) I need programs/editors that only run on windows. 2. I have been able to work perfectly fine in nodejs and running task runners and compiling JS code with Webstorm and VSCode as editors on windows *(using bash as the terminal)*. 3. I really hate Apple. I won't pay the "apple tax" for low speed computers (compared to a desktop). I work on a computer that is "maxed out" and half the price of an Apple workstation. I like their OS though. 4. I wanted to switch to linux and even have put my development environment on VMWare, but because everything worked so fine (except yarn lol) I stayed on MS. 5 Gaming!
I guard my functions from invalid input, and leave early, I've been doing JavaScript full time since node.js was in early releases. I've worked at places where they code the meat of the function inside a huge conditional and declare a result variable at the top. function(opts) { let result = null; if (opts) { if (opts.opt1 == 'thing1') { results = 'you selected Thing #1': } else if (opts.opt2 === 'thing2') { results = 'you selected Thing #2'; } } return result; } vs function(opts) { if (!opts) { return null } if (opts.opt1 == 'thing1') { return 'you selected Thing #1'; } if (opts.opt2 === 'thing2') { return 'you selected Thing #2'; } return null; } Keyword... "worked"
Do you have to be a paid apple developer to access the beta?
Like every article ;)
Doesn't Windows use Ubuntu bash or something now?
I did this same thing with USA Today's website. US version - 331 requests, 2.5 MB download. EU version - 33 requests, 286 KB download. *Literally* 90% ads and trackers.
I personally wouldn‚Äôt recommend reading a 1000+ page book as a beginner trying to learn the language. Maybe when you‚Äôre a bit more advanced you can use that book as a reference, but to try and sit there and read it is not going to help you at all. Odds are you won‚Äôt remember much if you somehow got to the end (unless you have photographic memory) and it would be a huge waste of time. Start with something simpler, like the free course at www.watchandcode.com or the [beginner modules on Mozilla‚Äôs website](https://developer.mozilla.org/en-US/docs/Learn/JavaScript). Definitely get as comfortable as possible with vanilla JavaScript before moving on to a framework. Frameworks come and go, but knowing the fundamentals of JavaScript will let you love between old and new frameworks easily. The main advantage to using Node.js instead of another backend technology is having the same programming language on the backend and the front end. You only have to know JavaScript for the entire stack rather than having to know JS for front end and another language for the backend. It‚Äôs just a preference really, you may come to find that you like a different backend technology better than Node.
Yes it does. I tested it but ran into some comparability problems where their implementation of the ubuntu VM in windows 10 was missing something that was needed *(can't remember what it was now but It made me use the bash terminal in https://git-scm.com/)*
I thought it wasn't a VM but native. You might as well use vagrant if that's the case.
I guess at least this time you're right about correcting someone. Not your previous comment.
But do you really need realtime, no reload refreshing? Because it looks that is more a job to be done server side. Reading database, templating with html, serve content?
&gt; Arrow functions are not currying. They aren't, but they can be used to create curried functions, and that's the most syntactically nice way to do so in JS. &gt; I'm not really sure you truly understand what currying means. I'm quite sure I do. &gt; Currying is partial application It isn't. Partial application is the dual of currying, which is to say that you can partially apply a curried function. &gt; [..] and is implemented using second order functions and/or bind keyword Nope. let curried = im =&gt; a =&gt; curried =&gt; function =&gt; ... let notCurried = (im, not, a, curried, function) =&gt; ... It's as simple as that. You can do the same with nested 'return function() {..}'. You can technically also do the same with bind, but it's fairly ugly. Partial application is some thing like: let partial = curried("missing")("an")("argument") Closures are a natural consequence of being able to do those two things. They're not an especially interesting concept on their own.
They call it a "Windows subsystem", I just thought of it as a virtualization. It is "native in the sense that after it is installed it can be enabled via the normal command prompt. https://docs.microsoft.com/en-us/windows/wsl/install-win10 It might have gotten a lot better now since the April 1803 update, but I haven't felt the need for it yet. I'm using VSCode and using bash terminal I run both server (Rest api) and React client simultaneously using "concurrently". Everything works perfectly in windows :D I have to admit I got some problems after the 1803 update because I am not running as administrator for security reasons. NPM stopped working all of a sudden and I think it had to do with the windows 1803 update. I tried to re-install nodejs but it always wanted to install as administrator and that didn't work for me so I solved it by downloading the .zip of the nodejs installation and copied it over manually. Now everything works fine.
You don‚Äôt buy the requirement of immutability?
[https://i.imgur.com/x3HWCPk.gif](https://i.imgur.com/x3HWCPk.gif)
I‚Äôve seen that what is throwing people off from gql is the QL part, it is a query language but not a db query language meaning it doesn‚Äôt replace databases nor queries to database, heck you don‚Äôt have to have a database at all to use gql. What it is important to understand is the GRAPH part, the way I think about it is, graph =&gt; tree of resources, how you query a tree? That is your graph query language, graphql is very useful when you have a tree of resources where each node of your tree is resolved somehow and might need to know about the parent node to be resolved, then you have your ‚Äúresolvers‚Äù that are functions that resolve each node of your tree given the parent node. The resolver can be calling a query to a db or another service or a file or whatever as long as it brings the data back for your node, when gql shines is when the tree is more complex and you have to fetch several resources from multiple data sources, gql will call the resolvers in the correct order in parallel when can be parallelized making the graph resolution as fast as possible. I guess my main complaint is that it is very pedantic on its schema definition and maintaining it can be taxing and in small applications that do not need graph resolution can be an overkill. 
What isn‚Äôt a functional language? A language that makes it impossible to write a function that returns a value? 
Sounds like a nightmare. Join the dark side. Get a Mac (or Linux, but Mac is better).
Immutability is literally the definition. It couldn‚Äôt be less arbitrary
Does anyone know if this is free to use or do I need the developer account?
Competition is a good thing, even if the competitors are a perceived lower quality. 
Apple Maps is so bad that I think it‚Äôs some genius intential business tactic... it‚Äôs gotta be..
He sounds like someone who has never used it, actually. Probably believes Macs only have one mouse button, too.
&gt; Most iPhone/iPad users use Google Maps Source?
Nice sentence. Care to back it up with any, you know, logic or facts
I agree! Prettier is great. I run it with auto-format-on-save set up in my editor and never think about formatting again. However, AFAIK Prettier won't make structural changes to code like I suggested OP should consider in my original post.
The author mentions that you can get retrieve a symbol key even if you don't have the reference, by using `Object.getOwnPropertySymbols` (or `Reflect.ownKeys`). So what if we use a proxy to trap that call as well? const private = Symbol(); const proxy = new Proxy({ [private]: 42 }, { ownKeys() { return []; } }); Now `Reflect.ownKeys(proxy)` (and similar methods) will give you an empty array. :) AFAIK there's no way to access the target of a proxy, but if anyway can figure out a way to break this I'd be interested to hear!
Checking state, inputs, etc... at the very start of the function and returning or throwing early is a common practice called ["guard clauses"](https://refactoring.com/catalog/replaceNestedConditionalWithGuardClauses.html). It helps to reduce the amount of state a programmer needs to keep in mind while reading through a function. If a function has too many returns in its body such that its confusing and becomes hard to read, then its a good candidate to break up into smaller more narrowly scoped functions that are easier to understand. Code structure will always be opinionated -- but there are best practices that have developed over many years of software engineering, and we should do our best to leverage them!
It's honestly pretty powerful TBH I was really tired when I read your post, and wasn't paying attention :/
8/10 developers write prototypal inheritance as prototypical. 
No problem, glad to be of help
Listen this [https://youtu.be/bo36MrBfTk4?t=1260](https://youtu.be/bo36MrBfTk4?t=1260)
Ha, I'd imagine I've done that a tonne of times. I even read it back and didn't notice. 
I think that you do. In the video it says to login to the developer portal and get an api key. I assumed you needed one
My small front end library. https://github.com/edwrodrig/js PS: I hate javascript
I heard it was developed initially for a raspberry pi
It's Apple, so you probably have to pay the $100.
thank you very much for your answer well I'll be a noob JS dev but not a beginner programmer I programmed C++ 15 years ago still remember a little my concept class, pointers etc etc so JS won't be a introduction to programming to me im a system engineer who may switch to programming not sure yet 
thank you very much for your answer well I'll be a noob JS dev but not a beginner programmer I programmed C++ 15 years ago still remember a little my concept class, pointers etc etc so JS won't be a introduction to programming to me im a system engineer who may switch to programming not sure yet 
thank you very much for your answer well I'll be a noob JS dev but not a beginner programmer I programmed C++ 15 years ago still remember a little my concept class, pointers etc etc so JS won't be a introduction to programming to me im a system engineer who may switch to programming not sure yet 
Gotcha...still wouldn‚Äôt recommend reading that book entirely. It‚Äôs so detailed you‚Äôd probably quit from boredom pretty early on + it‚Äôs not really necessary. Get the basics down somewhere else and start building stuff. That book is more of a reference than something you‚Äôd want to read. If you have some programming experience and want to read a book, ‚ÄúYou Don‚Äôt Know JS‚Äù or ‚ÄúEloquent JavaScript‚Äù might be good options. Both are available for free online.
Developer accounts are free, but if you want to actually submit something to the App Store, you need to pay the $100.
How long does it take to reach Junior or Intermediate level of programming in Javascript ? a year of study at 10-12hrs a day ? 2 years ? I mean like the job post when they say junior intermediate or full stack dev with node etc
document.getElementbyId(x).getAttribute(y).length OOP, dumbass. Properties and messages.
Apple Maps is more out of date and seems to be updated less often from what I can tell. But it's passable.
Break everything into the smallest possible tasks. Write the code for all the small pieces first and then figure out how to put it all together.
Anything on the front end is just going to be a wrapper for IndexedDB, so either use the native API to build exactly what you need or find one of the many wrappers for it.
Is this a joke? Are you punking me or something? You realize that example has nothing to do with Object Oriented Programming, right? Those are functions being invoked, returning more functions that are then being invoked.
I think what might help here is the general programming concept of abstraction. Realize that even a complex project is just made up of many many smaller more simpler parts. Say you want to build an Image Editing App. Well you don't sit down and write an image editing app. After a lot of thought, you would write the components of the app: loading screen, the canvas, the color picker, the brush selector. And what is a brush selector? Basically a grid of images that each represent a object containing information like size, density, angle, opacity, etc... (of course this is too simplified but it gets the point across) You get much better at this with experience as you learn the capabilities of the language. There are many websites like codewars.com that will present you a small challenges to solve with your language of choice. Repeatedly solving these sorts of problems will give you the experience to begin to knit it all together into larger applications. Mostly, however, it will just come with time and dedicated practice. &gt;An expert is a man who has made all the mistakes which can be made, in a narrow field. ‚Äì Niels Bohr
You've never heard of people minifying their production assets?
&gt; Get a Mac No