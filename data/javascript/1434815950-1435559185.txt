Thank you for you reply. I heard that investing time in Angular is pointless now, because version 2.0 will be very different.
&gt;Meanwhile, `stopEventExtractXYShowMenu` is clearly a very bad name. `handleThingClick` tells you this function is only handling the concerns of the click event. But it doesn't, if all your method did was handle a click event and not do anything with it, then sure. More often it's going to kick off a bunch of other functionality, which is good to know when your reading the event listener setup. &gt;To offer another POV. As you even say yourself, the function should be named after what **it** does. It would be a bad idea to name it after what it _calls_. `handleThingClick` does **not** show the menu. It should **never** be called `showMenuWithEvent`. What it does is it handles the event and wires it to _whatever_ action that has to be called. If tomorrow it is decided that clicking _thing_ should instead show a dialog, `handleThingClick` should **not** change its name. If handleClick changes what it does, the method name should 100 percent change to describe what it's doing differently. Or subscribe to a different/new method, because it's hard to know what else in the program is using that method. 
Seems like you need better architecture.
And definitely not whereFrom
 function makeRandomNumbers(howMany) { var results = new Array(); for (var j = 0; j &lt; howMany; j++) { var r = 0; for (var i = 0; i &lt; 1000; i++) { var now = new Date; if (now.getMilliseconds() % 2 === 1) { r += now.getMilliseconds(); } } r = r / 500; results.push(Math.trunc(r)); } return results; }
JSLint works too for this sort of thing.
This is old. There are better shims and apis out already 
patch 0.02 alpha: ;(function(){for (var i=0, out=[]; i &lt; 100; i++) out.push(4);return out;})(); commit message: * re-committed to account for cosmic ray interference ( thanks /u/edensg ) * wrapped in immediate function to keep global space clean and to resolve "SyntaxError: return not in function" * declared an output variable "out" * replaced loop body with insertions to the array for output as-per the spec. ( thanks /u/fb39ca4 ) ----------------------------- v 0.01 : for (var i = 0; i &lt; 100; i++) return 7; these are all pseudo random anyway... mine just relies on cosmic rays interfering w/ memory registers at run time... 
http://phaser.io/sandbox/templates
There's also a huge world of langagex to javascript frameworks like elm, purescipt, ghcjs etc that bring big productivity boost and strongly typed safety to front end development. If you have to put up with an entire stack of compilers like webpack, babeljs, sass, hot reloaders etc, then might as well get some type safety and frp goodness for it.
sorry, cosmic ray hit my memory buffer
I made a pretty sun
Thanks!
This script can be used the same as an ad blocker. You can use it obnoxiously, or you can use it responsibly.
The "it costs more" argument has been [repeatedly debunked](http://blog.easy-designs.net/archives/the-true-cost-of-progressive-enhancement/).
Updates will now be posted on /r/angularreddit
Now it's time to write JS to detect this snippet and block it.
a more dirty test is, this worked in the earlier versions of AdBlock, don't know if it still does. html: `&lt;script src="ad.js"&gt;&lt;/script&gt;&lt;script src="html.js"&gt;&lt;/script&gt;` ad.js: `window.hasAdblock = false;` html.js: `if(window.hasAdblock) console.error("Expected Adblock!");` a very neat way i've seen to tackle this is by setting a background image, or doing some pseudo-`::before` magic with the ad container, which more often than not isn't removed and would only be visible when the containing elements are gone.
For some reason, I find it hard to believe you. 
&gt; Show me a React app that degrades without any extra code. I wouldn't use React when building a website based on PE. I'd use libraries that are more compatible with that approach and maximize code reusability on the client and server. There are many good ways to do it, but one I like is Express on the server and page.js on the client to universalize the routing paired with one of the many templating systems that supports both Express and client-side templating. Done correctly, you can do MVC on both the client and server with the same code. If your templates are written with semantic HTML, you can just serve a server-rendered flow, a plain CSS file, and no JS to unsupported user agents. It's not that hard.
"4".repeat(100).split("").map( x =&gt; +x)
You're right I could, but I would prefer to use a more JS native build system especially when it comes to projects which are Open Source on github. 
 "Math.random()|".repeat(100).split("|").map( x =&gt; eval(x))
looks awesome. great job.
The main logo needs some left padding. 
Isn't that the point though? Nothing conformed to one standard, so jquery meant there was a standard set of tools.
Doesn't come out too well on mobile. Buttons/ text too small and low contrast males it difficult to read at a glance... White on light green for example. It's a nice layout, but could use some size/ colour tweaking IMO
I never said you had to use this, I'm simply showing how it would be possible.
I have been. The problem is that `make` doesn't work on windows without difficulty. When it comes to open source projects I like to keep barriers to entry as low as possible. 
1) C#/.NET: That's a Windows thing. If your company runs on Windows it may make a lot of things easier. In our company we have the ERP system run on Windows and MS SQL Server. We still use Ruby on Rails, but a few things would integrate easier if we would use Windows tools all the way. Beyond that I would not like to write lots of complex business logic in Javascript. I like the language so far, but I prefer Ruby when I need to write more complex tasks. 3) Simply yes. (though PHP as Ruby and a many others are also open source). Don't compare with Twitter, they are huge, as in really, really very huge. There are not many sites that process that amount of data. They have like 750 million tweets per day (last time I checked, most likely even more now). With retweets and any other form of processing the move billions of database records every day. (And they still used Ruby for a very long time). You will most likely never see a site that comes even near. For now just assume that most major technologies can handle most relevant tasks easy enough and somebody out there has used them for big things.
Good point, and a valid reason to avoid make. I just don't care about windows :)
Was this recently private? This is awesome, clean and looks extremely reusable.
Technically this creates 100 random strings.
How did you make it so that connection lines appear and animate when you scroll down to the appropriate area?
What a nightmare that was in the beginning.
I cloned the repo. Can you show me how to run this locally? I read the comment section about Angular Seed which says you should do npm install and npm start but there is no package.json in the project.
We already have a detection script using class names even before making an ad server call.
seems to be broken
Haha, genius.
I agree. Elm in particular seems really cool, and is already affecting the JavaScript community in a pretty big way. Mostly in-and-around the React community. Exciting to see what comes of it.
An article titled "Purely Functional Composition" That focuses exclusively on OO patterns, you sneaky bastard...
Hi Kevin, my name is Andrei, I think I can answer your question for the perspective you are looking for. I used to do performance programming in C++ in highschool, and won some algorithmic competitions. I've been working as a web developer for 4 years now, so I had the transition from precise programming to web development. When I first used weak typed languages, I hated it. Python, although clean, left me uneasy since I was used to being aware of any byte I used for my applications, as C and C++ let you do. Javascript is way less transparent than python, but I grew to love it. The main advantage is the easiness to work asynchronously. Although the scope feels retarded at the beginning, you'll see that the scope is really easy to comprehend locally, which means that it's really easy for your app to just juggle with objects asynchronously without loosing control over the scope. This easiness to work asynchronously compensates by far JS being slow at intensive calculations. The overwhelming majority of business applications are less focused on calculating responses, but rather "assemble this response and send it". Which means, IO is a bigger issue than CPU cycles. Node handles IO amazingly. After initialization, everything you do inside an node app is just "throw objects around". Get info -&gt; create objects -&gt; throw objects around -&gt; assemble response. Every single async object "throwing around" is getting it's fair cycle on the event loop in such an elegant manner, that waiting for IO does not pause the thread like in other languages. You can have as many thousands of user response handled one by one on the event loop as your ram allows it. Everything is controlled, and you can improvise for as much as you can. [And this is is only one node.js process. If you're really clever, you can go on multiple processes. Here's the big fascinating unknown for node potential. ] If you're innovative JS rewards you amazingly, which is why there are so many good frameworks written in javascript. You can do anything with javascript. You can do functional programming, you can do imperative, you can make it feel like java, or you can make it feel like lisp, and still work as you'd expect it, since the way js works is based on **really simple** things. Watch Douglas Crockford, when you'll understand why the javascript works how it does, and the context it's in, you'll grow to love it, as I did. Best regards from Romania
The main thing: they are a unique identifier. It allows you to "hide" information from the end-user without the possibility of name collisions. var Person = (function () { var firstName = Symbol('firstName') var lastName = Symbol('lastName') return class Person { constructor() { // this data is "mostly private" this[firstName] = 'John' this[lastName] = 'Doe' } getName() { return `${this[firstName]} ${this[lastName]}` } } })() var person = new Person() console.log(person.getName()) // does not enumerate "private" names console.log(Object.keys(person)) 
Different languages, frameworks, libraries, etc. have different ways of doing things and learning them changes how you think about problems. In general it is good to learn many systems even if you don't use them directly because you can apply what you learn to what you do use.
I'm calling bullshit on your calling bullshit. Do you mean bullshit among your own personal feelings? I guess it could be correct then but who cares. 
Before jquery, writing cross browser js was like alchemy. Now it's like chemistry.
Couldn't be said any better
Yeah. It seemed like low hanging fruit to me... 
Nice! I agree with others that the price isn't bad because it pays for itself. Even better if your company pays for the license :)
What's broken about it ?
got it, thanks. It's pretty crazy that you managed to make this after starting with angular only a week ago!
If you have any interest in learning/rebuilding hit me up with a PM :)
http://imgur.com/IqbH1VB that's all that's showing up.
Angular 2 is indeed very different from angular 1 but definitely not pointless. Angular 1 is still a great framework that is also mature in terms of 3rd party element and community support. Just my personal experience At my work, we are starting a new large scale project, after the management gone through a period of prototyping with different frameworks in the last few months, they ended up sticking with angular 1 mostly due to the availability of support and developer resource.
Please post the console errors
I think it is important to say, that most of these JavaScript frameworks are backed by a large company. Angular is backed by Google, React is backed by Facebook. The only exception would be Ember. It's popularity now is purely of the open source community. Ember was initially named SpoutCore 2.0. SproutCore 2.0 was similar to Angular 2.0. Just as Angular 2.0 is virtually entirely different from Angular 1.0, SproutCore 2.0 was totally different from SproutCore 1.0. SproutCore was initially heavily backed Apple, and was used for Apple's web service MobileMe (it's still used by iCloud today.) Apple does not commonly openly contribute to open source projects, but they did contribute to SproutCore. Tom Dale, core team member of Ember, actually worked for Apple while working on SproutCore. Even though Apple may not financially back, or even contribute as much to Ember, they do use it! Most recently, it was used for the Apple Watch User Guide! http://help.apple.com/watch/ edit: mis-typed Facebook as Google
Is webpack a full build tool? The website makes it seem like it would be one step in a larger build.
&gt; Stack Overflow Careers you forgot backbone. why don't you uh....run these numbers again and have them on my desk in 5 minutes... that'd be greeeeeaaat. 
Will do. Thanks!
feels sooooooooooooooooo good to be right! thanks, you made my day!
I pity the people who have to work with you. You are everything that is wrong with this industry. Gotta be right at all costs, fuck everyone else.
"()" invokes a function. If a function returns a function, you can invoke that one by adding yet another pair of parens: function foo() { console.log('a'); return function() { console.log('b'); } } var bar = foo(); // a bar(); // b foo()(); // a b Similar: var a = [ x =&gt; x * x, x =&gt; x * x * x ]; console.log(a[0](5)); // 25 console.log(a[1](5)); // 125
Hahah, good catch. didn't realize I typed Google twice. :)
`obj.style.background = "";`
 $('.mapWijk').css('background', 'transparent'); That's all you need. You can also set multiple properties by using an object. http://api.jquery.com/css/ Also, create a test case on jsbin or jsfiddle. I'm not really sure what you're trying to do.
This one is for NodeJS buuut: function generateRandom(callback) { process.on('exit', function () { var arr = []; for (var i = 0; i &lt; 100; ++i) { arr[i] = Math.floor(Math.random()*100); } console.log(arr); }); } generateRandom(); It will only generate the random numbers once you try to shut it down. So if you wait for it you'll never get numbers until someone tries to restart the app :D
Doesn't do anything. Using Chrome. 
Definitely a thing in JS too if you are interested in annoying users. :) window.onbeforeunload = function (e) { var arr = []; for (var i = 0; i &lt; 100; ++i) { arr[i] = Math.floor(Math.random()*100); } console.log(arr); };
Nice reactionary downvotes /r/javascript. I expected better.
Using [GitHub stars for JavaScript projects](https://github.com/search?l=JavaScript&amp;p=1&amp;q=stars%3A%3E1&amp;s=stars&amp;type=Repositories) as a popularity metric: Repo | Stars | Rank (JavaScript) -----|-------|------------------ [angular/angular.js](https://github.com/angular/angular.js) | 39,946 | 1 [meteor/meteor](https://github.com/meteor/meteor) | 25,786 | 6 [facebook/react](https://github.com/facebook/react) | 23,758 | 8 [jashkenas/backbone](https://github.com/jashkenas/backbone) | 22,167 | 10 [driftyco/ionic](https://github.com/driftyco/ionic) (Angular.js) | 17,386 | 19 [emberjs/ember.js](https://github.com/emberjs/ember.js) | 14,077 | 29 [riot/riot](https://github.com/riot/riot) | 6,577 | 116 [marionettejs/backbone.marionette](https://github.com/marionettejs/backbone.marionette) (Backbone.js) | 6,267 | 129 [flightjs/flight](https://github.com/flightjs/flight) | 6,186 | 132 [ractivejs/ractive](https://github.com/ractivejs/ractive) | 4,058 | 254 [derbyjs/derby](https://github.com/derbyjs/derby) | 3,743 | 295 [lhorie/mithril.js](https://github.com/lhorie/mithril.js) | 3,729 | 297 [aurelia/framework](https://github.com/aurelia/framework) | 3,335 | 336 
I feel like this to be truly bad, at least 1 index needs to be assigned to twice, because that would complicate debugging.
Ember has it's own cliff(s) that developers run in to. Namely Ember-CLI and Ember 2.0. Both backwards incompatible (and opinionated) enough to make you wish you'd not built more than a simple "hello world" app. My team is stopped working on new functionality, which we try to get to Ember-CLI, before we even begin to thing about more catch-up we have to do. We've been "down" for three weeks so as to not encounter un-mergeable branches, and we're only trying to get to CLI right now. It is going to be *at least* two weeks more. We wish the upgrade was performed by a script!
Seems to be a deployment issue. I'm hosting this on the smallest digital ocean droplet available which only has 512mb of memory. That and the fact that the cpu is at 100% consistently is probably the cause. This was happening earlier and restarting the droplet and adding some swap as described here (http://serverfault.com/questions/622791/high-cpu-usage-in-my-digitalocean-droplet) fixed it but I guess only temporarily. This is my first time i've deployed a personal project myself so if anyone has any experience with deploying to digital ocean droplets I would appreciate it. Maybe this droplet is just too small for the work load that is on it? Sorry about this everyone! I'll keep looking into this. Just take my word for it that the application is dope...
In certain circumstances it is desirable to have a property name that is guaranteed not to conflict with consumers or other libraries
`key != Symbol.instanceOf` was a double typo: https://github.com/raganwald/raganwald.github.com/commit/fb990a3281e0aaf6d9efe3871c55b411296c16cc &gt; We don't have a way to get all own property (what would you call them, descriptors?) at once? There might be, I just don’t know what it is (yet). While we’re on the subject, this code is meant to illustrate a certain way to think.If we were writing a library, we might also want to support the properties that use the `get` and `set` sugar.
Less like Java, but still quite like Java. I'm not arguing that that's a good thing necessarily, but Angular 2.0, especially combined with TS, really reminds me of my days doing EE. I don't think it's a secret that Angular explicitly tries to cater to Java folk.
I assumed it was just a brain slip :)
Also, feel free to edit the post and make a better title: https://github.com/raganwald/raganwald.github.com/edit/master/_posts/2015-06-20-purely-functional-composition.md This link will automatically fork the blog, and when you’ve finished the edit, you can [automatically create a pull request][pr]. [pr]: http://raganwald.com/assets/images/pull-request.png
&gt; How did you know I treat random reddit commenters the same way I treat the people I work with and care about? Well... &gt; there I go being right all the time again There's your answer. You think this is true. I guarantee your coworkers don't. They think you're a nob.
worked for me (firefox), groove!
Don't use Backbone.js? There's much better alternatives that are still evolving and being updated instead of stagnating.
And types, which mean fewer errors and better tooling, are a bad thing? Those type annotations make it much easier to work with multiple developers on the same larger project. You don't have to use type annotations, but there really is no point in omitting the crucial surface ones. You won't do anyone (or even yourself) a favor if you skip them. Without them, you *will* waste more time than the few seconds it would have taken to add them. Anyhow, you don't have to use TS or Dart if you use Angular 2.x. Also, if you use Aurelia, you can still write your app in TS. So, this is kinda unrelated, really. Another key point is that Angular 2.x code is simpler and terser than 1.x code. There is nothing bad about that, is there?
Prepare to pull your hair out. Devs just don't comment enough. Everyone agrees that it is good practice and necessary, but it is rare to meet anyone that actually follows through.
If you follow the standard in some places and not others, you are not compliance. The problem is not that no browser followed the standard ever, it's that there were extreme inconsistencies on where you could count on it to be adhered to. We can hate jQuery now, justifiably I might add, for narrowing the skills of many web developers, but we can still understand that originally jQuery did something very very very useful. If you disagree with that last part you are simply a zealot.
I was speaking in general, but you are right.
CSS3 selectors for browsers that didn't support it. Technically this was borrowed from the sizzle js engine, but back in 2009 &amp; 2010 this was a killer feature to support ie6,7, and 8
And this is why Ember-CLI is my bestest friend. 
&gt; different browsers using different syntax. Funny. That's what I said. Strange how redditors read differently than the rest of the world. &gt;People wanted a library they could use to ship code that would work everywhere. Gee. Kinda like what I said, too, but, talk about wholly misinformed. You seem to mix up syntax with standards compliance and ignore implementation. But this is reddit, after all, where no one can set the bar low enough.
One day I'll take the time to really learn regex. Until that day it's black magic.
So a lack of comments doesn't necessarily say, "this is trivial and you should understand it immediately" ? I've had colleagues suggest that doubling a file with comments can detract from the usefulness. I kind of get that. A lot to change if code mutates. Generally I try to write a sentence-like docstring for every method IF the method name doesn't reasonably say what it does. Maybe I'm an exception as I LOVE good commenting. It feels just so right.
I think the argument for symbols is stronger for mixins, as you might have two mixins that use the same property name. Either would work on their own, but if you mixed them both into the same class, boom. Symbols for property names solves that problem neatly. That is less of an issue with classes, as if class `B` extends `A`, presumably you look at the source code for `A` before writing `B`, so you wouldn’t accidentally use the same property name for another purpose. It is an issue with large class hierarchies, as adding something to `A` after `B` is written could cause a conflict in `B`, this is the “fragile base class” problem. But most people these days shy away from building large, deep hierarchies.
&gt; Like how was selectByClass treated differently by browsers in the past It didn't exist at all in older browsers. The solution was to get all elements using `getElementsByTagName('*')` and manually iterate through them, doing your own filtering. A simple/naive approach would look something like this: function hasClass(element, name) { return (' ' + element.className.toUpperCase() + ' ').indexOf(' ' + name.toUpperCase() + ' ') &gt; -1; }; function getByClass(parentEl, className) { var els = parentEl.all || parentEl.getElementsByTagName('*'); var result = []; for (var i = 0, count = els.length; i &lt; count; i++) { if (hasClass(els[i], className)) { result.push(els[i]); } } return result; } It was fantastic when `querySelectorAll` came along, since it lets you do filtering by CSS selector. It still had some issues (as only the CSS selectors supported natively by the browser would work) but it was a great step forwards. These days, with modern browsers, you can pretty much rely on `querySelector` and `querySelectorAll`.
&gt; there was no getElementbyClass() I think... jquery started that one Actually that was Prototype, jQuery came later on and some of its functionality (especially around class management) was heavily inspired by Prototype.
I'm surprised no one has referenced this... Here's what jQuery has and does solve for cross-browser compatibility: https://docs.google.com/document/d/1LPaPA30bLUB_publLIMF0RlhdnPx_ePXm7oW02iiT6o/edit You can find this via http://youmightnotneedjquery.com
Nah, I like it. I was just expecting f(g(x)), not classes/subclasses. Btw, thanks for including Object.assign. Had no idea that existed. Terrible support at the moment unfortunately, but good to know that's one less thing that libs have to cover in the near future. 
Register two separate listeners.
jQuery itself didn't do that. It used Sizzle, which, if memory serves correct, came from Yahoo somehow. jQuery wrapped Sizzle.
The real problem with this pattern is that having non-semantic function names leads to accidental shadowing with inheritance. class Vehicle extends EventEmitter { constructor() { this.on('start', this._onClick); } _onStart() { doSomethingAVehicleWouldDo(); } } class Car extends Parent { constructor() { super(); this.on('start', this._onClick); } _onStart() { doSomethingACarWouldDo(); } } Now, since `_onClick` is a "private" method, ie. it is considered to be an implementation detail of Vehicle. However, since this is JS, it still gets inherited and overriden. This means that when a `Car` receives the `'start'` event it actually calls `doSomethingACarWouldDo()` twice, instead of calling `doSomethingAVehicleWouldDo()`. By using instance methods with these standardized names, you're pretty much ensuring that this will happen if two classes in the same inheritance chain respond to the same event.
ReactJS and EmberJS get my vote (I'd avoid Angular 1.x and 2.0 seems like a bad remake of React). If you want to learn a framework that will push you to the edge, look at [CycleJS](https://github.com/staltz/cycle). I wouldn't use it in production yet, but it will force you to learn about things like FRP and pairs well with ImmutableJS. It's one of the few upcoming frameworks I'm keeping a close eye on.
This bot will do HTTP requests?
I don't think there's anything "purely functional" about a workaround for problems you brought on yourself when you decided to design programs in terms of messy bundles of mutable state and behaviour. But I do see how this may alleviate some of that pain.
Before I answer your questions first let me say that as a programmer I strongly prefer strong/statically typed languages. I sincerely believe that these system catch bugs sooner than the "squishy" system of python/JS/Ruby. So actually, I don't really like JS. I'm forced to use it because it's the standard inside all browsers. Additionally, though I understand UI code forced one into a "don't call us we'll call you" style of programming. I feel that JS then took this particular way of thinking too far. Anyone how has tried to wrestle with multiple interlocked and interacting promises will understand what I mean. So I'm ALSO desperately awaiting ( har har ) the await/async features in ES7. SO unto your questions: 1) I would pick a language which is strongly typed, has traditional threads ( and ideally fibers as well ). This is because this style of programmer will carry you further into larger systems and larger teams. There is a reason why teams like NetFlix and Amazon use Java. It's because they're not writing simple CRUD systems, but truly complicated and large chunks of software. However, if you are, for some reason, not a fan of strong or static typing then JS is better than PHP (YUCK every which way ), and on par with python and ruby. There are some advantages to one language everywhere, but mostly only if you are on a team of people who only know one language. I honestly prefer teams who are more polyglot, that experience with different ways of doing things pays off. 2) node is fine at IO, and honestly it's fine at CPU intensive stuff (not as good as solid java code or C/C++ but far better than python or ruby ). The problem with Node is that when it's doing that CPU stuff, it prevents any other requests from happening. it's single threaded. 3) Honestly, pretty much everything is open source to one degree or another now. Even M$ has largely come around on this one (Ok, there are still some important pieces in that stack which are not yet open source ). So the open-source-ness is probably not a solid determiner. That said, various technologies do have their niches where they're often used. And sometimes they're used well beyond what is rational (I'm looking at you symfony+PHP ). So I would pick a technology stack based on the type of problems you enjoy solving. I'll illustrate with two extremes: If you like cranking out reasonably simple systems and moving onto the next thing while working in small teams, perhaps PHP or Ruby makes sense. If you like working on massively parallel "big data" programming problems you should probably learn java or scala. And if you are in the middle, my strong preference is to error on the side of ability to scale up. Ok, so here are my favorite tools at this point in time: web back-end programming: java or scala ( used to include C# in this list, but while the language is great, the rest of the ecosystem doesn't really hold a candle to java/JVM ). I'm looking also at Kotlin, but haven't written anything there yet. web backend frameworks: dropwizard, jhipster, play!, spark. scripting (less than 2 pages of code, minimal maintenance): python. avoid bash, prefer python over ruby. browser: javascript, typescript, angular, interested in web components. dev tool chain: bower, gulp, yeoman super simple web apps: PHP, but this better be like 2 served pages with perhaps 1 form. deploy: linux, the degree of visibility is just much higher than windows. tools galore. dev machine: pick your front end (linux/mac/windows), but it MUST run unix inside. So if you do windows, then you better have a linux VM inside there, or install cygwin. the github cli tools almost cut it, but then fail horribly if you try to push things. I've also written systems in C++ recently, but I'm really rooting for D to supplant it. C++ has too much baggage at this point. Rust is interesting. Nim too. Go I'm not sure about. Finally, there is a little bird that continually tries to convince me to dive down the Haskell rabbit hole and see what they're smoking down there. In the meantime, I'm still trying to really 'get' scala's tying system. ---edited for spelling and clarity after a night of sleep.
I'm not a bot. I just run them through a benchmark suite. 
It'd be great to see this extended to have a `Path` component which accepts a series of `Command` components consisting of the path commands. The `Path` component can then use `this.children.map` to convert it into the expected `path=` string, and all of the above could then be wrapped in an `SVG` component which sets the `path=` attribute on itself, so you'd end up with: &lt;SVG&gt; &lt;Path&gt; &lt;Move absolute={[2, 2]} /&gt; &lt;Line absolute={[62, 2]} /&gt; &lt;Line relative={[0, 60]} /&gt; &lt;Line absolute={[2, 62]} /&gt; &lt;Line absolute={[2, 2]} /&gt; &lt;/Path&gt; &lt;/SVG&gt; The cool thing about the above is the `absolute=`/`relative=` attributes can be functions, so you can start passing in the mathematical functions you need to draw the SVG. Essentially you end up writing what looks very similar to the existing SVG syntax, but with full JS processing power behind it! Anyway, just my thoughts running away with the idea. Great work on the tutorial - it's very nice!
If you're only looking for requests that go across the wire you've got the standard developer tools Network tab (which is ok). I tend to go with Fiddler2 however. If you want to get all crazy, wireshark is probably the top o' the line.
As long as the request is made over HTTPS, then yes it's still secure. Here's a link explaining more: http://answers.google.com/answers/threadview/id/758002.html#answer
I'm skeptical of HTML directly within JS with JSX. Is that something I want for anything but small applications? I haven't played with the idea of combining behaviour, structure, and style. I could get a widget all in one file. Does it work out that well?
Bless you, your future kids, their kids, and the kids beyond. HAHAH Yeah, I think its like *vanilla* Javascript. Oh I did ALL the HTML on CodeAcademy, still didn't get what's so special. I just thought of them as one is Burger King and another is McDonalds (I KNOW that's not the case :/ ) as for the &gt;"os" THATS EXACTLY IT. Thanks for explaining it to me Don't worry about it being 2am, it was clear as day what you told me and once again, THANK YOU!!! This is 40% of my grade and I'm trying super hard to get and understand all of this. I truly am.
Random question Google didn't help with. What's sideways data loading? I suspect it's something I know but not by a name.
 [].map.call(Math.random+Math.random+Math.random, Math.random).slice(-100)
I have been using Gulp for a few months now (no experience with anything else) and it was really cool until my application grew and a laundry list of exceptions to the build scripts grew. I end up with 15 or so packages just to make the gulp tasks run. I just want to write front-end code via. CommonJS and end up with two files: app.js and vendor.js. Maybe I didn't explore Bower far enough as I couldn't find a reasonable way to get my desired browserified structure without shimming everything.
Nice! 
&gt; there is a little bird that continually tries to convince me to dive down the Haskell rabbit hole and see what they're smoking down there outstanding. :D
Stupid too. I wonder that I could improve...
Nop. Actually, jQuery made Sizzle and then released it as a separate project to make it available for other projects. [January 2009](http://blog.jquery.com/2009/01/14/jquery-13-and-the-jquery-foundation/)
Worked for me on Android Chrome. Love this idea - reminds me of the Captain in Wall-e. "Define dancing."
Not a problem at all. I'm still learning too, and we learn best by teaching and explaining. Keep at it! 
&gt; summons I'm going to use this from now on. &gt; for loops Iterate over an array of objects, when I was first learning to program, the only explanation that made any sense was the shoe closet analogy. You keep a pair of shoes in each box (analogous with an item in an array). The closet is the array. It contains multiple shoe boxes. Obviously, you can put whatever you want into these boxes...not just shoes. You loop over them by counting at 0 and adding 1 to a counter. The loop exits when the length of the array is reached: ``` for (var i=0, len=myArray.length; i&lt;len; i++ ){ //do something with myArray[i] here. } ``` Basically what this is say is "while i is 0 and less than the length of the array, do some shit (the block of code) and then add 1 to `i` If your professor hasn't explained the shorter syntax for iterating over an array I would ask him about his thoughts on it. `myArray.forEach(doSomething)` &gt; conditionals That's just simple "if this then do that else do this other thing." `if ( 1 &gt; 2 ) { //this will never execute }` `if ( a === b ) { //do some shit if a is the same as b }` You define what `a` and `b` are before you setup the conditional clause. 
I expect a proper build tool to let me automate all parts of my development process. For example tasks like: * cleaning the target directories * invoke parser generators * bundling everything up into a zip * deploying the output on a server * bumping version numbers * running tests * running linters * checking for dependency updates I should be able configure or script my build tool to do these things. I shouldn't need to have shell scripts lying around nor should I have to remember command lines and processes to do these repetitive things. 
That is definitely a job for Gulp or Grunt. For some, you'll have to use plugins for others, you should use directly NodeJS (as clean). Keep in mind that is NodeJS so a Javascript server side scripting. If you didn't find a plugin that make what you want... you can script it yourself ! ;-)
My team replaced JSCS and JSHint with ESLint and haven't looked back. Supports the latest ES6 goodness and can be extended to support JSX styling rules.
I looked at React and I like it, do you guys know any good free guides for React?
To put it simply if you're not building an isomorphic single page application then Webpack will only be part of your build. That's not the entire truth of course, but following that rule will save you a several month long headache :)
If we're talking about HTTP/HTTPS requests, take a look at Charles, it's basically a proxy that can intercept any HTTP based requests. You can even set breakpoints and manipulate data to play around with certain values, which can be useful for reverse engineering an API.
`div` and `span` are non-semantic elements (they have no direct meaning), differentiated by their `display` defaults, `div` being used as a generic HTML element for virtually anything (a generic container), while `span` usually being used on text nodes. It doesn't really matter in essence, you can take a `span`, change it's CSS to `display: block` and treat it like you would a `div`. All elements are equal bitch to the CSS engine.
No, but to be fair, no matter how good you are regexps are *always* easier to write than to read.
Using the event bus is absolutely fine in many applications and you won't even notice problems with 20-30 models, views, collections. There are cases when you can avoid using the event bus, see the example in the article. I would not give much thought to it in a weekend project though as I would prefer getting things done quickly and efficiently. Once you contribute to a huge application for years, maintainability problems emerge on a different level. 
Worked fine for me on Debian Chrome. Great idea! It's a fun way to explore the data. It's now even easier to get lost in Wikipedia for hours. :D
 // Time how slow this code is. var t0 = performance.now(); function getRandomInt(min, max) { var request = new XMLHttpRequest(); var url = "https://www.random.org/integers/?num=1&amp;col=1&amp;base=10&amp;format=plain&amp;rnd=new&amp;min=" + min + "&amp;max=" + max; // Synchronous XHR request.open("GET", url, false); request.send(); // Ensure we got a valid response from the API if (request.status === 200) { return (parseInt(request.responseText, 10)); } // Otherwise, return the standard IEEE-vetted random number from RFC 1149.5 return 4; } // Slow way of creating an array var values = new Array(0); for (var i = 0; i &lt; 100; i++) { // Create a new array 1 longer than the old array newArr = new Array(values.length + 1) // Copy all the previous values to the new array // .push() is not slow enough. for (var j = 0; j &lt; values.length; j++) { newArr[j] = values[j]; } values = newArr values[j] = getRandomInt(0, 100); } console.log(values); var t1 = performance.now(); console.log("Completed in", (t1 - t0) / 1000, "seconds") This takes about 1 minute to complete.
Better is relative. I regularly use MarionetteJs on top of Backbone and it's also evolving. I have written code in React, AngularJs (1.3), EmberJs, I learned many ideas from using them, but I am still happy with what Backbone+Marionette can offer. I would probably not use Backbone.js without any other frameworks or libraries on top of it though.
I left out 83 ;)
For those interested, I have a project called [nanoscope](https://github.com/5outh/nanoscope) which focuses heavily on composition of objects in Javascript, actually. The idea is drawn from [lens](http://lens.github.io/) originating from the Haskell community, and basically consists of a bunch of primitive getters/modifiers for various operations that can be composed purely. The approach is very different than the one outlined here, but I figure it's worth mentioning since it's very on-topic. :)
That's a really nice idea for a library :)
Yeah, thats basically it, if you need an example this is probably the best site: rsclues.com See how when you do click on a link that you've searched for, in the URL box it says clue?id=(number). That's what I'm kind of going for, but I'm unsure on whether I'll need some sort of a database, or if I can do it in some sort of a huge array. And when I say search bar, I basically mean something like the Google search, with Ajax implemented. (Sorry if I do sound a bit dumb, I'm fairly new to programming.) 
hmm "popularity"... probably not the best word to use then. Popularity means being prefered by **many** people. You're just one dude. So maybe you meant "My personal preference". In any case it looks like a few people here did actual popularity lists... so no big deal. 
If you are willing to learn JavaScript and AngularJS at the same time here is a [cookie clicker clone](http://plnkr.co/sO79j2/) I created using AngularJS and an [AngularJS based game engine](https://github.com/Hypercubed/angular-ecs) I've been building. Using just this example you should be able to add your own "buildings" and achievements right away. If you want to understand more about the engine take a look at the [wiki](https://github.com/Hypercubed/angular-ecs/wiki). If you have any questions contact me.
If they are sending plaintext account passwords then it is not secure, doesn't matter if your using SSL or TLS. One would also hope that the authCode is a single use token, which you can probably verify with a bit of sniffing.
Cheers Romania!
document.all and document.layers back in the day. The still give me nightmares.
How do you send non-plaintext passwords? I'm pretty sure all passwords on the internet are sent in plaintext. They are secure because of SSL. 
only when i'm wrong. I was afraid this thread was to buried for anyone else to see! Now I'm so happy to see it's not! Thanks for reading!
Thanks! Didn't know -- I get weary when I see the words password in a javascript app, and figured I'd consult the community here. Have any tips on sniffing / finding api requests to an unpublished / documented API? I feel like I'm on the right track but I can't stop but to think there are tools used for API detection / end points / etc for this kind of thing. Thanks!
So do folks who can't stop commenting on a buried thread. Are you not entertained??? I am! :) sigh.. i have to take a break though.. can we pick this up on monday? I know you can't let it go either now. ha.
It was playing a game of whack a mole with the break / fix cycles. Fix a bug in ie7, you've broken something in Firefox. Fix that and you have to fix something else for ie6. Think of that but just never ending and when it did end, you had a cobbled together mess, instead of the great thing you started with. 
Well, nothing's ever original and we all get _inspiration_ from somewhere :) Sure, [there were other selector engines](http://www.paulirish.com/2008/javascript-css-selector-engine-timeline/) (in some cases little more than a function) before jQuery. It was Simon Willison’s function `getElementsBySelector` that John Resig [played with initially](http://ejohn.org/apps/jselect/). And Behaviour.js got [him thinking more in general](http://ejohn.org/blog/selectors-in-javascript/) about what would later become jQuery's well known syntax. But in any case, no, [it was indeed written by John](http://ejohn.org/blog/selectors-that-people-actually-use/). I remember reading him saying so somewhere.... quite probably in Ajaxian.
It allows for a component to get data from a resource such as network or local storage, rather than being passed as props (equivalent to HTML attrs if you don't know React). 
Try to avoid thick-client JS frameworks unless your runtime environment [explicitly guarantees that JS will always be available](http://www.sitepoint.com/javascript-dependency-backlash-myth-busting-progressive-enhancement/), such as NW.js, Cordova, internal LAN webapps, etc. It doesn't sound like that's the kind of webapp you're building, so in your case a lighter weight frontend makes the most sense. Isomorphic is definitely a good way to go. Since you're already leaning towards using Express on the server, I would recommend pairing that with [page.js](https://visionmedia.github.io/page.js/) on the client which uses the same API for routing on the client as Express does on the server. You can also use this [page.js plugin](https://github.com/kethinov/page.js-express-mapper.js) to share your routes on the client and server without any code changes. (This makes your routes isomorphic.) After that, just pick a templating system that is compatible with both Express and client-side templating (you mentioned Jade, that should work) and have at it!
I've just pasted your snippit as-is into the Chrome Dev Tools, replaced the : with a ;, and it works fine for me...
I'll help.
A more comprehensive tool would be [Fiddler2](http://www.telerik.com/fiddler)
For the front-end client application there are many options, if it is something simple I like to use Knockoutjs as the base framework, Reactjs is pretty cool also, if it requires more features and complexity I usually go with Angularjs. Have you tried yeoman.io to help you get started? Now for the server side Nodejs is a good option, but I personally like the Microsoft stack, ASP.net MVC. You can code in C# which is pretty flexible and has a lot of documentation out there. The last part is the data storage or database, you can go with MS SQL, Postgres, MySQL, MongoDB. Many options too, again I like MS SQL because I am more familiar with and easy to get started. Good luck.
If you would like to help, can you check out the game so far, and help me figure out why the cookie is so big? I'm using Hypercubed's base code, and I can't seem to figure out how to make it smaller to let everything fit into place. Index: http://www.mediafire.com/download/c2fcv7jh5wq0bjb/index.html Script: http://www.mediafire.com/download/8xfb7pqxi53w5fq/script.js Style: http://www.mediafire.com/download/508hx4e73l5a7rh/style.css
Sure
Even with HTTPS, applications shouldn't be passing secure data on the URL https://blog.httpwatch.com/2009/02/20/how-secure-are-query-strings-over-https/
Ah, I failed the inverse version of the Turing test. 
Just save it and paste the link here when you're ready!
Thank you for the shoe box/closet analogy. It all makes sense when its explained with oversimplified metaphors. Thing is, he really enjoys nesting his For statements, so even if were to master a shorter syntax, I would be lost on how to implement the rest of the code. And another question, when you're thinking of code to solve a problem, what is your thought process? Like how do you tackle writing the code? {I need help on how to attack the problems too}
I'm dead &gt;All elements are equal bitch to the CSS engine Welp, thanks for letting me know cause I was stressing out thinking that they were all special. Once again thanks for helping clarify that!! 
Node is an environment where Javascript can be executed. It includes a number of standard libraries. While these factors heavily shape how code is written for Node, it is not a framework. Node is also not a language. It is an environment in which an interpretation of the ECMAscript (Javascript) language can be run. In the broader sense, yes it is a framework, just as much as C++, PHP, or any other language is a framework on top of bytecode, but there is little opinionated structure for things other than basic IO and utility concerns. Angular, conversely is thoroughly a framework. It is highly opinionated about how you interact with it and use it to construct applications. Angular has its own domain specific languages (markup, filters, expressions), but it is not really a programming language. Angular 2 is looking to be more library like, but is still relatively opinionated.
`foo = []` creates a new array, yes. `[]` is an array literal which is equivalent to `new Array()`.
As /u/vertice mentioned, passportjs is pretty much the defacto standard at least for connect/express applications (anything with middleware). Passport can do all of the auth strategies mentioned in this thread and a bunch more that werent.
https://github.com/raganwald/raganwald.github.com/commit/473ec989af06e5b8950fa64af922b35cbe659eed
If you hate Frontend development, you should probably leave it to someone who doesn't.
Lots of people use passport, but I'm personally not a big fan of it. JSON Web Tokens work well and are really easy to implement yourself.
I really dislike Passport. JWT tokens are easy to implement, and lots of OAuth identity providers (Google, Facebook) have their own Node libraries for authentication without Passport.
&gt; More often than not, they were dead on correct. Standards compliance can't be dead on correct AND use different syntaxes. Then you went on a rant about reddit. I guess your hole has been dug deep enough. Well played.
Essentially, yes. If you assign any variable the value [], immediately afterwards it is guaranteed to point to an empty array of length 0.
this is one of the more confusing modules I've used (by that I mean making your own auth, haven't tried the third party support) but it works quite well. I do wish the documentation was simplified though.
What's it giving me that Angular's not? (Other than trading off power for simplicity)?
There are many things that mean "worst" when programming. Since everyone was intent on ugliness, here is my take on worst time. Should finish in give or take 6.8051 years. var x = []; var y = setInterval(function () { if (x.length === 99) { clearInterval(y); } x.push(Math.random()); }, Math.pow(2, 31) - 1);
Most of us hang around here because are in the industry, me included and for many years too, so I wouldn't exactly say that it was over my head. Since you were down-voted quite a lot, instead of coming to the conclusion that it's reddits fault, maybe question the content of what you wrote? "Redditors" are just people commenting on a message board, there's nothing special about us that make us any more or less intelligent.
Okay I will adjust
Pfft. Most redditors are kids under 21 whose sole purpose in owning a computer is to play games. The crazier the response, the more likely it's true (and at least the last three times I asked someone their age, it was 15). So most people here are in the industry? No. And I doubt more than 20% are in any significant position in the industry and only have insignificant experience or knowledge. Getting downvoted on reddit is a badge of honor. Cause following the reddit crowd means you're doing it wrong.
Fair enough.
The shitty ones.
It can be deciphered, but it is difficult to grok at first glance.
There are too many people who don't believe that comments are good practice.
No. I pride myself on my ability to read regex and encourage others to work on a fluent understanding of them. They are important.
i've heard good things, just beware if you have used it as there have been a number of critical vulnerabilities in recent months : https://auth0.com/blog/2015/03/31/critical-vulnerabilities-in-json-web-token-libraries/ that's a good sign though, because it means the module is actively maintained by a responsible maintainer.
I believe you're running into this problem: https://jslinterrors.com/dont-make-functions-within-a-loop
RemindMe! 1 day.
Yeah you don't quite appreciate the separation it offers until you have some complicated mixed remote/local + oauth 1/2 scenario and you somehow manage to squeeze it all in without headaches.
I think we found the ass-burger...
Seems a bit unnecessary. Does anyone use this? Maybe someone could talk about some pros and cons? I think people would argue just as much about this as they would otherwise. 
I have yet to see a web application that isn't designed around mutable state and behavior, can you share some examples?
Pretty sure HATEOAS is unrelated from XML. JSONApi is yet another HATEOAS implementation proposal.
I just remembered something which may help you get an idea... Around 2001-2002, I bought [a set of these](http://www.visibone.com/javascript/) and brought it to work. It quickly became a reference to _always_ have at hand for the whole team. [This](https://www.visibone.com/products/ebk12-13_850.jpg) is a newer version of the DOM reference it included. Different highlights back then meant things such as "Only IE", "Only NN4", "W3C recommendation", "IE4 no (IE5 maybe)" (yes, "maybe", for some of them you couldn't even say for sure) or other variations. [The Javascript one](http://www.visibone.com/javascript/jr1_850.jpg) wasn't really as bad, with only a few differences, compared to DOM support, CSS or even [HTML](http://www.visibone.com/html/htcht_840.jpg). This is some years before jQuery arrived, but things were not too different.
[oh](http://amundsen.com/media-types/collection/) [boy](http://stateless.co/hal_specification.html) [yet](http://swagger.io/) [another](http://www.restdoc.org/spec.html) [HATEOAS](http://json-ld.org/) [specification](https://github.com/kevinswiber/siren)
Honestly i'm tired of seeing these specifications pop up and all end up being the same, I count five traditional HATEOAS-like specifications, not counting Swagger since it's documentation, but if you just look for hypermedia specifications, they're there by the dozens.
All of the HATEOAS implementations I've seen so far (not that many mind you) were based on JSON. Are there really "many" XML based proposals out there?
http://imgs.xkcd.com/comics/standards.png
[Original Source](http://xkcd.com/927/) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 1658 times, representing 2.4053% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_csekoxd)
My company is using it quite extensively. The biggest advantage is that we no longer waste time bikeshedding API structure. The biggest con is that the format isn't as self-explanatory as a lot of JSON APIs but I think it's more powerful than most. I particularly like the fact that each response includes hyperlinks to related resources.
It looks somewhat disorganized, not well structured. Or, better expressed, it looks sort of improvised. What I would expect from the introductory article of a series is: 1. a clear definition of the subject of study 2. a clear definition of the goals of the series 3. optionally, a brief introduction or overview of some _very general_ ideas 4. an overview of the particular subjects that will come later in the series Points 1 and 2 are not really clear. There's one sentence on JS&lt;-&gt;ES and there is, in passing, the mention that the focus will be the "JS interpreter". But this mention seems to lose importance after all the attention went to the "lots of things in a browser" explanation. Also, "focusing on the JS interpreter" is different from "Javascript as a programming language" mentioned in the initial "Backstory". After reading the article I'm still not clear if the series will be about JS the language or about JS interpreters. Point 2 in particular should include, imho, indications as to what kind of reader the series is written for. Is it for casual readers? Or will it require advanced knowledge? What is assumed of the reader and what will he get out. Point 3 is optional, but there's something I didn't mention: _very particular details_. An introduction like this doesn't seem the place to get into excessively detailed or excessively particular problems. The whole part on "Security Issues" gets focused on a very particular problem and I don't think is one that can be understood or explained in an introduction where you have yet to say anything about the subject. The last point is more or less your "Coming soon!" section. But as it is, I feel you haven't planned it enough. It looks more like a list of "things I want to make sure I mention at some point" than an overview of the actual subjects that will be explained. There are also a couple of minor details that I feel are _not correct_ or at least not correctly expressed. This... &gt; Unlike Java, C#, etc. it was built under the pretence to be a multi-paradigm language. Which made it unique. ...doesn't really make much sense. JavaScript is certainly [not _unique_ for being multi-paradigm](https://en.wikipedia.org/wiki/Comparison_of_multi-paradigm_programming_languages) and is not really that different from other languages in that respect. Also, I don't think being multi-paradigm was really such an explicit design goal as can be understood from your sentence. The mention of "use strict" in the context of "sandboxing and marking code as untrusted" or XSS is also quite surprising, as it's completely unrelated to that kind of security.
Checked your comment history and it appears I just got trolled! I'll cut this thread here.
JSONschemas, useful. This, not so much.
I would looooove to talk more about companies that use JSON API in production, so if you're interested in having me give you a shout-out in my talks, send me an email or something :)
That's my point. You're already using HTML5 (which is why it is no longer called HTML5) and you can mostly polyfill what isn't there. You're already using ES2015 and you can mostly "polyfill" the missing syntax using babel.
The thing that resonates with me the most in the article is the state of the documentation for a lot of the gulp plugins. I've spent the last couple of work days updating our build system and working around breaking changes. A lot of the plugins have about 50 words and two minimal examples, and you're lucky to get any sort of in depth explanation of how it works. They make me feel kinda dumb, it's like they expect you to know exactly how to use the plugin in your workflow from reading the GutHub one-liner. The build tools would be so much easier to use if the documentation was clearer and simpler. 
Are Flux and RxJS mututally exclusive?
By "mutually exclusive" I mean would it ever make sense to use them together? My understanding was that the FRP stuff is a fundamentally different flow model.
So you're bailing? Typical redditor. When faced with reality they attempt to make the topic about me when, in reality, they don't know what they're talking about so they bail. Coward.
I'd recommend OAuth. I've used JWTs as the format for the OAuth token, but OAuth as the actual authentication mechanism and the token is opaque to the end user. (The use of a JWT for the token means that the server can validate that the token hasn't been tampered with, is correct for this user, and hasn't expired yet all inside the same token, as well as allowing you to add custom fields to it - like your list of supported scopes)
Thanks for the clarification!
I don't understand, are you saying you'd rather declare which parts of a module are private rather than which to export?
col-xs-4 is a twitter bootstrap class. Make sure you have the twitter bootstrap style included. 
Awesome.. much more natural. How about making the font size larger ? people like that chunky stuff :)
yo I heard you liked APIs so I made an API for making APIs so you can API while you API
Looking at a real-life example helped a bunch. Thanks for the zendesk link. So from what I gather, each route has a thing it returns (a "base" if you will), and you can ask for other things optionally on a need-basis? In that case, I can see this being more useful. The abstract looking stuff in the doc really doesn't do it for me.
Not saying anything about this particular spec.. but just because someone as part of an effort to write maintainable code attempts to organize their effort in such a way others can benefit does not immediately mean that its better or worse than someone elses effort to do the same. Just because someone else put forth a similar idea doesnt mean some future individual should forego their efforts. As per almost every other technilogical advance.. some ideas will surface as great and useful, and others will fall to the wayside. You might as well make the same comment every time a new language is created. None of the things you linked are the same at all. I cant say which is best (more likely there is something to take from each), but if we all viewed new perspectives of ideas already manifested as pointless, no new technology would be created. Sorry for the rant.. i just dont see the point of the negative connotation expressed by "oh boy yet another." Honestly im glad there isnt only one suggested specification. 
You're right. Generally the system includes simple content related to a single entity, such as a post, but if you want to include all comments then you could ask for the post plus all comments and the system will deliver everything to you. Sometimes it's beneficial to include everything without making a special query, but other times the additional data may be too much to download in one request. At a minimum the references should be available in links so that your code can know where to get the data when it's needed, performing a lazy-load if desired.
Shameless plug: [there is a library that helps you get started with standard API media types](https://github.com/fortunejs/fortune), it covers 100% of the JSON API specification (and most recommendations) and there's [tests to prove it](https://github.com/fortunejs/fortune/blob/master/test/integration/serializers/json_api.js). My opinion: it is not a great format. Some of its concepts are completely unnecessary (relationship entities) that arise from its other shortcomings (lack of specification for array operators). Nowhere in the spec mentions REST/hypermedia, and it is not designed to conform to REST per se. Example: one cannot traverse JSON API given a single entry point and its media type, an "index" payload is not defined in the spec. It is also closely coupled with a single format (JSON) and application protocol (HTTP), so much that it dictates what query strings the server should respond to, and what response status codes may be given (this limits use cases such as 3xx redirects). Alternatives: Hydra, Siren, Collection+JSON, Mason, Micro API, and more. People love to complain about the diversity of media types but don't want to admit that just sticking to any specific media type at all is far more helpful than using generic `application/json` or `application/xml`. Also there's not really that many, one only has to peruse the [IANA registered media types](https://www.iana.org/assignments/media-types/media-types.xhtml) page to notice that hypermedia types are by far a small minority.
If possible can you guys add a link back to https://github.com/Hypercubed/angular-ecs ... I would appreciate it.
I would really appreciate seeing a simple todo project of this methodology. Rxjs is awesome from what little I've seen.
I... just... kind of deploy them.
Wait... you're not OP...
That was my initial plan as well, release early, release often. Until I realized that I risk paying a fine of up to 500 000 euro if I don't inform the user about the use of cookies. That got me thinking...
I use this website in order to check the most important items in webdev. Hope it works for you -&gt; http://webdevchecklist.com/
Really good link! Even if it doesn't cover legal stuff, it's still really useful 
What about this links? http://developer.android.com/distribute/tools/launch-checklist.html (just in case you're developing for android)
Great. How fast is it?
Wow, that's exactly what I wanted, may I ask, how did you move the cookie and add the background, I may of just missed it, or was it something new you added?
You may ask! I moved the three sections around using position:relative; left:; top:; That bit of css allows you to move elements around relative to where they would normally appear in the document. For the background, I just added it as body { background:url('url of image goes here'); background-position:center; background-repeat:no-repeat; }
Tell me more...
Hey everyone. As a disclaimer, I work for MaxCDN. However, our team recently interviewed jQuery and definitely think it's worth a read for anyone who uses it. Some key points in the interview include: - jQuery core is actually on about 63% of the top million sites in the world and 17% of the entire Internet. - jQuery averages about 15,000 hits per second to their CDN and 99.8% of those are cache hits. - jQuery uses CloudFlare to mitigate DDoS attacks
IMHO--yes, it's fading. ES6 (ahem..2015) is now [approved](http://www.ecma-international.org/publications/standards/Ecma-262.htm) with greater browser support than a couple years ago, and transpilers like [babel](https://babeljs.io) make non-implemented features usable today. If you're a fan of the syntax and feel you're more productive in it, use CoffeeScript. It'll still be around and supported for a while regardless of popularity at this point. But if I were starting a new personal project from scratch today, I would write it in ES6/7 or my personal favorite "JS-replacement", TypeScript.
The programmer works in mysterious ways. Thank you.
Did you post this because imagus is not working with imgur? Because that's the problem I'm having today.
Good architecture? No seriously, you don't care about ugliness of angular?
https://github.com/caseywebdev/cursors
Get off my lawn. Jokes aside, have fun with the new stuff coming out.
Yeah, but can they change shape to make them the same shape as the button?
[You right now](http://1.bp.blogspot.com/-Q4INLfjtcro/UMOZZk41ctI/AAAAAAAAah0/nU9R2efTfA4/s1600/simpsons++2.jpg)
Yeah... you can just use the exact same technique I used on the &lt;body&gt;. Just use it on a button: button { background-image: url('http://sustainabledish.com/wp-content/uploads/2012/07/banana1.jpg'); background-position: center; background-repeat: no-repeat; background-size: cover; /*You can mess with this to get different effects*/ font-weight: bold; /*not necessary*/ border-radius: 4px; /*not necessary*/ }
Everyone was really into CS for the fat arrow. Much less need for it now
Pretty cool! The entire time though... I wanted to make the little guy jump! You aware of any need for a junior/entry level developer? html/css/js
How about [free](http://eloquentjavascript.net/)? Did you try [Codecademy](http://www.codecademy.com/en/tracks/javascript)? I think they do a great job teaching the basics. You do a little reading and then have to pass a little test.
Right, whenever I add it into &lt;body&gt; (I put it in there because I have been researching what body and head means, head is what it loads before the page is visible, I think ;p) and it just makes the whole page go haywire, the buttons move, and the text moves accordingly to fit in, do you think there is another factor making the buttons change position? (I probably sound really stupid asking this, but this is the only way Ill learn how to code this)
no, i'm not having an issue with imgur links. I want to create a similar behavior on my own websites. I find refreshing the page refreshes imagus. 
Most of the great features will be in ES2015/2016. TypeScript offers something different entirely and will be integrated into Angular 2.0 &amp; Aurelia and also works well with React. It's going to remain big, but I think CoffeeScript will slowly fade now that most of its good ideas are becoming more commonplace.
That Eloquent JS looks promising! I did try codeacademy and completed all the free javascript, html, and css courses, but it left me with no direction on where to go from there. It was a great intro, for sure, but I still don't know how to make anything meaningful.
Define "meaningful." Make a calculator, calendar, game, clock, etc.
Meaningful (adjective): Having meaning, function, or purpose. Meaningful (adjective): Fraught with meaning; significant: A meaningful glance. See Synonyms at expressive. Meaningful (adjective): Having meaning, significant. --- ^(I am a bot. If there are any issues, please contact my [)[^master](http://np.reddit.com/message/compose/?to=Spedwards&amp;subject=/u/Define_It)^(].) ^(Want to learn how to use me? [)[^(Read this post)](http://np.reddit.com/r/Define_It/comments/31vrec/define_it_how_to/)^(].)
Just to pedantically clarify: to "jump the shark" means doing something so zany or over-the-top as to make yourself look ridiculous and make it clear that you've lost your mojo and are now just desperate for attention. CoffeeScript definitely lost some momentum but hasn't jumped the shark in that sense.
Those are good points. I'd like to make it clear though that my boss isn't "toying" with them intentionally. He legitimately believes that it *should* only take about 30 mins to do this test. Despite several of us trying to reason with him otherwise. I've been a dev at about 3 different software companies in the past 6 years and I've had to take some sort of coding assessment at every one before I was hired. Haven't seen a company that doesn't do that yet... I just feel that my boss takes it a bit too far. I've never been given a strict time limit.
[Perhaps more relevant still](http://www.google.com/trends/explore?hl=en-US&amp;q=es6+-yamaha+-kawai+-varrstoen+-motif,+coffeescript,+typescript,+EcmaScript+6&amp;tz=Etc/GMT%2B6&amp;content=1). (Hid the names of a few manufacturers with ES6 product models.) Note that under the related search phrases for CoffeeScript is "CoffeeScript to JavaScript." I left that bit in because it's too ambiguous to make a clear cut guess about the intent of most users. However, we don't see that language in any of the other related search results.
Right, how can we possibly fix that?
Do you mean like 16:9 or something like 720x1080? 
Yeah, you're right, there are online assessments, writing code on a white board, etc, but anything I've done has been during a tech interview. Never have I been assigned homework so to speak. Seems strange anyway since a guy could theoretically hire out his homework. I just feel like he may be inadvertently running off the best talent with his approach. 
Lol, true but I'm not wrong.
Alright... try it now: http://codepen.io/ForScale/pen/OVOLOM
Still, whenever I put the code in, it seems to be moving the buttons around, and I noticed, it doesn't change the background of them either.
Of course! I'm a self-taught, intermediate/novice (html/css/js) myself. I love discussing development/programming, so feel free to hit me up on here any time! Here's my CodePen with a bunch of little projects (if you're interested): http://codepen.io/ForScale/public/
I'm confused now... Are you saying you want each button to have a specific background image? And you have to copy all the code over, not just the css.
Can you post the test? (just out of curiosity)
Very nicely done. Casing with fat arrows is particularly nice.
Ok, because I'm really bad at explaining things, Ill try to do it properly this time (Really Sorry!) This is what I want it to look like when its available to buy: http://i.imgur.com/CPseSAP.png and I want it to look like this when its not available to buy: http://i.imgur.com/q5RwZRu.png
what I did was for every interval .push([]), and then in the other function that assigns the objects I made a variable var currentSpot = tenMSevents.length - 1; and the tenMSevents[currentSpot].push(new object). This creates a lot of empty arrays but thats great because then I have a way to keep track of when things did or did not happen. 
Introduction post for Redux: https://medium.com/@dan_abramov/the-evolution-of-flux-frameworks-6c16ad26bb31
I avoided using "ES6" because of the interferences shown by /u/atomicfiredoll which add a certain distortion to the comparison. To be fair, though, I do believe that it's not only ES6 going up. I think it's a combination of several reasons, not just the gain in popularity of other options (TypeScript? Maybe. Certainly TS had a huge boost with the Angular/atScript affair). Probably some part of it is that CS had some _novelty_ factor and that is something that at one point always fades out.
u wot m8? did you use grep? :p
Last warning about personal attacks.
meh, the javascript community does not need any more frameworks.
Thanks for kindly letting me know about the guidelines.
https://github.com/swfobject/swfobject is pretty much the way to go. I think it (or a version of it) might also be included in the flex sdk (http://www.adobe.com/devnet/flex/flex-sdk-download.html) which is probably your best bet since it will be maintained with Flash by Adobe as swfobject is already no longer being worked on.
thank you
It's easy enough to make them look however we want... I can make them look a certain way and stay that way, it's just that I don't understand the javascript (because it's Angular or something) well enough to know where the colors are being specified. We need to know where in the js the color is being changed. 
**over 100** people, in a year? are you all insane? if you still haven't found someone, after all that, i think it is indicative of an issue with your process...
Or maybe deeper. Maybe the job/company/project/compensation is not interesting to start with.
Its gotten to the point where if you are using CoffeeScript you are missing out on features, mostly due to Babel. Think ES7 decorators which are popular in React/Flux world, will be used in Angular 2. ES7 also has async/await (which IcedCoffeeScript offered). Also some ES6 features like using variables in dictionary keys `{[foo]: 'bar'}`, and some of the destructuring stuff is not supported by CS.
yah, like advertising for a junior position (and junior pay), but looking to fill a senior one. or thinking they need google quality people to push out brochureware websites.
You raise a valid point - there is not actually very much D3 in there - but there is a little! It's utilising the D3 timer module.
Yeah, let me know!
Finally, I'm starting learn to actually do stuff ;p
Ooh! Yeah, that looks good! What'd you do to achieve that?
Ah... I see it, you scaled it to .75. Nice!
Learned from what you did, plus hopefully about to add something
It was made to take advantage of the tricks asm.js later formalized. Then it was made to generate asm.js.
The achievements popup (eg. "Wake and bake") pink texture: http://i.imgur.com/CPseSAP.png
honestly with rxjs i wonder why i need angular at all...
[Yes you did.](http://www.reddit.com/r/javascript/comments/30wbiy/sunspider_spartan_vs_chrome_4102272101_numbers/cpx0mem?context=1)
I needed a web JSON Schema validator that supported deeplinking to a specific state, and also supported referencing multiple schema files. So I wrote one! It's my first modular Javascript project too, pretty exciting! Github at https://github.com/hufman/json-schemata-validator
I'm not too proud of it: http://codepen.io/ForScale/pen/BNmapw
Yeah? And Java 8 is just now getting lambdas, so not all languages are equal, nor do they change at the same rate. If you like LISP go program in LISP. Last I checked this was /r/javascript, where posts are made in reference to information and advancement to **javascript**.
If your boss has unrealistic expectations, and it shows during the interview process you've probably lost a lot of developers just based on that. I know I wouldn't go any further if I ran into that.
I'm not sure "missing out" is what really happens. CoffeeScript is a different language, with different features; ES6 took some inspiration from it, as Coffee did from Ruby, etc... The fact that it compiles to JS doesn't mean you are missing out. If I had to compare features, yes, CoffeeScript supports computed properties, with string interpolation, like `{"#{foo}": 'bar'}`. In ES6 destructuring you can't do `var [a, ...bs, c] = [1,2,3,4,5]` and expect `var a=1,bs=[2,3,4],c=5` while in Coffee you can do `[a, bs..., c] = [1,2,3,4,5]` and it works. And ES7 decorators? I'm not sure how they improve upon higher-order functions. People that use Coffee, from my experience, don't use it instead of ES6; most people use it because it is familiar to them coming from Ruby, or because it reads better to them than JavaScript. In this regard, ES6 has "missing features" as well.
Define "word".
It's not that we didn't find *any* candidates. There were some very good ones and some excellent ones. My boss is just very very picky and I think it is unnecessary. I'd love to hear some suggestions on how to improve the process if you have anything in mind.
Be sure to check out [Cycle.js](https://github.com/staltz/cycle) if you haven't already. It is an RxJS-based library, uses [virtual-dom](https://github.com/Matt-Esch/virtual-dom) instead of React, and it just makes a whole lot of sense.
Wow, thanks for writing all of that, it was really insightful- I've never really heard about early webdev from an insider's perspective. I'll make sure to remember my predecessors' struggles when I write code from now on.
You're welcome. I sure hope you'll succeed, we need more competent frontend developers.
I'll second Eloquent JavaScript, and I highly recommend supporting the author and picking up a physical copy. It's handy to have by the bedside for a little light reading before bed.
1 problem with "homework" is that most devs have some form of work they could show or some references but who has time to do these things anymore? Also our field is so easy to land work (I could be tunnel visioned so please feel free to correct me), so why would anyone bother since it already feels like a distrustful thing. I think filtering better first by knowing what you want and what you will consider minimum qualified for that role and then spending the extra time to get to know the person. Not just technical questions, but learn who they are. I myself have hired a bit of folks and have been the interviewie many times and I use my experience from both and do not take the position of thinking I know more than the other person. Edit: these are just my thoughts on this subject and am actually curious just as you are to other strategies. 
A good way to reset his expectations on the test would be to have the existing people under him all take it, and measure the time they took. Assuming they are familiar with the framework you reference, one can assume that a potential hire will take significantly longer that you would due to that alone. If he sees his existing developers making trivial mistakes such as syntax errors and such, then that could also soften any unreasonable expectations on that front.
Typescript looks interesting, I'll check it out. Thanks!
Fire your boss (get him out of the process).
Thank you for that clarification. I actually remember that addon pack, if only because it was a welcome change from all the AOL disks that came in the mail.
how many did you hire? how many positions? interviewing is going to take you and the boss out of production for (on average) 4hrs each. that's 800hrs wasted on interviewing in the last year. 100 candidates, each spending 4hrs + 8hrs dealing with your "test" is 1200hrs gone. that's a *year* of manpower, down the drain, just interviewing people! find someone who is on the very-good to excellent spectrum, hire them on a temp-to-hire contract for 30 days, and even if they don't work out, *you are still saving money/time*. you could pick someone at random who knows what the acronym JSON means, and pour 500hrs of training into them, and still be up.
&gt; My narrative wouldn't be complete without a honorable mention of another browser that never had so many users, but was an absolute work of art. He said, without actually mentioning said browser.
Congratulations, you have found the hidden bonus question! Jokes aside, it was Opera.
I'm a noob/intermediate, so take what I say with a grain of salt: Okay... looks like your dealing with objects and accessing keys and values within objects. var P = { "dog": "Poodle" } var p = { dog: "poodle" } alert(P["dog"]); //alerts Poodle alert(p[dog]); //does nothing because the syntax is wrong... dog is not defined I don't know... is there more to the question? There has to be...
That's what I figured. I've used Opera from 2001 until Chrome first came out. Maybe I should switch back.
Get one or two of your good programmers together and observe the candidate struggle through a problem on the whiteboard. Don't require perfect runnable code, you are looking at the logic and their thought process. If the candidate jumps straight into the problem and heads down the wrong path, or doesn't acknowledge hints or direction from the interviewers, then it is not someone that you want. Same if they stress out and can't even think. You want someone who will work through some examples, ask questions, define the question fully and potentially real the problem down into small pieces and get to work. The problem doesn't even need to be easy, it doesn't matter if no one ever solves it, you are looking at how they approach difficult problems.
The button is being disable when the ng-disabled (attribute in the html) condition is met. 
I rolled my own using Lenses. Most of the existing implementations I found tried to use reflection based approaches that were a lot less flexible.
 var dog = 'corgi', P = { dog : 'Labrador', corgi: 'Doberman' }; When we refer to anything that is inside double `"` or single `'` quotations, we are creating what is called a ['string literal'](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#String_literals). So, when we say: P.dog // &gt; 'Labrador' This is the same as `P['dog']` -- this will look for the *key* of `dog` in your ['object literal'](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#Object_literals) `P` When we say `P[dog]`, it would *evaluate* to `P['corgi']`. `dog` is a variable with the value of `corgi`. So to take this principle a bit further, it would be this basic idea which you would use to [traverse an array](http://stackoverflow.com/questions/3010840/loop-through-array-in-javascript). var i, n, P = ['cat', 'dog', 'cow']; for (i = 0, n = P.length; i &lt; n; i++) { console.log(P[i]); } Try it here: http://codepen.io/anon/pen/NqwPVq
It depends exactly how you structure it. You could have "Named" actions like Flux and then have stores listen into the events they care about. I'm not a particular fan of this approach, but it works. In my case, I treat Stores as "dumb" containers that simply use "Rx.Observable.Scan" to apply functions of type "state -&gt; state" onto the previous state. I then wrap the output state in a "Cursor" that contains a lens and a pointer back to the input bus. Any component with a reference to the cursor can pass a state manipulation function to the cursor and it ends up back up to the correct store, using the Lens focus on the relevant part of the data structure. 
This is some solid advice. However, from my experience some people just work differently. Some folks are great at "social programming" - that is, they work really well with direct input from others and with others standing around them watching them and bouncing off ideas. These people are also usually good at pair-programming. I, and most of the other devs I know, are just the opposite. For some, it's hard to think critically in a socialized situation. However, you turn us loose on our own and we can tackle a problem independently and usually in novel ways. I would recommend a situation like you are describing, and in addition to that, give the candidate a simple code test (maybe something along the lines of FizzBuzz) and leave them alone at the computer for about 20 mins before you come check on them. This way, you not only find out if the person has the prerequisite skills, but you find out if they are comfortable coding directly with other developers or if they are better working independently.
oh wait i figured it out the path is assets/&lt;the folder it's in&gt;/recorderWorker.js. not assets/javascripts/&lt;the folder it's in&gt;/recorderWorker.js super confusing 
Take a look at [this](https://github.com/eorroe/NodeList-Prototype-Extension/). I apologize ahead of time, not the best written README
Your boss is the problem, not the process. 
[window.prompt](https://developer.mozilla.org/en-US/docs/Web/API/Window/prompt) returns a string always. You'll need to convert that to a number using [parseFloat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseFloat) or [parseInt](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt).
Prompt returns a string, so you need to convert it to a number using parseInt or parseFloat var num3 = parseInt(num1) + parseInt(num2);
Thank you very much!
The hyperlinks in the response is actually my gripe with it. "Link" is an HTTP Header built specifically for the purpose of providing links to related content and is used by many APIs for pagination. APIs should return the requested data with as little enveloping as possible. As an example, here's Github's API documentation on pagination: https://developer.github.com/guides/traversing-with-pagination/
I don't think I've ever seen them not follow the order of being added, but the spec does say: &gt; Although all EventListeners on the EventTarget are guaranteed to be triggered by any event which is received by that EventTarget, no specification is made as to the order in which they will receive the event with regards to the other EventListeners on the EventTarget. http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-flow-basic-h3 So if you're that worried about it manage the triggering yourself with a single listener that will iterate through your behaviors in the specific order you need.
[Was it this?](http://techjobs.me/), not sure if this is the right one but it's a militaristic jobs site posted about a week ago.
&gt; Was it this? I don't think so, if I recall correctly the color scheme was an orangish. There was a search across the top (but below the orange nav bar) and the job listings appeared below the search row. Thanks for that though, the more the merrier! 
If only node had a module loading system so there wouldn't be any need to define globals like this. 
Awesome, I think we got the help that we needed, thanks a lot!:)
I don't like the 'take it home' assessment approach. I'd rather sit down with a candidate and work through a problem with them. This gives me a better idea of their level of technical knowledge, how they approach problems, and how they work on a team. It can be difficult to bring people around on this type of thing though, there's a lot of people out there that think everyone should be able to jump through their obstacles to get employment, and you'll miss out on a lot of good people like this. Not everyone will know everything, but if they can take feedback, bounce ideas back and forth, and have a solid foundation; they will ultimately be much more successful on your team.
Useful post for absolute beginners, but why no mention of arrow functions?
There are some good reasons. Polyfills, for example (`Promise`, `Map`, `Symbol`, etc.), but I agree - it is a mistake, in this case.
And [most.js](https://github.com/cujojs/most/tree/master/test/perf), my preferred JS Observable lib, and damn fast!
Not currently, but I'll probably clean it up and stick it on Github at some point. 
I wonder about the performance impact of Function.bind. If Function.bind creates a new function each time is it more preformant to just scope a reference (`var _this = this;`)?
This must be tagged as "jsporn" ! :-)
https://channel9.msdn.com/Events/ALM-Summit/ALM-Summit-3/Technical-Interviewing-You-re-Doing-it-Wrong You ask me such questions and I leave - no need to waste both our time. I don't think I'm the "best" programmer, maybe not even top 5%, but I'd say I can claim top 10%. There are a lot of people faster than me, but I'm thorough and clean, and I DOCUMENT. Lots. And not bullshit comments like "// This line adds a and b" but "meta" explanations for why I choose certain concepts, why I coded something sub-optimally (deliberately), where in the code they might to have to refactor when they change this part, etc. And I take positive risks: No budget to refactor? I do it anyway, I find the time, and I risk having to do lots of overtime because if my idea doesn't work I'm left fixing it all by myself on my own time, and I'm responsible alone because if it doesn't work I started rewriting major code parts despite being told there's no time and/or budget. Questions on "code this algorithm" don't get any of those aspects. I once had a major company hire me (as a very expensive freelancer) even though I could not answer what a left outer join is. It's not that I really didn't know, later in the job I constructed large complicated SQL queries with ease, but I hadn't done it in many years and it always takes me a few days to change my "working set" of knowledge that I've available in my brain. And I heavily rely on the Internet, why reinvent the wheel, why know everything when StackOverflow has so many people willing to help? There are many META-properties of developers like willingness to take risks and therefore responsibility, willingness to communicate (i.e. document - and *how*) and ability to empathize with other programmers (meaning being able to know what other people actually *need* or find useful when you write comments), that such stupid interview techniques are unable to capture. Pure coding IMHO is the LEAST important of the skills in most cases. Very important is the "atmosphere" at your place: How easy is it to admit not knowing things and mistakes? And I mean the gut feeling not the rhetoric. If you mess up, is your first impulse to go to your boss and open your heart? A place where failure is safe is good. On the other hand it needs people willing and eager to learn. From what you say it sounds like if I did get hired it's a place where I might be reluctant to own up to mistakes and instead have an incentive to appear invincible and cover up my (numerous) mistakes. 
Makes sense. Keep up the good work, sir.
or write code that takes context as an argument. if you want to get rid of this...stop using `this` *instead of* foo.prototype.callServer = function callServer(){ $.get('some/file.json').then(function onSuccess(data){ this.displayMessage(data); }.bind(this)); //bind the outer 'this' context }; *do* var foo = new Foo("bar"); var promise = callServer().then(save(foo)); function callServer () { return $.get("some/file.json"); } function save (foo) { return function (data) { return foo.save(data); } } This would look a bit cleaner with a proper functional lib to handle the curry, but you get the idea.
Work on Atom started quite some time ago and predates tools like Babel and TypeScript. The food-for-thought question here is: If they were choosing their primary compile-to-JS language today, what would they go for? 
Fortunately, I believe Chrome will be getting arrow functions within the next month or two! It's in Canary at least.
Why do you ask that? There is nothing in the implementation that should be bad for performance - no hidden cost. But I don't have benchmarks.
Right, stuff like FRP has been around in academia for a while (often way back in like the 50's-60's-70's, but in this case 1997). However I can't believe it's ever being used in the industry, but it might soon in the web world (e.g. Elm). I actually find the web world to be quite innovative.
It may be your area but I just went through the hiring process of 3 different places. None gave me take home work, I did phone interviews and then showed up for the in person interview. I discussed my current projects my past ones etc. The tech questions were functionality questions irrelevant of language. More to see how your thought process went. My point is, that I think your boss might not be doing what's best for the company. If any of the three places I was interviewing at would have asked me to do homework, I wouldn't have even bothered calling them back. There are plenty of opportunities out there right now. I was being fought over and I live in the SE USA where jobs aren't as readily available as other places. 
You have to have an extraordinarily relaxed atmosphere that makes nervous candidates immediately feel at ease for this to work, or you are going to weed out not just "undesirables" but people who are merely nervous in interview situations. Which is a lot of them. http://www.salisbury.edu/careerservices/students/Interviews/Stress.html Mammals need *time* in a new situation, it's how our brain works. ALL higher-level animals. Ever notice how you enter a new situation (party, waiting room, anything) and merely by sitting there for an hour you suddenly feel sort of "at home" and superior to the new guy who comes in? You have not done anything, you just sat there! If you insist on going "all-out" in interviews you decided to fight very basic brain structure. I bet if you ask someone a month after hiring when they are secure in the job and with coworkers the same level of questions people will do a lot better, one because of the above and two because they now have the "working set" of knowledge in memory that that particular job requires. One of the best things you can do in an interview process is take out the pressure. Don't be "you dare enter our holy realm and ask for a place among us highly paid gods?" And acknowledge a possible failure to hire right away, but place it in perspective *in advance*. By making a failure more (subjectively) more likely right away it takes away pressure "if I fail my life is ruined" (even if only for a few days) -- I'm talking about *feelings*, not objective realities. The smallest and least significant part of our brain is about the latter. Get the "animal brain" to relax so that the "thinking brain" won't be hindered by inhibiting signals from the former. "Stress" (which is just a neuronal network status) literally inhibits synaptic connections. [Depending on how empathetic interviewers are interview stress may help](http://thebrainbank.scienceblog.com/2011/11/20/could-stress-actually-help-you-pass-a-job-interview/), but in an interview like OPs where the interviewer focuses less on the person but mostly but on "achievement" that won't help. There IS a role for stress-based interviews, when you higher air-traffic controllers or pilots for example. I don't think there are many roles in IT where that is applicable. Presentation on interviewing of programmers: channel9.msdn.com/Events/ALM-Summit/ALM-Summit-3/Technical-Interviewing-You-re-Doing-it-Wrong
I think it was an experiment that didn't really go anywhere itself, but it's inspired other work. It's not been touched for a couple of years.
www.interis.com/ing
&gt; However, in the bind() case, you're also creating a copy of that function with the value of this set to the passed argument. You're not, it just creates a function that uses `call`, source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind &gt; The bind() function creates a new function (a bound function) with the same function body (internal call property in ECMAScript 5 terms) as the function it is being called on So what's happening when you use bind using your example: this._myFunc = this._myFunc.bind(this); Is the equivalent of: this._myFunc = function(){ this._myFunc.call(this,arguments); }
I wrote up a comparison here: http://www.reddit.com/r/javascript/comments/39cere/typescript_vs_flow_results_from_our_investigation/ Summary: if you're working with an existing codebase and want to move over gradually then Flow is the correct option. If you're starting a new project from scratch (or it'll be easy to convert an existing one) then TS is the correct option.
What about universal js?
How about JavaScript?
Why not Koa? Yield is da bomb.
Yeah, most of the scale is really on the back end though and aside from Node, is done in other languages.
It couldn't be called nerd-stack with Koa. nkrd, ndkr dnkr? Nope.
Switch to vue.js and call it [nkvd](https://en.wikipedia.org/wiki/NKVD).
Require uses the flyweight pattern. When you do require('blah'), require caches 'blah' in a object in require.cache using the __filename of the module as the attribute key. On furthe require('blah') calls it returns the cached version instead of reading the file. 
It's not. Isomorphic means that two categories can be converted between each other without losing information. The problem is a JavaScript program isn't a category. Categories have a way to compose operations on them and an identity function, and you're probably going to have to stretch to make that work for JavaScript in any meaningful way. Isomorphic is just abuse of a strictly defined mathematical term that's super useful in programming already. It's not helpful. 
Ladies love JavaScript 
One JavaScript. ^I'll ^show ^myself ^out.
I've been meaning to try out web workers so I might play around them and see if I can get some other threads involved in the fun. Though for some reason either chrome or windows is capping the script's cpu usage on my computer - none are maxed out for me, and it struggles to get 20fps at 500k. I wonder if requestAnimationFrame has anythign to do with it?
Your boss sounds like a dumbass
Delightful Javascript?
Yeah, at one point someone started to get it to work for asm.js, but that too appears to be abandoned. It would be interesting for someone to pick up the torch. http://jlongster.com/Compiling-LLJS-to-asm.js,-Now-Available-
http://www.reddit.com/r/javascript/comments/3at6su/nerdstack_isomorphic_node_express_react/csfwrrf
Isomorphic is a term used in disciplines other than mathematics. In evolutionary theory, it describes "similarity in organisms of different ancestry resulting from convergence." The use of isomorphic to describe the convergence of front-end and back-end code is very in line with this definition.
I know, but it creates Emscripten-like output which follows the same basic principles as asm.js (and is its inspiration).
&gt; CoffeeScript supports computed properties. My bad, as of Feb 2015 it does. &gt; ES6 has "missing features" as well. By "missing features" I am referring to the ES6/ES7. Traditionally CS could do everything (more concisely) and more. But now with Babel, it can do everything ES5, most of ES6 (but more verbosely - e.g. computed properties `{[foo]: 'bar'}` vs. `{"#{foo}": 'bar'}`), and will miss out on ES7. I was a long time CS user, but I would be missing out if I continued in CS at this stage, and the few features available in CS but not in ES6/7 do not justify it for me any longer.
&gt; Nowhere in the spec mentions REST/hypermedia, We don't say the words, but links are a core part of the spec. I'm confused, because you say you don't like 'relationship entities', but that's a core hypermedia concept: linking. &gt; and it is not designed to conform to REST per se. Example: one cannot traverse JSON API given a single entry point and its media type, an "index" payload is not defined in the spec. Just because we don't tell you what goes on the index doesn't mean you can't put something as your index. In any case, if you prefer one of those other types, they're great too. Each media type has a problem it's trying ot solve, and we have a specific one. If you're not trying to solve the same problem, then another format will fit your case much better.
While it's true that there's a `Link` header, would you also argue that HTML shouldn't have `&lt;a&gt;`? Where do you draw the line between in-body and in-header? &gt; APIs should return the requested data with as little enveloping as possible. A lot of stuff in JSON API seems like it's extra, but it's actually not. It's simpler overall, because it considers both simple and complex cases, rather than optimizing for the simplest case.
very well done.
I've been using supersonic ever since and overall it's pretty solid. There are a few little quirks to using everything in the work flow but I'm happy with it so far. I'm hoping I'll be able to implement phone gap plugins easily since I know I'm going to need at least one. It's simple to get up and going with it, I would definitely recommend it!
It's probably also worth remembering that most programmers come from an engineering background, which I expect should imply that they've come across the mathematical term more often than any other definition. Which I think is important because someone with any kind of math background might actually be confused by the use of the term in the way it is being used by JS devs.
The trouble is with the javascript operator '+'. It means two things: 1. Add numbers 2. Concatenate Strings. Since you have strings, javascript assumes you mean to concatenate them. I used to solve this by doing this: var num3 = num1 - -num2; That's because the '-' operator is unambiguous, always meaning subtraction. I no longer do it that way in favor of this way: var num3 = Number(num1) + Number(num2)
Where's the Javascript?
such little code. very cool.
We could work on it over the next few days... 
Ok, sure, only if your up to it though, I don't want to force you to do something.
I hate all the negative voices that jump up whenever you post anything on reddit. Let me join them though: I can't think of many things worse than *seriously* being forced to try to work on the same code with other people. For fun to waste time and not accomplish anything - sure, but why not go to a pub instead? But I fear this is meant to be serious? &gt; Concurrent text editing allows for engaging and efficient collaboration that would otherwise be impossible. OMG. Has anyone tried not just cooking with other people, but working *on the same pot* with other cooks?
No worries! I'm a little busy with work, but I'll have down time over the next few days... We'll keep working on it! If you haven't heard from me in a couple of days, shoot me a message to give me reminder! And feel free to fork the CodePens and work on them yourself!
Awesome!, Its nice to hear that you are going to help, if you weren't I don't know what I would have done ;p
there are of course links but they are rather underspecified. the basic example which I keep bringing up is that there is no index specified therefore no guaranteed way to traverse a jsonapi. collections are not discoverable by default. side loading, embedding, compound documents, whatever you wish to call them, is a great feature. however I would prefer for features to be discoverable. 
Fair enough. I think that this is a 'we only have a spec, not user guides' issue... as I said above, we don't have a _specific_ index concept, but that doesn't mean there's no index.
What problem does this solve? What are the benefits over other stacks?
your eg site , has a listener on the input box , which on typed a character does a search similar to how google search works. Clicking on any of the item, takes you a new page (and not does AJAX) whose id is matched with the id of the clicked item. Lets divide the work in 2 parts * A simple web page server * Client Server responsibilities : * Support a search via an GET API with search keyword in the query string * Supports a GET API which gives you data to rendering given some id. Now how to mantain the data thats upto you. If data is very small, you can have an object map for eg {'foo' : "This is data bar" } or else depending on what u want you might want to keep a DB. Why i am exposing this API is i want to do an AJAX and do a single page app instead keeping a new page for every request which is the traditional way to do it. Client : On the client side apart from your HTML and CSS, you will have a JS which will handle all this. On typing a character it will do an AJAX call to get the result from the server and display it in the dropdown. On clicking on a specific item , again you will do a request to server to fetch the data, and display it in your page. Everything in a single page app. Things you need to get started are * A simple Node JS server, (or any other server language you prefer) * Simple client JS and HTML5 with some CSS for beautification. There are tons of resources to get started on both of them. Hope it helps :) 
And if you want the ultimate configurable interface you want to use uzbl.
That's python. Wrong Sub.
Sign me up
Functional-ish I'd say. JS has some things you need to be aware of when writing functional code. Here's an article that touches on a few: http://awardwinningfjords.com/2014/04/21/functional-programming-in-javascript-equals-garbage.html But what you're saying backs up my point, these things have been around for a long time but it's only been fairly recent that people have started talking about it. 
For anyone who is interested in this kind of thing, I implemented a similar solution in [jQuery-Keyframes](https://github.com/jQueryKeyframes/jQuery.Keyframes/blob/master/jquery.keyframes.js#L175-L176). It also handles css generation and has a couple of [nifty plugins](https://github.com/jQueryKeyframes).
Sounds cool, but WebAssembly is coming.
Author here: I can confirm what hahaNodeJS said
Or any of the numerous server-side techniques for avoiding client-side injection attacks, or for optimizing data flow (especially with super-large datasets)
Ok, this makes sense, Thank you for all your help :D
&gt; the JSON API (presumably application/json) It's actually `application/vd.api+json`: http://www.iana.org/assignments/media-types/application/vnd.api+json &gt; maybe you're saying that since the HTTP spec provides Link and HTML provides &lt;a&gt;, I should be offended at duplicated standards? It's not that you _should_, but I thought that you _are_. I was going by this, from your first post: &gt; The hyperlinks in the response is actually my gripe with it. So I was pointing out a different media type that also has in-response links. I guess what you're saying is that that's okay because it's legacy, but no media type that's now minted should include in-body links? Apologies if I'm misunderstanding your argument here. (and yes, you're right that `&lt;link&gt;` is identical, and would have made my point stronger. I'm more interested in body vs headers than the specifics of the particular implementation)
Your argument makes absolutely no sense to me then. I'm sorry, I'll just stop and we can agree to disagree.
Example of the package being used to proxy calls to a Web Worker running Lua: http://blixt.nyc/js-luaworker/
Just run it through the coffeescript compiler right?
So &lt;20% of market share supports arrow functions. How does this not equate to &gt; Browser support is completely lacking for arrow functions at the moment to you. Just because support is coming in the future doesn't change that there is little support in the present.
You are binding the `this` of the function, it's really not that hard to reason about.
thanks! I will look into it. I just adopted for same reasons outlined in SO. I will update it
A couple things. First: var k = null; (k).isTrue(); &gt; TypeError Second, how hard is it to do: var foo = "a thing"; !!foo; &gt; true foo = null; !!foo; &gt; false I appreciate the effort, but seems a little silly to have a one line lib for this. Let alone bower/npm installs. Alternatives to `variable?true:false` =&gt; `Boolean(value)` `!!value` for checking those vars.
This looks fascinating, but what exactly does it do? Is it a code coverage tool? Is it a test runner?
Hey man, I appreciate the feedback! I been developing JS for a few years and I would appreciate it if you gave me feedback. I always worked in environments where I was the only developer, so I can definitely see if I adopted terrible practices and stuck with them. If you want, I can create a PR in github. Or even just a simple list of what I'm doing wrong? Thanks again
 navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia; if (navigator.getUserMedia) { navigator.getUserMedia({ audio: true, video: true}, function(stream) { var video = document.querySelector('video'); video.src = window.URL.createObjectURL(stream); video.onloadedmetadata = function(e) { video.play(); }; }, function(err) { console.log("The following error occured: " + err.name); } ); } else { console.log("getUserMedia not supported"); } if they deny, you'll get a PermissionDeniedError in the error handler above.
JSON and HTML are 100% isomorphic in that an xml tag can be represented as a JSON object and vice versa. However, this isn't really projection (projection is closer to finding a way to strip information out of a structure idempotently) either. A projection is *not* always isomorphic as its frequently impossible to go from a projection back to the original structure. I see why people started saying isomorphic JS, but that doesn't make it technically correct. I don't really care because I'm not part of the JS community, but it's still wrong. 
Agreed, but isomorphic also already has a computer science definition so it's not great to have two equivalent terms. Especially since the isomorphism between [x, y, z] and {0:x, 1:y, 2:z} is a very different beast. It's less of a problem because of correctness and more of a problem of overlapping terminology. I like just calling it JavaScript. 
A few things. * You're missing the closing `}` in your `video.onended` function * `document.getElementById();` not `document.getElementsById();` * Your script is running before the video element is created, you need to wait until the page is loaded. Ftfy below: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;style&gt; div.video-container { text-align: center; } &lt;/style&gt; &lt;script&gt; window.addEventListener("load", onload); function onload () { document.getElementById('video1').onended = onended; } function onended () { this.style.display = 'none'; } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="video-container"&gt; &lt;video id="video1" autoplay&gt; &lt;source src="video/mov_logo.mp4" type="video/mp4"/&gt; Your browser does not support HTML5 video. &lt;/video&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 
&gt; seems a little silly Also, extending `Object.prototype` with this... just... *sigh*
Check out this series (this one is free for kindle) You Don't Know JS: Up &amp; Going https://www.amazon.com/dp/1491924462/ref=cm_sw_r_awd_j5EIvb7RWV3XE Also, this was very good.... The Principles of Object-Oriented JavaScript https://www.amazon.com/dp/1593275404/ref=cm_sw_r_awd_36EIvbWQBZRF0 Also, as someone who pretty much began with jQuery because of all of the cross browser issues in 2008...this has been helpful http://youmightnotneedjquery.com/ ...and of course learn what's in ES5 and upcoming ES6 features. There's been a lot of really good additions that people overlook when googling js solutions to problems, and taking outdated answers as a solution. The environment is changing really fast, and you should take caution when doing your research. ..pay attention to article dates...etc. 
Very cool. This would have been great to have last week when I wrote something very similar for an internal project. Have you done any testing trying to transfer very very large JSON objects? (i.e. &gt; 200MB).
Thank you so much for taking time to read and reply to me, what I am after, is more practice than Theory, I really want to start writing code instead of only reading...
Have you considered just thinking of a project and building it? That's how I end up learning the most, because inevitably I realize that I don't know how to implement some functionality and I then have to look it up. Working with APIs is usually a learning experience. Right now I'm working with a web API that delivers poorly formatted HTML and I have to write a bunch of JS to fix all the problems it gives me. So that's always an option.
When you say JSON objects do you mean a 200 MB string of JSON data, or plain objects? If you're transferring that much data as a string I'd recommend you put it in an ArrayBuffer and transfer the buffer instead of copying it. That said, I have used this package for my project https://github.com/blixt/starbounded where I have multiple workers accessing a huge 1 GB game database to extract various resources in parallel. The resources are generally only a few MB each, but it's transferring a lot of data between different contexts as game levels are being loaded. You may also want to look into using IndexedDB – you should be able to access the same database instance from both the main scope and the worker scope.
"*Complete* lack of support" equals 0%. It's not the same as "little support" or "some support". https://en.wiktionary.org/wiki/complete#Adjective
I don't know where you're at as far as skillset so it's a bit tough to answer, but working with libraries like angular and d3 have been insightful. I've also been doing things with no libraries when it makes sense. For instance, you can find plenty of "ajax" type examples that are cross browser (html5). I've been mostly a c# guy for several years, but I've been finding that nodejs, and sometimes the full mean stack are also good practice, as well as using task runners for front end development like grunt. Honestly, the only answer to this question... is hands on experience if reading isn't your bag, but there are so many new things happening these days, it would be foolish not to read up a bit (unless you have unlimited time for trial and error).
That's good to know. Sometimes i like a hard copy to carry around... sometimes i try and read on a tablet...but outdoors...it kind of sucks.
I just get 3 blank panes on top and one big blank pane on the bottom
http://addyosmani.com/resources/essentialjsdesignpatterns/book/
I am of course reading, and I am quite familiar with Ember.js JQuery etc...but, As you said, Hands-on experience is invaluable. I am not opposing the idea of reading, or saying that i don't want to, No, What am saying is, I find my self reading the same things (That I already know) Over and over and over again...I want to put that in Practice..
Yep! This. It gets to the script tag and runs it, which is before any of the body is created. If you put it in a function which is run on page load or at the end of the page, it should work (aside from the other errors mentioned)
Have you ever heard of http://www.codewars.com/? Basically a bunch of user made code Katas ranging in skill levels. They give you points for completing them, and when you complete one you can see everyone else's answers. People vote on answers based on the most clever, shortest, efficient, and/or best solutions to each problem. There are also forums where they discuss each kata. Some of them can be pretty long and can take quite a bit of time to complete as well. Pretty fun way of learning a new language, learning things about a language you never knew existed, and getting better at memorizing methods, syntax, semantics, etc.
Good ideas. MeterorJS and ShareJS are already a thing. Or maybe someone could copy the Datomic ideas to C/C++/Nim and then you could do your system with Emscripten/Web Assembly.
Thanks for bringing this up!
It is indeed IMO a bad practice. Whether you have an intermediate variable or not doesn't matter. Reason being is that at least to my preferred conventions if you're creating a class instance you're using it to store state (depending on contextual this), whereas anonymous objects are dictionaries. This way if you're doing `module.exports = new ...` you're semantically exporting a mutable state. If you would consider this a code smell var mycoollibrary = require('mycoollibrary'); mycoollibrary._internalData= 'cake'; mycoollibrary.myPersonalUnconnectedDataThatIsn'tAPlugin = 'pie'; You would also have to consider this a code smell as well. var myMutableUser = require('user'); myMutableUser.setName('Jack'); Having stateful libraries is a nightmare because what if your event loop callbacks switch functionality on each other? They all hold the same reference! Also what happens when you accidentally make a bug that overwrites a library function/variable with garbage? Good luck finding that one Also Winston is just the worst because instantiation of a new instance just breaks normal class convention because they dug themselves into a hole with how they designed the library over one little export line. Now for compatibility they can't change it which is hilarious. I mean check it: var winston = require('winston'); // Class instance var logger = new (winston.Logger)({ // Calling a constructor. transports: [ new (winston.transports.Console)(), // Calling nested library classes unrelated to `winston` instance. new (winston.transports.File)({ filename: 'somefile.log' }) ] }); Likewise this creates an issue where you want to name something transports in the module and the instance because it's semantic and you can't because you chose to dig this hole for yourself. tl;dr your users should interact with your libraries in a read only way, export classes not instances, don't use module state. Also a cute way to get around this which I don't recommend you ever do is: delete require.cache[thisShouldBeWhat__filenameIsInWinstonsIndexJs]
I highly recommend [Eloquent JavaScript](http://eloquentjavascript.net/) by Marijn Haverbeke. I was in a similar boat as you and it helped me improve my JS skills immensely.
I heard it loud and clear, I removed those. It was something I convinced myself was the right thing a long time ago
Go through the core modules of http://nodeschool.io
Thanks, this is a great explanation. I think I get what you are saying, especially with the winston example. A better pattern would be for winston to export the class definition and users to create an instance from it, like: var winston = require('winston'); var logger = new winston(); I think I've fallen to this trap and will update it, thanks. The other thing is I use [sequelize](http://docs.sequelizejs.com/en/latest/) for creating my models. And in my `models/user.js` file I do this var sequelize = require('sequelize'); var User = sequelize.define('User', options); module.exports = User; later other files like routes can use this model like var User = require('./models/user'); User.find(id, function(user) {}); Would this be ok? It seems that this is ok since User is exposing some functions that's used to fetch instances but nothing's changing is state outside of models/users class. 
Because you know when they were figuring it out they were like... fuck it, what if we add one more?
Read raganwalds stuff
Thanks That list of loader is pretty complete with linters and pretty much everything I can think of. I guess I have not run into other tasks yet maybe. 
Yup I was gonna link this if nobody did yet
These are common mistakes to you? It seems those errors would only crop up for someone who has absolutely no idea what he's doing.
Looks interesting. Where are the examples?
CodeAcademy is pretty awesome, and free! I'd recommend learning 'raw' js first then diving into jQuery/AngularJS etc
Wow this Kata thing is amazing. Thanks for sharing!
Lots of people still use document write. How else are you meant to get html out of JavaScript? /s
Well isomorphic is actually a Greek word which translates to 'equal shape / form', so the semantics (oh look another Greek word ^ _ ^ ) in this case are pretty much OK.
&gt; Before reaching the client, it must come through two filters. First one is a security filter. It filters out all the data user is not authorized to see, leaving out just personal, shared and public rows.
[It's on the website](http://documentation.js.org/html-example/), which is linked to by the Github page.
Thanks, didn't see that. OP, I'd put a link near the top of the GitHub page to the examples. Otherwise looks great. 
I JUST STARTED this book last night. I'm pretty excited about it.
Not sure I agree. The trend is towards more code on the client and/or isomorphic apps with Node. Not that people aren't still writing backends in Python, Java, Scala, etc. but the web apps I'm seeing generally have a straightforward REST API on the server tier and little else.
Create your own projects. This will help you the most. It allows you to not only hone the skills you are working on. But also work on skills normally outside of your own scope. You will have to learn, not only front end UX, but also back end development as well. You face all of the problems and have to come up with your own solutions. This will force you to read more, but also learn. Coming up with a project is easy, create a website, application, game, etc. Don't think to much into this, just start the process. I keep a lot of projects running. Just because I might want to work on different things at different times. But I keep projects going in as many categories as I can, because I can always work, and improve on something. Those brilliant ideas happen when you are working on your worse material. You can also measure your progress keeping all of your projects. Save Everything! 
This seems to be broken for me (using Firefox 31) - the graph just advances horizontally in a straight line and I don't see any circles.
http://blog.ustunozgur.com/javascript/programming/books/videos/2015/06/17/how_to_be_a_great_javascript_software_developer.html
&gt; No, the DB will not talk directly to the client ever. The client may have a local DB. Also, there is stuff like Firebase. Being able to talk to some DB doesn't mean that you have all privileges.
I concur.
Rules of thumb: * Factories: good for deferred construction of objects, e.g. you have 2 out of 3 dependencies and know that in some given context (e.g. an event fires) you will get that 3rd dependency (e.g. a DOM node). Note that it's usually neater in js to use fn.bind() to supply args as you go. * Observers: good to communicate over system boundaries - one system emits/publishes, the other listens via on/subscribe. The obvious example is the interaction between the user's actions in a browser and your code, where you can listen for events in your system and the UI system doesn't need to care about your behaviour. You can use this understanding to apply to your own projects. * Singletons: good for optimization 2 years into your project if you don't have a composition root. Also great for using right away for "efficiency" when you're really only "creating technical debt" or "shooting yourself in the foot", depending on how you look at these things and whether you'll be the one fixing bugs involving shared state later ;)
Have you tried changing the signal frequency? I guess there might be some canvas incompatibilities..
I use it in conjunction with gulp, I reckon I could potentially get away with just using webpack if I tried hard enough, but I was used to gulp, I mainly us webpack for running my files through babel and packaging them.
try this: https://jhusain.github.io/learnrx/ it's excercise-learning regarding functional programming in JS.
Not requiring a server is _sort of_ accomplished by using [remoteStorage](https://remotestorage.io/): each user has his own storage somewhere, where web apps can save that user's data to (see also: [unhosted](https://unhosted.org/)).
I've now gotten it to work by changing the third line to: var waveformInput = document.getElementById("waveform").elements["waveform"][0] So I appended [0] to it and I'm getting the square function. If I append [1] I'll get the sawtooth function.
Yeah, this is annoying because fuck progress
There should be a TLDR in a few words explaining **what** it is. I don't want to read two pages of useless chit-chat to get a hint that it might be about web components. 
You get that here: http://famous.org/framework/
Maybe they're just trying to act like every other js framework.
I was just asking myself that question for a starter kit I'm in the middle of building! My answer is that for most scenarios plain-ol' webpack is fine. For example, if you're just messing around with a new project, it is obviously fine. If you're building a node module, you're still ok using webpack. Even if you're building something with both a production and development version, you can produce different builds by defining a different config in `webpack.config.js` based on an environment variable. The one situation where it makes sense to use gulp as well is when you don't know the filenames of the final script files. The major case where this happens is when you name your script files with a hash to prevent the browser from caching them. In this case, your index.html will change with each build, and so you'll need to use something like `gulp-inject` to manage this. For an example of this, see `gulpfile.babel.js` in [react-black-triangle](https://github.com/jamesknelson/react-black-triangle)
Here is our list of JavaScript learning resources for new Kensho engineers http://glebbahmutov.com/blog/getting-up-to-javascript-speed/
Can someone tell me whether I should care about this? I need an adult here!
I'm using [**imagemin**](https://github.com/sindresorhus/gulp-imagemin) with **imagemin-mozjpeg** for setting JPEG quality (default **imagemin-jpegtran** doesn't allow for setting JPEG quality).
It's not a new framework 
Nope, it's been out for a while. They just held off the marketing until a quiet week came along.
I code on the open-source game 0 A.D. in my free time: http://play0ad.com/ It's not a browser game, but we do use JS for most of the simulation code. Our JS is a bit easier, as we don't need to take browser compatibility into account (browser compatibility is the dull part of JS that requires a lot of testing). Any work you do is always volunteer (we have no paid members), but you can start with experimenting a bit (implement strange features), and then go over to really implementing wanted features (for the main game or a mod under development), depending on your skill. Join us on IRC if you want more info: https://kiwiirc.com/client/irc.quakenet.org/0ad-dev
Waiting for the troll to arrive. I can here their footsteps.
When I started learning JavaScript (twelve years ago now... holy damn) I usually found some projects I liked and dissected them. Used a debugger to find out what made certain parts of the code to trigger, then stripped out all the stuff I thought was cool or usefull and experimented a bit with them to see different results. (Just like when I was a kid... I took stuff apart to see what made them tick, then back together after it's all in pieces and been thuroughly looked at) I don't think I've ever read a book on programming in my life, so no tips for you there, but as many others have said (and this was how I did it), create something. Start out with something simple with one spesific goal/task, then start building projects that depend on other APIs to get some inspiration for coding styles and ways to do stuff etc. Look at some podcasts on youtube. Google has some cool stuff https://www.youtube.com/user/GoogleTechTalks/videos (much more than just JS though)
jpegoptim
&gt;If you want someone to care, I'd suggest writing some code in React or Angular, rewriting it in Famous, and then giving a detailed breakdown of why you think your code is better. Perfect. That's probably the only thing that would convince me to switch from something that already works well and has a large community around it. 
&gt;&gt;Given that the Famous Engine is modeled after the capabilities of modern game engines, it made sense to start by looking at first-class game engines like Unity3d and Unreal Engine. &gt;No, actually, that makes no sense at all. How would you model a JS framework after the capabilities of a modern game engine? Do you support ambient occlusion? Shadow maps? Depth of field? I assume you mean you're modelling it after their architecture or design principles, but that makes barely more sense. Name dropping Unreal Engine does not sell me on your framework. They are talking about the Engine, not the Framework, these are separated. For example the "Virtual Dom" is the engine for React when updating UI. &gt;&gt; How do these tools enable building richly interactive applications and interfaces? &gt; Speaking as someone who has used Unity3D a fair bit, the answer is "badly", and from what I hear Unreal isn't much better. They're good at pushing pixels to the screen, but Unity is famously terrible at creating in-game UIs. Its not about those game engines creating UIs, but how you manage the data. I am not sure about Unity but Unreal Engine has whats known as Blueprints, these are components which are composable, and can react to events. So it in reference to building a game not building UI in a game. &gt; Also, adopting dependency injection in a JS framework to enable easier unit testing does not fill me with confidence that you understand how to write an easily unit testable framework in JS; I think it's a pretty widely shared view that DI was one of Angular's many design mistakes I can only guess you are talking about how it's implemented? The "magic" behind it? DI is important to testing in general as well as being tied to a specific library, or in Angualr's reference, component.
This comment has been overwritten by an open source script to protect this user&amp;apos;s privacy. If you would like to do the same, add the browser extension [TamperMonkey](https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo) for Chrome (or [GreaseMonkey](https://addons.mozilla.org/en-us/firefox/addon/greasemonkey/) for Firefox) and add [this open source script](https://greasyfork.org/en/scripts/10380-reddit-overwrite). Then simply click on your username on Reddit, go to the comments tab, and hit the new OVERWRITE button at the top.
&gt;Any JS library to Build something like Facebook I guess you don't know that's a standing joke.
No
Neither Atom nor Sublime are really meant to be IDEs. Nuclide is closer since it prepackages some of the necessities that make an IDE, but still I think its far from the traditional concept of an IDE. Atom's performance is still subpar to Sublime when it comes down to the editing and power use (even after the big overhaul). Meanwhile even with all the right packages installed, the intelligence is nowhere near what WebStorm can offer **out of the box**. My only concern with staying on Sublime is that the development around it seems to be slowing down (may be wrong here but this is just what I've observed from my usage), whereas Atom backed by the might of Github is surely to continue at a blazing pace. So right now I guess if you are on Sublime and looking for a different glorified editor, Nuclide seems like a good option. Whereas if you want an IDE, WebStorm is still the best.
it has some fancy-looking graphs! and a soothing, minimalist color scheme! that's it, i'm sold, death to servers. 
This looks the same as every other text editor out there now. Sublime, Atom, VS Code, etc.....
The first difference is that you no longer have to create a local variable like `that` `self` and `_this` which risks mixing up coding styles and imo isn't very descriptive or intuitive if you have never seen this workaround before. There is a slight tradeoff that `.bind()` is creating a small method and method call over your normal function, but it's typically a very small overhead. However, there are times where using .bind() to bind an event method on a class can actually save you from having to write your own anonymous method so that tradeoff isn't really there. Example: function MyClass() {} MyClass.prototype = { 'BindEvents': function() { $('#MyButton').on('click', this.OnMyButtonClick.bind(this)); }, 'OnMyButtonClick': function(e) { // This method will be called } }; OnMyButtonClick will be called with what you would assume is the correct `this` by it referring to the instance of `MyClass`. To replicate this you would need to create a local variable to hold `this` and then create an anonymous function inside the BindEvents method. This is my most common use of `.bind()` and where it shines.
it's a good place to start out imo. I did some of it a couple months ago when i was starting to learn js, and the best part about it was the active community. there is always someone around in the chat to talk to or code with.
Because the influx of JS tools is overwhelming.
What!?! If you need to find out if an object is true or not you should be using a boolean. Not hackily converting it to one.
use a loop and: getmessage(int number) setmessage(int number, string msg) instead of duplicating functions
Get learn LDAP basics, head to ACL section. That notion you're trying to present is the myth created by the relative databases world and has nothing to do with reality.
Another day, Another framework
What would lead to an error condition?
even if a new front end framework is destined to be the next big thing it won't hurt your job prospects for quite a while if you don't learn it now. And if one is going to be the next big thing, it's probably doing something better than the current big thing. famous has gotten like 25mil in funding, and other popular frameworks like angular and react aren't exactly hurting for developers. 
That image does nothing for me. It seems more of an art piece really.
Not very useful and doesn't explain arrays
What am I even looking at? If it's a picture, just post the url... Edit: Okay... now there's something there. Before there was no image.
The 2MB limit has been fixed in version 0.208.
It does everything I need. Opens files, lets me edit files, saves files.
Imagine spending time in Federal Pound Me In The Ass Prison.
Looks like an over-glorified cheat-sheet (anyone remember those?)
Do you not use `&amp;&amp;` or `||` because they use double symbols and look "ugly"? `!!` is a very standard way of casting to bool in js and will make sure you have consistency with other developers you stumble across.
Because they're not *new* tools. They're the *same* tools with a new coat of paint. The same features and the same problems. Doing *anything* other than creating a new JS framework would be more productive. Destroying JS frameworks would be more productive. Fuck, going outside and gardening would advance the state of JS more than making another fucking framework.
Hey CSS9 engineer ... you are up to date right?! Cause I think you missed n° 10 http://glenmaddern.com/articles/interoperable-css ;)
Thank you, sir.
It's for beginner mainly &amp; not finished yet. I was trying to clarify the internal relationships between all those Js concepts with a more structured mind map, rather than just a write &amp; play tutorial or a syntax cheat-sheet.
https://github.com/reactjs/react-magic
Just use sublime for the small stuff and any version of intellij for projects. Pretty much got everything covered this way. Of course ios is a different animal.
Just to make sure you're not confused: Java and JavaScript are completely unrelated languages. They have more differences than commonalities. As the saying goes "Java is to JavaScript as ham is to hamster". Your Java experience won't translate easily to JS and you should be aware that you need to learn the language from scratch even when it looks familiar. Language-wise you also need to pick up HTML and CSS. Keep in mind the real world is as much about frameworks and libraries as it is about languages. But you also need to understand the environment you're working in. For the web front-end this means everything from DOM to HTTP as well as the various web APIs that keep popping up in browsers (going all the way back to AJAX but also what many people think of when they say "HTML 5"). You don't need to be perfect at everything. You don't even need to be good at most things. But you need to be aware of what exists and how it is changing. As for what it is like -- that depends on what you are going to do. "Web developer" or even "Web front-end developer" is a very vague label in practice. You could be a regular employee, a freelancer or something in between (e.g. working for an agency). You could live in Photoshop and mostly do design work or barely even touch CSS and stick to JavaScript. You could be developing accessible web pages that have to work in IE8 or using all the latest shiny toys while churning out web apps at a startup. If you're working mostly as a developer, you might spend most of your week trying to figure out a single problem or be super-productive and implement a ton of new features in a single day. It's really hard to describe a "typical" day of work as a "typical" web front-end developer. There are as many different versions of the job as there are people with that job title.
Hah wow, should have known it would have already been made. Thanks!
reading it from Eloquent Javascript (Annotated Version). It's much better with annotations by a former Google employee. See http://watchandcode.com/courses/eloquent-javascript-the-annotated-version
&gt; I'll stick with BBEdit OHHH its one of those snooty people that hate new stuff. buncha weirdos if you ask me
I'll fix it,thx;)
This feels like a homework question because no one in their right mind would ask "are good practices important in todays landscape" without expecting a lengthy reply that is essentially a re-word of what unobtrusive JavaScript IS. edit: spelling
A jpg. For text. Fuck me 
That's really a very good point, it makes me think that beginners might be even more confused with such a bunch of abstract syntax rules without further details. I'll reconsider its title or application scenarios(I'm using it as a syllabus while teaching other people who have no experience of Js by myself, I'll keep trying to update &amp; refine it to make it more helpful to whoever that might need it;)
There's also PDF version of it... ;(
This is a good diagram, I like it. $0.02: The Data Type branch should be broken down into "Value Type" and "Reference Type" sub-branches. This is a distinction that's worth showing as it's a common source of error.
Also many helpful suggestions😂
Where's the rest of it?
[My reaction in one picture](http://i.imgur.com/9DP5fTP.jpg)
Working on it ;)
Right. This is why I'm looking for Javascript-specific patterns. 
Interesting... Thanks for the explanation!
From someone who is very visual, I greatly appreciate this. Its like those pictures you see where they have all of the pieces of a car laid out, so you can see what all goes inside. Nice work. :)
Nuclide uses Atom. Facebook said the Nuclide is now the official Facebook IDE, so we'll see a lot of investments made by Facebook into Atom. Those investments along side the investments made by Github and the community, make the future of Atom look very promising. Sublime is great and had a huge head start but I don't think it'll be able to keep up with Atom and the huge community that is growing around it. 
😈
The only thing better than umteen javascript frameworks is umteen - 1 javascript ide/editors. or is it umpteen?
I'm trying to figure out why you're getting dogpiled for rolling your eyes at Yet Another Editor that checks off the buzzword list, and admitting that you're going to keep using "something old and comfy" when there's plenty of people around these parts that use vim (or vi even) for day to day. As far as I can tell, your boat is still floatin.
Yeah. Atom is getting a lot better, and 1.0 is right around the corner. (Didn't they say June?) In fact, I've had roughly the same amount of bugs in Sublime as Atom lately. Performance is still subpar but Sublime has its own (less fixable) performance issues. ~~vim is supreme~~
last time I checked, (been a while) sublime not only couldn't do file association properly (dbl clicking a file.py wouldn't open it in sublime) AND the developer said windows was the problem, not sublime.
&gt; That said, I wouldn't be opposed to a text editor that decided excessive line wrapping was actually garbage and not code to be highlighted. :P just generally, yeah. 
Neat! Haven't had to try since moving to a new job. Will keep an eye out for that if I do encounter it. It's still my go to editor. That and Webstorm and VI. Mostly Atom.
I remember that thin butterfly O'Reilly Js book! It's clean and enlightening in some (odd) way..
Man I'd like to see your work flow. 
I'm not writing any intense javascript. Pretty CSS heavy. 
This one? http://shop.oreilly.com/product/mobile/9780596517748.do I'm new to JS and hadn't seen that before. I've flicked through a friend Rhino one before to look something up but this looks more interesting. 
By using this one weird trick...
&gt;Everyone with eyeballs thinks they can do your job &gt;It garners no respect from anyone &gt;JavaScript is a joke to most programmers Completely disagree with these.
That's pretty cool, but as an actual teaching aid, I feel like it'd be more useful to some sort of sci-fi advanced AI than to meatbags like us. :\
I guess if you have a good task runner (or not using preprocessors) then your editor doesn't need to be very full featured. 
&gt; JavaScript is a joke to most programmers That used to be the case once, but not today. We have `node.js`, an entire backend server that runs on JavaScript and with the importance being given to dynamic languages lately, JS can be anything but a Joke. OOP is possible in JS, though not by the way of classes, but using functions. Almost everything you can do with a compiled language can be done with JS too, and the modern browsers are powerful enough to run them fast.
I think as with many dynamically typed languages (e.g. Python) it's less about design patterns and more about idioms. As others have pointed out, many of the GoF patterns simply don't apply to JS because you don't need to implement the patterns yourself, the language already provides them. In practice, as always, it depends. The exact idioms will vary from team to team and from project to project. Maybe your team leans towards the functional side of things and everything is done using function composition and monads. Maybe your project uses all the features of ES2015 and beyond thanks to Babel.js and there are generators and co-routines all over the place. Or maybe you are stuck in IE8 land writing jQuery code and everything is a jQuery plugin. I second the recommendation of Osmani's book and whatever Raganwald is currently up to. Here's a quick rundown of [GoF design patterns](http://c2.com/cgi/wiki?DesignPatternsBook) I actually use in JavaScript (though I rarely think of them as design patterns): * Factories: functions that return objects that have methods, especially [objects with varying prototypes depending on the input using constructors](https://github.com/arangodb/arangojs/blob/master/src/collection.js#L12) * Singletons: thanks to prototypal inheritance, all objects in JS are singletons. If your module exports an object that has methods operating on its properties, it's by definition a singleton. * Decorators (OO): functions that take an object and add additional behaviour to it. In JS these are often called mixins (but the term may refer to other concepts in other situations). * Decorators (FP): functions that take a function A and return a function B that invokes function A on its arguments, modifies the result somehow and then returns the modified result. These are also implemented as syntax (called annotations) in AtScript/TypeScript, where they are especially used to modify ES6 classes (i.e. constructors-with-prototypes). * Facade/Adapter/Proxy: common for implementing polyfills but even oldIE-compatible AJAX libraries tend to fall into this category. * Command: partially applied functions (often incorrectly called "currying"), for example. Most of the times this would more correctly be called "closure" as it's a syntax feature. * Observer: everything from [observables](https://github.com/pluma/obs) to event emitters and [PubSub](https://github.com/pluma/sublish). * Memento: (de-)serialization using JSON, YAML, etc. Thanks to JSON this is trivial for plain objects. If you have nested objects with non-native prototypes, this requires a little more code. * Strategy: thanks to dynamic typing, this is easy. Less obvious examples would probably be browserify's ability to swap out modules in your node code for the browser bundle.
This is somewhat missing the long road of Linux users for which the only workable browser was Netscape 4, followed by Opera and KHTML. They all sucked in different ways, and none of them was really acceptable browser, though I guess Opera came closest. But being written in Qt, it tended to look completely out of place on your desktop if you did not happen to be running KDE. But then again, so did Netscape 4 with its Motif UI. Eventually Mozilla approached 1.0 release. It took so many years. It was usable somewhere in the 0.9.x version, but very, very sluggish compared to every other browser out there. The C++ abstractions involved in the codebase were rumored to be legendarily inefficient, and I could believe that. Opera might have had a good reputation in hands of its users, but as a developer I frequently found Opera-specific bugs that were weird. One of my favorite was seeing the string "BeforeScript" on screen instead of the desired content, if I attempted to define an Object using {} notation containing a key whose numerical value was greater or equal to 16777216. I think their JavaScript engine was by far the weakest of the whole bunch.
have you tried it? is not much better than anything out there, and I felt it was much harder to use.
You shouldn't. 
Maybe [this one](http://shirtjs.com/product/8-bit-js-black/)? They have an [npm](http://shirtjs.com/product/npm-gons-olive/) shirt similar to your description on that site but this is the closest yellow JS one.
I still use Require.js on all of my projects. I don't get a lot of utility out of node modules in the browser, because: * it's annoying to have to manually verify the licensing is appropriate on all included modules by the ones I installed * file size tends to bloat due to having multiple versions of the same libraries installed * I don't like needing a build process in development if I don't need one I also wasn't a fan of how I had to mix different syntaxes in webpack to, say, import a node module into an ES6 module. Maybe that's been fixed (it's been awhile) but it was a pretty big turnoff. With all of that said, there are certainly downsides to using require.js by hand: * The build process is horribly documented- there are conflicting options, depending on the type of build that you're doing, so you'll need to cross-reference documentation and tutorials * Pulling in libraries with their own loaders (looking at you, google maps) can be tricky to figure out your first time * There's a wee bit of boilerplate My preferred process is actually to write my code in ES6/2015 syntax, have `babel` watch my source directory and compile individual files to the AMD equivalent in a dist directory, then run the compiled code in a browser. Change javascript, refresh browser, no painful build process. You could easily do the same with browserify or webpack, but you'll have to look up how to do incremental builds in each. But, all of that is just my opinion; take it for whatever it's worth to you.
So you do something like this? http://babeljs.io/docs/usage/modules/#amd Seems to be a good option. Thx!
&gt; They are talking about the Engine, not the Framework, these are separated. I read the linked post. I read your comment. I still don't understand the difference. Or why I'd care. Again, I'm a developer. My day job is using JS frameworks to solve problems. If you're trying to sell me on your new JS framework, you need to explain how the entire package you're selling can be used to better solve the problems I face. &gt; I am not sure about Unity but Unreal Engine has whats known as Blueprints, these are components which are composable, and can react to events. Unity does have components and "behaviour scripts", and they do react to events, and you can place multiple behaviour scripts on an object which technically makes them composable, I guess. But...it's not an amazing design, it's not particularly nice to use, and it's tied quite closely to the Unity editor GUI (the fact you could drag and drop behaviours onto objects was a big selling point for them once; why you'd want to was never clear to me). I guess it's what they had in mind with their weird little behaviour/"functional CSS" fragments, but honestly it doesn't seem a tenth as good as React style mixins. (Then again, maybe it's the same as React style mixins? How would I know?) &gt; I can only guess you are talking about how it's implemented? The "magic" behind it? Kinda. Generally there's a tradeoff between magic and boilerplate, although you'd like to avoid both. Angular 1.x made some unfortunate choices that meant they ended up with both, instead, and I think their DI approach is a good example. It's very verbose (actually, all three different and subtly incompatible DI syntaxes are verbose, and the fact they even have three different ones it's its own brand of insane, but that's neither here nor there), but it's *also* confusing and surprising (and in one of its more common forms, conflicts with a lot of common tooling to boot). And it's made worse by the fact that a large Angular app is generally complex and tightly coupled; an Angular app needs to rely on DI much more than, say, the Marty/flux/React app I'm working on right now, but it also has a *much* worse DI implementation. It's not a good combination. Again, what I want from a framework is something like "we understand that writing unit tests is super important, so here's the concrete steps we took make it easier". By comparison, "we copied some other framework's approach" is weak (did you copy it correctly? And why wouldn't I just use that framework if it's so good?). And saying that you copied **angular** is nuts.
I don't have time to try *every* new tool that comes out. I'm willing to try the better ones, but I need to be sold. If you don't include a section in your announcements that says "here's 10 reasons why this framework is worth two hours of your time to look at" (or words to that effect), you are fundamentally unserious, and I very literally have no time for you.
It's actually been public for most of its existence, but only recently hit 1.0.0 (stable API)
Rule #1 of JS: if you want to do it, someone else has already made a library for it.
I'm not a fan of RequireJS or AMD. The way in which you have to include dependencies is straight-up messy, especially compared to the node/CommonJS module format. I haven't looked at webpack in a while, so I don't remember the reasons I had for not liking it, but I've chosen Browserify for my development and I've never regretted it. Pair that with Gulp and you've got a great build environment. I've written a very indepth article about [Getting Started with Gulp, Browserify, and NPM](http://justinjohnson.org/javascript/getting-started-with-gulp-and-browserify/) that will get you started quickly. As for modules loading asynchronously, it's not all it's cracked up to be. In some cases, async loading can actually cause performance issues depending on how many requests are being made and how dependencies are structured (e.g.: a module requires a module that requires another module, that requires another, etc). I've worked on a couple projects where changing from AMD to bundles has drastically improved both actual and perceived load time. Bundling up all your JS into one or two minified bundles is actually quite performant. For small sites, I put everything into one bundle. For large projects, I will sometimes put all third party dependencies (jQuery, lodash, moment, etc) into one bundle and all application code into another, which makes it easier to cache all the third party stuff (since that bundle will change rarely). And there's no large need to worry about build times with Browserify. In my experience the initial build has always been fast, and if you use Watchify (which is also discussed in article), builds for incremental changes are completely unnoticeable. 
the operator **instance** doesn't exist, it's **instanceof**. 😋
While yes, you're correct, bitwise operators are pretty rare in most js applications. it would be great if OP could edit the diagram to differentiate between commonly used features and lesser used ones. 
I haven't studied all of these and am no authority, but one example I can think of is the constructor function. It seems that the leading experts of Javascript consistently hold that the constructor function, in fact anything where you have to use the `new` keyword at all, is not ideal for Javascript. 
How would you respond to [this comment](http://www.reddit.com/r/javascript/comments/3aw2le/what_are_the_most_common_js_design_patterns/csgsrp9) regarding Osmani's book?
Finalized and broad browser support making it appropriate for production use without a transpile step is another thing. That said ... yay arrow functions.
Licensing is indeed a pain; more tooling would be good in that area. But to your other points: - you can dedupe multiple versions of the same module; browserify also does this on a per-file basis. Quite often you end up with *less* bloat overall when you use many small modules (and dependencies that also adhere to that philosophy) because everything ends up getting deduped and re-used. - in today's modern workflow there is always a build step; be it compression, transpiling, etc... You can't really escape it :)
Ugh I hate that. How do people think this is a good idea? 
I hope the guy that decided to disable pinch zooming on github.com buys a phone some day and realizes how incredibly wrong his decision was.
&gt; appropriate for production use without a transpile step You need some kind of build process anyways. Using Babel does not make it inappropriate for production use. You don't think CoffeeScript, TypeScript, Emscripten, Dart, GWT, Closure Tools, and so forth are all inappropriate for production use, do you?
Missing that key on my phone :) 
If you're using require.js (and not writing ES2015 code) you can defer building the code until you're ready to deploy. Personally, setting up the build up front and occasionally building to make sure the code's minification safe is all you need to do. If you are writing ES6 code, you still only need one build, as opposed to ES6-&gt;CJS-&gt;Browserified code, so at least it's one less step. As far as deduping goes, that's a decent workaround... but I'm a bit skeptical of the "many small modules ending up with less bloat" because your many small modules will need the AMD/UMD/CJS wrappers. I'm sure there's an appropriate balance, of course.
Exactly! Bear in mind that you'll still have to understand the r.js build process (for the amd modules) or use an alternative AMD module bundler. I wish the https://github.com/systemjs/systemjs bundler was faster- ideally, it'd be nice to avoid r.js altogether for writing ES2015 code, but my experience (from last fall-ish) was that it was much, much slower than having babel transpile and require.js load the code.
He'd get way less hate that way.
I'll tell that to Go (golang) so it can laugh.
Very cool. I'm going to show this to some of my devs. My only constructive feedback is to replace all your directional quote marks with nondirectional quote marks. 
Learn JavaScript *syntax* in one picture
A frontend tools book in progress: http://tooling.github.io/book-of-modern-frontend-tooling/dependency-management/webpack/getting-started.html
It’s extremely readable code, and I think the game is cool. To put it plainly though, what you have is 36 global variables and tons of anonymous functions on your event listeners. everything is floating in the same space. If you really want to get object oriented, try to incorporate more class hierarchy and privacy between your objects. On line 54 the variable game, an instance of a game, is being used inside of a function inside of its own prototype function. A lot of OOP programers might dish out some criticism on that note. A Game's behavior is being defined as have a function inside of it that contains a current instance of itself at the time of definition. It still works though, and that’s what matter at the end of the day. You did a hackathon so this is to be expected. Let’s think about how you could rework this though: Could you get rid of some of the global variables by making your objects take arguments when you instantiate them? Which of these objects need to know about each other and which don’t? How can we enclose them from other objects have access to them? What about the event listeners? Could you abstract some of the anonymous functions in them into something like ‘controller’? Just some things to think about - separation of concerns, single responsibilities. In regards to your other questions: Phaser.js and Pixi.js are two very powerful libraries for canvas manipulation and making stuff like games. I have used Phaser.js to make a pretty fun game. It's pretty easy to get started too. Lacking returns isn't necessarily bad, because your information isn't flowing from one place to another. All you're doing is merely calling one function when a conditions arises, and those functions render stuff as opposed to transforming existing data. I find that in interactive applications it’s common that you won’t have explicit returns because what you’re doing is reacting to user behavior. The logic that determines that reaction though, as it gets more complex, may not even work without return statements. I do notice quite a bit of repetition. For example line 667 - 672 you manually add two different css properties to 3 different DOM elements, while right above you iterate through a button array in a slick, smooth fashion. Why not also iterate right there? Furthermore, have you used jQuery? It’s a lot of people’s bread and butter. Adding CSS properties in bulk is easy with with it. You could give those buttons a class and do it in one line: $(‘.my-button-class').css({‘z-index’:10,’visibility': ‘visible’}); Keep re-architecting this game. Look at some open source javascript programs that do stuff with games, and stair at their code for a bit. It’s good that you did it without any libraries because that when the most learning happens.
I understand, but chatter is not very customizable and we would like to use this concept for a product. So, every product will have its page and we capture #tag trends about that product on to that page. We also want to be able to copy paste the messages and report on them. We considered using chatter groups as a product name but it's not working out. 
Even then, Vim by itself for software development isn't sufficient. Trust me, I've tried. I even tried to turn it into a full-fledged IDE. It's just not worth it when purpose-built IDEs exist and you can install a Vim plugin.
I'm not sure what it is, but this theme doesn't sit well with me. It looks like it would be covered in ads. I think it might be the un-centered content, and the sidebar on the right side. The yellow accent color stands out too much in my opinion. It's very ... shocking? I'm not sure what word I'm looking for. All the modules feel very spaced out and placed in an ad-hoc manner too.
This definitely crossed my mind and I'm sure I can refactor that specific function, but I'm still not sure I'd be returning anything upon calling it. I'll keep at it. Thanks for taking the time to reply.
tldr; &gt; By now, 4 years on, Web Components should be everywhere, but in reality Chrome is the only browser with ‘some version’ of Web Components. Even with polyfills it’s clear Web Components won’t be fully embraced by the community until the majority of browsers are on-board. &gt; ... &gt; Polyfills meant theoretically Web Components could work on browsers that hadn’t yet implemented, but these have never been accepted as ‘suitable for production’.
Cool! It works. But is there any global settings to switch this off? It's really annoying to do this every time I type a quote.
Yes, you gotta find a way to turn off "Smart Quotes."
just do it~
They're optimistic that they *may* be able to *agree on a spec* that *may eventually* be implemented by new browsers. I'm... excited! Maybe in 2020 we'll actually be able to use web components. :P There remains no solution for legacy browsers. There remains no solution for the polyfill that doesn't really work. Don't get me wrong, web components are a neat idea, but they're not very pragmatic at the moment, and certainly not any time soon. Polymer 1.0, production ready, is a complete joke. 
&gt; I'm... excited! Maybe in 2020 we'll actually be able to use web components. Things are very different if you only support evergreen browsers. Those will support ES6 by the end of the year, for example.
I have no issue with the build step - or with Babel/etc. They are solid tools. I guess I meant to say - "Using arrow functions without a build step isn't ready for production use". As just serving up ES6 code to the browser right now, isn't going to work for many people. 
As mentioned, RequireJS is outdated. Browserify is just CommonJS module format in the browser, emulating NodeJS. Webpack can handle CommonJS or RequireJS, but it also adds a lot more. Webpack can handle the entire build process for you if you so please. This includes optimizing images, compiling SCSS, etc. I'd recommend Webpack, use it for as much or as little as you need. It also has a development server which will serve assets and supports hot reloading. It's really nice not having to refresh the page when changing code. https://github.com/petehunt/webpack-howto
that's pretty cool. which software did you use for making this diagram?
I don't need HTML imports, because I use webpack. I can already require javascript modules, css, less, json, etc. And HTML imports lack namespaces. If I HTML import two web components named "accordion", what happens? I don't need shadow dom, because I use webpack and Mithril components. With those tools I can require() and scope my CSS to my components as needed. And I don't need custom elements or lifecycles, because Mithril gives me a virtual DOM. If a component's controller contains the function onunload, it will be called appropriately. I am not trying to be a turd in the punch bowl vis. a vis. web components, but it seems like it will be years before they are ready, and the problems they attempt solve are already solved.
Mindnode
Its good for playing the hitler wikipedia game!
&gt; "Using arrow functions without a build step isn't ready for production use". As just serving up ES6 code to the browser right now, isn't going to work for many people. Who's just serving up ES3/ES5 code? You've to use a minifier at the very least. There is always a build step.
I've switched to JSPM^[0] . Developing with it is incredibly easy. I know, I know, another package manager. But it works well with npm, and can install from github and other sources. It also integrates with the System.js module loader. I highly suggest at least taking a look at it. I've used RequireJS and Browserify in the past, and I have nothing but good things to say so far about JSPM. [0] http://jspm.io/
Check the console (F12 -&gt; Console). You should see something like: ReferenceError: brown is not defined Once you fixed that, you should get: TypeError: wordsArray[i].charAt(...).toUppercase is not a function Because it's toUpper**C**ase. Always check the console for errors.
I merely simplified, having used both Linux and Windows all this time. All in all, Linux did not make such an impact until Apple fashioned khtml into webkit. Also, Opera really had bad JS support, but then, those were the days of document.write, so what did you expect?
I would recommend to use the `DOMContentLoaded` event rather than the `load` event.
Why's that? None of the js here needs to run before the vid grabs its metadata. 
Two ways to solve `var num3 = Number(num1) + Number(num2);` and `var num3 = (+num1) + (+num2);`
I'm using it for a booklet I'm working on to automatically click a button at a time specified by the user. Here's the code so far: javascript:setTimeout(function(){document.querySelector('input[type="submit"]').click()},Date.parse(prompt("At what time would you like to press the button?",Date())) - Date.now()) If I'm understanding you correctly, I could get it to activate on the leap second with "`Date.parse("2015-06-30T23:59:59") - Date.now() + 1000`", but getting proper times across a leap second would require "`Date.parse(prompt("At what time would you like to press the button?",Date())) - Date.now() + 1000`", because subtracting the Unix timestamps would give an inaccurate result. Is this correct?
Timer resolution varies a little across browsers and operating systems. It is not always the case that fudging with the system clock will affect your timers. As an example I've just tried on Chrome and Firefox in Windows 7 and changing the clock doesn't affect timers. They fire after the expected duration. I would probably bet on the timer firing after 60 seconds, not at a certain time, but I wouldn't make anything critical to depend on it.
If you're already a programmer I think (!) this makes things a lot clearer if you want to delve into JS. 
Heh sorry I misread, I thought you had read it already. You have hit the nail on the head though, GoF at the time of publication was forging the new paradigm founded on an industry with roots in mathematics and science much the same way as JavaScript is building a new world on top of an established stack. JavaScript for me is fundamentally more expressive than lower level languages in the way that a child born into money can be more experimental with their life choices knowing they have the backing of a logically sound foundation. Do skim or digest the patterns if you get a chance however as the concepts are timeless; but yes, not necessarily related to modern JavaScript development per se
&gt; This isn't going to happen. [really ?](https://visualstudio.uservoice.com/forums/293070-visual-studio-code/suggestions/7755573-open-source-vs-code) &gt; We are not open sourcing the tool itself at this point, but as we move forward we will explore open sourcing more of Visual Studio Code. 
So, if I'm understanding this correctly, `setTimeout(function(){ … },Date.parse("2015-07-01T00:00:00") - Date.now());` would actually run at 2015-06-30T23:59:60?
I've never even heard of Mithril until today, and Vue and Aurelia until just right now. ~~I'm not sure I want to~~ Unless they become the next big thing AND web components is still far off, I'll be avoiding any new frameworks like the goddamn plague. We frontend developers need to take a stand to stop all this framework bullshit. This is NOT innovation. This is BULLSHIT. To the hipsters who are downvoting.. oh, is knowing "alllll about Backbone, Angular, and React, not to mention Ember, Knockout" not enough for you? Please link to *anything* made in Mithril, Vue, or Aurelia. Or link to exactly what the above poster says: &gt; But if you want anyone to care, then COMPARE IT TO THE OTHERS. ... I'd suggest writing some code in React or Angular, rewriting it in (Mithril, Vue, or Aurelia), and then giving a detailed breakdown of why you think your code is better. Or fuck off.
My guess is that most systems are not so precise as to care for leap seconds. Usually, the internal clock is readjusted now and then by an NTP server. Until this readjustment, the seconds just go on one by one. But let us assume the case that the adjustment just happens to be during the leap second. A fraction of a Millisecond before the timer interrupt triggers, the clock is set back to 23:59:00. That is the only case in which the browser would actually wait 61 seconds.
Are there any resources that helps you get started? Seemed incredibly complicated to me.
This is how I learn best. I really wish more people would map out language syntax more often
The answer is actually "it depends on your browser and operating system". But that question is a bit different. That not only implicates the timer, but also how `Date.parse("2015-07-01T00:00:00")` is calculated. I mean, does the system calendar incorporate the leap second or is it an adjustment that is made at that point in time? Right now, -again Windows 7-, if I try `Date.parse("2015-07-02T00:00:00") - Date.parse("2015-06-30T00:00:00")` in my browser console, it does **not** include the extra second. So...
The thing with your Mithril components is that they are Mithril components. Using them in an Angular/Ember/React/whatever app doesn't sound like a good idea, does it? Web Components work with any modern framework. Mithril included.
So yes, then? It's the same in Windows 8, by the way, at least in Chrome.
What do you mean by the interrupt? And why 23:59:00?
I just switched to JSPM aswell. So far, it's been awesome!
Mistyped: 23:59:60 (though the timestamp will relate to 00:00:00).
Fuck the browser. JavaScript can vdom precompile universal web components that run on any system, that's the future of programming. Libraries like lodash reimplement browser APIs more efficiently than the browser's 'native api'. Browsers should condense JavaScript's API while exposing lower level functions from the underlying DOM and native code. 3rd party libraries can implement classes, DOM tree traversal, even basic structures like objects and arrays (look at immutable.js and mori). The current es6 polyfills compiles to es5 happen to be better in performance more often than not using native es6 APIs of a browser engine. Wtf? It's too late. We already have solutions better than what will theoretically become - it's time the browser wars end (or begin again) by implementing a low level JS access to API's of the runtime that actually matter.
I barely have any experience in Ruby, but I strongly suggest you do it by yourself!
that's just learn the syntax, if you want to learn programming syntax is the less of your problems
Uh if you're double clicking on a file in explorer then it's up to explorer to decided which program to open that file in. You can register programs with explorer for a certain file type but that's all you can do.
probably not
This. Heard of [WebAssembly](https://github.com/WebAssembly)? edit: add href
This really helped me! https://github.com/petehunt/webpack-howto
Why is your colour legend in hex? Is there something preventing you from actually showing the colour? I haven't used GitHub's markdown much so I may be wrong on whether this is possible or not.
I use &lt;span color="#hex"&gt;#hex&lt;/span&gt;, seems not working as expected :(
Has nothing to do with my point.
Just like Web Components have nothing to do with XML?
For some reason you are trying to show that XML isn't written letter-by-letter the same as HTML or components. What that has to do with anything, I don't know.
Typically no. Usually routers like backbone will have a method for changing the current route (e.g. Router.route("/foo")). Routers usually will detect the # part of urls (#/foo) and notify the code that handles that route. That said I would use chrome dev tools, inspect the menu item and then click on event listeners to see what code is listening for clicks. Could be that one handler is stopping propagation to the others.
The Web is Dark and full of Terrors.
I don't think a single course alone will allow you to confidently say you "know Javascript" . I'd start by googling small Javascript projects to work on. The first thing I made after finishing a javascript introduction was an analog clock, felt pretty strong on the concepts at play afterwards and moved on to more complicated projects.
There is some malware on that site trying to get you to download chrome.exe from some random site. Avoid.
Question. This looks like it's serving with babel-node. Is babel-node ok to run in production? I've typically just used babel like this: "scripts": { "start": "npm run build &amp;&amp; node server", "build" : "npm run build:server", "build:server": "babel index.js --out-file server.js", }, or
&gt; totally like XML. Are you going to continue making things up to suit whatever your agenda is?
Interesting concept. However, I think es6 generators solves this better. Just yield the async result, and violá, [sequential code](http://davidwalsh.name/async-generators).
&gt; In ES5 we can merge prototypes using Object.assign Kinda, sorta, but not really given that `assign` is ES6.
There's malware attempting to get me to "update Firefox" after I tried clicking the back button in the browser.....
`babel-node` is only used to generate project documentation and build a distributable package from the original source files
Working on an project documentation boilerplate, here is a demo: http://www.kriasoft.com/babel-starter-kit/
Thanks all for the replies, but it doesn't seem to be working. I've rebuilt my code from tencircles' and jodraws' suggestions and it still stops before the first transition in my pseudocode. It merely plays the video, as it did before, and does not hide it nor advance to the sudden appearance of the next element, as if the onended function were a brick wall. Here is my updated code, including the seperate script and relevant styles. animation.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;link href="styles.css" rel="stylesheet" type="text/css"&gt; &lt;head&gt; &lt;script src="/script.js"&gt;&lt;/script&gt; &lt;style&gt; div.video-container { text-align: center; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="videoDiv" class="video-container"&gt; &lt;video autoplay class="" id="video1"&gt; &lt;source src="video/mov_logo.mp4" type="video/mp4"/&gt; Your browser does not support HTML5 video. &lt;/video&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; script.js: window.addEventListener("load", onload); function onload () { document.getElementById('video1').onended = onended; } function onended () { var newParagraph = document.createElement("p"); //calls into existence an ethereal paragraph newParagraph.innerHTML = "now here's a text line!"; //defines the text inside the ethereal paragraph document.getElementById("video1").className = "hidden"; //kills the video //display: none; is the only line in the ".hidden" class (which is in styles.css) document.getElementById("videoDiv").appendChild(newParagraph); //adds the paragraph } Again, thanks for helping me this far in. The big question is why the page behaves as if there's no javascript working at all.
Haha that comic is fantastic!
What else did you try to say then? Please elaborate.
That doesn't really negate anything I said... People are requesting they open source it, so they gave a PR-friendly reply saying they'll try to do whatever they can, while admitting they specifically do not plan to open source the tool itself. The reason for this is because they AREN'T just using Atom as a base with some packages added on top like Nuclide. They just used Electron for the UI. If you look around, a lot of people are saying what they've made is actually faster than Atom. It definitely seems faster and more stable to me. Anyway, I think the reason they don't want to open source it is that they want to guard their Intellisense/Node.js Debugger/etc. features closely...
No. You-er vs. Yore
Because there are bugs and someone has to fix them.
&gt; If you want someone to care, I'd suggest writing some code in React or Angular, rewriting it in Famous, and then giving a detailed breakdown of why you think your code is better I wish this was common everywhere. Especially bloggers who say doing things one way is better than the other.
https://github.com/tgriesser/create-error
Interesting. I pronounce them "yər" and "yore", respectively.
Hopefully in ES6+.
Learning coffeescript is easy. Debugging coffeescript after it's been trans-piled to javascript can be a giant pain in the arse sometimes.
That video is awesome!
JSPM is the holy grail. Just seems that most havent caught on from browserify/webpack just yet. Being able to include from github when needed (no package.json? not published to npm?) is a godsend. Also, its built on system JS and uses proper hooking into the ES6 module loading functionality. JSPM uses a standardised approach to package management.
honestly, I know this is something which "appears" to fall under the spirit of the extensible web manifesto and all that, but we keep seeing the same crap - trying to answer a problem with more high level solutions. Yes, I think the effort to be able to replicate all standard html elements is an important bar, but I think its still missing the real problem. HTML is trying to serve two masters: - one is a sort of declarative data structure which is intended to be easy-ish to read and write, a surface interface - the other is the actual render tree under the hood CSS is a sometimes elegant, sometimes ugly way of assisting the transformation from the data structure tree to the render tree. So as we push to make the web more suitable for *applications* instead of *documents*, perhaps we should really be thinking about a way to get off of this high level api crap, and really go for the guts! I know that evolution is the winner over revolution. I'm not even trying to say that we burn it all down and start over. What I'm saying is that at the very least, I know we have the DOM currently, and I *know* that browsers have a notion of a [render tree](http://taligarsiel.com/Projects/howbrowserswork1.htm#Render_tree_construction), which is what is actually responsible for the display. And let's be clear - this whole concept isn't even really all that new - what we're talking about is basically a [scene graph](https://en.wikipedia.org/?title=Scene_graph)! So instead of continuing this silly march to force everything through either HTML code as text, or the hideous DOM api, and the same for CSS, why not work on exposing a sane layer below that - a new scene graph and transformation API. Custom components and html elements alike would map to nodes on the scene graph. CSS would map to traversal and transformations over the scene graph, but the API would allow hooks for developers to do the same. And maybe we even start thinking about WebAssembly in the mix, and how that can be used. I'm not saying its easy, but I do think its feasible, and certainly better than all this web component stuff. 
MP3 is a proprietary format. Please avoid it if you can.
No one else? Tmux/vim for the server editor, brackets.io for the js-built browser. Oh and http://www.tutorialspoint.com/codingground.htm
I actually don't agree with you. I find the js that coffeescript generates to be readable enough. But this is my personal opinion. Coffeescript also supports source maps, doesn't it ? This makes the debugging easier.
Good point, a Vim type editor gives you a similar workflow. Not exactly the same as running the editor in your browser, but pretty close. But also I love being able to hack and edit my editor in the same HTML/Javascript languages that I'm familiar with for my web work.
Those are implementation details that would need to be measured and are likely to change. I certainly wouldn't base any logic off of it ;) 
Coding Ground looks neat, but I can't any info on there that really explains what it is. Is it something I can download and install on my own web server, or is it just for use on tutorialspoint.com?
Sounds like [Cloud 9](https://c9.io/)
aaaand [atom.io](https://atom.io) is down. 
I have a setup similar to yours I guess, my dev box is a Vagrant VM. I use the Cloud 9 SDK on it: https://github.com/c9/core it works pretty well. I looked around for a while and couldn't find anything nicer than Cloud 9. From what I understand, Atom would be a fair amount of work to run in the browser so if it happens it won't be overnight. Those Atom plugins that Facebook just released may be a good alternative too: http://nuclide.io/docs/remote/
and now searching for/installing packages is a nightmare...
Oh yeah, Cloud 9 is also based on the same core editor (Ace). Actually, I guess they are the ones maintaining Ace now.
Is it surprising to have pro-javascript fanboyism in the /r/javascript sub? If this was posted in /r/webdev or /r/coffeescript maybe there'd be different comments.
I tried it. I found that the search tools were functionally inferior to sublime text, and its general speed felt slower. I like the way it's made, and I would use it if these things were resolved.
There really isn't something that will work. Because of how js is actually blocking/synchronous, there is no guarantee on setTimeout. Just run: setTimeout(function(old) { console.log(Date.now()-old); }, 100, Date.now()); A few times and I can get results of anywhere between 0-15 ms off.
 let $=$ =&gt;Array($.length).fill(0).map((_,i) =&gt; String.fromCharCode(($.charCodeAt(i)+(1&lt;&lt; 16)/2)%(1&lt;&lt;16))).join(""); window[$("聥聶聡聬")]($("職聩聮聤聯職耮聲聵聮聮聥聲聗聩聮聤聯職耮聰聲聯聸聹聃聯聮聳聯聬聥耮聬聯聧耨耧聈聥聬聬聯耠職聯聲聬聤耧耩耻"));
Most of atom's functionality resides in packages, which can be written in coffescript, ES5, or ES2015 (like, yes, shameless plug https://github.com/nesukun/atom-minimap-linter)
Actually almost all patents have expired. There are a few in the US left so you probably shouldn't use it in the US.
Fill is a new ES6 API. Maybe Babel repl only does syntax. Try in a browser with good ES6 support (eg msedge/chrome canary/ff nightly).
Dunno about Vue or Aurelia, but for Mithril there's this: https://github.com/lhorie/mithril.js/wiki/Who-Uses-Mithril Some of those (e.g. Guild Wars 2, 90min) pull in the range of millions of users per month. Others are good examples of non-trivial in-production open source project (e.g. lichess.org, flarum.org). Some of them are ports of YUI/Ember/Angular codebases (done for performance/maintainability reasons). I also saw Mithril mentioned in job listings for Barnes and Nobles, The Muse and a few other places a few months ago, and I was also told there's a guy writing a book about it that will be published by O'Reilly. FWIW, Mithril isn't really about innovation, it's about bringing simplicity back to frontend development. Here's a good write-up about a developer's experience with it (compared to previous Backbone experience): https://medium.com/@bjmfactory/mithril-js-interview-with-gilbert-425f4a28c415 
but javascript isn't object oriented.
Atom is hardcore...like grandma
Yep, especially on machines that rely on multi-thread work for heavy lifting. Github has done an impressive as hell job getting Atom's performance to acceptable limits, and for most people it will probably work fine. But I personally can't stand a sluggish code editor, the slightest lag in scrolling, switching tabs, typing can frustrate my fragile thinking brain. As much as I love JavaScript, I feel like its just not right for some uses, code editing is one of them. 
If you have everything but H (including lowercase h) you could do it by encoding String.fromCharCode("72")
Anyone know if the theme in [this image](http://i.imgur.com/mQS2cLZ.png) is available?
Cool, official recognition of the JavaScript noun. Now we need to work on getting the verb form recognized.
Huh, I wonder why [mine](http://i.imgur.com/fX31e7v.png) doesn't have that padding/rounded edges.
Yea, I was hoping to think of a simpler way than that, but that may be what I'd have to do. The method I used in this code was forcing built-in strings (ie. true, false, null, undefined) to grab characters. Ideally, I want to find a way that required me to not actually type any characters - using `fromCharCode` would require me to get a string reference to `C`...
&gt; Just let them rage my friend. Sure, I just wanted to point out that Mithril isn't as vaporware as some people make it out to be. I'm not on Reddit much, so forgive me if I'm bringing too much Hacker News etiquette :) WRT MVC layer dependencies, it depends on what patterns you are using. With observables, yes, you can make the view call out to controllers without introducing them as hard dependencies, but at the end of the day, to make the code do something meaningful, you ultimately need to call a handler in a controller from a dispatcher in the view, be it as direct call via a hard dependency, or a indirect call via an observable. One way of thinking of it is that the hard-dependency controller acts as its own interface, whereas with an observable, the interface sort of "floats in ether". I recall reading that Reenskaug himself (the inventor of MVC) wasn't happy with a fully observable-based MVC pattern and I've personally had issues w/ "come-from" hell as well. I dunno, I like to keep an open mind. I hope others do too :)
How does Atom compare to [Brackets](http://brackets.io)?
It's a word that is used often in written communication. If suddenly there were a million web pages talking about LordScrotumSniffer, then they'd probably add it too. 
When I was playing with earlier versions of Atom, it seemed to be slower and less responsive compared to Sublime, especially for large files. Is this still the case?
Oh man thanks! Learning more stuff about this editor every day
I agree, author may have an argument about "not replacing sessions" (which I also think is kinda wrong), but it has no risk factor regarding the auth layer. The article is misleading. On a sidenote, do these tech companies completely trust their employees editorial skills? I guess anyway their SEO "company blog" strategy is cheap.
Yeah usually when you give a level-headed reply to a rage, you are just met with more rage :P I'm with you on come-from hell; direct calling is much easier to trace. I just view it as a necessary evil or a trade off. Maybe this? //view module.view = function(model, handler) { return [ ... m("button", {onclick: handler.rotateClicked}, "Rotate links") ]; }; //controller module.controller = function(model, view) { return { handler: { rotateClicked: this.rotate }, rotate: function() { ... } }; }; So the view just makes a direct call without going through some event dispatcher. It can be less verbose, and the naming convention can be whatever. But the point is the view knows nothing about and can access nothing from the controller, other than the handlers for the view's events. So the view in effect has no dependency, but the controller does, because it must have knowledge of the events. I.e. the controller is consuming the view's interface, not vice-versa. &gt; I dunno, I like to keep an open mind. I hope others do too :) ~~Lol you're talking like you're the author~~ Whoa you are.. I think
This has been recommend a lot lately: http://javascriptissexy.com/how-to-learn-javascript-properly/
I think it's still slower and than ST2 but that's a tradeoff I'm willing to make for now. Still a bummer that you can't load files &gt; 4 MB.
thanks for the suggestions. I was also wondering why when I add a script to the page the slogan "connecting alzheimers patients with caregivers" jumps off the titlebar class and goes back into the titlebar when I delete the script. I'm also wondering why when content.innerHTML += is used to update the output of the content class it doesn't print in the format I have set for the content class.... it is not indented in the same way... but rather flush left. thoughts? http://jsfiddle.net/wraneus/11mf2n03/8/
Oops! Thanks. I'd been staring at it for ages trying to figure it out. Sometimes you just need a fresh pair of eyes. :)
i know. it's a complete rewrite. is meteor+famous compatible with it yet? 
I like being able to configure it without having to Google things.
I prefer it over Brackets personally, but some people prefer Brackets. Try it out and get a feel for it yourself. 
It's glorious!
&gt;*"Foolish pupil - objects are merely a poor man's closures."* - Qc Na
Is this a joke...? Please tell me this is a joke.
How about "I'm not gonna piss off my users with ads"?
I kind of like the way this framework seems to work.
Yeoman generator for it https://www.npmjs.com/package/generator-javascript
I uninstalled my touch screen HID. Now that it's not in my face, I no longer think about the problem for users. As OCD I am about things like this, I'm surprisex at how OK I am with my solution.
Great
I agree
Seriously, what does ES6 offer that ES5 doesn't? You shouldn't be using classes in Javascript anyway. 
Apart from that there are other nice things that are added in ES6. Not a big fan of classes myself but I have to say, it's fun writing other things in ES6.
It doesn't even support JSX yet, don't think it has even been updated since its initial release. http://visualstudio.uservoice.com/forums/293070-visual-studio-code/suggestions/7752528-jsx-support
I really liked it.... until i found out there were no namespaces ◉_◉ [Is true namespacing possible with Polymer?](http://stackoverflow.com/questions/28140440/is-true-namespacing-possible-with-polymer) ... then i switched to React :D ( if anyone knows a way to do something like this) . It's got a great deal of components though... [component.kitchen](http://component.kitchen/components) ; [customelements.io](https://customelements.io/)
Ah the downvotes for a perfectly cromulant question. I agree. What's the necessity? Are we going to enshrine every popular proper noun into the Oxford Dictionary?
Someone recommended this [annotated version of Eloquent Javascript](http://watchandcode.com/courses/eloquent-javascript-the-annotated-version/) in a post a few days ago. I've been reading through it and it's really been helpful so far.
Array.find for one...
Read everything [Eric Elliott tweets](https://twitter.com/_ericelliott). He has a book called [Programming JavaScript Applications](http://ericleads.com/javascript-applications/), which is excellent. He also has some [great resources collected](https://github.com/ericelliott/essential-javascript-links) for learning and reference. Also look at [YDKJS](https://github.com/getify/You-Dont-Know-JS), as it is a great resource on the quirks of JavaScript. And hook up with a local JavaScript meetup or Slack group until you can land an open source consulting job to do it full time. Being around like-minded people who are better than you at it will sharpen your skills. Most importantly, one thing unique to the JS world is that you will often be dealing with user experience issues that back-end workers can be insulated from. I recommend embracing that, because the tech world needs user empathy and good interaction design much more than it needs another tech savvy JavaScript programmer. Good luck.
Just arrow functions alone would make it worth the update alone in my book. Promises will also simplify a lot of asynchronous things. 
 іf (false) { console.log('Hello World'); } macro:function іf (condition) {return !condition;} 
More importantly, so is bukkake.
Meanwhile, in Visual Studio 2015 ...
In 8.1 it happens even when no touch input device attached.
Even the OS you are running on will not be able to guarantee execution on a certain time or sleep for the exact number of seconds you specified. Call me if there's a real-time system that can execute a browser or nodejs. And if it can, I think it just broke it's real-time system. ;-)
I am slightly confused. What is it specifically about NPM that you do not like? I haven't really heard a developer complain about it before. My only complaint with NPM is lack of flattening and de-duping, but version 3 which will be out from beta soon has those features added in.
Every time I type in "npm install" it fails with dependency issues. Always. Then I have to hack package.json until something works.
My favourite part of this article was the massive popup that said: &gt; We think that Big Data Analysis is going to play a critical role in every industry &gt; Do you agree? I actually read through the article and this is nothing more than a marketing attempt. Nothing new, nothing we haven't been told before or already know. Some pretty broad claims without any references to back them up. other than "Walmart said this" and "Paypal said that" - not trying to hate here, but this is a junk article. Aside: Open Sans as a font for body text is a bad choice. Love Open Sans' heavier weights for headings, but for body text I find it hard to follow.
It must be technically possible. I was able to open ~200MB files in Visual Studio Code, and they are both running on top of electron. That being said, I still can't make the swap. It's missing packages I can't live without any more (such as [align-tab](https://github.com/randy3k/AlignTab)), and for some bloody reason, the chromium engine uses some strange anti-aliasing with any font I use regardless of the css overrides, which makes all the text look blurry. Gives me a headache after 10 minutes.
What are you talking about? NPM is the best package manager I've ever used *because* of its dependency resolution.
it's awesome. been using it a few months now.
Actually, now that I think of it, I really am looking forward to [destructuring](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment).
http://stackoverflow.com/questions/5224295/javascript-the-good-parts-how-to-not-use-new-at-all
[Documentation for jqChart](http://www.jqchart.com/jquery/chart/ClientSideEvents/DataPointMouseEvents)
The title should be a 30 min seminar on why we might want the idea of isomorphic apps with no actual demo of working code to use
you haven't tried webstorm.
What's the difference that makes you prefer it over Brackets?
I forget the specifics off the top of my head. I remember Atom feeling faster and I was doing a lot of stuff in Ruby at the time which Atom seemed to have better plugins for. That was probably about 8 or 9 months ago. I did like Bracket's vertical list of open documents instead of tabs, but I found a plugin to get close to that in Atom. 
I agree with u/utuxia. When going for jobs, it is a huge help if you can demonstrate or prove your skills - so you could show up with a laptop with one of your MEAN apps on it and talk about what you did, it will make you stand out. When I was conducting technical interviews for Web Developers I quickly learned that recruitment was difficult - it wasn't easy to find good people. If someone showed up to an interview with a laptop with some apps that they had built on it, in their own time (which also shows off your drive and independent learning skills, and that you are actually interested in the code), and could talk about what they did, they would stand out by a mile. I'd say get applying for jobs. You sound like a good candidate. Even if you haven't already got years of experience in pure JS, you've shown that you can learn.
I almost always demo a side project when interviewing. It's rare I actually show something from the job I'm leaving. It just shows a sense of ownership and drive...I like to hire devs that have similar interests. This technology changes so fast, if you have 5 years experience in Angular it tells me you're not willing to learn anything else.
I think one of the main benefits is that each component is name spacing in it's own right, you wouldn't want to create two of the same components and if you do, I'd say the core of what polymer is has been misunderstood. I've been working with Polymer since 0.3 and find it to be a brilliant step in the right direction. It becomes easy to achieve complex functionality with very few lines of JS.
I sound like an evangelist haha, but it's a total shift in the way you think about how you put apps together, it's a library more than a framework, you can (and people have) use frameworks with it. Personally though I've found myself not writing much boilerplate due to the data binding, it's really made writing complex interactions simple. My setup is usually Polymer and lodash together.
Did you notice that there were also added words like "twerking" and "sexting"? Anyway it's a nice news.
&gt; Aurelia I've not - I'm going to check it out today. Thanks! It looks like it tackles something I've been unsure about with polymer, which is single page app implementation. Have you used it?
"fap fap fap" too.
What are you using for error checking? My class is having me use jsfiddle.net
... do you like The Office?
I've not saw it either. Facebook need to write more thorough tests.
For solid and deep understanding of JS I would recommend this book: http://www.amazon.com/Secrets-JavaScript-Ninja-John-Resig/dp/193398869X
Hopefully people will stop spelling it "Javascript" or "Java script" (╯°□°)╯︵ ┻━┻
Same here. I've tested it twice now. Each time the performance was significantly worse than Sublime.
Is it open source? Available outside of Windows? Not too familiar with it.
Which is quite sad, since the premise of an easily hackable editor is really nice. I want to like atom, but the drawbacks are just too large... Edit: editor, not señor... Silly autocomplete 
seen*
I'm not sure what facebook's deployment architecture is like and what their load balancing looks like, but I'll occasionally get JSON where I should be getting a page on random page loads. For the most part, Facebook is usually pretty well engineered. It doesn't crash or break very often for me, which is impressive at the scale they operate at.
sweeet
Yep, that happens from time to time. I'll try to remember to make a screenshot of that the next time, just for fun
Is VS Code your main editor now? I'm always on the lookout for the new shiny.
Promise.all(iterable) returns you a promise that resolves with an array of values once all of the promises in iterable have themselves resolved. You probably want something like var shitToDo = [promise1, promise2, promise3, someValue, promise4]; Promise.all(shitToDo) .then(function(arrayOfShitDone) { // Access your array results here. });
seent*
Thank you! RiotJS needs more exposure. Its clearly the easiest web component framework out there. Its all just classic html with great tools like scoped css, isolated in reusable files. 
Looks like server-side React compilation failed.
The definition they've chosen is: &gt; A proprietary name for: a programming language, developed by American technologist Brendan Eich and released in 1995, commonly used to enable interactive features within web browsers. with the earliest recorded use in December 1995.
I use angular and node in nyc, 2 years experience, 30k.
Blog post: http://blog.npmjs.org/post/122450408965/npm-weekly-20-npm-3-is-here-ish
Absolutely the same here. I want to use a hackable open source editor but they're just not fast enough compared to something native like Sublime. Be nice if Sublime went open source...
You might want to remove the user id. https://facebook.com/profile.php?id={userid}
&gt; Your dependencies will now be installed maximally flat. I came.
http://www.oxforddictionaries.com/words/how-do-new-words-enter-oxford-dictionaries
Still seems strange to include proper nouns of random things just because they're popular-ish. 
Next will be every Reddit user name.
Not sure how that's related, but... I watched a few episodes. I found it sometimes funny, but too often painfully awkward to watch regularly.
Ah, that's positive. Still, I think there's a lot of distrust of Microsoft. You know, the whole "embrace, extend, extinguish" thing. It's a reasonable concern.
It may be Windows' fault that this is such a big deal, but *it's such a big deal.*
You have a terrible username, but thanks for the link.
Sweet. His [website](http://raganwald.com/) has a ton of links to stuff. Also, his[ book is online for free](https://leanpub.com/javascriptallongesix/read)!
saw this all day in the business manager 
thats simply not true. Both editors use the same core (https://github.com/atom/electron) - thats all. Atom is still pretty slow.
Oxford Online Dictionary is basically trying to capture the actual usage of a language. It's not trying to dictate any sort of rules, just reflect current usage.
Compare the day/month/year instead of the ms...
Yep, it definitely should. It's been discussed and the dep structure was the biggest issue https://github.com/bower/bower/issues/1520
Arrrgghh... I updated it, but it's still not working. My mind is fried!
what about Trending Topic 2 though...some interesting stuff right there
No need to get nasty. It's just an experiment.
Right on. Thanks.
This is quite hacky but this will allow navigation within the domain http://jsbin.com/roluyi/edit?js,output function popit(){ return 'You are leaving the page.'; } var host = 'http://crm.int'; $(function(){ window.onbeforeunload = popit; // selects all links that have an href starting with `host` $('a[href^="'+host +'"]').click(function(e){ window.onbeforeunload = null; }); }); edit: you can add this to allow f5: $(document).on('keydown', function(e){ if(e.keyCode === 116){ window.onbeforeunload = null; } });
Aaaand, this has been the issue with React from day one.
Here in Portland, we're all talking about Trending Topic 4. It's pretty obscure, you probably haven't heard of it.
Don't know why people downvoted you, but this was my first thought too. This makes installing top-level packages much better on Windows, but also negates the attraction of Bower besides simply being a separate folder.
Nothing's wrong with it. I just really wanted to use Atom for everything. I've compared and discussed my favorite text editors [here](http://www.reddit.com/r/webdev/comments/31vmf1/what_is_your_favorite_lightweight_code_editor/cq5fdq1). If you're really curious, I'd check that out.
Thanks for the suggestions. I saw YDKJS suggested in another thread a few days ago as well, I'll definitely have to check it out
Thanks!
Disclosure: self-post
Thanks for the input! I wouldnt be able to show the stuff I've done so far but I'm going to start thinking about something I can do on the side.
&gt; Has that changed? For me it has. Only start up is a little slow, but that doesn't matter to me. I used to love sublime, but I wouldn't want to go back to it now.
I think it's cool and it might be a good way to learn regex. I probably wouldnt use it in a project but just as a tool to help me work out what regex I should use in my project.
how did go OP?
Trending Topic 2 is lame. Everyone knows.
I find the idea pretty good, but it can take a lot of space to do something simple like generating a range. I wonder if you've thought about changing some of the functions to support chaining. If you don't know what that is, it's the difference between being able to do this: var reg = xeger(function(x){ x.any(function(x){ x.literal('a'); x.to(); x.literal('z'); }); }); and this: var reg = xeger(function(x){ x.any(function(x){ x.literal('a').to().literal('z'); }); }); The way you've set this up (where each function basically just appends to a string) doesn't make this difficult. you'd change your functions to return the object instance. for instance, for the 'to' function: Xeger.prototype.to = function () { this.add('-'); return this; //returning the instance enables this }; 
&gt; the issue do go on about his ambiguous "issue" 
TY!
TY!
TY!
jquery changes the `this` in click callbacks to point to the dom element. When you call it yourself through the console, you're not making that change.
I can't imagine why this is being downvoted. This is a serious suggestion and is exactly what we're doing at Adobe. We use the [Webcomponents.js polyfills](https://github.com/webcomponents/webcomponentsjs) (which were developed as part of the Polymer project) to enable us to use webcomponents that work all the way back to IE 9. We're not composing entire applications with web components, we're using them to build UI widgets that are used by different products with different stacks. Web components, specifically custom elements, give us a way to do that in an interoperable fashion that doesn't force one product to adopt a different stack just to put an autocomplete widget on a page. [**Custom elements are a W3C standard**](http://w3c.github.io/webcomponents/spec/custom/). I would highly recommend looking into the different standards that make up web components and using web components to build discrete widgets and interactive elements in your next project. Read more at [WebComponents.org](http://webcomponents.org/).
With custom elements, you can simply write the namespace as part of the element name. Let's say you're building a UI library called Coral, and you want an Autocomplete component. Call the element `&lt;coral-autocomplete&gt;`, and it's effectively "namespaced" under the `coral-` namespace. Store its constructor as `Coral.Autocomplete` inside of the `Coral` namespace and you're done. That's good enough for me. That said, we're using [custom elements](http://w3c.github.io/webcomponents/spec/custom/) and the [Webcomponents.js polyfills](https://github.com/webcomponents/webcomponentsjs) (which were developed as part of the Polymer project) to enable this on older browsers, but [you can do the same thing in Polymer](https://www.polymer-project.org/1.0/docs/devguide/registering-elements.html).
`self` is ALWAYS going to be `window` in this case. It simplifies down to this inside your IIFE: (function () { var self = this; })(); Inside of the body of an IIFE, `this` is set to `window`, and you're storing that reference in a new variable called `self`. `self` is never going to change after you set it, so it will always point at `window`. This line also makes no sense: jQuery(document).ready( searchForm ); `searchForm` is not a function. `searchForm` is whatever running that IIFE *returned*. Since you `return this;` inside your IIFE, `searchForm` is set to `window`. So that last line is identical to: jQuery(document).ready(window); which makes little sense. What are you trying to accomplish here?
I'm trying to make a reusable object with some methods that can be used as event handlers and also some methods than can be called when necessary elsewhere in the code. ----------------------------- Edit I think this does what I want now. But is this even the way it should be done? var searchFormDefinition = function(){ var $ = jQuery; var self = this; var $residential = $(".section.residential .section-details:not(form)"); this.toggleResidential = function(){ console.log('this is', this); console.log('self is', self); $residential.slideToggle(1600); return 'buzzbuzz'; } var observationSetup = function() { $(".section.residential .section-header").eq(0).click( self.toggleResidential ) } observationSetup(); this.toggleResidential(); }; jQuery(document).ready( function(){ globalsf = new searchFormDefinition(); console.log( 'test is ', globalsf.toggleResidential); } ); 
Here's what I would do: jQuery(document).ready(function () { var $residential = $(".section.residential .section-details:not(form)"); function toggleResidential () { $residential.slideToggle(1600); } $(".section.residential .section-header").eq(0).click(toggleResidential); window._myHandlers = { toggleResidential: toggleResidential } }); // now I can do _myHandlers.toggleResidential(); // (when the page loads) There's no need to do anything as complex as you're doing. You just need to both attach the handler using jQuery, and store it someplace globally accessible. **Edit**: Though I lied, ACTUALLY what I would do is... Sample HTML: &lt;div class="section" data-section="residential"&gt; &lt;h1 class="section-header" data-for="residential"&gt;Residential&lt;/h1&gt; &lt;p class="section-details"&gt;...&lt;/p&gt; &lt;/div&gt; &lt;div class="section" data-section="commercial"&gt; &lt;h1 class="section-header" data-for="commercial"&gt;Commercial&lt;/h1&gt; &lt;p class="section-details"&gt;...&lt;/p&gt; &lt;/div&gt; &lt;!-- ... other sections ... --&gt; Code: var $ = jQuery; $(document).ready(function () { function toggleSection (name) { var selector = '[data-section=' + name + '] .section-details:not(form)'; $(selector).slideToggle(1600); } $('.section-header').click(function () { var sectionName = $(this).data('for'); toggleSection(sectionName); }); window._shortcuts = { toggleSection: toggleSection } }); // now I can do _shortcuts.toggleSection('residential'), // _shortcuts.toggleSection('commercial'), ... // and I don't have to write a bunch of different mostly-identical // handler methods for different sections. :)
sorry, the example will be released soon. the Angular team asked us to add more end to end tests and upgrading our build process as we're moving the repo into the angular github org
You can force this on a function with bind, like so: $(".section.residential .section-header").eq(0).click(toggleResidential.bind(this)) jQuery has a method for this as well: $(".section.residential .section-header").eq(0).click($.proxy(toggleResidential, this))
Yes, but simple code for toggling a div isn't really my problem. Being unable to create a reusable object and know with certainty when and what the value of "this" or "self" will be is what I'm trying to figure out. There's going to be more than 4 of these toggleable panels (with child toggle panels) so I'd like to have each represented by its own object. Call me dumb but I've been trying to figure "this" kind of shit out since 1999. Every time I think I'm making progress I have to switch to another task that doesn't involve any JS for months at a time. Regarding edit, yes all code will be set up to be generic. Mostly just toggling all siblings except for a few special cases where a panel can have multiple sections open simultaneously, or where a panel is forced always open. Yes this is basically just a set of accordians with accorians within accordians. Yes I could just use the first jquery accordian I find.
The nesting behavior is still there, but it only surfaces when there are conflicting versions of a package. That's different from a system like bundler which refuses to work or does something wrong when there is a dependency conflict.
We just use straight `require` calls, and mock out dependencies for tests with proxyquire.
&gt;There's going to be more than 4 of these toggleable panels (with child toggle panels) so I'd like to have each represented by its own object. As somebody who does large-scale web development for a living, I promise this is not going to be useful and not worth the extra complexity. The way you've written it with the constructor function will work. The reason `this` works when you do it that way is the semantics of the `new` keyword. Invoking `new fn()` creates a new object and then invokes `fn` with that object set as `this`. That's not the same as using an IIFE, where `this` is always set to `window`. The same thing would work as an IIFE if, instead of doing var searchForm = (function () { var self = this; self.fn = function () {...} return self; })(); you did var searchForm = (function () { var self = {}; self.fn = function () {...} return self; })();
Or if you're using browserify or webpack you don't need to upload node_modules, you just upload the build files.
there any advantage of using es6 over clojurescript?
[Something new I can stress over! Weeee!](http://i.imgur.com/l0d2VLp.png)
Go.... on
Node.js has no issue with long paths; it's written with them in mind, using the appropriate APIs for that. However, lots of other things don't support long paths, even Windows Explorer has big issues with it. This means that if you just want to `npm install` something, there's no problem, but if you want to manipulate it in any way, even something as simple as removing whatever you installed with anything else than npm, you will encounter issues.
^
disable adblock. 99% sure that is your problem.
Let's not try and pretend bower is sane.
You must be fun at parties.
And high and mighty pure frontend devs are very frustrating to those with a strong backend capability. 
Welcome to the developer community. You must be new here. We're a bunch of immature little shits.
Could you expand on this?
Looks like u are having a problem with virus.exe? Jk jk
Yes and No. I'm pretty late to the ES6 game, but have been trying to keep up on the new features. From what I understand (from the blog post) is that Symbols are Types (just as Object, Number, etc are types in JS). However, because Symbols are all unique, without a reference (`var x = Symbol()`), Symbols are never equal; so `x === x` will eval to True, but no other Symbol will. var x = Symbol('test'); var y = Symbol('test'); x === y // false Symbol('test') === x // false I have no idea how the engine interprets Symbols, but I'm sure someone on this sub does who can explain it.
robocopy, ftw! mkdir dummy &amp;&amp; robocopy dummy node_modules /MIR &gt;NUL &amp;&amp; rd dummy
the only bit i found really interesting is the global symbol store (ie: `Symbol.for('key')`) which crosses into iframes and web workers. 
I'd go with a lib where someone or a community has solved the problem already. I've not personally had to support multiple languages so far, though I know the term is called i18n / Internationalization. The typical way to go about it is have each language you support as a separate resource, why would you want to download every language as a user? Do an AJAX request and any other appropriate logic when switching languages. The approach seems to be you assign a key to any text you provide translations for, such as a key of 'greeting' with 'hello' for english, and other languages use their language code(en for english) along with the 'greeting' key(this is for you and will always be the same) followed by the value for the translation such as 'hallo' 'bonjour' 'hola'. A quick google search gave me this: http://i18next.com/ it's i18n for JS, no idea what is most commonly used.
What is your concern? A symbol is a unique value. What you've explained is how they operate.
Sounds to me like exactly how it is expected to behave, or am I missing something?
Great suggestions. I just released 1.3.0 which includes chaining, since someone else mentioned it earlier. I also like the `valueOf()` and `toString()` ideas too, I'll add that. I also agree it's important to learn Regex. In fact, the readme basically assumes you already know regex. It's similar to db ORMs. I'd hope back-end devs know SQL before they start doing db migrations with Rails. It doesn't mean we can't try other ways to the same thing though.
&gt; It doesn't mean we can't try other ways to the same thing though. Agreed. I don't think there's anything wrong with this project at all. I see potential in it being a useful tool to generate regular expressions pre-runtime. There isn't any reason a build tool couldn't execute Xeger and replace it with a regex in the application code. Likewise, with existing "playground" tools like jsfiddle, I imagine this can help people out who just need a regex to plug into their application. Anyway, I forked the project to play with some of this. I'm also making a TypeScript definition file for it.
That is exactly how they are supposed to behave, you aren't missing anything. The only time Symbols will be equal (aside from assigning a single symbol to multiple variables, of course), is when you use the global registry. For the same reason, incidentally - Symbol.for returns a pointer to the same Symbol when the inputs are the same: Symbol.for() === Symbol.for(); // true
He/she doesn't seem to understand reference equality
Whatever is building your project should be running an npm install anyway, don't upload dependencies, if you want a local mirror for security or safety then mirror the repository wholesale.
This is what you actually want: var searchFormDefinition = function(){ var $ = jQuery; var $residential = $(".section.residential .section-details:not(form)"); var searchForm = { toggleResidential: function(){ console.log('this is', this); console.log('self is', self); $residential.slideToggle(1600); return 'buzzbuzz'; } }; var observationSetup = function() { $(".section.residential .section-header").eq(0).click( searchForm.toggleResidential ); }; observationSetup(); return searchForm; }; Now you can call: var mySearch = new searchFormDefinition(); mySearch.toggleResidential();
It's easier to write software than reverse engineer it. If your application is truly where the secret sauce is, its unlikely a compelling business case, no? 
it depends on the app, but often the secret sauce can be hid behing a REST service, such that the app itself is just boring generic code.
java !== javascript &amp;&amp; ham !== hamster
* The chances that your electron app contains something worth reverse engineering is very low. * If it truly does contain something that valuable, then you could hide that part on a server and call it remotely. * Obfuscating code etc will harm your ability to debug and support any problems which appear in the field once the app is released. That is a real cost. * If all else fails, use a legal solution and skip messing this technological ones. 
Have you seen http://enclosejs.com/ ?
I'm surprised it's taken this long for NPM to correctly update subdependencies, or deal with updates to shrinkwraps. Does no one else ever develop applications with changing dependencies? I've had endless headaches at work over this. I ended up writing a script that scans the node_modules folder to make sure it matches the shrinkwrap, and then if it doesn't, deletes the whole folder and re-runs `npm install` because NPM needs its hands held. so I'm really excited for this update!
Still nothing to differentiate ES6 to ES5 sources ?
I don't think it contains any code worth a reverse engineering effort tbh. The initial project requests desktop applications that work offline to interface with their hardware, at a later date they'd like to expand with a web service. Sourcemaps get around those obfuscated code issues :) Have you experienced an issue when they didn't? Could you expand on legal solution? Do you mean patents?
http://emberjs.com/blog/2013/05/03/ember-data-progress-update.html explains what ember data actually is and why it's cool.
http://stritti.github.io/log4js/docu/users-guide.html looks like a good option
This probably is not the kind of control you want, but just in case you don't know it: The [Console API](https://developer.mozilla.org/en-US/docs/Web/API/Console) offers more than just `console.log`, and accordingly console tools offer you _some_ controls to manage that. In particular, Chrome, Firefox and IE (current versions) all offer you the option to only display certain _severities_ (i.e. `error`, `warn`, `info`, `log`). In addition to that, both Chrome and Firefox consoles, let you _filter_ the displayed items with a key/regular expression. Additionally, use of `console.group` and `console.groupCollapsed` may help you organize your console view. Of course, this doesn't _turn off_ the `console` calls. But at least it does give you some control as to what is displayed in the console.
Only works for v8 bytecode. Probably usable in this case, if you can get it to run with electron.
The stuff you pass to Symbol is for labeling purposes only when console.logging a Symbol. It has no bearing on the hidden, always unique Symbol value.
I'm with you. I now use webpack, but bower never did me wrong.
or of course document.getElementById("myImage").src = 'http://www.site.com/test?a=' + seconds + '&amp;b=' + (seconds - 21600); // edit: brainfart
I've been using Atom for a few months right before 1.0 release but switched back to Sublime. There is a lot of issues with keyboard shortcuts (at least on Windows) and app overall stability is severely lacking. Other than that, and subpar perfomance, it's a decent code editor and pretty much best alternative to Sublime and jetbrains products. I feel like playing with it again sometime in the future.
The Client has stated due to certain customers policies(some are government) that running web servers/services on the machines the software to be used on is a no go. They were rather reluctant when I mentioned Electron uses Node and Chromium thinking it'd cause problems with policies the IT departments put in place. I've been thinking perhaps the sensitive code can be compiled into a dll that Node can access? Haven't done this before.
I was thinking more about error messages which users see and report to you. They don't have source maps and it can be hard to go from a obfuscated stack trace back to the source. If someone copies code out of your app then you may have a copyright claim against them. 
That was inevitable.
Smart quotes, variable assignments and missing semicolons were problems found. var sheet = SpreadsheetApp.getActiveSheet(); var startRow = 2; // First row of data to process, assuming headers var startColumn = 1; // Last row of data to process var lastRow = sheet.getLastRow(); // Number of rows to process var lastColumn = sheet.getLastColumn(); // Fetch the range of cells where data exist var dataRange = sheet.getRange(startRow, startColumn, lastRow, lastColumn); // Fetch values for each row in the Range. var data = dataRange.getValues(); var j = 0; var i; var oldBin; for (i in data) { var row = data[i]; var nextRow = data[i+1]; var prevRow = data[i-1]; var bin = row[1]; var nextBin = nextRow[1]; var prevBin = prevRow[1]; if (oldBin == prevBin) { j++; } if (nextBin != bin &amp;&amp; nextBin != "empty" &amp;&amp; j&gt;=29) { var j = 0; } else if (nextBin != bin &amp;&amp; nextBin != "empty") { sheet.insertRowAfter(i); sheet.getRange(i + 1, 1).setValue("empty"); //marking the row as "empty" } } //End "for"
Every obfuscation can be reduced to plain JS - without variable names etc. Even v8 byte code might be disassembled soon if that is an issue. Still, as most people correctly remarked, it's usually not worth the hassle.
Don't write "plugins" - just solve problems in isolation as much as you can. A good practice nowadays is to author in CommonJS and publish to npm, as it works with a variety of tools (webpack, jspm, browserify). Or you can author in ES6 and transpile on pre-publish to CommonJS. 
So CommonJS format is the best bet?
Give examples of uglified code and try to quantify how much work it would take to clone it rather than just write the same conceptual program. 
serious question
I tried, for some reason they still believe others would put the effort in to reverse engineer, and yet if compiled to bytecode/binary they believe this type of person would drop their efforts. They mostly seem concerned about sensitive algorithms they've developed, I'm going to look into Edge.js to provide that code via a dll which should make the Client happy :)
This is not the right forum for these kinds of questions, but I'm bored, so what the hell. The "1 review" and "write review" buttons both have an onclick attribute that makes them do to the following when they're clicked: $('a[href=\'#tab-review\']').trigger('click'); This bit of code means "Find all links whose href attribute has the value #tab-review and do a click on all that you find". There are no links with the href value #tab-review, so clicking on these buttons will not have any effect. Seems that you need to enable something to provide the review functionality. I have no idea what that might be.
np!
You should get them to clarify that policy. There is no real difference between a compile program that replies directly to function calls (like say a DLL) and a local hosted, bound to 127.0.0.1 address. If the ddl exists, physcial access allows the method calls against that DLL. If the web server exists then, local access allowes calls to the end points. If your end goal is (wrongly) protecting the source on the client side while still using Javascript, then you will just have to get creative with your solutions. Let me know what they clarify, as they likely have the wrong concept when it comes to a local server/services that is only accessible to the host that is running it (the client machine and not outside the host system or network). 
I put it in all my apps. 
Have an application with a week+ old npm-shrinkwrap, and run npm install in its directory. Have someone clone the repo to another directory/computer, remove the shrinkwrap so they can update things, maybe fiddle with package.json to change some versions, run npm install to get the latest (within the given ranges) dependencies and subdependencies, create a new shrinkwrap, and make a commit with the shrinkwrap. Back in the first repo, pull the commit with the updated shrinkwrap, and run npm install. NPM doesn't actually guarantee that the full shrinkwrap will be installed! Subdependencies may not be updated. (This is a fun thing to discover when the application has already been deployed to production.) Then there's other cases like this - https://github.com/npm/npm/issues/7268 - where it detects that subdependencies have become incompatible but puts no effort in to fixing it. The above seems to be a perfectly normal workflow for developing an application with a team where we're often updating our dependencies, sometimes about once a week or two. And NPM often fails us, and I have to go to my affected coworker and explain that they need to delete their node_modules directory and re-run npm install for the build to actually work.
They had mentioned something about that customer having heavily locked down systems where some local ports were being blocked?(though that's unlikely a problem, just use an available port right?) Along with it causing more trouble with IT and providing support, though I think this was more to do with running Node on the customers employees desktop environment. Would you still push for the REST api service? DLL files is possible via Edge.js on Node. This should protect the sensitive source code in question right? It's just a collection of algorithms that take in values, apply some logic and then return those values from what I understand.
edge.js? .net is very easy to decompile as well.
Given similar obfuscation, I'd much rather reverse-engineer a statically typed DLL, than a dynamic blob of javascript. You just get a lot better code navigation abilities and that's a huge part of quickly going through code
Here's a copy and paste of the file I wrote yesterday to upload videos to my S3 bucket: var AWS = require('aws-sdk'); var co = require('co'); var debug = require('debug')('app:sqs'); var assert = require('better-assert'); var _ = require('lodash'); var s3 = new AWS.S3({ apiVersion: '2006-03-01', accessKeyId: 'XXXXXXXXXXXXXXXXXXXX', secretAccessKey: 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX', region: 'us-east-1' }); exports.uploadVideo = function*(data) { assert(_.isString(data.filename)); assert(data.body); // buffer, string, or stream assert(_.isNumber(data.size)); var params = { Bucket: 'myLittleBucket', Key: 'source/' + data.filename + '.webm', Body: data.body, ContentType: 'video/webm', ContentLength: data.size }; return new Promise(function(resolve, reject) { s3.putObject(params, function(err, data) { if (err) { return reject(err); } return resolve(data); }); }); }; Just remove the Promise nonsense. Is that what you were looking for? The only way to be productive with AWS is to go to the actual API docs (http://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html), find the service you need (S3 in this case), create an instance of it, and then find the method you need to call on it. The `params` available seem overwhelming, but the docs clearly mark the few that are required (like the bucket name, upload payload, etc).
No, use UMD for maximum compatibility. Works with AMD or CommonJS, browser or server. https://github.com/umdjs/umd/blob/master/README.md Some build tools like webpack can be configured to add the UMD boilerplate for you, e.g. with webpack you author using CommonJS and specify your output to be a library with a UMD target.
I've added a link to it from the readme. Great job!
someone deserves some free spices.
A better, more useful way to grab specific elements is `querySelector()`. It works with CSS selector syntax so to query a specific element you can use `querySelector('#elementIDName')`. It can also be used on classes: `querySelector('.className')`. If you want to grab a whole set of elements you can use `querySelectorAll()`.
ES6 Modules with Traceur transpiler. Grunt or Gulp build system
So many unnecessary DOM queries happening. Oof. 
It seems to be over now, but what is/was DevWars? 
ITT: No consensus Ideally: ES6 Modules with no build step
Browsers don't support CommonJS modules either. Webpack, browserify, etc. support both.
I think that libraries are the primary use cases anyway. Casual programmers should probably not use them.
what is the 'co'? 
DevWars is a live game show where you watch 2 teams of 3 battle each other for 60 minutes to create the best website. The game is recorded and can be researched on twitch under Past Broadcasts. Also, if you're looking for more DevWars recordings, check out YouTube.com/DevWars for more games
another question does the Key name have to match the name of the file, or can it be a randomly generated name such as a userID+timestamp?. Also on your Key: 'source/' is that a required part of the Key or is it something you just added? Also Thanks for the reply I really appreciate it. 
Wow those are actually pretty substantial changes to the api...
I haven't used jest, but we're using gulp, mocha, chai, cucumber, karma, and browserify together without any problems at all. It's been such a smooth integration, we haven't spoke about the stack in some time. It "just works".
Have you actually built anything with JavaScript yet? Doing projects is the best way to solidify what you've learned.
In my experience, I built a project about 3 times over. Each time I'd incorporate a better way to do something. Do a project that'll take you 20 - 25 hours to complete. Absolutely, 100%, FINISH THE PROJECT. That's essential. Then scrap it, and start again. What use to take me 6 months now takes me 2 - 3 weeks but only because I can foresee the bigger issues that pop up at the very end of the project. 
Sure, you're absolutely right.
Do you want something from the shop? Would be more than happy to send a few things over :) please PM!
TypeScript.
If its a simple game, you could just use a webview, and write barely any native code.
I think the question is: "How does photoshop(replace with other big name, offline software) do it?". Of course they aren't made(mainly) with javascript, and you can still get to their source code. Sounds like compiling it to assembly with v8 is the best way to do it.
The problem is probably that you're trying to attach the listener(s) before the relevant elements exist. I recommend to use event delegation. In the future, provide a test case. Use jsbin, jsfiddle, codepen, or whatever.
Check the console for any error message that might help you in fixing it.
Cant really speak for frameworks, but phonegap/Cordova is probably your friend here. 
OP didn't fail. According to the curve my professor gave the class, I'm sitting close to a B! However when I walked out of the exam, I felt like a toddler in an engineering class 😂 Thanks for asking :)
Check out ionic 
I've used [Ejecta](http://impactjs.com/ejecta) to get [three](https://itunes.apple.com/us/app/syrush/id903688443?mt=8) [javascript](https://itunes.apple.com/us/app/kick-bot/id869188877?mt=8&amp;ign-mpt=uo%3D4) [games](https://itunes.apple.com/us/app/scurry/id892274154?ls=1&amp;mt=8) on the app store. It wasn't painless, but it does work well.
I have learned one big lesson about working with frameworks/environements/stuff, and it is this: Do not try to fight the system. Learn to work with it. In other words, don't try to prevent the browser from doing stuff it wants. It's better to preserve the state of what the person was doing, so that when he/she returns to the page, their place and selections are remembered. 
So you're writing a modular front-end application. Maybe one "file" or "module" depends on another. Either way, you have a bunch of javascript files attached to your html page in a particular order. Bower is pretty optional. In some cases, front-end libraries may only support bower. They may have a `package.json` for npm, but most of the time it's for packaging/build scripts for that specific library/application. So you may have to use it regardless. npm is likely the future for front-end dependencies and is the "now" for server/packaging. Everybody hopes that npm will just win already and bower will die out (especially with npm 3-beta now available). The concatenating/hashing will likely dissipate with ES6 browser support since modules will be native just like they are in Node. Automatically appending scripts to the html is a bit hacky, and this has been identified as kind of a anti-pattern. It may accidentally include things you don't need. So to skip the old concat/hash methods of yesteryear, you'll want to use Webpack or Browserify, which basically translate "files" or "modules" into bundles of code. You'll need to use CommonJS/AMD or ES6 module structure to diagnose dependencies between your files. It is a much more future-proof way of concatenating and it supports dependency resolution. As soon as ES6 browser support comes around, you're code should mostly just work (minus a bootstrapping process). Webpack/Browserify can replace gulp, but typically only for gulp-concat/gulp-uglify, which is maybe what you were using to "bundle" into a single a file. It does not replace Gulp in general because Webpack is a module bundler and Gulp is a build system that can do a bunch of other things, like trigger unit tests or code coverage tools. One thing to point out, [gulp can be replaced with by npm](http://blog.keithcirkel.co.uk/how-to-use-npm-as-a-build-tool/). tl;dr - Use npm/Webpack/babel if you want to be ready for upcoming ES6 browser support. Keep grunt/gulp if you need testing/benchmarking.
yay
I always laugh at the thought of a company going under because a competitor got access to their minified source code. 
I saw.
Decorators make 'higher order components' in React really pleasant to work with.
Have you looked at [React Native](https://facebook.github.io/react-native/)?
Every other big software does it simply by being really big. Reverse Engineering takes more time for a bigger code base. It would be easier to develop gimp from scratch that reverse engineer Photoshop.
Well, there are too many libs and they all work like shit.
This is all My Humble Opinion, but anyway... Most of the people who are complaining that the DOM is slow come from a pure web background and have little idea of how native graphics and GUIs actually work and are rendered by the browser, operating system and hardware. They also have little idea of how the browser and layout engines actually work, and hence they don't know what to expect from the DOM nor do they know how to work with the browser and not against it. You can't just spam HTML templates and jQuery all the time and expect it to automatically go fast. The fact of the matter is that if you want your application or UI to run fast then you need to optimise it. You need to understand what Chrome is complaining about when it says "Warning: Forced Layout" etc. But you know what? Native developers often have to do the same thing. Half the reason why native toolkits like Android's XML stuff is so fast is because its developers have spent heaps of time profiling it and optimising it to go fast. 
As someone constantly yelling at people to stop using jQuery to do stuff that's simple in vanilla JS, I love this post.
Android's XML markup is also fairly slow in practice. DOM isn't any slower by itself, because the Android XML is also a Document Object Model. What makes it slow is the layout and CSS. Those have to be recalculated after most actions. 
Do you have any benchmarks proving either of those statements?
Android's styling is much simpler than the browser's CSS.
Mostly yes, also it has to handle malformed syntax correct, while Android's XML does not. Also, the XML style DOM is an inherently slow solution (although it matters very little after the CSS and layout), But we are stuck with it.
One of the big problems in HTML rendering is the sizing model. It's pretty much impossible to lay out any even slightly-complex HTML in a single pass. The DOM API is not very well-suited to high performance, either. If you want to change properties on two different elements at once, there's no simple way to say "Hey, I'm going to change a bunch of stuff on this page, please hold off on rendering it until I'm done". In general, the browser will batch up changes, but only until some operation tries to read anything from the DOM, because at that point you need to re-layout everything, in case the element you query moves or resized because some other element moved or resized. Along the same lines as the Flipboard blog post linked here earlier, when my former employer was trying to optimize scrolling and layout performance on mobile browsers, we went through fairly heroic efforts to avoid reading from the DOM or creating DOM elements on the critical path for any animations. A lot of our optimizations turned out to be pessimizations on other platforms, so there was a lot of code that had to run differently depending on which platform you were on.
&gt; One of the big problems in HTML rendering is the sizing model. It's pretty much impossible to lay out any even slightly-complex HTML in a single pass. Could you elaborate on this a bit more? I'm not entirely sure what you mean by sizing model. &gt;The DOM API is not very well-suited to high performance, either. If you want to change properties on two different elements at once, there's no simple way to say "Hey, I'm going to change a bunch of stuff on this page, please hold off on rendering it until I'm done". &gt;In general, the browser will batch up changes, but only until some operation tries to read anything from the DOM, because at that point you need to re-layout everything, in case the element you query moves or resized because some other element moved or resized. Wouldn't this be a problem for any DOM implementation, not just for the web? Android uses a DOM implementation for it's XML layouts but you seldom hear complains about Android's DOM but you often hear about how terrible the HTML DOM is. 
&gt; "Hey, I'm going to change a bunch of stuff on this page, please hold off on rendering it until I'm done". Actually, the existing behaviour is to not re-render until either the currently running JavaScript event terminates, or the script requests information about the document that forces style computation. So, you can achieve what you want already by just not forcing .getComputedStyle until your DOM mutation has terminated.
100% agree with that. IMO depending on browser support one should drop all unnecessary libs and build/use small modules instead. Even with lower browser support polyfills do a great job most of the time. 
Quit reading. Start doing.
&gt; the existing behaviour is to not re-render until either the currently running JavaScript event terminates, or the script requests information about the document that forces style computation I did mention that, in the very next paragraph. It's often not quite so simple as that in practice, given that you're going to have multiple pieces of code that want to control layout, and it can be difficult to do certain types of layout without measuring the size of one or more elements.
What I mean by "sizing model", and I'm sure there is a preferred term for this that I'm just spacing on, given the late hour, is just this: If you have a typical HTML page with a few nested elements, and you want to lay it out into a container (like a page), then you can't just start at the top element and work your way down to the bottom, nor can you start at the bottom and work your way up to the top. A child element can be constrained, or clipped, or scroll inside its parent, and the parent can be forced to grow to accommodate its children. Siblings can push each other out of the way, text might need to re-flow a couple of times, etc... I'm not familiar with the Android DOM, so I can't really comment there. But as mentioned, it's not so much the DOM tree structure itself that causes performance issues, as it is the complexity of rendering that tree.
You're looking for [webpack](http://webpack.github.io/). /thread
In some cases that is faster because their canvas only needs to support a small subset of the entire dom. Therefore they can make a much more "optimized" DOM via canvas that has only a small fraction of the features.
Are there benchmarks that show that jQuery is significantly slower than vanilla JS?
jQuery is a parking ticket compared to the felony that is Angular.
Part of the reason why the DOM is slow is because it is HUGE. I have always been of the opinion that many of the people who complain about the DOM being slow are the same people who are limited to things like querySelectors and frameworks, which really are incredibly slow and are not the DOM. I consider such reasoning as incompetent bitching and quickly move on with life. Compared to pure JavaScript execution the native DOM methods are not fast when it comes to performing complex animations on nodes containing a large number of child nodes and a massive amount of text. Otherwise I would argue the native DOM methods are always fast enough.
Here's the thing, being 10 times slower than super fucking fast is still super fucking fast. I've heard these same arguments about managed languages like Java and C# from C++ programmers for decades. They're wrong. Yes, adding safety and convince costs you hundreds of milliseconds during execution but hundreds of milliseconds is still insignificant. If you are getting poor performance in an application look at your code before blaming the language. Chances are you are doing something in a way that could be done better and that's what's giving you performance problems. Refactor that one offending function instead of dropping all your frameworks and tools. 
UMD is more useful as a bridge to those still working in legacy build systems like RequireJS or just plain script tags. Its easy to get it wrong, it adds bloat and complexity, it is problematic when your library has dependencies, etc. Usually it's better to just author in a real module format (CommonJS/ES6) and automate UMD through webpack/browserify only when necessary for legacy systems. 
I don't think that will save you from the write-read-write problem.
I would have agreed with you three years ago. But eventually (largely thanks to NPM, Browserify and now Webpack) CommonJS mostly won against AMD. Nowadays I would recommend either CommonJS or ES2015 import/export syntax with Babel (which translates to CommonJS by default). UMD is still relevant in a vanishingly small number of use cases, of course. Most notably: if you're writing a library for use in browsers that will be used largely by people who are not using any module systems (e.g. most use of jQuery in the wild). Outside those use cases you can stick with CommonJS for two reasons: 1. Most people already use CommonJS. 2. Those who don't use CommonJS most likely use build tools that can handle CommonJS.
[Cool ES6 stuff...](https://leanpub.com/javascriptallongesix)
Well nothing big, only small exercises but not a real project. The problem all ideas I have need a server-side part and I really know nothing about node till now. Any good ideas for a first little project that's only client sided? Well the first things that come into my mind are a cookie clicker or a calculator... 
But what project could I do, that doesn't require a server-side part? I don't have any good idea like mentioned in an other comment above. 
I didn't edit it. No big deal. 
It's possible to get 60fps without resorting to canvas, but its arguably harder and canvas can provide an easy way out. But with canvas-only you also lose out on a bunch of stuff. Accessibility, native handling of various input devices, and different display types (print vs screen, etc...) Are all out the window. Even things as simple as "press tab to move to next field" or "open in new window" need annual intervention. And by the time you add all that back, you pretty much end up at the same performance of the normal DOM.
No, hundreds of milliseconds is NOT significant in a UI. It **may** be significant in a background calculation that are being done billions of times, but it is certainly not significant in a UI. One hundred milliseconds is 1/10th of a second. It's literally the snap of a finger. It's imperceptible to the human eye. If your user interface requires the user to click buttons thousands of times as fast as they can then you are doing something horrendously wrong.
Because jQuery just littered their code base with calls to sleep(500) right? The last time I saw a library author decide to *go vanilla* and replace all of their jQuery method dependencies they immediately started having to deal with nasty bugs on Safari that the upstream project didn't have. Between the naive VanillaJS implementation that they ripped from the first result on StackOverflow, and the jQuery implementation, guess which one had a fix for a rendering issue with Safari? Don't you think your advice, which doesn't advise people to consult the annotated jQuery source to evaluate if the extra logic is worth the performance price, is a bit irresponsible?
I'd say it's pretty close to what is popular.
Ok, did that, took me like 10 seconds to answer 10 questions from 15 years ago and get that "beginner" badge. Now where's the tough stuff? :)
What issue are you having? I've attached all three events that you mentioned to a single element without any problems.
3417 here hell yeah! lol
I think /u/sime makes a good point. There's [a whole pipeline](http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/) that takes your DOM tree and CSS and turns it into pixels, and it is performant in and of itself. Understanding that process and using the tools available can pinpoint problems once you know you have them. On the other hand, the DOM is a synchronous, stateful abstraction. It's easy to introduce slowdowns as your page (and the number of contributors) grows. You need more and more sophisticated code to coordinate independent pieces and make sure they read/write the DOM effectively. In my opinion imperative code gets very hard to manage at scale. In the case of [React](http://facebook.github.io/react/), the virtual DOM is an asynchronous wrapper around the real DOM. By providing this layer, React does a bunch of the hard work for you, minimizing and batching updates to the real DOM to ensure we invoke the aforementioned pipeline only when needed. It hides the complexities of mutation from the programmer, who can instead focus on clear, declarative rendering code. You could ask, "why don't browser manufacturers provide such an API built-in?" and the answer is more vague. People are working on things like [Web Components](https://en.wikipedia.org/wiki/Web_Components), but standards move slowly and there are many competing schools of thought.
no worries, im on vacation atm i dont think its possible for me to get mail here. thanks anyway
My favorite indicator is normalized NPM downloads, that is NPM direct downloads and not total downloads which also includes downloads of dependents.
If you like using Native DOM API's I think you'll really like [this](https://github.com/eorroe/NodeList-Prototype-Extension) please let me know what you think, and if you like it **star** it thanks :)
There are many easy ways to architect something *like* the DOM, that could be mutated and rendered to screen far more performantly than the current DOM. None of these naive solutions will ever be realized because the billions of web pages on the planet depend on myriad quirks and behaviors of the current DOM. There are probably a few very complicated, very difficult-to-implement ways to make the existing DOM more performant without breaking billions of web pages. It will likely involve tearing apart existing engines and/or building new ones from scratch (e.g. servo).
https://www.coursereport.com in case you want to research others. From what I can tell .isSexy's course is pretty new and wont have any credibility from past students. Kind of a roll of the dice.
The `extends` clause of a class declaration is just an expression that returns a class (or constructor), so you can do something like: `class BookLover extends compose(Person, BookCollector, Author) {}`
I believe lodash will excel in ES2015 for iterable utility functions, like take, zip, union, intersection, etc
Heh, Brackets is above Atom. Also Backbone is still incredibly popular. And Semantic is above Bootstrap. 
Isn't take just another name for slice(0, n)? Anyway I agree some of those functions are still useful. (But I wish they worked with any iterable, not just arrays!) The nice thing about lodash is that it allows you to just import (or even install as separate packages) the functions you need; there is no need to install a monolithic library where a large portion functions were only necessary when browsers just supported ES3.
Yep and also word wrapping and text justification which is an absolute pain to not have although not very simple to do when you consider what it entails.
As a non-native speaker I may have missed to use appropriate terms. Should I change the text to "The table shows statistics and a ranking of the 10k most interesting JavaScript projects"? Is "popular" ok when we focus on the timeframes "popular today", "popular this week", "popular this month" or should i call it "trending"? 
Brackets: 22.6k stars | 4.7k forks Atom: 17.5k stars | 3.0k forks (but Atom is "trending" with +155 while Brackets lost -93 points this month) Backbone: maybe was(!) popular. It lost 96 points this month Semantic vs. Bootstrap: When you click on the Bootstrap link you will find that "angular-ui/bootstrap" is meant. "Bootstrap" doesn´t count as a JS project and is not recorded (but I can see that this is missleading and think about adding the name of the owner) 
..."or have been interested in"! When "angular 2" doesn´t get enough stars/forks to beat "angular" before they start "angular 3", "angular" may stay on the top of the list for ever. The first column is a eternal ranking. But my focus is on the three right columns of the table that shows "activity", "trendiness", "interestingness" or "popularity" of a project in a certain timeframe and some of the dynamics in the community. I will think about it...
So much overlap. Such a waste.
Oh! That is cool. I love JavaScript :D Expressions everywhere! Could even be a little crazier and do: class BookLover extends components `Person, BookCollector, Author` {}
nobody said something about "usage statistics" or what you can find in the wild. When you shorten "most popular JavaScript projects on Github" to "popular on Github" you are pretty close to what the table shows. i think this guy understood the difference: https://twitter.com/vallejosfab/status/614876855305379841
Click bait.
I definitely find myself squinting a lot in codebases that make extensive use of Lodash. Unfortunately, no matter how much I try to avoid it, I always end up needing *something* from a utility library. With Babel though, I always feel like I've failed once I start reaching for utility functions. Not sure if that's good or bad.
And as a reminder for those of us still supporting IE8 and other ES3 browsers - there's an [Array.generics](https://github.com/plusdude/array-generics) project for supporting the ES5.1 methods shown in that post.
And don't forget about the performance boosts _over_ native APIs. Edit: bustin my balls /u/TMiguelT bustin my balls. 
Bit off topic but when did the whole ES2015 vs ES6 thing happen? Only just really noticed it in the past few days always thought it was ES6.
Lodash-fp and Ramda auto-curry. Built-in functions don't offer this.
Very good points. I was actually on the verge about omitting that replacement for `_.range` from the article because yes, it's ugly and not as obvious as other examples on the page. But I do think it's a nice example of how `Array.from`works. Other ways to achieve it include `[...Array(n)].map((_, i) =&gt; i + x)` and `Array.from(new Array(n), (_, i) =&gt; i + x)`, which are both equally ugly. So I guess this might be a case for a library function. But maybe if I would only need this once in the codebase I would still use this hack instead of pulling out a library just for this. Wrt (2), some people actually think having separate functions for those different use cases is better than functions that do type checking and have different return types based on the input. That's why Ramda has separate `map` and `mapObj` for example. And while this might work for arrays and objects in Lodash, the support for different collections is far from universal, with `Map`, `Set` and other `Iterable` collections missing.
Thanks for the link. [es-shim](https://github.com/es-shims/es5-shim) is another project that polyfills those ES5.1 methods for old browsers.
It's debatable, really. I think GitHub generally uses the term "trending" like here: https://github.com/explore Personally I think "most interesting" isn't entirely correct either. That people are interested in it (i.e. paying attention) doesn't mean it's interesting (i.e. deserving attention), just that it's good at grabbing their attention. But that's probably splitting hairs. ;)
You're returning the result of evaluating the strings (true when not empty, IIRC), not the strings. Delete the parenthesis surrounding the strings to be returned.
Sure. If it's a big general purpose library people who don't use a module system are likely to be interested in, go ahead. Hence my example of jQuery (which simply doesn't play nice with module systems because the plugin system is based on patching the global jQuery object).
Another thing about take is that if you're using lodash take is one of those functions that will commonly be leveraged by shortcut fusion, and can therefore offer substantial optimizations (especially against large datasets, obviously). Not saying you're wrong, obviously, but being a little pedantic because it might be helpful to someone to know this.
2702 and 2931 :)
"Don't use lodash, use ES6 functions and add an entire compile step to your code if it didn't have one before!"
It's already sort of supported in ES2015, just not directly through `Symbol.iterator` and spread: `for (let [key, val] of obj.entries()) { /* do stuff */ }`
Yup. The conclusion, as always, is educated and judicious use of all tools. I don't think verbosity vs. complexity is a worthy evaluator. 
that's a very good point. Edit: but based off of his history, it looks like isometric is his.
why? I have 10 years Angular, 10 years Backbone and 15 years react experience and I'm just finishing my first internship.
I'm assuming he's referring to this: https://developers.google.com/speed/articles/reflow 
You need to be careful with data types. What you're getting from the prompt is a string, so your avgArray looks like this, for example: ["1", "2", "3"] And the result of what you intended to be a sum will actually be: "123" And your average is 41. To fix this, you can parse your strings to floats or integers. Tip: As you're learning, it's really helpful to use console.log() throughout your code to see if the results you're getting are what you intended.
`return` is not a function, it's a keyword. so replace `return(whatever)` with `return whatever`. Here is a nicer version: function compare(choice1, choice2) { if(choice1 === choice2) { return "It's a tie!"; } else if( (choice1 === "rock" &amp;&amp; choice2 === "scissors") || (choice1 === "paper" &amp;&amp; choice2 === "rock") || (choice1 === "scissors" &amp;&amp; choice2 === "paper") ) { return "Player 1 wins with " + choice1; } else { return "Player 2 wins with " + choice2; } } It's also a good idea to make sure the input is valid at all, this code assumes that both of the arguments will be `'rock'`, `'paper'` or `'scissors'`. So you could put something like this at the top of the function: var choices = ['rock', 'paper', 'scissors']; if(choices.indexOf(choice1) &lt; 0 || choices.indexOf(choice2) &lt; 0) throw new Error("Not a valid choice! We're playing rock, paper, scissors here."); 
Wow, turns our I actually did write one of them.. too bad I can't even get interviews.
why does this list start with 0?
In your last example, you're passing Name instead of Key in your if statement.
But we are talking about the most popular, not what's most used? Popular is pretty broad, I'd say. No one said or would even agree that Angular is the most used JS, but many would agree that it's the most popular. 
No, you're right. I might not need it - I could just go back to using loops for everything. But then I'd have to write it, and fix my bugs, and explain to everybody else wtf it does. Or, I could just use it.
And don't forget, performance is almost never going to be a problem for the vast majority of javascript people are writing. Optimize when you find that things are slower than you'd like.
HackLang (facebook's PHP with cool stuff)
I find it humorous to see things like select2, a little drop-down utility, compared to ember.js and other major frameworks.