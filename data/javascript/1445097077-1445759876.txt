In all honesty, it would be a lot easier to find and fix any errors if this was in a [jsfiddle](https://jsfiddle.net/) or something of the sort.
Awesome!
You can surely use modules with functional programming. FP is not about 100% functions, its more of an idea/theory that has proven itself over and over to be a better way, comparing to a traditional oop way, with mutable and global state/variables.
typeof complex === typeof complicated
Did you also have issues getting the modal to open, it looks like it's not doing so in the fiddle.
no it opens on my computer fine, maybe the transference to the fiddle is where it messed up.
That's because /u/hoorayimhelping made that post.
https://css-tricks.com/snippets/css/a-guide-to-flexbox/
This. Learning Clojure will make writing functional JS really easy (but a word of warning, you'll never want to write a line of JS again after writing Clojure for any amount of time)
Is there a reason you're using absolute px for the width/height instead of percentages? At first blush, that would be my first stab at simplifying that; if you want a box that's 1/3 of the width of the parent, make it width: 33% instead of doing those reads with js.
Woah
Not even close. Completely different problems. One of them is described by "chaos" (the math. theory), the other one isn't. "Complicated" still is predictable with finite effort, a complex system isn't predictable with any amount of effort. "Predictable" as in F=m*a always, but the weather forecast only approximately and for very limited conditions (for example, 2 weeks max. out of billions of years, in a small area on earth out of the entire universe).
But I don't keep the stage to any specific ratio, it will need to be resized a lot to all kinds of aspect ratios. It's the boxes inside that need to keep an aspect.
It doesn't matter too much, but there's a bug in the Iterator-only code, there the internal _index never gets reset so you could only do a for-in loop once per object. But Generators sort that right out!
Another option with good support if you have to be fixated on aspect ratios like that is svg &lt;image&gt;. Aspect ratios are built-in concerns for svg, though you may have issues with IE8 and under.
I'm talking about the thread. I didn't make this thread.
 function vowelCount(str) { return str.toLowerCase().split('').reduce(function (memo, char) { return ['a','e','i','o','u'].indexOf(char) !== -1 ? ++memo : memo; }, 0); }
What do you mean by "do not cause side-effects"? 
Depends how you define 'easier', but I don't think it's inaccurate to say my code is much easier to read, and, frankly, better written. Again, it's not perfect, but there's very little logic, all the variables are clearly labeled, it's pretty DRY, and, somewhat importantly, there's only about 20 lines. Unless you're uglifiying/minifiying code for production, it's not a good idea to use single letters as variables/parameters because we're not computers. Having the compiler process a few more characters is insignificant compared to struggling trying to remember what "a", "b", and "c" are doing. If you want to re-write the jQuery in JS, you're more than welcome to. I did it because this was a prototype, and speed of production take precedence over performance when prototyping. Feel free to search for alternate solutions on how to maintain aspect ratio. [I followed this.](http://stackoverflow.com/questions/1495407/how-to-maintain-the-aspect-ratio-of-a-div-using-only-css) 
As everyone else has said, it is the way you're doing a comparison with this line if (str[i] = 'a','e','i','o','u'){ I think this is an interesting take on "contains" or "in array". I could only assume that you're trying to say &gt; is str[i] equal to 'a' OR equal to 'e' OR equal to 'i' and so on I'm not much of a programming language polyglot, but I'm not sure if that syntax exists in any language. The only thing that I can think of is python's in check. if str[i] in 'aeiou': #python My advice for the future would be to console.log where you think the issue is occurring. My first attempt at debugging the code above would to put a console.log('in here', str[i]); inside of the if condition. That wouldn't show up, so I'd console.log(str[i]) before it. Then console.log(str[i] = 'a') which would return 'a' no matter what str[i] actually is. From that point you'd see that a single equal sign is an assignment and not comparison operator. Long story short, throw some logging in there and check the console against what you expect the values to be at that point in your code. Have fun programming 
Did you try [jQuery.removeData()](https://api.jquery.com/jQuery.removeData/), [like so](https://jsfiddle.net/jt0bkq0m/2/)?
&gt; More important: I don't use inheritance for any size projects anymore - neither classical nor prototypal. I have not a single this or bind anywhere any more. I always know what a variable points to, it's all lexical scoping and factory functions returning interface-objects into the lexical scope when I need an object. Coming from classical OOP this is the concept I am having the hardest time with. Do you have any open-source work that serves as an example of a large-ish system (something more than a coding example or a todo list) using this structure? 
Also getting this issue as of a couple days ago
I don't think MVC is enough to warrant a book on its own. You'd be better off looking at a book about whatever technology you're working with, which will include stuff about MVC if it is applicable.
The smallest unit where this is relevant is the "module". It does not matter if your system has 10, 100, or 10,000 modules. If you want you can mix the styles per-module, while many will gasp at the suggestion my point is if the interface between the modules is clear then it does not matter that much what you do inside any one of them. So I don't see why you need a "large" project as an example. It should not make any difference. All you need is to know the basic pattern, how you write a module that doesn't have any of *this* (haha - pun intended?): You simply rely heavily on *lexical scoping*, so you *see* what you have access to and where and simply use normal variables. In contrast, with objects, `this` and its properties and methods on the prototype you need to follow the actual execution to see what values are actually being used. Everything that usually is on `this` now is in the closure of the function that was called. If this returns not just values but something more durable that function creates an object with "API methods" that it returns, and through that object the caller gains controlled access to the closure created by the generator/factory function. This also removes any questions about "private properties" - *everything* is private (inside the closure) unless it is explicitly put into the returned API object, which should only contain functions, normally. Any value-holding properties now all are normal variables in the closure, there is no `this` object. 
I recently switched from grunt+browserify to gulp+webpack. The differences are staggering. The separation of vendors/app code, watch and hot update speed, webpack blows the competition out of the water. Mere days after I started my project with browserify, watch and rebuild took over 4 seconds. I managed to optimize it down to around 2 seconds, which was still much longer than it takes to switch to the browser and refresh the tab. Webpack does it in well under a second, while watching ONLY the things in my dependency chain (and not something like `folder/**/*.js`).
The problem you're encountering is that the value of `u` is changed by the loop. All of your functions are referring to the same `u` value. The way /u/andersevenrud suggests you fix it will work, but note that it's sending requests sequentially. This might be what you want, but note that if you have 50 guesses, then the worst case time will be &lt;avg time for one request&gt; * 50.
Ran into this sometime in the last few years. If you plan to perform a series of actions – say in a plugin – it is very convenient, because you can save the object from `.data()` and operate on it; no need to "set" it at the end because the reference is the same. Also, if you call for an argument that isn't on the object, it will go back to the dom to check for it. [Here's a fiddle](https://jsfiddle.net/kr9xm5rh/) 
memes
Using OP's code to make them run parallel: function attemptImageReplacement(pic,URLAttempts) { var finished = false; function checkImage(url) { if ( finished ) return; var evaluation = new XMLHttpRequest(); evaluation.onreadystatechange = function () { if ( finished ) return; if ( evaluation.readyState == 4 ) { if ( evaluation.status == 200 ) { finished = true; switchWithResize(url, pic); } } }; evaluation.open('HEAD', url, true); evaluation.send(); } for ( var i = 0; i &lt; URLAttempts.length; i++ ) { checkImage(URLAttempts[i]); } } /u/DoomTay You might find this [thread] interesting :)
I forgot
Hi /u/peterczar2000, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Please put it in a fiddle.
I think that `display:none` will remove the element from the layout totally which would avoid reflow so that is just like "detaching" it with JavaScript. I think that `visibility: hidden` keeps it in the render tree, and will render it as a blank rectangle. Quote from [google devs](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction): &gt;As a brief aside, note that 'visibility: hidden' is different from 'display: none'. The former makes the element invisible, but the element still occupies space in the layout (i.e. it's rendered as an empty box), whereas the latter (display: none) removes the element entirely from the render tree such that the element is invisible and is not part of layout. So if for example you change the height of a `visibility:hidden` element, this can still cause a reflow because the render tree will be updated. A `display:none` element cannot possibly cause a reflow as far as I can tell.
oh thank goodness. the constant pop up was driving me *insane*
It's an angular project, it also uses a lot of general modules that everyone uses - lodash, moment, jquery, bluebird, etc. Libraries either works out of the box, or very easy to setup. 
MVC is just a design pattern, not the big deal. You can get it by looking at tutorials like [this](http://www.tutorialspoint.com/design_pattern/mvc_pattern.htm). A good way to see it is by the following example: In the javascript context, you originally create a form in the markup(HTML) and when you hit submit basically you need to parse all the fields, validate all the data, and finally create a structure to save it to a persistent storage. People realized that this is a very repetitive pattern in modern systems. So MVC is basically an abstraction to do all that in a way that you can maintain it very easily and if the data schema changes things does not break. Basically you will create a UI based on the object to be stored and the UI contains the bindings to each field of the object along with specifications to its validation. When the form is submited you don't need to parse anything since the form itself is bound to the incoming object and is already validated, so you just either do some business logic with it or save it. The same goes the other way when you want to edit something, you just select the object and it automatically shows in the UI and each change most of the time does not need additional procedures because everything is bound by the MVC framework of your preference. Edit: A lot of typos, sorry.
Curious what you still use gulp for as I was able to replace most of its functionality with webpack, though not sure if I've gained anything as I still find webpack more confusing. Something that's been tripping me up a lot is that all these build tools are so powerful you can do anything with any of them... It's about finding what's a good fit for your workflow
fixed. thanks!
&gt; That's a matter of some philosophical debate. I've taken a few functional programming courses that would disagree with you. FP courses tend to strictly enforce this because it's a shortcut that would let you fall back into an imperative trap. In real world code though, mutation is completely acceptable in a pure functional codebase. Even in Haskell, it's idiomatic to use `ST` to hide mutation behind the scenes, and it's not too uncommon to see `unsafePerformIO` hacks around the place to mutate things where you really shouldn't be. This should always be considered an optimisation where specifically needed (ideally after profiling) rather than being used by default, as in most cases you don't need it - Persistent data structures can counterintuitively often be more performant, especially when using Laziness. 
If this is a production system, please make sure the modal is keyboard accessible! 
Webpack subreddit: https://www.reddit.com/r/webpack/
Your title and your text don't match — do you want to know if the array contains any of those words, or do you want to remove the words? If the former, then use [`Array.prototype.some()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some): &gt; var badWords = {foo: null, bar: null, baz: null} undefined &gt; 'This sentence contains the word foo'.split(' ').some(function(word) { return word in badWords }) true &gt; 'This does not'.split(' ').some(function(word) { return word in badWords }) false If the latter, then use [`Array.prototype.filter()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter): &gt; 'Remove the word foo and bar from this sentence'.split(' ').filter(function(word) { return !(word in badWords) }) [ 'Remove', 'the', 'word', 'and', 'from', 'this', 'sentence' ] Both of these are ES5 features.
I'm using gulp for uglifying and other build maintenance tasks that I don't need when using the webpack-dev-server. So webpack gives me a script bundle, gulp does the same except it also minifies it, puts it somewhere on the disk and does other "buildy" things.
How are "cat" and "hat" unimportant words?
Hi sorry for the confusion, but what I am doing is basically parsing a text for a set of key words. However, these key words often include things like "house" and "cat" which are not as important as things like "Freud", so I would like to remove "house" and "cat" from the list so that my key words only contains the more important words.
This is more of a philosophical topic rather than technical one (although I think both has it's ups and downs). Webpack takes a kitchen-sink approach giving you lot of features in one package(I realize that you can have plugins too) while browserify encourages you to do one thing only letting you build piece by piece. The benefit of webpack (aside from hot-reload) is that it's easy to get up and running in no time since you get all the features in one package. The benefit of browserify however is that since you built it piece by piece you can pluck and replace any packages that you like any time. The downside of webpack is that since you get all the features in one package if you wanted to change any behaviour of certain feature in the core then you can't do so easily as you could do with the other approach. On the other side with browerify, since you have to build things piece by piece it's hard to get started with it in short period of time if you're not familiar with the eco-system. Discoverability becomes an issue for new comers. There's a long discussion [about this already](https://gist.github.com/substack/68f8d502be42d5cd4942) and I don't want to dwell on this again. However, I'd like to see webpack go towards Linux's philosophy more in the future cause I actually like some of the features in webpack too.
&gt; "Favor object composition over class inheritance." &gt; Which is a well-known quote from the GoF book. Naturally, the GoF definitions apply. I stole your line. :) There's new replies in the conversation with Elliott, and your phrasing here was very crisp, so I used it. :)
I tried using webpack with gulp and angular 1.x...I gave up pretty fast on that.
If you are unsure which words are really representative of a category you can calculate [Term Frequency-Inverse Document Frequency](https://en.m.wikipedia.org/wiki/Tf%E2%80%93idf) values to decide what is important and what is unimportant.
I think one thing many are missing with this is that this is a real thing. People are saying things like "just use React" "never use jQuery" etc. - and what's the result? Cargo-cult programming. Especially less experienced developers who are being told these things are prone to not really understanding the difference, and then they just do something blindly, like using React+Flux for something trivial where it would be completely unnecessary.
Modules were the first thing I looked for, too. I don't understand why all of the browser makers would wait for the spec for modules, while they *pushed* ideas to the spec for the other things. 
To be fair, if I had the energy, I'd adhere to a style where you must always pass a boolean into situations where it's going to be coerced. The intent is just more obvious. I don't think I've ever seen code and went "nah, we definitely should rely on more implicit coercion right here". Similarly, I prefer `if (n &gt; 0)` over `if (n)`. Semicolons too are often unnecessary due to ASI, yet I wager most of us reading this write semicolons every time.
You should use watchify instead of grunt watch. Watchify will do incremental builds that take a fraction of a second. It takes the same args as browserify.
Thank you! I had the same problem, and this worked!
Webpack handles minification and putting the bundle where you want it. What else do you use Gulp for? I use a combo of npm scripts and webpack, never found the need for something like Gulp.
But Webpack also minifies it an put it somewhere on the disk no? What were your other tasks?
`webpack-dev-server` does not put anything on the disk, that's why I separate the uglify task from webpack - because I only want it when I'm building a prod bundle.
I don't want minification in my dev environment - `webpack-dev-server` runs the webpack config which only contains tasks that are shared between prod and dev. The rest is done by gulp. The dev server also doesn't write files to disk. I know webpack can do minification and output the files, but I don't see a reason to have a more complicated webpack config with cases for dev/prod, when I already use gulp for a lot of other tasks.
hmm this seems more like a plug for Mithril rather than an unbiased comparison. So what's the catch with Mithril? The writer didn't mention any which kind of makes me suspecious 
[browserify-hmr](https://npmjs.com/package/browserify-hmr) can hot swap module definitions. To use: watchify main.js -p browserify-hmr -o public/bundle.js [handbook writeup on browserify-hmr](https://github.com/substack/browserify-handbook#browserify-hmr)
I recommend learning server-side Javascript (Node) which will give you a powerful skill and also force you to work with plain ol Javascript. I don't think migrating from jQuery to vanilla front-end Javascript is going to have much of an impact on your skills. I mean, sure, do it at some point as it interests you, but at the end of the day vanilla Javascript is really just more annoying, at best. http://youmightnotneedjquery.com/ I think a better way to level-up your front-end JS is to jump into a framework like React where you don't need jQuery aside from maybe its $.ajax convenience. It'll force you to learn new ideas and ways of doing things.
Ah okey, I have been messing around a bit in Angularjs, making two apps just for fun. And I have also been thinking about trying to use Node, but my host does not support it so it hasn't felt worth testing it when I can't host it live. And thanks I will defenetly look up React also.
Yeah, I have recently started to wrap my code in functions to make it more readable and easy to reuse. but that's just per js-file.
I'm sad that [mercury](https://github.com/Raynos/mercury) never appears in these comparisons. Despite the lack of documentation, I'd say it's an excellent stab at a super-minimal unidirectional frontend library. EDIT: oh, it's mentioned in passing at the bottom of the article. My bad!
I agree with you to some degree, I guess it depends what kind of work you will be using JS for. I'm not proficient with things like Node or Angular... or at least I don't use them much, however the other dev's I work with use them a lot more and swear by them. That may well be me coming from a different direction than they are, but for many things a lot of these templating engines are overkill. I guess it really depends on what the JS is to be used for.
Ah thanks man I will definitely check those out!
I actually just updated the template I provided as I realised I had left in the code that I used to make that template. Duh
That I can understand :)
&gt; `unsafePerformIO` hacks around the place to mutate things where you really shouldn't be Actually, it's usually used to perform IO when you know it's perfectly morally correct, but would otherwise be disallowed by the compiler. You make it sound like people are secretly updating values on the sly, where AFAIK it's more often used to do things like more fine-grained memory/resource management.
True - I could have worded that better.
I'm using gulp for the same reasons but after reading more about webpack it seems that gulp is rather... Useless. Webpack can clean directories, minify files and bundle images. Gulp just gets in the way. 
I am learning AngularJS (slowly and painfully) and Node, and the concepts behind architecting modular code. I understand both are based around the ideas of modules and promises, so my idea is to grasp it at a lower level. 
I agree. In linguistics, you have 'stop words', so called unimportant or filler words, and you can find a good list already in JSON format here: https://github.com/6/stopwords/blob/master/dist/en.json But cat and hat are clearly not unimportant words and it will not be easy to filter them; your criteria for importance is unclear.
I work as a developer on a very big e-com site and trust me, there are no silver bullets, only spaghetti food. Creating an e-com site is really complicated stuff, both front- and back-end. If you don't have a team working on the site full-time, I would recommend finding a solution tailored for e-com First hit on my google search http://ecommerce-platforms.com/compare/top-10-shopify-alternatives
This isn't even close to being a comparison though. Worst of all, even though it talks almost entirely about Mithril, it says barely anything concrete. It's really a plug, Nothing more.
I'm someone that learns by doing, and I pretty much taught myself JS from a young age. Been doing it for about 16 years now, and I've watched it change. Whenever I want to get myself caught up on the new 'coolness', this is the process I usually follow. 1) Pick a framework or library that is now the rage. Way back when it was jQuery, then it was Angular, now... maybe Angular 2? 2) Tell yourself you want to copy functionality of said framework. You want to build your own little library. You are going to use the existing framework as a guide, but write all your own code. 3) Once you have that code working, run JSLint against it, as it will tell you where you really cheated. Why do I do it that way? Well, for one, the people that write a lot of these frameworks are really smart, but learning too. You can get neat ideas on how to handle different situations in code by watching what they do. Next step, tackle a problem you see that others might have not yet. Doing your own project is really the best way to get good.
It sounds like you just want more functionality than Bootstrap provides. Decide what more you need before asking this.
&gt; One of my trick questions, during an interview, is to ask someone to write something in javascript. If they use **an existing browser and don't build the entire internet from scratch** , the interview is over and I walk them out the door with a kick in the pants. That said, jQuery is certainly something that should be used judiciously.
&gt; I feel that I want to be able to make my own libraries Just from this statement my two cents are that learning unit testing and module patterns would benefit you the most.
 // make classes behave like context bound ObjectHelper.bindAllMethods(this, this); I'm not sure how to think here.
You sound like someone who isn't a programmer.
This is actually the right way to write JavaScript... If you are using something that looks like classes, with constructors and object variables, you're doing it wrong.
Ouh I like this idea very much! I shall start writing my JS thisway in bigger projects!
Conversely I've worked with a few "I can do it better" programmers in my time who insisted on doing everything themselves, even when jQuery was already included in the site for other aspects of it. So instead of a cohesive code base we ended up with areas of the site that used lines and lines of CSS, Javascript and event listeners to pull off what would otherwise have been a couple of calls to $. Part of being a good programmer is using the right tools for the job. It's perfectly fair to take some of those tools out of the equation and ask them to solve the problem without, but if you leave all the tools on the table don't be surprised when your screw has them reaching for the power drill instead of the screwdriver. That's them identifying the most efficient solution for you.
This visualizes the space that files use through a source map, e.g. the space that each source file occupies in a minified JS file. It doesn't visualize the sizes of files on disk.
Good post op. Minor typo: "it'll know more about your stack th~~e~~an even you do, and it'll know better than you how to best optimize"
If you want to learn vanilla JS, make a nested menu system that runs on JS and loads menu items from a JSON file on your web root directory. Try to do this without jQuery and don't rely too heavily on pure css even though there are solutions out there like suckerfish menus and bootstrap dropdowns. This should be sufficiently complex to learn a whole lot. You will have to * load the menu items asynchronously * manipulate the data * Create all the DOM nodes * populate each menu item and sub item * handle events like hover or click * handle closing menus when you click outside an opened menu (actually kind of tricky) * show/hide elements, etc.
You could generate an Angular boilerplate with Yeoman and use Angular Material, or the thousands of pre-made directives available on the internet (AKA Google).
@_ericelliott has 13k followers.
You really think a random statement here about a quiz is any indication of how we write production code?! Sounds like you're a redditor.
Usually a side effect is changing anything outside the scope of your function, class, or module. Writing to a file is also a side effect because it changes the state of something external to your program.
npmjs.com for js unheap.com for ui
You have to return function itself. 
I agree. That conversation with Elliott has run its course, and I don't plan on commenting on newer articles. But I also think that when we see his ideas regurgitated elsewhere, that we should communicate corrections. If people aren't informed about the misinformation in Elliott's ideas, then that misinformation tends to spread. I've noticed a lot of newbies recently who regurgitate Elliott thinking they understand composition, but of course they don't because neither does Elliott. And sometimes even non-newbies get duped, such as Johansson, who's an entertaining character and ends up spreading Elliott's misinformation even further. I think it's important that the corrections become as widely known as the misinformation.
Yes. Lodash is great! Sometimes even faster than native implementations. And when you use something like webpack you can just include the lodash functions you need and you don't load the entire library. 
I think making a video game isn't a bad idea. Make something thats more complex... Whatever you'd enjoy the most. I made [this](https://github.com/oldboyxx/space_invaders) some time ago and it was insanely fun! I suggest you try something similar :-) Why a game and not some kind of app? It's arguably more fun. Before learning system architecture and advanced structural patterns you should have a good grasp on the language itself. Making a small game is a good way to learn js syntax and practice OOP. btw the code in that repository isn't clean at all + it's coffee, but you can do the same in pure js ofcourse! 
tonicdev.com is nifty also, but yea, node.
It's somewhat amusing to me that it's only now that JS build systems are starting to do what GWT gave you out of the box for almost a decade now. That said, I am still hesitant to recommend GWT for new projects because the dev experience has been pretty miserable.
Read the following two books: - The Good Parts by Douglas Crockford (author of JSON, basically a JS guru) - Secrets of the Javascript Ninja by John Resig (author of jQuery) Then, whenever you start creating, just use them as a reference. They're totally worth it, trust me.
And V8 is Chrome's JS engine.
If you return nothing, nothing is returned ;-) function printSum(a, b) { console.log(a + b); } vs function returnSum(a,b) { return a + b; }
Eric seems fairly critical about comments. I tried asking him about what he wrote on his site on twitter and he just kept telling me to go google something. I told him I know Haskell which I guess in his mind meant "this guy is not a complete tool" which made him actually stop talking down to me. YMMV.
I think maybe I'm coming at it with skepticism because my apps have been heavily form based, two way binding type things rather than a page with an input box. For instance, a transaction page with ajax fetched suggestions for bill to, ship to, and product sku, with discounts, tax rates all computed from attributes of the selected product, billing customer, shiping address, as well as underlying general default settings. The computed tax rate, price, discount, and shipping fields are also manually adjustable after the computation auto-populates, and dependent totals/subtotals are updated as changes are made to fields. I like the idea of one way data binding, but maybe I just haven't worked on an app that fits react's strengths?
Maybe this is obvious, but if you don't need a command-line interface then you can always just use a javascript console in your web browser. (also: you don't actually need IDLE to run Python interactively like that - that's also what Python does by default when you run it from the command line)
Spidermonkey
if you're the only dev and you're making a prototype, don't worry about design patterns. Just make the damn thing work. The thing that frameworks give you is a starting point that will have a number of common features built-in.
using your own browser: http://jsconsole.com so there you can also see which features of ES6 your browser supports, respectively Tip: use a modern browser like *chrome* or *edge* and enable experimental javascript via flags (chrome)
What are some examples of the "common features" you are referring to? The only feature of MVCs that I find useful for small projects is data-binding. Stuff like directives, animations, routing, etc are easier using JQuery and/or vanilla JS in my opinion.
You can generate files via JS by using blobs. That is, let's say you had an SPA or something of that nature that lets you do spreadsheets; your user has just created a bunch of data in rows and columns and now wishes to download it in CSV format. Without blobs, you'd have to submit this data to the server, have the server put it into a file and send it back with a "Content-Disposition" header. With blobs, I can simply generate the CSV file in the browser itself without ever sending it to the server and then have the user download that. This saves bandwidth and backend processing time.
The pdf http://www.maritimejournal.com/__data/assets/pdf_file/0020/1033940/Javascript-The-Good-Parts.pdf
Design patterns and frameworks aren't terribly useful for code that you're going to throw away or otherwise abandon. They're useful for providing common solutions to common problems. In particular, frameworks offer the basis for consistent solutions throughout an application's code base (that's the goal, not a guarantee). If you're working on something that's a one-off project, whose code will never be touched by anyone other than you, just do what you already know how to do.
Hot reload is even faster/better with JSPM/SystemJS using https://github.com/capaj/jspm-hot-reloader 
i think so
 &gt;The separation of vendors/app code, watch and hot update speed, webpack blows the competition out of the water. No it doesn't. SystemJS reloads faster and is more robust: https://github.com/capaj/jspm-hot-reloader
Idk if I'd consider knockout or react to be part of the hype machine. I'm using what seems to be an older library, but nearly all places I've interviewed with are instead using react. I just want to understand why.
Rhino runs on the JVM, so sometimes it is used to run JS inside java. But it's very slow.
I personally like the idea of all state being stored in Redux. The replaying of state changes is broken when components have their own internal state. Here's an interesting discussion about it [link](https://github.com/rackt/redux/issues/159). It doesn't seem like there is a right way it's more what works best for your app.
For more information see: http://dart-bridge.io/
If you're comfortable with Knockout use it. If you feel it falls short in any aspect, investigate another popular framework.
That's for sharing this everyone! As someone who's trying to ramp up, these resources are really awesome. I also enjoy - Nodeschool.io's Javascripting interactive course! https://github.com/sethvincent/javascripting and of course MDN's documentation - https://developer.mozilla.org/en-US/docs/Web/JavaScript
Ignore virtual DOM, that's a red herring, an implementation detail. It has virtually no bearing on how you write your code or structure logic. The main value React brought was the component system, which pretty much all other frameworks have now shifted towards (Angular 2, Ember, and looks like it's even been adopted by knockout as well). Have you taken a look at [Vue](http://vuejs.org/examples/)? It's a lot like knockout, but with cleaner syntax and you data-bind to plain JS objects
Aside from jQuery, no front end framework has any tangible share of job listings. The odds that you'll have experience with the full stack of any job is getting slimmer and slimmer as things fragment more and more. Far more important to be a good learner and good at reasoning and be willing to learn new things than trying to go after a slightly popular framework which will just be replaced by something else in a few years.
Reading comments here: I think OP wants some real world feedback of advantages and disadvantages, not merely "if you like it, use it".
While I've seldom noticed knockout to have large speed issues on my beefy developer machine, on some very large projects I've worked on in the past, it was possible to notice hangups with knockout rendering on low-performing client machines especially. I've experienced the same on large scale angular 1 apps. So far, I haven't noticed any speed issues with react, but I also haven't quite got to the large scale complexity that I was doing in my previous knockout/angular apps. The big knock a lot of developers gave to knockout, iirc, was having to encapsulate objects in the getter/setter functions (not that big of a deal though). Knockout also doesn't, at least when i was last using it, have an easy way of encapsulating functionality, which is invaluable when you have to use the same components in a half dozen projects. In the end, it comes down to picking a framework that lets you write clean, maintainable code, and that doesn't get in the way too much. Pick what you like.
/r/androiddev 
There's nashorn now which I've heard is much better 
I currently use durandal for single page apps and find it easy to understand. I'm definitely looking into Aurelia on my next mess around project. I'm also fiddling with elm, but I'm not sure its got staying power just yet. 
Its not quite a requirement per se, but applying as a backend dev and seeing 75% of the companies I apply to are using react makes me think I might be missing something. Considering that I have to assume thier CTOs are better devs than I am, maybe they know something I don't!
As a rule of thumb I always apply, not only in redux / react, but also in marionette / backbone. Always get data from the greatest common factor. Data goes down, events goes up.
Not at all, but it largely comes down to just how much script you actually are including on the page. If you are using progressive enhancement then that method works just fine. Use your build process to concat your scripts into a single file and include the final `&lt;script&gt;` element at the end. No problem. If, on the other hand, you realize that you have more complex needs and you want to use a module loader like `requirejs`. Of course, once you build `requirejs` modules, you're basicly back at putting things at the bottom of the page. This is a long video, but I highly recommend it: https://www.youtube.com/watch?v=li4Y0E_x8zE 
You may find the benefits of React are unexpected and profound, different from the changes you might find moving laterally to a framework like ember. Using React has greatly simplified my *understanding* of the UI's I build. I structure things differently now. I have fewer bugs. I enjoy coding more. I feel like I've leveled up.
I asked this question in IRC and one of the guys comments helped me some: it DOES return it. but it returns it to the function where n is 1. and that function doesn't return ANYTHING to n === 2, which returns nothing to n === 3, which returns nothing to n ===4, which returns nothing to your initial call of factorial(5, 1)
You can remove the virtual Dom and do full component re-renders and your code would not change in the slightest; it's an implementation detail.
It's important to remember that react is a view layer. It's not supposed to manage data fetching and stuff. Libraries like redux go well with react to create a more complete framework, but react on its own should only take a state and render it
If you find yourself having more of style related questions, I would wholeheartedly recommend https://github.com/feross/standard
Btw (and I'm not saying you should ever do this), but who says you can't do multiple inheritance (or stamps or whatever) using ES6 classes (with some ES7 decorators)? Not to mention factory functions. https://gist.github.com/Alxandr/db7b2b5cbb3cc03e10dc
Structure
Honestly not that good anymore. It's a bit dated now that we have ES6.
If you want the dummyanswer: https://www.codeschool.com/
I like Baobab, for that matter.
I tried to compile a two-file project using ES6 modules, but I couldn't figure out the right incantation on the command line. What am I doing wrong? $closure-compiler --language_in=ECMASCRIPT6 --js foo.js --js bar.js --js_output_file out.js bar.js:1: WARNING - unreachable code import Foo from "./foo"; foo.js:9: WARNING - unreachable code export default Foo;
Redux, definitely. It's really not that difficult, documentation is good, and it's becoming the de facto standard.
Any reason to (not) use this over Babel?
Hey, Arva dev here. The Arva community is very much open to suggestions, so feedback is always welcome. Because of the specific context-bound callbacks that e.g. Famo.us and Firebase have, we'd either need to explicitly .bind() all methods that are used anywhere in a callback chain, or bind all methods by default. We feel that manually binding a lot of methods pollutes the codebase, and decreases the readability gains that ES6/7 has given us. That's why we chose to bind all methods by default for now. We haven't found a better way yet, if you have something in mind we'd love a PR or a discussion so we can implement it. Anything to get the cross-platform app development to the next level!
I asked around elsewhere and I was directed to [Knockout](http://knockoutjs.com/), which seems to completely fill my requirements. It has built-in directives that can bind to any DOM event (click, mouseout whatever), and that's just what I needed. 
Thank you. I quite agree. What would be a better place to start then?
I think main problem is that you take in `this` 2 times.
For the absolute, non-initiated beginner, I would say start off by running through the Code Academy courses on HTML, CSS, and JS. It is the cheapest, most accessible way to get initiated. It isn't the best way to learn how to program that said - it's a little too procedural. I don't think it builds your ability to break down programming problems. After that, "A Smarter Way to Learn JavaScript" is good for practising, and getting that all important muscle-memory nailed down. "Programming JavaScript Applications" by Eric Elliot is a good book for learning how to start applying JavaScript practically. I'd recommend 'Secrets of the JavaScript Ninja' by John Resig and Bear Bibeault (w/ Josip Maras with the new edition) once you're really starting to get to grips with developing with JS. Second edition is on the way. (Disclaimer, I'm an editor at Manning, who publish this :) ). Definitely take a look at Addy Osmani's book on design patterns. As well as this, a lot of what you do with JavaScript is interacting with the DOM. So absolutely start really trying to get your head around the DOM. Cody Lindley's book on the DOM is a great book for this. But also, whenever you use a JavaScript function that accesses the DOM, read the docs for them. The Mozilla Developer's Network is a great place for this. That's probably your first 6 months - 1 year. 
Still has to transpile down to at least ES5_STRICT though. So all the concise ES6 gets expanded. Arrow functions to regular functions, generators to large state machine switches. 
IMO learn React first, finish a couple of simple projects using just React from scratch. That will give you a feel of how React works (React requires different thinking), then you can learn flux.
Was the first book I read and glad it was. I think it depends on the reader's approach. If you want a good place to start learning(CodeAcademy etc are great but imo don't really teach well - they just provide some exposure to what things look like) JavaScript as well as gain introduction to concepts you will need to research alongside - it's a great resource. EJS and similar should be read like textbooks and supplemented by other learning meanwhile. In that light it's terrific, and when you hit some obstacles, gather what you need from other sources to step over, even if it takes time. Readers who are serious about learning might want to combine it with an online intro to CS course. 
Relentless persistence http://cube-drone.com/comics/c/relentless-persistence
And how is this different from any other transpiler? Google closure has the benefit being an optimizing transpiler.
No, sorry but no. It's 2015. Promises are a language feature now. If you need promises in your library, assume they are available. Specify that in your documentation. Promises are trivial to polyfill using `es6-promise` or `core-js`. If you target node and the browser, use CommonJS. You can use babel to write your code as if it were ES6 but the output should be CommonJS. Browserify and webpack both support CommonJS modules. AMD is dead (or "COBOL dead" -- there may still be people using it but unless you have a good reason to, don't). Your code shouldn't try to detect what environment it is running in unless your code actually needs to do different things in the browser or on the server. Instead extract that code into dependencies and then use the bundler to substitute the browser version at bundling time (browserify does this out of the box). Don't kid yourself by thinking isomorphic code is "universal". Isomorphic is strictly about browser vs node and compatible environments. There are tons of environments that support some subset of JS, some don't even support async code. You can't support all of them. Clearly define your targets and make sure your code works there. If someone comes up with a different use case, have them file an issue or submit a pull request. There's no point in overoptimizing before you even know whether a use case is at all relevant or common. And don't try to make your library some kind of panacea. Make sure it does one thing well, and preferably one thing only. Make sure it also plays well with others. Having many small modules is the Node way. Don't try to re-invent the wheel by solving problems that are out of scope of the actual library you should be writing. EDIT: On Browserify vs Webpack: again, this is likely out of scope. Unless your library does something a ton of people are going to use in their websites (read: web*sites*, not web*apps*), you likely don't need to provide a distribution bundle yourself. Instead make sure your library can be `require`d when installed with npm and people can use whatever bundler they want. EDIT2: &lt;rant&gt;Also, fuck bower. Bower is useless and doesn't solve any problems npm doesn't already solve better. The idea of bower dependencies being flat and npm dependencies being bloated is just a comforting lie.&lt;/rant&gt;
It's not optimizing for size when you are using ES6 together with modern browser features. As a browser with modern features (like WebCrypto) is likely to have a pretty good ES6 support. So any transpilation just creates bloat. 
I don't know... This doesn't look like inheritance to me, compared to how I used class inheritance in Java projects or how I used prototypal inheritance in JavaScript. The way I see inheritance, there is a parent/child relation, so when you inherit from an object, you put the parent object *above*. An object D can inherit from B and C which both inherit from A... So there is a parent of a parent of a parent and it becomes complex when there are 3 levels or more. With composition (or traits or mixins, whatever you call it), you put objects *aside* so there are no levels. If D is composed of B and C which are both composed of A, you could say D is **directly** composed of A and write D = compose(A,B,C) without any side effects. So as I explained before, I don't understand what the *diamond problem* is doing here and why Jeff says there is still a hierarchy, because you can always "flatten" declarations. Maybe I miss the whole point... Anyway, I have the feeling that people just get confused by words that have a different meaning depending on their own experience and education. We should be more pragmatic, show more code and encourage people to put in practice these concepts, instead of arguing over words and abstract concepts.
Most browsers do not have good ES6 support. We're talking about the language syntax and not the new APIs. Its more optimised than an ordinary transpiler... If you are saying that it's less optimised when you dont care about the browsers that wont support it (as they wont support the APIs you use anyway) then you're the minority at the moment and I assume (if the functionality isnt already tucked away in some hidden argument) that what you are after will come at a slightly later date. 
Welcome to the serious business world, where you have control over what browsers people use. 
Careful with that term, "fully functional. " Erlang and Haskell are both on the functional spectrum, but are quite different. I think what you were reaching for is a lang with an immutable focus.
The world we can thank for prolonging the life of IE6
Yes. The most obvious example would be WebCrypto, as the API is directly reliant on ES6 Promises. So therefore if I'm using WebCrypto.... I can use ES6 Promises. 
Do your own work. Don't be lazy, I'm sure you're very capable
If you control what browsers people use, and those browsers support ES6, then you don't need a compiler, you can just serve the ES6 files. What's your point?
Hi /u/thsherif, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `tsherif.wordpress.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [tsherif.wordpress.com](/search?q=%28and+site%3A%27tsherif.wordpress.com%27+author%3A%27thsherif%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|9|100%
&gt; Use them, like you are using classes in Java/PHP/Ruby/Python. I mean, simply use constructor as constructor, super as super(parent call), extends as extends. I am still of the mind that classes exist in JS, because people are forced to write in a language they are not willing to learn. That attitude eventually hurts everybody that has to consume or maintain such code down the line. &gt; Of course it’s up to you how to hide private methods/properties, but easiest way I found yet: Ignore that. Just learn the language and understand closures. Public/private is a natural feature in the language comes from where in a scope chain something is declared. There are no `public` or `private` keywords in this language, because they aren't necessary. I get the impression from this article, and nearly all others that attempt to promote class use in comparison to prototypes, that the author cannot program without inheritance. Once a developer learns to address that problem the need for classes diminishes drastically.
Thank you for your comment. About this: &gt;I am still of the mind that classes exist in JS, because people are forced to write in a language they are not willing to learn. That attitude eventually hurts everybody that has to consume or maintain such code down the line. Before classes, everyone was writing their custom functions, custom extends etc for using classical inheritance in JS. You cannot mind control all these people and program their minds for using prototypes and no class/new/inheritance etc. So better way right now - just tell them, that they can use classes, but they don't need to mix them with something about prototypes. About consume and mantain - it's easier to mantain code with classical inheritance than code with some patterns and "everyone think about your own way of multiple inheritance, composition etc". If newcomer is going to use JS - better for him to use classes, which will be part of a language, than dozens of patterns for prototypal programming with mixins/multiple inheritance etc. After all that he can learn about prototypes. In my experience, if you're not from other language with prototypes - and somebody is forcing you into that - you'r gonna have a bad time with your code full of uncertainties. Also, of course I can program without classical inheritance. Title says "for newcomers to brand new world" :\
Browsers don't support ES6 Modules, so need to preprocess with something. Plus optimization (particularly dead code elimination) would be nice to have. Also ES6_TYPED output is still marked experimental, which was my original point. --language_out VAL : Sets what language spec the output should conform to. If omitted, defaults to the value of language_in. Options: ECMASCRIPT3, ECMASCRIPT5, ECMASCRIPT5_STRICT, ECMASCRIPT6_TYPED (experimental) 
React takes a functional-like approach. It always renders the whole tree. Same input should be rendered to the same output. To handle performance issue when the "whole" tree is rendered, it introduces virtual DOM to tackle that. So I would say virtual DOM "indirectly" affects how component is like in react.
The result is an array. &gt; var a = 'foo bar baz'.split(' ') undefined &gt; a ["foo", "bar", "baz"] &gt; a.join('-') "foo-bar-baz" &gt; a.reverse().join(' ') "baz bar foo"
Split returns you an array. To do what you need, you should do something like: var res = str.split(" ").join("%") // or any other delimiter
Use Twitter Fabric's velocity-react package: https://github.com/twitter-fabric/velocity-react Yes, it uses JS on the DOM to animate and that seems like a bad idea because it sort of goes against the ideas behind React, BUT Velocity is pretty much the best JS animation library out there when it comes to performance &amp; simplicity/ease of use. Alternatively, you might want to check out the approach Netflix went with: https://www.youtube.com/watch?v=g01dGsKbXOk 
At what point are you stuck currently? Show us what you have thus far. 
Classes are available in ES6 because the alternatives suck to work with and are quite verbose. Also no one can really agree on the "right" way to write JavaScript, so here's another way that at least has a lot of research and history behind it. &gt; ... in comparison to prototypes, that the author cannot program without inheritance Prototypes are like extreme inheritance. I'd argue that prototypes lead to less clear hierarchies and unintentional abuse, especially when some developers get "creative."
`&lt;button id='doMathButt'&gt;&lt;/button&gt;` for a button `document.getElementById("doMathButt").addEventListener("click", function(){});` for setting up the click event handler in the js `var userNums = prompt();` to get the user input `Math.min();` and `Math.max();` for finding the smallest and largest `alert();` to print out/alert to the user. Let me know how you do! 
So, Reflux makes a trade-off: it trades many of the great properties of Flux for brevity. This makes sense for small applications and prototypes. But if you're writing a real app and you're using Flux, you'll probably want all of its great properties: * The guarantee that actions will be processed sequentially. Predictable flow of control. * Ease of debugging: just put `console.log`. Even easier thanks to sequentiality. * Managing dependencies between stores. `waitFor` sucks, but if you need it, then it's easier than using Reflux's facilities. * The ability to capture actions and replay them. * Transforming actions (depends). Redux has its own properties in addition (the store acts as dispatcher), many of which would be much more convoluted without a single-point-of-entry: * Time travel. * Devtools. * Middleware. * Hot reloading. * Record and replay. Also Reflux automatically generates action type constants, which makes it harder to reason about actions, serialize them, and type-check them. If you use explicit action constants (in a single file especially) then you are awarded a quick high-level overview of all behavior in your application. ping /u/sazzer
Again, I disagree. If it saves OP time and work to use the communities' stateful components, then I'd say go ahead. However, I'd suggest that any new components that OP writes for redux be completely stateless.
Thanks for the react-velocity link - the framework I'm trying to port (disclosure: mine) has physics and input tracking [for the same payload as Velocity](http://popmotion.io/guides/feature-comparison) so I can't use an existing solution. However that's a cool place for me to start investigating possible form factors. I'll give it a go and see what I like/don't like. I did watch that Netflix video at the time and it seemed to me they were making things needlessly difficult by sticking to CSS3 transitions when JS is almost as performant and infinitely more flexible. Again though, this video probably contains a bunch of knowledge I'll want to keep in mind, thanks for reminding me. **Edit:** From the Fabric blog post: "we took care not to get flummoxed by bubbling “animationEnd” events" - Ha, that cuts so close to the bone!
I'm starting to lean towards putting everything in redux as well. What sparked this question was that my coworker said I should put the filter object in redux but do the filtering in the component. What is the consensus on filtering data between stores? Or should both the loading of articels and filtering be reducers on the same store? 
If this is for a programming/web dev course of some sort, I'd caution you to find answers here without giving it a shot yourself, Googling around, doing some trial and error, and even banging your head against the wall for a while trying to grasp it. This is a very simple problem, and is certainly a building block for learning the most basic concepts of programming, web development, etc. If you just accept an answer and turn in your homework without understanding how it actually works, you will have a very hard time with the next assignment, and with learning the concepts of programming and web dev in general. 
&gt;I agree that should be the goal, but I don't think you should attempt it in a real app until the rest of the community gets there. If we all think that, the community will never get there.
I was under the impression that redux has a single, immutable application state, within which the entire state of the application and it's components are stored. The whole point in this is that the entire application is very simple to reason about, debug and test because you always know exactly what it will look at for any given state. The views and reducers are pure. Adding state to components ruins this.
Hence why I said "in a real app". 
Generally true, but for simple UI components, it's a bit obtuse to keep all of your state in the store with current tooling. Imagine you have a `Button` component that changes color when hovered (and this state is managed by Redux). There's really not that much benefit to keeping this in the store, and to make things worse, you've now made things less performant, less reusable, more error-prone, and more boilerplate-y. You have to somehow keep track of every button in the app manually and ensure things get cleaned up properly. These problems can be fixed, but I don't think we're there yet. Feel free to experiment or to try it in small parts of your app, but doing this for a large app with actual stakeholders is, at the moment, an idea without much upside. (To clarify: *most* state should be in Redux. I'm not advocating using `setState` except for simple, reusable UI components at the edges of the application, HoCs, or when performance is critical.)
This was extremely painful to read. It's not even classical inheritance, and yet the author claims it is multiple times. It read as "Don't bother learning how the language works. Just do this instead." I couldn't even finish it. Awful article, IMO.
this is the order in which you do things? I had my max and min functions as I just read about those online. I am supposed to have three numbers I don't know. Does this mean I should have three variables in my program?
I've had a lot of luck with react-velocity. It works surprisingly well. I think it actually fits React quite nicely - take something imperative and make it declarative.
The latter. The idea is that you have one source of state, your redux store, and one top level update/reduce function.
&gt; Use them, like you are using classes in Java Please no. Downvote all you want, but I've had to deal with Java. Believe me, you don't want to go there. If you have any good arguments about why Java is awesome, feel free to comment and share your wisdom!
This doesn't work? str.replace(" ", "%");
Please share your experience about Java and classes in particular. Why classes there are not ok?
&gt; Before classes, everyone was writing their custom functions, custom extends etc for using classical inheritance in JS. I think that primarily applies to developers attempting to simulate classes. The various hand baked solutions are certainly less uniform than a standard approach. I really think this is the primary technical problem classes fix in the language, which is both a valid problem and a worthy solution. The biggest personal objection I have to classes in this language is that they don't fit well in the language, as it's designed. The various hand-baked class solutions indicated the particular code was written by persons who possibly lacked JavaScript experience but certainly didn't lack programming experience. Such problems were generally easy to identify and correct, which means such code would eventually be phased out of any projects achieving high enough consumption and receiving contributions from multiple contributors. This is the economic evolution of a project to gradually reduce its tech debt. Consequently, the new standard class solves various immediate style and integration problems while suppressing the underlying architectural discussions that contrasted with the older hand baked solutions. The big problem there is that concerned code will not grow out of problems that arise from this style of code writing. This is not to say that classes are always good or always bad. They are an architectural approach to how a given sample of code interconnects its various pieces. Technically, inheritance is optional in this language. Large elegant applications can achieve separation of concerns and segmented functionality without using inheritance. In the past this reality always became an inescapable truth as JS applications grew beyond certain sizes, which really forced developers to carefully weigh their options and consider their approaches. My primary fear, regarding classes, moving forward is that developers newer to the language won't take that step to address whether or not classes and/or inheritance are the best path to scale an application beyond a certain size. Instead of considering various options to solve a given scalability problem they will instead attempt to redefine the problem in such a way that pieces of the problem are solved extremely elegantly without addressing other aspects of their applications that may atrophy. That means tech debt is retained in their applications without being transferred out of the project, and is extremely hard to identify. I suppose my gripe with classes is not their use, but any long term growth consequences resultant from their use. I wouldn't even know how to measure such. If somebody could find a way to solve for tech debt identification in architectural planning in such a way that is crystal clear to junior developers writing the code then the class holy-war is solved either way.
Your "friend" is saying that you should build some functions that would enable the consumer to utilize them as such: http://jsfiddle.net/L57pj72f/
Yep. 100% agree.
Does this "friend" have a role at a university?
I sometimes feel that the development of the JS spec has maybe a little *too much* impetus right now, and every in-depth discussion at the early stages of spec additions is invaluable to the future of the language. As such, (even though I don't yet have enough insight into ES7 features to contribute) I applaud this article, it brings up some interesting points, and I'm looking forward to see the discussion it spawns.
Pretty sure its on javascript now too
Nope still Java: https://developers.google.com/closure/compiler/docs/gettingstarted_app That's kind of annoying to deal with, although this NPM module looks like it helps a little: https://www.npmjs.com/package/closurecompiler
Here's my small but powerful vanillajs view library that's easy to understand. Just learn from the source or use as is: https://frzr.js.org ;)
This guy knows what's up.
I didn't do any of the UI parts, but here is a functional solution. You could now wire up buttons to do the rest of the solution. http://codepen.io/anon/pen/PPEoxV?editors=001 edit: I realize now that the point of the exercise may be to get you using for loops... so my solution isn't worth a whole lot.
I'm unsure about that because of the idea that it can only be set to fail upon one failing or pick the first one to finish, even when one earlier in the fed array might be better
I feel the same way: using generators to write supposedly "cleaner" async code (by leveraging yield but then having to wrap the whole construct in a container that "knows" how to keep calling the function) never felt clear or right to me. Some of the inner code is a bit cleaner than Promises, but at the expense of being much more conceptually confusing (and there is no "right" implementation). I never found Promises to be all that confusing in the first place, particularly if you think of/write them as [compositions](https://medium.com/@dtipson/functional-programming-is-for-dummies-fa130a629250). Async/await achieves a readable, descriptive flow. It's sugar for generators under the hood, but it's much _better_ sugar than something that's openly a generator.
 async function renderChapters(urls) { urls.map(getJSON).forEach(j =&gt; addToPage((await j).html)); } Err ... can't you do this? Promise.all(urls.map(getJSON)) .then(o =&gt; addToPage(o.html));
Some promise libraries have a .when method which will return the successful and unsuccessful promises. You can also use this workaround http://stackoverflow.com/questions/30362733/handling-errors-in-promise-all
Not if you want to guarantee the same order. Your example does all requests in parallel.
I hadn't heard of this but it looks awesome, thank you.
It depends on which framework you choose, how much you build on top of it, and how much you need to do. If you're building a simple web page, you probably don't need more than jQuery (which is a framework itself). The framework I start projects with is a heavily modified and extended version of backbone. It has the concept of multiple "pages" and a menu system. Pretty much all SPAs have "pages" and menus. It also adds some things into the render cycle like transition in and out events, and has built-in basic routing.
How tied are you to the recursive fibonacci_cal? Because there's an iterative version of fibonacci that produces fibonacci numbers in order. If you used that version of the algorithm, your code is basically: var res, previous_res; for (var count = 0; count &lt; num; count++) { //calculate new res from res and previous_res arr.push(res); } return arr;
Thanks for relinking. I've been learning JavaScript for the past couple of months and have been scouring the Internet for articles and tutorials. I'll have to read the entire article when I have some time. It looks pretty comprehensive. :)
You can use Typescript, if your type definitions are well it should all make sense and work hell. Anyway it's about time type annotations are implemented in JS, hopefully on ES7.
Native solution would be nicer. Not to mention that it would increase running speed, too.
Its the same order... but it should be: ``` let data = Promise.all(urls.map(getJSON)); data.forEach(o =&gt; addToPage(o.html)); ```
It needs to be recursive, as it stated in [the original exercise](http://roman01la.github.io/recursion-exercises/). Iterative would indeed be so much easier!
Oh, that's easy too: function fibonacci(num) { // base case. returns [] if num is 0, [0] for 1, and [0,1] for 2 // grab fibonacci(num-1) // add the last two elements of that array, and push it onto the end of the array // return that array }
What did you do here? 
I certainly see where you're coming from, but an important aspect of the nature of the upcoming changes is that they are fully backwards-compatible, meaning that noone is forcing your hand in what sort of Javascript you write, only extending your options. If you wish, you will be able to write the same code 5 years from now as you would today, simply disregarding the new "pycoffrubyscript" aspects of the language.
[Check the console](http://jsbin.com/xawurucibi/1/edit) By the way forget the dollar sign, my reddit client for android doesn't show some characters when I format text as code.
This is not the unique cases where static typing is necessary, in JS code once you start having a rather extended project you will struggle with what type of data comes from this or that function, there's good integration with editors and all that. It's a great asset and can make you much more productive, spot errors easily. I don't think they would do it obligatory, a la TypeScript definitely, there may be people not liking the changes.
And a developer using react really needs to know none of that :)
partseInt(yourStringHere); https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt
or: var x = Number(extracted); This is type casting thought.
Okay guys, thanks to all of your help I figured it out! var filename = this.src; var extracted = filename.replace ( /[^\d.]/g, '' ); var number = parseInt(extracted); And it works! :D :D :D upvotes for each of you
&gt; The best thing to do is to start putting that knowledge into context as soon as possible and as often as possible. Basically, start doing stuff with your programming skills. This is the key. Thanks for your input.
&gt; would be pretty much universal language Surely you are joking?
You can write your own promise library. Not to mention that you could also write a combinator let only = (predicate, handler) =&gt; error =&gt; { if (predicate(error)) return handler(error); else throw error; } promise .catch(only(e =&gt; e.code == 404, e =&gt; { ... handle it ... }) .catch(only(e =&gt; e.code == 403, e =&gt; { .. handle it ... }); The point of both options is that DSLs based on higher order functions are a lot more flexible and powerful than the rigid set of built-in keywords that often wont even play nicely together. Can you write this? async function* myGenerator() { } Without language support, of course not. The problem isn't limited to JS either, Python 3.5's async/await doesn't combine with python's generators either. You can't even fix it to make it work because its a language feature, not a library. Can you do it on top of generators without a library, with those "unclean wrappers"? Why, yes you can: https://github.com/spion/async-generators
Yeah, I agree that having a nice gradual type system built in would be awesome.
That looks like a nice library and I've heard good things about it, but haven't tried it myself. It seems to use the [Mode View ViewModel](https://en.wikipedia.org/wiki/Model_View_ViewModel) pattern which I was not aware of. This just shows that I'm biased towards learning the tools I'm already using! Thanks for showing me something new, I think I'll try Knockout.
Optional in the sense that you have the `any` type for example and can mix between having static typing or not having, thus being optional.
I probably shouldn't write the first comment as it may look awkward and/or suspicious but I was lurking on reddit from my bed and... well I made playground and I am really happy (surprised) to see it on top of someone's list. I just want you to know that I'm a redditor in case you have some questions regarding the library. 
I really want to use Typescript, but it's hard selling a company on a new tech, though the code completion in IDEs sure is nice. An optional type system (ala google's proposed ["SoundScript"](https://developers.google.com/v8/experiments?hl=en)) would be great
I don't understand why we need "async", it should be enough with "await". We should be able to run any function in an asynchronous way without modifying its firm, like in Java for example. 
&gt;meaning that noone is forcing your hand in what sort of Javascript you write Unfortunately, I don't always have control over the javascript I write. I work in a team, and the team has a say in what kind of Javascript I write. They want to move to Babel, pushing things forward for the sake of 'new, shiny'. But, Babel won't help us ship code any faster, and actually causes problems because it's more difficult to debug a transpiled language. I can see ES6 could cause some developer burnout, because now there are hundreds more rules to remember about all the new features of javascript, and many more ways to write the same thing. I also have to read a lot of code, and ES6 isn't going to help in that regard, it's only going to make understanding javascript more difficult, because it isn't really javascript now, it's a mashup. Where does it stop? Apparently it never will now that the floodgates are open and ES7 is coming. I'm not happy that javascript is having more features piled on top so a few people can code python and call it "javascript". Javascript *was* brilliant because it *was* simple, easy, and the 'bad parts' were actually very few. That is not the case going forward. I don't consider ES6 to be javascript any longer. Javascript has become a mashup. 
 var fibonacci = function(n){ if(n &lt;= 1) { return [0]; } if(n == 2) { return [0,1]; } else{ var arr = fibonacci(n-1); var l = arr.length; arr.push(arr[l-1] + arr[l-2]); return arr; } }; This was my answer. In no way ideal, but a lot more streamlined.
jspm FTW!
The first style is known as "K&amp;R" style and appeared in the book "The C Programming Language" by Brian Kernighan and Dennis Ritchie, the designers of C and Unix. The second style is "BSD" or "Allman" style and appeared in many of utilities and code that was added to the BSD variant of Unix, much done by Eric Allman. I personally prefer the BSD style. There are pros and cons, like anything. 
&gt;new account I remember the last thread with the exact same problem and it WAS homework. And it wasn't a "friend" then. Nice try: https://www.reddit.com/r/javascript/comments/3oj7eu/new_to_javascript_and_received_this_assignment/
GSAP is great too. One of my favorite website designs/animation uses it: www.mintdesigncompany.com But don't underestimate velocity. It's also very, very good... and free and open source.
You probably know this, but your example can be reduced further. Looks a little cleaner. Promise.reduce(tasks, (values, task) =&gt; task(arg1, arg2 ...) .then(value =&gt; { values.push(value); return values; }), []);
&gt; What's the difference between C extending B (which implicitly comes with A), versus C extending BB and A individually (that is, flattened)? &gt; &gt; The answer, of course, is that there is no difference. Not in that simple example, but when you start building a more complex application there is a clear difference: *(I'm going to extend your Python due to the terse syntax, but I've never written a lick of Python before!)* class A: def getA(self): return "a" class B: def getB(self): return "b" class C(A, B): # comes with both A &amp; B's behaviour def getC(self): return "c" # Now we only want B's behaviour, we can do that two ways: class D(B): # comes with B's behaviours only instead of everything that C may contain. def getD(self): return "d" class DD(C): # comes with B's behaviours, but also everything C contains. def getD(self): return "d" Especially when I come back to the code at a later date and want to add a new `class E` that only `class D` uses the behaviour of: class A: def getA(self): return "a" class B: def getB(self): return "b" # Some new functionality is added class E: def getE(self): return "e" class C(A, B, E): # comes with behaviour from A/B/E def getC(self): return "c" class D(B): # still only B's behaviours def getD(self): return "d" class DD(C): # Now has been given E's behaviours too def getD(self): return "d" 6 months down the track, another dev comes into the codebase and says "Oh, hey, `DD` has a `getE()` function. Awesome, I'll use that! Now you're locked into `C`'s implementation of `getE()`. If `C` changes, `DD` will to. Not only that, but the fact that `getE()` was dragged in with `C` is the banana-gorilla problem (Asked for a banana, but got the gorilla holding the banana and the whole forest). I think the majority of the discussion is around more complex applications, rather than snippet-sized examples. Especially with respect to working on large teams over long periods of time.
Awesome, thanks for that link. Explains a lot and why the Allman style can be problematic.
Excellent, there we go. Thank you very much.
It would also reduce (not eliminate) the need for web assembly. Why add new language if JS gets good enough?
&gt;writing an article without doing any homework is suspect. But it's great for page rank. Note who submitted the article. Look familiar?
 function linearSearch(array, elementToFind) { for (var i = 0; i &lt; array.length; i++) { var element = array[i]; if (element === elementToFind) { return i; } } return -1; } or array.indexOf(elementToFind); /r/algorithms 
&gt; Another new account https://www.reddit.com/r/javascript/comments/3pdkix/friend_sent_me_this_problem_and_i_am_lost_beginner/ https://www.reddit.com/r/javascript/comments/3oj7eu/new_to_javascript_and_received_this_assignment/ Nice try rewording the question. No one is doing your homework
Really? Interesting. I would not have guessed that (in regards to the private slots, I mean). Every time I found myself thinking that a private variable would be useful, I typically just ended up adding an underscore to it, and trusting that if end-users started poking at my underscored variables and broke something, they'd know it was their own fault.
If it's being pushed as a group policy, meta tags and other tricks won't work. You'll need to set a header: x-ua-compatible: ie=edge That's the only thing I've found that can override the group policy for intranet sites to use compatibility mode.
Technically, both are K&amp;R... but the first is more widely accepted as K&amp;R where the second is BSD [KNF](https://en.m.wikipedia.org/wiki/Kernel_Normal_Form), a variation of K&amp;R. 
&gt; But this is not why async functions are a step in the wrong direction. Then why did you include that part in the article? Nothing above this line is unique to async/await, and it doesn't really add any value. The part below is the interesting part of the article, and the entire blog post would have been more powerful if you only had that part. I've found myself in your situation a fee times, where I wanted to make a custom async engine, so I definitely see your point. But that has happened only very rarely, and the majority of the time I end up having to wrap my generators with `co.wrap()`. Async/await I'd for those majority of times, and so covers 99% of the cases. I can live with using adync/await most of the time, and use generators when I want more control. Or maybe add a decorator to the async function, indicating which engine it should use. In that case it's not a step in the wrong direction, it's just not a large enough step in the right direction yet. 
&gt; Your example does all requests in parallel. It's throttled by the browser. Initiating 100 requests simultaneously is perfectly fine. There will be only 6-8 simultaneous connections to the same host.
 &gt; parseInt('12.jpg') 12 parseInt simply stops at the first non-digit character.
&gt; Ignore that. Just learn the language and understand closures. Public/private is a natural feature in the language comes from where in a scope chain something is declared. There are no public or private keywords in this language, because they aren't necessary. It's not quite that simple, though. Using closures for private state forces other decisions. For example, you'll have to create new copies of each function for each instance and attach them to the instance itself. Whereas if we didn't use closures, then we could use the prototype chain to contain those instance functions. You end up having to choose between closures or prototypes. &gt; I get the impression from this article, and nearly all others that attempt to promote class use in comparison to prototypes, that the author cannot program without inheritance. The prototype chain is inheritance too, so...
The problem is only minor if you have 3 functions. When you realise that pretty much every single function in your system potentially needs access to the transaction, the problem is suddenly not so minor, and the solution is very practical indeed. What libraries are using doesn't really matter - this only pertains to application code. The engine I wrote starts off with promise support, however unlike async / await it doesn't stop there. It shows how to build on top of that to add support for additional useful constructs. 
At no point in your career will you get to be 100% comfortable with every piece of technology you are using, unless you want to spend 20 years maintaining legacy cobol systems. Whether or not you think it is reasonable is not important. At the end of the day, they are paying you to work on what they tell you to do. So how do you make that bearable? First, try and learn something new and get a little bit better every day. Don't worry about being perfect and don't spend all of your free time trying to cram documentation into your head. Ask questions of the more senior devs, read the codebase and try to piece together how it works. Maybe watch some training videos on the weekend if you have time. Second, realize that if the work doesn't get done and you gave it your best, then it's not your problem. It's your boss's problem. You got hired for a reason, and you're not going to get fired because it took you a few more weeks to pick something up than they though. Especially considering they probably spent a few months trying to find an employee. 
We're here to discuss Javascript, not do your homework for you. Maybe you should try listening in class, doing the required reading and then working out how to do it yourself.
I imagine for backwards compatibility. The example uses the standard Date constructor provided by JS that works this way already.
Maybe you missed the part where I said "causes problems because it's more difficult to debug a transpiled language." Not interested in "Typescript". Doing just fine with Javascript 1.7 We're not going to use Babel. We'll wait until ES6 is fully supported in all major browsers.
Javascript 1.7? Holy shit, that's from 2005. You're not even doing ES5?
Hi kenman. Thanks for the heads-up. I am new here and didn't realize that was considered bad form. I'll mix it up a bit in the future.
It sounds like you don't like JavaScript anymore because there are new things you're not willing to learn.
I'm willing to look from another viewpoint, but you have not stated why its a poor fit. ES6 generators are bi-directional, which makes them coroutines, which makes them a good fit for a whole bunch of things, not just creating iterators. I can think of an alternative explanation why generators aren't being used this way: the existence of async/await killed the previously lively exploration in this space. Which is precisely what I'm trying to undo by writing this article :)
I think you make some interesting points, but not everything is fair, and some can be countered with better designed code: 1. Predicates in catch statements. This is a red herring: the problems you point out are problems with try-catch statements, not with async/await. You'll run into exactly the same problem with synchronous code. Since async functions are based on promises, this actually isn't that much of a problem, since you can still use the promise based error handling in combination with async/await, like this: ``` await dowloadImage(url) .catch(e =&gt; e.code === 404, handle404) .catch(e =&gt; e.code === 401, handle401); ``` Async/await isn't intended to replace all promise semantics. 2. Cannot use higher order functions. This is again not really an argument against async/await, because you'll run into exactly the same problems with vanilla promises. I.e. without async await you'll end up with this: ``` urls.map(getJSON) .forEach(jsonPromise =&gt; jsonPromise.then(j =&gt; addToPage(j).html)); ``` The real problem here is that you use the wrong tool for the job: if you're dealing with async connections then you should use functions that are designed to work with promises. E.g. I could easily write a library that allows to map an array sequentially with an async function, and get something like this: ``` async.mapSequential(urls, getJSON) .forEach(j =&gt; addToPage(j).html); ``` The problems with higher order functions are problems with promises in general, not with async/await specifically. 3. Arrow functions give us more power than ever before I'm not sure what your argument against async/await here is. Do you mean to say here that vanilla promises aren't \*that\* ugly because of arrow functions? 4. Loss of generality and power You're spot on in this part of the article, IMHO your article would be much stronger if you only have this section here. However, for about 98% of the use cases you don't need this additional power, but you do benefit from a more expressive syntax. Async/await isn't designed as a solution to all async code, but just for that where it makes sense. If you want to do something that can't be done with async/await, then use something else. What you say here isn't necessarily a reason not to use async/await, but it is a reason not to use async/await everywhere.
How is that syntax clearer than current syntax? I think we need more choice in the browser, I am not liking the direction nor the velocity of JavaScript (ES*).
This is slightly off topic, but... &gt;It’s gradually becoming clear to wider community that you should be transpiling; I'll be honest. It's not clear to me. And I have a hard time understanding why *everything* I've been seeing in the JavaScript world is written in ES6 lately. I mean, I've looked at ES6 before and played around with it. Classes are nice, but they don't seem to offer anything that the old fashioned prototype way doesn't. Let and const don't make much of a difference to me, since I almost never have to use closures since I started using map, reduce, forEach, etc. I'll admit sometimes I wish I had fat arrow functions, but again, it's mostly just the nicer syntax. So we're adding this extra build step, making our source code different than the debugger code, raising the barrier to entry to newcomers, and making life harder on those of us who work in a place where we *can't* transpile. All this, just for nicer syntax and a couple new features? I thought we tried that with coffeescript and decided it wasn't worth it. So can someone explain to me what the appeal is? There must be something I'm missing.
try now, should be fixed
&gt; So can someone explain to me what the appeal is? There must be something I'm missing. You can import stuff and your editor will know about it. Y'know, just like in any sane language. http://i.imgur.com/BRv0BH2.png Classes and modules are a pretty big deal. Creating your application's structure in a declarative manner makes it accessible to tooling. Of course there are also a bunch of other nice improvements like block scope and being able to close over your loop counters.
Well, this one gives you static typing... I myself miss arrows, while others might miss the class keyword, because they try to write 'classic' style object-oriented code. So yes, mainly for the nicer syntax.
&gt; For example, you'll have to create new copies of each function for each instance and attach them to the instance itself. What's the practical downside of this? If you compare speed and memory usage of closures vs prototypes, the differences in practical terms are negligible.
If you mean cleaner than the imperative syntax, the win here isn't so much in cleanness but more in the fact that its less error-prone and has less boilerplate. In imperative code, if you only wish to only handle certain types of errors in the catch statement, you must not forget to rethrow the error (add else {throw e; }). Basically there is no current syntax.
If you're writing non-trivial Javascript for the web you should at the very least be bundling and minifying as a best practice. At that point another step to transpile is not really a huge deal. (And you should also use sourcemaps for debugging purposes).
2 is use static assets even if your content *does* change. Restructure your page if necessary as dynamic data arrives.
It's still good advice that encourages good design as opposed to scaling techniques that make the app a huge mess. Until everyone does it, it has not been said enough. I would rather read an article about good web app development practice, than one about some new, but inferior, technology.
One way to mitigate halting problem would be to add option that program stops after (say) 10000 loop iterations no matter what. I think that would be a worthy feature.
I don't personally use React, but I know most of the well-known rendering libraries (lodash, mustache, etc.) work just fine server-side if your rendering target is text/html. If the target is live DOM (and if memory serves, react does target shadow DOM), then it's a fools errand, of course, because you can't access the DOM at the server.
You can do that already! There is no loop on LJSON, so you must provide your own. That allows you to set a bound if you wish: LJSON = require("./../LJSON.js"); var lib = { inc : function(a){ return a + 1; }, loop : function(limit,state,update){ limit = Math.min(limit, 1000); // No more than 1000 loops for (var i=0; i&lt;limit; ++i) state = update(state); return state; } }; function add10($, x){ return $("loop", 10, x, function(x){ return $("inc",x); }); }; var add10Str = LJSON.stringify(add10); var add10Val = LJSON.parseWithLib(lib, add10Str); console.log("add10 stringified : "+add10Str); console.log("add10 to 5 : "+add10Val(5)); That outputs: add10 stringified : (v0,v1)=&gt;(v0("loop",10,v1,(v2)=&gt;(v0("inc",v2)))) add10 to 5 : 15 That is the reason I think a type system isn't really necessary.
I did use it, but sadly, it's often wrong, or not helpful.
Neat!
d3 is great for things like that, but it may be a little heavy-handed for your purpose. If it is, I think there are a few libraries that offer a higher level interface for charting that work on top of d3.
I did not know the Joi, but I study on
Disappointing there's no code, but I suppose that's what you get if you buy his book. If you want to see some chaos code, I recently made a [site with a background that can be either the Mandelbrot set or Conway life]( http://chaosscape.com/chaos) written in vanilla JavaScript. Click the triangle at the top right to hide the pesky content.
&gt; you must not forget to rethrow the error Unless that's the behavior you want because you handled it. That's like saying 'functions are a step in the wrong direction because you have to remember to return a value or else it doesn't get returned.' It would be more clear if you completed your example. In your example above, go ahead and fill in the "... handle it" part where you want to eat the exception in one case (aka recover) and respond to it (like log something) and let the exception keep propagating in the other case. Once you've done that, I'll do the same for my async version.
**Changes:** * Added RSS feed at /feed (and respective icon in the menu) - *most requested feature!* * Changed the Blog's RSS feed link to /blog-feed * Added article Popularity display * Added article Social Sharing buttons **Work in Progress:** * List of aggregated feeds (sources) Thanks for the continuous feedback and suggestions.
I don't have McAfee either. This post is the only usefull result that is get when i google this problem. How do we fix this?
Do you know any other programming languages? or are you learning programming too? 
It's something I liked when I started programming. It was kinda nice that "1" would become an integer. But I've spent far too much time debugging issues related to implicit coercion. `parseInt(n, 10)`, for example, rules out an entire class of problems. I get why people like it. I was just trying to point out why I wouldn't say it's "completely unnecessary" to be explicit. `if (!!x)` in isolation does look kinda silly. But I think it makes more sense if it was consistent across the project. Also `!!x` can be an indicator that `x` isn't a boolean already, and in Javascript I'll take any hints I can get when I'm reading someone's code! I don't think we are in a hard disagreement.
Many times people say that typescript is a superset of javascript. But it seems to me that it is actually not a true superset. If you first assign a string to a variable, and later change the variable to be a number, the file won't be valid typescript. This may be actually good design, and give you probably better tooling support, better completion etc. But it doesn't seem valid to then call typescript a superset, right?
For the first one I would write it as: [1, 2, 3].filter(item =&gt; { return item &gt; 2; }.map(item =&gt; { return { x: item, date: new Date() }; }); Second one the same, except using fat arrow: promiseFunc("123") .then(otherPromiseFunc()) .then(data =&gt; { console.log(data) }); Although it would be nice to have the method inference like Java: .then(System.out::println());
True, and I would usually use a variable, but others may not.
It still produces .js output though. Nearly all of its errors are effectively just warnings.
Yay! What is it? He doesn't know. He doesn't even say on the linked github!
Some valid points. The limitations of the packages/accounts systems and the hacks required for some otherwise normal function has been a pain point for sure. The biggest I have is the rebuild has gone from super quick with the livereload to the rebuilding of packages that require 5-10 seconds to see it.
Dear Universe - I'm sorry for creating this, if that matters.
For some of us this is new. Gotta start somewhere.
If you think its not a problem, thats fine. Personally i see it as problematic that I can forget that last `else` line and break a lot of code, and that the default, easiest thing to write is a catch-all block. If I designed the language, I would force every catch statement to have a predicate filter (which would make catch-all explicit and opt-in rather than opt-out). Which can be done with a promise library based on higher order functions.
Can you show code to clarify what you mean? Here's what *I* mean: function ClosureVsPrototype() { // Private per-instance state kept in closure var private = 'foo'; // Only functions defined in the constructor and // attached to the instance can be public and use the private state this.privileged = function () { return private; }; } // Functions on the prototype chain can't access the per-instance private state kept in closure ClosureVsPrototype.prototype.notPriviledged = function () { return private; // nope }; A function can have closured, per-instance private state, or it can be on the prototype chain, but it can't be both.
Please don't do this. If you explain why you want it through, perhaps people can give you alternatives.
Here is an honest question, can you stake any future in any of the JS frameworks out there right now? The only Javascript framework that has seemed to stand the test of time is jQuery, and it isn't really a framework, but a library. Anyone remember when there were literally dozens of frameworks for event/data binding? Where are they now? I understand Meteor has received millions in funding, but how long is the lifespan going to be? 1 year? 3 years? Now we have Meteor, AngularJS, AngularJS 2, Mithril, React, Aurelia, and probably 7 more that I am unaware of and 3 more that got created since I started this comment. I've found that javascript frameworks in general are so much risk to take on with the technical debt you could incur if they disappear overnight or the internet moves en mass to the next great thing. 
commented above. I know its pretty ridiculous to even try to do this and if this was only the case for internet explorer it would be possible to use ActiveX but we're trying not to go the IE route at all and were wondering if this would be possible on any other browsers. I swear I wouldnt be posting here if I wasnt already desperate for answers. 
Thank you! The instruction were in a weird order on the website
Isn't that basically what Flow does?
But instead of having random result, could undefined behavior lead to exception ?
&gt; every decent linter will complain that what you're doing is a bad idea. JSHint and ESHint don't check that kind of thing.
I think that typed JavaScript would be acceptable for most uses. I mean, there isn't that much to gain from using something else. Due to turing-completeness anything can be done in any language, really. JS is just more lightweight than most and with types it would be both fast and safe.
That would be great, but I'm not sure how to implement that. The issue is that LJSON works by applying an argument-collector to functions in order to infer their source. When you have `x+1`, what argument-collector is added to 1... which JS hilariously interprets as "the user wants to concatenate the source code of x (the argument collector) to the string 1". I'm not sure how to work around that :(
Even with some optional typings, you would still miss things like Options, Results, Enums (typescript has integer only enums) and tons of other things that I'm not thinking of right now. Also don't forget personal preferences. Lots of people (me included) prefer other languages than JS
The easiest solution to that is to make `private` a property on `prototype`. I know this is absolutely weird, but it would solve all use cases. The only practical difference then would be that instance get `foo` by calling `this.private` instead of private as a variable. This works because the prototype is just an object, albeit a special hidden object, and it is a property upon an object instance, and properties upon the prototype object are only available where the prototype is available. Example: var a = {}; Object.setPrototypeOf(a, {private: "foo"}); Object.getPrototypeOf(a).private; If you need anything to be private to an instance then just use a var declared in the instance. If you need anything to be a private in most cases, but shared between a few specific instance then just wrap those few specific instances in a function where the closure is declared.
Yea it is, I think babel removes flow annotations by default.
But it's true that it's a bad idea.
Let's side aside the wonderful argument that TDD helps you design better code. The fact remains that you will get to a point where changing anything will break something that you won't catch. Further, as time goes on this will get worse and worse until almost no work can be done whatsoever. At that point, people start talking "rewrite". Usually, the company goes out of business soon after that. Oh yeah, almost forgot. Your life will be miserable during the aforementioned slow train wreck. Tests help you not break things. Plain and simple. 
TDD only exists to limit regression exposure in production. TDD should be essential to any product, but it comes with a unique cost/payoff that has to be accounted for. You can absolutely live without TDD, but doing so means a higher risk of regression issues ending up in production, particularly problems that you have solved in the past that you are no longer aware still exist. If you are of the mindset that you absolutely cannot live without TDD or that living without TDD will destroy your career then I would say you are probably either an inexperienced developer or extremely sheltered. Having this kind of mentality, for example, would prevent you from releasing a product in a start up given limited resources, funding, etc because you are too afraid to experiment without somebody holding your hand. To me saying you cannot live without TDD is really no different than saying you cannot live without JQuery or some framework X because the risks are too great and the world is too dangerous to live in.
Trust your gut. You can test too much and you can test too little. A small set of unit and integration tests can do wonders for a project. The difference between 0% tested product and 10% tested is huge. If this guy thinks that spending a few hours making some basic tests is a waste of time then he is feeling some pressure somewhere telling him to get stuff done NOW. I've seen this many times in my career (QA Architect here) and often the pressure is self imposed. For example, a manager may say it's fine to slow down and add tests, yet say they need features XYZ for the release. The common reaction from devs is to prioritize XYZ over the tests even though the manager said slowing down is okay. The issue here is for sight and communication. If the dev would look ahead and see the massive debt he is creating, he would pick the tests (foresight) but then he also "hears" from the manager than XYZ is required. The proper reaction to to step back and plan the release with testing Tasks and stories and push out a feature for the greater good of the product (communication and foresight). Trust your gut. Be smart. Be reasonable. If you have learned all there is to learn from this job then it's time to move on. 
&gt; Should something like financial transactions ever break after a push to production in an enterprise business application if testing is done right? Stuff can always break and you won't be able to test every possible situation. Testing can only increase confidence, not make guarantees. &gt; testing our code over and over again in development and QA Most sane organizations I've seen consider manually testing and/or tracing code paths to be a *waste* of developer time, and that's the value of automated testing and coverage metrics. &gt; QA environments (which can never really be like the production environment) I'd take this as a bigger red flag than not wanting to write tests. Of course, that no test thing is a red flag, too, I'm just saying mis-matched environments is a *bigger* red flag in my book. &gt; Do you have any advice? Always Be Interviewing. Even if you're in the best job of your life, keep your resume out there so you know what you're worth in the market. 
Having tests and TDD are 2 different things. Automated test cases are particularly effective at the library and services levels. Trust your gut and just do it. Think about it this way, you're testing manually at this point. You're a developer. Why do it when the computer can do it faster. TDDs a little different animal. It's a design technique. It could possibly help, but not with all your existing code. Also, don't worry about testing every little thing. Look for patterns in the current problems that you have and focus on those. Production is always the most important thing. Writing tests for functions that never caused a problem won't get you anywhere when production is down. After production is stable, then you can expand. Your Lead might be an idiot. Or he might have other business factors driving him that doesn't require a stable production. Seriously. Time to market matters in some situations. So don't get too enamoured with the idea of TDD or full test automation. Focusing on the problems and how to catch them earlier. If testing can help with that, you have proof you can present to your Lead. But always trust your gut.
&gt; Example: &gt; var a = {}; &gt; Object.setPrototypeOf(a, {private: "foo"}); &gt; Object.getPrototypeOf(a).private; But now your private isn't actually private. a.private // "foo" So it looks to me like you reinforced my point. If you use the prototype chain, then it's public. If you use closures, then it's private but you give up prototypes. You can't have it both ways.
Go buy "Code Complete" and read it. Then leave the copy anonymously on the lead developer's desk. The author uses data from studies on the subject to back up his claims on the use of various methodologies (including testing). You'll be a much better developer of you learn to use TDD. Whether you choose to keep using it is a personal choice, but you should learn it enough that you understand ask the reasons WHY it's a valuable approach. It's not just "finding bugs". Another thing that wouldn't happen if your team and using it is that "putting out fires" wouldn't take 50 hours either. That statement indicates to me that your code is very tightly coupled with that fixing one area requires multiple developers fixing other areas. Try using your own time tracking tools to asses how much of your time is spent doing the original coding, how much of spent fixing it later. I track the pattern of that time split as things progress. You'll see the latter grow and the former shrink. Use metrics to change minds. And if you can't change the project lead's mind, you may want to share your thoughts with his boss before finally deciding to leave. I know when I'm the boss, hearing that I'm spending more for less is valuable feedback. 
There is no such thing as "no framework". Once an app reaches a certain complexity and size, even if it uses vanilla JS and no 3rd party pieces, you've essentially built a custom framework. New developers on your team now have to learn your custom framework which may have made sense to you and the team when you built it, but he/she is coming in with zero context. And I bet you haven't documented it as well as a widely adopted open source project and if there are problems with it you can't ask SO or anyone outside of your company. I really hate this argument against "frameworks" like they're just inherent technical debt that are going to drag you through the mud. What happened to not re-inventing the wheel? They save you time so you can focus on important things, like delivering value. 
TDD is vanishingly rare. Testing at all isn't very common, though this varies with the field you're in. The newer a company is and the more their product is churning, the less likely they are to have a culture of testing. You'd think that even if the company is making hand-over-fist profit early on that they'd be more likely to spend extra on process because they have the money, but it's just not so. Fast growth naturally leads to a culture that's resilient to process. Even clients will often choose the testless time projection because it's at least twice as fast. If the application you're building for them doesn't touch financial data or compliance requirements, then it does make sense to prefer the fastest MVP and play it from there. Deploy fails in production? Roll back and try again. Finally, tests don't guarantee anything. At worst, the tests don't actually test anything worthwhile and do nothing but tie up process and dev time. If you think it's frustrating working on a project with no tests, try working on one that aimlessly shoots for 100% coverage at all costs. When I was a junior dev, I felt similar to you. I had a lot of ideals and best practices that I thought were really important. But now that I've been battered by reality and things like time constraints and rapidly changing requirements, I don't even remember what those ideals were. Good luck.
Ah labels... long time no see, good ol' Pascal days.
Writing tests is great for documenting your requirements, which is very useful, especially when you return to projects many months after working on them. It also forces you to write everything in more modular ways, which is a good side effect.
IMHO there's little reason to learn JQuery in 2015. It was created to solve a problem that existed in 2006 (cross-browser compatibility), and that problem pretty much no longer exists in 2015. John Resig stated in 2008 (soon after he was hired by Mozilla) that his intent was to get its functionality baked into the browser, and he largely succeeded: the W3C analogues of most common JQuery functionality will reach about 98% of web users today: https://news.ycombinator.com/item?id=10420597
&gt; Here is an honest question, can you stake any future in any of the JS frameworks out there right now? No programmer, of any mainstream language, can base their career on a single framework. In fact, it's arguable that limiting yourself to a single language will also be a career-limiting move.
&gt; https://gist.github.com/ilyaigpetrov/afb50eb4060bc198de97 Awesome! Adding it now. You have some really interesting insights in this comment. Thanks for reading.
yeah your point about not being able to export React components without a namespace was something I ran into. I was able to solve it by creating a `client-npm-deps` meteor package that uses browserify and exports dependencies. So using ES2015 destructuring, or just pulling out each component like ThrdPartyComponentA = require('some-dependency').ComponentA ThrdPartyComponentB = require('some-dependency').ComponentB then exporting them in the package with api.export(['ThrdPartyComponentA, ThrdPartyComponentB'], 'client') So you can use `ThrdPartyComponentA` in your code instead of `SomeDependency.ThrdPartyComponentA` It is a little extra work, but it's not too bad in the long run and you're still using the actual npm package. I really do hope that they can find a solution that allows the same features their current package system enables and integrates with ES2015 modules, but in the meantime this is livable. 
Coming back to this sub after getting sick of being flooded by inexperienced programmers posting with announcements of new ephemeral javascript libraries every day, I'm so glad the community is still coming up with great ideas like this one.
Back in K&amp;R days, when they wrote C on punchcards or teletypes, white space cost money, which is an (maybe not *the*) original reason for "K&amp;R braces."
&gt; It's up to you to decide whether or not you agree with that opinion. If you do, then you should also evaluate how hard things will get, when your opinion starts to split away from the framework's opinion. It's this last part most people don't consider or get wrong, then they end up with a project whose direction runs counter to the framework(s) that make up the foundation of that project and voila, you're being dragged through the mud. I've worked for a number of large corporations--some that have eschewed framework usage and some that have embraced it. I've seen the painful scenario of fighting against a "framework" go both ways in having to fight against a readymade third-party framework and in having to fight against code that was generated internally with some appropriate usage of third-party libraries like jQuery and Lodash/Underscore. From what I've seen, there all but invariably and inevitably comes a point when a team--even a good team--comes to consider jettisoning their well-intentioned and well-formed code in favor of going greenfield. It seems to be not a matter of if but of when, and what decides the when is largely how well the code has been maintained (read: how well entropy has been delayed).
Thank you for simplifying this for me. 
What I meant was, for the course of a project. Example, if you work for an agency, it gets chaotic when front end devs are always chasing that new great thing - not minding the fact half a dozen projects were just completed and will need ongoing support. The tech debt in that case, starts to pile up fast.
Hi /u/webuilddesign, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `webuilddesign.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [webuilddesign.com](/search?q=%28and+site%3A%27webuilddesign.com%27+author%3A%27webuilddesign%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|7|100%
One mistake to another
Given the context of "Married to Meteor", I'm pretty sure the author meant "Married to Mongo" but got his M's mixed up while writing.
Functional languages do this kind of thing quite regularly using monads. 
well, it depends. Abstracting away your dependencies can help a lot if you need to swap one dependency for another. It's no magic bullet, but it can make life easier. But that takes time, and if your deadlines were set by salespeople rather than by the engineers, you might not have much choice
Hi /u/Waterclift, I've removed this post because it doesn't appear to be related to /r/javascript. If you feel this is in error, then please explain why it should be here. Thanks.
Pretty wicked that you can teach it new stuff by writing your own modules. Do you have any others in the works?
Thanks.
Well if you aren't giving the reasons why, how can we reach a deduction that TS is a mistake?
You need to wrap it with parens to make it an expression instead of a statement. (function say(){ console.log(this.name); }).bind(obj2)
Important to note that you should return a string from that function: window.onbeforeunload = function(){ return 'You sure?' }
Thanks, I forgot about that. Adding it now.
The program was made using JavaScript in a different way. It shows one more way to develop desktop applications with JavaScript. It is interesting and helpful to javascript developers looking for new ways to develop desktop applications using web technologies.
I think that what the "no framework" folks are saying is "you *should* be building a custom framework, one that is specific to your needs." I look at it like this: the point of all source code is to capture accumulated knowledge about the problem domain, in a form so precise that a machine can execute it. If your problem domains are the same, then the source code will be the same, and you should abstract the commonalities out into a library. If your problem domains are *almost* the same, you should put hooks into the library so it can call back into application code, and you have a framework. The economics of the tech industry select against companies that are solving problems that are *nearly* the same as other companies. Because software has zero cost of reproduction, these markets quickly become very competitive, and hard to generate profits in. That means that they eventually die, and their developers get laid off. That explains a lot of the observed facts about framework use. The biggest and most successful companies (Google, Facebook, Apple, etc.) almost never use other peoples' frameworks, because the reason they are big is that they are in unique markets, which make their needs different from everyone else. Framework use goes up in good economic times, because competitive pressures are less and a number of businesses can occupy the same market, fed by venture funding. Framework use tends to be greatest among startups, and particularly among funded startups, and as the company grows and differentiates, they usually need to abandon the framework (per ExNihil's comment below). This doesn't necessarily mean that *not* using a framework is the right decision; you could be needlessly duplicating work by building your custom framework. But it does mean that if you're genuinely in a situation where using a framework is the right call, *you've screwed up your product positioning*, and there's a good chance that you will either move off of it or be out of business when the economic tide goes out. Yes, this sucks for developers, who need to learn something new with each place they go to. That's why they pay us the big bucks. Knowledge that everybody else knows counts for nothing in a market economy; only secrets have value.
Well, the "good news" is that using bind at the place where the function is declared/created doesn't make any sense anyways. If that one object you want to use is available at that point, you can just close over it. Bind is for dynamically changing the value of `this` at runtime. E.g. you can use it to tear a method off: &gt; var qs = document.querySelector.bind(document) undefined &gt; qs('div') &lt;div id="header" role="banner"&gt; Or do something like this: &gt; function foo() {console.log(this.bar)} undefined &gt; foo.bind({bar: 'ohai'})() ohai https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind
Ah, I see, the black, non-underlined "link" in the middle of the page. I don't know how I missed it.
I was just recently arguing this point with a guy who insisted we should avoid frameworks because "eventually they will all go belly up and then where will you be, huh??". Sigh. I've experienced your pain countless times. The other, not even once.
Making it blue and underlined would be a lot of work too.
Since I already post too much personally identifying information on reddit : a high end one with plenty of RAM :P His article is spot on about the build times being annoying.
I would be better for the future and if you plan to work and share with other Javascript devs to move to ES6/ES7 with Babel for example. This is Javascript as per the standard, not a slightly different version of it. The day Javascript allows optional types, Typescript will make zero sense at all.
I'm trying to figure out if what you said would be possible for a Wordpress site. And if so, how to do it. It seems rather tricky.
Thanks for the heads up.
This still won't work, because you're not assigning the return value of `bind()`
Check out meteor up (mup), it's a godsend.
Knockout js
Yeah... not sure how I mixed the two up in my first/second denotation, but the first is 1TBS (also known as BSD KNF, which is a variation of K&amp;R) where the second is widely accepted as K&amp;R.
So a point by point rebuttal, since the Author asked for it. **Meteor's package management system.** Meteor is a node app that's already put together for you. Any npm package you want to add can be added to your app in a variety of ways. The first [Google result shows this to help you with that](https://github.com/meteorhacks/npm). **Lack of control** see above. It seems that OP had some problems coding (what platform doesn't present problems?) and thinks that his one issue is the death knell of the entire platform. **Dirty Hacks are Encouraged** Didn't OP just complain about not having any control? You can't have it one way without the other. You want to hack the platform? Do it, that's called control. You want to use the platform as is? Do it, but you still have the option of altering it a la the two points above. **Community Experts in Short Supply** I have built a reputation on stackoverflow answer meteor specific questions for the last year. And you know what? I have to answer them within 5 seconds of posting because if not, someone else already has. Again, it seems like OP hit one snag and flipped the table. **You're married to mongo.** This is true, if you don't like Mongo, don't use meteor and don't use MEAN. **Code reuse will suffer.** This is simply untrue. My apps since switching to Meteor are faster, leaner, cleaner than anything I've ever used before. **Bureaucratic and slow, Solving Their Problems Not Yours** Honestly OP, do you get David Heinemeier Hansson when your rails app is slow? What honestly do you expect when you're paying nothing? **The mobile-ready argument is hype.** This is an opinion that's not well founded. I have 5 apps in the app store and google play currently, 3 built with meteor, 2 built with cordova using a REST api. They all work fine with average stars of over 4. **Builds and tests are slow** Not for me. I'm not sure OP, did you actually consult any documents or community support? **Most interaction with Meteor is in a synchronous style.** Again, OP, did you really read the docs? It sounds to me like you saw a bit of meteor and decided to dive in. That's great! It's what I did. And you know what? I had a lot of questions a long the way. So I asked for help and in time, I got the hang of it, used it and made some really nice and fast applications. It seems you didn't take the time to actually go over what meteor is, and what it's good for and what it isn't. For starters, if you don't like mongo don't use meteor. Simple. If you don't like synchronous code, don't use meteor (though you could still code however you want). Simple. The fact of meteor is that it's changing the way things are done. You can change with it, or do it how you always have. That's up to you. Writing a hit piece because you got frustrated with a new framework is really sad though. You didn't like it? Move on to something you do like, or will you write a hit about the next thing you don't quite understand too?
They point this out but React is not really a framework in the same sense as the other two (thank goodness!)
Yeah, I had a blast going through it. You might also enjoy his JavaScript animation book, if you haven't read it yet: http://www.amazon.com/Foundation-HTML5-Animation-JavaScript-Lamberta/dp/1430236655/
There are caching engines for WordPress which store your site statically and rerender the pages as they change.
Don't be pedantic. It was obvious that they meant 3rd party frameworks. There's a big difference between implementing design patterns and creating reusable code and using the same made by someone else. For starters, you're not stuck with adapting to their design decisions. You're not stuck having to learn their code which will probably be different from yours in ways that make mentally transitioning between the two less than seamless. You're not stuck with lots of code you're not using which you then have to become familiar with because it's being used internally by parts that you are using. You don't have to worry about making changes compatible with future versions because you're the only one making changes.
Yeah but there are so many frameworks out there, odds are you probably haven't used the one at your next job so it's the same thing except, maybe with better docs.
Really, it was the minute that people started using Github profiles as resumes and every jackass decided they needed to fill theirs up.
Thanks. it wasn't my original intention but I wanted a background that would work for Life and Mandelbrot.
Why hate Microsoft? They make a lot of really cool stuff.
No I don't and no, what I said wasn't wrong in any way, nor did you offer anything to back up your statement that it was. Not sure where you work but there are things like coding standards, code reviews, linting tools and so on which keep things common on a project built by multiple developers. And the bottom line is, you, meaning your team/organization has control over these things as opposed to some 3rd party framework where you just take what they give you.
&gt; they use most of their open source tools in production tho, so that's telling you about how they trust in their stuff. Yea, but Facebook's products often have some of the weirdest and most frustrating bugs I've experienced on websites. For those bugs to pop up on top of their own tools makes me not trust those tools.
Well, the day Javascript allows optional types, we will have loads a type definitions files already ready to use thanks to typescript... 
&gt;&gt; What happened to not re-inventing the wheel? &gt; It disappeared the minute programming became "cool" and everyone wanted to be a rock star. Not-invented-here syndrome is largely driven by two things: a corporation's desire to have complete control and/or programmers who put ego ahead of cooperation. There is are a couple of other reasons: * the trade offs made by the prior implementation do not fit the current needs * the quality of the original work is poor * cooperation is not working -- sometimes a split is needed if egos/ideas clash I understand the sentiment but I wanted to point out it isn't quite so simple.
&gt; Classes are a waypoint before better static-type-checking tools are integrated. Might as well just make Java compile to JS.
I understand what you're trying to say, but to say that ES6 doesn't fix any of the bad parts is a pretty bold statement. You aren't the only JavaScript programmer. The introduction of ES6 might not be helpful for you, but it is for others. 
I was pretty shocked when I realised that... I was hunting through my stack trying to figure out what the heck was going on! So cool though... Flow is fantastic now that it's supporting a lot more of the ES6 stuff.
Check out koa. I've been toying around with it and it is very slick. As soon as I have a new green field project to start, I'm seriously considering using it.
Interesting take on it, but it seems like you're saying that JS and PHP are great because you can monkey patch and base all of your code on flimsy assumptions? Personally speaking, I would never, ever want to go back the time we depended upon global variables and various other forms of global state in JS. I was around then, and I never found it particularly fun. (In fact I still have to deal with it on a few particular projects.) But PHP? PHP is shit. JavaScript is the language of the web primarily because it is the only language you *can* use for real projects without significant hurdles. But honestly, JS is perfectly good these days, as long as you avoid the bad stuff and set up some good tooling (Browserify/Webpack/Babel). PHP is the language of the backend web because mediocre programmers refuse to learn anything beyond it, because mediocre managers continue to hire for it, because every mediocre PHP host offers it, and because WordPress. PHP is not a good language in any way other than being easy to use (and abuse), easy to outsource, and easy to find incompetent programmers. (Please don't be offended if you're a PHP programmer. The fact that you're on this subreddit is a good sign in-and-of-itself, and what I've said almost surely doesn't apply to you.)
Thanks for your point. This is the complaint I heard the most, actually. My argument is counter it. I think PHP/JS are good because of their flexibility, bad programmers can easily abuse it and turn it into a piece of shit, as you say. But there are tons of good programmers that get brilliant stuff out of PHP/JS. WordPress is one of those "brilliant" things, IMHO. We do not need to pollute the global namespace in JS: we can still use module patterns. WordPress is very extensive and doesn't use monkey patching. 
I see it completely the other way around. Maybe this is true for people writing their project in notepad++, but this supposed freedom, makes it hard if not impossible to write a smart IDE. The more brains the IDE has, the more productive I am.
The web is a distributed effort. If you go solo, or all your team agree on the same IDE, this could be a point. Otherwise, you can't measure productivity on a language based on the quality of metadata IDEs can capture from it. 
I did laugh at that image, haha. ;) Strict languages that enforce something on programmers are not made for the web. The web is held by glue and workarounds because normally the creator of a library do not support it, then other person takes over, and this goes on and on (a lot of "fix by adding"). Stricter languages would only make it harder/slower. I stopped complaining about languages and started looking the other way around: people should learn how to code, otherwise we would set the "default" at a very low level (full of bureaucracy to make sure you are really doing it right) and tie the hands of good people from doing good stuff. 
Not really, optional static type checking enables one to prototype using good ol' javascript and build upon that a production quality system.
Definitely an interesting take on it, and I applaud you for putting it out there. I agree that power and flexibility is a good thing when put into the right hands. I think ES6 is a good compromise - you have the static structure by default, along with the ability to mess around with it if you really need to. &gt; people should learn how to code I can also agree with this. It's amazing how many people get CS degrees and then either can't code or never look beyond the Java world for a decade.
What? jQuery didn't get $10 million from Microsoft. Where did you hear that? I'd like to see a link.
I think I'll wait until at least version 0.50 or so... Seriously, jS package maintainers can't even commit to real whole number releases, you think they'll commit to a single module system?
Summary: I picked a project that was too ambitious for my first one with a new tool, didn't plan properly, got upset with the work, and now I'm trying to justify the project's failure by convincing myself that it's Meteor's fault and not mine. Harsh? Efficient.
Microsoft has the best dev tools in existence IMO.
Except there would probably some documentation and people looking for points on GitHub. 
You can't blame a language for the bad code of a bad coder. You blame the coder and you blame whatever education, or lack of, that they have had. If it's reasonable to be able to produce good code that does productive things then the language is fine. A language that makes coding more difficult or confusing is a bad language. PHP is neither. Writing code is part science and part art, and some people are shit at both.
I would usually agree, but PHP - particularly combined with MySQL - is a different beast.
This is something that really irks me and thank you for writing this. Yes, the average Android device has low spec'd hardware, but you know the old saying: a poor craftsman that blames his tools. We can't be so naive to think that everyone is using the latest and greatest. In the case of Discourse, 700kb of Javascript is batshit insane for a mobile device (especially on 3G) to handle. Being careful can only get us so far, but lets make sure we are doing everything that we can to ensure that we aren't exacerbating things by stuffing our pages with megabytes of static assets.
But what about scaling the API? The article makes some great points about using a CDN provider like Cloudfare and separating your assets/static content from the API itself. But the question that isn't handled here is: what happens when traffic substantially grows and your API is handling more and more requests per second? You can't scale an API using a CDN. If you're serving JSON from some kind of database, you have caching, but you get to a point where the cache is not enough and you're stuck handling thousands of connections per minute. It would be interesting to know how much traffic they're seeing and whether or not they've run into scaling issues with the API yet.
Correct. Plugins like W3 Total Cache handle moving and serving assets from CDN's as well as caching pages statically, database queries and pretty much anything you'd ever want to cache.
I suppose we'll just disagree on this one. The title is "a step in the wrong direction", but the example you gave shows that async works exactly the same as javascript already works for synchronous exception handling, only it makes it async...I'm failing to see how you spin this as 'the wrong direction'. If you're arguing that javascript shouldn't work that way (like you did in my other comment), then your point has nothing to do with async, and is just commentary on existing javascript syntax. It's not that async is going in the 'wrong' direction, it's that it's going in a direction that is consistent with the existing language, and you don't like the way the language already works. The fact is, even if there was broad agreement that filterless catches should be forbidden, it's not going to happen because it would be a breaking change. If async came along and DIDN'T work the way the language already works for sync code, a lot more people would consider that the 'wrong' direction. WRT your point about it being too easy to forget to re-throw, I just don't see how your alternative improves the situation. Would it not be just as easy to forget to call your 'only' method? The default for Promise.catch (with no arguments) is exactly the same default as the sync version of catch (gotta-catch-them-all). In fact it's somewhat worse because if you don't re-throw in a catch it will turn it into a fulfilled promise and the other catch handlers in the chain will never see it.
How so? Are you referring to using PDO, and cutting-out the shitty old functions... which we all know won't happen this lifetime? If that's the case then again it comes back to education, and lack of.
I'm referring to the poor design decisions, inconsistency, by-default-unsafetyness/insecurity, unreliablity, unpredictability, and undebuggability rampant throughout nearly every corner of the PHP language. All of which is made worse by the poor design decisions, inconsistency, by-default-unsafetyness/insecurity, unreliablity, unpredictability, and undebuggability rampant throughout many parts of MySQL. I can at least give credit to MySQL though; it's been improved a lot. PHP, not so much.
For me the main missing piece is the lack of optional type annotations (as I pointed out a few times). If someone adds that, it would be great. At least typed objects would be nice.
&gt; When a programmer spends a day working around an Internet Explorer 8 bug, the only sense in which this is a reflection of the "problem domain" is "Internet Explorer is a problem." Can you get around the fact that X% of your users use IE8? If not, then Internet Explorer is part of your problem domain. If so, then Internet Explorer is not. There may be a radical difference in how you architect your program if you don't have to support early IE versions. There's also likely a radical difference in how you architect your program if you are latency-constrained and have to support early IE versions vs. if you are not latency constrained (hint: browser-detection is not always a bad idea). The answer may very well be "no". In 2010 I was working on the first major visual redesign of Google Search. I gave my manager an estimate of how long it would take to make it work with IE6, we went to the head of Search Infrastructure, and the decision was "Drop support for IE6." &gt; As far as I can tell, DuckDuckGo is basically identical to Google technologically but one is fantastically profitable and the other isn't. Considering I worked on Google Search and have followed what Gabriel's written about DuckDuckGo's architecture extensively, I'm in a pretty good position to say they are not at all identical technologically. The differences are all in things that you would neither know about nor care about if you don't work for Google, Bing, or DDG. That's my point: details matter. When you adapt a framework, you are choosing to solve the details in ways that the authors of that framework solved them. That *might* be appropriate; it depends whether your needs are similar to their needs. Or it might just corral you into building the same product everybody else does. &gt; Can you explain to me what it is about AirBNB, Uber or Zillow that would force them to make frameworks that match their "unique problem domains"? I'll give you another example from Google because I'm intimately familiar with it. In 2009, when I joined, we had an engineering constraint in Search that the search results page must be no more than 20K gzipped, including all results, HTML, CSS, and JS. That precluded any framework at all, because every single one of them was bigger than that. I ran an experiment to see if we could use JQuery on the SRP (I really wanted to), and it *doubled* search latency, which would've cost Google a couple billion in revenue. By contrast, consider GMail. GMail was probably the first widely-adopted SPA. It has a very different engineering constraint: you open GMail in a tab once per day and then keep it open forever, but you want individual actions to be highly responsive. So it made sense to do everything in Javascript. GMail uses a homegrown framework (now open-sourced as Google Closure) that focuses very heavily on modularity, and on making sure hundreds of developers can work together productively on distinct features. Google Closure is generally not suitable for startups, I rarely see anyone recommend it here, but it is very good for the type of hundred-developer projects that are common at Google. Before I worked at Google, I ran a startup that did casual games in Javascript. I used JQuery for many of the static parts of the site. However, in the games themselves, JQuery was completely forbidden. Why? Because a single call to .css would drop the frame rate of the game from 15 FPS to 2 FPS (remember, this was before V8 came out, when no browser had a JIT for Javascript). I'm sure AirBnB, Uber, and Zillow have similar constraints on their businesses, but I wouldn't know them because I'm not in that business.
If your question is where do you put the style tag to make the button red, it should go in a style attribute within your button tag. &lt;button style="color:red" .../&gt;
There's lots of options, it depends on what's keeping your API down. Sometimes you just need more servers. Other options start with profiling then include: sharding, partitioning, indexes, SSDs, dedicated servers, eagerloading, NoSQL read slaves, refactoring, rewriting a module. There are lots of guides for performance/availability optimizations, you really need to profile for the bottlenecks, know your system and tools, then experiment and resolve the bottlenecks. Logs can help a lot, too.
I would choose Java over PHP in a heart beat. Java is so much more sane. I think JVM and JavaScript both serve similar purposes in different domains. JVM is a very robust server runtime targeted by multiple languages. JavaScript is a very robust cient (and now server too) runtime targeted by different languages. PHP is just a shitty Apache module that runs shitty PHP code.
They only started doing that the minute after every company started requiring a github url to accompany their rockstar ninja coder position applications. I don't like to play that game, but it seems to be the only way to prove your worth and get employed these days.
I agree, but I'd still take consistent, sane boiler plate over whatever PHP is.
&gt; but also knowing reams of PHP specific stuff to get it right Such as what? As someone writing PHP right now I'm at a point where I've become blind to whatever issues people seem to clutch to. Either I'm totally ignorant of the problems, or the problems are minor and easily solved, or they aren't problems at all. Please don't give me reason to give you zero respect by linking to fractal of bad design as that won't wash with me. I'll take PHP's minor absurdities and things people manufacture to complain about in lolphp any day of the week over languages like Python and JavaScript. I think perhaps we are at a point where some people just have to admit that they simply prefer one language over another as it resonates with them and what they know. If that's Python and Clojure for you then great.
&gt;Not-invented-here syndrome is largely driven by two things: a corporation's desire to have complete control and/or programmers who put ego ahead of cooperation. While this may be true in some places, it's not universally so. A huge problem is that not every frame is *capable* of doing what you need it to do. You can shop forever and not find a framework with the exact features your organization needs (and will need in the future). That leaves you with either hacking apart an existing framework for no other purpose than to say you're being a good person by using another framework - or to make your own, and tailor your solution to the problems of your organization. Neither is a great option, but you need to pick one. Having done both, extensively, I feel pretty confident saying that it's better not to fork a framework and fuck it up. You have no idea what bugs or misfeatures or architecture designs that you're carrying along with, and if you need to hack it in the first place, you're *going* to need to hack it again, until it's an unrecognizable mess that nobody would have said was a good solution if they didn't know the history. And also, let's not pretend that "corporations" are the problem here. *Many* hugely influential projects, languages, frameworks, tools and libraries come directly from corporate teams who were able to open-source. Those projects start for the same reasons; nothing fit their needs. &gt;there very much is a degree of risk involved with tightly coupling your project to a 3rd party framework, especially in the corporate world, and it's ultimately up to each individual project and the people behind the project, to assess and mitigate that risk. And that leads to either using a framework or doing a better job in-house, neither of which is inherently bad or good. 
Bad link, redirects to "www.weaver.org", which is owned by RealNames (an e-mail hosting site). I think you meant to type "weaver.js.org" instead.
guess we're both fans of bit101. his coding math channel is also very good
Get through this: https://github.com/rmurphey/js-assessment
I've being using hapi js for some time now. Having a very good time with it. You might wanna check that out aswel.
Long story short, Glagol started out as an alternative runtime for [Wisp](http://github.com/Gozala/wisp), and ended up as something a little bit more generic -- a mini-framework for building a program in a way that allows editing it at runtime, without having to constantly restart the whole thing, or rebuild parts that haven't changed. Its intended purpose is to serve as a stepping stone towards live coding of multimedia experiences, such as websites, or musical performances; but it can also be useful for iterative development of things like shell scripts or small daemons. Since Glagol's origins are in my attempts to make a comfortable functional programming environment on top of a V8 runtime, it was until recently written in Wisp. Over the last couple of days I took it upon myself to rewrite everything in vanilla JS, in order to make it more useful for people who are not interested in this niche dialect. In fact, right now JS is the only language it supports; Wisp worked earlier today, but the code in `runtimes/wisp.js` needs to be brought up to date with the latest changes before it can work again. (Send me pull requests with adapters to _your_ favourite JS preprocessor!) A cool feature is being able to access the values of neighboring modules via identifiers that look like standard pathnames: `./foo`, `../foo/bar`, etc. (Which, admittedly, is a hack that Wisp's syntax happened to easily allow, since `.` is translated to `_` and `/` is a namespace thing that translates to attribute access). In plain JS, you can do `_.foo`, `__.foo.bar`, which doesn't look like a path anymore, but works the same. This is inspired by Plan9's "Unix-but-more-so" approach of providing the same file-shaped interface to everything, and foreshadows a few other experimental features that I have in mind for the future.
You're right that `only` doesn't solve the issue, I'm just showing how function based DSLs are really easy to extend compared to rigid language keywords The right direction of development for ES7 would be to at least add the ability to do filtered catch, before adding async/await. Then I'd be able to write a lint rule that forbids unfiltered catch. I suppose I could also write a lint rule that demands that the code inside catch in async functions must be if (...) { } else if () { } ... else { throw &lt;e&gt; } Its certainly easier to write a rule to allow `.catch(only(...))` but disallow `.catch(...)` though. So yeah. Maybe not necessarily a step in the wrong direction, but definitely a premature "leap". The language is not ready for it. It got by fine without this feature so far because `catch` was useless for IO errors, but when you add IO in the mix the number of possible kinds of errors that will be caught by `catch` grows by an order of magnitude.
I've just had a brief look at d3 and it looks great! Hopefully it will have just what I need. Thanks!
I am skeptical about the benefits of static typing. Our IDE are already doing a great job with type inference, and most of type errors I get are not caused by my own code but by external sources: user inputs, web services, server-side rendering, browser built-ins... stuff that TypeScript compiler cannot check because it is retrieved at runtime. I have been experimenting dynamic type checking with [ObjectModel](http://objectmodel.js.org/) . So far I am very pleased with this approach. Tell me what you think
This is what I always say when talking about "plain code" frameworks, that is, frameworks that are just a bunch of opensource, uncompiled code. I think it becomes trickier when the framework has services for deploying and packaging your code and other tools you grow dependent on. That's why Backbone has done it for me until now. It just guides you in building a solid application but doesn't really abstract away anything. Also the code is very straightforward. If they decide to close the project tomorrow, I lose nothing.
Old reasons, not relevant to the discussion. I just thought I'd mention this so people know I'm probably not a MS shill promoting their products. I genuinely like it.
&gt; so it's the same thing except, maybe with better docs But that's a world of a difference. I'd much rather inherit a large application built on an old version of e.g. ExtJS than one that was stuck together by a developer that that's no longer around and maybe didn't understand the first thing of software architecture.
&gt; A webpack plugin to do this would be trivial, for example. Using rollup internally. So your claim at the end is not so true. You are very likely going to use it. Just not directly from your package.json 
&gt; The day Javascript allows optional types, Typescript will make zero sense at all. I await that day too. Not because I hate typescript (I don't) but because optionally annotated JS is so damn enticing.
For 99% of use cases, esp in the frontend, I'd say you're better of with someone elses work. Building and maintaining a web ui framework is not a trivial thing, and there are many edge cases that are hard to cover. Yes, you'll be adopting their choices and designs, but that's likely "ok" because you gain so much else (esp a community). Most developers (and companies) are simply not capable of producing an actual framework. All private/internal company frameworks/libraries I've used throughout my career has been the worst maintained and most bug ridden code ever. Usually reuse is in the form of copy-paste. Rarely is there any package infrastructure, and if there is, there's no QA, I've seen packages that didn't even run (exceptions not matter what), etc etc. (Enforced) coding standards, continous integration, code reviews, are all the exception rather then the rule, most often championed from the floor, and thus with little management backing and interest. 
Heh.. Hmm. Took a look at the repo and it looks like it actually declares ember-cli as a [dependency](https://github.com/angular/angular-cli/blob/master/package.json). Interesting, I suppose. 
Basically, yes. JS can namespace things within scopes, i.e., functions. A lot of libraries for instance return a a single object that you can work with as an API of sorts. Immediately invoked functions that return an object is a popular way to do this, e.g.: var MyMath = (function() { var name = "MyMath"; var double = function (number) { return number * 2; } return { name: name, double: double }; })(); However, this doesn't take care of organizing your code in different files etc. Instead you'd use a some kind of program that conforms to some design pattern taking care of namespacing etc. One of the most popular and simple ones is [Browserify](http://browserify.org/) using the CommonJS design pattern similar to how NodeJS does things but for the front-end. It basically bundles up all your js files that are linked with the CommonJS pattern into a single file (aptly named bundle.js) which you then link to on your html as your only script tag.
Author's post mostly seems, to me, to be a reaction to that he felt mistreated on his [GitHub PR](https://github.com/meteor/meteor/pull/5465) and while he claims: &gt; The only feedback I got in several days on this PR was someone complaining... Looking at the PR it was not "several days" before a response but about two days and while it might not be what you want to hear the guy has every right to raise his opinion (good or bad) on the PR. I might be wrong though and the PR was just the last disappointment the author could take before writing this blog post. However if this post is just written in anger after the PR, I'm sorry, but I have a hard time taking it seriously.
You can improve minification and gzipping by bundling
I'm using mvc so bundling and minification is taken care of. It just seems like I've got a lot of functions listed in a single file. Some methods reference methods in other javascript files so namespaces seemed like a good way to make that reference obvious for someone else that may work with the code. E.g. seeing "helpers.pad()" indicates where the pad () method is. I've got separate js files dependant on each other which I know may not be the best way to do things, but as these js files are only ever going to be used for this one project it seemed reasonable. Edited: hopefully explained myself better 
Don't take this the wrong way but, what?
You are right when you say they hired me for a reason is that reason is that I can do things even if I don't know how to do it I can figure it out somehow. For a junior-mid developer like me it is always challenging to think like a senior Dev it is just about experience and that's what I am building now on my career. Thanks.
You're probably searching for the `compose` function, or in LoDash it's called `flow`: https://lodash.com/docs#flowRight *Edit*: Its implementation would be something like: https://github.com/Wildhoney/Funkel/blob/master/src/funkel.js#L59
Your code will stop at the first `return`.
so I removed the returns but it still doesn't work
I got no idea what this means
That looks real handy, thanks!
I'm not particularly Meteor-savvy (as indicated above), but my understanding is that you don't want to be running unbundled meteor on a live server? We don't need the live-reload bits in production and we don't want to be sending out loads of unbundled unminified files.
Yes, I certainly agree that other things being equal you want to hire the candidate with broader/deeper experience. It's only any implied prioritisation if other things *aren't* equal that I'm questioning here.
Yeah everything works fine I'm just looking at making it more readable. No one else has looked at the code apart from myself in the three months I've been working on it. Thanks for the advice 
I read a few weeks that several of the more popular framework projects do indeed share ideas (and tools, it seems). 
&gt;That seems like the front-end equivalent of asking someone to write a red-black tree implementation, and about as useful as an evaluation method. No way. This is the front end equivalent of only using container classes and their methods to interact with data structures, then being asked to use a raw vanilla array and throwing your hands up and saying "I don't know how to access elements without using a getAt method." Your answer would have been correct three or four years ago, but the web landscape is vastly different, because of jQuery. It's made itself way less necessary for DOM manipulation.
Sorry, but I think its a really bad interview strategy. jQuery is an API just like any other, and the DOM is another API. Knowing the DOM API doesn't mean you understand whats *really* going on under the hood, its more like scratching the jQuery layer of paint off the hood. You're looking for someone that can pick up a new API in a few weeks, not someone who knows how to work with a specific API.
Commenting for future purposes.
Its working now thankyou! I did function validateForm() { return (validateEmail(),validatePaymentType(), validateRestrictedMode(), validatechanneldetails()); } 
You can click "save" instead, FYI. 
open source use projects making use of other open source projects, the scandal! 
Every language can have those features. The fact that JavaScript and PHP happens to be like this on their very start is part of the reason of their popularity. You drop a file and get new functionality. That's awesome. There is a "hooking system" between WordPress and the plugins, but the plugin code uses the "Assumption Inversion Principle", i.e. it uses some symbols that are pure assumptions of the environment. If plugin code needs to "hardwire" itself with some "import statements", then the WordPress Core would be doomed from changing, because there would be a hard tie between the code pieces. This loose coupling is what makes it special, flexible and powerful. 
&gt; i.e. it uses some symbols that are pure assumptions of the environment What do you mean? In Wordpress do they just do if(globalMethod) { globalMethod(); }
I ended up trying both, i preferred React but ultimately i ended up going with [VueJS](http://vuejs.org/) as i can use this a bit like i use jQuery and slowly ease into the component/SPA aspect of it. I think of Aurelia and React i'd say React is the one to go for, for now but my ultimate choice was Vue :)
Just going by the docs, I don't think so. But you should be able to handle it via group policy.
Not all people in the javascript community are in it for the popularity contest :) (which is the impression of many libraries). Teams from typescript (microsoft), angular (google), react (facebook) and ember (Ruby/Rails community leaders) are really working towards the same goals, so collaboration is a very good thing. Also - open source is amazing for exactly this reason :)
Most if not all of his issues with Meteor are things 99.999% of people won't encounter. I've been working with Rails for about 5 years now and not once did I have to modify Rails core. Why did this guy have to modify Meteor core? Again: Very specific needs or just ignorance. Most people won't run into this issue. His criticisms aren't valid, and pretty dumb.
Nah they told me raw DOM no frameworks allowed. I really tried to pull binding and OOP out of my ass on that one too and well didn't do well :) 
Heed this advice at interview time and even *you* can destroy!
Source: &lt;iframe ... allowfullscreen="true" sandbox="allow-scripts allow-pointer-lock allow-same-origin allow-popups allow-forms" allowtransparency="true" ...&gt; Message: Ignored call to 'alert()'. The document is sandboxed, and the 'allow-modals' keyword is not set. Well, alerts are pretty annoying. Just use console.log or innerHTML.
So in my professional experience in enterprise there are so many frameworks in use that even if I wanted to use vanilla JS I couldn't. For example I do a lot in liferay. It wraps the entire DOM in AlloyUI crap. Au natural won't cut it as the expected scope won't match up because of how portlets are delivered to the page. You're probably right to think in todays SAAS and other types of organizations. I can do stuff in native JS if I can pull up MDN and at least see node documentation.. but transversing through the DOM, binding, and/or especially anything with AJAX can be quite difficult without some sort of framework moreso during an interview where people are watching you. TLDR: If the technical requirements require no framework I get that. But grilling me with tough questions so you can hire your friend is what some of these have felt like. Granted I really think it has come down to I just suck at live coding...
disclosure: self submission
Ok, looks like I'll need to reach out to the server admins then to see if I can get my URL exempt.
Quick explanation of the biggest differences: Typescript is mostly about having compile time checking. JavaScript is really powerful in part because you can pass data around and it usually doesn't matter to your runtime what that data is, most of the time it'll keep "working" even if not as intended. This is really cool in web dev, because you don't know where input might be coming from. A very some example is a number. If you pass that number from one variable to another it's still a number. But if that number is a form input or a request, then it's probably a string. Because JavaScript doesn't care, it'll just do whatever it's gonna do. This cuts out all the repetitive code of recasting the types of variables. It also cuts out the need for programming for edge cases that would break an app. That user's edge case won't be satisfied but it usually won't crash the browser or server. TypeScript doesn't remove this power. But it give developers some optional control and a way to find some hard to find bugs. It does this with bring in types in the code so your code is cleanly passing around what your other code is expecting. But then it compiles to JavaScript and runs just like javascript, because it is. 
This is the kind of bullshit that's lead to idiots filing their Github profiles with useless crap. You can tell what languages I worked with? Yeah, that's on my resume champ (seriously, you're in charge of hiring people?). Code quality? It's absolutely trivial for me to rip off code from anywhere else, tweak it so can't just do a quick search to find dupes and done. Also, you have no idea if I actually understand the concepts/frameworks/libraries/languages/tools/design patterns that were used. I could easily have cobbled together pieces from online resources. Your misplaced trust in an indicator that is so easily manipulated is pretty scary.
Odd thing is... alert()s still work in jsFiddle, same Chrome browser. That's why I assumed it was a CodePen thing...
:) Been there before. That's not the case here...
JSFiddle might have allowed them, I remember trying a few weeks ago there and it didn't work.
I just tried and it's working. Weird! Thanks for discussing!
Instead of blaming the technology for your inability to operate have you considered practicing your architecture skills? It would allow you to prototype much faster and identify problems far earlier before they become an expensive nightmare.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/node] [I made a library to enhance Object.observe event bindings. Let me know what you think!\[x-post\]](https://np.reddit.com/r/node/comments/3pnaow/i_made_a_library_to_enhance_objectobserve_event/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Yes, but this isn't something you could fix. https://developer.mozilla.org/en/docs/Web/HTML/Element/iframe &gt; `allow-modals`: Allows the embedded browsing context to open modal windows.
Filed at https://github.com/google/closure-compiler/issues/1222 I'm on vacation but I'll look into it when I get back in November. Make sure you're on the latest version by the way.
When interviewing, I think it's useful to ask things that the applicant doesn't know to see how they handle things they don't know. See how they approach a problem, identify that they don't know, and what they do from that point. 
Interesting... Thanks!
And a lot of this even can be moved into bash scripts, assuming that is acceptable for your team. Like why futz around with node file copy APIs when you can just `cp -r`. For many projects, things like Grunt and Gulp just get in the way and don't provide enough benefit for having to deal with them.
Somebody needs to fill their Github profile so they can use it when applying for jobs.
You can click "save" instead, FYI
At least node is platform independent. If you're not on linux/Mac bash scripts are out.
Yes absolutely.
It might be fair, but it doesn't make much sense. It's not hard to learn the DOM API. Most people just don't do it, because most of the time, jQuery and the like are far more productive. Testing for memorizing stupid APIs is not particularly smart.
This is why I stick with vanilla JavaScript and jQuery. Once a framework comes along that is as solid as jQuery, then I might use it. I thought AngularJS was going to be the jQuery of MVC frameworks, but after the Angular 2 announcement that seems to have gone down the tubes.
You could do that without JavaScript, but it would be kinda silly and complicated. Basically, you'd need a rule per combination. So, if there are 3 buttons in one category and 4 buttons in another, you'd need 12 result elements and 12 corresponding CSS rules for showing the right one. Additionally, you'd need to structure your markup in a very specific way. http://jsfiddle.net/eaLxm8fn/
I disagree. The DOM isn't that much lower-level than something like jQuery. It's just a *significantly* shittier API to do roughly the same thing. So it's not really "what's under the hood", as you'd have with assembly and low-level C. Moreover, it's an API anyone who uses jQuery can pick up in a week or two. Again, it doesn't involve learning some deep concepts. It's just memorizing a bad API to do what you already knew. I mean, when all else is equal, I guess that could be a tie breaker. But you might as well quiz people on the order of parameters in PHP functions. It's roughly as useful.
You can click "save" instead, FYI.
Upvoted for Backbone. We use it along with [Marionette.js](http://marionettejs.com/) and [Cocktail](https://github.com/onsi/cocktail) for our main Rails app.
It's a easier than it used to be, with querySelectorAll and so on. So it could be useful if you don't want the 200kb jQuery requirement. But it's still kinda shitty.
Nothing you do can override what the user sets. But I was able to detect that they had Compatibility View on (which makes everything render in IE8 mode and generally isn't supported by my app) and send them to a page with instructions on how to turn it off.
I'm just using bash scripts in my projects these days. All the tools I use (babel, stylus, web pack, etc.) all have --watch flags. So I just kick them all off from one script and away I go.
You can copy static files with webpack using file-loader, and in fact, it has several advantages if you do so: * file-loader would copy the **require**d file and put it to the destination folder. * url-loader would convert, for small images, the file to base64 and inline it in HTML (if it is small enough) saving you an HTTP request. * image-loader would automatically compress the images * style-loader and css-loader work together to take CSS and inline them in HTML, again, saving an HTTP request. If there are any images in your CSS (e.g `background-url`) it can be resolved and packed automatically using the aforementioned file-loader. I'm using these loaders for all my styles and images and it works great.
Ugh, that... almost everything. People love to post that link as an example of how jQuery is unnecessary, but to me, it reads like an ad for jQuery. Check out the alternatives to .is, .filter, .siblings. And I'm not even talking about everything that has to do with classes, before IE10. What a load of hot garbage.
Isn't OSX Unix? I think it just has some platform specific commands added, like every other linux distro.
Sorry, was just my experience with them all :D
He means that your scripts won't work on Windows.
It was mentioned on stage of the AngularConnect event that the angular team collaborated with the ember team for their new CLI. So yeah, not a surprise (or a big deal, for that matter).
How do you arrange that, out of curiosity? Just a folder of scripts? &gt; scripts/watch &gt; scripts/build &gt; scripts/deploy 
I like JavaScript, but things like this highlight some of the awfulness of the language. Whilst learning C# I never came across such awkwardness that necessitated numerous explanations about why things work they way they do and how to work with or around them. Edit: btw I appreciate your writings and attempts to explain for people like me ;-)
Just be thankful you don't use PHP. :) Ah, downvotes! Reply and tell me why PHP is the best thing ever invented, and better than JS. ;) Can't do it? yeah i know its ok. :)
You can override compatibility view with a meta tag. Enterprise Mode though, not so much.
My standard shell on Windows is bash in conemu64. Comes with git for Windows.
What? Webpack even comes with a dev server?!
Yeah, there are lots. Just wait 2 more years. React.js will outnumber Angular openings 5:1 at least.
&gt; step 1 of your job as a dev to create an equivalent reinventing wheels is not a good thing to do. step 1 of your job would be to start using jQuery or another high quality, battle-tested library that solves your problem. there are some limited circumstances where you can't include library code for one reason or another. these are edge cases though. that's why I get so surprised when interviews insist on vanilla js. unless the interview is for a very specific niche kind of development where using libraries is impossible or impractical then its just bizarre to me to ask anyone to not use libraries to assist in development. that is actively bad development practices. 
I agree to some extent, but I also think people will grab the newest thing whether it fundamentally does something different or not. For me it's sometimes hard to tell the difference between something I should run at and learn and something that is simply newer. I swear everyone was part of the Gulp lovefest even just a couple months ago. Edit: different -&gt; difference
Focusing on vanilla js has really helped me understand third party code and their API's. I find that I pick up on their docs way quicker than before. While I wouldn't use it in real production stuff, I believe it is vital to be somewhat knowledgeable.
They sure do make it easier though, don't they? 
Not the correct approach, You should call all functions individually and store it in a variable and then do and of all of them. Something like: var validEmail = validateEmail(), validPaymentType = validatePaymentType(); result = validEmail &amp;&amp; validPaymentType()
And try adding `--language_out=ES5` maybe.
You mean the Linux make command? How is that relevant here?
"Writing a low-level DOM manipulation framework" isn't an example of some core concept. It's a performance requirement, more than anything. You could also say "could you write a webapp that takes less than 20kb overall in jQuery", which incidentally is a far more common argument. I'm not saying there are no cases where plain DOM might be more useful - even in far more common cases than your rather extreme edge case. I'm saying that knowing the DOM doesn't really teach you all that much, core-concepts-wise. jQuery is not some high-level abstraction of the DOM. It's, at most, a utility library that acts as a very light wrapper over existing DOM methods. And it's becoming increasingly more so over time. 
ASP.NET? 
These "why you don't need X" links are like crossfit. You can tell me about the revolution but I'm going to stick to my tried and trusted tools just like I'm going to stick to a workout that involves bench press.
It does the same thing
The answer to the question about familiarity with the Dom is more valuable than the knowledge of the Dom Api itself. It identifies someone who seeks a deeper understanding of how something works underneath. Some roles need people who seek deep comprehension of a stack and some roles are appropriate for someone who just wants to get something done with higher level tools.
If only every company had the same policies yours does. But then again, I'm sure it didn't start out that way. Quality is a goal to be worked towards constantly.
What I have a problem with, is the idea that the DOM is how "something works underneath", and jQuery is some high-level abstraction. It's really not. The DOM is just a more cumbersome (and in the past, browser-incompatible) API to do the same exact thing. The core concepts are identical. 
An abstraction is an abstraction. The main problem with jquery is it's imperative nature. In any case, some people will be curious about what, if anything is different beneath an abstraction and some will not. 
You're probably spot on there, but I feel that some frameworks / libraries will have their advantages over others in this scenario. I think React is probably what I'm doing to end up going with though, if only Angular 2 was near completion...
Seems like it's the users of the frameworks that get more caught up into the 'x vs y' wars, while much of the dev teams behind the frameworks seem to be far more collaborative, sharing ideas and learning from each other. 
&gt; But then again, I'm sure it didn't start out that way. No, it certainly did not. It has evolved to this point and there were several obstacles that had to be overcome. For starters, a process like this makes development slower. But it also meant less back &amp; forth with QA and less time spent on support calls, because our software is just over all, better. This argument was a bit hard to swallow for management, and it took some pressuring to get them to understand. The code reviews were tricky, because some folks felt that they would be publicly shamed somehow. This was overcome with time as those particular dissenters realized that negative reviews were not attacks on them, but rather it was done in support of the project itself. Plus it's a great mechanism for leads like myself to help teach less experiences programmers. To me the current challenge now, is when someone makes a commit, and I would notice something wrong in the diff, point it out, then get told "well, it wasn't me who wrote that". We, as team, need to take ownership of the project as a whole, not just our own individual contributions. 
I disagree. An abstraction that's merely a more consistent alias, or a three-line utility function, that doesn't change a single core concept, is substantially different than *actual* abstractions, like React or Webforms. If you dig under that abstraction, you'll find nothing but less consistent method names that do the same exact thing, and missing basic functionality that you have to write your own utility functions for (stupid shit, like splitting and joining class names manually). You won't really find any new concepts, or any enlightenment about "how things work underneath". And I'm not sure I get the point about jQuery being "imperative in nature". It's no more and no less imperative than the DOM API. If it was more declarative, it would've been a far higher-level abstraction than it is.
No, it really isn't. :-( Well, maybe compared to old ASP…
You're talking like you've never been employed as a developer 
People that do front end work have quite varied skill sets and rarely the patience to do bash scripting when you can do similar or the same tasks in Gulp much faster.
I just good use IDEs so I don't need any of this crap.
Gulp is a task runner, which happens to have many build tools with a compatible API. It doesn't enforce anything on how you link them together. Webpack is a monolithic build tool that supports plugins. It has some kind of life cycle, but doesn't care what you slot in. Run your build/deploy/publish tasks with Gulp, but having an orchestrated build tool makes it easier for everyone to just do things one way.
I think it is easier for you to explain how it is irrelevant (-:
But you'll find it difficult to leverage the community for reusable bash scripts. What you want is an orchestration framework where each of your bash scripts can execute in a controlled and ordered way. In other words, a modular build.
I agree with ejfrodo. I was searching for such explanation, thank a lot!
Adding `--language_out` resolved it. Thank you! I'm definitely going to have some fun with this. :-) Enjoy vacation!
Like if you were using JS for your application code and wanted a somewhat small task runner so you could also run your build process in JS? Someone should make that...
try javascript.
It still exists... For now. 
so so true. 
Even then, node manages to misbehave between systems. It's the least cross-platform cross-platform system I've used.
We should just go back to using Automake. It's been around for decades and works great.
Per my original line it has made me a better developer. I agree with you completely. However I don't think it benefits front-end development much. 
Nothing wrong with vanilla. Especially when you're loading onto other people's pages, loading in additional libraries can add a lot of weight.
I only downvoted because of the passive-agressive overload in your edit
&gt; there's an unhealthy obsession with [...] knowledge of trivia rather than good working habits. Yes. &gt; there's an unhealthy obsession with vanilla js right now No. I'd sooner say there's an unhealthy obsession with frameworks. Too many people ask, "which framework should I use for [insert use case here]." That is the wrong question. The right question is, "how can I use vanilla JS to solve this problem and at what point would using a framework instead be worth the tradeoffs?"
1. some libraries are large. very common utility libraries are not. jquery is only 90K when minified. backbone is only 19K when minified. 2. very commonly used libraries such as jquery are probably _already_ in the user's browser cache if you're linking to a CDN distributed version. 3. yes there is something wrong with vanilla. cross browser compatability issues are still a problem, and overly verbose and confusing APIs in vanilla js are likely to slow down the rate of development and potentially even increase the number of bugs in your program. 4. using only vanilla js might be appropriate in some niche cases. if initial page load time for first time visitors is important for your use case, that might be an argument in favor of it. if you're doing some kind of dynamically loaded redistributable widget that's another potential use case that supports using only vanilla js. in general though, there isn't a lot of good justification for it. its a handicap, not a virtue to limit yourself to vanilla js when developing your frontend for the vast majority of use cases. 
&gt; jquery is only 90K when minified. Are there situations where you not be able to minify jQuery?
Why would you code an entire application in vanilla javascript when its so easy to include things that people have already made?
It's important to weigh the tradeoffs *correctly.* The most important tradeoff is performance. All frameworks are slower than properly-written vanilla JS. Is slowing down your app to make your life easier as a developer worth it? Depends on the project. Sometimes yes, sometimes no. But that is the first question every developer should ask themselves before considering anything else.
PHP did for server-side programming what JS did for the client. Neither are perfect programming languages, far from it, but both made it incredibly easy to get started. E.g. I just learned to write an HTML document with a heading: &lt;h1&gt;Hello World!&lt;/h1&gt; Going from here to "I can write an HTML document with a heading that also outputs the user's name from a query param" requires that you learn two things in PHP: how to read a query param and how to write a string. Which is - afaik - as minimal as it could possible be: &lt;h1&gt;Hello &lt;?php echo $_GET["name"] ?&gt;&lt;h1&gt; No controllers or views or functions or classes. No compilation or restarts. Not even multiple files. All given a basic setup which thanks to things like LAMP/WAMP was a matter of clicking a button. It's a thing of beauty when it comes to learning. There's a reason for all the crappy PHP code that is out there: It's written by people who managed to get started with PHP but never had to learn "serious" software development. True, many people who started with PHP then went on to objectively better platforms for bigger projects. And big projects "stuck" with PHP aren't all that great to work on. But pretending that PHP as an entry point to programming is bad, isn't quite fair to PHP.
none that I know of, other than an inexperienced developer forgetting to do so or not realizing how important it is. 
&gt; So it could be useful if you don't want the 200kb jQuery requirement. There's also Cheerio.
Funny that even though your posts for this site are automatically filtered as spam (and thus never viewable on /r/javascript), they still get upvoted somehow...
Is Gulp generally considered better than Grunt nowadays? 
I didn't know about the `arguments` thing... good to know.
How would you move your static files like css, fonts to other folder rather than put them in the same folder with bundled.js?
I think when it comes to build tools, trying new things isn't all that bad. Take whatever fits the project when you begin and roll with it, in my experience the build process rarely changes. In best case scenario other contributors in the project don't even have to care what kind of system analyses, compiles and copies files around. They can just run the "npm start" you mention in the README and start working with everything you listed as supported. Your average bundling, static analysis and preprocess/transpile operations are relatively simple with all the tools and even if some of them aren't exactly intuitive, most devs can tweak the code or configuration without all that much research.
&gt;I await that day too. You already missed it. ES4 has types. 
There are a lot of problems that require methods that I haven't yet learned about. I'll run into issues with how to run functions with them. I guess its hard to say what's isn't clicking bc honestly it's probably a lot. I feel like I just need more practice using recursion, callbacks and for loops. 
&gt; dived (diven?) It's: dive, dove/dived, dove/dived. Anyhow, if you're coming from CS, there is another thing which might surprise you. You can close over your loop counters if you use `let`. Each iteration gets its own copy. for(var i = 0; i &lt; 3; i++) window.setTimeout(() =&gt; console.log(`i: ${i}`), 100); Output: 3, 3, 3 for(let i = 0; i &lt; 3; i++) window.setTimeout(() =&gt; console.log(`i: ${i}`), 100); Output: 0, 1, 2
Yes, it's file processing and streaming is much faster. It's also easier to look at because it's more programmatic instead of configuration based 
The internet is based on *nix. Windows can't even get the slashes going in the right direction.
Webpack + Babel for ES6 transpiling is my choice (and yes, production code).
&gt; alerts are pretty annoying ... what? You're annoyed by alert popups that you yourself create?
People are downvoting because your hating on a language with out backing it up. And your edit asks them to prove you wrong... I am god, praise me! What you don't believe be, prove me wrong, you can't! No one cares to prove a stranger spouting hate on the Internet wrong. It's easier to express your disagreement with a simple down vote 
I guess... its just a couple of lines of code and even though you were looping through a bunch of nodes it was still faster at execution time than a querySelector. I know having to write those few lines of code and hide them into either a generator or behind an alias is a complete career ender for some people, but really this just isn't a big deal. To me querySelectors are like extra sugar in food. For most people it really makes all the difference (can't live without it)... except now you have rampant morbid obesity and children with type 2 diabetes. A nice convenience shorting people's life spans, driving up medical costs for everybody, and making people slow as shit (provided they have to run somewhere and not have a heart attack). Its easy to draw such comparisons so directly when projects making frequent use of querySelectors tend to be tightly coupled and more costly to make massive changes against.
[The folks at facebook approve babel.](https://mobile.twitter.com/amasad/status/631251607422787584) TypeScript is just another language that compiles to JS, with type annotations being one of it's main features. It borrows lots of C# syntax, the tooling is second to none and also wants to provide future ecmascript features the way babel does.
[**@amasad**](https://twitter.com/amasad/) &gt; [2015-08-11 23:51 UTC](https://twitter.com/amasad/status/631251607422787584) &gt; http://Facebook.com is now compiled with @babeljs 🎉🎊✨ ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Sure. Honestly, I thought the problems with PHP were pretty evident and well-known in the broader community, and a google search for php will usually explain why it's a bad language, but if you want some of my opinions on the matter, then [here's some from yesterday](https://www.reddit.com/r/javascript/comments/3pkf6y/blog_post_why_javascript_and_php_rule_the_web/).
jQuery was first to market and made writing Javascript more accessible and cross browser than others at the time, not to mention cut down a lot of code you used to have to write. Plus, there were plugins. It was adopted very quickly.
I suggest http://www.freecodecamp.com/ Along the same lines as CodeCademy but with a very large user community (in chat at all times) who are always willing to help. The Basic Algorithm section is where stuff starts to sink in.
Bunch of [goddamn neutrals](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTiTJKmtMiVkWHQL8n9QG-YmXMVrhKu9jCfXRRwi_829D-Uz8un) in here Use Bootstrap at the very least. Looks good with minimal effort. I love React and totally recommend it.
On the other hand, solid tools are timeless. People still use Emacs for a reason.
I wrote a 5-part blog post series on promises: http://blog.getify.com/promises-part-1/ Also, I've covered them extensively in two of my books: https://github.com/getify/You-Dont-Know-JS/blob/master/async%20&amp;%20performance/ch3.md https://github.com/getify/You-Dont-Know-JS/blob/master/es6%20&amp;%20beyond/ch4.md#promises Lastly, here's a great visualization for them by Nicolas Bevacqua: http://bevacqua.github.io/promisees/ Hopefully those resources help.
That's all very well until you get handed a project with a 493 line long gruntfile. I wish I was kidding.
And the $10 million?
Karma and Jasmine? Regardless yea I had some issues too.
It burns me that all those build tools are being compared to `make`. Make is from another age, back when rebuilding the whole project every time you added a semi-colon somewhere was not just stupid, but also a huge waste of time. And so the whole tool was designed to let you express dependencies in a way that will avoid building more than you have to as much as possible. If your build tool is too cool to natively check for last-modified timestamps and compute a minimal rebuild graph from a tree of dependencies, it probably shouldn't be compared to `make`. 
Masochism?
Is it a fb project now? Looks like the creator is working there nowadays
it's dicking around with `$inject` and `$compile` and sometimes having to do a manual `$digest` that makes it a hassle for me.
Oh course you don't *need* it. The real question is do you want it?
Hey brah. I probably shouldn't have done this, but I wrote the code because I was bored and wanted to flex my JS skills a bit. Keep in mind, I just strung this together quickly and you'll probably need to improve it. Can't do all the work for you. HTML: &lt;button id="clickMe"&gt;ClickMe&lt;/button&gt; &lt;p id="output"&gt;&lt;/p&gt; JavaScript var button = document.getElementById('clickMe'), output = document.getElementById('output'), counter = 0; button.addEventListener('click', function(e) { counter++; if (counter === 1) { output.innerHTML = 'You pushed the button'; } else if (counter === 2) { output.innerHTML = 'You pushed the button (again)'; } else if (counter &lt;= 5) { output.innerHTML = 'You pushed the button ' + counter + ' times'; } else if (counter &gt;= 6) { output.innerHTML = 'Stop pushing the button.'; } }, false); Edit: Forgot to add you might want to check out [Foundations of Programming: Fundamentals by Simon Allardice] (http://www.lynda.com/JavaScript-tutorials/Foundations-of-Programming-Fundamentals/83603-2.html). It helped me think more like programmer and how to break problems down into steps (algorithms). Your exercise was pretty easy and the instructions were laid out great, the only thing that was left to do is to translate it into code. Good luck brah, you're gonna make it.
I'm not sure it's a facebook project, per se, but the creator does work for them. I would assume they picked him up to ensure that integration/improvement with react/jsx continues, but that's just speculation on my part.
Good luck on that test! 
All good until you have to run something like make, which a build tool would abstract away for you.
You could probably use typescript in secret if you needed to, since it can output clean javascript including all your comments.
the vast majority of issues I have run into with Node are on Windows systems... But I guess that's to be expected because it wasn't written on Windows or with Windows in mind. Linux really seems to be the most ideal environment as I've had a few issues on Mac too, but all the issues I've had on Mac were related to homebrew and none of them were big.
An abstraction thats merely a more consistent interface is either unnecessary or a shim. 
Something that would make your code more readable, elegant and shorter is not unnecessary in my book. 
Not too familiar with Atom brah, but it should.
I wrote that code in Codepen, but I usually use Sublime Text. As long as you can run it in the browser or an IDE it'll work brah
[dived](http://conjugator.reverso.net/conjugation-english-verb-dive.html)
&gt; You can tell what languages I worked with It shows what languages you *choose* to work with, not necessarily ones you currently do. And it shows the problem domains that you tackle using them. It's a better indicator of if you use the right tool for the job. &gt;Also, you have no idea if I actually understand the concepts/frameworks/libraries/languages/tools/design patterns that were used I'd have even less of an idea of that without seeing code. And anyway, that's what interviews are for. But either way, a Github gives a wealth of information *along with* the resume.
We have to come up with a standard!
None of that affects me. I'm sorry, but it just doesn't. They barely register as interesting. You could argue that there are too many settings in the ini, and that would probably be true. With the prevalence of PHP across the internet I think you paint a picture that just isn't true. What servers today have allow_url_open to be set, or whatever other ini gripe you have? Things being wrong in the past is a historical note, not a current issue. Functions that mutate: Possibly an issue for some, but not for most. I'd be curious to hear how this has impacted you in the past. Errors vs exceptions. I know Pythonistas love them some exceptions. Errors aren't exceptions, but exceptions can be errors. I can't say I've come across any exceptions that weren't for something I've done which breaks the program and is worthy of an exception being caught and logged. I know this is a personal preference, but I don't want exceptions for every little thing that has to return some minor error state. I prefer to reserve exceptions for things that are truly broken. mysql_ is so deprecated that it hurts, and for you to bring this up is clutching at old woes. As a PHP dev if I go on old information then I'll be basing my 'education' on bad data. The current state of PHP, and for some years now, is well-past a mountain of issues that used to exist. I suspected old-woes would be the argument made, and more-or-less it was. In the meantime most of us can still get coding with PHP without any drama at all. The newb running xampp on their computer serving their first program using mysql_ functions is not representative of what I would consider a coder with education in PHP... self-taught education or otherwise.
[Image](http://imgs.xkcd.com/comics/standards.png) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 2103 times, representing 2.4657% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cw8fec4)
It eventually leads to complete nightmares of highly coupled spaghetti code when used to build products of any level of complexity above a brochureware site.
Python is not that much slower than JS. Particularly with things like C libs underneath the covers (numpy for example) and also with PyPy / Cython. Honestly I feel like many Python programs heavily utilizing numpy will probably outperform the crap out of JS. Also there is C, C++, Haskell, Go, Scala and quite a lot of other cool languages. Also I thought this was /r/programming/ not /r/JavaScript/ where my comment would have been much better received and the comment I respond do would have been ridiculed.
Eh, people keep moving on to newer, purer languages. Every language out there is going to have some warts. Some of the ones that are stringently "correct" may even lose usability for it. The real measure of a language is how productive you can be with it. For that PHP has been a smashing success. Same goes for JS. One gripe that I have with JS is that it still doesn't have a real module system or a good ecosystem built around that. I am excited for ES6 modules to finally fix that and for HTTP2 to get rid of this concatenation mess that we've had to do so far. PHP has had this covered like a boss for some years now with its namespaces and with Composer. I get that NPM fills this space with JS, but it just feels awkward and messy compared to Composer. I'm hoping that with ES6 modules, we'll get a cleaner analogue on the JS side. Grumbling aside, I really do like both languages.
You would want to memorize that couple lines of code" and repeat it in every project? I doubt it. You would put it into some kind of convenience library right? Soooo, something like jQuery/Zepto/Cheerio....? I wondered why your name looked familiar. Oh yeah, you are the guy who was railing against classes while confusing RAM for Storage...
What part of jQuery, exactly, leads to shit code? ('spaghetti code' is impossible in js as far as I know because there's no goto keyword). There's no language, framework, lib or paradigm that makes it any less difficult for bad programmers to write bad code. I've seen shit jQuery and shit xmlhttpreqs. I've also seen shit angular. A library containing commonly used functions isn't to blame for poorly written code. 
Would be nice if Node had rest parameter support, I guess I have to wait a little longer ...
Webpack has hot reloading so when you change something there is likely a chance you will not need to refresh. (automatically, or manually)
Depends who you ask and your target. I've heard many experts argue 500+ kb is death for a mobile site. Do you want to spend half that on jquery? On the other hand, I've seen sites 50+ meg in pictures alone (professional fortune 100 companies). 
I would make it a library file. Reproducing it would only take an extra 10 minutes per project, which is still trivial. &gt; Soooo, something like jQuery/Zepto/Cheerio....? First off, I find almost never need a getElementsByClassName method. Secondly, these 4-6 lines of code is less than 0.5kb.
I still use make. It's a great tool. I'm old.
Personally I've been working with gulp and really don't like the plugin system you have to buy into. For every "thing" that is used that's not a plugin by gulp, I need a plugin for it. I've on more than one occasion encountered a plugin that's outddated and I want to replace with a simple command from the native dependency but alas, I need a plugin that is in it's streaming ecosystem.
[removed]
Here I am wondering why just using raw JS (and Jquery), CSS, and HTML is so frowned upon. I cannot be the only one that finds it easy, bordering on trivial, to wire everything up properly and in a way that is maintainable. CSS is supposed to be this ugly terrible thing but I am baffled as to why. I use scss for its extra features, but could just as easily, and on occasion still do, stick to vanilla css. The hardest part is naming my selectors. Normalize.css and the next line are all I need. *{box-sizing: border-box;} I look at things like node, react, and flavor-of-the-week.js and am in awe at how adding several layer of abstraction is supposed to make things easier, let alone accessible and compatible. Not to mention, until recently and maybe still, javascript was one of the more quirky languages in existence, next to PHP, with lots of loljs to go around. What happens if JS is disabled? To shreds you say? What happens when that framework loses popularity and is ultimately abandoned? To shreds you say? If for some reason your giant javascript framework fails to render your view, there is little room for recourse. You can do server side rendering, but I am led to believe that is a waste of time and no one does that. I'm a web developer that maintains and builds pretty complex sites and am willing to listen if someone could enlighten me on this. What am I not seeing? I'd love to make my life easier if possible.
My experience has been that nothing is ever documented, so at least I'll have the framework's :)
Me and you both. I can't fathom why so many people are scared of vanilla.
Please help me along, what would be a usecase where you'll need something like this? And why would something like moment js not suffice for that usecase? For the rest thumbs up looks great.
&gt; kind've Wut
`_.throttle(myFunc)` done.
Yeah I went and checked after I posted. Past participles aren't always that intuitive.
The question is more of "why is this happening?", rather than "I need a throttle function!!!". I also mentioned that I'm building it as an exercise.
Yeah I hear you. Just trying to help out!
Author didn't mention Flyjs which is the next generation (es6) build tool.
You can also use VS Code or Atom + atom-typescript. They all use the very same analyzer.
I'm aware of the various actual implementation of throttle functions. I just cannot wrap my head around why this implementation is not working as it should even though the logic looks sound.
I use both gulp and webpack. Copying file with gulp is easier and platform independent.
I'm not using process.nextTick anywhere...
maybe i'm the fucking newb. lol
THE AMERICAN PEOPLE ARE SICK AND TIRED OF READING ABOUT YOUR DAMN BUTTONS!!!!!!!!!!!!!
You're right, didn't read properly. When you invoke the function from the timeout, you then clear the timeout so the next call to the throttled function will go right through.
Playing around with webpack I did the same. Luckily webpack supports it natively by renaming the config `webpack.config.babel.js` from `webpack.config.js`
Except meteor has integrations with both react and angular now? The package system was at one time a boon, but has now become a problem. I've seen comments from the MDG that they intend to integrate meteor with NPM so the package system is no longer a wall.
Honestly recursion is something that sophmore year CS students rave about and isn't used too much in the real world. While working I've used it very rarely to solve things.
For me I wasn't a very good coder until I got to coding and got some experience. Do some actual coding/projects instead of coursework on sites. Create a chat program or a script that finds all the prime numbers up to 100. I'd suggest an intership but I doubt you have the time 
Node &gt;= 0.12 actually 
Because they copied this behavior from Dart. Heh. You can either consider the entire loop as a block or just the loop's body. So, you either have a block with repetition inside or a block which is executed multiple times. Neither option is more correct than the other, but the latter is certainly more convenient. That's why they went with that definition. Many beginners are confused by the unintuitive behavior you get with `var`. Having to put things in an IIFE or yet another block just for the sake of being able to close over a copy of the counter variable is kinda weird and clunky. In Dart, if you actually want JS's `var` behavior, you can simply declare the variable before the loop. Same story with JS: If `var` isn't allowed and you still want this behavior for some weird reason, you can just put the `let` declaration in front of the loop.
Maybe you were using babel, [node 4.0 blog post](https://nodejs.org/en/blog/release/v4.0.0/)
Oh, it's quite possible to write spaghetti code in JavaScript. Often it goes by the name "callback hell". But you're right, good and bad programming is still good and bad programming. Different libraries and frameworks help with different kinds of project, and the claim that you can't do anything more complex than a brochure site with jQuery is obviously silly: plenty of people have done it, and some of those projects have been maintained for longer than any of these trendy frameworks have even existed.
How does that work with the .NET CLR? I know it supports IronRuby and IronPython but do you have to install support separately? I presume all Windows boxes come with latest .NET these days ... ?
Everytime I build up a new system, I still end up forgetting about the [node/nodejs](http://stackoverflow.com/questions/20057790/what-are-the-differences-between-node-js-and-node) issue. I've had awful experiences with homebrew and postgresql which has led me to be a bit distrustful of it ...
Make something practical. Even if the result is a turd you'll probably learn a lot through doing it. Create a todo list app, or a voting app, or a simple side-scrolling game or something. If you don't even know where to start with that, then do a tutorial that walks you through building something like that.
Sorry, i don't understand your question, the benchmark suit bench against many different async libraries listed in the result, not only mine, how comes 'no point of reference' ?
Object.observe is only supported by chrome and will likely _never_ be supported by other browsers in its current form.
OK, suppose I develop on Windows. Now how is it relevant? Also I was asking a genuine question because I didn't understand what you meant. Fortunately other people with less of a chip on their shoulders have explained for you though so it's all good. 
Really? 
Thank you /u/chtulhuf, that is why Gulp still have its place in JS development workflow.
I'm not sure I understood your question correctly, but a JSON string is by definition an object (JavaScript Object Notation). So by putting your array in a JSON, you're transforming it into an object. What you could do is to make a key and store your array as its value. You'd have an array (and thus its lenght) inside your object.
That's weird... look at this: http://imgur.com/a/BZRMQ The request sends an array, the server gets an object. PS: PW in there isn't a problem, its just for testing purposes atm
&gt; And yes, I know what is considered an array in javascript No offense, but based on your question I'm guessing you don't. You're probably trying to serialize an array-like struct or something that extends from Array like a jQuery reference.
A JSON string is by definition a string. You seem a bit confused. `"hello"` and `[1,2,3]` are perfectly valid JSON values. That we generally wrap things in objects to transport them as JSON has more to do with convention than with JSON itself.
if you make each of the functions return `true` when it passes and `false` when it fails it will work; function validateForm() { return true &amp;&amp; false &amp;&amp; true &amp;&amp; true; } //this will return false If run, it only moves onto the next validation if the current one returns true.
We're not currently using ES6 at work. We have a large codebase and the direction to try not to break IE 8 though we don't actively support it, so core functionality needs to be ES 3. We've run into interesting issues when adding polyfills. You can break IE 8's `JSON.stringify` if you have added to the prototype of both Array and Function. We do talk about the language features and the amount of suck the transition will cause for the team.
First image shows the array prototype clearly. Also I create it via = [] and the only function I use on it is push()
Does `Array.isArray` say that it's an array? &gt; Does json not distinguish between arrays and objects ? Try `JSON.stringify([...'abc'])` in the console.
Are these `arguments` "arrays" you're trying to stringify? `arguments` is only a pseudo-array; it has numbered indices and a `length` property but otherwise it's a plain object. To convert to real arrays: `var args = Array.prototype.slice.apply(arguments);`
Is dmarks the array that is turning into an object? Or are the elements of dmarks supposed to be arrays? Show us where you are building dmarks and we might find the answer.
Right, thanks for the explaination. I need to look more into this. 😅
Yes look at the POST action of the contact form on you website and mock that in the speadsheet script? You might run into some issues with CORS but in theory it should be doable.
On mobile and the image won't load for some reason. What's the output of JSON.stringify?
No there is not one specific resource I could point out to you sorry. From what I understand what you want to do is this: 1. Notice that there has being a new Google form submission. - What we want to do here is get notified about any change in the document, you'll need to dive into the API I think there is a function for it. 2. We want to post this data to the website contact form - For this we need to know which fields are required in the contact form - Create an object the same way as the form would be submitted( which will involve a lot of trial and error, your network tab of the devtools will be your friend during this process) 3. POST the data with an XHR request from the spreadsheet script. - Take a look at this page if you are comfortable with xhr requests https://developer.mozilla.org/nl/docs/Web/API/XMLHttpRequest - Verify that the data is received in your backend. As I already said CORS can be a serious blocker for this. So first find out if you are allowed to POST or GET from different origins. 
Haha, I'm not sure if my post made me sound like I'm new to JS, but I'm not. I'll be using Gulp more than likely, and there'll _definitely_ be some form of livereload in there. I'm very passionate about developer experience, and keeping things organised and sensible. In fact, the project that this is for is in-part being developed because I'm trying to showcase an alternative directory structure for the CMS we're using to make things more organised, make builds easier, and make the deployed sites more secure.
Ok so in place of 'Pizza' I would get the values of 'Name' and 'Email' from my sheet. If the form I am submitting to is in the following format for example: &amp;nbsp; Name: Hair Colour: Email: &amp;nbsp; And I only collect Name and Email, do I need to create an object like the following: &amp;nbsp; var myForm = {}; myForm.key = Sheet1.Range("A1"); // This is Name myForm.key3 = ""; // This is Hair Colour (Hence blank) myForm.key2 = Sheet1.Range("A2"); // This is Email 
[Image](http://imgs.xkcd.com/comics/is_it_worth_the_time.png) **Title:** Is It Worth the Time? **Title-text:** Don't forget the time you spend finding the chart to look up what you save. And the time spent reading this reminder about the time spent. And the time trying to figure out if either of those actually make sense. Remember, every second counts toward your life total, including these right now. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/1205#Explanation) **Stats:** This comic has been referenced 289 times, representing 0.3387% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cw8rnig)
Would it help if I private messaged you the page that has the form im working on?
I can say from using other MVC frameworks, the ASP.NET MVC implementation is pretty darn good.
Great comment. I do definitely agree on the time cost vs benefit of learning a new tool. It won't always make sense to move to the latest and greatest - especially if that includes a major redesign or moving over a lot of legacy sites. Speaking more on the hobbyist-side, it is certainly nice to have those tools in your toolbelt. Sometimes it really pays off to know a CSS preprocessor, or to be able to test a site in WAMP or Vagrant without editing production code. But there's a mental cost associated like you say, and communicating and changing an entire team's workflow is even more difficult. Heck, there's still companies making money by selling table-based layouts as templates. Just shows that there's room in the market for all types of devs.
dmarks is the array. It contained objects. I got around the problem by using another approach where I manually encode the information inside a string and use an array of strings, not of objects. It works this way.
well I would have expected a serialization like dmarks[]={a:valA, b:valB} or something, instead what I got was dmarks[0][a]=valA&amp;dmarks[0][b]=valB.... I'm not sure if this is right.
Oh cool. Two more random words that I'll start seeing next to "ninja" and "rockstar" on job listings.
You know, I'm not sure I've ever used recursion in a javascript app. One of the things I like to play with is making an "evolution simulator" where there are two objects with one being a predator animal and the other a pray animal. And they have "genes" that can mutate and stuff. In general, though, I've never done a challenge "just to do it". I've learned just about everything in situ. 
Hey! So... you can look at lists of methods, and then when a problem comes along you can have a vague idea and Google around to figure it out... which will help you learn. Recursion is fun! Callbacks... I still get a bit lost on those (I'm no expert or pro, though), for loops are pretty straight forward... Can you/have you do/done FizzBuzz?
Don't save the api tokens auth key in client side JavaScript.
cool stuff, thanks! starred and will play with on the weekend
I made something very similar to this about 10 years ago as a cell phone wireless simulation in Visual Studio 5. It's a fun reminder of the fun stuff I got to write in college and it's been amazing to see all these abilities be able to be moved to the web. Thanks for sharing, I'll be playing with this tonight. :D
Naive question: Is there a proper read order to your books? 
Those are only in the context of the.NET CLR. I mean that when you do a fresh install of Windows Desktop or server it should already have Ruby and Python installed on it. OSX does this already and I believe some Linux distros do as well.
Postgres is a little weird with brew, the main problem is that the brew script is so poorly documented with what you have to do after you run brew install. If you've never set up Postgres before, how are you supposed to know that you have to explicitly "initialize" a db instance before you can start it? Other databases do all that shit for you.
Hi /u/60devs, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `60devs.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [60devs.com](/search?q=%28and+site%3A%2760devs.com%27+author%3A%2760devs%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|5|63% [tips.60devs.com](/search?q=%28and+site%3A%27tips.60devs.com%27+author%3A%2760devs%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|2|25%
So, basically all you have is Python. Well Python is fine enough, no argument here. I didn't know PyPy is actually that effective. Cython is subset of Python so it is more of a dialect. There is also an effort with "sane mode" in Google to remove most of JS absurdities (and improve the speed a lot). &gt; Also I thought this was /r/programming/ not /r/JavaScript/ where my comment would have been much better received and the comment I respond do would have been ridiculed. You know what should also be ridiculed? The fact that anyone ever took Java seriously as a language. JS has lots and losts of flaws, but ale least it is not bloated, verbose crap with infinite boilerplate. I would like to see JS replaced, but it has to be with something lightweight and straightforward. Well, there are things like Clojure and Kotlin on JVM but they just aren't nearly as popular as JS. Haxe is pretty good universal language, but again not popular enough. Ridicule all you want, but do come up with the sane alternative, and get enough people on it. 
Nope, he is correct. nvm install 0.12 node &gt; Promise.resolve(42).then(function(v) { console.log(v); }); &gt; 42 You have to remember a lot of ES6 features were in node from 0.11, they were just under the `--harmony` flag. But actually `Promise` was available in 0.11 without that flag.
_HITLER_, developer master race
Good IDEs allow for build scripts for those cases. These JS libraries are just reinventing the wheel, poorly.
Fun is killing a homeless man with your bare hands. You kids need to get out of the house more.
Oh, the blog post is misleading about it then.
This is **not** /r/domyhomework and JavaScript != Java. 
I agree that the details are a bit different, but that is based on the limitation of what's available in browsers. My understanding is that workers are implemented as threads in browsers -- with the imposed limitation that you can't share state. If a future API in browsers allows for workers/threads to share state, then I'll add it into the lib. I agree that the Node.js implementation using child processes is heavier than I'd like (and a misnomer), but a future version will very likely use something like threads-a-gogo (https://github.com/xk/node-threads-a-gogo/) to be more in line with the browser implementation. Thanks for your feedback
You're the deck of cards animator. Good job on that.
Yeah, I've made similar with Flash as well, also like 10 years ago :D
I started to write a lengthy reply, but it's not worth it. You have your opinion, and I have mine. I get on with writing PHP just fine, and so do many others. Our computers don't explode due to us writing PHP code. We don't spend all day banging our heads against the desk due to some fiercely engineered lolphp issue slapped together in an effort to fuck shit up. PHP doesn't do things how you want. OK. That doesn't stop the rest of us getting on with it - happily and without problem. Have a consolation upvote.
&gt; JSON.stringify([...'abc']) ... is ES6 syntax, yeah? I had no idea it works in the chrome console already. :] That will be nice for quick tests.
lol I must've confused this with another thread
That looks like an array of objects.
The factorial of 5 (or 5!) is 1 \* 2 \* 3 \* 4 \* 5 = 120. "x *= y" is short for "x = x * y". And, well, that's the thing you have to do in a loop. Unrolled, it looks like this: var result = 1; result *= 2; result *= 3; result *= 4; result *= 5; And then "result" would be 120.
Probably what the book is intending is for your index to your loop to start at a number and keep decrementing until the index is 1. since it says "...given number down to 1." In a for loop: for (....; ....; index--) the third clause in the parenthesis is where you tell what your index is supposed to do. If you say index++ it will increment and if you say index-- it will decrement each time you pass through the loop.
Would love a night mode for this. (yes, I know I can fork it.)
easier file copying =&gt; gulp vs webpack, platform independent =&gt; gulp vs shell script
You asked me how a build-tool was relevant in a discussion about build-tools. I do not think I am the one with a chip on my shoulder. Other than that, I agree with you. The latest make for windows was released back in 2006. I do not use Windows so I have not really experienced not having make at my disposal.
But is it really that bad to reinvent the wheel a few times? Technically C can do everything that JS can, but that doesn't mean that we should just give up on JS and spend all of our time improving C. Debian and REHL are at about feature parity, but we shouldn't just give up on one and put all our eggs in another basket. While technically make can do everything that gulp can, it's much easier to stay in JS when working with JS. With gulp i can compile all my sass and hotreload a site with like 3 lines of code. Gulp has tons of ready made plugins for it, and it's using the same language i'm developing with which makes it less of a context switch to go from coding to modifying a build file. IMO make is ugly, clunky, and difficult to work with. So much so that there are tons of systems made to generate makefiles instead of having to write them yourself. Making a new build system in JS for JS by JS devs can mean that it can be faster, easier, and more intuitive to use for JS developers. 
thanks for advice, i was having this issue too
Such a great idea! Have to do it ;)
Is this the modern day fireplace video for the living room TV?
You can call it in javascript like this: var result = fact(3); This would make your result variable equal to 6, which is 3!. The same result is achieved by the other function as well.
Something like that :D
Gulp is dope. I have no reason not to use it. It makes my life easier and that's cool.
It wouldn't be faster unless they went all the way with static typing. As in 'var a = {}; a.b = 6' would not compile. Oh yeah, it would also have to be complied. Personally I much prefer the idea of WebAssembly.
I mean faster than now. And yeah "var a : number = {}; a.b = 6" should generate an error in JIT stage. &gt; Oh yeah, it would also have to be complied. V8 already does JIT compilation on the fly.
The order of my YDKJS books that I recommend reading (if reading most/all of them) is: * Up &amp; Going * Scope &amp; Closures * this &amp; Object Prototypes * Types &amp; Grammar * Async &amp; Performance * ES6 &amp; Beyond
Wonderful. Thanks for the reply. 
This use of `const` is giving me heart palpitations.
TypeScript really isn't anything like C#. About the only similarity are generics and the C-style syntax.
But do I get all the features of browsersync? I personally like opening my projects on my main computer with few mobile devices and having them all refresh together.
That makes no sense by itself. What library?
Ah yes, I see. I'm sure there is something you could do around that. Maybe with another observable that `await`s that one?
 function start(){ var sum = 0; while(true){ sum++; var diceOne = Randomizer.nextInt(1,6); var diceTwo = Randomizer.nextInt(1,6); println(diceOne + "," + diceTwo); if (diceOne == 1 &amp;&amp; diceTwo == 1){ break; } } println("It took you " + sum + " rolls to get snake eyes."); }
I haven't looked at the code yet - however on the visualization side (and this is just an opinion) I think there is too much real estate given to the brain image. I see what you are trying to do by matching up the node locations with regions of the brain - but I think it ends up wasting space and making it harder to read.
I would also add that if you're building with something like Babel, then the polyfill means you won't have anything to worry about anyway.
true, but it is supported in node 4 which is still javascript =D
Thanks! I was actually thinking about making a voting app last night.
I agree in the example you can just use a foreach loop. I wrote Permutest with many more variables in mind. So many separate variables that loops would be very deeply nested. Permutest (hopefully) makes those cases easier to reason about.
Mostly, it's sloppy and you shouldn't do it. In this case, it could be to show that the anonymous function is an event handler, which gets passed the event when it's called of course. It's possible the code in the function used the event but was changed and no longer does. Anyway, yep, it's sloppy and you shouldn't do it. Your linter* will catch this so that you know you can delete the argument safely. Don't leave little poops lying around in your code, remove unused variables and arguments. \* Use a linter. if you don't know which one to use try eslint
Hmm, I can't say the same. This one is silly, but actually quite well-rehearsed, and the short bit I watched did bring up an important technical matter (browser sampling rate in a drawing app) I've literally watched talks like "I hooked my doorbell up to an Arduino!" and "I bought a kit and now my hat lights up anytime someone says my name on twitter!"
I should also mention that "sane mode" that google is suggesting for JavaScript would prevent adding properties to object once it is defined. So it can be optimized neatly.
Well if JavaScript becomes a truly statically typed language and also has its quirks removed then it isn't really JS anymore is it. I mean some of the most iconic aspects of JS is the fact that it is one of the most loosely typed language ever made, and the huge amount of really fucking shitty quirks. At which point I probably wouldn't be that against it. But a JS programming language that is remotely similar to what we have now is something I will only touch when required to.
Could make a bundle that loads async?
Interesting, but is it ever the case that you've wanted to use a library that requires jQuery and thought 'nah, I'll substitute this _other_ module that provides `$` instead!'
I also disagree. This was really informative and fun, IMO. :)
He is talking about using `const` even though you are changing the variable in the loop. That code won't work in ES6. It throws an error in Firefox. It only works for you because babel changes `const` -&gt; `var` for you
No, just plain vanillajs.
Could be that it was used, and the code was taken out, could be auto formatting, could be they -might- use it in the future, could be left there so that other developers don't have to add it in when they need it. A lot of reasons, but it's really not bad programming or bad behaviour to have it in there if you're not using it. What you're looking at is the event reference, see [my comment on stackoverflow] (http://stackoverflow.com/questions/27769267/understanding-javascript-syntax/27769496#27769496) for a bit more: &gt; This is actually an object that is accessible within that function. Usually it is called the event reference. The object holds details, functions, variables, etc., about the function and event, allowing you to handle the event and access properties of it. You are able to access it once you set a name to the first argument of the handler, that is `function(event) { }`
Note that this is a self-submission. Presumably the author is being facetious. Anyway, good talk /u/cube-drone!
Facebook is built in react, AFAIK
Why do I have to register? 
very impress visualization. one question is there a reason you are updating the URL? because it complete blows up my browser history and back button!!!
I'm not really sure why people go to these conferences, when the speakers are just talking about the same stuff found in blog posts all over the net.
In Utils, make all methods static 'static randomNumber() {}. You can thereafter use them with 'Utils.randomNumber()'.
It's to document that it's available. Even if not used now, you never know what people will need in the future.
I'm afraid you're wrong. `for` creates a new scope, and in that scope, all of the variables are constants (btw, [ES6 allows `const` in `for` loops](http://www.ecma-international.org/ecma-262/6.0/#sec-for-in-and-for-of-statements)). If you dont believe me: const fs = []; for (const firstName of ['Chris', 'Kevin']) { fs.push(function () { console.log(firstName); }); } for (const f of fs) { f(); // will print Chris and Kevin } If you use `var` (in the first loop), which is function-scoped, `Kevin` will be printed twice. If you try to reassing a `const` variable in Babel, it won't even compile the code.
This meandering blog post shows he doesn't know his history which would have answered the question he started out with.
Hope no-one minds me posting my own library here, but I've just released v1.0 of my particle engine for Three.js! Finally. The project's been around for a while now (a few years), but when a minor change happened in Three.js r72, I had to rewrite a lot of it. Figured I'd add some new features while I was doing it. I need to make a lot more examples, as there's a lot that it can do that I'm not explicitly showing, but there's some (hopefully) decent documentation, and I'm planning on writing some tutorials in the very near future. Repo is [here](https://github.com/squarefeet/ShaderParticleEngine) :)
Hi /u/catstanza aka. /u/ryanchenkie, Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just ` auth0.com` and `ryanchenkie.com`. Thanks for your consideration! /u/catstanza|count|% :-|-:|-: [auth0.com](/search?q=%28and+site%3A%27auth0.com%27+author%3A%27catstanza%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|10|59% [ryanchenkie.com](/search?q=%28and+site%3A%27ryanchenkie.com%27+author%3A%27catstanza%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|4|24% /u/ryanchenkie|count|% :-|-:|-: [auth0.com](/search?q=%28and+site%3A%27auth0.com%27+author%3A%27ryanchenkie%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|14|78%
&gt; I don't care if my code is sane or insane, as long as it leads to fast, clean code. :P I'll considering change the title next version :), maybe something like "Fastest async library" or something. This title comes out when i'm try to read bluebird's code, i can't keep tell myself this guy is insane(no offense, he knows what he is doing) because he did a lot of v8 optimization, and the code become obscured to read. &gt; It's very similar to promises That's only true on the surface API, a Promise is a proxy to a value in future, while Action is just a wrapper of a function waiting for a callback: var Action = function(go){this._go = go;} So an Action can be retried, cancelled, or whatever you want to be, you can read more about the difference on project's [wiki](https://github.com/winterland1989/Action.js/wiki), questions are welcome! &gt; except the chaining is more explicit. I guess you're looking for something like async-await, right? Action provides Action.co to work with generators, you can read more about it [here](https://github.com/winterland1989/Action.js/wiki/API-document#actioncogenfn--generatorfunction).
Every time I read anything about "generics" being added to JS I have to snicker and then just go WTF?
No. I'm using it for an internal app, only running on chrome. It's far from complete (no default params, or import/export for instance), but what is there is pretty good - fat arrow, set, map, weakmap, generators, single var key/vars, promises, even class if you're into that.
Requesting the image is by itself a request. The only difference being that asynchronous loading could be non blocking 
And Cheerio is only 4kb with many more useful utility methods. Why are you so against using an extra 4kb? Why do you feel the need to create your own library? I guarantee it isn't tested as well as the ubiquitous solutions. I think you don't have anything useful to contribute other than trying to feel superior about your "Not invented here" syndrome.
Yep, functions are perfectly fine. This isn't like Java where everything *must* be inside some class. To stay organized when the codebase grows, you simply put them into modules.
Read the chapter about functions and loops again. You claimed you were confused by the question, but it appears that you don't know how either language feature works. You should be able to write a loop which outputs the numbers from A to B. You should be able to write a function which accepts some arguments and which returns a value. You should know how to call this function. Try a different (online) book if you have trouble understanding the one you got. /r/LearnJavascript
Looks alright. Just remember that ES6 doesn't give real classes like you'd find in other class-based languages like C++ or Java. The `class` keyword you're using in ES6 is syntactical sugar on top of Javascript's existing prototypal object model, albeit with a standardised constructor pattern. Be sure to try out [other OOP patterns](http://addyosmani.com/resources/essentialjsdesignpatterns/book/) as you learn.
;)
JavaScript: the good parts. 
libraries, not frameworks.
If you build an application to any degree of complexity, you will end up having to build your own framework to keep things organized.
Check if the demo page looks good on mobile / smaller screens. If it doesn't, you can spend time on making it responsive. There can be filtering options below the search input box, but not sure if you can finish in a short time. Like seeing only devices available on AT&amp;T or that run Android 3.0 and above etc. Not sure if the tutorial's author got any inspiration from gsmarena but you should at least have a look http://www.gsmarena.com/motorola_moto_x_style-7229.php
Actually, you can write it this way: button.onclick = event =&gt; event.currentTarget.disabled = true; `event.currentTarget` is equivalent to `this`. (And, BTW, `addEventListener` is better :–)
Node gardens sure are mesmerizing..
&gt; Math.floor((max - min) * Math.random()) + min Well spotted.
Nice, I didn't know this. I'm unsure why this comment got down voted, as it is a handy solution.
I totally get you, I am often in the same boat as you. It is my impression that frontend technologies are very fruitful market at the moment, and there is a lot of competition about how to improve current frontend stack. This constant competition and constant claims that "one is better than the other" can create an illusion that the "other" is bad. Making a new thing, better thing, doesn't mean that the old thing is bad and broken. It still works. People and companies use it, successfully. Otherwise technology would die down. Look at Dart for example, and then again, look at Angular 1. Dart is dead, and Angular 1 still lives, besides the fact that it's broken and obsolete. So in the end it boils down to not what's the best stack in the world at this very moment, but what stack will suit your team and your project for the next couple of years. And this decision needs to be yours, and not by some big names in the industry. Don't be swayed by opinions, blogs and tweets. Take what YOU think is the best choice, and what YOUR team will be comfortable with. And if possible, make it a team decision. Hell, I know a lot of teams that are still choosing Angular 1 to start with, because it's been around for a while, devs are comfortable with it and there is a strong community. They'll have to migrate sooner or later, but they will prototype faster. TLDR; Pick something that fits the project needs, that dev team is comfortable with and stick with it. Hope this helps. EDIT: Just want to add, that with this ongoing competition on the frontend field, one cannot afford to wait and see who wins. There will always be something newer, something better than what you chose, but the reasons for your choice are still valid. That doesn't change.
true
Thanks for the encouragement! 
github link: https://github.com/andrei-cacio/ironwing if anyone wants to take a look. FWI the readme is a bit outdate, it now has some new cool features. I will update it one of these days.
Brilliant talk, Curtis!
I like the cut of your jib:-) In all seriousness, I would go further than just JavaScript. There is a bloody explosion of languages, libraries and methodologies at the moment. For the first time in my career I'm having trouble keeping up. In terms of keeping project success (and keeping a sane maintenance environment), I'm in a bit of a three year cycle - pick a few of the winners and stick with them. That being said, it's hard to sometimes contain the enthusiasm of new hires who talk of Angular, React, Backbone or whatever the next framework is.
`this.canvas = document.getElementById('canvas');` This breaks the encapsulation of your class. You should pass a Canvas element to the constructor instead of relying on some external state. Now your Canvas class is effectively a singleton, because you can't really have several instances of the class since they would all use the same canvas element (and conflict with each other).
Is it true that you cannot argue with Eric Elliott, because he will just block you or delete your comments if you don't agree with him? I can't remember where I read that accusation.
Its million, a lot of people dont use M because that is the roman numeral for 1000 and was used as 1000 in finance for so long. MM is used because it's a thousand thousand (1 million)
I feel a lot of these things myself. But imho there is one thing to remember. On the internet it often feels, that most of the people are so much smarter than you are and they know pretty much everything. But if you look closer. Most of the time there is someone knowing a lot in a couple of areas and someone else knows a lot about different areas. In the huge intermingled thing the web is, it feels that everybody knows about everything but THIS IS NOT TRUE. Honestly most of us are doing only educated guesses. The more you know the more educated these guesses are, but still...
Did you mean to switch to Portuguese there? Haha, I only ask because sometimes my girlfriend randomly switches between languages too, but by accident. 
Simple. Because our employers pay for it and it gets us out of work for a week.
A lot of those people are complete fakes who copy paste code, including whole repositories, and claim them as their own. They rewrite other people's articles and whole books only slightly changing the text, order, and examples. They talk out of their asses. Most are that person at work too busy arguing about semicolons to do real work, some of them are unemployed jackasses, but some are predators that charge money to give talks and are actively destroying the JavaScript community. 
using 'innerHTML' does not lead to nice performance. I know, even xxx*.style.*xxx shouldnt be used either
great job!!!
The OP speaks Portuguese. The portuguese edit in my post was to be a hint for him. (But if this is against the rules, I'll edit my post again) Accident is when I don't use ";" in Javascript (too much Python in last weeks, lol) =)
Nightmode added! (click the moon on top left corner) ;) https://nodegarden.js.org
Monopoly Millions.
Because it isn't necessary and is inflexible. This isn't Java. Just use functions.
I think the first thing to realize is that the front end is absolute madness right now. There are so many different libraries and frameworks it is absolutely *impossible* to keep up. Put on top of that the build tooling which is still relatively new to the front end and, like everything else, in constant flux, and it is easy to become over whelmed with options. And forget opinions because as you noticed they tend to shift. To me the front end is a "what's trending" sort of industry right now. It isn't mature (comparably to server-side languages and frameworks). I blame that partially on the industry itself. I've read a lot of job postings that want experience building/maintaining a framework, which just perpetuates people to make hobby frameworks. And I think all of that is extremely frustrating to a lot of people. What really needs to happen is for people to stop forking other people's projects just to tweak it every so slightly and then re-releasing it under a different name. But that is another rant all together. So to answer your question, I don't think you can possibly keep up with front-end tech, at least not with any depth of knowledge, while also leading a team. What we do is we allow team members to evaluate new tech and then try and sell the team on why it is better than what we are using right now. And some of the most important questions we always have are similar to what others have mentioned (what is support like, how mature is the project, who else is using it). I would say you should make the basis of switching out any piece of technology on a business need. Does the new tech do something we need that our current tech does not do? Does the new tech save us *significant* time (i.e. is it worth the additional time to get the team up to speed in the new tech) in spin up or code management? If we decide to swap old tech out in an existing project, what is our commitment (time/effort) of doing that replacement? If and only if we've met sufficient reason and the team is comfortable in making the switch do we actually make the switch. I don't think there is one good answer to this question really. It is all dependent on the team, the project, and the business.
Thanks for the replying, this makes sense.
Yup, exactly this. There is not the one right way. Choose whatever works for you. And there will always be people that think your choice is stupid and everything would be better if you'd just have chosen a different framework. Maybe that's true. Probably not.
I think at this point, even if his book does have some good points about clean organization, there's too much noise to sift through. It's like 6 or 7 years old now and javascript is moving lightning speed relative to other major languages.
Have a look at : https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/Using_geolocation For privacy reasons the user will be prompted to agree that your code can get their long/lat. So you'll need to make the API call inside the success function using the users long/lat: var latitude = position.coords.latitude; var longitude = position.coords.longitude; You can then make an AJAX call to http://api.walmartlabs.com/v1/stores?apiKey={apiKey}&amp;lon=" + longitude +"&amp;lat=" + latitude +"&amp;format=json
It would: Create 5 buttons Which are named 'Button 1', 'Button 2'.. up to 'Button 5'. Which when clicked will output their number in the console once. The follow up question would do exactly the same thing. I agree with other user. Use jsbin or codepen, or at least a pastebin to share your code in future :) 
Permutest isn't on the same level as QuickCheck. QuickCheck, in the Haskell environment, can rely on the type system for many guarantees to generate test data. Permutest just takes multiple enumerable sets and runs one test for each possible combination of each set's values with all the other values of other lists. Tests need to provide their own test data. I haven't looked to deeply into QuickCheck, but those are the immediate differences I see.
&gt; will output their number Nope. They will output the same number 5 because the click handler has no variable i of its own, they all access to the same "global" i which is 5 when the loop stops.
I want to be less dependent on Google Sheets, as it's not exactly a very safe place to keep data. I'll take a look into Node.js / node-spreadsheets Thanks! 
To be honest, when I got hired as a full stack guy and was put on back-end node work, my desire and ability to keep up with the front end churn has been steadily decreasing. 
You can click "save" instead, FYI. Or, you know, just star the repo.
&gt; Accident is when I don't use ";" in Javascript (too much Python in last weeks, lol) Then don't use semicolons. [It's](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding) [okay](http://inimino.org/~inimino/blog/javascript_semicolons), [really](https://www.youtube.com/watch?v=gsfbh17Ax9I).
Javascript is Turing complete, in theory you should be able to make any game in it that can be written in another programming language.
I'm in the same situation. Although we started about a year ago. At the time, we made the front end stack as "new" as possible. (React, flux, sass, websockets, webpack, etc). Yes, all of these will be "old"...really soon haha. However I stick with the idea of the product lifecycle. The aim is to get about 5 years out of this, depending on the money of course, it could be 8... Since everything is now a 'module', and views are independent of the data model, I suspect this will be much easier to adapt into a new front end. In the end, trying to keep up month to month will kill you. Don't do it. Productivity will be shit and you'll never actually ship code...
I mean, you could just try it both ways and see what works.
I have not. Will try.
Use `let` for the counter and it works as you'd probably prefer it to work. Short demo + rough explanation: https://www.reddit.com/r/javascript/comments/3pn5y3/arrow_this_clearing_up_how_es6_arrows_handle_this/cw86s96
This is a really neat game, very artistic and fun, but I do have some exaggerated critiques below, so don't take this as shitting on your great work. * I like the fact that you have the artistic talent, but not everything needs to be hand sketched. The Audio mute option takes up a lot of space and is a little confusing. It's fine, but could be better/easier. * It's a little confusing that the character can disappear on the left and reappear on the right, but the floating platforms cannot. * What do the skulls and other collectibles do? As A person who plays a lot of games I instinctively want to collect these, but why do I want these? Why would I risk game over to go for one? Is there some way to indicate that these add to your score or give you some benefit later on? People like immediate feedback so right as I collect one, delight me with some animation or feedback of some kind. * Also this game has people jumping on coffins. If you make it you move on, but missing the coffin could be game over. It's a very risky action in my mind. And it's not very clear where exactly my feet have to land in order to have made it vs missed it. The more you can clarify the exact height above the platform I need to be at to successfully land on top of it, the better. You may think that ankle high is good because it gives the user some room for error, but really the user accounts for this and makes roughly ankle high their new target when jumping. But if you just made the skeleton jump slightly higher and then they had to line up to the pixel with the bottom of their feet, that would actually add more certainty and ease the user's mind a little making it more fun. They would know as they jump whether they will probably make it. Again, take this all with a grain of salt. I'm just a user. You made this thing. It's yours and its great in a lot of ways. Also nice timing with Halloween right around the corner.
Because you close over "i", which will be 5 at the time those functions are run. There is only one "i". var x = 'foo'; function print() { console.log(x); } x = 'bar'; print(); // bar That's essentially what you're doing.
My point of view is this: I'm not working at google. I'm not going to compete with these other devs at google. I work for a smaller company. I just have to be better than everyone else that wants to work at this company. If I or the other devs here were good enough to work at google or where ever, we'd be there not here. I'm happy here being mediocre. Now, if you're the supervisor and you're trying to tell your subordinates how things need to be done, you're not doing something right (imho). You've got your minions and you need to delegate to your minions and trust that they know what they're doing rather than trying to make them do it exactly how you want it done. You can't be expected to keep up on everything, so you have to trust your people and take their opinions on technology and their experience into consideration. 90% of the time, when I pick up a new technology, it's something that I'm exposed to on the job... Like if I have to collaborate with another programmer and he uses a tool I've never heard of but think it's neat. I've almost never started using something just because I've read about it.
That's cool. I'm sure this game will do well on this [subreddit](https://www.reddit.com/r/ledootgeneration/)
I wonder what the carbon footprint of that looks like, compared to just reading blog posts.
Do what works for you and YOUR projects. Follow best practices, but do what you can to keep up on what is best for yourself and your team and products best interests. There is *no* way to keep up on all of the best practices. Pick things to specialize in and focus on them. Hire people for your team that have different specialties. &gt; I follow the big names in the industry and see them changing their perspective almost monthly. FYI: Many of these big names are not out there building websites and doing client work. Many of these big names are out there talking, speaking and writing about best practices while not actually using them in a day to day basis. They don't have the perspective you have - they don't deal with clients, colleagues, and managing a team that actually needs to do this work. 
I actually also made collisions now more realistic: https://nodegarden.js.org https://nodegarden.js.org/electrons.html ;)
**TL;DR** - There will always be an explosion of technologies. Develop your own criteria. Try new things only once in a while. Avoid all other noise. Develop an eye for cruft and overly complicated frameworks and avoid those. If they can't evolve, they will abandoned. In general, a technologies success is directly related to it's footprint. If it is too large, it will die. Either way, you have to utilize your own aesthetic. Examples: I decided back in 2004 that I would never learn Flash, as it would not survive the winnowing of plugin technology that I saw coming down the road. It never even made it to mobile. Same with CoffeeScript, TypeScript, Dart, etc. I never bet against VanillaJS(tm) and am just now starting to use ES6 features as Node 4 is here. I love almost everything about ES6: spread, arrow functions, default properties, etc. Frankly, I have resisted ES6 classes, coroutines, yield, Promises, etc. as they're not solving problems I actually have. When async/await show up and become mainstream, I'll try them, but I As Knockout, Backbone, Ember, and Angular each arrived on the scene, I saw them as extremely bulky and overly complicated. I just didn't need them. I was fine sticking with simple jQuery SPAs. Up until React, I haven't seen a particularly meaningful reason to abandon jQuery. Although I'm bullish on React, I'm pretty suspicious about the majority of flux-style libraries. There's a lot of winnowing that needs to happen in this space still before a victor emerges. This same thing happened with build tools and asset delivery. RequireJS didn't pass my gut-level check of actual benefit, so I avoided it. Same with Grunt. Gulp passed the sniff test, so I decided to use it. But literally dozens popped up after this and most of them did not: BrocolliJS, Brunch, etc. I mean just look at this crap: https://gist.github.com/callumacrae/9231589. I've used Webpack to get some benefits of hot-reloading, but I don't like it. It seems more crufty and complicated than gulp. Again, with DB, after Mongoose hit version 3, I've never even entertained the idea of exploring CouchDB, RethinkDB, LevelDB. The value proposition of learning a completely new DB is usually not attractive. 
&gt; Yeah, tone is unnecessarily harsh Its probably because I grew up in the military. It is a different kind of professional culture. Positive confrontations are highly valued and they really like to use their *outside voice* with emotionless absolutes. Tip toeing around the daisies with subtle pleasantries is utterly foreign. Empathy is extremely valued, but those guys work too much to waste time with sympathy where sympathy is considered a child's toy. There identifying and caring for the needs of your peers is essential, but empty kindness just isn't valued. In that kind of culture if you are going to be kind then absolutely mean it and follow up on it or don't even bother.
Not 'Any' game.
Here's the solution that I worked out: http://jsfiddle.net/Paceaux/6qo6tuhy/ I extended the Math object with a simple function to tell me if a number was "squarerootable". ¿probably not good? I decided to use the table api for creating rows/cells. I think my next thing is to figure out what to do if my list isn't squarerootable.. but I've got an idea of what to do. 
All in all, probably pretty similar.
ok. yeah. I wouldn't have thought to do that. I like it. Thank you! 
Thanks man! Great feedback! ☺ 
FWIW, I'm glad someone is working in this space. Keep it up. 
I don't know that I'd say "most", but you're right about[ cargo-cult](https://en.wikipedia.org/wiki/Cargo_cult_programming) programmers. Back in the early 00s I worked on a video game. The programmer was off-shore and was rarely available, never fixed bugs, etc. As soon as Quake 1 was open sourced, you can bet we got all kinds up engine updates and fixes as well as new features like moving entities like, you know... DOORS. Not too long after that, the company made everyone sign new NDAs and some kind of "hold harmless" doc where the co was protected from individual malfeasance.
Yes, that's much more accurate and succinct than what I wrote. :) 
I should've formulated my question better.. because it was really about, "how do I take a flat array, and populate that data into rows and cells." this is the solution I have: http://jsfiddle.net/Paceaux/6qo6tuhy/ I ended up taking the original "flat" array, and creating a new multidimensional array out of it. And then iterating over the multidimensional array. the question wasn't so much about DOM manipulation as it was a programming question. My challenges are/were: 1. Best that I can figure, I wouldn't be able to do it from a "flat array". I'd have to have an "array of arrays", first 2. with an "array of arrays", the most efficient I can get is by using two loops. So... I think.. really.. my question was, and is, "is there a way that I could take a flat array of N items, and **using only one loop**, populate a table of rows and cells?" 
Eh, the list is missing David Flanagan's *Javascript: The Definitive Guide* [amazon](http://www.amazon.com/JavaScript-Definitive-Guide-Activate-Guides/dp/0596805527). It's over four years old now, and a dry read, but it's the best I've read. Obviously, it doesn't cover ES6, but it's a great, thorough place to start. It's sitting on my desk right now. edit: and, although it isn't free (unlike many of the books on that list), you can grab a used copy for pretty cheap. And uh... I hear there's a dark corner of the internet where you can get pirated books easily. I strongly disagree with such practices, though I do like a thorough preview before I buy.
aka 10 centimeters
…or 0.1 meters. Amazing how that metric system works, isn't it?
Thanks! :D 
[removed]
Thank you for replying. That makes much more sense! What is the point of returning the function update? I though you could just call the function once it's defined.
Definitely go for it, if anything you'll be learning the process of releasing a module! There's a nice free tutorial on egghead, towards the end the author uses some more specific tools but the majority of it is great. Goes over everything you'd need
JS is fine as is. If it works it works. There's plenty of niche ways to do things depending on niche use cases, and they're usually discovered and learned through side projects. I can do a lot of things with jQuery that might *technically* be better done with other libraries, but I'm not going to reinvent the wheel just because something might be slightly better. It's good to have modular code, so that it's easy to adjust different components when there's real benefits without breaking the rest of the system.
Actually, I don't think it's misplaced. He says "We’re going for the trick with returning update functions again." and does the samething inside the score function
It's purely a cultural thing. As a trend, the companies you're referring to hire younger people who missed out on the lessons of the past and are thus doomed to repeat past mistakes. I'm seeing some of the same poor designs coming back accompanied by fancy logos and convention talks. They're all single, jacked up on caffeine, and trying to make a name for themselves amongst others in the same boat. It's a runaway feedback loop out there. TL;DR they're wasting their time, so don't let them waste yours. In general, you don't need to worry about a new framework or technology until it's at least two years old, if not older. Only at that point can you see what direction the community has gone in and if it's worth looking into. Then ask yourself: assuming it quickly loses popularity, will there be maintenance or security concerns in five or ten years? If you're not building something that can last, you're just going to be stuck solving the same "problems". As for specific advice, avoid any framework sponsored mainly by one company - Google, Facebook, whatever. Avoid any framework or technology that locks you into doing it their way or prevents you from migrating to any other system (design for legacy and migration - don't embed your business logic into the technology). And, the one I feel most strongly about, avoid any technology that tries to blend more than one technology (html, css, javascript, etc) into the same file. We learned not to do that the hard way a long time ago with asp/jsp. Not to start a flame war, but just look at something like React and ask yourself if people won't be cursing its name before too long.
Got it, thanks for the greatly detailed reply! I really appreciate it.
When adding more child arrays (e.g. ['m', 'n', 'o']) you were inadvertently creating extra columns as well. In your inner most for loop I changed `ii &lt; arr.length` to `ii &lt; arr[i].length` http://codepen.io/anon/pen/KdQrjO
Fantastic work! Only critique is that it's a bit awkward when edge-switching with the mouse, but I'm not sure there even *is* a solve for that.
Yeah, I have to fix that, things u get used to when developing I guess. 
I tinkered a little and forked your fiddle to here : https://jsfiddle.net/jkwuj980/ Since you're using forEach elsewhere I utilized map and spliced off the list to not have to juggle as much maths. T
Try unheap.com and browse the ui/modals category.
Why did they include a book about creating javascript frameworks? We don't need that.
Hi /u/ironjontan, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
I'm a little confused by your post. You claim you're _en route_ to a $100m buyout, but you're not even sure what technology to choose? So what exactly do you have that's worth $100m? Most of the time, a buyout of that magnitude is done to acquire existing technology and a large userbase.... and by extension, that should imply that the technology decisions have already been made a long time ago. And to answer your over-arching question, the same thing applies: companies get bought for their capabilities and for their userbases. Technology choice underneath of that is almost meaningless. Do the real work of making capabilities and growing user base, and let the guys in the tech department of the next place sort out their complaints about tech stack. (And yes, there will _always_ be complaints.)
Well, the *goal* is to output it all to an HTML table. I was initially hung up on how to go from a flat array and get to cells and rows. The only way *I* could see how to do it was to make a 2D array first. This is the ES6 way, right? 
[Array.from](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from) is from ES6. However, that first line only generates an array which looks like this: ['#00', '#01', ... '#24'] You can use `var` instead of `let` to make it work with ES5 engines. The interesting bit is the "row \* 5 + col" bit which maps the 2D X/Y position to the equivalent position in the 1D array. let a = Array.from({length: 25}, (v, k) =&gt; '#' + (k &lt; 10 ? '0' : '') + k); let html = ''; for(let row = 0; row &lt; 5; row++) { html += '&lt;tr&gt;'; for(let col = 0; col &lt; 5; col++) { html += '&lt;td&gt;' + a[row * 5 + col] + '&lt;/td&gt;'; } html += '&lt;/tr&gt;\n'; } console.log(html); Output: &lt;tr&gt;&lt;td&gt;#00&lt;/td&gt;&lt;td&gt;#01&lt;/td&gt;&lt;td&gt;#02&lt;/td&gt;&lt;td&gt;#03&lt;/td&gt;&lt;td&gt;#04&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;#05&lt;/td&gt;&lt;td&gt;#06&lt;/td&gt;&lt;td&gt;#07&lt;/td&gt;&lt;td&gt;#08&lt;/td&gt;&lt;td&gt;#09&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;#10&lt;/td&gt;&lt;td&gt;#11&lt;/td&gt;&lt;td&gt;#12&lt;/td&gt;&lt;td&gt;#13&lt;/td&gt;&lt;td&gt;#14&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;#15&lt;/td&gt;&lt;td&gt;#16&lt;/td&gt;&lt;td&gt;#17&lt;/td&gt;&lt;td&gt;#18&lt;/td&gt;&lt;td&gt;#19&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;#20&lt;/td&gt;&lt;td&gt;#21&lt;/td&gt;&lt;td&gt;#22&lt;/td&gt;&lt;td&gt;#23&lt;/td&gt;&lt;td&gt;#24&lt;/td&gt;&lt;/tr&gt; Easy, right?
This last part. Reading through OP's post my thought was "this person is intentionally pushing him/her self to keep up to date and learn." The smartest people I know are often not the loud mouths who criticise and prescribe but the ones who always feel there's more they need to learn before they consider themselves "good enough". If you feel uncomfortable, like you're working too hard to keep up with things, it means you're learning. And if you're learning (especially when you're already at the level of OP) you're one of the better devs.
just use ##### ```document.createElement``` ##### with ##### ```document.appendChild``` ##### They are native methods, not like ##### ```innerHTML``` + [string] ##### where [string] will be parsed and afterwards via Setters &amp; Getters (too lazy in javascript) added to DOM. It`s even better to apply ##### ```DocumentFragment``` ##### in your code when a loop is within
 !1 === !false
At the post of mine above yours I got used to ```xxx.style.opacity = 0``` ### I `ve said that I used that scheme like you. ### ```innerHTML``` &lt;-&gt; ```style``` ### both of them are -- as I mentioned before -- lazy cause of setter&amp;getter feature
I would like 1 megamonies, please.
Forgive me if I don't believe your guess.
Programming would be a great job, except for other programmers. Everyone has their way of doing it, and it's the right way as far as they are concerned. We hired a new guy recently, and on the first day he wanted to change our coding style and our stack to his way of doing things. Major red flags. He thinks he knows better, but he's immature and impulsive and has not considered that there's a reason why things are done the way they are.
Meh just do what works and be alert to when things aren't working well, and then change course. I think getting too caught up in trends is just as bad as not following them at all.
This is so awesome, thanks for creating this. I might start a new client project that needs *exactly* this kind of thing.
I saw a [visual representation of this](https://twitter.com/rundavidrun/status/587671657193455616) recently on twitter.
[**@rundavidrun**](https://twitter.com/rundavidrun/) &gt; [2015-04-13 17:40 UTC](https://twitter.com/rundavidrun/status/587671657193455616) &gt; Imposter Syndrome: be honest with yourself about what you know and have accomplished &amp; focus less on the difference. &gt;[[Attached pic]](http://pbs.twimg.com/media/CCfUQh_UsAAXNKv.jpg) [[Imgur rehost]](http://i.imgur.com/jfjmPLC.jpg) ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Your questions should be focused on infastructure, design patterns, and geared towards the problems your company is facing. Are you having trouble with the development process? You need someone who's interested in improving it. Is the development process solid, but deployment an issue? Focus on people interested in that. At a senior level, your job is more than having experience. You're presumably leading other developers, enforcing code reviews, setting the tone for development in your department. Knowledge of your language is of course, very important. You should be asking about their experience and implementation, challenges they've faced in the above areas, specifics on how they overcame them. 
actually, very easy. This was an approach I was hoping to find. I was convinced that there had to be a way to do it without creating a second array. and, lo and behold... there is. 
The use case of *customer has been on the website for 10 minutes and browsed 5 of our products &gt; popup is then triggered "Hey {customer name}, you're eligible for a 10% discount today"* will require some more logic than just a popup. A popular way to to it us using localstorage or cookies to track certain metrics, then lay rules/trigger on those metrics, and personalizations to the content I run a SaaS that helps you do mostly what you're looking to do: OptKit.com. I'd be glad to help answer any tech questions via PM or email
There's literally no reason to use those libraries if all you need is filter 
Not sure what you're really trying to achieve but why not have a browser only bundle and node only bundle?
I may not have done the best job of explaining this. But, yes I think I ultimately need separate bundles for the browser and the node. However, I have a couple questions about making that work well. How can I structure my code to allow for separate bundles? I.E. for my file reading functions should I split them into two files based on environment (utils.files.node.js and utils.files.browser.js) or is there a sensible way to keep them in the same file like they currently exist and still be able to generate distinct bundles? And even if they are separate files how do I use the require/browserify syntax to generate separate builds when many files are shared but a handful are different? And how do people generally setup npm projects that have separate builds. For example a user can currently use my library like so regardless of environment. var myLib = require('my-lib'); myLib.start(input); Would I have this part of the interface work something like this? var myLib = require('my-lib').server; or var myLib = require('my-lib').browser; Or are there better options available? And will the above actually prevent myLib.server from being bundled in a browser app or just prevent it from being executed?
No probs - I've learned a lot from open source stuff so it's my tiny way of giving back :) Do open any issues if you're stuck trying to do something or find any bugs!
I want to give some perspective from a slightly less team based point of view, but I hope it still sheds light. Let your team communicate with you, they too have side projects, do a lot of reading etc. Sometimes if you're curious about what they've found for being a solution to X, Y, or Z you can ask them for input. It's not bad leadership to listen to your team, in fact I think its the other way around, I think its fairly good leadership. I am pretty versatile with the frameworks and libraries I can use because I (most of the time) don't work under someone that dictates those things (Though clients will make requests or supply you with a platform that is already using something you'd rather not use, which you get stuck with). Javascript is beautiful, but its easy to get lost in all the new things that are out for it. Libraries, Frameworks, forks and plugins for each, hell jQuery alone can get nuts if you start investing too much into non-maintained plugins. The best thing in my opinion is to be as flexible as javascript, if a new framework comes out, keep an eye on it, understand what it offers and where it excels, but don't adopt it as gospel right away. The best thing about JS is that it works in so many ways, don't let that become it's bad thing. 
Probably never. I'm more interested in calling it JavaScript once it's not 'the new JavaScript' anymore. For now I only say 6 or 7, 2015, 2016 when it's important which version a particular feature comes from. 
No space between while and condition? Savages.
when the dev is better than the linter.. (╯°□°）╯┻━┻
I'm happy to see the article tell me the thing I want to know most that surprisingly few articles about new web/javascript technologies seem to do: why should I care. Good stuff.
Why?
Forgive me if I don't believe yours.
As someone who's used Bower in the past but now uses npm, can someone explain the advantages of using Bower when using Browserify? You can just use npm to manage your front-end dependencies, and include them with a require(). I suppose the Bower ecosystem has much more front-end packages, but I don't count that as an advantage.
Interesting, will investigate further. 
Php is better than Java??? http://i3.kym-cdn.com/entries/icons/original/000/005/545/OpoQQ.jpg
Yep, at least in the context of web apps. If I have to look at another enterprise ProxySingletonFactoryFacadeBean, I'll kill myself. (Certain popular forms of PHP, i.e. the one where you mix HTML and PHP, are worse, but if you use a framework like Laravel then it's vastly superior to Java for web applications.)
Im using 46.0.2. Those examples work on my chrome too, this may be something im doing wrong. But this next code works on Firefox and not on Chrome: &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://raw.githubusercontent.com/goldfire/howler.js/master/howler.min.js"&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function() { var sound = new Howl({urls: ['c_note.mp3']}); $('#test').click(function(){ sound.play(); }); }); &lt;/script&gt; &lt;body&gt; &lt;p id="test"&gt; CLICK ME! &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; EDIT: sorry for this horrible format, im a reddit noob 
most of these frameworks are target Single Page Applications (SPA) how do we start using it to target CMS systems which rely on multiple pages. Many of which dont have a great API abstraction layer. (also we'd lose all our SEO) 
this!
When you get seasoned as you apparently you are, you can realize and appreciate why ego is the enemy. Id say youre good.
^()&gt;&gt;&gt;/r/ProgrammerHumor
Browserify can use the browser property in package.json. There's a good explanation of it here: https://gist.github.com/defunctzombie/4339901 From the browserify docs: &gt; browser field &gt; &gt; There is a special "browser" field you can set in your package.json on a per-module basis to override file resolution for browser-specific versions of files. &gt; &gt; For example, if you want to have a browser-specific module entry point for your "main" field you can just set the "browser" field to a string: &gt; "browser": "./browser.js" &gt; or you can have overrides on a per-file basis: &gt; "browser": { "fs": "level-fs", "./lib/ops.js": "./browser/opts.js" } &gt; Note that the browser field only applies to files in the local module, and like transforms, it doesn't apply into node_modules directories. Now when and end user required your lib in node they will get the default requires. But when browserifying they will get your internal modules swapped out with their browser compatible counterparts. If you're lib is modular enough most of your code should be able to be shared, making the target specific implementations small and easy to maintain. Note: this is only one of many ways to accomplish this. 
Hint: there's more than one answer. 
As far as I can see there's literally no reason to use bower. NPM or JSPM do the same stuff and a lot more. Maybe there was a benefit at one point?
Are you bringing up Chromes Developer Tools and seeing what it is reporting? Mine is reporting strict MIME type issues with howler.min.js
1.5 for the added effort of making his own tutorial site with registration 
I totally agree. Code interview questions seem bizarre to me: you're asking people questions unrelated to what they'll be doing in an environment different to where they'll be working. You're optimising for people who will jump through hoops, which might work for huge companies, but probably not so much for smaller ones. Above all else, *attitude* feels to be of utmost importance. Sure, with a senior position you expect them to have a lot of experience, so by all means ask them to explain various problems they've come upon in their area of experience. But what you'd really be looking for is that they have enough varied experience to prove that they learn whatever *else* it takes to do the job.
Just like you don't need a shotgun to kill someone. It implies overkill. It was said in an amicable and lighthearted manner. Chill man :) 
Very good! If there is no reference to it within the inner scope, no closure will be formed. And so if you drop into a debugger on line 4, in theory x should be undefined. However, depending on the browser and it's version, that behaviour might change! Which is why I bring it up. It varies by browser and by browser version. 
&gt; at a later point managing a team can relieve a bit of the stress of staying up to date. I'd argue the exact opposite. I've recently had the opportunity to lead a team, and am now 6 months in to leading a team of 7 other front end devs. If I were to not stay current, there is no way I'd be able to apply my years of experience as a heuristic to any of the things my team suggests. Call me a leader or manager or whatever, but I'm there specifically because I can tell when to say yes or no to an idea, tool, or framework (and to remove roadblocks for my team so they can get on with building great things). Not just to let everyone do their own thing because it's the latest and greatest. Having said that, I make it a specific goal of mine to allow everyone the chance to prototype ideas which could have a positive impact. At the very least; they learn something valuable from the failure. Otherwise we'll hopefully continue to improve and adopt best practices as we grow and evolve the team / codebase.
I'm also leading a team of 7 front end devs, but my hiring strategy is the opposite: I'm after great React devs in particular. We already have some folks concentrating on the architecture, etc, others concentrating on our base SASS, all while building the customer facing products. Now I'm specifically after folks who know the tools we use so they will be able to really nail the customer facing side of things, freeing the others to concentrate on getting our architecture, etc, right. I've give as far as organising meetups in my city based on the software / tools we use to be able to meet those good devs (while supporting the community and continuing to grow it).
I can produce at least 3 different behaviours just between Firefox and Chrome, depending on the browser and version. Firefox after 42 has introduced a debug mode whereby it will capture the containing scope whether an explicit closure is formed or not, however it will only do this if the debugger is enabled. Every version of chrome I tried will produce 'x is undefined'. My point in pointing this out was two fold. 1) many of the js developers I asked this of did not know that x 'should' be undefined here, which means that at least some of the people that stumble on this post will learn something about how closures and scoping work. 2) I'm sure even fewer know that the latest version of Firefox will actually form a closure over a containing scope regardless of it is referenced of the debugger is enabled, to aide in debugging. I encountered this myself this week and it was not obvious to a lot of people I talked to, so I hope by pointing it out that at least a few people can understand that if you were using an interactive debugger and you dropped into a similar context and were curious as to why some values from the containing scope in which that function was defined were accessible through a closure while others were not (again depending on browser and version), that this simple example might illustrate why. 
1) no, x "shouldn't" be anything. It could be undefined, "not defined", or 11. It's simply not reliable. My point however, is that I don't see the value in a "puzzle" that has nothing to do with code and more to do with the specific implementation of a debugger in an edge case -- why would anyone be trying to inspect an unused variable?
But again, who in their right mind inspects unused variables? Also, I don't know anyone that _actively_ debugs in multiple browsers. You develop in one and do minimal debugging in the other. I open FF dev tools like once/month.
As a geographer turned robot software engineer, that diagram is so apt at describing my feelings and my reality. I've recently graduated from worrying I don't know enough to worrying that people won't notice or trust I know enough. 
No, it won't cause a bug, because if you attempt to access a variable from an enclosing scope it will create a closure as expected. But if you have not accessed a variable from the containing scope, and no closure is formed, and you drop into a debugger in the local scope for debug purposes and attempt to access a variable from the containing scope because you want to know its value at execution time and get 'undefined' but looking at your code think, I have clearly defined it in the enclosing scope, and go 'that's odd, why can't I access it within my local scope?', again, depending on the implementation you may be able to (firefox &gt; 42 with debugger enabled) or may not (firefox &lt; 42, chrome, other browsers I'm sure). It only comes up in 'exploratory debugging', as it did for me. And I only brought it up here because when I asked/pointed it out to several JS developers, they were all stumped that this was the case, so I thought that other JS developers here might learn something about scope and debugging.
&gt; While React provides JSX as a template engine and Glimmer relies on HTMLBars, IDOM is just a simple API for building DOM elements This is a little bit misleading, as JSX is an _optional_ syntax extension that just transpiles down to `React.createElement`, which has a practically identical goal and syntax to IDOM's. At the end he even mentions that they're also building a Babel plugin to support transpiling JSX syntax to IDOM's syntax instead of React's. Which sounds great!
Usually you don't need fancy js libs there at all. What are your trying to do?
&gt; But there is the ever present doubt that future technologies will obsolete present methodologies. Eh.... Maybe. But think about what's currently really driving the buzz in the JS world right now: Stuff like immediate-mode UI (React), one-way data flow (Flux), moving away from plain callbacks as a means of enabling async code (promises, async/await), immutable data, functional programming in general, types (Typescript, Flow), etc. These are new libraries and new frameworks, but they're hardly new technologies; these are mostly ideas invented in the 80s or earlier, which often hit their hayday outside the web in the 90s. There's very, very, **VERY** little new under the sun when it comes to programming, and while I am happy to be a web developer, I'm not going to lie: Our area of programming is a backwater. What you need is a good understanding of programming fundamentals. The fancy stuff is fun, but you know what reallllly matters? Being able to look at a chunk of code, figure out what the critical path is, tinker with it for a few minutes, and eek out a few percent more performance. Code might be ES6, or PHP, or Ruby, or some weird fork of Coffeescript that only six people have ever used; it doesn't matter. &gt; I want to know that when we hand our company off to a more developed enterprise that the engineers will say "this architecture makes sense, and I'm glad to take over and turn it into something greater." Well, if it has a good architecture, then they probably will, but architecture is pretty much orthogonal to the constant churn of new libraries and frameworks. If anything, trying to use the latest cool tech makes having a good underlying architecture harder (I pity all the poor guys with apps written using Mongo that are starting to realise just how much that's going to hurt them). Actually, what they're more likely to think is something like "wow, I can't believe you got to play with all these cool tools that we don't get to use because we have a big legacy codebase. Lucky asshole!", and then they'll go on about their business, because angular versus react is almost meaningless compares to solid architecture versus crappy architecture. And even that pales into insignificance next to "did it actually fulfill customer needs". Which I guess it did, or you wouldn't be being acquired. You know what customers really, **REALLY** don't care about? Whether you used ES6 or ES5 to write the app. They just want to get something done. TL;DR: You're fine. :)
I don't understand the problem - the jsfiddle seems fine...
the jsfiddle isn't my full site just the rainbow code I'm using, and like I said, it works fine as it's meant to, I want to modify it so that when a link is hovered and becomes rainbow, it's subtle and slightly fades in and out of that hover state. I've been using CSS transition states to do this with normal hover states but it doesn't seem to affect a javascript hover state, so I think it might be that it needs to be written into the javascript maybe?
Matreshka is fucking awesome. Keep up the great work dudes.
Can you post a fiddle of the problem?
I find this coding style to be unclear and difficult to reason about and this is just 7 lines of code. What is going on here? const Maybe = val =&gt; ({ val, fmap(f) { if(this.val === null) return Maybe(null); return Maybe(f(this.val)); } }); As opposed to [this](#thing_t1_cwb3btq) (from user [ugwe43to874mf4](https://www.reddit.com/user/ugwe43to874nf4)) which is clearer: function Maybe(value) { return { value: value, fmap: function(applicableFunction) { if (this.value === null) return Maybe( null ); else return Maybe( applicableFunction(this.value) ); } }; } And here ([CodePen](http://codepen.io/SeanJM/pen/yYKLKr)) is an attempt to clear it up even more (I prefer to wrap `false` because it is clearly `falsey`): function Maybe(value) { return { value : value, fmap : function(applicableFunction) { if (value) { return Maybe(applicableFunction(value)); } return Maybe(false); } }; } Compacted version, 8 lines and clear ([CodePen](http://codepen.io/SeanJM/pen/vNRYjZ)): function Maybe(value) { return { value : value, fmap : function(applicableFunction) { return value ? Maybe(applicableFunction(value)) : Maybe(false); } }; } --[ Original unclear version from unclearer version that I wrote which does not work ]-- function Maybe(unknownValue) { return { value : unknownValue, fmap : function(applicableFunction) { if (unknownValue.value) { return Maybe(applicableFunction(unknownValue.value)); } return false; } }; } Is this more clear? I still don't get the practicality of this kind of application. And this recursive function will never end... I get the desire to use the new tools, and I appreciate the article--but I can't reason about the authors code very easily.
If you want a hand, post some code and I might be able to fix it. I'm not going to write it for you though.
Why is this better? This code doesn't do anything. Its just looking for the destroy event and then not running any code because of it? Seems like redundant code to me. And since it keeps listening, wouldn't this (placed globally or at a place where it can often run) result in memory issues?
That guy doesn't know pie charts or areas
It's not the utility of 'Maybe' I have a problem with, it's the way his code is written. I just didn't find it easy to reason about.
Yeah, I was trying to reason about his implementation. What I did was make a maybe that will return two methods, 'pass' and 'fail', I found that to be cleaner to understand that function. Your implementation is definitely clearer to me.
You have to write it like this: function foo({a = 'a', b = 'b'} = {}) { console.log(a, b); } foo(); // a b foo({a: 'A'}); // A b Don't use optional parameters if they aren't optional. "printNameAndAge" clearly needs a name and an age argument. function printNameAndAge(name, age, {pastTense = false} = {}) { console.log(name, age, pastTense); } printNameAndAge('John', 23); // John 23 false printNameAndAge('John', 23, {pastTense: true}); // John 23 true Don't use option objects anymore. Whenever you encounter one of those, you have to check the docs. Option objects are inaccessible to tooling. However, if you use TypeScript, option objects are somewhat nicer than destructuring. You get auto-complete for everything and if you pass a nonexistent property, it's caught by the analyzer. Personally, I think that reusing destructuring for this was a mistake. The syntax is a mess, you can pass whatever you want, and the default values aren't compile-time constants. Optional named arguments with default values is much simpler in other languages.
Unfortunately, this is really for a Greasemonkey script for a dead third-party website, so tagging the desired nodes isn't an option. Besides, this is really for a case where there are multiple cases of the first node, usually paired with the second node, arranged in a table
I think what you point out here may be one of the reasons I don't really like FP in JS. Doing this kind of more "hardcore" FP just doesn't feel right. It becomes kind of boilerplatey because you need so many helpers, so the intent behind the code is somewhat obscured. Now, I've used Haskell, and his examples make sense to me. But that's because I'm familiar with all the concepts. It's a lot better there, because of the language level things you get to support it. Infact, what you propose with a "pass" and a "fail" function is another so-called functor in Haskell, called Either, although in Either's case they are called Left and Right, for fail and pass respectively. Their benefits are probably harder to grasp with a fairly trivial example like in the article, but personally I feel it was a quite good intro nevertheless.
They like lint errors?
I also like &amp;&amp; for quick undefined checking EG: global.someCoolFn &amp;&amp; someCoolFn();
Yeah, after playing expressly with the `Maybe` function you presented, I appreciated it's brevity. It may be better to rename it to `Either(nameString).pass(myPassFunction).fail(myFailFunction)` So in practice to compare that version to an if statement: if (nameString) { myPassFunction(nameString); } else { myFailFunction(nameString); } 
I edited my post. Yeah, I understand that. It's nice. And I almost forgot to thank you, your response helped me understand what the original author was trying to communicate.
I also saw this: condition ? other_code :"" leave these hacks to the minifier, your code is meant to be read by humans
maybe when browsers adopt new standards every year? Future Reddit post: "Browsers finally adopt ES2015 spec in 2018." Though on the flip-side of that - maybe it would add more pressure to browser vendors to adopt standards faster to avoid looking dated.
 ({ x: 3, destroy() { console.log(`${this.x} bottles of beer on the wall`); this.x--; return this.x &gt; 0; }, whatever() { while(this.destroy()); } }).whatever();
Oh, and if anyone has an example of such a thing sitting in an e-mail, I would be so appreciative.
that's not a hack it's a language feature. it has its uses but it shouldn't be used as a substitute of writing the full If statement
they're called ternary conditions https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator
&gt;to meet other people...? You can't do that without flying half way around the world? I'm also talking about local "meet ups" which typically have a similar format. I never see anything they're speaking about that I haven't *already* read in a blog post. I guess the local ones offer free food, and it has marketing/PR potential for the company hosting the event. They have them where I work regularly - and while someone is giving a speech I'm off in a corner reading the exact same thing on a blog post, and then getting back to work. 
Is it just me, or do js developers enjoy making up solutions for non-problems? What is the goal of this?
So, I'm guessing that's a whopping, "don't even try this"?
There are better ways to spend you time. There are a small handful of clients that support Javascript in emails. AFAIK none of them are on mobile. It's bad enough getting basic styles working cross platform...
Yeah, I know, I just can't figure out for the life of me how that space improves things.
You don't do it with function because of its mathematical background. f(x) = mx + b and that jazz. It does improve readability which won't matter for a single line but over a large file like one you can get in Java or C, it is very helpful. Also helps in any scenario when you have something like while(((x + foo) - bar/2) &gt; 7) in a different language. Helps with selection. So while it doesn't make a big difference in Javascript, it's standard practice because of style leaking from other languages. It's habit for many programmers. It's also in like every style guide. No matter what else they disagree on, Google, Airbnb, and jQuery guides all recommend a space after the reserved word and the condition.
Sandi Metz writes about this in POODR, I agree with her and you.
Reminds of numpy, pandas and matplotlib. The only thing I dislike about this codebase is the esoteric variable names and function generation. I would honestly hate contributing back to it. https://github.com/sloisel/numeric/blob/master/src/numeric.js#L1966
The methods `call`, `bind`, and `apply` exist to supplement the relationship between a function and the scope of `this` inside the function at execution time. `this` is undefined in a function, due its execution context, when the function is not aware of the object from which the function is called. When that does happen `this` resolves up the scope chain until it reaches an object in global scope, typically `window` in the browser. The three methods allow a developer to manually define the execution context of a function so that `this` is bound to the context of the stated object. This problem more commonly occurs due to OOP programming patterns and the developers misunderstanding between scope and inheritance. Personally, I couldn't tell you the difference between the three methods without having to look them up because I never use them. I have stated exactly this during job interviews in the past. Never having to use these three methods is blessing that comes from avoiding inheritance in this language and/or only associating inheritance with event execution. These methods are a hacky work around that complicates the understanding of code from a high level. I understand that there are many people who need these because they absolutely cannot imaging programming without inheritance. That is unfortunately the world we live in.
i don't think its a shitty interview question. .apply/.call are used frequent in real life and when making hiring decisions i've found this question to be very helpful in sorting out the most unexperienced candidates. i'll typically ask this in a phone screening/pre-interview setting.
Reactive programming isn't functional programming.
Thank you very much for the response and info. I tested the code you provided with an alert(imgs.length) and it's saying 0 each time. Does this mean it's empty and not working properly? I tried changing a few things with it and couldn't seem to get it to pick up any of the images. also I've been looking around trying to figure out how to combined a &lt;span&gt; tag with the mouseIn/Out but everything I come across is shown with JQuery or is used inLine on the image. This is some more info on what we are trying to achieve. We were told to recreate this image so the picture enlarges as the mouse rolls over (one of them is enlarged in the picture as an example): http://i.imgur.com/a6FNdzB.png This is the only info we were given for the Javascript part 3. In your JavaScript file, write a loop to seek out all the img tags with the newly defined class (hint: querySelectorAll()). 4. For each image, attach a listener on the mouseIn event to create a new &lt;span&gt; with a larger image inside (based on the src attribute). Add another listener on the mouseOut event to hide the newly created &lt;span&gt;.
This is the spooky part of JavaScript for noobs. If you have a JS class, Cat, and you say var tom = new Cat("thomas"); console.log(tom.name); the output will be "thomas" now lets say you have some function that is not part of the Cat class. It is all by itself. function getName() { return this.name; } calling getName() or getName(tom) or getName("thomas") always returns "undefined" because this.name has not been defined inside that function. but calling this: Function.prototype.call(getName, tom); is like saying call getName where "this" is tom. It will return "thomas". Because this = tom and tom.name = "thomas" and this.name = tom.name. because .call(a, b) sets the "this" property of the function a to b. or it sets the "this" property of the function "getName" to tom just for that one function call. so this.name is the same as tom.name for that one function call. 
That's not correct/complete. The context of `this` can be changed with all three methods but that is not their only/main purpose.
OP wasn't asking about the ternary operator. It's just a boolean conjunction that never evaluates the second expression if the first evaluates to a falsy value.
These look fantastic! 
`Math.max.apply(null, array);` is an example of apply that does not change the context at all. As Pytim said, it is incomplete to only talk about changing context with call, apply, and bind. Plus, bind can take arguments as well. This can be used to partially apply a function.
~~Why not?~~ I use apply when doing inheritance. var ParentClass = function(){ this.someProperty = "hello"; } ParentClass.prototype.myFunction = function(x){ this.someProperty = x; } var ChildClass = function(){ ParentClass.apply(this); //run constructor of parent class with child class's context this.someOtherProperty = "goodbye"; } ChildClass.prototype.myFunction = function(x){ ParentClass.prototype.myFunction.apply(this, arguments); alert(this.someProperty); } var childObj = new ChildClass(); childObj.myFunction("test"); alert(childObj.someProperty); 
The Rx Library the article refers to is functional reactive, like most reactive libraries. In fact, functional methods are just about the only way to effectively interact with streams. 
Checkout chart.js they do a great job of canvas data visualization!
&gt; Function.prototype.call(getName, tom); Uh, what. I never ever ever use it this way. What I do instead is getName.call(tom); Thus: function, dot, (call or apply), open parens, this, optional arguments, close parens. It's more fun with function arguments, which would come after the "tom", and which is the difference between `call` and `apply`: `call` takes a list of individual parameters and `apply`one array just like arguments. (Mnemonic: letter count of the words "call" and "apply" is the same as of "list" and "array" respectively). Why would you ever do that? Invoking callbacks, similar to as "event handlers", in your own code, so `this` and `arguments` are how the handler expects them.
&gt; The slowest part of the DOM (which is actually nothing DOM related) then and now is rendering the visual changes to the screen Kinda... what one can infer from what you're saying here is that `paint` is the most expensive step, which is true -- but it's also true that `paint` is triggered by DOM changes. Also, there's the `layout` step, which is really what the DOM is for, and can be expensive depending on the complexity of your tree. The goal of a virtual DOM implementation is to both limit and batch writes so that you pay minimal, defragmented costs to `layout` and `paint`. It's an optimization that comes before the DOM engine is even called, so the speed of the DOM engine isn't really relevant -- any engine would benefit from being used more optimally, just like any speed database would benefit from batching your queries. 
&gt; It's like calling the [].map function, but on my elements instead. What a fucking trainwreck of a language. 
You're trolling, right? ... just because I'm worried you're not: &gt; similar to 'write sorting algorithm from memory' If you're talking about quick sort or something, then sure maybe that's beyond the scope of many frontend jobs. But "a" sorting algorithm is so simple that it should absolutely be intuitive, not even something you need to memorize. If I give you 15 index cards with numbers on them and ask you to order them, would you just stare at me blankly? &gt; you will never use this in reality I use this all. the. time. If you genuinely don't use this then I have trouble believing you've ever worked on a project where JavaScript plays anything more than a very ancillary role. &gt; since it's a dynamic call, it cant be optimized Nonsense. If I'm giving you the benefit of the doubt, yes it can be slower than other ways to invoke a function. This is because you're doing an extra property access and passing an extra argument, nothing to do with "dynamic". It's just as "dynamic" as every function call. &gt; however, there are many 'experts' on the internets who must use every spec feature Actually I've found the JS community to be almost phobic of using uncommon spec features. Even just label a non-loop statement - a feature that's been in every standard and implementation of JavaScript since the beginning - and people start shouting at you. And with good historic reason: JavaScript is a language that was transformed from a toy into a workhorse by a book written on the premise of using only parts of the spec, not all of it. I actually don't think there is any language this statement is *less* true of.
I'll see if this works. I originally disabled the add-on which solved it for a week-ish but updates must have happened or something coz its back bugging me again.
Personally all boils down to a single concept: write code for other people and not for yourself. I'd avoid braces on a if with a single statement just for the reason the code looks eye-candy, faster to read and because in a sea of braces adding additional braces makes my head explode, but for a fact I know that the Developer which will succeeds me will probably fuck up everything.
Java and Objective C so you can plug the gaps in React Native. I thought about saying swift but the transition in Apple's SDK to swift isn't 100% complete. 
Hey Zeoxult, You are right that it is not working properly, but it is tough to see why without seeing it run myself. I do have a guess though. Where do you put your javascript code? Is it in a `&lt;script&gt;&lt;/script&gt;` tag in the `&lt;head&gt;`? Because if that is the case, the code will be executed before the rest of the html is there. This means that your `&lt;img /&gt;` tags do not exist yet, when you try to operate on them. There are two solutions to this. The easiest is to just put/load your javascript at the bottom of the page, right before the `&lt;/body&gt;`. This way you can be pretty sure the elements you need will be available. The slightly better solution is to ask the browser to execute your code after all the elements are there. This works as follows: document.addEventListener("DOMContentLoaded", function(event) { // put your code over here var thumbs = document.querySelectorAll('img.artThumb'); alert("there are " + thumbs.length + " images"); }); To explain what happens, we ask the browser to call the `function(event)` when the `DOMContentLoaded` event happens, in context of the `document` object. This nicely leads us to your next question. For your exercise you will need to create a `&lt;span&gt;` element in javascript when the `mouseIn` event happens in the context of one of the images. So, what you need to do is; retrieve all images, using a loop, for every image call `addEventListener` on that image for both of the events, and create a function to handle both of those events in which you show/hide the span. I hope this helps. If you have any more problems, feel free to message me :) 
Webasm, I feel like speed critical parts of the web are going to use it. Secondly something fun like python for just that reason.
You'd want something like this: $('#my-form').validate({ showErrors: function(errorMap, errorList) { //code that should happen after validation if errors are found goes here }, submitHandler: function(form) { //code that should happen after validation if no errors are found goes here } });
SQL and Python. SQL to help you manage big data better. Yes, there's noSQL databases, but no, they're not as good and fast as SQL yet. If you're dealing with anything bigger than basic CRUD operations, you'll want a SQL database, and you'll want to know SQL. Python to help you deal with any system side scripting easier. Bash is good, but sometimes you need to do a bit higher level stuff that would make anyone except a bash expert cry by trying to attempt.
i mean, node exists...
Clojure and Go
Probably C++ and Python. C++ and Java are the standard "get shit done" languages. They're everywhere, there's tons of courses for them, and every programmer in the professional world knows one of them. I prefer C++ just because it's more forgiving. I never learned the pattern of "public static final street fighter arcade" thing Java has got going on. And Python is great if you want to do computational stuff and hate MATLAB like me. And it has some extremely robust web frameworks like Django. Edit: A sentence I fucked up.
For React specifically, understanding immutability is key. For that, some experience with functional programming would help immensely, but a very simple example of what I meant can be expressed more easily using an [ES6/ES7 code snippet.](https://gist.github.com/novacrazy/5cd14202a18d09a9ae4e#file-example1-jsx) Wherein the `const` variable declaration prevents any modification to those variables (assuming anything actually enforces it, but still). For more complex data structures, you should look into [Immutable.js](https://github.com/facebook/immutable-js), and generally for an "aquire, copy+mutate, assign" pattern to accessing component state. [Example using Immutable.js](https://gist.github.com/novacrazy/5cd14202a18d09a9ae4e#file-example2-jsx) Other than Immutability, getting to understand the declarative nature of React components can be a bit strange. Communicating between declared components is also a bit strange at times. Flux (and its variations), Redux and others can help with organizing data throughout your applications. If you want to research the competition to React in order to understand the problem they are all trying to solve, [Incremental DOM](https://github.com/google/incremental-dom), [Virtual DOM](https://github.com/Matt-Esch/virtual-dom) and React all try to solve building dynamic, fast and responsive DOM structures with little or no actual DOM manipulation if possible. Although React is arguably the most complex of those frameworks, and is the only one that supports component lifecycles and internal state. If you're coming from jQuery, React might be a pretty dramatic shift in thinking. Wherein jQuery you could find a DOM element and modify a value in it, in React you have to re-render a declared element with a new value. Things like styles and attributes must be explicitly declared in the rendering. That's all I can think of right now. If you have any questions, feel feel to ask.
I think you want linear easing. Something like this? http://jsfiddle.net/sq2rvLsp/
Java covers pretty much everything, especially backend, android ... For 3rd i would learn php becase it is easy to pick up but is still a core web language. 
I'm not sure what your skill level is, but if you're at all interested in contributing to a full application rather than an npm module, we're always looking for help with [kibana](https://github.com/elastic/kibana). The best place to find small things to work on would be any issues that are labeled as "low fruit": https://github.com/elastic/kibana/issues?q=is%3Aopen+is%3Aissue+label%3A%22low+fruit%22 To get kibana up and running for development, check out the [CONTRIBUTING.md](https://github.com/elastic/kibana/blob/master/CONTRIBUTING.md).
You're not incorrect, but... &gt; for the use cases for which they are designed Key words here. They're not designed for big data, which is specifically the use case I was talking about. When you're trying to correct people, please don't take their words out of context.
Except 75% of the web runs on *nix/BSD and doesn't use .NET anything.
&gt; when I'm coding in other languages, I always feel like, "Gee, I could be doing this in C!" and there's little reason why I shouldn't. That doesn't really sound like you're writing idiomatic code in those other languages, then. It sounds like you're writing C-in-Language-X, rather than Language X. To paraphrase a very wise man, "if you only eat in McDonalds, the food will taste the same in every country you go to". That doesn't mean there are no differences in national cuisine - it means you're missing the point of *going* to all those other places, because you don't explore the new things about them and (deliberately or subconsciously) only stick to the minuscule subset of options that you already know. If you're writing idiomatic Python, Ruby, Java - even Javascript - (and let alone something like Haskell or a Lisp) then you should *absolutely* be frequently writing stuff that you couldn't easily write in C... otherwise those other languages simply wouldn't exist. If you aren't getting that experience then you aren't using those other languages properly, end of story.
One would have to be something I could use for the backend. In order of my preference that would mean Ruby, Python and PHP. I would use the other half to learn about general algorithms, performance, security, agile practices, project management and people skills. 
Now can you tell me how to do it with es6? Thats pretty useful considering by the time angular 2 comes out it should be here. Also transpilers. 
Ya for sure, depends on the region too. I imagine there are a lot more linux programming jobs out in sillicon valley than there are around here in eastern canada. Java is pretty big around here too.
This is the perfect answer: SQL and Python. 
Have you ever considered rust? It seems like it'd tickle your fancy and its within your scope of systems programming languages with great documentation and guarantees! 
To add some more, NoSQL is awesome for non-homogenous data storage of large document sets. The performance of a relational database will out perform most NoSQL implementations in many, many cases. Key-Value stores are a bit of a different beast because they're so limited in the style of data they hold. The best system's going forward will likely be hybrid combinations of all three types I mentioned with a fourth type we've not fully fleshed out. People use NoSQL as a buzzword and tend to imply they are the future. It's just not the case, regular old RDbMS systems will not go away, and will continue to improve along side these document based systems. 
Aside from the ES6 style, I definitely agree with the functional approach: A function should do one thing and do it well.
Yeah, rust is great! But I wouldn't suggest it as a second language after JS—there are just too many conceptual leaps to overcome.
Haskell and C. Fundamentals are paramount and those two will take you a long way in understanding them.
Which is a shame IMO. Smalltalk was/is a beautiful language.
Lots of enterprise stuff is either java or .NET They're very much sister languages. Hell even their syntax is similar. My preference would be .NET even though there's fewer jobs in it simply because C# is so much nicer than Java.
[removed]
For education: ML and Prolog; for employment: Java and C++. In reality, no reason to limit yourself to two. Languages, particularly their implementations, all have their strengthes and weaknesses. It is hard to learn the tradeoffs if you are limited to two.
In my experience and depending on the device, canvas doesn't play too well with Android/iOS from the browser (if you're doing that). I myself was using Phaser and had to resort to using Cordova and Crosswalk together. Also, here's great service to compiling and testing games that you might want to look into, ( https://www.ludei.com/ ). Last time I used them, it was free and saved me tons of time when testing on Android/iOS. 
This twitter account was created exactly for your needs: https://twitter.com/yourfirstpr
I just made it like that in case you have more complex functionality than should be put into small closure. It's preference, really.
I think if I were to pick three languages, I wouldn't pick JavaScript as one of them because I'd replace it with Ruby. Then probably C++ and Scala or Clojure. Honestly, though, that's not really in terms of employability so much as it is enjoying most of the space. For employability, probably Java/C++ and Go (something old and something new). I'm assuming SQL doesn't count because you could pick up basically what you'd need in a week or two, where with Java/C++ it'll take probably years to get to the point where you can get an actual developer position in it (assuming your only background is web javascript).
I guess my point was that Node is probably only going to pick up more steam in the next five years so you won't have any trouble finding a job writing a Node backend for the web. Meanwhile, if you learn Java and Swift you can then branch out into the mobile space rather than picking two out of the many other server languages available. Of course I don't know if that assumption is actually true. The question is clearly asking for opinions, not answers.
What's the state of wasm? I hope you're right that it starts to take off.
Look into Phonegap
Thanks ill check that link. It does look like something triggered by touch event unrelated to my code tough.
You want to be employable? Java and C++. If you want to do simple websites, PHP or Python. You want to be a better programmer? C. Other people have recommended other things. Those are probably good ones too.
Without pasting the whole article: http://www.2ality.com/2015/06/web-assembly.html#first_experiences_in_practice
Woah woah woah - you missed my point that it's not a performance war. IDOM is built for performance, VDOM is built for abstraction. The performance benefits of VDOM relative to ember / angular was surprising and gave developers permission to explore alternatives patterns of development. That accident paved way into insight about architectural patterns possible with an open source ecosystem as massive as npm - which didn't exist when jquery, angular, etc. were initially built. If anybody is using vdom for performance reasons alone I think their confused and I agree with everything you said about the DOM
touch events can fire on drag events too, so it could fire 10x every 1ms... you can try a 'debounce' function, so it only runs once every N ms that looks like this: MaximumMSPerCall = 100 newmousefunc = _.debounce(oldmousefunc, MaximumMSPerCall) try 25ms debounce, its lovely. or simply you can try: * profile each line them and rewrite each line for speed * use only 1 for loop inside a touch event (0 is best) bad: `array.filter(...).map(...).compact(...)` good: `asdf = []; for (i in array) if (x.prop == 2) asdf.push(x.prop*2)` (only 1 loop) * moving you calculations outside of the func that you dont need to calculate each time, ex: good: width = $(window).width() height = $(window).width() function oldmousefunc () { ... } bad: function oldmousefunc () { width = $(window).width() height = $(window).width() ... }
/u/ugwe43to874nf4 has already broken it down, but if you want to do more reading on Functors, here's the relevant chapter of the Mostly Adequate Guide: [Tupperware](https://github.com/MostlyAdequate/mostly-adequate-guide/blob/master/ch8.md)
Depends on what you want to do. If you If you want to dive deeper into building backends, go with Java and SQL. Java is *the* language for building backends and advanced knowledge of SQL and how SQL databases work will benefit your architecture skills. I would advise *against* learning C, or old C++. They are the examples of how not to build programming languages and you will be better off learning modern C++ instead. However, the only things you'll learn from these languages are memory management and the pain of old APIs. Java is definitely the language to use as an example of great API design (especially with the latest date time and filesystem libraries), great documentation and great coding standards. The only thing that I like about C++ that isn't in Java are templates.