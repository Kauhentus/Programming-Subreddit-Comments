You'll get used to arrow functions. Just don't create one-liners of functions returning functions and it's perfectly readable.
You can write your own but maybe he is referring to 'pattern' &lt;input type="text" pattern="\d+\.\d+\.\d+"
Afaik every browser that supports it will prevent you from submiting the form if there are invalid fields, yet Safari will gladly just submit the form. It is submited as a bug, and opened over 7 years ago - https://bugs.webkit.org/show_bug.cgi?id=28649 as it break the spec ( https://html.spec.whatwg.org/#interactively-validate-the-constraints )
Safari has supported extensions since version 5, which I believe was about 6 years ago, roughly the same time Chrome officially launched its support for extensions. I certainly don't defend safari's lack of compliance, that said the WebKit team seem to be heading in the right direction with the Safari tech preview builds they've been putting out recently so I hope to see some improvement. As for the MacOS foundation being shit, not really sure that's true. It's a pretty interface built on a pretty solid BSD unix foundation. What's your issue with it? (Genuinely interested to hear about it if you do have one)
so Sweeeeet
Linking the browser with the os is a monumentally stupid idea.
I don't understand this at all. They don't even allow other web rendering engines in iOS so people on 9.x can experience the web with its latest technologies, it's not at all like the hardware can't support it. This only makes it even harder on devs.
Meh, Mac and iOS users get the sub-par rendering experience they deserve. If there weren't two amazing, open source browser alternatives out there, that would be one thing, but no one should be catering their code to account for one vendor's proprietary, buggy browser.
Then complain to Apple, and show users a warning that they aren't using a standards-compliant browser. That's the only responsible way to deal with the situation.
The way Google finally did it is reasonable—making Webview an independently updatable component. I don't understand why Apple doesn't face the exact same monopoly charges Microsoft did when it integrated IE into Windows. 
&gt; I don't understand why Apple doesn't face the exact same monopoly charges Microsoft did when it integrated IE into Windows. I was wondering this too. Perhaps because iOS is not even close to as dominant as Windows was back then.
And instead, Google gets prosecuted for insisting that its apps get bundled on phones that have the play store. Apps that users can easily ignore in favour of whatever they prefer.
50% of visitors were on ios in my last project (over 10m users). I wouldn't discard it just yet
Safari is faster than Chrome and uses way less memory on Macs. I have no idea why that is but I'm curious...if Safari can get better results than Chrome on Macs by doing things differently then what's the problem? Are you saying that it's tougher for developers to build for Safari? I'm not saying that you're wrong I just don't understand what the issue is...
You don't work in the IT, do you?
Because iOS does not have anything close to a monopoly.
&gt; undetednted for nearly a month primarily in US right before election time. ...huh?
Well, ESR probably not yet supports all ES6 features you need to run this script. Maybe try another browser, if you are able to.
On iOS, Chrome is a shell on top of Safari, so that might be why. Something something walled garden. 
Nope. Unless you count Chrome, which, on iOS, is just a shell around Safari. 
show my how you easily use ssh on your windows, show me how you use gnome as your desktop instead of the ugly windows one, show me how you can use the exact same commands for your server and your desktop. Show me how your system starts 20 programms in 10 seconds without being slugish afterwards. I can come up with stuff that sucks for you but is great for me too. Plus my system is working just fine. I dont have all the issues you just mentioned, because i dont need that stuff. But maybe im just a different person as you are and so my machine works just fine for me and wouldnt for you. Just use whats best for you in your situation man. Im just saying that linux is great, although i know that it has some big probs.
If only people would upgrade to a version of Windows that had a replacement for IE... 
Well find it and tell me when you have it but you are not allowed to send me benchmark programms n stuff.
Can you show your function?
And still can't properly handle fixed positioning; it's been buggy since they first introduced it like 5 versions ago... No excuse.
Yeah, and fortunately the next generation of consumers is smart enough to avoid the Apple hype. http://ped30.com/2016/10/13/apple-munster-teens-iphone/ 
What have they done to deserve it? 
https://gyazo.com/d539eb3a78061ffd5e4cda89dc564507 The showListOfProducts is where I have to dynamically build a table, but before I get to that I want to see if I can even see the contents of a function in a webpage through a html document
It's not a stupid idea if you understand one thing - always follow the money. In this case Apple makes money from the apps, by creating a better browser they would cut into their app revenue. 
The click event is only triggered after a mousedown event and a mouseup event. The mousedown event is triggered whenever you push down the left mouse button, the click event is only triggered after you push it down and then let it back up.
It's all about the money! They make money from apps. If iOS had a better browser, developers might make their apps there instead of in the App Store. Here is a life hint, anytime you wonder why some business or politician or whoever made some sort of apparently non-sensical decision, it will always make sense if you just follow the money. 
Also there is some shifting happening right now with steam and games being playable on linux. Microsoft even starts porting some of their programms to linux, like visual c++. And also vulcan, wayland and flatpack are some great advantages that are coming or already exist for linux which could make a big difference, so i believe that linux wouldnt suck forever for the stuff you just mentioned.
You can't just write an object to the dom like that. You're going to get it's prototype. You could try using JSON.stringify(object) or console.dir(object). &amp;nbsp; You've got other maintainability issues. It's crazy to give each game and category it's own variable. Game19 for example is bad programming. Either create an array literal where you instantiate the objects, or use Array.push. &amp;nbsp; Your function showListOfProducts takes a games argument but you never use it. &amp;nbsp; Your array games is never used or added to. At the moment it's useless. &amp;nbsp; Your categories shouldn't be individual variables but an object with keys that map to the object for the category so you can do categories.01 or categories['01'] instead of naming each category individually. &amp;nbsp; You've got a lot of problems to fix before you consider writing this to the dom. When you do get that far you're look for something like createElement and createTextNode. 
Learn some DOM basics, it's a pretty easy, high-level API and ideal for all your game UI. You'll need to learn it eventually anyway. Rather than using the canvas API directly, take a look at pixi.js which will perform far better and do more for you. Also check out howler.js for audio. ".io game" doesn't mean anything except paying 10x more for a domain than you have to.
isn't my var games = [] being initialized into an array? and with every gamesx in the line under creating the array just adding an object to an array? Thats how I understood it
I bet Netscape Navigator would be super fast too, but if it can't render things properly, then what's the point?
You're close, but what is happening here is that you are creating an array and assigning it to the variable `games` and then you are creating and assigning many games to many different game variables, so that games is still just an empty array: var games = []; var games1 = new game('01', 'cool game') console.log(games) // logs [] console.log(games1) // logs {productId: '01', name: 'cool game'} There isn't a magic naming convention to assign values to an array, you have to do that yourself: var games = []; games[0] = new game('01', 'cool game') games[1] = new game('02', 'another cool game') Check out this Mozilla Developer Network documentation on accessing values in arrays for more information: [Accessing array elements](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Accessing_array_elements). Hope that helps. EDIT: removing var 
Thanks. I didnt want to ul the whole load. How can I extract the real text that you describe in your reply though?
And Chrome for iOS is not open source.
ok :/
Machine code supports conditional jumps. If some register is zero (or not zero), jump to some other memory location and continue there. That's basically how these statements work under the hood.
&gt; [I] really want to start developing games with html5 canvas Try Phaser (which also uses Pixi, by the way) with TypeScript. Phaser is shipped with type definitions. You get much better tooling if you use TS. However, you can still benefit from those type definitions when using JS if your editor supports d.ts files. VS Code and WebStorm do this, for example. You just have to tell them to load those d.ts files and they'll become a lot more knowledgeable about those libraries.
Why do we support a browser that does not support the Web? It doesn't make sense, if shit doesn't work on IE, its users should realize that it is a shitty software that doesn't work and move on to another browser. I think we should build software for the web, and not for specific browsers, the browser is just a means to access the web, and it needs to conform to the Web Standards in order to do so. If it doesn't, well then it just isn't a browser.
Here's what the A-Frame community did this week [A Week of A-Frame 30](https://aframe.io/blog/awoa-30/).
Hi /u/Markthethomas, this post was removed for 2 reasons: * Announcing that you're writing a book has very little (if any) value for /r/javascript * Trying to sell said book is strictly prohibited on /r/javascript Please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). Additionally, you are posting from a single source (`ifelse.io`) more than we're comfortable with. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [ifelse.io](/search?q=%28and+site%3A%27ifelse.io%27+author%3A%27Markthethomas%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|8|62%
[link to game](https://isyn.github.io/doors_game/game.html) [link to github](https://github.com/iSyn/doors_game) I made a little puzzle game with an added bonus at the end! This was my first project in my web development course and im extremely happy with it. I made a separate post a few days ago but i still want to show it off a bit!
Careful of falling into the new IE trap (aka Chrome) as a result though, it always annoys me to run into non-toy web apps that refuse to run in Firefox or Edge.
Yarn "why" is a pretty impressive feature. I guess people at fb wanted to get rid of cyclic dependencies issues that you may get with npm .
Apple allows alternate rendering engines, what they don't allow is alternate JavaScript VM's so if you write your own engine you are stuck without scripting (see: Opera Mini).
Yes? And what about web views?
Haven't tried in iOS 10, but in 9 you can't even specify the height of an &lt;iframe&gt; for god's sake.
I've worked on two of my projects today: 1) Adding unit tests to [NanoTunes](https://github.com/jamesseanwright/nanotunes), a lightweight music schema with an [OscillatorNode](https://developer.mozilla.org/en-US/docs/Web/API/OscillatorNode)-based implementation 2) Starting writing a [binary search-driven number guessing game](https://github.com/jamesseanwright/guess-my-number). It's a vanilla JS frontend but uses Redux for state management. The basic bindings are working but it isn't functionally complete yet; hopefully it'll be there in the new few days. It uses [Rollup](http://rollupjs.org/) for bundling; this is the first time I've used it and so far think it's great.
There shouldn't be a "var" at the beginning of the last 2 lines.
Holy hell.
Well actually, I am thankful for the charges because otherwise explorer.exe would really be iexplorer.exe. Thank fucking god that did not happen.
[removed]
Chrome has a nifty tool for printing objects. console.dir(object);
There are web views, which are effectively just browsers that you can embed into a native application (this is what Reddit apps typically do when you click a link). Web views are not an application, but are part of the OS. They can still do better; for example, Android's web view is a separate component from the OS. But for now, it still makes sense to say "iOS10 supports ES6". 
Android Marshmallow and up use the Chrome browser's rendering engine for webview. The Android browser is 6 weeks behind desktop Chrome. On Lollipop it uses a standalone WebView app which is based on Chromium, updated every six weeks. Below that it was embedded in the system and not able to update.
Actually it's... hmm it all checks out. As you were. 
I'm curious. Why would you use TS over Flow?
https://addons.mozilla.org/en-US/firefox/addon/greasemonkey/
We have bash on Windows. It's pretty easy to ssh. Exactly the same as Linux actually.
That is the fault of Mozilla and MS. They should be shipping at par, but they aren't.
But my 7!
Oh I see. I'd recommend looking into flow because there are some [differences that make flow a more-than viable alternative without that much of a change in syntax](http://djcordhose.github.io/flow-vs-typescript/flow-typescript-2.html#/) :) Also, if you are wary about Flow being used in production, check out the [Yarn codebase](https://github.com/yarnpkg/yarn/tree/master/src).(I hope you've heard of Yarn by now!) It is written completely with Flow and transpired by Babel. It's very pretty code written by some badass engineers at Facebook. 
Or people could stop using features that are bleeding edge and not standardized yet. I get that we all want the new shiny to make our lives easier, but if it can't be polyfilled it's always better to wait for it to be in a complete and well implemented state before using it.
I'm actually thinking about selling my iPad because so many website just don't work at all.
It's a balancing act of development ease and efficiency, value to the user, and number of users affected. If a certain platform feature is going to substantially reduce work stress in my life and those within my team, but it hurts UX on Firefox -- well, sorry dumbass Firefox users. Switch to Chrome.
Never heard of Respo before. Looks nice.
There is also local storage in the browser. Similar to cookies but more space, etc. Here is some info but there may be better discussions around. https://www.smashingmagazine.com/2010/10/local-storage-and-how-to-use-it/
I think it was a product decision when they were trying to build a touch browser in a mouse-driven ecosystem. They were afraid nested touch scrollviews would suck for users, so they bent the rules to avoid them.
STP is very nice in my experience too. Have struggled with some long running issues in vanilla Safari though that STP fixed long before. Frustrating.
Nested touch scrollviews definitely *do* suck for users.
For a subreddit that should be promoting compatible web standards you seem awfully anxious for Chrome to become the next IE. The market stagnates when one browser has a virtual monopoly, it happened once and it will happen again if everyone gets forced to use chrome by developers that care more about having bleeding edge features than writing compatible software.
My perspective is fueled less by the supremacy of Chrome and more focused on the desire for users to choose agents with the very best possible Web Platform feature support. With measured apathy for those who do not.
Wasn't this proposal killed?
&gt;Maybe some benchmarks behind this statement may help convince people like me http://mathieuancelin.github.io/js-repaint-perfs/redom/index.html js execution time in Chrome is ~2.5x slower than fastest virtual DOM libraries.
Don't yell at me :-(
I moved biddle from alpha status to beta status. It isn't mature enough yet for use in production, but it is ready for people to play around with. I still owe technical documentation... and plan to provide this tomorrow. https://github.com/prettydiff/biddle It is a self-hosted application publisher and package manager
You can't do that.... you could however try injecting js into .html
yes. exactly I want to inject/modify the script so it'll parse out all the bs. someone recommended Firefox addons like Greasemonkey, and one customizable one. It shouldn't require an addon!
I think the confusion is that Object.observe got killed, which is not the same as "Observable."
Here's one: http://pakastin.fi/perf But performance depends on so many things, that's why I'm not comparing to any library. I didn't even say virtual dom would be slow.
I agree with you when talking about non-standard features, but ES6 and ES7 are real standards just like HTML5.1 is standard. It's not unreasonable to expect support for the current standard the way the standard specifies (looking at you Chrome).
Try [Numeric JavaScript](http://www.numericjs.com)
Very true try converting github.com/webpack/Tapable which is the backbone to the entire webpack core. I'm willing try either.
Yeah true, but thats new and it only works on windows 10 64 bit. Plus you have to activate dev mode and then install it. Thats not as easy as it is on my linux. I just press ctrl + alt + t and i am in a terminal where i can use ssh. The ubuntu bash in win 10 is accually a really cool feature i have to say though.
If you wanna learn a little bit about them, I did a livecoding session on Monoids in Javascript: https://www.livecoding.tv/evilsoft/videos/aEWmN-functional-js-monoids
Can you create a "real world" test that will be fair to your library? Right now you show to everyone that your library is good at one use case - reversing lists. Everything else is a bit unfair :)
&gt; Currently, clicking on any content block's header will expand that block, and doubleclicking will collapse it. If you're talking about the 2nd click (to collapse it), that's not "doubleclicking". That's just another normal click; a double-click is clicking twice in under 250ms or so, like you do to open files in Windows. Also, I'm going to give some unsolicited advice for the rest of your script, hope you don't mind! var $content1 = $('#content1').text(); Usually when writing jQuery, you'll want to only use the `$` prefix on your variables if they contain a jQuery object -- in this case, it's not a jQuery object, it's just a `String`. var $content1 = $('#content1').text(); // etc. var $content6 = $('#content6').text(); If you think you need to add a number to the end of the variable, you're probably not using the right datastructure; you should probably be using an array instead, but since you don't use any of these variables in the fiddle, I can't tell how you intend to use them to offer an actual change. $(this).parent().addClass('contentblock'); $(this).parent().siblings().removeClass('hidden'); It's better to not re-run the same selectors (`$(this).parent()`), and instead, save them to a variable. Anyways, here's what I ended up with: https://jsfiddle.net/d3p03ruu/13/ It seems to work the same but with much less code.
Agreed, they're also on my most wanted list.
I need to investigate if it's possible to get raw data out of it..
The reason I tend to use the reorder perf is because that's the thing RE:DOM does (except creating elements). Updating the components is done with native DOM calls and are as fast as can be. So in addition to reordering, another thing to perf would be creating the elements. But basically RE:DOM caches the query and returns a cloned node, so it's also as fast as can be.
Sorry, in my first fiddle I had what I was doing mapped to two different functions (hide on click, show on dblclick). When I figured it out with the code I put in my comment it was just one click and another click. Thanks for the advice! I figured I was doing everything in a round about way; I appreciate knowing what's standard!
https://github.com/localvoid/kivi-dbmonster/blob/master/src/data.ts raw data generation
Ive seen this question come up multiple times and it puzzles me. Its frequency also concerns me. This mythical "community " is invoked and the writer presumes to speak for it using a royal "we" voice. So now before i release open source code, i have to contact anyone who has done something similar and get their blessing and if i dont im a pariah? And what masochist would prefer to submit a PR if they already had a functioning, superior product??? Like, "yeah, i want the project to take 3x as long and deal with the extra bugs. i dont know about this community 
While i understand that it isn't that hard, its still pretty time consuming, especially putting it up on definitelytyped. I can understand why some aren't going to be bothered by sharing their input. And making these .d.ts files for all the dependencies i'm going to use is something i really dislike about typescript right now. I can understand why you need them and why they aren't there (yet), but it still takes up some of your time. And for every change to the original file that you are writing for, you need to update your file as well. Somehow i hope they will figure out a way to make this process easier. Especially for those lesser-used modules/plugins/dependencies
I also think that it is not good that we have to write the .d.ts files manually. I try to create my libraries using TypeScript so the dts files can be auto-generated. I can also generate ES6 files and ES5 files so babel and vanilla users are happy as well. I would recommend everyone to use TypeScript as their base language so it is easier to proved support to all the other use cases. Microsoft tis working on https://github.com/Microsoft/dts-gen which helps but is far from being the ultimate solution.
jesus, you're pretty dense aren't you? safari has 4% market share, just saying it's not particularly attractive, but have fun with your sub par browser, i really don't give a shit. 
Clearly you do as here we are, 17 hours later and this is still bothering you. You couldn't run safari even if you wanted to buddy. Suck it.
Thanks good link. However, what I'm looking for is more how I could add some momentum/friction to the parallax elements. Any tips?
I use the chrome app for everything on my i phone. Works great.
A WebView and/or JSContext is still just a Safari instance AFAIK. 
OP, Did you ever learn which was the most recommended? I am in a similar position.
It's a chrome "bug" I think, the scroll with the mousewheel triggers *once* the "scroll" event, firefox triggers the event as many times as it scrolls. Try it with firefox or with the scrollbar it's perfectly smooth. So I think you may have to overwrite mousewheel event to fix it. Mousewheel events are always a pain to deal with especially with touch event..
I was also confused why you didn't use Flow. It looks superior to TypeScript in every way. I asked the Inferno team the same, as they chose TypeScript over flow – they said it didn't really matter (like you did) but that all their core team knew TypeScript, not Flow so that's why. I thought it was a poor reason, surely they could have picked up Flow? Then again, I guess it's still better to use TS than nothing.
You've to document the types of your API either way. You might as well go with the tersest option.
It makes the life of library authors easier, too. Type annotations are much terser than JSDoc comments and they are always in sync. Furthermore, you get tooling benefits while writing/testing the library. Finally, you can offer your library in 3 different flavors: ES5, ES6, and TS. By the way, the d.ts files can be also used if you use JS. WebStorm and VS Code can load them. Then you get tool-tips and type inference (in places where that lib is involved) even in JS.
Kivi is really fast.
virtual DOM is not meant to be magically faster though, it's meant to be an abstraction. Having an abstraction over a legacy/crappy API (such as the DOM) is massively important. Long gone are the days that people are using jQuery all over the place that virtual DOM had collisions with real DOM. In fact, people can get by without using jQuery at all now!
&gt; And making these .d.ts files for all the dependencies i'm going to use is something i really dislike about typescript right now. If you don't have a d.ts file for a library, can't you just declare var obscureJS : any; in one of your files and proceed as normal?
As I mentioned above, I'm also in the Flow camp, but it's important to understand why people pick TypeScript right now. Essentially, TypeScript probably has a 1000:1 mind share ratio right now, partly due to better marketing, more polished tooling and easier to setup, as well as having a 2+ years head start on Windows support. The advantages of Flow are also very difficult to see unless you build a complex application with both it and TypeScript and compare side by side which kinds of bugs you catch (or if you're a type system nerd). If WebPack does go with Flow, it will get hundreds of people asking why it was not TypeScript, and while I think its fine and the correct choice, it will be hard to explain. WebPack has been really popular in the React community for a long time, so Flow usage among Webpack users is a little higher than the average, making it easier, but its something to keep in mind.
Check out https://redom.js.org and you'll see how do I use the DOM.
I just tried it with fixed and absolute, and both seem relatively smooth to me. Did you change anything on the codepen since posting this?
Someone posted code already. Simple doesn't always mean efficient. I want to learn how to block certain portions of a given website from loading up in my browser with jscript. I can probably load the script from my local harddrive, have it connect to the internet, parse out all the bs, discarding everything except the login part. I don't think it's really complicated operation. The host file allows me to block domains. A script would allow me to block ads. An addon would require installation and remain in memory until Firefox is closed...
No experiment is a failure. There are only results.
What do you mean by "stateless"? What is your goal?
 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;script src="https://redom.js.org/redom.min.js"&gt;&lt;/script&gt; &lt;script&gt; var el = redom // ☺ var mount = redom // ☺ var hello = el('h1', 'Hello world!') mount(document.body, hello) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; doesn't seem to work.. I wonder why..
I'm about to launch a FeathersJS app, keep your eyes on [this Twitter account](https://twitter.com/BeachfrontD) for updates! Anyhoo, I think Feathers is fucking awesome. I'm not paid to say that, in fact, I probably annoy the devs with my questions/confusion sometimes, haha! I tried Meteor first but there were some things about it that annoyed the hell out of me. At this point, I forget what those irritations were, but I found Feathers via trying to find a replacement for Firebase because I didn't want to use a Google-owned product. One of the devs wrote an article on how to replace Firebase with Feathers and I was hooked...pun intended?
Arrow functions without spread operator are kinda bitch though. No `arguments` variable sometimes is annoying. 
Fixed now, thanks!
That didn't seem to work for something like a plugin for jQuery...
To use a module lacking types you should be able to do something like: declare module 'jquery'; import * as $ from 'jquery'; or declare const $: any; if you're just including the script file in your html. That said, doesn't jquery have types? I'd think you could `npm install @types/jquery` 
JavaScript months are zero based starting with January as month "0". Other than that my only advice to you would be to not reinvent the wheel unless you're doing this for a school project or just as a personal exercise.
You do have a point of course. I'm one of the self taught cool kids, or rather was. I've been in web dev for close to 20 years now. All in all I agree with your point, but there are more factors to consider though: 1) Working with Javascript (or the alternatives like TypeScript) is generally faster than Java or other "serious" languages like C# or C++. 2) Usually the problems one tries to solve with Javascript are much simpler. Probably 90% of what Javascript is used for is front end dev and Node micro services. 3) Javascript development is becoming more advanced every year. For example OOP design patterns are becoming common which was almost unheard of 10 years ago in the Javascript world. Thanks to TypeScript for example we now have types, real classes, interfaces, etc. I wouldn't be surprised if in 5 to 10 years the language evolved to become something closer to C# or Kotlin.
Haha that's one way to reinvent the wheel. For what it's worth, solving this problem is considerably easier with `Date.prototype.getDay` which returns a 0-based integer (where 0 is Sunday) of the provided date. Anyway, in answer to your question -- the following note appears on the wikipedia article for zeller's congruence: &gt;NOTE: In this algorithm January and February are counted as months 13 and 14 of the previous year. E.g. if it is 2 February 2010, the algorithm counts the date as the second day of the fourteenth month of 2009 (02/14/2009 in DD/MM/YYYY format) https://en.wikipedia.org/wiki/Zeller%27s_congruence Possibly related? I don't know enough about how the calculation works to really help you. It sounds like a problem with the mathematics and not JavaScript itself. edit -- looks like you accounted for that. Another thing, `K the year of the century (year mod 100).` -- it looks like you are just passing it along from the input.... this isn't defined, but has it been modded by 100 ? edit2 - add more parenthesis around operators and maybe split it out into different variables. edit3 -- Actually, it looks quite wrong, the end of it + Math.floor(Y / 4) - Math.floor(Y / 100) + Math.floor(Y / 400) In the wikipedia, it is + (k/4) + (j/4) - 2j Unless I'm totally missing something here, this looks to be a derivation of the formula. j is the number of the century -- it might be easiest to take the first two characters of the year as a string and parseInt to get the century year. 
My tiny UI library called RE:DOM also does server-side rendering as well: https://redom.js.org https://github.com/pakastin/nodom
I've just split this from the Optlam package because I need it in so many places. Posting here in case anyone eventually needs a fast λ-calculator with convenient import/export formats.
Feel free and take a look at our new documentation page which has our "Core Concepts" webpack.js.org/concepts The page is still a work in progress, but this should help you understand more about the tool.
You'll be happy to hear that configuration usability and documentation are currently our number 1 and 2 goals for webpack. This is just some "things we would love to do in the future for larger sponsorship" and to help make webpack easier to contribute. If it turns out that we POC TS or Flow and it doesn't do either of these things, then it's not worth it. The results is my biggest concern. 
Ah, sorry I misread that. For something like that, I think it's easy enough to extend the definition. Eg: declare module 'jquery' { customPluginFunction: () =&gt; void } 
That's what I get for copy and pasting from the first example. Editing.
Off hand, I'm not sure where you could ask for math help. I know /r/askscience has math for a topic, so that might work - but there may be more specific subreddits that might be more suited -- off hand, like I say, no idea.
Sorry! Thanks for letting me know about Showoff Saturday. 
I appreciate OP writing up the info and hoping to help the community. That said... this would all be fine if I am mucking about a project at home and felt like passing a little time to contribute. But in reality, I'll be at work, pushed to the limit to reach dead-lines and the last thing I have in my mind is stopping all Dev work to contribute to this and trying to explain to my boss why exactly I'm doing this... because... I really don't even know... I mean, I understand what .d.ts files are for... but when I try to explain to anyone coming from another language they all have the same reaction I did at first.... "Uh... WUT?". I actually tried to explain it to them this week. When the decision was made to "Go Angular", I was trying to explain all the "new" things we'll have to do in the project which will take time to setup, which wouldn't have been an issue before. And people just don't understand... what are we doing all this extra stuff for? I still just don't get it. It's 2016.... what on earth are we doing that this is now a necessity just to write some code.
&gt; You just keep repeating that it's complicated. Not really. I said that putting anything other than compile-time constants there is a bad idea. &gt; It's just a function called when no argument has been given, something you would normally do within the constructor, which makes the functions intent harder to parse. I've no idea what you're trying to say. &gt; Could be a function that accepts a dom node to add its stuff (for instance a canvas) and will create and return an empty div by computation if none is given. There isn't any point in adding children to a canvas element. You only get to see the fallback content if JS is disabled. Anyhow, if it isn't some specific element from the page, you get a div back which you now have to add to the page? That's the kind of API you'd want to use? &gt; Computed defaults make it incredibly easy to see what's going on right from the functions signature. Arbitrary complex expressions are arbitrarily complex. If it's a compile-time constant, the value is right there. If it's an arbitrarily complex expression, you've to take a closer look.
What? You're kidding! A webpage is just html and javascript. I want to block out everything except the two boxes. I've written code in C++. I can probably program everything into a temp data struct, dump the bs, and then display just the prompt. Are you sure? Edit: people posted the code required to perform the mod using Stylish, another Firefox plugin.
I have contributed to a lot of Redux related dts files at work? Why? Because after taking a look to multiple frameworks and transpilers we decided that the best option was TypeScript + Redux + React and when we made this decision we were aware of the lack of dts files. This was more than a year ago and almost no dts were available today most of them are available. Just think that there are a lot of companies in which you are allowed to spend time doings things like building your own framework and releasing it as open source. of course you need a good reason to build your own stuff. The default is to choose some open source tool and contribute to it if there is something missing that you need. 
&gt; what on earth are we doing that this is now a necessity just to write some code. It's duct tape for making JS scale. It's a trade-off. I agree that it's unfortunate that we have to use this kind of workaround, but at least we break-even fairly quickly. After a few hundred lines you've already benefited enough from the improved tooling to make setting everything up worth it. If all the libraries you're using come with type definitions, it's a fairly smooth ride.
`npm` can load packages from GitHub (and similar) - including from private repos - without them needing to be in NPM's repository. As your code is already on source control (it is, right? ;) ), you can install them!
&gt;&gt; I've no idea what you're trying to say. class Canvas { constructor(dom) { this.dom = dom || document.createElement('div') ... this.dom.appendChild( .....internal canvas) } getDom() { return this.dom; } } Into this: class Canvas { constructor(dom = document.createElement('div')) { You assign anyway, only in a non descriptive way. There is nothing arbitrary in what the signature does. &gt;&gt; There isn't any point in adding children to a canvas element. I didn't write that at all. &gt;&gt; Arbitrary complex expressions are arbitrarily complex. Pretty much all view frameworks use computed props, most other languages have constructs for it. Getters and setters are computed, computed object keys, functional programming where functions return computed results by default, etc. 
Could still use a better summary.
"Anyhow, if it isn't some specific element from the page, you get a div back which you now have to add to the page? That's the kind of API you'd want to use?"
It's an example, but yes i do use something more or less like that for v-dom scenarios where dom doesn't exist unless the component is mounted. The class in that case represents a wrapped canvas unconcerned about the whereabouts of the target. Might be any other case where the default is functional.
I'm not sure I understand what you're asking. I think you're saying that you have a PHP class that queries APIs based on some configuration and maybe some arguments. Perhaps you were calling this class in your web-facing PHP script, such as index.php. Now that class is handling more business logic, increasing request processing time. If this is close to correct, keep reading. First and foremost, be aware that you CAN increase timeouts for your PHP scripts in php.ini (max_execution_time, etc). It's okay to increase these values to provide your application a little buffer, especially when dealing with network latency involved with your API calls. However, this solution will not scale and would provide a horrible front-end user experience (who wants to wait 5 minutes for a web page to load? This takes us to your question about JavaScript handling the business logic and the API calls. That would work but you still have constraints, hopefully we can assume all the remote APIs aren't having timeouts. So this leaves you with a constraint of long-running JavaScript, you don't want to keep the AJAX request open too long for a number of reasons, I won't cover here. Possible Solution: I would recommend leaving your code in PHP unless you have other reasons to reimplement in JavaScript. Let's assume your business logic written in PHP is accessible at a REST API endpoint: /do_work. Rather than load a index.php page, we can make an AJAX call to the /do_work endpoint, but instead of waiting for a response, fork to process in the background, and respond with a job id that you've somehow mapped to the background job. With a second REST endpoint, you can long-poll /status/&lt;job_id&gt; which can return whether the job is complete or not, maybe even percentage complete. Alternative to long-polling, you can look into using websockets to communicate job status but your server-side implementation is still roughly the same. You might want to read up on message queues and workers to implement this in a scalable way: http://stackoverflow.com/questions/32204947/valid-architecture-for-a-message-queue-worker-system-in-php
It must be yarn shill day
Thanks, this is definitely a lot like what I was looking for!! Now if only npm had a way to install to a specific path, rather than node_modules... :)
Oh they finally did that? Cool :) It might seem like nitpicking at this point but that technically still means the same thing I was pointing out - It's still webkit that's running the JS code, not iOS per se.
Before I get complains about another node library, I would like to let you guys know that there is a god while that I don't work with NodeJS so I'm trying to get bet on track little by little. This is one attempt to write some NodeJS code and that's all :)
`npm` (the tool) can install dependencies from a range of sources, not just packages that are in the NPM (the company) repository. In your case, it can install a dependency from a `git` URL. You could have your script or library on Github and just point `npm` at it to install it into your project. (if you don't already have your code in source control, you should start doing that) Using `git`, you can specify the version (or range of versions) you want, exactly like other packages. If you don't want to use `git` (again, you should), it can install from tarballs via URLs too. Full details are here: https://docs.npmjs.com/files/package.json#urls-as-dependencies
Won't that declare it a second time and override the first?
First off, you're definitely going to want to use the [canvas](http://www.w3schools.com/graphics/canvas_intro.asp) API. For a 2D game, I definitely recommend using some sort of library or engine that sits on top of it. There are [lots of great options](https://html5gameengine.com) and any one would greatly enhance your productivity versus working directly with the canvas API, which is very low-level. Also, most if not all of the game engines will have optimizations that will make your game faster without you having to do any extra work. But with that said, I would make sure you're comfortable with the language and try some practice games in very small scale just to get experience under your belt before diving into a library. Maybe first try creating some 2D art with the barebones canvas API and `window.requestAnimationFrame` to get a feel for it.
Alright thanks. If possible I would rather write using pure JavaScript and the canvas for educational purposes as you said, if it is doable and won't end up screwing me with performance issues etc. The basic idea of my game is a 2D platformer similar to Super Mario Bros. The graphics won't be too complex. I presume the 2D canvas will suffice for this?
Yes, if hardware acceleration works, something like Mario won't be a problem. Even without acceleration, the CPU of most systems is fast enough to make up for it.
Thank you for your tips, regarding Y, m and q, the lecturer had a preset amount of requirements where we had to use those variables. Y for year, m for month and q for days. I totally agree it's a stupid way of naming them.
You can detect, in addition to the scroll event, the mouse wheel event. https://developer.mozilla.org/en-US/docs/Web/Events/wheel
Don't bind to scroll events, instead use requestAnimationFrame to check the y offset repeatedly. If it changes, change the css properties. This means touch and scroll will just work, and you aren't redrawing when it's not needed.
It's awesome to see a person taking time to create in open source. But, what is the point? As in, why should I use this over simply writing a bunch of promise functions?
Thanks for sharing! It makes me sad that people are hesitant to share their work without fear of the hivemind complaining about "fatigue". 
This blog entry doesn't really say anything that you can't find from a cursory glance of MDN and caniuse ¯\\_(ツ)_/¯
Maybe this is a dumb question, but now you can have a Uint8 in javascript and do real bitwise operations? I was reading "the good parts of javascript" and it mentioned how a bitshift is actually going from 64-bit float to int, then but shifts that, then converts it back into a float.
that will be `char32_count`, paste below text to the textarea if 2 &gt; 1: print("OK") 
What?
wrong sub I guess
Underscored methods. As long as you're coding with professionals, underscored (eg. "_getFoo") methods are superior to traditional Java-like privates. No one calls an underscored method outside of a class, so you get the benefit of private-ness when refactoring. But when you're unit testing and you need to stub an underscored private method, you're not prevented from doing so (as you would in Java).
You can split by a regular expression. let word_count = text.split(/\s+/).length [String.split](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split) [RegExp](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp)
As I said, either use proxy/vpn/etc. to change what your browser receives, or use anot add on like others suggested
Thanks! You are right with my goal having to make the function work with any object. And you advice works, particularly for the example above. However, based on your experience, how do you consider what to make flexible and decoupled? In this case, should I decouple "getOrderName" and make it more flexible, if I need another function called "getOrderDate"? I am new to programming and would like to get my programming "design" as "correct/right" as possible.
Are you looking for something like this? https://www.fullstackreact.com/articles/using-create-react-app-with-a-server/
Once they roll out a language interface for web assembly (right now its just a byte code format) you will get the C#/C++ like capabilities. Most of the problems, in my perspective, are cultural and not technical. I have been writing web code for almost 20 years as well. Its my primary profession. I have also had a secondary part-time profession for as many years in the military. When you have a big strategic effort the planning processes are similar. The planners create a planning horizon (they call it a horse blanket in the military and a roadmap in the corporate world). These things establish objectives over a timeline from which milestones are documented. Working backward they then create some iterative objectives whether its waterfall, agile, or something custom. The big difference though is that on the military side the skills to accomplish a given task don't radically change within a 5 year horizon. You know what you need and you provide your own training to ensure that your people are always capable even if expendable. In the corporate world training doesn't exist... at all. It is fundamentally absent except for some small (extreme) edge cases. You are more likely to get training as an hourly employee performing manual labor than as a mission critical systems engineer holding the health of the business in your hands. Although a military mission is diverse in its responsibilities and risks you generally have vague ideas about the required capabilities and can form fairly accurate estimates. It is rare that anybody gets this right in software even though the field of scope and acquired risks are substantially more narrow. The big difference there is that prior to execution a military team will perform really deep intelligence gathering sessions and conduct rehearsals, while in the corporate world planning left to the project managers and everything else is ad hoc. The really ironic thing is that everybody in a military trains like the people around them are completely expendable. You could get injured or the mission could change in a heartbeat and you have to adjust. The reality is that in the military you are far less expendable than in the corporate world. How frequently is your buddy going to get killed on the job or walk away and get a different job? Its pretty rare, but in the corporate world people jump ship or get laid off all the time. This is incredibly common, but for some reason it ALWAYS comes as a surprise and you generally only have a two week notice to adjust. Good luck trying to hire a competent replacement within two weeks while having xenophobic fears of training. I think part of the reason for these failures in the corporate world is that you are often awarded for ignoring common problems so long as the work gets done by a promised deadline. Training costs money and don't get rewarded for spending more company money. In the military, on the other hand, you get a training budget so that such excuses are eliminated. This kind of neglect at the managerial level in the military follows you and will quickly end your career. It could even result in law violations that result in fines and jail time. It is simply easier to accrue technical debt, because the people who will bear the consequences are those who come after you once you have moved on to management or employment elsewhere. Everybody wants to point fingers at prior incompetence but nobody wants to accept ownership in the present. Nobody wants to be the mean bad guy who points out incompetence and raises the bar, because then you are just the old asshole guy and certainly not the cool kid.
My goal, is to make a piece of code as re-usable as possible. In which, for this case, is a function that deals with a database. 
Not it is right sub, I suggest to paste that _text_ into the textarea and check the result in `word_count`. I'd used python because it uses space indentation for blocks.
Nice!
more like text.replace(/[^_0-9a-zA-Z]/g, " ").trim().split(/\s+/).length
No this article only teaches me how to launch a server. I can do that with just `npm start`if I use webpack-dev-server. I just need to test my app in a dev server and my app need to have server end modules. Some tools like react-starter-kit has a server.js file so at least I have a clue where to put some server end codes. But I am not sure how to do that with create-react-app.
The fastest way is to use webgl and write a vertex shader. The canvas 2D api is just too limited and dumb to be fast. You seem pretty comfortable with the low-level bitmap stuff, you should try your hand at GLSL. Once you get the hang of it you'll be able to do way more interesting stuff without worrying about performance ([thousands of particles are not a problem](https://gfycat.com/ThriftyCloseFlickertailsquirrel).) Use three.js or pixi to handle the nasty webgl boilerplate.
please consider characters outside of `alnum` too. for OP, yourString.match(/[^\s]+/g).length would also do.
Still "What?"
FWIW, I went ahead and dropped in a router. :) Supports linking and navigation now; took a couple hours to add: https://github.com/nolanlawson/pokedex.org/pull/60
Just sort by 'controversial'
So there is no way to just allow microphone use on android device? I mean the app works out of the box with chrome, but after cordova port there is no output sound from the android device...
jquery validate picks up attributes on form inputs and performs validations on them. i.e., you have an email input - change the `type` to `email` and it will trigger the email validation for that input. There's a bunch of options for it including where to show error messages, the rules (in case you don't want to do inline validations) I'd just clone their [git repo](https://github.com/jzaefferer/jquery-validation) and take a look at / play around with the files in the demo folder. The bootstrap one looks pretty good and goes over most of the options I would expect to see (error placement, custom messages, rules) 
Not really. When you read from a `Uint8Array` with `var x = u8array[i]`, you read a single byte from the array with a value between 0 and 255. However, `x` is still a JavaScript variable, so that value needs to be represented by a `number` type, i.e. a 64-bit floating number. Of course, modern browsers are smarter than that. While a 'dumb' interpreter would need lots of conversions, modern JavaScript engines have JIT compilers that use runtime information to produce more efficient code. For example, if they find that a variable only ever holds integer values at runtime, they can JIT compile it to code that works with int32 values, skipping the conversions from/to floating point numbers.
http://todomvc.com/ provides a nice list of javascript frameworks. 
My personal favourite is Angular. It has many nice features and lets you write single page apps and more. Also, Knockout is fine but is a bit on the decline in my opinion. I heard a lot of people getting excited about React. It has a growing community I think and it's worth checking out.
thanks=)
Although not technically a framework, it's worth giving Inferno a try if you like something like React but a smaller file size, better performance and a few additional features that have yet to land in React. You can use `inferno-compat` to switch a React codebase to Inferno with a few lines of config in webpack/browserify too (great for when you want to use third-party React libraries).
 ...which also fixes the problem of having multiple empty spaces next to each other...
JQuery and MooTools are not frameworks, though.
Now we need a class to protect that module
OK I see this article is actually recommended from the project's github page. I didn't know it is so much work to integrate with Node.js back end though.
I'm a web developer who took (and subsequently forgot most of) several levels of calculus in university. What are some applications of lambda calculus in the development world? Web or otherwise.
I didn't test this fix but it looks like you are using the value attribute incorrectly as it only allows numbers. You can instead use a data attribute. Try replacing the value attribute with data-value instead. so each li looks like this: ``` &lt;li data-value="EN" class="dropdown menu-search"&gt; ``` Then change the query to: ``` var lang = $(this).closest('li').attr('data-value'); ```
I guess you're not that big into RxJS then either?
Can anyone bring real life examples, where having bot would save your time? For instance, why have a bot for weather information when you can Google everything within few seconds?
thanks XDXD finally worked XD
ES6 modules do nothing in the browser as you can't load them. The spec isn't mature yet. Wepack is a buildsystem, it does far more than bundling modules.
For me bots make sense for the things that you are not using that often, ie. imagine ordering pizza or calling a taxi/uber - you can do that from the website or app (but why would you need an app for something that you use just a few times in a month), but isn't it easier if you can send a simple text message with your favorite messenger? For pizza, most of the time you are getting one or two same pizzas to the same address, it's just one simple message instead of searching Google, visiting website, logging in, etc. For taxi most of the time you don't care about the current position of the driver, you want to know when the taxi arrives. There's a bunch of other things, those two examples are over-simplified. One more useful thing for me is making MVP in early stage startup -instead of building 4-5 different things you can focus on a chatbot and test the idea with minimal effort on the programming side. Of course, it doesn't work for all ideas. Space Explorer bot is just a showcase for our bot builder, there's no real value for it.
Wrong, browsers don't support ES6 module loading yet: https://developer.mozilla.org/it/docs/Web/JavaScript/Reference/Statements/import#Browser_compatibility This is probably because it's not as easy writing the spec as some syntax sugar. So we have Webpack is a "bundler", meaning it reads all your files that you "imported" and puts them all in a file (or a couple which require each other), which you can then load in a script tag in your browser.
Well I don't know how, but I have HTML file on desktop with code in pastebin I provided, and if you try selecting second line of text, it works. MAGIC... EDIT: And I need it to update innerHTML while I'm selecting code, not when I release left mouse button.
A better description of what happened: “jQuery Foundation” is now “JS Foundation”.
A few minor quibbles: * "Javascript" -&gt; "JavaScript" * "Destructuring using an array" -&gt; "Destructuring using an array pattern" (or: array destructuring). * "Destructuring using an object literal" -&gt; "Destructuring using an object pattern". The syntax is similar, but it’s not an object literal!
Thanks! That sounds like it'll work better. I need to look up some good tutorials for webpack so I understand what's going on in the config.json btw if you looked through my code, any feedback? what do you think of the idea?
Serious question here, how easy is it for you to use React.js in your applications knowing that so many people in China are still using IE6?
Hmm, the definition of word is indeed vague but print('ok') do have a single group of letters divided by any number of whitespace(based on common sense) while including newline and linefeed characters. You probably have misunderstood the question and tried to count *tokens or identifiers*. :) Needless to say \W won't do anything useful by itself.. I wonder which point you are really trying to prove or just nitpicking..
I have tons of valid steam DLC keys to give out while working 60~90hrs a week. I just went 'fuck it, I'm making a steam giveaway chat bot in node' one day and I have never regret it.
&gt; or ORM (.... oh right, all of them are terrible) What's wrong with Sequelize?
I have found a use case for var that let cannot solve: Say you want to assign a different function to a variable depending on whether you are in production or development, but you also want to make sure that when you run the code through babel and uglify that the assignment happens in a single var declaration line, to reduce the number of var statements to a minimum. Using let with dead code elimination causes neither block to appear, because regardless of being in development or production, the let is block scoped and will be removed. Using var lets you put the declaration right in line as if the 'if (production)' isn't even there.
You make a good argument. What are your thoughts about defaulting to `const`, though? Thanks for commenting.
I think you should use const unless it's absolutely necessary not to. Redefining variables is another common source of bugs (yeah I know you can redefine object properties on const, but still). Const helps enforce a more pure, sane codebase in my opinion.
At least we agree on that. :) Like I said in the post, I wish there was a way to make function arguments be `const`. Whenever I write Java code, my method arguments are always marked `final` for similar reasons.
Moment.js should be integrated as native date library in the next specifications.
Sorry, you're right. The loader is it's own specification based on the module import / export specification provided by ES2015. https://github.com/whatwg/loader
Er. It doesn't. The passing goes the other way. Your application passes the file path to node, and node gives you back a string of the contents (or callbacks or promises.) The only time at which `node` will give you paths and filenames is when you're scanning directories.
How so? If your y offset hasn't changed then you just return out of rAF
In your opinion what problems does this seek to address?
That looks outstanding! Saved for later. Also &gt; "Made with ~~love~~ a keyboard" All of my this. 
...Where do I go to get in on that
Also, beyond the lack of support for ES6 module loading that u/pontiacks mentions; webpack can provide functionality that won't ever be part of ES6 modules: bundling html templates, bundling css (and including it directly from the JS) and other assets. Or the plugin that allows you to define "compile-time constants".
Even when browsers finally get module loading, we will probably still use webpack. ES6 module loading makes an ajax request to get the module, witch isn't nice for a large web app. And it will also not be supported by old browsers so... Yeah, it will be great for quick prototyping on the browser, node and electron, but I wouldn't even think about using it in production on a web app.
Sequelize is okay in the same way that Bookshelf is okay. Both do the job, but honestly after having used Django/South, there's absolutely nothing in the nodejs environment that even comes close to comparing to it. I find both sequelize's and bookshelf's querying to be very confusing, I've been using Bookshelf for about a year and I *still* have to pull up the docs to figure out how to do minor things. Bookshelf's underlying library, knex, is actually really good though, but it's mainly a SQL wrapper, not an ORM. Where they both really lack is in migrations and schema control. In Django/South you define your classes, it detects the differences between your definition and the database, and auto-creates a migration script for you. It's ridiculous to me that nothing exists like that in node (that I know of) -- I want one place to store my schema definition, have my ORM classes use it, and have my migration scripts use it. I shouldn't have to edit 2 or 3 places to create a migration, then let the ORM know what changes I made. Also on a personal, picky note, I don't like their class definitions, (bookshelf.js anyway, sequelize.define() is okay). I'd love to see an ORM based on ES6 classes, it'd make things a lot cleaner in my opinion. 
I was hoping for something more practical. I can see what their goals are as written in the article, but the primary objective doesn't sound like a problem demanding a solution: &gt; Figure out some standards and best practices and maybe start to consolidate our best toys in a communal toy chest. Their solution sounds like a problem. Surely there is something more than funding some pet toys. This is the kind of madness the core Node community works very hard to explicitly avoid, which they refer to as *user land*. The reason why this is a problem is that induces favoritism under the guise of a standard in opposition of choice unless they take the Mozilla approach and simply throw money at projects them deem worthy without officiating any of it.
Missing an /s, people are too lazy to think.
I only skimmed it quickly, but regardless of the reasoning, I'm paranoid about them branding themselves with such general language. I'd hate for people new to web development to think that jQuery IS JavaScript.
You should skim a little deeper. It's not just jQuery. That's the point of the name change, to communicate that it's not just jQuery. But I don't like the language either, ever since some joker snatched the npm name "standard" (could you be any more cocky?) and used it to distribute a linter that forces you not to use semicolons. You asshats, "standard" means "generally accepted norm", not "tiny minority view THAT I THINK IS RIGHT, F\*CK ALL YALL". If you feel the need to include in your README "It's fine. Really!", links to three different justifications, and a link to an alternative that's literally just a fork with this one thing changed, *then it's probably not a standard*. ... /rant
Totally agree about the limitations. They're not as mature as other ORMs. However, Bookshelf's classes *are* compatible with ES6 classes, so you can `class User extends bookshelf.Model {`.
Bots can make it quick to retrieve information that you know is out there when in a group chat. They're basically like "I'm Feeling Lucky" buttons without having to wait for pages to load or circling back to paste a link. For example, if someone in a Slack chat hasn't heard of a game everyone's talking about, fetching the link to the product page and some basic info is only a /steam or /bgg command away. Another popular use case for bots is notifications. If a development build breaks, or an urgent trouble ticket comes in, you can instantly notify the relevant teams by posting an automated message in their chat. It's nothing that email or custom apps haven't done before, but if your teams are already using group chats, it can make everything a bit more seamless. I'm equally as puzzled for most one-to-one chatbots though. If I'm the only user in a chat, I'd rather just use a web page. The only exception I can think of is voice assistants like Siri or OK Google. They're not bots pre say, but they both seem to have similar functionalities at this point in time.
blatant ad.
TL;DR: they lived out of the office and worked 15 hour days.
Ofc it is. You can't use let or const here: switch ( action.type ) { case 'ADD': const { a, b } = action; case 'UPDATE: const { b } = action;
Welcome to r/javascript!
Moment also does way more than those three things you mentioned. In a lot of projects moment isn't even coming close to the size of other dependencies you may need, and it solves a lot of problems that make working with dates a pain in the ass.
Right, thanks. Slopy copy pasting ;) I have lots more research to do so I understand this a little more clearly before I feel comfortable telling infosec yup, this is how we can do it and i can deploy it correctly.. but can you give me a high level look at what the interaction between crypto.js node and the browser is? Thanks
That violates the requirement to have a the declaration and assignment inline, using only one var with comma separation.
Sure, from my library: https://github.com/dwighthouse/onfontready/blob/2.0-SpaceCharacter/src/onfontready.js#L39 If let is used, babel's dead code elimination deletes the entire declaration/assignment. One could pull the declaration out, but then there would be extra costs to the compressor.
"isn't nice for a large web app" is debatable. Some seem to believe that loading many small modules is preferable over http2 because the overhead previously associated with loading many small files can largely be mitigated and then you are left with a superior caching scheme.
My thoughts exactly 😈
Not ignorant. They are vastly underused in the current web. Every bloated png logo can and should be SVG at this point. 
I'm with you. Semicolons for LYFE
I will therefore try to explain in few simple steps what to take into consideration for a rational choice of a new framework to use for your projects.
I am no longer a fan of OO in JS (or in general TBH). Although I will never use this, I think you did a good job. simple, easy to use, easy to understand. Now it just needs some inheritance and a protected name space, once inheritance is addressed. ;) 
Saved
Ah, thanks for letting me know and for trying to answer! I actually got some great help on Stack Overflow, so I think I'm good now :)
Started using it about a month ago, coming from constant SailsJS usage. I can't compare to Meteor (never used it), but I can just share a personal opinion. So, if you're used to the typical MVC framework flow (like in Sails, Laravel, Symfony) you'll be having a bit of a hard time with Feathers, until you get used to the services/hooks workflow. But I think it's great if you want to do an application with decoupled functionality, like microservices.
&gt; The fact that there are no authoritative voices clearly identified as such in the JS ecosystem Isn't that what IETF, W3C, and TC39 are? &gt; It has been in fact quite easy for some people in the past and present to gain a certain popularity while spreading a lot of, let's say, "not too good" information around, by mostly riding on hype, social skills, getting a cool name, or, precisely, the absence of other voices calling them out with enough authority. Its like crying because some people actually believe everything Trump says. False messiahs are going to happen. Don't care. The best practices have been well known for over a decade. Even with the release of ES5 and everything after this hasn't dramatically changed. I don't need a ~~parent~~ authority figure because search engines are too far away or because I am so hopelessly lost in tooling I have completely forgotten there are actual problems to solve. What are you hoping for in some authority figure that isn't already available to you?
My issue with the semicolon debate is that in every job I've ever worked at, all the devs preferred semicolons. Never met someone who drops them. It's like that evening news story about the knockout game that kids were supposedly playing but no one actually knew if it ever happened. 
For the curious, the issue isn't just that `var`s get hoisted, it's also that closures in JavaScript capture variables *by reference*. I'm going to dip into C++-land for a bit, because C++ lets you capture *either* by reference or by value. vector&lt;function&lt;int()&gt;&gt; callbacks_captured_by_reference {}; vector&lt;function&lt;int()&gt;&gt; callbacks_captured_by_value {}; int i; for (i = 0; i &lt; 5; ++i) { callbacks_captured_by_reference.push_back([&amp;i] () { return i; }); callbacks_captured_by_value.push_back([i] () { return i; }); } // 55555 for (const auto&amp; cb : callbacks_captured_by_reference) { cout &lt;&lt; cb(); } // 01234 for (const auto&amp; cb : callbacks_captured_by_value) { cout &lt;&lt; cb(); }
Even if you used `var`, that second value of your `Node:` array would be undefined, always. You're trying to use the future result of `Type()` inside the expression that creates `Type()` itself. You just can't do that.
But they are doing different things, and that's why there was a performance difference: for(let i=1;i&lt;6;i++) { setTimeout(() =&gt; console.log(i)); } vs for(var i=0;i&lt;5;i++) { setTimeout(() =&gt; console.log(i)); } Illustrates this. Anyone who is/was dealing with optimization to the point where they have to worry about the performance difference would be able to figure this out.
And a closure to protect that class. We must go deeper!
You can...I promise, it is by the time that it is "needed" with that Union Type it will be defined...Give it a shot, `npm i union-type`. https://github.com/paldepind/union-type My point is, there are many valid use cases for using hoisting, and to say black and white, do not use `var` is not a good practice. 
I mean. I cannot think of a way to represent Union Types like Trees or Lists without using Hoisting. I like how it gives me Elm like Unions. With some type guarantees. Is it clever, or an understanding of hoisting? EDIT: Oh wait. you are right!! but it cannot become undefined with `const` or `var`, so yeah, a little clever. 
I'd note that this is also somewhat true for integers. If you define a variable as `var foo = 123|0; then it initialized to a 31-bit integer and will stay as such if you don't overflow it or use it with a float.
Think about it like synchronized swimming though. Everything happens at the same time.
Yeah, so for example we could do: const RECURSIVE = undefined; const List = Type({ Empty: [], Node: [ () =&gt; true, RECURSIVE ] }) 
You could loop over a range of length 5. And there are genuine uses for var over let as well.
Right ... 20 people all performing their routine at the same time; that's parallel processing and asynchronous. Consider the synchronicity of each step of their routine as something like thread synchronization.
Made with love always seems overly positive and disingenuous. I tend to hate my projects, but it's part of the process. Ever heard of the Flatiron School? They're a great example. Too cynical?
The key phrase there was "as long as you're coding with professionals ..." :)
totally, or even const List = Type({ Empty: [], Node: [ () =&gt; true, undefined ] }) You were totally correct, sorry I got so snarky ;)
Yes you can, throw a block around them and you're fine.
https://nodesecurity.io/ is a good start. Regarding the dependencies you can lock down your versions by removing the caret in front of the version number. Second question: nothing. But that's not unique for npm, any software can have flaws.
Oops. Thanks for catching that. It's been fixed.
&gt; Anyone else with me on this? Perhaps we can start with a Babel plugin. Or just use [Ramda](http://ramdajs.com/)
&gt; \W won't do anything useful by itself Right, I mixed up a bit. I had in mind Python's findall function, which is "match" - opposite to split's "unmatch" In [4]: re.compile('\w+').findall('if 2 &gt; 1:\n print("ok")\n') Out[4]: ['if', '2', '1', 'print', 'ok'] if fact Javascript has the same (I googled a bit) &gt; 'if 2 &gt; 1:\n print("ok")\n'.match(/(\w+)/g) [ 'if', '2', '1', 'print', 'ok' ] &gt; You probably have misunderstood the question and tried to count tokens or identifiers. Definition of word important, because for me 'print("ok")' is obviously two words and the question was to`count words`. The regular expression syntax think the same `\w`- word char `\W` - not word char. But match helps also, when we look for your definition of "word" - space separated tokens &gt; 'if 2 &gt; 1:\n print("ok")\n'.match(/(\S+)/g) ['if', '2', '&gt;', '1:', 'print("ok")'] 
I haven't delved - what are they?
I found these to be pretty good: https://www.youtube.com/watch?v=s6R0VEdoVt4&amp;list=PLqq-6Pq4lTTYFJxC9NLJ7dSTI5Z1WWB6K
Asynchronous doesn't mean parallel. An advantage of async control is that you get similar benefits as you would from multithreading, but it's different. Async is having a jar of rocks and filling it with sand and smaller rocks and finally water to maximize the amount of non-jar stuff. Parallel is just getting more jars of rocks.
Or rather, why you should know the behavior associated with `var`/`let`/`const` and use the one that is appropriate for the context you're writing in.
Seems more like they're coming together to build more of a JS standard library, and if it all worked together semantically then that's pretty cool. I'd definitely consider it for enterprise stuff where picking libs is a painful process. But you're right, it does look like some old dogs making one last gasp while they still can.
 var ele = document.querySelectot("#output"); // container for text var raw_html = ""; Array(100).forEach((e, index) =&gt; { // loops from 0 to 99 raw_html += `${index} ${Math.pow(index, 2)}`; }); ele.innerHTML = `&lt;pre&gt;${raw_html}&lt;/pre&gt;`; // set #output's html to our generated text inside pre tag
&gt; that closures in JavaScript capture variables by reference Wait, what? No they don't. JavaScript always passes/captures by value for primitive types. Your examples show capturing by reference/value in C, but the issue in JavaScript is related to scope. Before "let", JavaScript didn't have built-in support for block scoping, and therefore the iterator reached 5 before the callback function was executed. 
Thanks! As you have suggested, I will move along with then programming and improve later on when I am more experience with it. 
Haha. &gt; Made with ~~love~~ a keyboard. I am guilty of putting "Made with" comments on pages I've built although I usually do something funny with them like animations and the such.
Thank you! I will check them out
I'm pretty sure you just need to move var image = $(this).position(); inside the click handler. Where you are using it, 'this' does not not refer to the clicked picture. 
&gt; Wait, what? No they don't. JavaScript always passes/captures by value for primitive types. For argument passing, that's correct, primitives pass by value, but for closure captures, even primitives are captured by reference. We can demonstrate that JavaScript closures capture by reference by making two closures and showing that they don't have separate copies, but rather they manipulate the same variable. function f() { var i = 42; var o = { get: function() { return i; }, increment: function() { ++i; } }; return o; } var o = f(); o.get(); // 42 o.increment(); o.get(); // 43 The reason why changing `i`'s value from one closure also affects `i`'s value from the other closure is because they're both ***referencing*** the same variable. If, on the other hand, each closure had their own distinct copy of the value of `i`, then one closure's value wouldn't affect the other's.
I'm not supposed to use jquery for this assignment according to the instructions.
Babel ES6 function callAsync(func) { return new Promise(function(resolve, reject) { func.then(function(resp) { resolve(resp); }).catch(function(err) { console.log(err); reject(err); }); }); }; return await callAsync(query);
What you're saying is correct. Your example is referencing the same variable, but that's because "i" is still in scope. I guess it's just a terminology difference. I've only heard of passing arguments by reference. I think it's implied that manipulating variables that are in scope is done by reference. 
I think it's not jquery, it's a new feature from es6 
&gt; I have really wanted to get in to coding for a long time I just not sure JavaScript is the best choice to start, unless you want write code for web. I don't feel, I can advice about specific language, but it may help if you describe what you want/plan to with programming and relevant information about your background. https://www.codecademy.com/learn/javascript https://developer.mozilla.org/en-US/docs/Web/JavaScript or just make two files `my_web_page.html` &lt;html&gt; &lt;script type="text/javascript" src="my_first.js"&gt;&lt;/script&gt; &lt;input id="a" size=3 value="1"&gt; + &lt;input id="b" size=3 value="3" /&gt; = &lt;input id="result"&gt; &lt;br&gt; &lt;button id='get-result-btn'&gt;Get Result&lt;/button&gt; &lt;script&gt; var btn = document.getElementById("get-result-btn"); btn.onclick = handleBtnClick; &lt;/script&gt; &lt;/html&gt; `my_first.js` var handleBtnClick = function(){ var a = document.getElementById("a"); var b = document.getElementById("b"); document.getElementById("result").value = sum(a.value, b.value); }; var sum = function(a, b){ // open debug console (F12) console.log(a, "+" ,b); return Number(a) + Number(b); }; open `my_web_page.html` in browser and play with it - try different examples from Mozilla's site
I'm pretty new at this stuff, i'm not sure about some of what you've written. How would I code that?
I get what you're saying now. You're right, capturing by reference is part of the problem. 
I thought [this book](http://eloquentjavascript.net/) was pretty good, iirc there are runnable code examples and some good exercises. If you've never porgrammed before, then some of the exercises *might* be a little difficult, but don't be discouraged! 99% of people never complete all exercises in a text. 
What do I have to do to make the display such that it starts from 0 and increments till it reaches 99 and then display the power of each number to the right of it. http://imgur.com/a/gZ3eD This is what I have so far
I'm a prude, but I lost track of this post after being riddled with typos and random curse words. I think the compose operator is super useful, but this is far from the first time it's been suggested to take elixirs or Haskel's. 
You are very close. I've noticed some errors, and made a gist to help you -- you're still going to need to finish it off though gl! edit: notice I logged the variable `text` so you can see what you're putting inside the output div -- open the console to see it. https://gist.github.com/anonymous/d9d13e20052813888915725428576b7a
i wager that most of the time people only know a project is part of a foundation because that project made a blog post about it
I tend to agree with /u/NewNole2001. In the source docs, the relevant code doesn't kick off any sort of parallel tasks and the docstring comment says "all path are start and finish at the same time". Async can mean a lot of things but this one seems pretty un-intuitive. Anyway, it's not worth bemoaning. This is a great library and the author has done some awesome work
&gt; JavaScript always passes/captures by value for primitive types. That isn't really true. But it isn't entirely false either. JavaScript could pass primitives by reference, or it could pass them by value, and which it does is fundamentally unknowable. This is because primitives are *immutable*. You can't change `true` to `false`, `42` to `43`, or `"yes"` to `"no"`. And unlike objects, primitives don't have properties you can change. There is nothing you can do to a primitive value to make it anything different from what it already is. So you could think of JavaScript passing primitives by value and objects by reference, but this is a distinction without a difference. Personally I prefer the simpler model of thinking that JavaScript assigns/passes/captures *everything* by reference.
100-200 particles shouldn't be an issue, even with svg if it's simple enough. If you use canvas - especially with webgl - it will be fine. What type of particle system do you want?
Thank you very much! I need to add the code to display the numbers and the math that will display each number squared. Not sure how to do that
Just use _.flow() https://lodash.com/docs/4.16.4#flow https://medium.com/making-internets/why-using-chain-is-a-mistake-9bc1f80d51ba
Yes, you should look at the [Math.pow](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/pow) function, and make some alterations to line `6`. 
I'd like to know what the actual difference is? Please do explain; P.S: And out of curiosity I executed those 2 loops together, and got an output which has now confused me. The output (on Firefox) was: 1 2 3 4 5 (only this one, 5 times) I was expecting all of them to be printed twice.
http://imgur.com/a/pFrQJ http://imgur.com/a/xVcNi Is this all correct?
Well I didn't use jQuery, so you're fine
I only use var at the top of a scope to declare undefined variables specific to that scope and specifically only in that place. i.e. I hoist before the engine does. This serves two purposes. 1. makes it stupidly simple to find/read where variables are declared, and 2. actually forces you to think about which scope you actually need for variables. Honestly, I don't ever use block scope, and don't find I need it. I've been writing JS for 15 years without it, if you understand the language and how hoisting works, it provides literally zero advantage over well structured code.
Found this tweet so funny
Interesting, how would you tackle a problem like this without deffered promises? Let's say you have a React component that keeps a ref to some other component, and then you have a number of methods that depend on that ref existing. for example, you have an method listening to some event, and calling a method on the ref based on the data emitted. i.e _myEventListener(data) { if (data === 'foo') { this._comp.thing(); } } render() { return ( &lt;Component ref={(comp) =&gt; this._comp = comp} /&gt; ) } You have no guarantee that the ref is set once the event is emitted, but if it is emitted, you would still want to call that ref's method once it's ready. I have this situation in a couple of place in my day-job application and deferred promises seemed to resolve it very nicely. constructor () { this._getComp = new Promise((resolve, reject) =&gt; { this._setComp = resolve; }); } async _myEventListener (data) { const comp = await this._getComp(); if (data === 'foo') { comp.thing(); } } render() { return ( &lt;Component ref={this._setComp} /&gt; ) } From the top of my head, can't think of a more elegant way to do this. 
My company has the same principle for Java code with `final` variables, but I'm not a really big fan. I like to keep `const` reserved with constants, like numbers and strings at the top of the file that aren't meant to ever change. I do not like seeing `const` variables in the middle of a function, it just irritates me, I always use `let` in those cases, even if I'm not going to reassign them. I don't use `var` at all anymore. Of course this is all my personal opinion and practice, you can always disagree.
What are you trying to do here, this code would work with all `let,var,const` so I assume there's more after this switch statement? If the intention is to use `a,b` after the switch statement, I would put `let a,b` at the top.
Also note that V8 isn't the only Javascript engine out there.
I understand your argument, but I think it works for you mostly because you're used to it. It's also a generally accepted good programming practice to declare variables closest to where you use them. This is something that hoisting violates, and why I also advise to drop usage of `var` altogether.
FWIW I believe const variables can be better optimized than let but I'm not positive on that, I'll have to do more research.
You should really look into why you need something like this. Odds are you should really be wrapping your function body in a Promise constructor, splitting up functions, nesting Promise constructors, or chaining Promises. What is your use case?
What about you just put free cloudflare in front of your server side rendered app and save yourself a ton of money on redis ram? 
That's a huge overstatement...the practice in the C family (and long advocated by Crockford) is to declare variables at the beginning of a function/scope.
I wonder why babel tells me I can't do that due to reassignment then... perhaps because we can't do that? And you don't always need all values of object, sometimes you only need few of them, and writing code which tells which ones you're going to use is cleaner. And I find using `var` cleaner, then using blocks or declaring at top.
That may be true for `final` variables in Java; but in JavaScript I would doubt there's a difference after transpiling my code into ES5. I'm pretty sure all my `let`s and `const`s for the most part are all transformed into `var` variables when I generate my bundles. You can paste this code into https://babeljs.io/repl/ and see that the end result for `let` and `const` are the same. function x (a) { if (a) { let b = 1; const c = 2; } console.log(b, c); } after transformation "use strict"; function x(a) { if (a) { var _b = 1; var _c = 2; } console.log(b, c); } I don't know what happens if `let` and `const` are natively supported though, my current engineering job requires transpiling all code for React Native.
This is the dumbest idea. Loops have these great tools like break that can be very useful. If you need a loop, use a loop.
I really ~~love~~ like honest remarks like "made with a keyboard" and "powered by electricity". 
I don't think those are good counter-examples. C before C99 only supported declaring variables at the beginning of a scope, which is why it was an established practice there for long. For newer C code that's no longer the case and in other C family languages (C++, Objectice-C, C#) it's never been a good practice to declare at the top of a scope. Crockford used to advocate it for JavaScript because pre-ES6 only had hoisting declarations, so in that case you might as well embrace it. Now that we have proper block scoping, he doesn't advise to do that anymore either. So no, I don't think it's a huge overstatement, given that the only languages you can use as a counter-example are following suit as well.
Sorry about that. When I made it long time ago it made sense in my head, then realised it wasn't appropriate at all. I also thought no more than 3 dev would see this repo :-S I ll try to update the the repo this weekend.
Thanks everybody for your positive and interesting/constructive comments. Reddit sounds like a nice place (compared to HackerNews). I'll try to come more often :) PS: A Vivus tool should come up really soon. I'll post it here.
[Brutal](http://i.imgur.com/EqYSm0p.png)
Did some testing myself and found similar results. My main concern is about inertia; how long will it take the community to shift, if at all? Also, it seems like (at least right now), Yarn is fully dependent on npm? All packages are still created via npm, and you even install Yarn via npm. So maybe the future of Yarn is simply as a "production npm"?
Babel takes care of that.
I personally prefer to avoid features, that are too different from other languages, if there are good alternatives. This way I can reduce cognitive load and save some time for important things.
Watch out, this is misogynistic. You don't want to go around hating women, do you? (Check the tweet replies)
Hey, your duration is way too high. Make it 200 and test again :)
Reddit also has amazing features for sharing content.
Like almost everything it depends on the size and interactivity of your project. But to answer your basic question: &gt; Are frameworks necessary in modern web ? No. They're optional, but will make your daily life easier. They come with a great set of tools and solutions and thus you don't have to implement basic logic yourself. That doesn't mean you shouldn't/ can't do it without a framework though. Using plain JavaScript you find yourself in full control of every aspect, but with the price of having to maintain a lot more. Pick what suits your requirements best. Personally, I write in plain JavaScript quite a lot if it's just a small project and won't become more complex in a foreseeable future. But if I know in advance the project has lots of interactivity, modules, and will grow in size and features I start with a framework.
Oh. That one. 
Could you clarify what you mean by "so much work"? You create a separate Node app and make AJAX requests to it. This is not different than integrating with any other server, like Rails. It's not even "integrating" because your React app is just a JS app, and it can talk to any server.
Yes, sorry, it's not an actual code I run, just a quick example to drive the point. For example, you have a React Native's text input that you want to focus once a socket is opened, but the connection is not the most reliable. It might connect before the text input is rendered, or it might connect 500ms after the input is rendered. In any case, you don't want to focus on the keyboard until it is loaded (you listen to the typed characters and send them over the socket, for example). 
Take a look at this article http://www.playfuljs.com/particle-effects-are-easy/
I don't get these people, really. Like a militant non-smoker sticking around in a smoking area.
Agree. npm3 hurt the Node/JS ecosystem big time. I look forward to its demise. The code for yarn is excellent and is statically typed with flow.
I hope the companies employing these people eventually realize it won't do them any good... I've already added Github, Salesforce &amp; Auth0 to my list of no-go companies simply because they hire people pushing their white-man-hating SJW bullshit onto others.
The original tweeter could have made the phrasing neutral. It would have been very easy to say "`npm install yarn` like getting your ex to move your new SO's stuff into your house"
I find a lot of people think async == parallelism, which might be why they're disagreeing with you
&gt; Two of those aren't even related to JS JSON spec is published as a RFC through the IETF. Anything that has to do with network connections, like Fetch, is checked against IETF working groups. The DOM is a W3C working group. The W3C is also working on a lot of web enhancements that can only be executed through JS. &gt; authoritative voices i like authoritative voices as I mentioned 3 and there are many more. The difference is that these are professional organizations comprised of experts as determined by the academic products of the individuals and their group contributions to the advancement of technology. It takes more than being a blogger or toolsmith.
[removed]
yarn is an alternative to npm. It is made a collaborative effort by multiple companies including facebook and google, so it is not something to be suspicious of. 
&gt;It was a joke and people should be allowed to make jokes without pointless backlash. But then how will non-tech people get careers in tech if they can't harass and shame straight while male engineers on Twitter for daring to speak like a normal person or having their own opinions?
There's a big difference between hipster development and actual viable prod/enterprise options.
That's because it was literally announced a few days ago and solves a lot of common pronlems people in team based environments encounter. It's extremely common for people to be excited about something new for a while after its first announced. This is like complaining that suddenly all your friends are Star Wars fans because they saw a trailer for the new reboot and it clearly looks good. 
Is it the name? Should they change it to Regurgitate? Repeat? Repeal the Corn Laws Now!?
I think the complaints are focused around a follow up tweet, not this original one.
&gt; including facebook and google, so it is not something to be suspicious of. _who would've believed that_
This is not meant to be a slight against JavaScript, but JavaScript is quite easy to write applications with. Its low barrier to entry allows you get pretty far *without* being analytical and logical, hence which trolls like this can make a living at it.
&gt; It's made by Facebook so I'm slightly wary. in collaboration with Google and Tilde (the people behind Ember, JQuery, Handlebars and RoR) and it's open source so there's really no need to be wary.
According to [caniuse.com](http://caniuse.com/#search=let) it is now supported.
It was a reply to a follow up tweet saying the new GF was better for being "younger, hotter". Annoyingly Twitter isn't very clear on what tweet follows what.
New http://xkcd.com/303/ is like: http://i.imgur.com/vnRqKQO.png
[Image](http://imgs.xkcd.com/comics/compiling.png) [Mobile](https://m.xkcd.com/303/) **Title:** Compiling **Title-text:** 'Are you stealing those LCDs?' 'Yeah, but I'm doing it while my code compiles\.' [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/303#Explanation) **Stats:** This comic has been referenced 796 times, representing 0.6058% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_d8x44wd)
'Server rendering' is what you're asking about, and while its possible with React, I don't think very many people are doing it, and that's not what the create-react-app is for. You can make 1 app server with 1 database. Then you have your React web app, Android app, and IOS app all talk to that same API
Why wary? Facebook also made React. Are you wary of that?
&gt; http://fortune.com/2016/09/13/salesforce-first-chief-equality-officer/ Well that sounds...progressive. I'm all in favour of equality but that seems a step too far and will probably be hijacked by nexxy and sycophants. I know her and her motley crew think they're doing good - I just struggle to comprehend how.
Oh, I think that may be my problem. I think it's doing it once per frame so my computer basically blows up and the fan turns on after like a minute. I'll make a fiddle soon.
You may want to keep going down that thread. http://imgur.com/wHMZsFL
Boy it sure feels good to have clean air in my lungs and not cancer! I love coming here! Don't mind me while I cough loudly into your drink!
https://github.com/marlun78/number-to-words
Read the license 
Not sure why you're being downvoted. If anyone had bothered to read the Polymer 2 preview notes, they ripped out a lot of stuff to use native APIs and native DOM and even mentioned it can be coupled with whatever data flow you want now, especially one way. Basically, Polymer 2 ditched dirty checking, uses ES6, and is more React friendly now. 
I probably retweet more than I compose own actual written tweets.
I think people get annoyed that judging a woman / partners worth based on age and beauty is a sort of objectification. So it's loving women, but superficially, I guess?
Emily Rose, lead developer evangelist at Salesforce. She felt that this tweet was misogynist.
Yes, but yarn fixes some of the issues they had with npm (mostly related to continuous integration). [The blog post](https://code.facebook.com/posts/1840075619545360) describes why exactly they decided to build their own client.
I just posted a blog post yesterday basically making this same point!
They explain their NPM problems in the announcement post https://code.facebook.com/posts/1840075619545360
Welcome to JS Innovation^^TM I understand where you're coming from but at least this is a black box change i.e. a swap out from NPM to Yarn. Just be thankful it doesn't require you to rewrite your entire application in the framework de jour.
Maybe it's her goal to become the Sarkeesian of web dev and people keep giving her the attention she needs to achieve it.
You do it to yourself. Up until recently the company I work for has been running nodejs v0.10, npm, browserify, bower, bootstrap and angular 1. I upgraded us to node v4 so we could make use of some es6 features on the backend. But, lo, our workflow hasn't really changed in 4 years except small iterative steps to make our lives easier.
Thanks for the constructive response. 
Just as any browser other than Chrome was created to fulfill the purpose of downloading Chrome
Here is the finished version my friend. http://codepen.io/jeffm64/pen/YGEvBg
We built Toolbeam (https://toolbeam.com), since we found it really hard to build any sort of ad-hoc tools natively on mobile. We needed something a bit more robust than a web app but one that we could share and update easily. The service is made up of 3 parts; a React Native app for iOS and Android, a Nodejs CLI and a backend API. The CLI pushes a spec to our API and the app renders the spec to the user. It would be greatly appreciated if people can play around with it and give us some feedback.
There isn't any. Also, for that you would need to use geojson layers, and you most likely won't have photo view either
Replace twitter with any other social network (including reddit) and you get the same stupid message. 
I'm a big fan of Kyle Simpson. I haven't read all of the YDKJS books, but I did read scopes and closures, and this and object prototypes (really good as well). I know Kyle feels the same way - that you shouldn't just wholesale replace your `var`s with `lets`. When I blogged about it, I basically just got downvoted. Hmm.
&gt; http://fortune.com/2016/03/08/salesforce-equal-pay/ Wait, so they found that out of the 1,000 or so employees that this affected that it was roughly half male and half female. &gt; In the post, she revealed that approximately 1,000 6% of employees required a salary adjustment, and “roughly the same number of women and men were impacted.” And then the article goes on to say that this closed the gender pay gap..... I mean, I'm not trying to start shit, but the fact that it was "roughly equal" means that there's little there to support that it was a gender-based pay gap... Unless I missed something?
Fuck that is perfect. 
29% of Salesforce employees are women. Given equal absolute numbers, the circumstances disproportionately affected women.
I wouldn't take the down votes too seriously. Seems that the JS community doesn't care for the hows and whys too much. I'm still working through the fourth book of YDKJS and it's really giving me such a strong appreciation for the language. I'm not zealously afraid of mutation now because I can understand more of the reasons for it and use it as a tool. Trends come and go but deeper understanding will get you a lot further. 
I would love to see it if guys when crazy when a girl tweeted: `npm install yarn` like getting your ex-BF to move your new BF’s stuff into your house
&gt; the fact that it was "roughly equal" means that there's little there to support that it was a gender-based pay gap... Unless I missed something? Perhaps the adjustments were almost all "down" for men (who were paid more before) and "up" for women (who were paid less)? "Roughly the same number" adjusted for either gender, but not necessarily adjusted in the same *direction* overall?
Ok, yeah that makes sense now. Stats are hard.
Were they giving pay cuts? I thought they were just bumping up, and not bumping anyone down.
That's awfully sheet sighted. This particular person was effective at getting someone removed from a speaking gig with a single tweet.
I don't know - the article only talks about "equalizing" pay and (at least some of) the employees receiving "salary bumps". It also says "if there were unexplained differences, salary adjustments were made for both men and women as needed", which is again skirting ambiguously around whether adjustments were "up and down" or "just up". Something doesn't add up here. As you note, if the adjustments were all up then the fact that both men and women were affected in equal measure seems to indicate it isn't an equal-gender-pay story at all - it's just a general equalisation of pay across the company (similar to salary-banding). If it does have a gender component (justifying the press about "equalising the gender pay gap") then presumably they would have had to revise a lot of men's pay down, or else the math doesn't add up.
I think it would be just as funny (which is to say, mildly) and applicable. The only difference here is that this would be seen as empowerment instead of misandry. For some reason treating ex-boyfriends like shit and expecting men to perform jobs involving physical labor is kind of the norm.
&gt;yarn install # Or `npm install` if you're old-school :) &gt;old-school :) well, that's slap in the face
Language support?
I've been down this road before. One thing you can take a look at is [firebase-queue](https://github.com/firebase/firebase-queue). It's fairly nice and provides a way for you to have worker threads react to data pushed to Firebase. I used it for a while but for my purposes I still ended up implementing a separate server with REST and SocketIO interfaces since one thing I needed my app to do is not so easily implemented in JavaScript and I didn't want to split the codebase into three parts instead of two. FWIW Firebase is still a great realtime database, but I find myself using it more and more as a database that clients can read directly instead of an entire backend replacement. EDIT: couple edits for clarity
Or, you know, they actually address and improve issues.
screw npm - &lt;script&gt;copy paste code&lt;/script&gt;
Maybe we could stop referring to pieces of software as girlfriends.
Can't you do that with let? 
Interesting! Could you explain how to make the code wait till after the the div's position is declared before the code stores the position? Would I wrap the whole code in a $(document).ready? That didn't seem to work :( And I think I understand what you mean with the array.join, does this work? var coords = ['M ', 'startx', 'starty']; var correctPath = coords.join(', '); 
In the case of yarn they tried that first and weren't able to accomplish what they needed. Elsewhere you can't just snap your fingers and force project maintainers to accept you as a contributor. Many tend to get standoffish when you assert that they're project should go in a different direction altogether.
&gt; I think people don't understand what misogyny is. Agreed! &gt;Misogyny means hating women. Being attracted to young and beautiful women doesn't mean you hate women. That's actually a very natural thing to be attracted to. And case in point.
I want to break up with Angular2, but she made me build my life around her lack of a document ready hook.
`const` master race!
Well, if you hate ES5, then I don't see why ES6 would convince you to fall in love with the language; there's a couple new things (classes, short-hand/pointer-like functions, template strings, groundwork for module loading, array map/filter/reduce, etc), but it's hardly anything ground-breaking from ES5 - just some conveniences to make developers' lives easier (good to note most browsers and even Node don't fully support ES6 yet, although I write 99% of my code in ES6/stage-0). As far as tutorials that show you how to create an application from scratch; there really isn't a tutorial I can think of that will show you 100% bleeding/modern-dev techniques and how to deploy it, set your environment, etc all in one single tutorial =&gt; you will more than likely need to pull from multiple tutorials to determine how you would like your build/dev-environment to be structured (that's primarily how I learned). The client-side web development process has not evolved much in terms of deployment/coding practices for the past 5-10 years; what has changed drastically are the build tools, frameworks, etc. used to build the apps. Ultimately, no matter what tools/etc you use, apps are still compiled down into files/images/assets + HTML + JS + CSS and served by a back-end. From the sounds of it, you want to build a SPA (single-page-application) with a potential back-end and/or API to query. This is a pretty common scenario and you can find examples all over google if you simply search "single page application web development examples". React + Redux + ImmutableJS are great for these types of SPA's mocked with multiple views/routes, but probably a bit advanced to jump in to if your base-JS is still lacking. As far as the build environment that I believe suits front-end developers very well; I would recommend using NodeJS for your basis as your task runner, build environment, plugin manager, etc. From there, you can choose which frameworks/languages/etc you would like to integrate (such as react, angular, or just base ES6 with babel, etc). Additionally, you can utilize Node/npm to setup webpack, which will basically contain 90% of your config and setup a local environment to serve your assets, have hot-reloading, etc. Hopefully that gives you an idea of where to start learning modern front-end development =&gt; it's a long &amp; opinionated journey out there - good luck!
That should be fairly simple to do. I'd just try with a 2d canvas to start, and if you aren't getting the performance you need, maybe look into webgl.
I've been noticing that lately too. It's been around for a while, but I just started to identify it. People act like something they don't like is a direct mortal insult to themselves and their family. And they do it for everything. Their reaction is either "meh" or visceral hate. Not everyone does it, but it's definitely a thing that a lot of people do. 
Is there a video with Kris's talk about that? I can find only the PDF presentation.
Quick Question: Sorry for being ignorant but is ES6 being used by modern browsers yet and where is a good espanation for it? I've never heard of let before but it makes sense.
Personally, I just find it easier to think in object oriented ways
You're jumping through hoops - replacing the standard loop body, a block statement wrapped in `{` `}`, with a function `wrapper` - to get around the fact that `var` scoping only works on functions, not block statements. With scoping that also works on block statements you can skip the `wrapper` dance and just move that function's body inside the `for` loop. Also, that `var i = index;` is unnecessary, just reference `index` from `wrapped`. As is the function around `wrapped();`, just call `setTimeout(wrapped, 100);`.
What I mean is that in the partial code snippet you pasted, you are referring to the `left` and `top` variable on the first line in what I presume is an`if` statement. I'm also guessing you've declared these variables earlier in the code. Then in the else statement you declare those variables again and assign a different value. You might fall into the trap of thinking that `left` and `top` only get these values if the `else` statement is executed but declaring `var` in `if`/`else` statements [doesn't work like that](http://stackoverflow.com/questions/11532072/defining-javascript-variables-inside-if-statements) I'm guessing `left` and `top` have the value `undefined` by the time they execute on the first line and that is the source of error. **TD;DR** Always **declare variables at the top of the scope** and then assign new values if you need to in`if`/`else` statements. Naturally, this code won't work if it's executed before the document has finished loading and the elements have their position, so this code needs be wrapped with $(document).ready I mean that `correctPath += ['S600', (top-0), (left-0), top].join();` Is the same as `correctPath += 'S600,' + (top-0) + ', ' + (left-0) + ',' + top + ' ';` So what you wrote looks correct. This syntax is less prone to type errors, missing `,` etc.
Have you read her past tweets? That woman is a nut. I can say that because she several times admits to having or being affected by mental illness.
I think that should be mentioned in the article. For most the applications i have built, there are too many users for this type of approaches to make sense. Even if you want to roll your own, varnish makes more sense that redis here and will be both cheaper to operate and can have a disk fallback. Cache invalidation is possible with a simple http request and a few lines of config. Edit: varnish, not vagrant
- Yarn is fully dependent on npm? No. They use the npm registry to download packages, there is no need to create another main package repo. But you don't need the NPM cli tool. - All packages are still created via npm, and you even install Yarn via npm. That's wrong. You don't need to install Yarn with NPM, in fact, the recommended method is not NPM. As I said before, there is no need to create another registry, why not use NPM to host packages?
Go with Koa + middlewares. I recently created one awesome router, exactly for REST APIs cuz I need it. https://github.com/tunnckocore/koa-better-router - I'll just publish v1.2 tonight. https://github.com/tunnckocore/koa-rest-router - after v1.2 of above will publish stable v1.
Right, but when did you last hear a short man joke? There's a biological reality for both genders, but our society echoes the message about women needing to be young/beautiful very loudly, while it echoes the message about men needing to be tall *much* more quietly. Plus, if someone made a joke about trading their short boyfriend NPM for the taller Yarn, while I certainly wouldn't get offended (I'm neither short nor easily offended), I would feel bad for every short guy reading that joke and feeling worse about themselves. 
I started with duration at 200, and it flashed to completion in an eyeblink, so I tried cranking the duration way up to see if that would resolve the issue. Didn't help (still finishes in an eyeblink )
It really isn't - Twitter is less like classifieds and more like propaganda.
What do you feel is lacking about your current stack? If you're comfortable with it, it'll get the job done. That'd be my personal preference (though I've landed on using `hapi`). It kind of sounds like you're asking for something like Loopback, which essentially takes an ORM and generates all of the GET/POST/PATCH/etc... routes from each model? While that does sound appealing in theory, how many of those routes/methods would you really use? Feathers.js might be a middle-ground. It comes with JWT authentication and the ability to switch between realtime updates and normal requests for each resource. It supports several ORMs and database libraries, so you should have the flexibility to add custom stuff.
Do you know how can I return the value of the fetch?
Nope, I've moved to react. When needed, I'll call the native api's. This approach is really not hard as it seems, keeps me from being dependent on the firebase folks (as I was with backbonefire), and makes debugging way easier as there is less "magic" happening. As an aside, the decoupled approach will also make it simpler to move off FB totally, which I hope to do soon.
Windows Defender is worthless. It eats up so much system resources and just barely gets the job done. It's one of the reasons I stopped using Windows altogether. Even when you try to disable it, some pieces of it still linger in your system. I hate not having that control over my own computer. That's why I'm full Linux these days.
JS devs aren't really fans of webcomponents and especially Polymer. If it ever takes off, it means way less JS happening in the browser. So you're not really going to get any unbiased responses here about it.
Not a bad way to go about it for most cases. I would challenge you to think critically before changing your `const`s to `let` though to see if a different refactor might be more beneficial.
Thanks for the reply. I will look into Koa and this middleware for sure. I've been reading good things about Koa lately on this subreddit.
The value doesn't exist yet because of the asynchronicity of fetching data. This is how you can access the value (once it's available): https://jsfiddle.net/Ld9eLrfz/ Or you could pass a callback to be executed on success: https://jsfiddle.net/Ld9eLrfz/1/
Here is my code // The amount of circles we want to make: var count = 150; var rectangle = new Rectangle(new Point(7.5, 7.5), new Point(12, 12)); var cornerSize = new Size(2, 2); var path = new Path.RoundRectangle(rectangle, cornerSize); path.fillColor = 'pink'; var symbol = new Symbol(path); for (var i = 0; i &lt; count; i++) { var center = Point.random() * view.size; var placedRectangle = symbol.place(center); placedRectangle.scale(i / count); } function onFrame(event) { for (var i = 0; i &lt; count; i++) { var item = project.activeLayer.children[i]; item.position.y += item.bounds.height / 15; if (item.bounds.top &gt; view.size.height) { item.position.y = -item.bounds.height; } } }
Here is my code: // The amount of circles we want to make: var count = 150; var rectangle = new Rectangle(new Point(7.5, 7.5), new Point(12, 12)); var cornerSize = new Size(2, 2); var path = new Path.RoundRectangle(rectangle, cornerSize); path.fillColor = 'pink'; var symbol = new Symbol(path); for (var i = 0; i &lt; count; i++) { var center = Point.random() * view.size; var placedRectangle = symbol.place(center); placedRectangle.scale(i / count); } function onFrame(event) { for (var i = 0; i &lt; count; i++) { var item = project.activeLayer.children[i]; item.position.y += item.bounds.height / 15; if (item.bounds.top &gt; view.size.height) { item.position.y = -item.bounds.height; } } }
blocked me as well for (respectfully!) challenging her “proof” for crockford’s alledged misbehavior
Yea, koa definitely worth looking, Feathers too. Feathers uses socket.io behind the scenes for the realtime. We also have `koa.io` (which I should move forward soon, cuz I'm current maintainer) in the koajs organization.
[angular](https://angular.io/docs/ts/latest/tutorial/) offers a pretty in depth tutorial that results in a "complex" app.
furthering the analogy, she called the only idiots dumb enough to listen to a crazy person calling up numbers in classified ads.
You *can*, but you will never know when it has a real value: https://jsfiddle.net/Ld9eLrfz/2/
Hmm I see. Is the nature of promises... Would you suggest anything else to accomplish what I'm trying to do here? Just a method to call the API and assign its value accordingly to some if statements.
`latOrLong` is the value of the Promise returned by `getLatitudeOrLongitude()`. The full code looks like this: function getLatitudeOrLongitude(url, LatitudeOrLongitude) { return fetch(url) .then(response =&gt; response.json()) .then(data =&gt; { if (LatitudeOrLongitude === 'latitude') return data.results[0].geometry.location.lat else return data.results[0].geometry.location.lng }); } getLatitudeOrLongitude(url, 'latitude') .then(latOrLong =&gt; { console.log('RESULT: '+latOrLong); }); 
Once you start with Promises, you have to continue with Promises. If you don’t like this coding style, take a look at the co library or async functions (which are part of ES2017): async function getLatitudeOrLongitude(url, LatitudeOrLongitude) { const response = await fetch(url); const data = await response.json(); if (LatitudeOrLongitude === 'latitude') { return data.results[0].geometry.location.lat; } else { return data.results[0].geometry.location.lng; } } async function main() { const latOrLong = await getLatitudeOrLongitude(url, 'latitude'); } main(); More info on co and async functions: http://www.2ality.com/2016/02/async-functions.html 
jesus i almost feel bad for people like that. how unhappy of a person do you have to be to do that over something a stranger on the internet said
&gt; What exactly is the misogynistic part? Well, woman complain about lack of good models for them and the whole crazy ex gf trope is a major example of it. &gt;If the OP was a female and the tweet said BF instead of GF, would it still be offensive? Well, the misogynist part comes from the fact how society portrays woman in most media. If you google search 'bad boyfriend trope vs 'bad girlfriend trope' you'll see the second term has much more results and examples than the first one. It's obviously misogynist because it shows a reflection of how woman are portrayed in society in general, but it's not the kind of prejudice an older person would exhibit. 
Thanks. Wanna start some project involving firebase, looking for best way using it.
`latOrLong` **is** a variable. You can, in principle, assign it to an outer variable: let outerVar; getLatitudeOrLongitude(url, 'latitude') .then(latOrLong =&gt; { outerVar = latOrLong; }); **But that is rarely a good idea.** Normally, you just move forward, passing on `latOrLong` to the next processing step: let outerVar; getLatitudeOrLongitude(url, 'latitude') .then(latOrLong =&gt; { nextProcessingStep(latOrLong); }); 
&gt;Well, woman complain about lack of good models for them and the whole crazy ex gf trope is a major example of it. Except the original tweet doesn't mention anything about the ex's sanity. You are assigning unspoken meaning to the words based on your own biases. &gt;Well, the misogynist part comes from the fact how society portrays woman in most media. Which you then further along here, by explaining where you're getting the unspoken meaning from, which is not driven from the context provided by the tweet itself. Applying context when no context is given is not safe. Here's a fun example of this... Based on the image of the original poster, I can assume he's a young white male, likely living in America. Based on my understanding of America, I can assume he's a Christian. Based on him living with his girlfriend, I can assume he likely has sex outside of wedlock. Based on my understanding of commonly held Christian beliefs, I can assume that this means he's committing a sin and thus is going to hell. Now, I can take those claims and say, "Well clearly he's a sinner who's going to hell." Except my explanation is based on my own biases and not the actual truth. The truth is that I applied my own logic to draw conclusions without any defining context. That's the same thing that's happening here by assuming that because he mentions an ex-GF that the ex is by definition "crazy" and this tweet is misogynistic. &gt;It's obviously misogynist because it shows a reflection of how woman are portrayed in society in general Except, it doesn't. You assigned your own context to it in order to shape it into something misogynistic just as I assigned my own context to shape it into a declaration of sin.
[removed]
I've only been on vacation for 3 weeks and I come back and the nodejs crowd has decided that grunt-&gt;gulp-&gt;webpack wasn't enough, and now you're all replacing npm! What next, Python for Babel?
You can replace var with let in your example and it does the same thing. Also, if you run this in a script on a page, you now have a global variable `window.i`due to the var in the for loop.
That's an argument? You should play by other people's rules even when that means lost time and productivity over other options? That makes no sense. The yarn team explored their options and determined that creating a new project was more economical in terms of time and effort than retrofitting npm. It's not their responsibility to make sure there's only one package manager, so they did what was best for them.
I can't seem to get Yarn to install global packages. I get no error but they just aren't there (npm works). Also, it proved to be less reliable in installing some open source packages I've been using. I would get random errors or non-functioning software with Yarn, but npm would work flawlessly. At least IMHO, I'd rather wait a few more seconds and not waste time trying to debug what didn't work than using Yarn.
Before joining Facebook I used to work at Cloudflare, before the launch I synced up with some friends to see if they could help us improve global performance of the npm registry. Not much has been done yet but once we do we'll publish something about it. It was a kinda last minute dealing but we wanted to get the proxy setup and the client pointing to it ahead of launch so it wouldn't be a breaking change later on (registry URL is stored in lockfiles so it would be a breaking change).
Dude, thank you! Seriously. Between your books and site, es6 was so quickly adopted in my workplace. Keep being awesome! 2ality.com for those curious
[Fuck me](http://i.imgur.com/UEBaj4R.png), I think we need another cold war. Our generation is doomed. 
Still a bad comparison but I agree with your point.
Best for them in their opinion. Apparently their opinion is not the same as those of npm. But that's a question of who is right. Just because they created yarn doesn't mean they were right and more people thought they weren't. However, who will decide who was right? Usage and time will.
[Update as needed](http://www.lolroflmao.com/wp-content/uploads/2011/08/Internet-Explorer-10.jpg) 
The official API is supposed to return objects, which it is when I try it. But when I use their official node module for making the calls it somehow returns promises. I have looked in the source code and it makes calls just like I do so I have no clue what's going wrong. 
It's not a question of who was right. They don't need this to become a popular tool for it to be worth their investment, it already is. They aren't banking on it being better or more widely adopted than npm, only that it was the best way to accomplish what they needed to accomplish. If you don't want to use yarn, then don't use it.
after your class definition you need a 'return Plugin;' On line one you need to add (to the start of the line) 'var Plugin=' (so its like 'var Plugin = (function ($) {' ) Then later down you detect which export you want to use 'if(typeof(exports)==='object' &amp;&amp; typeof(exports.module)!=='undefined'){ exports.module=Plugin; }else if(typeof(define)=='function'){ define('Plugin',[function(){return Plugin;}]); } [EDIT CLARIFIED] var Plugin=(function ($) { $.fn.pluginFactory = function (config) { let $this = $(this); return new Plugin($this, config); }; class Plugin { constructor($this, config) {} } return Plugin; })(jQuery); //I might be a little wrong below due to spelling or API implementation errors if(typeof(module)==='object' &amp;&amp; typeof(module.exports)!=='undefined'){ module.exports=Plugin;//require1 }else if(typeof(define)=='function'){ define('Plugin',[function(){return Plugin;}]);//require2 } // or safer var Plugin=(function ($) { // ... return Plugin; }); if(typeof(module)==='object' &amp;&amp; typeof(module.exports)!=='undefined'){ module.exports=Plugin;//require1 - later var Plugin = require('Plugin')(jQuery); // var myPlugin=new Plugin(); }else if(typeof(define)=='function'){ define('Plugin',['jQuery',function($){return Plugin($);}]);//require2 }
It even says so in the page footer, so yes.
I would compare "messages" approach with jQuery approach. In other words, you have an event, user make (or dispatch) an action and you deal with it in the handler, the same data flow in jQuery and "messages" approach, right!? However, it's a fragile solution, doesn't scale well and so on... This's why now we have MVC/MVVM/Flux and Redux patterns to build frontend apps. So, you can use messages to provide data between different part of webextension but it's the same as to use jQuery for frontend in 2016. Of course, jQuery makes very well its job and if you don't have any problems with your current architecture/approach - you don't need Redux, you don't need to change anything :)
Eh as I said mostly a joke. But the speed difference is the major factor. For most of major version 3, NPM 2 was actually a lot faster. Then the whole progress bar thing. As of now though NPM 3 is quite nice.
Same for me, also `chrome://inspect`
`let` and `var` are only of equal performance for trivial cases where `let` can be provably replaced with `var`. In all other cases, you need to account for the TDZ which necessarily tanks performance (I don't think you can solve all cases because of the halting problem). As it currently stands, simply doing `let foo = 'abc', bar = 'efg'` will make v8 deoptimize the entire function and I would guess (without taking the time) that any other non-trivial occurrence does the same at the moment. TDZ was a mistake. It removed the wart of const being either undefined or a constant value, but created another host of issues in return.
https://jsfiddle.net/Ld9eLrfz/4/
I can't get your problem, srsly
Why use `let`? If your block var has a unique name, then storing it in the function scope isn't bad and not having an extra closure lookup potentially improves performance (things like the Google closure compiler go to great lengths to perform this optimization). The other case is looping where you want unique closures for each iteration, but this is already handled by lambdas which have the bonus of being explicit rather than implicit (the ES4 let block would have been much better). Then there's the TDZ screwup which made `const` constant (rather than `undefined` or constant) in exchange for something that can't be statically analyzed except in trivial cases -- most of which are served just as well by `var` (seriously, with `let` there is the potential have use before define errors that are present in code for years before the right combination of input gives you a heisenbug). Then there are other fun things to learn. For example, very few JS devs I've met using ES6 know that it creates an intermediate scope between the calling function and the called function that is responsible for setting up variables named in the paramters. They also don't know that these variables actually use `let` and that the parameter intermediate scope has it's own separate TDZ before the final values are passed to the actual function. ES4 let blocks were explicit and handled the only real case for `let` rather elegantly (that is, loops) with the additional bonus of being easy to think about in terms of a lambda (and no TDZ to worry about). A decent [article](http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified/) on TDZ in general.
Be a middle-aged woman and talk about what you would let a sexy shirtless group of teenage vampire/werewolf boys do to you and no one bats an eye. But be a middle aged man talking about teenage Miley Cyrus and see if the same middle-aged women give you an ounce of respect.
Don't say that his/its, it's wrong and offensive. Even if she's a lunatic (and she definitely is, based on the whole Douglas Crockford episode), it's like using the n-word because you're mad at one black guy.
I think when you embrace online culture wars as your identity, you start to find enemies anywhere you look, you find provocation even in innocent comments. Look what happened with Ken Bone. It wasn't enough that he's a decent person, with a post history showing nothing but compassion and empathy to others. The online warriors still managed to ignore all of that and isolate 2 reasonable posts and make a monster out of him. I think if nexxy was mentally healthy, and had an identity and hobbies other than Twitter warfare and drama, this never would have happened. 
Ive made a function in which a nodejs module is used to make API calls. The function is asynchronous while the API call of course takes some time, ad the function will end before the API response is received
Hi /u/MrWackyGuy, this is /r/javascript. Despite the similar names, Java and Javascript are worlds apart -- you might try your luck in /r/java.
Option 1 includes both versions in the output. Option 2 doesn't understand that the function can be removed. So both include a ton of unnecessary code in the output.
* comment about girlfriends * comment about how comment is offensive * comment about how comment about how comment is offensive is offensive
Why does TDZ necessarily tank performance? Do you have a source? How do you know this? Do you have a reproducible benchmark?
I've used it recently. It's very good. 
Artists name checks out. 
Imo, by and large... don't. Do something with the value via a function. Get out of the habit of keeping a bunch of mutable values around you assign things to: if you need to update an app state, then keep track of app state in one principled place, and use functions (like callbacks to then) to update it in a standard way. Don't get into the habit of thinking you even need some way to get values back "out" into an outer scope, assigned to some lone variable. To a Promise, the outer scope is in the past. Effects chaining off of promises should deal with altering an app-wide running record of the present. It will help organize things better and things easier to refactor later.
I believe you've made a mistake by saying Java and you actually mean JavaScript - the two are different languages. From your post it also sounds like you're looking for a jQuery solution. If all of that is correct then you're looking for the [contextmenu](https://api.jquery.com/contextmenu/) event.
I don't know if anyone has actually done the math, but the issue is fairly widely known. [For example](https://github.com/babel/babel/issues/563). Intuitively, the issue with static analysis is that it seems to require running every branch up to the point where you can guarantee let is not used before it is defined for that branch. If the branches can recur/loop in any way, then that is the halting problem. A decent [article](http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified/) on TDZ in general. EDIT: Given that you cannot statically validate (except for those easy cases which are essentially the same as var), the only option is to dynamically validate which means that you must naively check every access for undefined -- well, not quite because `let foo = undefined;` is a definition, so you have to have another behind the scenes undefined to compare against. Think of it like boxing a variable in Java. A sufficiently smart JIT could sort through it's code and remove all the `if (isAlreadyDefined(foo))` boxes after the variable is defined, but the cost of going through the code would probably be higher than the check itself (except for the edge cases where it defines right before a highly optimized loop). If it chooses not to unbox them, then the overhead is the same kind of overhead you'd expect from boxing in Java except that this box always has a branch that is inherently hard to predict.
I get what you're saying. But lets look at in reverse. How many javascript programmers know ASM or C? How many of these people are aware that memory management, as in arranging memory addresses to link to one another in linked lists or tries, is an amazingly fast and organized technique that consumes very little resources? Ok, now you have OOP. and this is great. we're making some real complex things with less lines of code. But we can't optimize how those objects are made, stored, or processed by the system. In fact, those objects have extra padding and index just to make them work properly. Some of this is good. Private stuff, garbage collection, con/destructors, etc. Some of it is bad, like extra work and the loss of being able to make complex condensed memory mapped storage with minimal instruction. This would come in handy for memory sorting and checking. (we lost our procedural programming perks) Now we're going functional, where we just reference the type and idea to do a type of function. But now we can't create, optimize, or change the kind of objects we're working with. It's like being stuck with a certain set of lego pieces when you really need custom pieces. (We lost our OOP perks) I do understand as we go upwards we get a bigger grab at managing much more complex systems and ideas. Programming a data processor for 1000+ cores would be much more simple with a functional program than an OOP. Programming the organization of 1000 processes would be much more simple in OOP than procedural. Just programming "Hello World" is much easier in procedural than ASM. And well, even ASM is better than filling out paper punch cards right? #I honestly believe the reason computers are so bloated with memory requirements is because we're so far away from the basic cores of the computers. But maybe because manufactoring gives us an insane amount of memory, we don't need to be perfect with our code anymore.
&gt; why not just add prepare and make people who want both pre-npm publish and postinstall use that. It Because it would break backwards compatibility as soon as npm 4 was released. With their plan, you at least have a whole major release to switch to the new method.
There's nothing misogynistic about this joke. A female could make the same crack, and it would make even more sense since guys usually do the heavy lifting...wait, was that statement misogynist? This is the kind of bullshit that makes people tune out to actual issues with sexual discrimination in the workplace and gives feminists pushing for equality a bad name. And she just has to be hot shit in the javascript community. Why couldn't she pick something like Ruby to throw Well, this is going to be the thread of the week again. She sounds like a joyless wretch, and she's doing more harm to her cause than good by constantly crying wolf. All it accomplishes is people muting their words when aorund her.
There's also an FAQ at https://code.facebook.com/license-faq
Have you tried codewars? They do fairly decent challenges.
 function bar() { var foo = 2; setTimeout("console.log(foo)", 100); } bar(); What gets logged to the console?
Wow, these are pretty awesome!
Hopefully some sort of warning telling you not to pass a string to setTimeout like a crazy person. Apparently not. 
The official API is returning correctly, it's the request library that's giving you back the promise. you just need to resolve it with `then`. What are you using to make the request? Whatever it is, it's likely something along the lines of `request(url).then(data =&gt; // your data object)`
what hacky shit is passing a string to setTimeout
 function number_string(){ var numbers = ["One","Two","Three","Four","Five","Six","Seven","Eight","Nine"]; return numbers; } Why do you have a function that doesn't /do/ anything? It just returns an array. You should be storing the array as a const somewhere so that you aren't unnecessarily calling functions. num = (humanize_ten( parseInt(num/10)-1)+" "+number_string()[(num%10)-1]); Don't ever modify the prototypes of built-in objects. Especially with enumerable properties. String.prototype.humanize = function() { // ... } And since you didn't wrap all the code in an IIFE, you now have 5 functions (some of which are useless on their own) that are exposed to the global scope. Wrap your code in an IIFE and return what you want the user to be able to use. var func = (function () { // code goes here. return _func; })();
Have you ever heard of Napeoleon Complex? There is an entire, widely held and discussed stereotype of short men being domineering overcompensators. (Even though Napoleon himself wasn't a short man). How about the phrase "Tall, dark and handsome"? Or the massive statistical over-representation of tall men in positions of leadership. Or the open mocking men who wear lifted shoes get? All these things exist, and nobody makes a big deal about it, because ultimately it's not a big deal, and people shouldn't be basing their self worth on something as trivial and uncontrollable as their height. So as a short man, if the joke were to be reworded to be Ex-BF, or short Ex-BF, or short EX-BF WHO LOOKS EXACTLY LIKE YOU {JORDAANM}, THIS JOKE IS EXPLICITLY REFERENCING YOU!, it would be just as funny, because the nature of the joke hasn't changed. It's still a joke comparing impolite social etiquette to software practices. The point of the joke is that asking an Ex to do this thing is being rude to them.
That's what I'm doing to make it work yes. Now I realize that that's needed with promises. I should be able to use the official library now. Thanks lol I'm an idiot (but I never use promises so I have an excuse :p)
I never code in the global scope so this should not happen, until you simply copy paste this to the window scope.
Now that I have read the tweet closely, I find that **@nexxylove was actually trying to attack @DamageLimiter** (not @IamDevloper) for saying &gt;The ex-GF wasn't my GF yet. Before it could have gotten real between I was introduced the next candidate... younger and hotter! which is actually misogynist. But somebody on twitter assumed otherwise and everyone followed suit.
I was at the summit - was an awesome event with some great talks. The one about tooling and polymer 2.0 under the hood are probably the best 2. 
Thank you! It is a very simple algorithm, but it turned out well, mostly by accident of course. The whole idea was to test creating html canvas entities with JSX.
You mean components like Blutooth? This has nothing to do with polymer - you can do same elements in 1.6 - it really depends on the API's that browser supports.
This is valid javascript since forever. It is not recommended though.
There’s more discussion about this in the issue, BTW: https://github.com/npm/npm/issues/10074
Evangelists should be purged from this industry.
Firefox was "inspired" to implement the same feature recently.
Build a new version of React while engaging your core. 
You don't see it so much because its not very well supported in babel. https://babeljs.io/docs/usage/caveats/#classes I don't think there's a whole lot you can really do with this that can't already be done with composition. The species support also restricts you to the constructor signature of your superclass. I think Array subclass instances, for instance, are created with a 0-value length argument when using Array methods
Since most new features don't hoist, exports at the bottom makes the most sense.
On Node.js (as @senocular mentioned, I wouldn’t use it on browsers, yet, because this feature needs to be supported by the engine; it can’t be transpiled), I used it to implement a queue: class ArrayQueue extends Array { enqueue(value) { // Add at the end return this.push(value); } dequeue() { // Remove first element return this.shift(); } } Delegation is a cleaner solution here, but you also need more code to implement it. In general, I like that subclassing enables you to non-destructively add methods to Arrays.
Hi /u/Mrkickling, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
A little late to be writing about this isn't it?
lol
I'm going for the "article about xxx fatigue" fatigue, recursively, ad libidum...
Nice! I made an [array subclass that can switch from being dense/sparse](https://jsfiddle.net/dmq8o0q4/2/)
The library uses ES6 Proxies to catch usages of properties and methods, and retrieve the result from Redis. It seems to work fine with normal usage (see `test.js`), however it has a very strange bug: you can't do `.splice` on an array of objects, contained in an object. What is interesting is that the exception is not thrown in the library, but in Redis: at some point in `/node_modules/redis-parser/lib/parser.js`, an internal buffer no longer exists. I have absolutely no clue why this happens, considering that all requests I make to Redis are simple GET/SETs on keys. I'd be very happy to see this issue fixed and understand where was the problem; this bug puzzles me so much that I'll even tip you a few euros if you manage to find a solution.
It looks like the native implementation of slice is causing Proxy "get"s to be called which could wreak havok. I would suggest adding some logging into the library and see what all is trying to be pulled from redis.
So the easiest way would be to include a `bool` `isLoggedIn` in your state, and then you test that first when they try to edit: songs_edit_click = (event) =&gt; if (!state.isLoggedIn) return; //stop from editing //... proceed so there is state when they are logged out, because state is everything `mutatable` that you need to render and interact with the app, but you use the state`isLoggedIn` and authorization to keep the user away from the rest of the state. The logged-in `cookie` or `session` stuff is actually part of the HTTP state (backend) too. **sharing state:** your suggestion about a different component for editing is actually a good one. it may give you way cleaner code, or it could be a PITA. I haven't seen it before though with react (most people just mash both together), feel free to try it out. You can of course replace the original element with `element.replaceWith()` (iirc) or jQuery, and copy all the props by doing like `&lt;SongListEditable ...some props&gt;`, sharing state is a bit trickier, I would create a method for that if theres not a built in react way. getting current-state if its inbetween mutations, you have to use a callback, so something like this is used. //psuedo code, not sure about vanilla replaceWith //get current state and make new object my newElem = React.create('&lt;SongListEditable/&gt;') this.refs.songListKey.replaceWith(newElem) this.setState( (actualCurrentState, props) =&gt; { //callback newElem.setState(actualCurrentState) //or just the items you want newstate = { item1: actualstate.foo, item2: actualstate.bar } }) in other words its possible but you have to do your own engineering, i dont think its out of the box functionality. cheers
You've got a couple options here. As far as your original question, yes you can use the object literal pattern to reduce globals. But here, we might as well make `house` its own object and not use any globals (except `house` itself). Original: var house = { bedrooms: 2, bathrooms: 3 }; function alertBedrooms() { return "The house has " + house.bedrooms + " bedrooms."; }; function alertBathrooms() { return "The house has " + house.bedrooms + " bathrooms."; }; Object literal pattern: var house = { bedrooms: 2, bathrooms: 3, alertBedrooms: function () { return "The house has " + this.bedrooms + " bedrooms."; }, alertBathrooms: function () { return "The house has " + this.bathrooms + " bathrooms."; } }; //usage: console.log(house.alertBedrooms()); // "The house has 2 bedrooms console.log(house.alertBathrooms()); // "The house has 3 bathrooms Module (prototype? not sure what to call this) pattern: var House = (function () { function House(bedrooms, bathrooms) { this.bedrooms = bedrooms; this.bathrooms = bathrooms; } House.prototype = { alertBedrooms: function () { return "The house has " + this.bedrooms + " bedrooms."; }, alertBathrooms: function () { return "The house has " + this.bathrooms + " bathrooms."; } }; return House })(); // usage: var house = new House(2, 3); console.log(house.alertBedrooms()); // "The house has 2 bedrooms console.log(house.alertBathrooms()); // "The house has 3 bathrooms
JavaScript interpreter that interprets JavaScript source code and executes the script accordingly. Google’s open source JavaScript engine. JavaScript language that compiles into JavaScript. JavaScript representation of the user-interface logic is written in JavaScript, and JavaScript dispatches requests for information such as PDF documents, site-specific browsers, and desktop widgets. Javascript Javascript. Javascript.
&gt; The result of that one simple line is a 13-16% difference (I ran it about 10 times with consistent results on Chrome 54 OSX). I'm still on Chrome 53 at the moment and on Windows, but I get vastly differently results. They differ by only 0.57% (var was faster by 0.57%). I'll update and see if anything changes. It's also worth mentioning that we're testing buggy code. The ternary operator will never take the truthy path, and if ever it did, it would result in a reference error, as it should.
&gt; Hmm.. How would you do that? If there's a way I can do this without the class crap I'd love to know That just means having your object contain an array rather than be an array. You can decide the public API of this object, whether it needs to match Array, or be a subset of it, and operations related to the array part of your object transfer over to the array defined within. function Stack () { this._array = []; }; Stack.prototype.push = function(){ return this._array.push.apply(this._array, arguments); }; Stack.prototype.pop = function(){ return this._array.pop(); }; Stack.prototype.toString = function(){ return '[' + this._array.join('|') + ']'; }; var stack = new Stack(); stack.push(1,2,3); stack.pop(); String(stack) //-&gt; [1|2] Arrays are low level enough that its generally easier stick to a more functional approach with libraries like lodash if you need extra behavior, since it would take extra work to convert arrays from different sources to your specific array type. var arr = someObj.someMethodReturnsArray(); let last = _.last(arr); // vs. let myArr = MyArray.from(arr); let myLast = myArr.last(); &gt; No, subclasses of Array are Arrays but with a subclass prototype. They work just like a normal Array, just with the modifications to it. Which I think is what is so cool. Is this in reference to the species comment? What I mean by that is, when you subclass something like Array which supports species (superclass methods that produce instances of the class that use the subclass's constructor, or whatever is defined for Symbol.species), you need to make sure your constructor supports creation through those methods. Array.map, for example, returns a new array. But if you extend Array, and you call it from an instance of that subclass, then by default, it will return a new instance of that subclass. Since that instance has to be created internally within the native map implementation, you need to make sure it works for your subclass. As an example, lets say you want to make an array subclass that _must_ have 3 or more elements: class Tripod extends Array { constructor(...legs) { if (legs.length &lt; 3) { throw new Error('Tripods must have at least 3 legs (preferably exactly 3)!'); } super(...legs); } } This is fine until you try to use an inherited Array method because it will attempt to make your instance without the required legs: let trip = new Tripod(1,2,3); // ok let mappedTrip = trip.map(x =&gt; x + 1); // Error
That sounds cool. But I guess there's a part of me that will always be suspicious. Running ASM from a console like environment linked from a web source seems like madness to some, but seems like a dream to me. Just to squeeze out as much juice as I can. :P
Thanks very much!
So uselessly genius :)
The code is not actually buggy because the alternate branch is unreachable (it's usefulness is another question). The point was that in complex cases, it isn't possible for the guard to be removed. Adding a branch to every access will always come with a penalty. Static languages are faster because they skip lots of runtime checks that dynamic languages need. View our let problem as a type union of type BoundLet = Undefined | Null | a; //where a is polymorphic on all other JS types type Let = NeverDefined | BoundLet; Unfortunately, any function or operator that uses `NeverDefined` is potentially toxic. In the case I wrote with the ternary, I don't know of any way to statically infer `BoundLet`rather than `Let`. If you cannot, then you must box it inside something similar to the Maybe type in Haskell, but because everything else isn't strongly typed, the type inference goes down the rabbit hole to infinity. Since you can't solve the halting problem, you check in real time. There are books on the problem (none free that I know of), but this may shed some light on this specific issue ([See page 123] near the boxed code (http://www.cs.tau.ac.il/~msagiv/courses/pl14/chap6-1.pdf)). This issue is well known in type theory. I may not have done all the math, but I'm very much certain this issue exists and all non-trivial `let` statements are unoptimizable.
Okay I understand what you mean. But say you want to `.filter().magicMethod().map().magicMethod2().reduce()` isn't that going to be a bitch? &gt; it will return a new instance of that subclas IMHO, that's what's nice because it allows you to do chaining with the extended methods. In your Tripod example, this allows you to control that a Tripod will always be created with at least three legs (which is what you want). If you don't want it to be a Tripod anymore, make it an array! let reducedTrip = [].concat(trip).reduce((x,y) =&gt; x + y);
But if I did that, this would be more like a beginner JS exercise. 
I updated to Chrome 54 and got `var` faster by 11%, a lot closer to your numbers. So it looks like Chrome 54 lost some performance in this area. `var` and `let` used to have virtually identical performance.
Crap, another framework to learn.
[removed]
[Callstack](http://Callstack.io) is hosting [React Native EU](http://react-native.eu/) in Poland Q3 2017. You could always attend both. :)
Eh... you're technically adhering to the letter of the rule but missing the spirit of the rule. 1. Name collisions. There are fewer chances of this happening now with your change, but still a chance. What if another library wants to define "house"? 2. Spooky action at a distance. Functions are much easier to understand when the communication is explicit and obvious, by passing arguments and getting return values. Implicit communication through shared, non-local values is a lot harder to trace. When your code is only two functions long, it's not such a big deal, but when real programs get to be tens of thousands of lines long, it goes a long way to being able to understand and trace what's going on.
Definitely convenient for creating custom Errors. class MyError extends Error {} try { throw new MyError('something bad') } catch (e) { if (e instanceof MyError) console.log(e.message, e.stack) throw e }
Just use IIFE's
&gt;JavaScript dispatches requests for information such as Self and Scheme. VueJS is a proxy for a server to make it happen. MongoDB, ExpressJS, AngularJS, and Node. Web analytics, ad tracking, personalization or other purposes. ECMAScript 2015 / ES6 code translator transpiler. &gt;MongoDB, ExpressJS, AngularJS, and Node. nice.
Have you considered making a webservice?
Recommend a link?
Thanks for the feedback. I'll keep this in mind.
There's a few ways to do this. Here's an example fiddle that I put together: https://jsfiddle.net/radiantstatic/asr8eqrn/ There's a postClick and a preClick implementation, I would recommend the postClick so that you're not manipulating the page every time you load a page. preClick will change all of your a tag hrefs on page load to the original + appended tracking code. postClick will append the tracking code AFTER the a tag has been clicked.
https://github.com/MostlyAdequate/mostly-adequate-guide
How do you suggest we protect our APIs from this sort of attack? Use a strong and large key to sign the JWT?
oauth?
I have always done it by keeping whether a user is logged in as part of my state. Then when I am rendering my component, I check my state and render based on if someone is logged in. In other words, there is still state when you are logged out, but it just has 1 field. When a user logs out just remove the other fields that u added when they were logged in and update the logged in field.
&gt; Observer Pattern is a library to parse, validate, manipulate and display animated 3D computer graphics on a Web form to make sure that they are explicitly exposed. MVC Framework for Node. Web form to make it happen. WebGL is a structural framework for dynamic web applications. Inherent to its dynamic nature, the increasing speed of JavaScript for server-side Web applications. --- &gt; Grunt is a swiss army knife, focusing on the model-view-controller pattern. BEM is a JavaScript code linter. Hapi is a function that gets called immediately after declaration. Web applications. PostCSS is a JavaScript API for working with text, arrays, dates and regular expressions, but does not include any I/O, such as the content of an e-mail message to the server. --- &gt; JavaScript library for JavaScript. Universal is an application more responsive. Animation of page elements, fading them in and out, resizing them, moving them, etc. Flow is a testing framework. I/O, such as Node. --- &gt; Design Patterns is a software design pattern in which it is embedded. HTTP as API. VMs and platforms built upon them have also increased the popularity of JavaScript engines has made the language a surprisingly feasible compilation target. V8 is Google’s library for efficient data fetching. JavaScript programs. --- &gt; JavaScript was never intended to be such a language that compiles into JavaScript. JavaScript library for efficient data fetching. ES6 code translator transpiler. Flux is an application framework for Test-Driven Development. Web Components. --- &gt; JSLint is a language that compiles into JavaScript. VueJS is a simple, pluggable static site generator. HTML pages, also known as Dynamic HTML. Web Components. Universal is an assertion library used with a clean underlying data model. --- &gt; Observer Pattern is a creational design pattern used to speed up the setup and installation process of a Web browser. Electron is a community-driven attempt at explaining the loads of buzzwords making the current JavaScript ecosystem in a few simple words. 3D content for the intermediate to advanced JavaScript developer. Web browsers without plug-ins. MVC Framework for Node.
Oh my, I love you. seriously thank you!!!!!!!!!!!!!! I could just add this into the &lt;head&gt; section and should be good to go?
&gt; Arity is the standardized specification of the page. Because of course it is.
came here to suggest this. 
In terms of security, there is no real concern as long you are careful. When logging out, removing all things from state that are sensitive and should only be accessed by those who are logged in. This way, even if a user somehow is able to change state (unlikely) they won't get anything valuable. This is of course assuming you have proper security in your back end. In terms of using props vs state, I am not sure what you mean. Its completely okay to use state when not logged in. As an example, you might want to cache songs that the user loads by saving them in state so you don't have to repeatedly make requests to the API. You might separate your state into two: regular songs and pro songs which requires a user to login. When a user logs out, remove the pro songs from the state, but leave the regular songs in and just read those when rendering your components. When a user is logged in, read from both the regular and pro songs. If your app gets complex enough and you find yourself having trouble managing the state of your components, you might want to look at a state management tool like Redux. EDIT: As a more specific example to your use case: If you require users to be logged in for editing songs, as mentioned above, you should keep track of it in your state. When a user logs in, store their information in state and then clear it when they logout. If a user edits a song while logged in, and then logs out, you have two options (that I can think of). You can refresh the songs list by making a request to the API, which will get you the updated songs (I.e w.e edits the user made) and use that when rendering. Or, if you are saving the songs in the state as I mentioned above, just update your state with the new song info. You don't need to remove the songs from the state, as they are not sensitive. Only remove the user info like username and session token or w.e you are using and update the logged in flag to false. If a user manages to change state some how, he might be able to edit client side, but he won't get past ur back end security.
i built something similar to this a little while ago. basedipsum.com (lil b themed ipsum)
 kd.UP.press(function() { setInterval(function(){ player.fire(); }, 5); }); hell yeah
It's already on yarn2.
Just seems like that convenience results in a less secure application. (at the moment)
Here's a fiddle I put together using jQuery: https://jsfiddle.net/radiantstatic/4rw6xaj1/
Improve npm first :)
I'd recommend that you try to contribute to some JS projects on GitHub. Community is quite helpful and you can learn a lot about writing real software (tooling, testing, maintainability, etc.) instead of some made-up exercises. Here's a great place to start: https://github.com/MunGell/awesome-for-beginners#javascript
when yarn is up to installing types correctly it will be the goto for js cli package mgmt. mark my words!
I don't need a framework for that, I write gibberish JS on a daily basis.
Is the gibberish webscale? 
Yeah. So... you downvote my comment because I'm correct? I'm not arguing that we should continue to use a broken and slow cli tool. I'm saying that we should continue to use the npm registry regardless.
You could also do this with CSS animations. Animate the background-color of the element. Here's an example (not my code): https://codepen.io/metagrapher/pen/tgcLl
I wonder how hard it would be to make a program that generates working JavaScript code that does nothing useful, then generate a blog post about rewriting that useless code making use of some cryptic ES6 syntax sugar. Weekend project, here we come. 
I have some code here from a previous project, creates a request animation frame around audio input from a mic. It has volume level, beat and frequency data. https://github.com/a-axton/threejs-web-audio-api/blob/master/app/AudioAnalyzer/AudioAnalyzer.js
&gt; Con: Package manager. There is none. And everyone is using npm and JS libraries. I think TS would greatly benefit from having a separate package library which would be filled with code which uses all the benefits of the language. This "con" makes little sense to me. There are many libraries that are transpiled from `TS` such as `rxjs 5` or `angular 2`... these libraries "use the benefits of TS" and are managed via npm.
I [took a crack at this myself](https://www.reddit.com/r/javascript/comments/4ltoxa/multiple_inheritance_with_es6_proxies/), so I can probably come back later with some tips and suggestions. But for now I'll simply suggest that you avoid mixing tabs and spaces. It makes the code hard to read when the indentation levels don't match up. http://i.imgur.com/t2E49DC.png http://i.imgur.com/TbDjUpo.png
I just made this stupid pen a couple days ago that generates random repeating backgrounds: http://codepen.io/lemmin/pen/ALJjzR
It'll take months of discussion for it to be even be considered, nice to get the conversation started now.
No need to be so harsh, this is a great intro, and gives some good examples on why and when you can use this. It's much more approachable than MDN is in many cases for devs that aren't as involved in JS as many of us. FFS look at the sentence explaining what it does: &gt;The File API makes it possible to access a FileList Containing File objects representing the files selected by the user. That barely means anything to me, and I've been working with the file APIs for years... MDN is a great reference, but for learning its pretty bad. Most of the stuff on David Walsh's blog is oriented toward beginners(ish) or "light dabblers" anyway, so it fits in perfect there like it is.
I don't think I'm being harsh here, not my intention. It'd maybe be good to just add a link to that or other resources to supplement whats available here. In your example the `FileList` and `File` words are hyperlinks to their respective full articles. And the page has clear and understandable markup which you can use to demo.
Try same without jQuery : https://jsfiddle.net/1f6zm54b/
FP/OO is an orthogonal concern to interfaces (and static type checking generally). FP with interfaces makes perfect sense, in other words.
You can take advantage of the web's incredible back compatibility to build great things without the hype. I'm not saying go forth blindly into deprecated territory, but you don't have to live on the bleeding edge all the time. Chill. 😎
I'd love to focus only on the ideas and arguments you put forth, but the grammar issues were very distracting. If you don't have a friend to help proofread your stuff, PM me and I'll help. Anyway, I agree with your underlying point, which has been made by many others too, that people should choose their tools based on the requirements of their project. I'm not sure all the code samples of how to do things in vanilla HTML and JavaScript are necessary for making that argument any more compelling, but overall the point is a solid - if not largely self-evident - one.
&gt; Math.floor(Math.random()*16777215).toString(16); Looks interesting but I don't know how it works Well let's break it down: Math.random() With the default arguments like this it returns a floating point number between 0 (inclusive) and 1 (exclusive). *16777215 We have 3 color channels (R, G, B) and each is 8 bits. That means in all we need to generate 24 bits of random number to get a random color. Since we want to spread our random number from 0 to 1 to cover this entire ranges so we can get any color out of it we need to multiply by the number of random colors. Since these are bits with 2 possibilities each (0 or 1) math tells us 2^24 - 1 (minus 1 to count 0 since 0 was inclusive). 2^24 - 1 = 16777215 so now we have `Math.random()*16777215`. Math.floor() Since our random number between 0 and 1 is likely to have many decimal places it is also likely to have those after multiplication. We need to make sure the final answer is rounded in some way to an integer since the RGB hex value we are aiming for wants an hexadecimal integer. Math.floor() is a simple way of just chopping off anything after the decimal point. .toString(16) .toString(16) will convert our decimal (base 10) random number that we generated into a hexadecimal (base 16) number. Now we have a valid random 24 bit RGB value encoded as hex.
Thanks for catching that. Looked okay on my local copy so I didn't even realize I was doing it.
I will add another con: ts definition files. Not the definition feature set itself, mind you, but having to find quality up to date definition files is a real pain. A lot of the ones in definitelytyped are very dated or poor quality (for example set as globals because ????). This is a big con for me, because it means I have to invest time to create my own.
I'm curious what specific cases caused issues. I use NPM daily for work and personal projects, and really rarely have to deal with any of this stuff. The speed is pretty good, and if it's slow, you can always run one of many NPM proxies (or use Yarn).
Pretend privacy is what I was going for actually. I prefer vanilla javascript. The underscore convention was good enough for me. Thanks though. 
Eh. I'd say it was their fault for calling it when told specifically not to. Haha :DD
Yes but don't rant here because this is a Javascript Safe Place. 
This looks pretty similar to Object.assign()? Also note that ES6 proxies are pretty slow.
In the end we decided to use npm because the cognitive overhead of different package managers was frustrating, and made it hard for new users to start using TypeScript. Using npm meant no new tools, and for a lot of people that was huge. So while I understand the temptation to fix all of the things, I think we made the right call. Yarn does look promising, and I'm looking forward to using it. `@types` (the scope that we've been publishing declaration files under) seems to work pretty well for a lot of cases, but some issues are still being ironed out at this point.
It stopped me dead in my tracks
Looks cool, but sometimes it's hard to get right direction of bullet (bad angle. pressed left. too left. pressed right. too right. Delta of angle seems too high). 
What?
 Number 1 con for me. I had to use TS/Angular at a previous job and lost a lot of time having to write/correct definition files for third party modules. TS is for C# developers who needed to learn JS 3 years ago IMO.
Want what ? I don't want it but the code that previous author wrote uses something similar to it and I want to port it to ES2015 first to be able to undertsand it better and then worry about getting rid of it.
Honestly it's not much worse than plain JS these days, just say `declare module 'the-module'` and move on. TypeScript won't complain about `the-module` anymore.
1. For now. JS tools are getting better every year. Even now we don't need TypeScript to do editor hints, "proper refactoring" or just linting code 2. `Classes, (...), fat arrow functions, etc.` JavaScript in 2016 also has classes and fat arrow functions so this argument is obsolete. 3. compatibility with JS is the reason TS goes up and CoffeeScript is dead. So: for the future language designers: go rather TS way than CS way when designing syntax of language which will compile to JS. 4. the same you can have with Babel. 5. Partially yes. But there is a "con" in this "pro". If you use TS you won't be able to use JS analysis tools (not all of them, at least). It's like driving left instead of right. 6. The same with JS. Actually community of JS is bigger than TS one. 
hello lucas :)
Check out the old-school, quick 'n dirty, jQuery-based code at https://github.com/0x24a537r9/kirbydesai. Works well on desktop/tablets/mobile (as long as it's not too small). The idea is just to automate [The Kirby-Desai Scale](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2923953/), which is the industry standard means of estimating how many laser tattoo removal treatments you'll need to remove a given tattoo. The scale is super simple (addition), but if I'm successful in getting access to the core study's source data, I'll probably add a machine-learning-based estimator to the page for greater accuracy.
Have you actually read the post? *"From here on, it’s clear that we need to do some improvements on the code. The improvements can be anything from swapping the low level DOM manipulation with a virtual DOM library or with React or Preact for example."* "do not use any frameworks or tools" was never the point. It's about understanding the context and gradually adding libraries and tools as soon as they make sense. You don't throw a monolith framework on a small todo app just because of "horrible performance". 
I'm not down voting anything on reddit, I don't know who and why did it.
Babel don't have any focus at all. Babel is not a language, it's a transpiler power house. You can do TS with Babel as well.
The point was never "do not use any frameworks or tools". Rather, find out what you actually need for a given project. *"From here on, it’s clear that we need to do some improvements on the code. The improvements can be anything from swapping the low level DOM manipulation with a virtual DOM library or with React or Preact for example."*
You're going to want to draw each line of the hangman with the canvas context's [lineTo](http://www.w3schools.com/tags/canvas_lineto.asp) method. Check out MDN's [Drawing shapes with canvas](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes) article for more info on how drawing works.
This article is from last year ;) 
Cool. There's no secret to Yarn, though. Of course it's fast, it doesn't download dependencies every single time. For me, installing global packages is broken, and sometimes installs fail without errors. Other than that, sure it's faster, but I'd rather wait 10 more seconds and have something that works.
How does babel not have any focus? It is a modular tool with a singular task. They directly reflect tc9 proposals and stages, properly collected in ready-made presets. With TS by default you're getting a weird mishmash of features that aren't in javascript and then a draft here, another there, then you wait 2 years for this, and 3 for that. The whole concept is confused, it's a type checking ... transpiler that limits the extend of modern day javascript. TS wouldn't be able to transpile large parts of the modern web as it stands due to its lack of living standards. Probably not a single redux based project would go through it. Using it, and then another round for Babel, the question is why? Just use Babel and you get a better transpiler, then Flow for a better type checker.
That's weird! We never heard things like that before. We hope releasing the v3 as an alpha version during December. The alpha will not be ready to production. We want to take our time to build solid foundations for Strapi. Feel free to join our Slack or send me a PM if you need more information.
&gt; Subclassing built-in constructors, ~~yay~~ yea or nay? FTFY
1. I don't know of any editors with proper hinting and refactoring for JS. Support is always half-baked compared to Java world, for example. TS is also not there yet, but a lot lot better IMHO. 2. Still transpiling. So TS is always one step ahead anyway. 4. You can even have TS with babel or anything else you can imagine. 5. Agree, but most used tools these days are compatible with TS: debuggers, build systems, etc.
Du to the own conversions JS is doing, you can shorten this to: if(value == null) { .... } But I'd prefer the the longer version you already wrote.
Dependency updates always cause problems. Especially global packages. My solution right now is to have ALL the tools locally on a per-project base. TypeScript, ng2 cli, ionic cli, webpack, gulp, everything is local with aliases set up in my shell.
This comment address two concerns: 1. local (private) publication 2. installer name resolution The Addy Osmani link provides several solutions for local NPM relays. Each of these solutions is reliant upon cached applications and resolution through the registry. If there is resolution of names through the registry at any time for any reason the solution is less autonomous. It seems the resolution to the registry can be avoided entirely if applications are manually added to the local NPM cache and the cache flag is assigned to a really long value. The problem with this approach is that it is entirely manual. The approach is more desirable if applications are initially resolved and downloaded from the registry and stored on a local NPM proxy with a high cache flag. As a user installing packages you can adjust, rename, and reconfigure anything as you desire. These changes may or may not work, but there is room for flexibility. In the end, though, these changes must be made by the installer (the end user). A publisher cannot impose such configurations, name changes, or custom download points onto the user in an automated way. That said it is entirely at the behest of the installer if they wish to avoid the registry to access the application via NPM. This isn't a problem to be solved as the user could manually get the code from github (or where ever) if they wanted to. The problem is how to publish and make available an application without the registry. The primary value of NPM is convenience. The more convenience is eroded to attain some measure of autonomy the less valuable NPM becomes. In my opinion the biddle approach is a more convenient way to attain maximum autonomy. There isn't any reason a user or publisher can't use both solutions.
"So far Angular2 has not always been easy to pick up, mostly due to breaking implementation changes throughout the different RCs, so not a lot of material except for the official documentation is up to date. Also, if you haven’t used Typescript before I recommend having a quick stab at a Typescript tutorial first to know what’s Typescript and what’s Angular magic 😉". Having to keep up to date with the latest ng2 on the project my team is currently working, I can say that the breaking changes were a pain. Me and my colleagues always joke on what the Angular team's definition of "stable" is.
Let's kick it up a notch &lt;marquee&gt;&lt;blink&gt;Welcome to my home page!&lt;/blink&gt;&lt;/marquee&gt;
I'm so glad someone posted this. CSS is so powerful now, yet so many people just default to javascript.
I find this a quite acceptable way when prototyping - however, there is a *small* fineprint: if there are N people creating things in N different ways, that becomes a communication problem. It is not a technical problem. It is a software process durability problem with several people contributing to the same codebase. Frameworks like React are used in big companies like Facebook because it gives some common language and organization for the code, not because it is the easiest or even best solution to any given problem. Of course they could just jQuery things up and that's perfectly fine given that all actions are properly documented. But even a single developer changes his / her coding during time, imagine 10 or 1000 developers - would reading all the documentation about the codebase might become a problem? Most likely. 
This works, though when I did it on my website a few years ago, it destroyed framerates for lower-end devices, I assume because it was forcing a reflow of the entire page for each frame.
&gt;don't improve upon the flow i've settled comfortably into in any way
I agree. But I’d only use `typeof value !== 'undefined'` if you are not sure whether the variable `value` exists or not (rare!). Otherwise, do this: // Note the `&amp;&amp;` in the middle! if (value !== 'undefined' &amp;&amp; value !== null) { ... } // Roughly the same as: if (value) { ... } 
There are some style guides that basically say you always should use `===`, but you can use `==` in order to check for `null` or `undefined` at the same time. So you could do the following: if (value != null) { // This will run if `value` is not `null` and not `undefined`. }
That's different and perfectly fine, this article isn't titled "Don't legally fuck yourself with corporations" it's complaining about the complexity of modern development and that going "old school" is the "new cool".
Did you try D3.js? It is very robust and highly flexible. There are many D3 based free and premium charts as well.
Really? The use of: if(value != null) { ... } is perfectly idiomatic JavaScript. In my world, only newcomers don't know or take advantage of that.
I thing a missing point in the article is that the server-side rendering part isn't meant to be for each and every request, it's supposed to be used only while the client js app code is loading. When app code is loaded, it takes over the rendering directly from api data, which is the whole point of a client app framework. Furthermore, with the concept of progressive web app, you can also local-cache the app code so that server-side rendering will really only be useful for first connection from a given device (and from crawlers). Your opening diagram especially makes the reader think that server-side rendering occurs for any request, which is like saying that you use React as a server-side templating language, which doesn't make sense.
[removed]
Great article. IMO it's always good exercise recreate things in a simple fashion so you can better understand them. For a sort of outsider perspective: I am a backend engineer by trade and interest (Go, C++, Python), but there are times when I need to do full-stack work. Over the past couple of years I've had a lot of trouble with build tooling, frameworks, libraries, breaking APIs, etc. in JS, especially trying to use Babel/ES6 and later TypeScript. These ecosystems change so fast though it is hard to keep learning. I've found Polymer to be very old-school-simple while keeping some of the niceties I liked in Angular and React like modularity and logical data binding. It's fun to work with. I also like Elm for certain applications that are amenable to pure functional design.
https://dorey.github.io/JavaScript-Equality-Table/
you should make sure that you're not near-instantly hit after starting the game. 
If you are using lodash, you can use _.isNil
&gt; if(a != null) console.log("pass?") if(a !== null) console.log("pass?") &gt;pass?
Do != null. This covers null and undefined but not 0, "", and other falsy things. Not sure about NaN, but I think NaN is also != null. The religion about always using === and !== is a little silly if you take the time to understand what they do.
No jeering at the strippers though, cause that would be sexist.
I wouldn't be surprised if most of the things are coded this way. The first half second is somewhat fluent, but the performance drops exponentially over time. 
Just do: `var HEROES = JSON-CODE;` JSON is already valid JS code.
Because `if (!!value) {}` and `if (value) {}` are the same You should only use `!!` to transform any value into a `bool`
if you like structure, learn Ember if you dont like structure learn Angular I would stick to one only, and be really good at it.
This is an interesting technique, but an exception is thrown if "value" isn't declared. The (typeof value !== 'undefined' &amp;&amp; value !== null) technique works as expected regardless of whether or not the variable is declared.
Laziness&amp; Impatience (but not Hubris)
No kidding: http://youmightnotneedjs.com/
They do sometimes, it's just random.
Which will be free-to-read, upon launch :)
My suggestion is to use typeof to check that the variable is of the type you expect, rather then testing for falsy cases. If you know you want a number, test if typeof !== 'number'. If you want an object, then things are a bit more tricky, but you'll need to validate the properties anyway, so it's less an issue. 
While perfectly fine from a technical standpoint I think it's hard to parse (because it basically inverts the check).
what about a refactor? exists = v =&gt; ( typeof value !== 'undefined' &amp;&amp; value != null ) if ( exists ( value ) ) dostuff() everyones requirements are a little different so i think its valid to refactor it out here. also lodash `.isNil`, and `._has` or `._get` for objects ex `foo.bar`
Gracias I will give it a go!
If I read this I would wonder if the writer realized this worked for `null` and `undefined`. I would argue it's better to be explicit than clever in this case.
You should add a start button or something to make the user click on the game area. The controls don't work otherwise. Also, game gets noticeably slower as more things appear on screen
No problem. If you are planning on using flux, I would check out Redux too.
Why would you do this just to alias a method? If there's no difference from the native methods, use them. Call push() and shift(), it's more intuitive for other developers that have to figure out what enqueue and dequeue are doing that's different from the existing functionality on arrays.
I would like to read the latter.
this is a common pattern. it should be taught more if you don't know it. AFAIK it's ingrained in many lint configs and style guides as only valid use of `==`
This isn't old school. This is competency.
I have a list of critiques on your game design. Fun for a couple of minutes though. Here's what you need to do to make it more entertaining, and make it have replayability. I'll start with the controls * The player needs to have acceleration on the aiming. It takes to long to turn 180°, but hair-point turns are too fast * Controls need a multi-map; some players use WASD, some the Arrow keys, and most shooters use the space-bar to fire The gamplay * There's no difficulty scaling, so there's no reason for me to play more than once * As the game progresses, the blobs need to increase in number, speed, and have smaller ones; achieve this my incorporating the player score into an algorithm * An ammo system would also help with the difficulty; have a limited number of bullets and add a reload time The aesthetic * Upon initial load, I didn't immediately know who my character was; it needs to look different from the meteors in a significant, immediately recognizable way * My shooting feels weak; it's the core mechanic so it should feel *good* * Meteor explosions are lame, I have a cool glowing thing coming at me with a lot of color and depth, and then it's explosion upon shooting it is a 1-color flat graphic that isn't rewarding * With a white center for the meteors, you have a lot of room for more color in the game besides a pallet of reds * Your game needs more.. pizzaz. Sometimes referred to as 'juice'. Read [here](http://blog.gameanalytics.com/blog/squeezing-more-juice-out-of-your-game-design.html) and watch [here](https://www.youtube.com/watch?v=Fy0aCDmgnxg) It's a great start, though. And I'm impressed that it's all in browser!
We need a package manager manager, like npmm.
I appreciate the level-headed response. I was wondering, and was going to leave a final comment about, who the intended audience is. JavaScript newcomers will be overwhelmed by this, but I believe seasoned developers are able to grasp these concepts and implement the technologies on their own. Personally, I find short, focused articles to be much more helpful than a full product implementation, e.g., one focused only on the document store implementation, or on setting up Apollo. I think, if the article you've written here was divided into many smaller sections and presented as a tutorial, rather than a how-to, it might be more approachable by more people.
 undefined === void 0; // or void(0) so if you want to save a few characters, you can do: if (value !== void 0 || value !== null) { //... }
This isn't clever, it's using a known functionality, it's using language features for the purpose they were designed, and it's the shortest solution to the problem. 
I find some languages forgo 'features' that you can write yourself. I haven't learned MongoDB (yet) but I'm sure it was a matter of applying 'to lower case' on both sides of the comparision
That is a very good point indeed. 
Still using Gulp 3
&gt; I'm wary because I already changed my entire workflow twice this month This amuses me. People complain about things changing.. When they're the ones going around changing things. Here's the magical cure to not having to change your "entire workflow twice this month": don't do it. I mean shit, this talk about JS landscape changing so much is so damn overblown. You can be on the bleeding edge and still not significantly change technologies for a long time. React was "hot shit" last summer and it still is. So was webpack. So was Redux. Now a package manager comes out when npm is pretty much the only other one people have ever been using. How many JS frameworks are actually massively popular? Angular, Angular 2, React, Vue. Those are the names that realistically get dropped nowadays. That's basically three frameworks and a major rework for one of them. And out of those 3 projects, only Vue came out relatively recently (but even still, people have been talking about it for months). Yes, if you obsessively feel the need to try out every single view based framework, you're gonna be slightly annoyed. I don't know any other language where people cry about getting to choose between 3 libraries over the course of a couple of years. If you can't handle that sort of decision, maybe you have to think if programming is something you're capable of doing. Task runners? Oh god the horror, you have the impossible task of deciding between Gulp and webpack. Both of which have been around for bloody ages as well. 
Sure I can write it myself however MongoDB should do the sort in complied C on an index natively. That would be 10,000 times faster if not more. 
Yes - in 2.1 we will assume that an import was valid so long as we were able to resolve it to *something* - even an untyped JavaScript package. The only time you should get an error is if you truly misspelled something or if you have `noImplicitAny` turned on (in which case, you presumably wanted well-typed dependencies).
XEmbed, else you can get discouraged here: https://discuss.atom.io/t/get-hwnd-or-window-handle-from-electron-for-directx-opengl/18418 you too might consider Qt5 (+maybe QML for easy descriptive UI)
Yet they were using popular libraries and it all *worked* just fine. The fact of the matter is that code worked, but could trigger a strange situation that caused an extreme slowdown. What modern language do you want to use that can't properly handle threads, given that we operate today on machines with upwards of 32 cores?
Hi /u/ISchrodingerscat, last warning. p.s. [deleting your old posts](https://www.reddit.com/r/javascript/comments/503zgk/) won't help.
That's amazing! I didn't know that browsers could function as servers. I'll need to learn more about this technology.
Important to also know when not to obsess on "uh oh I bound this component to my API Client interface". Sometimes components are just one-offs that are perfectly fine being specific to that implementation. This is one thing I enjoy doing with Redux. My containers are very strongly bound to this specific implementation, but all of their children are easily interchangable.
Really cool game play! Is this "based on a classic" or a new game alltogether?
This kind of mystery sauce happens with all kinds of frameworks. You either haven't used other languages enough or are forgetting your own bad experiences to hop on the Javascript is bad train. I've had this kind of shit happen with everything from Spring to Django. I've had context manipulation bugs from documentation being wrong on Spring and creating thousand of singleton threads. Same shit different language. Also Node/JS can handle threading just fine, it's just that most people don't get threading in general in terms of low level implementation that leads to this kind of crap. I have coroutine functions, daemons, with full promise fulfillment end to end and passing through IPC messaging events -&gt; streams. JS is great for threading because all you have to do is assemble your shit in a buffer than dump it into the event loop for coms.
&gt; The example is indeed extremely simple, but that's intended. It's so simple that he couldn't even get basic JSX syntax right
TL;DR: Write code to become a better coder/programmer.
I guess I'm just confused at the users who would make use of this over one of the many tools out there that can handle minifying/bundling and be integrated in any build process or development environment. Can you give me some more concrete examples of where this tool shines? Reading over your code it seems like a stripped out bundler essentially.
Still trying to figure out how to properly monetize HTML5 gaming.
And even then...
Really cool game. Nice job :) I just dont understand though why you are using multiple canvas's instead of 1?
I love it &lt;3 I need this on mobile.
Going out for popcorn. Who wants some?
Author here, happy to accept feedback or answer questions.
Directly using document in your components doesn't exactly make it easier to test. Just learn about context which solves most of the problems indicated. And just pass callback functions to trigger. Also, this code will suck if you have multiple instances of the component running. Take a look at CycleJS instead of this approach.
&gt; The religion about always using === and !== is a little silly if you take the time to understand what they do. It's comments like that that make me want to smack someone upside the head. Please take the time to understand the following loose equality comparison chart. It's not so clear-cut and black-and-white as is initially thought. http://dorey.github.io/JavaScript-Equality-Table/unified/ For the sake of all our sanity, please for gods sake continue to use the triple-equals comparison.
The easier way is probably to publish it on Google play. It is also possible to sell them at itch.io and or steam.
Not enough hamster dance.
&gt; Angular 1.x basically runs eval on DOM content. When evaluating it for use this was one of the major red-flags for me. Apart from that it couldn't handle many elements before bogging down. That and the architecture of the code made little sense. ... My god, there are people on that issue who have large Angular 1 extension deployments, I'd sack anyone who had anything to do with those decisions. It doesn't take much effort to determine Angular is not the tool for this job.
http://minesweeper-demo.herokuapp.com/ I used HTML for mine.
Take a minute and read up on type coercion in JavaScript. Edit: why the downvote?
Preach.
https://github.com/mozilla/addons-linter/issues/1000#issuecomment-255071991 This response seems 100% legit. Wouldn't want it in my browser.
Write code, publish on Github, try supporting some open source libraries that you have passion about. Build a credible foundational portfolio of work.
No, people just decided to call them different things. There's never been a clear definition of MVC in regards to: * Where the boundary lie * How each parts communicate with each other * How you initialize them * How you arrange them in memory In fact [Wikipedia diagram for it](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller) looks more like a typical unidirectional flow architecture. The distinction happens in implementation. Backbone, Ember, etc each has their own distinct flavor of how to do the above. It just so happen Facebook decided to market React+Flux/Redux as "not MVC", and characterized the definition of MVC in their documentations to not include itself. If you want to follow the general Wikipedia definition of MVC and apply it to React+Redux: * ActionCreator + Reducer = Controller * Components = View * State = Model You can also do the same for Flux/Reflux and pretty much everything else. 
Nice one! first thoughts: I think it might be better if you exposed some constants to build up combinations of keys instead of using strings, also if you want to distribute this you should publish it to npm and have some test coverage in order to be picked up and used in a production environment. Seems useful, good job :)
I understand what you are saying, and I've worked on teams where we had to deliberately avoid intermediate-level language features (in C#) in order to accommodate slower devs. I think that as long as your code can *demonstrate intent and prove its correctness*, then what's inside the function literally does not matter at all. If, on the other hand, it is important to be *procedurally explicit*, then you should probably just stick with `typeof value === 'undefined' || value === null` and not bother with the indirection of a function. *But if you do that are you sure that people will understand why you need `typeof` for `undefined` but not for `null`?* It's a slippery slope to the bottom. 
react does. its own version number says its not stable ???
Fun
I don't get why this is a problem for Firefox and not for Chrome... the use of eval on the dom that is.
React is at version 15.3.x They switched from 0.15 to show that they are absolutely ready for production. 
&gt; but 1) that's for the dev to choose, and 2) it's just a small exercise. So the article is worthless?
Sure. Let's go with that.
I raise you one: http://www.ronilan.com/bugsweeper/ :) (code: http://www.ronilan.com/bugsweeper/js/bugsweeper.js)
Chrome likely has better security around what extensions can do.
&gt;&gt; Convinced? Initialization, and main loop. That is our point for today: almost every kind of UI was designed around a central loop of events sent by different parts of the application This is the perfect summary IMHO (extracted from the article). 
It'd not just js... Browsers... Linux kernel... 
Very cool I like your's a lot. I raise you my code. The business logic is view agnostic. https://github.com/JohnathanWeisner/minesweeper-vuejs2/tree/master/src I haven't finished mine yet :D
Sort of... linux spent 15 years in version 2.x, then switched to a much more 'aggressive' release numbering pattern. Firefox spent almost 10 years through 1.x-3.x and now bumps a whole version every couple months. 
They changed what they consider major version update but they still followed a very sensible path and didn't skip numbers or stay below 1.0 for long periods of production ready time.
It's definitely not default for linters to allow `!=` Crockford himself spoke out against it and this specific comparison in The Good Parts. Moreover, the commonness of a pattern (especially in JavaScript) does not mean it's a good pattern.
This is one of the few corner cases where `!=` provides some benefit. It is entirely opaque, and is most certainly not known to every JavaScript professional. &gt; it's using language features for the purpose they were designed Really? The coercion of `null` and `undefined` by `==` is a language feature? Because it's so intuitive? Douglas Crockford specifically calls out this coercion as an 'awful part'. So there is at least some school of thought that it is bad. So using a 'bad part' of the language just in pursuit of the 'shortest solution to the problem' seems pretty clever to me. Also, I don't think the shortest solution to a problem is the goal when building reliable fault-tolerant software. 
Hey guys, thought you might enjoy this. My girlfriend is not a programmer so I've been teaching her some stuff. Thought it'd be cool to take a semi FP approach to solving the GoL. [Source for those interested.](https://github.com/zachrip/game-of-life/blob/master/src/app.ts)
Really cool!
If you look for text formatting, you can use [ckeditor](http://ckeditor.com/demo) it may do probably more than you ask. if you want very specific structure &lt;form id='form1'&gt; Title&lt;input name="title"&gt; Message&lt;input name="msg"&gt; &lt;input type="submit"&gt; &lt;/form&gt; &lt;script&gt; function handle(e){ event.preventDefault(); console.log(e.target); var inp = e.target.children; for (var i=0; i &lt;inp.length; i++){ if(inp[i].name) console.log(inp[i].name, "=", inp[i].value); } return false; } &lt;/script&gt; and format it as you wish (you don't have to do it with `form`).
You need to run it as https to get location data https://codepen.io/lettda/pen/yaGaLx The next problem you'll have to solve is how to get data from openweathermap, as I don't believe you can use https on it's api.
First of all, java and javascript are not the same thing. Khan academy is fine. Doing anything is fine, there isn't really a wrong answer to learning. Find what works for you - and good luck.
The React PATENT.md file has been there for months. Every time I've asked an Enterprise dev who was using React if they were concerned about giving up their company's ability to defend their patents against Facebook, I was met with a blank stare. It's sad that OSS is being hijacked in this way, and that few seem to have a problem with it. If you're going to use React, at least send legal an email checking if the PATENTS.md is going to be a problem. Have them review the full license while you're at it.
Ok thank you very much and yeah it works well for me ive learned alot in just 2 days and thanks for the good luck too. :)
Reading this it seems to me and I would love it if someone would correct me on this is that any page that uses an eval statement for parsing HTML would be affected by this, correct? As the exploit boils down to HTML being inserted by an extension which gets executed by the javascript on the page within an eval statement. If that is the case i have to wonder if the firefox browser shouldn't add more safeguards to protect users. Like disallowing extensions to run on a website that somewhere in their code uses an eval statement for example. Or forcing websites like github for example does to disable all inline javascript (which in my humblest opinion everybody should already do)
When stop() is called it immediately stops any currently-running animation on the element. If I assuming correctly that you first want to bigPicture to fadeOut for 5 seconds and then fadeIn the new bigPicture, then you need a callback. So try rewriting your code to something like this: $(".picture").click(function() { if ($("#bigPicture").attr("src") != " ") { $("#bigPicture").fadeOut(5000, function() { $("#bigPicture").attr("src", $(this).attr("src")).fadeIn(1000); }); } else { $("#bigPicture").attr("src", $(this).attr("src")).fadeIn(1000); } }); 
&gt; It is entirely opaque, and is most certainly not known to every JavaScript professional. Just because not every single developer is aware of a language feature doesn't mean we shouldn't use that feature. &gt; Really? The coercion of null and undefined by == is a language feature? Because it's so intuitive? No, because it's written into the spec. &gt; Douglas Crockford specifically calls out this coercion as an 'awful part'. So there is at least some school of thought that it is bad. I agree for the most part that type coercion can get a bit unintuitive at times. That doesn't mean we should pretend it doesn't exist. It's there, and it provides a convenient pattern for solving a problem that comes up pretty commonly. People will draw the line in different parts when it comes to readability, but I would argue that as long as there's a reasonable chance that a developer - that has done their research and actually tried to understand the language - would know what's going on immediately (and I believe this is the case with `variable != null`), then it's perfectly acceptable. Again, I'm not going to shy away from a language feature because somebody hasn't looked up how type coercion works. 
Hey. I work on Angular security and have looked into this. This is unrelated to Angular's sandbox. Using Angular in an extension does not mean Angular runs on all pages in the browser, it does not eval() the DOM of arbitrary pages (it'll only bootstrap the extensions' page). Unless the extension developer creates a security issue themselves (e.g. putting user data into an ng-bind-html), this is fine. There is an issue where having Angular in an extension makes it easier to circumvent certain defense-in-depth mitigations if a web page already has a vulnerability. It's not specific to Angular, but Angular makes it easier to exploit. We'll fix that.
IIRC it's WebRTC that allows the p2p stuff.
I believe that the commonjs version of jquery hosted on npm can be used to accomplish what you need.
Okay. Then why is the simpler `value != null` not an the opportunity to educate people about JS type coercion. I'm not seeing any benefit here. You are being strangely picky.
Khan Academy is actually quite good. I consider myself an experienced Web Developer after nearly 10 years of working in the business; and even I started working through Khan recently and learned a little something doing it. So yea, it's a great idea to do that, and will help you : )
So you'd rather cram in a 100kb framework or library just to do something simple? 
Focus on very tiny programs, this will keep you motivated at the beginning and later on you move at bigger programs. It will never end that you learn something new which make your past programs more readable or faster but you ain't got time to integrate this nor you take a break from your actual project. While you learn languages you could take a look at the Informatik part of the academy and other sources about this topic. Should you ever got questions on how to solve a code use stackskills.com. 
TypeScript still blows away any Flow based tooling i've seen
It's funny that this extension for flowtype is coded in Typescript :P I'm still on the fence about which I prefer to be honest.
Negative means you lost ;)
My intention is just to make it public and maybe it becomes useful for someone. But you're right. UI was never my strong point. I wouldn't mind of someone builds a better look for it! ;) 
Uh, I'm lazy I guess...
Actually I'm sloooowly remaking this game on CocosSharp. Not sure if I'll manage to follow through!
Oh just now I remembered that my comments are still in portuguese. If someone is interested, I can translate them to english and make them a bit more descriptive. 
It starts adding up when you have lots of extensions that include it (often unminified) and if you check how it is used it is often something that could be just as easily be done without the library. For something as simple as most browser extensions 3rd party libraries are often totally unnecessary.
If you don't need to worry about abstracting out the bugs and other oddities in legacy browsers, then you might be able to avoid a large library like jquery completely: http://youmightnotneedjquery.com/
another (ES6) method; let arr2 = [...arr1];
https://www.coachunt.com
 &gt; const a = 1 &lt; undefined &gt; a = 2 ▶︎ Uncaught TypeError: Assignment to constant variable
Done using window.setInterval
Maybe they read "girlfriend" and assumed it was a lie?
Picky from not just hard-won experience. It's primarily because type coercion is a mistake that Brendan Eich regrets not having fixed long ago. Long experience has shown that implicit coercion results in an incredible range of bugs. So many that using only explicit comparisons is the only sane approach for the robustness of your code. 
I think it's because they were doing semver wrong and decided to do it properly in 15. So they went from 0.14.x to 15.x
as YHSPY said, use babel to transcompile ES6 into code that's understood by every browser (ES5, latest fully supported)
I might not be understanding this correctly, but... Wouldn't "document.querySelectorAll" accomplish kinda the same thing?
You're not wrong. Templating works ok for read only things. As soon as you need to do anything more complex it just get's in your way.
Antici-
Anticiation
Don't worry about the language or doing things the "right way", just pick a language and learn to do something with it. Khan Academy is as fine as any source, use the one you like best. Most of the concepts you learn apply to many other high-level languages. You are learning programming either way. If you can make something that *works* as a beginner, you are doing things right. You are already a better programmer than I was at 13 and you'll have plenty of time to figure out why some ways to write code might be better or worse than others.
This is what it is really great at, I think. What did you use, Vue and VueResource?
&gt; only if you knew what tags were being used on the page before hand &gt; And there doesn't seem to be any way with querySelectorAll to make nodes out of all elements with IDs. You could do something like: "var list = document.querySelectorAll('body *[id]');" "*" will select every possible tag, and the "[id]" will filter out elements that don't have an id set.
Element.classList.toggle http://caniuse.com/classlist
What u/Rhomoid meant is something like that (as I understood it): var words = { ABCD: true, // Can be anything except undefined EFGH: true } function exists(w) { return words[w] !== undefined } console.log(exists("ABCD")) // true console.log(exists("DCBA")) // false In ES6: let wordSet = new Set([ "ABCD", "EFGH" ]) console.log(wordSet.has("ABCD")) // true console.log(wordSet.has("DCBA")) // false
I think generally if whatever you're doing works for you and your team, and you enjoy it, then don't feel compelled to jump ship. I think the React licensing however is really problematic, too. It's something shops should consider more carefully. 
Oh wow never heard of Vue before. Looks awesome!
Apologies if this is the wrong place to post - I'm new to Javascript and I'm building a logic engine that will help with calculate a Loan To Value amount. First and foremost I provide the variables: var formattedValue = 10; var formattedDebt = 1; var ltv = calculateLTV(formattedValue, debtAmount); *Note: the 10 and 1 here will be dynamic inputs from a field asking for property value and outstanding debt, but for the sake of this example I'm using 10 and 1.* Next I'm calling a function to work out if there's no debt, in which case it returns no value... so if there's no value I want to replace this with 0, otherwise just return the same number. function debtAmount(formattedDebt) { if (formattedDebt == "") { return (0) } else { return (formattedDebt) } } Now, this function debtAmount is what seems to be breaking everything, returning NaN. If I was to replace debtAmount with formattedDebt in the ltv variable above, it would return 10 as expected. Finally I want to work out the percentage of debt to value... function calculateLTV(value, debt) { return 100 / value * debt } alert(ltv); Any help troubleshooting here would be amazing, thanks!
http://news.ycombinator.com/ http://reddit.com/r/webdev http://reddit.com/r/javascript
That is a good point and really unfortunate...
Gotta love async code :p
Here's a working JSFiddle: https://jsfiddle.net/a3qz1560/3/ Your mistake was when you ran the following you hadn't passed in a value to debtAmount: var ltv = calculateLTV(formattedValue, debtAmount(formattedDebt));
Couldn't agree more. Nobody will ever convince me that adding programming to HTML (templates) is better than using HTML in programming (jsx). 
because it looks good on resumes
this looks promising. it's pretty much just the bits i wanted.
&gt; Vue​'s​ document is the bestation. ? 
I'm curious if you have an example of where JSX outshines HTML? I've taken a passing look at React but JSX has never grabbed me. What am I missing?
The fact that people are even asking this question explains a lot about why there's so many people crying about "too much decision" in the JS community. If you're having no problems with React and like working with it, there should be no reason to migrate to another framework, period. Even if Vue was objectively better. Sure, learn it, start the next project with Vue if you think it's better, but that doesn't mean you need to convert every piece of code you've ever written to it.
Repeating the same comment I made in the last couple threads on the topic: For reference, here's links to a number of relevant discussions and comments from Facebook and the React dev team: https://github.com/markerikson/react-redux-links/blob/master/pros-cons-discussion.md#reacts-patents-license In particular, the official FAQ on the "PATENTS" license addresses a number of issues: https://code.facebook.com/pages/850928938376556 
You could still install yarn faster.
The Github repo doesn't show a change to licensing in the past 10 months at least. What are you referring to?
I'd have liked examples of complex problems that were simplified with Vue, not just a 'hello world'. Hello world _always_ looks nice and simple.
Is it window.document?
Does it? Even when React is far more popular and desired?
After setting permissions by hand to AndroidManifest.xml the application finally worked. After that it worked with Crosswalk too.
This little library will help your forms degrade gracefully. Hope you like it :)
At least it isn't governmental website with comments like "fuck, this piece of shit should work"
&gt; Vue's document isation the best.
I think it's a matter of preference. I prefer vue mainly because I notice that I develop faster with vue than react.
&gt; The idea was to avoid having to write document.getElementById() and document.getElementsByClassName(), and instead have those nodes/collections ready at all times Great idea! I had the same idea. I'm working on a library (anti-framework!) called Aglet. You can create Aglets from any object (just like jQuery) and it will tier down automatically. It also creates parent references and each Aglet's dom object has a reference back to its Aglet. No more querying selectors! You just define the nodes you want access to with ids or an ag-name attribute. I forked [this Angular pen](https://codepen.io/Russbrown/pen/IgBuh) to show [how it would be done with Aglet](https://codepen.io/lemmin/pen/KgvypZ). log the page var to see the object that it creates.
Are gitlab and vue.js both "ycombinator companies" ?
&gt; Which is a pretty fair trade, why should I allow you to use my stuff if you're gonna sue me? Not very FOSS, is it?
Woah there. I'm not considering or advocating an actual migration, especially based off some comments on reddit, I am just looking for compelling arguments if any exist. I see people raving about Vue and they mostly seem to come from a position of being somewhat unhappy with React, but it doesn't seem like there are tons of React users jumping ship. I find that interesting and I'm curious to hear from folks who made the move, if they exist.
I like it, but I had to do a lot of digging to really understand how to use it and what exactly it's doing. Site could use more demo code to show exactly what's going on client and server side. 
Because separate templates that have only simple constructs you'd find in *any* template language are better than JSX for both separation of concerns, and syntax. Templates &gt; JSX any day of the week. Except react-templates, which has a full dependency on the entirety of Lodash, adding considerable bloat to the document.
Why does the mapper function take an array? Wouldn't it be more flexible to have it transform a single value and pass the mapper into `map` as needed? Such as: let mapper = Morphism(mapping); let results = [v1, v2, v3].map(mapper); instead of: let mapper = Morphism(mapping); let results = mapper([v1, v2, v3]); This would enable using the `mapper` in situations where the result isn't an array: let mapper = Morphism(mapping); let result = data.reduce((result, value) =&gt; { result[value.id] = mapper(value); return result; }, {});
page does not reload
Well then why have templates in the first place? Without a clear philosophy, I don't really see what the constant breaking changes were for besides keeping up with fads.
Some morning css and HTML and it is playable on the iPhone... I just sent you a pull request: https://github.com/mycelo1/mycelo1.github.io/pulls Have a great weekend :)
https://developer.mozilla.org/en-US/docs/Games
One thing that templating frequently suffers from is validation. In angular if you make an error in your template it does fuck all. I also used to develop PHP and had many of the same concerns, but JSX simply isn't the same as manually outputting raw strings in PHP. I completely agree; PHP code is full of nightmares because of that. If you make a mistake in your JSX, it will yell at you. JSX is a bit more verbose, but also a bit more explicit. Logic is happening in your templates no matter what syntax you use. &gt; They're practically invisible. Invisible logic can cause quite a few headaches. There's always trade offs with these things.
Being allowed to reassign a const at runtime isn't that big of a deal. Using const will give you better static code analysis in your IDE, and const will probably still be *at least* as performant as var in the broken cases. If you don't mind setting up a transpiler, start using let and const now. If you don't want to set up a transpiler but you're willing to drop support for IE 10-, start using let and const now. If don't want to set up a transpiler *or* drop support for older browsers, wait until IE 10- are deader. In theory, those browsers are already dead, so using let and const without a transpiler is fine IMO, unless you're trying to make money. Here's the support table for const: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const#Browser_compatibility
I would say lack of validation in angular templates is a problem with angular, not the notion of templates. Laravel Blade yells at you as well, it doesn't just fail silently like Angular does (which is indeed a major problem for Angular)
Yeah, sorry. Github.io isn't the most reliable host. Keep trying that it eventually works. 
 return (n%5) ? n+5-n%5 : n;
`const round5 = i =&gt; ( ( i / 5 | 0 ) +1 ) * 5;`
There is no agreed upon style. I use http://standardjs.com/.
Personally, I use [Airbnb's ESLint](https://github.com/airbnb/javascript) style guide.
Thank you very much! Merged!
This really reminds me of backbone 
Thank you guys &lt;3 That helped alot!
Thank you for your feedback! I will definitely add this behavior as an improvement. My wish is to keep the advantages of the curried function factory: Morphism(mapping) =&gt; mapper function Morphism(mapping, data) =&gt; Data projection As well as focus on the mappers composition by make them iteratee-first (like you suggest, lodash FP is a good implementation: https://github.com/lodash/lodash/wiki/FP-Guide#rearranged-arguments) mapper(data:[]) // actual behavior mapper(data:{}) // Future implementation. Indeed, it will also allow to [o1, o2, o3].map(mapper) Thanks!
I wish there was an official style, ala Go-lang. My office enforces 4 spaces, `lower_snake_case` and some_obj.some_method(param1, param2, param3); I don't even know where that last style is from but I hates it. :(
Exactly :)
Thanks for the feedback. Do you think the example from the repo https://github.com/artf/ajaxable is enough?
Standard does not include semicolons. Whether you like or dislike their usage, you should consider that the vast majority of the JS community uses semicolons. 
Lets define a component...say Image &lt;Image src={} /&gt; Now you say... why not use HTML img. Well what if I want a cacheable and responsive image. &lt;CacheableImage src={bgImageSrc} class={style.responsive} /&gt; Wait.. whats a CacheableImage ? its a Component that internally handles Cacheable state. ie.. downloading the file, caching it, understanding when the cache is expired, etc.. Now everywhere you want a cacheable image component.. use &lt;CacheableImage&gt; I maintain the [react-native-cacheable-image](https://github.com/jayesbe/react-native-cacheable-image) component Anything you want to reuse can be considered a component. Maybe you have a carousel of images.. &lt;Carousel&gt; &lt;CacheableImage /&gt; &lt;CacheableImage /&gt; &lt;/Carousel&gt; The Carousel component handles everything required of a carousel.. but has nothing to do with the images. These components can exist separately and be used separately, between projects, however you need them. Maybe you dont need a Carousel. Maybe you need a Carousel for Containers rather than Images.. Don't know if this helps you lol. 
I believe React didn't have patents.md initially. It was only after it started becoming noticeably popular that patents.md was slipped in (please correct me if wrong). Likely if yarn becomes popular, same thing will happen.
What do we want?! NOW!!! When do we want it?! LESS RACE CONDITIONS!!! 
http://stackoverflow.com/a/4585031/847382 If it's only changing the hash, you can use window.onhashchange.
TypeScript is just way more accessible which wins it for me. If flow was written in flow-JS instead of OCaml I might have used it. 
No shirt, no shoes, no semi-colons, no service!
Github is down at the moment for me so I can't take a look at the specific code, but what you said seems to make sense. I guess my main question is that I don't see how a component written with JSX is necessarily better than a component written using JS and an HTML template. I know it might be a preference thing for some, but I'm wondering if there are huge advantages or time savings that I'm overlooking.
snake_case is definitely not common in the JS community. That kind of param wrapping gets really annoying really quick. It does help when you have 8-12 Params, but I'd argue you have a different issue if you have more that 5 params. ;-)
Character limit? Are you referring to that crazy rule from 30 years ago that says you can't type past 80 characters because it wraps in editors that don't have scrollbars? ;-) Yeah, not a problem.
I feel like multiple inheritance, or even inheritance in general, is a "just don't" kind of thing. I have yet to see a real use case for inheritance on actual classes in JS. In my view, the Interface-Implements pattern is more useful. 
cant add anything in between website's code
In the end it needs to be about saving time. It's not that writing in JSX saves you time.. its the methodology behind React that saves you time over the entire lifecycle of your product.. and why new frameworks (libraries?) like Vue and others are coming out that provide similar state management like React. I believe in any case.. at the beginning I was at a crossroads myself.. Angular (Ionic) or React (Native). I was forced to use React for a development test for a position I applied for. I had already started a personal project using Ionic.. purchased a theme the day before. Then I started with React.. never looked back. 
Vue actually tries its best to have a stable API. Even their jump from v1 to v2 had less breaking changes than some minor version jumps in React did. The templates are an extra abstraction layer. It's like using an ORM over a query builder or just plain SQL. If you switch from one to the other, it's of course gonna be very different code, but it's an extra abstraction layer that will come in handy for many.
I suppose it's a matter of preference, but I've found that imperative-minded devs tend to prefer templates, while functional-minded devs tend to prefer jsx. Doing something simple like looping through a list is a pain in templates. Angular is different from Vue which is different from jade. Jsx is ***just Javascript***, meaning you can use all of the constructs that every Javascript developer knows, `map`, `filter`, etc.
I would argue then that your JSX templates (and they *are* templates) aren't designed properly if you're relying on things like map and filter. That's programming logic, and it does not belong in your templates, because it needs to be easily testable. Your templates should be as *stupid* as humanly possible, literally paint-by-numbers. So stupid they're not even worth testing. Meanwhile their view model should be responsible for distilling the data structure down to a "plug n play" format to be used in JSX in the simplest way possible. You then test that view model to make sure all of that logic is correct.
I use semistandard at work, same with semis :) 
Some people are still suspicious of React's licensing and patent jargon for one. Vendor lock in and technical debt if FB ever decides to go another route, or only support one paradigm that no longer fits your use case. HTML/JS separation of concerns. It's a bit harder to reuse your UI in another framework if it's all mixed into JSX. There are some reasons, they're pretty obvious though.
no, vue.document
Whats so good about yarn?
I've used Vue for work. The breaking changes between even minor versions were a pain.
I use 4-space indents, semicolons (they signal intent "this line is finished"), lowerCamelCase variable/function names/property names, with an exception for values coming out of / going into database / web services. I only use `+` for addition, use string interpolation for concatenation. 
Gangsta removed :/ https://github.com/npm/npm/commit/643dae2197c56f1c725ecc6539786bf82962d0fe
Exactly... That's like &gt;Hitler: The Good Parts
You can certainly use templates in a purely functional way.
It still sends me to the /match route which displays raw json. My ajax call looks like this: $.ajax({ url: 'http://localhost:3000/matches', type: 'POST', dataType: 'json', data: {'hello': 'world'}, contentType: 'application/json', success: function() { console.log(data); } }); Heres what the post route looks like in my express server: app.post('/matches', function(req, res) { db.collection('matches').save(req.body, function(err, result) { if (err) { return console.log(err); } res.send(req.body); }); });
the value of the guns ect. dont matter, because there will be logo´s or sth like that
i love snake_case. i find it way more readable than camelCase.
Since JSX isn't compiled at runtime, and is converted to just JavaScript at build time, you get the benefit of not needing to parse and run the html templates. 
NexT is really cool!
Nah, I doubt, especially now that polymer team announced on summit they will be using yarn - the current wording of FB patent clause is a no-go for some organizations.
I think it comes down to whether or not you consider JSX functions "templates". JSX is, in actuality, **syntax sugar for creating functions**. A JSX element is an *expression* that is *referentially transparent*. It is literally Javascript code. Some teams may like **expressing their views as Javascript functions** (since your view is a function of application state, see: [Why React is functional](https://www.youtube.com/watch?v=1-Btq9U2T24)). Some teams may like **expressing their views as static html**. Using html seems like a good idea at first, until you realize that html is for static interfaces, and websites today are dynamic. With JSX, you give up on the idea that html can be twisted into expressing dynamic views and just write your views as a pure Javascript function. Which, btw, is *much* easier to test in a vacuum.
We waffled on this, but we decided to use them after learning that a missing semicolon is actually a JS syntax error. The runtime simply corrects it for you (in most cases).
I believe JSX is an evolution of HTML. I no longer think in terms of &lt;a&gt;&lt;/a&gt; or &lt;img /&gt; or &lt;div&gt; etc... because these are static constructs. JSX allows me to define dynamic constructs that are composed of arbitrary HTML. 
http://webcomponents.org/ ;) Why you think you need JSX mess for that is beyond me.
And it still redirects after you have prevented the default event?
Except in a language where the vast majority of the standard APIs, popular libraries and frameworks are `camelCase` it just ends up looking like a complete cluster fuck.
exactly how is yarn going to "destroy" npm?
snake_case is really more readable.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programmerhumor] [Figured out the DDoS cause while browsing reddit • \/r\/javascript](https://np.reddit.com/r/ProgrammerHumor/comments/58pute/figured_out_the_ddos_cause_while_browsing_reddit/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Maybe add something like this? getKey.on('shift+enter', callback); I think possibility of adding something like 'e+space' with callback will be killer feature.
By being faster, more secure, dealing with dependency lockdowns much better, and a slew of other improvements.
Thanks, man. Interesting to hear people's opinions on this stuff.
The majority of JavaScript devs and code use semicolons. The majority of styleguides use semicolons. The consensus in the JS space is to use semicolons. Deal with it.
Semicolons serve a purpose. Even if they made no difference in code behavior, which they do, they would still serve an important purpose: to act as an explicit statement termination character.
I don't know about Gitlab, but Vue is not part of ycombinator, its only "income" is a patreon campain. http://vuejs.org/support-vuejs/
https://unity3d.com/learn/tutorials/topics/scripting Create Unity games with javascript.
When we're comparing templating languages to JavaScript, all templating languages often severely lack: static typing, runtime validation, tooling support. JavaScript (or any JavaScript-compatible language) will always be better than any of those templating languages. It would require a huge effort to get to the level js is at currently. The gap will only widen in the future.
Yeah how is this considered a good example? I could write this in about the same amount of code with Knockout. I don't know a ton about Vue.js yet but I know it has a lot more power then what they're showing. I just think this is a poorly thought out article. 
except it relies on the npm registry (via proxy)
I really wish this explained more about the power of Vue.js. What I saw could be written with a bunch of frameworks with code that simple. I currently work on a Knockout based project and I could write this in the same amount of code or less. &lt;div id="journal"&gt; &lt;input type="text" data-bind="value:message"&gt; &lt;div data-bind="text: message"&gt;&lt;/div&gt; &lt;/div&gt; ko.applyBindings({ message: 'Your first entry' }); edit for formatting
*fewer
&gt; I'm curious if you have an example of where JSX outshines HTML? JSX is JavaScript. Better yet, JSX is a JavaScript function call – they're composable. You're comparing that to a templating engine*, with all the shortcomings of any templating engine. * I believe by HTML you actually mean vue templates: HTML, vue.js-specific attributes, variable interpolation, etc.
Documentation would have been the most interesting part of that tool. Explanations about each key, what it does, a link to its w3c standard, and a simple example how to use it. 
Thank you!
It is a wonderful thing. I started using it back in 2012 and it blew my mind. My product still uses it to this day with great success. We have teams that use React/Flux and Angular but from what I've seen we produce superior features and code. We've had years to create custom bindings and patterns that just work. Since 3.2 we've been creating custom components and haven't looked back. Additionally a good portion of the code is under test too. KO can be exactly what you want it to be, you just need to invest. I think KO isn't as big as it could be because of the time that it came out at. Back when it was first released concerns like IE6 support were around. I don't even think Node had reached 1.0 yet. Isomorphic JS apps didn't even exist. Even the idea of writing an entire app in JS wasn't something people thought was possible.
[Hahaha yea silly](http://www.theverge.com/tldr/2016/5/4/11593084/dont-get-busted-copying-code-from-stack-overflow)
Are you saying you can't read Python or Ruby?
In python, you know what's going on. There's also significant whitespace.
Ahhh I must have just skimmed right over that and not realized. I'm glad you got it working, first and foremost. Lastly - thanks for the kind words, man. I really appreciate it and it means a lot. Trying to make it work isn't easy but I'll keep plugging away. All the best to you :)
I wonder if silliness can be a legal term (I was being silly your honour, I swear! I can't be held responsible for my silly actions!)
it's not that big a deal to me. a) i spend most of the time in my own code, and b) it's a good reminder when i do call outside my own code that it's something i don't control, which often leads me to researching more about what happens outside my reach. i've saved myself a lot of npm dependencies that way.
I think it's the reverse. A potential attack that allows pages to attain the elevated privileges of an extension to execute malicious scripts. I'm not an expert, but the other way doesn't make sense since extensions already have greater privileges than a web page.
I believe he is upset at their bullshit PC reasoning for removing it. They could have just said "removed unused alias".
http://codepen.io/anon/pen/JRwxkO ? There u go.
have you had luck running scripts with `yarn run`?
http://codepen.io/anon/pen/dpwajZ With the button alert
I've been writing JS long enough to &gt; ..know what's going on.. Going with the grain is a good argument for using semis... acting as a "statement termination character" is absurd.
The parser essentially runs as though everything is on a single line until it finds an error. It determines if the error can be solved automatically and if it should. Using semicolons prevents the internal error handling needed by ASI. 
Honestly, I'm fine with the pseudo-intellectual "dur hur i like python bettr" and "le no semicolons" hipster shit, I'm fine with people having special babel transpilers to make JavaScript more like their esoteric pet languages (that are apparently literally perfect and JavaScript is both shit and children's toy), but semicolons _are_ standard in JavaScript and calling your objectively non-standard linting library "standard" is some arrogant shit.
It's not a syntax error, it's called ASI, and it's good to know: http://www.2ality.com/2011/05/semicolon-insertion.html A syntax error is an actual error, and will throw.
I can't comment on the rest, but regarding this one &gt; Linting worked on the command line (for errors) and what not but getting any official language support in your IDE is not going to happen, as esinting works in sublime text. so it is up to ide for supporting linting, not framework authors
You're preaching to the choir... I'm eagerly awaiting the point we decouple the javascript middle/front-end from the backend and the senior dev that got to define these styles are no longer in charge of the global style guide.
That's how the spec defines ASI, but it's not actually how parsers implement it. Most just have an "eat semicolon" method which looks for a semicolon or a line break or '}', and throws if it doesn't find one of those.
I may be the only one to admit this, but I really liked Dojo back in the day. 
Thats why I keep my IE up to date, so I can reinstall Chrome faster if needed. 
Would it not be sufficient to set the background-size to contain and have the background position to center center? 
"inclusive"? Give me a fucking break. Sick of you people already.
12.3 Kloc -- damn tho
Here are some comments from Brendan Eich, the creator of JS, that I am basing this on. https://brendaneich.com/2012/04/the-infernal-semicolon/ "The moral of this story: ASI is (formally speaking) a syntactic error correction procedure. If you start to code as if it were a universal significant-newline rule, you will get into trouble."
See my reply above: https://www.reddit.com/r/javascript/comments/58oli0/comment/d92r82s?st=IUKRORFK&amp;amp;sh=993c1cbc
what do you mean? The background size on my css file is a percentage so if i used "contain" it wouldn't be the size i want. I tried it out anyway (i also changed the position to center center) and it didnt work. I also tried putting center center in the js (where it says 'center') but that didn't work either... 
&gt; Especially concerning 2 vs 4 spaces Use tabs and then each person can set the width of their tabs in their editor :)
It's completely unnecessary to politically grandstand like this in one's commit messages. Time and time again this type of thought and speech policing has proven to be regressive, excluding more people than it includes and preventing honest and open communication. Maybe if the team wasn't so busy wasting cycles on stuff like this they could improve npm to a point where we wouldn't need an alternative like yarn.
Hard to say without looking at you css too, but I think you can try using 50% instead of the word center. Also, this css on your .parallax will help smooth it out: transition: 0s linear; transition-property: background-position; 
If the vast majority of the JS community jumped off a cliff, I should too, huh? Not to say it's a valid analogy when talking about simple style preferences, but I've been without semicolons for years now without any issue whatsoever.
Well, sticking with the majority style makes it easier for others to contribute to your code and vice-versa.
codepen.io is your friend here. It's hard for anyone to help if we don't know what you're doing. Even just recreating a simplified version of your problem you'll probably come across a solution
What is gained by keeping the JS separate from the template? Seems to me like one is tied so tightly to the other, that most updates will require changes in both. Lets divorce ourselves from the DOM for a second. Lets imagine you are designing a class that manages some internal state. At some point you want that internal state (and some other arguments) to be combined into another data structure. Is it not ok to add a method on the class to do that combination? Personally, I think its very reasonable to just add a `combine` method. This is basically what a react component is. `combine` is of course called `render` instead. This design doesn't suddenly become hard to reason about just because we are talking about returning virtual DOM nodes.
Idk why but the js effect isnt working when i try to use codepen.io but here is a [comment](https://www.reddit.com/r/javascript/comments/58rpeq/how_can_i_vertically_center_a_background_image/d92s6y9/) i just posted here that has the CSS i used and a link to the webpage im talking about with a bit more info.
Hubspot.com
But shouldn't that mean that they should simply disallow the use of eval within extensions?
Not using semicolons isn't going to kill anyone. Also, for the record, the standard linter _does_ catch the caveats when not using them (even then, I've only run into it once in recent memory), and people are perfectly fine off now contributing to projects that do use standardjs. The bottom line being that going with the majority is hardly a valid reason for doing _anything_ much less tacking an extra, arguably unnecessary character at the end of every line. I sound like I'm making a mountain out of a molehill about this, but only because people _really_ love to overstate the importance of something I've literally never needed ever since learning I could do without them.
It seems that the way jsx works can be reused across frameworks. The way vue, angular, etc works cannot be reused. Their logic constructs are very similar but still distinctly different in syntax. Adding custom logic-like attributes will probably break any static analysis that supports that framework. Any static analysis for one framework doesn't transfer to others that easily. For jsx this is a bit different. After preprocessing the tags away, you're left with plain old js/ts/etc. Static analysis can happen much more easily on those languages. In addition, there are probably nicer ways to describe the elements compared to jsx. If you're using a lisp it might be nicer to use (MyElement ...) compared to &lt;MyElement .../&gt;, so jsx will not be needed at all.
I follow StandardJS, except with trailing commas in multiline arrays, objects, and function arguments, since it makes rearranging things on lines much easier. As far as 2 spaces / 4 spaces / tabs go, I don't think it matters that much. I wouldn't mind adhering to anything in that regard.
Do you mean the \^ symbol? It means "super" which, in the reddit web client, makes the text after it smaller and have a higher line height. Each \^ increases the effect. Are you using a reddit client that doesn't support it?
&gt; The code in question relies on Automatic Semicolon Insertion (ASI) and so cannot be minified except by parsing fully (including ASI) I'm confused. Why would a minifier _not_ need to rely on source parsing to minify _any_ code _ever_? This example is cited: a = b + c (d + e).print() Which, alongside starting a line with `[` and others, can cause problems with ambiguity. It's a good pitfall to mention and a good one to know about, but it's pretty much the only one ever. It's solved by assigning `d + e` to a variable, like a reasonable person, or optionally prepending the line with a semicolon. There's also a weird one: a ++ b Except nobody writes code like that. If they did, I'd rip it out of their repository and beat them on the head with it.
AirBNB with some changes to allow me to interoperate with the rest of my group at work without having to see red squiggles everywhere. 
That's fair. If the OP wants to go with the majority, it's best that they do, and that's perfectly fine. Standard isn't the majority, yes. However, that doesn't make it irrelevant. It's still adopted by a good amount of people, and I'd argue that it's existence is beneficial in educating people more about the language they work with. I read this in a video/article as a good case against semicolons, relating to teaching new users of the language. It talks about making micro decisions while programming. Here's an example the video used: function foo () { // body } let foo = function () { // body } Both of these are methods of defining a function, but you only put one semicolon after the other. Why? Because it's a variable declaration, not a function declaration, alongside other rules, etc. etc. In this case, it's easier to just not worry about where the semicolon should go, no? The ASI rules were made with common conventions in mind, and as we continue to follow those conventions, save for the (very) few caveats mentioned before, issues will rarely arise. 
That's funny... Apparently so: the Reddit iOS app. Edit: thanks btw!
How does removing the word "gangsta" make some people feel better? I feel like this is another one of those cases of some people saying "oh but what if *some people* are offended by that", because it makes you feel like a good person to think of other people's feelings or something. But in reality, those *some people* don't exist. Have you actually ever *seen* anyone get offended by the word "gangsta"? Why would that even be a thing? And as a result of that behaviour, the internet is now scrambling to censor anything that "some people" might get offended by, when those people, that are supposedly getting offended, are nowhere in sight.
What kind of keyboard is that?
This is a step in the right direction, but one problem I spotted is that the event system itself is global. You're registering functions to certain strings and sending strings to the global event handler. There are better ways to send messages to explicit addresses. One way is to create a reactive stream and pass it to the code which needs to listen to changes. You can combine streams too. Another way is using CSP channels; where you define a channel beforehand and pass it both to event sender and receiver so they can communicate over it.
Looks cute af, would have looked better if the js was in the hat. :P anyway, I hope she at least won a dinner and a massage for that. 
&gt; I think beginners have a lot more issues with things like function scope, etc than putting semicolons where they aren't necessary. Beginners have trouble with lots of things, but semicolons were definitely one of them when I first started out. I don't speak for everyone, though, but I'm fairly certain I still speak for a good few. &gt; It's not easy to forget a semicolon, because I have a linter. And don't say that's a cop out, because Standard is a linter, and without it checking for ASI errors, you can make mistakes as well. Fair. &gt; Semicolons are like periods: sure, I can write every sentence on a different line, and it would be just as clear, but periods are still useful because they are an explicit statement ending. I don't have to look beyond, to the next line, to tell if I have more stuff, because there's a semicolon to tell me "Done. Next thing." I don't agree. The end of a line itself _in well-written code_ (emphasis on that) is a good indicator of when the stuff on that line is finished. You can't equate periods in English to semicolons in JS because one is required, the other isn't. &gt; Don't speak for what you assume my experience is. I didn't really mean 'you' directly, but still. &gt; Even assuming this is true, why is that an issue? You should be focused on readability and maintainability when coding. It's one of the biggest concerns you should have on your mind. Code readability and maintainability is important, but it's second to making your application work. Microdecisions add up, especially if it relates to where and when to put semicolons. &gt; You can omit brackets from around if bodies, but you shouldn't, because they show you where the body begins and ends, explicitly. You can omit the spaces between keywords and parenthesis, but you shouldn't, because the spaces help separate them from function calls. Mandatory semicolons follow this line of logic. Alright, fine, we're mostly arguing over preference here, but really, the end of a line serves as a perfectly fine "this bit of code is done" indicator as a semicolon, and without less clutter at that. I guess it's strange to me to argue otherwise, but opinions are just that.
QWERT...Z. Please explain, I want to get some sleep tonight.
You don't generally need access to 'this' as they should really be used as pure functions, you can however pass in 'this' as a second parameter. From looking at your jsbin I don't think you understand how filter works, it should contain a function returning a boolean. Recommended reading for understanding 'this' - [You Don't Know JS: this &amp; Object Prototypes](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/README.md) For functional array calls - http://reactivex.io/learnrx/ 
It's a [Microsoft ergonomic keyboard](http://www.novatech.co.uk/products/peripherals/keyboardsandmice/wirelesskeyboards/l5v-00006.html?gclid=Cj0KEQjwnKzABRDy2pb7nPSazdsBEiQAI4lZQFFzWy7I0nr7lOn8Bppv0dDXG8IRo1YT-ZF5grNcez0aAjiY8P8HAQ#utm_source=google&amp;utm_medium=base&amp;utm_campaign=products), I used to own one, they are damn comfortable. The only downside is that everyone in the office simply must tell you how weird your keyboard looks every time they come over. Edit: a link.
You have multiple approaches to state management its a library not framework so you are not limited in any way. You can use flux if you want, you can do it the way you described above. Not to mention elements can have watchers that "affect everything". Try it out before you start pointing out advantages of other solution when you can have the same elsewhere.
Your keyboard looks weird. 
https://en.wikipedia.org/wiki/QWERTZ
Yep. This is the official Reddit iOS mobile app!
forEach: - Allows passing a function for some convenience - Iterate over both keys _and_ values instead of one or the other - Better browser support (unless you're using babel) for..of: - Looks a little nicer - Allows `const` declaration for some variable safety That seems to be pretty much it, otherwise they're mostly the same.
Also worthy of consideration: * `"func-style": ["declaration"]` because there's no problem with it, it looks better, and sets the `name` property of functions * `"space-before-function-paren": ["never"]`, although I only tend to use declarations (with names) and arrow functions (where this rule doesn't do anything) * You bet your ass I'm using iterators and `for..of`. Arroay methods are for processing an array functionally without side effects, `for..of` and other loop kinds for imperative code. I ban using `forEach` * `"eqeqeq": ["always", {"null": "ignore"}]` as `if (thing == null)` is a common idiom checking if something is undefined or null. * `"indent": ["tab"]` because of too many reasons to list. * `"semi": ["never"]` because it's cleaner, and when you use a linter anyway, any theoretical potential for problems hours away (not that I ever had a bug resulting from it) * Properties (`get foo() {}`) all the way! Fuck Java-style `getFoo()` methods, they have no semantic coupling, are purely a convention instead of being ingrained into the language, and you have to change the API if you want to add `set*`/`get*` to an existing field
native for (i++/in/of) is always faster than functional version (for-each, map) etc. http://jsben.ch/#/BQhED The general rule is, it doesn't matter for less than say 1000 entries, but you should not do `.forEach` on 100000 entries(not that you can't). And also the `break` is a feature only in `for`.
You forgot one important point (IMHO). `for..of` supports `continue`, `break`, `return` and just about any other flow control you want to use (just like any regular loop). Foreach doesn't. Example: async function countTheStuffs(stuffs) { let count = 0; for (let stuff of stuffs) { count += await countAStuff(stuff); } return count; } Another important point is that `for..of` works on anything. You can create your own iterators, and use `for..of` on them.
It's not the coupling that's the problem, it's the simply matter of organization. For simple elements it's not a problem, but for anything large and complex enough belongs in its own file.
&gt; What is gained by keeping the JS separate from the template? Readability, navigability.... I mean by the logic that JSX is ok, so is a giant chunk of jQuery at the bottom of an HTML document. I was under the impression that years ago, developers realized it was a fundamentally bad idea to keep these two things in the same document, even though they were tightly coupled.
This is so true. People complain about JavaScript fatigue while they could only learn fundamentals and pattern. Once you master them, you can use whatever framework is suitable for the project without many problems
I'm happy with PHP and JQuery (not trolling)
Thanks for sharing that! Perhaps my information is too dated and I should change my stance. To be fully honest, I work in TypeScript most days and it has some places where it really wants semicolons to be there, like class property definitions. If you have to put them some places, it feels more consistent to use them everywhere.
String interpolation is a nice option when you have it, but if you need to support any version of Internet Explorer... it's off the table :-( (ditto for the stock default browser on Android)
Glad I could hit the nail on the head ;)
I know its brendan eich, but that really just sounded like someone complaining about code style with no reasoning. ASI isstill just a language feature as is hoisting. Though i agree its good practice, if you know what youre doing i dont see any wrong in ommiting semi colons.
Dawwwww but it's so cute :(
Doesnt work for my situation but thanks anyways
Or @latest or @4.x
jQuery works perfectly fine if you build a regular website with a few interactive widgets like tabs, carousel, accordion, image zoom, date picker, and so on. Each of those widgets can be implemented as a jQuery plugin. The configuration for each widget instance can be inlined next to the required markup (convenient if you're using some CMS). At the very top of the page is a small snippet for storing the configs and at the very bottom is another small snippet which iterates over the configs and instantiates those widgets with the specified arguments. It's simple but very effective. Just add some naming conventions for the CSS and there won't be any problems whatsoever. The architecture is also completely flat. Each widget is it's own separate thing. And if you want to make two widgets talk to each other, emit namespaced events. I actually kinda enjoyed working like that. It's very straightforward and easy to teach to JS beginners.
for me, array methods scream “functional code”, and for loops scream “imperative code”. therefore i never use `forEach`. if i want side effects i use iterative style, if i want to consume an array into another value, i use filter/map/…
I see you like Windows and IntelliJ.
Something like this? http://codepen.io/anon/pen/mAvbpG
agreed, aside from the fact that scopes came too late and are barely used :( I just don't like the thinking that "wow new shiny thing let's destroy everything else". 
Hi /u/superpoops56, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
## Highlights - **production:** ready for and used in - **foundation:** very simple core for building more powerful routers such as `koa-rest-router` - **composability:** group multiple routes and multiple routers - see `.groupRoutes` and `.addRoutes` - **flexibility:** multiple prefixes on same router - **compatibility:** accepts both old and modern middlewares without deprecation messages - **powerful:** multiple routers on same `koa` app - even can combine multiple routers - use `.extend` - **light:** not poluting your router instance and app - see `.loadMethods` - **smart:** does only what you say it to do - **small:** very small on dependencies - curated and only most needed - **backward compatible:** works on koa v1 - use `.legacyMiddleware` - **maintainability:** very small, beautiful, maintainable and commented codebase - **stability:** strict semantic versioning and very well documented - **tested:** very well tested with 100% coverage - **lovely:** ~500 downloads for the first 2 days - **open:** love PRs for features, issues and recipes
Just because some people decided something was a bad idea years ago, doesn't mean we should just blindly follow that rule. The difference now is that people are structuring their applications based on small discrete components. These components include the ability to manage state, and then combine that state. The application can be more readable because you can look in one place to understand the job of a component (how that component manages state, and then renders). You also navigate the project based on components. If you agree that a class that manages its state and has a `combine` method is ok, then you should be ok with this unit of application structure. Sure, if you do not write your code in such a way where you have discrete components, it will be about as ugly as "a giant chunk of JQuery at the bottom of an html document", but thats why when using react you write components. I understand being apprehensive, I was apprehensive, but these are questions that were addressed when react first came out. I am going to go out on a limb and assume that you haven't written a lot of react components. To your point regarding readability, anything unfamiliar will take a second to get used to. React has a learning curve coming from other libraries too, I will give you that. But, to say that react code is always unreadable and terrible because people in the past told you to do things differently without digging into _why_ this is the case is a little short-sighted. If you would like to learn more about why those who develop react components believe that its ok to have a render method, you can search for "separation of technologies react" or just check out [this video](https://www.youtube.com/watch?v=x7cQ3mrcKaY&amp;t=128). I am not expecting you to become a react fan, I am pretty sure you have made up your mind in that regard, but maybe you will realize that your own biases against react's approach seem to be rooted in the idea that "we have always done it differently" and are not universal.
I don't see a "rank undefined error", I see a "$ is not defined". Looks like you need to include jQuery. That being said, I don't think your problem is "this", I *think* it's that you're trying to access an array element that doesn't exist. One way this could happen is if you try to assign to an array index that's higher than the array length. Try this: var x = new Array(); // BTW this can just be "var x = []" x[1] = {rank: 'fake rank'} x[1].rank // no error x[0].rank // Uncaught TypeError: Cannot read property 'rank' of undefined Now, you're getting this error from your score method, which does "for (i = 0; i &lt; this.cards.length; i++); {". If you've assigned to an index of cards higher than it's length (as we did above with "x[1] ="), lower indices of cards (just like "x[0]" above) will have undefined values. When you try and iterate over those undefined values and access the "rank" property of undefined, you get an error. I suspect your real problem might be in your shuffle method (as it assigns values to cards by index), but I'm not sure. The point is though that your problem is putting "undefined" (probably by assigning to a higher index, but possibly some other way) into your cards array. You just see the error later on in score because it tries to access that undefined. I'd try adding some "console.log(cards)" lines anywhere cards changes, and watch for undefineds being added. Also, two side notes: 1) "$(document).ready(function..." can just be"$(function..." (jQuery does this as a convenience) 2) when you do "this.score = function() {" to create a method inside a class function, you create a copy of that method every time you instantiate the class. In other words, "new Hand(); new Hand()" will put two copies of the score function in memory. That won't be a problem in a simple case like this, but in general the preferred method of defining methods in Javascript is to define them on the class's prototype: function Hand() { this.cards = new Array(); // you want separate "cards" for each Hand } Hand.prototype.score = function() {...} // you don't want a separate "score" method new Hand().score(); // this will work, because "new Hand()" gets all methods that were on Hand.prototype // but there's only one "score" method, the one on Hand.prototype; "new Hand()" just uses it If you've come from a classic OOP background that probably doesn't make a lot of sense, so here's a quick prototypal inheritance explanation: A) every object in JS has a secret `__proto__` property. You can't see it in the code, only in the debugger. B) when you do "var x = new X()" the `__proto__` property of `x` gets set to the `prototype` property of `X` C) when you call a method on an object (eg. `x.score()`) and the object doesn't have the method in question, Javascript looks for that method on the object's `__proto__` (ie. if there's no `x.score`, try `x.__proto__.score`) D) if the object's `__proto__` doesn't have the method, then JS looks for it on the `__proto__` of the `__proto__` (eg. `x.__proto__.__proto__.score`), and if that doesn't it work it tries the `__proto__` of that, until it runs out of `__proto__` to try. Hope that makes sense, but if not there are lots of pages out there that explain things in greater depth. Good luck! **EDIT*: Edited to fix `__proto__` formatting
Take her with you? I would try to find a mentor, this stuff can be pretty hard without someone to help you out and sometimes point you in useful directions. There will be a lot of things that you don't know and that you don't know that you don't know.
I've spent 4 days weeping in front of my computer screen, and now I removed the semicolon.. it works. Thank you, you beautiful person.
No problem. An IDE won't usually catch that as an error because technically it's valid javascript.
&gt; React was not built for a dev experience I pretty much disagree with this. Not comparing to Vue, and not saying React (and its tools + ecosystem) is the best in this regard, but it has in general very good dev experience compared to other component based frameworks/libraries we used previously (extjs, dojo, vaadin, swing) and other frontend technology (plain js, jquery, aui, jsp, angular 1).
I understand the point of the keyboard and don't think it looks weird. But every time I have to type on someone's, it's like I'm 6 years old again, having to very patiently watch my own fingers in order to hit the right keys. When you use that for long enough, can you type perfectly fine on a normal keyboard, or do you struggle, having gotten used to the ergonomic one?
I asked OP but I'll also ask you out of curiosity and sample size. Now that you've used it a lot, does it make typing on normal keyboards more difficult? Or can your brain and hands switch between the two different styles very easily? I worry that if I got used to it, I would be hamstringing my ability to adapt to the rest of the world.
React is pretty slick. Vue, OTOH, looks painful
I do not like most of these. This is why it's great that linters are configurable. I will however, offer my counterpoint for these rules. * `func-style` - I allow both. I usually use declaration style, but find function expressions too useful to exclude. * `space-before-function-paren`: Very simply, my syntax highlighting in Sublime doesn't kick in for functions without the space. * I'm all about that space. * I'm team semi-colon all the way. Honor your roots. I'd fight you if I had to work with you, but until I do, live and let live. :-D
@latest didn't work for me when i posted. gave me 3.9.1.
oh my god do you even hear yourself. "first they came for my npm aliases..."
That's good. Can you share it open source? Why not two separate repos in github ;] So we can continue developing it. Cuz I don't like tha architecture of benchmark.js really much - especially the async benchmarking - it's a lil' bit tricky and confusing sometimes.
Yes. Porch did so when React came out, rewriting a whole Angular codebase.
Good point, thanks. I don't have a style yet, I only started learning JS 3 weeks ago lol.
 var MyObj = function() { // Lexical this var _this = this; this.array1 = ['a','b','c','d','e']; this.string = 'This is a message'; this.method = function() { var _ = this.array1.filter(function(d) { out.appendChild(document.createTextNode('\n'+d+' '+_this.string)); }); }; The issue is that every function secretly defines its own "this" value, so your filter callback's local "this" shadows your MyObj's "this". We can avoid that by assigning MyObj's "this" to a variable of pretty much any other name that won't be shadowed in the inner function. I used "_this" but "that" or "self" are also popular choices.
I made a website to provide examples of mithril.js (front-end framework) in use as a side project this week. https://mithril-examples.firebaseapp.com/
Glad I could help, but kudos to swolecoder for finding the real issue!
Thanks for writing this! I noticed in the article you also talked about Either and IO types. Is prior knowledge of those functional concepts assumed or is there a previous article that goes over those two?
Comparing JSX and PHP is pretty irrational (meaning emotional). PHP is string concatenation. JSX is actual syntax, and on top of that it's easily translatable to React.createElement(). 
You will have to use a timer to iterate through the loop. This is bad practice. What are you doing which takes this long? Accessing the DOM will also slow down your function.
I would suggest getting rid of the "generate page url" button. The URL with a unique identifier should be available the moment a new test is created. Here was my test test, which was surprising, http://jsben.ch/#/93xLt I believed sample 1 would be faster than sample 3, but didn't realize it would also be faster than sample 2 since sample 2 stops on the first result.
JavaScript execution will lock your browser. Therefore a progress bar wouldn't be useful as it too would be locked from execution.
It took a few days to get used to it, the main problem was trying learning which keys *belong* to which hand, the Y key especially. I didn't have a problem switching between keyboards, sure it feels weird at first but after a few minutes you slip back into old habits. In fact, using a normal keyboard really highlights how much more comfortable it is to type on an ergonomic one.
Don't follow the hype train. Use something that works for you. For our team, after using multiple frameworks, vue.js feels the most sane to our company. Less stackoverflow, less bugs, shorter time to develop SPA. Businesses don't want developers to spend time configuring webpack, changing new libraries. They don't give a fuck about framework. What they want is the final product in quickest time. They also want developer happiness and get new developers quick working on a product without bugging senior developer on how to setup js environment. 
I was obviously talking about the experience I had with the 1.x version. Yes, I know that (apparently) 2.0 fixed this, but now it's late. I wasted sooo much of my time trying to "fight" this thing so... I don't really see a reason to go back to something that made me go through so much shit, thanks. Edit: I decided to give it another try, who knows...
Yes. Rebuilding own code and billing client is one great money maker.
I've written a [bit about IO](https://medium.com/@dtipson/let-s-make-jquery-a-monad-7df0e79a842d#.hwf5h52xn) and [Maybe](https://medium.com/@dtipson/getting-something-from-nothing-4645b8c1ffc6) (learning about Maybe is a good intro into Either, though the latter is generally more powerful). I'll add those links to the main article. IO is just a type that captures side-effects in a pure way: basically allowing you compose together operations without actually running them yet (until it comes time to run them, of course). Think of it as a sort of thunk manager. It's not particularly exciting in javascript (nearly everything IO does, Tasks can do with more flexibility, and you can naturally transform any IO into a Task), but very instructive to learn about. Either is a binary union type that is always either a Left type (with a value inside) or a Right type (with a value inside). If you're familiar with Promises, you can think of these as rejected/resolved branches of a Promise, but much simpler and synchronous. The main difference from a Maybe type (which is always either a Nothing or Something) is that both subtypes can hold a value. Just like Tasks/Promises, it allows you to write complex operations that affect one type of value or the other, depending on which is available. 
- Babel - React - Yarn - Other Facebook projects - Express - Koa - Angular - Other Google projects - [Vivaldi](https://vivaldi.com/?lang=en_US) - lodash - async - bluebird - commander - moment - jQuery If you are in an area where you can get things done using only request and leveldb, fine. I don't really care. Saying that most JS tools you use don't use semicolons is explicit confirmation bias. The fact is that most JS projects are written with semicolons, and you have to accept that. Denying it would be delusional. If you don't to use semicolons, don't. I'm not going to make you. I'd prefer, of course, for everyone to abide by the same set of standards when writing JS, but I can accept that some still won't.
It's not the single act that excludes people, it's the mentality of oppressing natural speech and language. "Ganster/gangsta" is, by any moderate measure, an innocuous slang term. Similarly, making a good product and this one single commit message are not mutually exclusive, but the fact that they felt the need to add a totally unnecessary commit message like this is indicative of an oppressive thought policing mentality at npm as a whole.
Ah, I See. The chart might be a bit confusing. Your block 3 is the slowest one. 100% means 100% time. The other two blocks are faster.
Will it blend?
I created http://jsben.ch It's a benchmarking tool for js snippets. My focus was to create an easy and quick to use interface. Example: http://jsben.ch/#/BQhED
welcome to my world :]
Do you keep it next to the keyboard to take advantage of duck typing?
I got that. You even indicated sample 1 was fastest with subtext next to the result. I was just surprised that searching all tags in the page using the vanilla DOM methods was faster than searching for a single element using a query selector. But, you are right that it might make more sense to somehow call that out. JSPerf communicated results in the opposite way where the bars measured the number of iterations so longer bars meant faster results.
*close enough for javascript
Thank you. setTimeout worked out well
I think this is an interesting thing to think about. People feel the need to discuss the merits of complicated tools when they're making complicated projects, not basic "here's what our company does and how to contact us" static sites. Those kinds of sites don't merit long discussions about SPA frameworks. Therefore, inherently the only discussions will be *about* complicated projects. Except beginners will see those discussions and think they also apply to the aforementioned basic company portfolio sites.