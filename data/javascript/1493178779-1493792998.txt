If that doesn't work try this: nvram set wl0_ssid=üê¢ This is my regular wifi nvram set wl1_ssid=ü¶Ñ This is my 5G wifi nvram commit rc restart
It is an overcomplication for a small app. But when it grows larger it's nice to have loose coupling between your read and write side.
You're running in the browser. The browser runs JS with a global Window object. It hosts the DOM API and other browser specific properties and methods. Node.js is pure JS (no DOM stuff) and runs anywhere that isn't a browser. A Node in a browser context is a HTML/SVG/XML element, comment, or text content (maybe I'm missing something). A ‚Äònode‚Äô in the Node.js context is an instance of an app (on a server). 
This looks really interesting! I never knew this was available to ReactDOM? I am assuming [this](https://facebook.github.io/react-native/docs/animations.html#animated-api) is the documentation that goes with it, although it is aimed at React Native? 
Not sure, different permissions I assume. Did the error message change at all, or same issue?
In this case it is probably preferable to just use CSS pseudo-classes (i.e. :hover and :focus)
We've all been there, talking shit when we didn't understand the problem. I spent a month with React, it's great, but it wasn't for me. Was a fun journey to see that side though, but I'll admit it was bewildering at first though.
Not a direct answer, but you might be interested in https://www.wikidata.org . There you might be able to get the URL of the articles main image, if you can manage to get the Wikidata item id of the Wikipedia page.
Have you used React? It's popular, because it works really well and solves a complex problem. Visualization of UI
What Brian said is the gist of it. I'd just add from my experience that altering a massive and complex that every JS engine is to add a new feature is orders of magnitude more challenging than to write a transpiler. And we're operating on a fairly fragile live ecosystem so every change will somewhere, down the road, hit some codebase that relied on the old behavior. Babel can add "global" in a matter of minutes. When we tried, we had to back it out because we broke the Internet. I'm not complaining either. I love what Babel is doing and I think that we couldn't ask for a better tool to test our spec proposals in a non-invasive manner, but the task of adding a transpiler vs. altering the JS engine, VM, JIT engine and compilers is completely different. Also, with the heroic effort to improve our testing situation and with all engines moving to rely on test262 for the conformance, things may get a bit smoother.
I think (?) it's smooth scroll.
I'm working as a web-developer for about 10 years. The main point of custom scroll behaviour is to make scrollbars custom styling. And default scrollbars are not customizable (at least, not in all browsers). So, to make custom visuals for a scrollbar you need to implement whole scrollbar behaviour manually. That's why it could differ from the default one.
In that case i would use PHPStorm over Webstorm... as PHPStorm is essentially everything Webstorm can do, but with support for PHP as well. The simplest way to start a project in PHPStorm is to just drag the root project folder over the app icon, and then the IDE will sniff through you whole project. PHPstorm is also my favourite editor for writing CSS/SCSS. ie if you CMD+CLICK on a classname in an html file, it will take you straight to the class in the CSS file. that saves so much time on its own.
That's odd. I don't see any custom scrollbars on that page. I assume a long time ago it has something to do with improving scrolling UX but somehow mousewheel scrolling got the backseat, thus causing the UX issues on mousewheel scrolling while everything else seems to work normally.
So long?! It used to take years (I'm talking nearly a decade) to get things added to browsers. I'm astonished at how rapidly things are implemented these days. 
Not necessarily when we are talking about boilerplate. That is the actual risk and one of the advantages touted by more succinct languages.
You can do the same thing in IDEA, even in .jsx files. Kinda lovely when the codebase grows
Correct.
Rule of thumb: never interfere with natural scroll behaviour... just don't.
Couldn't you use Preact or Inferno? It's more or less the same API, same eco system, often fully compatible, and they serve compat layers aswell. React has also been dumping [APIs that lock you in](https://twitter.com/dan_abramov/status/855834831384715264) recently, making migration to competing functional viewlayers more and more simple.
Not OP, but I hate smooth scrolling and have it disabled in the browser. Sites that insist on hijacking scroll events stick out like a sore thumb and are annoying as hell because they usually emulate it poorly. If I wanted that I'd let my browser do it. 
I love React. Like, I love its syntax, I love the basic philosophy behind it and just generally enjoy working with it. Unfortunately, however, I simply can't bring myself to use it in production due to the insane licensing terms. I realize that the scope of the offending terms is much more narrow than it was originally made out to be, but the fact that there is anything like that in the license makes me deeply nervous about how they view their role in my relationship with them, and makes it impossible for me to justify using it on anything mission critical.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [tomastrajan/angular-model-pattern-example/.../**model.service.spec.ts** (master ‚Üí 2aae6ce)](https://github.com/tomastrajan/angular-model-pattern-example/blob/2aae6cee8926e58c2a1db52743eb880cd929ac80/src/app/core/model/model.service.spec.ts) * [tomastrajan/angular-model-pattern-example/.../**todos.service.ts** (master ‚Üí 2aae6ce)](https://github.com/tomastrajan/angular-model-pattern-example/blob/2aae6cee8926e58c2a1db52743eb880cd929ac80/src/app/todos/todos.service.ts) * [tomastrajan/angular-model-pattern-example/.../**model.service.ts** (master ‚Üí 2aae6ce)](https://github.com/tomastrajan/angular-model-pattern-example/blob/2aae6cee8926e58c2a1db52743eb880cd929ac80/src/app/core/model/model.service.ts) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dgrny77.)^.
I have asked my question myself too. But does the question why do some browsers implement them faster then the other browsers has the same answer? I would really like to know. Thanks
Requirement: Build a login page that authenticates a user and presents a welcome to user page. userid and password for the use case. You can use any database and any application server. Or you could just tell me if the link here would help me for this simple task: https://www.fullstackreact.com/articles/using-create-react-app-with-a-server/
But Dan basically confirmed most of the original author's issues. Only a few issues were due to the author's misunderstanding, but even those misunderstandings are revealing of the experience one might expect from React. 
You can have your can and eat it, but you cannot eat your cake and have it. 
Idiots who hijack the scrolling feature because they think it'll be cool or something, when it's just messing with basic browser functionality. 
Seems interesting, but a bit different to react, there doesn't seem to be any lifecycle methods like mount/unmount etc? Also, I'm not sure of the ability for server side rendering currently?
What are the advantages of this approach? An advantage of passing an object is that you don't need to remember the order of the parameters.
Why lawyers have anything to say the tech you use? Are they afraid of lawsuits from facebook or something. Isn't react free to use or im missing something?
The license for react isn't as friendly as you'd hope
Aurelia is supposed to be "angular 2 done properly", but it doesn't seem to be getting any traction in the industry. The way I pick a technology, either you have a large community or it's something small enough you can figure it out yourself. Aurelia is neither. Documentation, for example, is poor. react, vue, angular, elm, inferno, preact, cycle, mythril, riot, ember (in that order) are frameworks I would play with before aurelia. This is a quite thorough comparison https://github.com/stickfigure/blog/wiki/Opinionated-Comparison-of-React,-Angular2,-and-Aurelia
&gt; To be clear, react is just your view I think everyone means "the react ecosystem" when they say react, i.e. react + redux and all the rest.
So many of these are going to die off, and rather quickly that. (I say +1 year).
I don't notice any problem with the scroll feels pretty native like? What browser and screen resolution are you using ?
How do I explain this... it's like there's a lag on acceleration and deceleration when I scroll with the mouse wheel. On the trackpad it's fine, scrolls as normal. But mousewheel tends to screw it all up.
Are you using a mouse wheel? There's significant lag on the acceleration and deceleration of the scroll. Chrome, and 1080p resolution.
I highly doubt it's my mousewheel's settings though. Try pressing the down button. There's a significant lag on the scroll, like about half a second before the scrolling happens. 
by observables do you mean `Object.observe()`? No, it's implemented with ES5 getters/setters. Yes it uses decorators as recommended way how to declare fields on a class as observable, but you don't have to use it with decorators. It works quite well even if you call the same method as regular functions.
The whole list or just that one?
Describing layout in functions is, in my opinion, the cleanest approach yet. This was probably the biggest paradigm shift since MVC, i doubt it's going away so fast unless there's a massive, new shift again. As we speak it's spreading to all other platforms. Not just by react native, but now there's [componentkit](http://componentkit.org/) for IOS, [litho](http://fblitho.com/) for Android, [reactxp](https://microsoft.github.io/reactxp/) for all platforms (made by Microsoft). And that is most likely just the first batch. React is still obscure as it's been relatively contained in the web, which it has taken over. But now there's more and more talk about cross platform renderers, this is where it will hit pretty much every platform that produces visuals. The moment it clicked for me was [react-blessed](https://github.com/Yomguithereal/react-blessed), which now partakes in the [eco system with crazy stuff like motion](https://github.com/gaearon/react-blessed-hot-motion). Or Airbnb's [react-sketchapp](http://airbnb.io/react-sketchapp/), which was revealed yesterday. These are almost futuristic and there is an insane degree of freedom that was unknown before. 
Hi @ahdinosaur, ok thanks for explaining. I was thinking about that when I post a message, I sometimes don't want everyone to find out that I posted anything at all (because of privacy), and then I would need another log + another identity, or another tree branch in the current log. I guess eventually I would end up with fairly many identities, per device, if there's no way to have many branches, in a single identity. But perhaps there can be a master identity, somehow, that signs the others. ... But the other identities then need to be signed, without adding an entry to the master identity's log. (For privacy.)
https://blog.feathersjs.com/ssr-vuejs-app-with-feathers-and-nuxt-bb7dfd3e6397
v0?
I agree that Alt hasn't had any activity lately and we probably should have used a more active Flux spinoff. But to me, the idea driving Alt is alive in 2017. We need to find a better way to manage application state.
Because in very large companies you have to run everything by legal. Some think it is the business people running companies, but it's really the lawyers. 
Is the folder structure static? Then you could work with htaccess files. Which would result in a lot of overhead with user-management. My reccomendation would be: Prevent the Webserver from showing the folder structure in the main folder and generate the folder names by hashing something secret. A 256bit-base64-hash should ensure enough entropy to secure the content within the folder. Then just share the secret or the full url with the user.
Instead of using sockets, you could use standard HTTP requests (POST, GET, PUT, DELETE) to do the CRUD. There's a bunch of resources available for that. Example: https://zellwk.com/blog/crud-express-mongodb/ 
I'm assuming it's [this site](http://keithclark.co.uk/labs/css-fps/) being referenced.
What server-software are you working with?
Absolutely. Also, there is a class on Udemy that I recommend to people that want to expand their current understanding of JS that is absolutely phenomenal titled [Javascript: Understanding the Weird Parts produced by Anthony Alicea](https://www.udemy.com/understand-javascript/learn/v4/t/lecture/2322828?start=0). Even with many years experience with JS, I still picked up some really useful knowledge from it. 
I just started working with node.js, but this looks interesting: https://github.com/expressjs/serve-index
It isn't inline in the `style={{}}` sense, it's inline in the js/css colocation sense. The result is the same as everything else: classes on elements. Actual styles are injected into the &lt;head&gt; or via CSSStyleSheet.insertRule().
They are licensed on their own terms. You can't patent a function or the component API. Oracle tried and flew out of court. Most variants do not use them anyway, their compat layers alias to it. JSX is also mostly regular XHTML except the brackets, for which exists prior art. Either way, 8 out of 10 frameworks are now using these principles. I've never heard about Preact and co. being even slightly inconvenienced by Reacts licensing terms.
It's enough to stop a fair number of firms from using it outright. 
9/10ths of innovation is creative destruction. 
Thanks :')
My choice is Angular.
Web components are old news. And you can't use Redux in web-components "just fine" because of it's dom driven oop/mvc backbone. You *hack* Redux into it with dependency injection. Flux was born because functional components made higher order components possible, a functional pattern that is impossible with web-components. I'd say learn React first before making assumptions. While its true that some of its principles aren't new, there has been nothing like it before. Name a single view-layer that had similar outcome.
I considered discussing transducers, but actually these two issues are partially orthogonal. Transducers can be written for working with iterators as well as for working with collections. This article serves to introduce mapping over an iterables, and having internalized that, you can move on to writing a `.transduce` function for iterables (or just use a library like [transducers-js]). I think it was already long, and it would have been way longer if the post had then introduced transducers. _but yes, totally worth mentioning._ [transducers-js]: https://github.com/cognitect-labs/transducers-js Also: https://github.com/raganwald/raganwald.github.com/commit/e660416b72a186335bd8a9319e78e52b5cf66482
Preventing users from changing the experience is *never* highly desirable. We're not talking about contributors editing pages here. We're talking about colorblind people fixing colors. You need to get your jackbooted ass to accessibility training.
Wew, calm down mate. 
Oh yeah. The license. I figured that was the only thing lawyers might object to so it didn't need to be clarified. 
Doing a large project as well, TypeScript is a must-have.
Again, css-in-js solutions rarely use inline styles, they result in classes like just any other website. When they say inline, they mean js/css colocation.
I agree with what you are saying but not how you are saying it. Even if you take into account colorblindness there are simply too many forms for a one size fits all solution. It needs to be left up to the user. 
I don't see why it wouldn't. You can still add normal classes to element, and normal stylesheets, and the browser would match those classes to the styles. Obviously the some rules apply like specificity, definition order, etc but it isn't any different than a plain old website with vanilla css and classes.
i guess a lot of people take off during the christmas season...
Popularity because this is the only option available for web development. Choices for back end is abundant starting with c++ to Java and go. Assumption of better for distributed architecture assumes that all enterprise apps are web apps but the fact is most are not. Agree somewhat with multi platform but so is Java go and python and other dominant languages. I agree it will be only option for web frontend development and might be used for some but significantly less backend code. But too far from future of enterprise dev.
That's my point. Part of accessibility is not getting in the way of individual remediations, and that's obviously not on previous commenter's radar. As for jackbootedness, I can't tell you how many times a gung-ho marketing person has told me "We need to do [asinine, unusable, inaccessible thing] to strengthen the brand." It's short-sighted corporate jingoism that disregards real outcomes in favor of perceived optimization. Take your pick: disabling the back button, forcing all links into a new window, making lists that are 70 items long, autoplaying audio, whatever. All of these things wreck the user experience and have a real negative impact on credibility and user acceptance. I once chose a different car brand because shitty website made it impossible to identify options, and prescriptive solutions from ux-oblivious marketers make shitty websites. I have little patience for people who put groupthink over user needs.
Yes, but even css-in-page solutions make it difficult for users to apply individual accessibility remediations. I have no problem with build outcomes that correctly separate presentation, business logic, and content.
The future of component-based styling is already here and it's called Shadow DOM. Shadow DOM allows you to attach an encapsulated ShadowRoot node to an element hold a components internals. Importantly for CSS, any styles contained within the ShadowRoot are scoped - with both upper and lower bounds. Shadow DOM is shipping now in Safari, Chrome and Opera. You can try it with this little snippet. Just paste into Chrome or Safari's dev console: let el = document.createElement('div'); let shadow = el.attachShadow({mode: 'open'}); shadow.innerHTML = `&lt;style&gt; :host { display: inline-block; background: #ffccaa; } span { font-weight: bold; color: white; } &lt;/style&gt; &lt;span&gt;I'm in a ShadowRoot&lt;/span&gt;`; document.body.append(el); let span2 = document.createElement('span'); span2.textContent = `I'm not in a ShadowRoot`; document.body.append(span2); 
It's kind of fun to look at dips and surges and see "oh that's christmas, and easter, and that's when it was tweeted by X and frontpaged on /r/javascript"
This is an awesome way to think about language (and, in a way, extend JavaScript to yet another paradigm). Thanks for sharing!
I'm using react on a daily basis, also people are using redux or uniflow with web components just fine. &gt; While its true that some of its principles aren't new, there has been nothing like it before. Name a single view-layer that had similar outcome. Ever heard of haskell? Or nixos where whole OS package state is being controlled by a function?
With any luck, there's documentation. Otherwise you look at usage and the source to see how things are used/done. Its not always easy (the codebase I'm working on now is like this - very large, no typing, multiple authors with different styles and code quality) but it works. Code reviews and testing keeps things stable.
I agree. Still on Angular here, and with the component method, component names are really just HTML elements. So it's extremely intuitive to create a `&lt;component-name&gt;.scss` file and scope all styling to the component itself. my-component { styling here... } Then `import './my-component.scss'` from the component itself, and let Webpack manage creating the combined stylesheet of all components. I really hate the, "you can do everything in JS" mindset... It really convolutes what a file extension actually means. I don't use React (jsx), but I went down the Adobe Flex (mxml) route long ago. Even then I thought it was bad.
Now typings are nice but they actually make your code harder to read..if the code is well structured and documented and you follow conventions and of course you know javascript well, you will have no real issues..on the other hand if your code is a mess nor Typescript or Flow will help you in any way..some c# and java guys just can't get the idea that javascript is a different language and that things work in a different way but so far I have seen plenty of great projects without typescript and a few really ugly with typescript..also the other way around..why not just use proper JSDOC
How does one remember even the names of parameters with object params like that? What tells me (you, anyone) that `{foo: "bar"}` is expected instead of `{bar: "foo"}`? It must be nigh impossible to determine what they are without relying on a dig into the source to see for your self. At least with the native way of doing it, IDEs can at least (rudimentarily) show us the method signatures of functions. 
`tage`? Haha
I'm not getting that at all, it starts scrolling instantly. If anything there's just a slight delay while it decelerates into the final position, but I'm having a hard time even noticing it. 
typehinting as it used in php f.ex. is actually a thing in js as well. Jetbrains Webstorm IDE for example supports it really well and makes coding mlre pleasent
Kind of infinite decay when comes to giving up on legacy. 
And it's back because it's under control of the Node Foundation.
my personal favorite feature that we're stuck with is &lt;div id="foo"&gt;&lt;/div&gt; foo.innerHTML = "YARRRR"; 
because life isn't a javascript program, real software engineering has to happen :)
That answer is different and harder for me to comment on in any detail. However I'd chalk the difference up to differing priorities, schedules, release mechanics, and that kind of thing.
How is jquery 'plain' and not 3rd party sauce ifself??? 
I meant jquery plugins by that.
Cool, thanks for the link! 
I see many benefits of strong types..in Java or c#..but in javascript, it is not as evident. Writing doc block is a standard, using an IDE is a standard as well, type error in JS are really occasional, the code required by using typescript is 3 times more than without it, 2 times more using flow, time required to write a JS application with typescript is 2 times more than without it..so the outcome is that for those few errors it will prevent it is not worth it..and benefits as autocompletion and type hinting are of the table because we have them anyway. Than again getting juniors on the track is a real issue..for a junior to read typescript or flow all over the place is a real headache..and we still run our code trough webpack, so it is compiled, linters are applied, tests are applied and static code analysis is applied..so I tried it on one module to see pros and cons..and yeah for us there were no pros
TypeScript is pretty great, but it's not the only required solution for scalable projects. As long as the code base is **modular** with descent **organization** and **documentation** than its maintainability will be fine. **[EDIT]** Oh, and linters and intelligent code completion are also essential. Optionally, a spellchecker for strings and documentation is also a huge benefit, especially if your spelling is atrocious like mine.
this and javascript became *fast* as a result JITs and the great browser wars
I've worked in a monorepo, single project, pure javascript (ES3 because it had to support old browsers, not ES6, either!) with about 5 million lines of code, and it was doing fine. I've dealt with small 50-100k line projects, including some with Flow or TypeScript that were absolutely unreadable. Linting is critical, types can help move the needle a little bit on top of that (they can also hurt if used wrong, like any other tool), but nothing will make up for lack of proper design and architecture. In a lot of cases pure ES6 codebases are easier to manage because less people go full blown class hierarchy garbage that's impossible to follow (nothing to do with the language, it's just the demographics).
CSS -&gt; is &lt;- presentation logic. It's the tools and management of that logic that are antiquated. JS is being utilized to augment the feature set of CSS since its inherently a static standard with no programmatic capabilities. You also get the benefit that the presentation layer for the component you're building is housed right alongside the other parts of the component. The best way to build an application is to divide it up into pieces. The problem with CSS currently is that the presentation layer for your pieces is all housed in this giant glob of global definitions that can easily overlap each other and wreak havoc. How many times have you had to fix a bug that was caused by someone else changing a bit of CSS that wrecked something you wrote. That's a problem inherent to the nature of CSS that these isolated scopes solve.
&gt; and it had none..if we have proper jsdocs JSDoc comments are super bloaty and annoying to write. Also, non-nullable types are super awesome.
&gt; Writing doc block is a standard That's true in many languages, but JS isn't one of them. JS doesn't have an official doc generator. &gt; the code required by using typescript is 3 times more than without it Type inference handles most of it. Have you actually tried it?
Sounds interesting, can you link to a react like UI components layer that's driven by Haskell?
Interestingly, the codebase on which I work at my new job uses Aphrodite, and I think it's fucking shit, because: * I've encountered various bugs with [pseudo elements](https://github.com/Khan/aphrodite/issues/231) and [media queries](https://github.com/Khan/aphrodite/issues/226). It's not as if these use cases are esoteric; they're pretty fundamental to CSS * the CSS it generates as a result of creating new classes for each computed combination of styles results in a larger stylesheet than if one were to use plain CSS or some preprocessor; while this might be defensive, it is possible to namespace and be defensive without JS-based styling tools * Including the bundle adds more weight to the page; while this is small when gzipped, the browser supports CSS natively, so surely invoking a preprocessor during a build step renders this pointless * Performance overhead of computing these styles at runtime vs using a preprocessor at build time This poorly thought-out nonsense. Stay well away. EDIT: The README brags "No external CSS file generated for inclusion" - how the fuck is this a good thing?! EDIT #2: Looks like my client wants to drop Aphrodite due to these limitations. Ha!
React will not be based on custom elements, ever. Other projects have voiced similar concerns, like the Ember team. Nothing that sits on functional components will use custom directives, that includes most modern frameworks. And it doesn't make the slightest sense for them either because that would be a serious regression, while stopping all progress that supercedes the browser. You can use them, sure, but that's on you personally.
With JSS half of them base on actual CSS, which as you said gets scoped, for the others the dom is an implementation detail. Newer renderers like rn-web/reactxp are cross platform, they run on the web, mobile and on the desktop. You style them using rn's CSS abstraction, which is also based on JS. Nothing that plays outside of the browser will touch or know a shadow dom, the concept is also useless for web-based functional frameworks because they are all declarative, not imperative. 
It lacks *scope*, if you wanted to compute you have to set css variables. There are many encapsulation libs, we use CSJS for instance, never seen it leak. Proposals with even harder to polyfill CSS specs will mean years and years of waiting time. JSS already starts to re-use and memoize styles piece by piece (styletron). There are optimization possibilities here that can't be matched. Hardly any performance gains to be had in shadow dom either. I don't think there's anything wrong with web technologies. But there's a point to be made about a certain threshold that JS is now clearly crossing. It's no longer a browser language that merely drives web pages. Can specs just ignore that? This was the exact concern several influential developers have already voiced.
https://productivity.netlify.com/ https://productivity.netlify.com/public/boards/58d383b20f4a2800178ef63e 
Thank you.
&gt; React will not be based on custom elements, ever. That's not what I said. I said that Custom Elements work fine in React, which is true. There were some issues with that early on, but this has been addressed many many moons ago.
&gt; I am a bit confused as to how a large code base of javascript can be maintable without strict typings? I guess it can, if you follow strict coding guidelines. &gt; Is using Typescript for nodejs a popular approach? For bigger projects, indeed. 
What is the whole discussion about? You can do that, yes, you always could. But custom elements will play no part in any forward oriented component based view-layer. And i highly doubt that shadow dom will play a role in style encapsulation, because it's tied to an imperative components model that conflicts with the newer, much more powerful declarative model.
Nice troll ;-)
I only point them out because I know you'll fix 'em!
I'm a little confused by the range of technologies you just mentioned, but it sounds like you can just use TypeScript directly: npm i -g typescript tsc index.ts There are a bunch of helpful options in the [docs](https://www.typescriptlang.org/docs/handbook/compiler-options.html).
They published this *a while ago now* but I'm sure some are still relevant: [Projects that power GitHub](https://github.com/showcases/projects-that-power-github) Here are a few of the front-end packages listed within: * d3 * moment * Leaflet * ace edit: formatting 
The first example is very contrived.
O_o
I can understand that some people love JS and want to put some everywhere. But that's one stupid trend. Why would you rely on JS execution for something that works wonders with CSS ? CSS may not be perfect, especially for components. But using JS to handle styles instead of one of the well-thought and dedicated tools that are around (Sass being the de facto standard IMO) is...well a stupid trend.
That is impressive!
Thanks, I had no idea there was a library like this - I thought I was gonna have to build a whole survey system myself, and now probably not :-) For comparison are there any others?
What do you mean? I don't get it
Wow, It could be awesome if you use my little project.
Thanks, your comments means a lot to me, never published before. Was expecting 0 points. lol
Thanks, I'm going to create a CSS serie, under the CSS-ART tag. You may follow me in twitter or github if you interested. I'm also going to blog in medium, but not sure if I should do it in spanish or english, so maybe spanish posts are not interesting for you. 
actually turning display: none to display: block has a really choppy animation, its more laborious to try and do all the fancy css to make it appear smooth. slideToggle() is much simpler and has a smooth effect. I figured it out and put a solution in the description. Thanks for your input!
Why have &lt;input class="btn-on" type="button" value="Encender"&gt; &lt;input class="btn-off btn-hide" type="button" value="Apagar"&gt; when you already have &lt;div class="on-off"&gt;&amp;lt; off-on &amp;gt;&lt;/div&gt; ?
This is an incredibly naive point of view to have. It's not nearly this black and white. Have you ever worked with a UI that has dynamically updating colors that the user can pick? You can't do that in CSS. There are a lot of use-cases for javascript managed styles beyond namespacing. Custom spring animations, especially staggered between elements is another. Every time this topic comes up someone has a crotchety comment like yours. I use a mix of both in my projects, and it's very nice. It's not a "trend", it's programming.
I tried mammoth as well but couldnt figure that out either :x. I tried using the browser-demo/index.html but came into some issues
I'm not sure what you mean by you converted a game into json. Do you mean you converted some of the data to json? Json just stores data, it itself does not execute any code
Not sure I would say it's the future of enterprise but you seem to miss his points in the article. He has a point that being able to reuse code in more places is powerful and that tooling is strong in the js camp. Cpp, while being super efficient, has poor tooling, and a scatter brained approach to open source code reuse. Also to get that efficiency requires you to leverage CPU specific instructions that can make your binaries less portable. Java tooling is much better and they have code sharing down. But again you still have to write your client side in js and the JVM can be challenging to deploy in cloud and container environments due to how it deals with memory. Python is slow unless you go to something like pypy and then you need to start worrying about module compatibility etc. And I personally find the syntax abhorrent. I'm not agreeing with this guy but he's not crazy. 
I played around with it over the summer, so I might be a bit out of date. It definitely felt like a better method to request data, but mutations seemed to be less well-defined than with REST. If I were defining a new, read-only API, I would probably go with GraphQL.
[removed]
&gt; Finally, why does github load html content by ajax, instead of loading the page just like any other multi page app? What's the benefit of this? Just like any other? This is extremely common for things developed with front end frameworks. It's what the whole 'single page application' term is referring to. Instead of reloading your entire application you replace the specific bit of content that needs replacing. 
it was kind of funny, there's a little value there
Tech industries have a higher incidence of "less aesthetic" people in general (for various reasons, not meaning to offend anyone), so there's a possibility it's just that. Either way it's irrelevant to the content, don't judge a book by its cover, etc.
I was kidding of course, sorry you guys are so serious. Wasn't meant to offend anyone. If you are out there, I'm sorry! You are beautiful! 
It's really a really fucking retarded one at that.
This is my favorite article on the topic: https://philsturgeon.uk/api/2017/01/24/graphql-vs-rest-overview/ Please disregard all the craps saying things such as "REST is dead, long live GraphQL";
what language is this?
"REST" is now a word that means approximately "doing shit in HTTP, with pretty URLs and methods or something dunno". In that context, GraphQL is just another implementation of REST. More strictly speaking GraphQL *is* an implementation of HTTP, because it is used over HTTP and it doesn't violate HTTP specs in any way, and HTTP *is* an implementation of REST. So yeah. If you're more confused than before you read that comment, you're welcome. 
&gt; But actually binding data to a view using javascript has not been done until just a couple of years back To be fair Backbone.js has existed since at least 2010 though
IMHO English is the only language that worth it. @baumannq
I'm afraid i don't understand your problem? The floating point issues only really become an issue when doing mathematical operations, storing them should not be a problem? https://www.youtube.com/watch?v=MqHDDtVYJRI
Oh, I see. Thanks for explaining.
Ironically REST can also work over any protocol - not just HTTP.
I think it will be the most common way to communicate with the backend for large single page apps. Will it replace REST for all usecases? Probably not. The overhead of running graphQL is quite big if you just need to get a small API up and running.
Case in point, [docker commands can be issued to its REST-ish unix sockets endpoint](https://docs.docker.com/engine/api/)
Eemmmm‚Ä¶ Not sure what do you mean‚Ä¶ `new` creates a new object instead of just calling a constructor function (in JS there is no difference between constructor function and simple function).
Yes I am using websocket, and I am using typed array. But I still want to compress the floating point number to use lesser bandwidth. Is that doable or a waste of time in javascript?
If you're using typed arrays, you can create a Float32Array to use reduced-precision floats. You'd have to do some profiling to see if actually gives any benefit.
 function MyClass(opt) { console.log(opt, this instanceof MyClass ? "I'm the constructor!" : "I'm just a function!"); } var test1 = MyClass('first'); // test1 === undefined // console output: first I'm just a function! var test2 = new MyClass('second'); // test2 is an object, instance of MyClass // console output: second I'm the constructor!
&gt; How am I supposed to know what data is stored in the array? That's up to you. You'll have to come up with a protocol for your server and clients. &gt; A 53 bits data becomes 32 bits. There must be some digits loss. Try it in the console: new Float32Array([1232.234523452345, 1232.23]) &gt; Float32Array(2) [1232.2344970703125, 1232.22998046875]
Yes, my apologies. Human languages. 
http://stackoverflow.com/questions/11141136/default-javascript-character-encoding
I'm not a massive fan of the idea of inline styles, I prefer CSS Modules, but we use Radium in work. Has anyone found a VSCode plugin that is like emmet for CSS in JS? 
I'm brand new to JS. Can you help me understand this post a bit further?
Sure! When you declare a string, it has to be represented somehow in memory. In the end, it's all ones and zeros, but there are different ways to interpret them. For example, we have ASCII, where 8 bits of binary encoding the value 65 corresponds to the letter A, 66 -&gt; B, 67 -&gt; C, and so on. That was a pretty America-centric encoding, however, so now we have ones that are better suited for languages around the world, such as utf-16. Take a look at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String and http://www.fileformat.info/info/charset/UTF-16/list.htm to see some different ways you can declare strings and the range of possible characters in utf-16.
&gt; The point is that loading CSS from the HTML document directly with a style tag (as described by a previous commenter) makes it difficult for individuals with special needs ... Do you have a link to that description? I'm a bit confused as to why it would make a difference compared to a linked stylesheet. 
I'm a bit surprised no one in this thread has mentioned ITCSS yet. It takes a component-first approach that seems to be looking at things from the same angle as "component-based styling", but looks at the bigger picture as well. If you're not familiar, it's not a library or anything, just a set of well-thought-out conventions that try to wrangle in the shotgun that is CSS as a tool. Anyway, you end up with files for each component, just like `my-component.scss`, so the result is similar. Of course convention is to put all styles in a `styles` directory, but there's no reason that has to be the case... they can all live alongside their component. Sometimes it feels like that's what "inline styles" is mainly trying to be about anyway...
Yes I get this result too. I guess it will cut the third digits after the radix point. Just hope this is a general rule.
hehe, that's not true :P I'm trying to contribute the spanish community too. So let me think about it.
There were no major differences between the older and newer version, few extra functions and logic options. You going to hard pressed to find courses based on specific minor versions. Better look through blog posts and change logs. 
I totally forgot about Proxies! This would definitely clean up my implementation
Total crap "How can you explain Frames in JavaScript?" what??
Sorry, I don't really understand... Do you mean I need to write console output instead of comments about return values? The return values are also important ‚Äì simple function will return something only in case when it has `return something;` statement, while a constructor with `new` keyword will return the new object even if the constructor function does not have any `return` statement. UPD: updated
What's the point of it? It just uses an array underneath without adding anything new
The main thing to know is you can make Angular 2 style components in AngularJS 1.5+. It helps a lot to have a more sane component life cycle. 
1. there has always been that split, but JS has always been more of a FP language than an OOP one (although you could bend it to look like OOP). Now that FP is becoming more popular (even Java has lambdas!) the FP proponents are getting louder 2. Typescript is about strong typing rather than OOP 3. What frameworks? What is "the old way"? A lot of people want to stay close to the metal and not have the extra complication / inefficiences of a framework 4. JQuery is slowly losing ground, but veeeerrrrrryyyy slowly, but it is still by far the most used library out there. And it has nothing to do with those things. It's because modern frameworks don't use it (as opposed to, say, backbone who did) and also because the main problem it solved, the difference between browsers, is becoming less of an issues as all browsers manufacturers are becoming "good guys" and following standards, plus they autoupdate
I found this course quite helpful. https://www.udemy.com/ultimate-angularjs-course/
https://www.ng-book.com/ - very good.
Streams would be better for this. This might work ok for events that are only going to occur once, but most events can occur multiple times.
could you please explain what you mean by the `overhead` ? do you mean performance-wise ?
Console.log (this is hard af) ;
Fuck Java
There's probably more elements with that class name. 
There are indeed. There are 5. But doesn't the [2] in document.getElementsByClassName('widget-title')[2].innerHTML = "&lt;span&gt;Blog Posts&lt;/span&gt;" ensure that I edit the element in-question? Or do I have to be mindful of other things if there is more than one element with that class name? I'm new to JS, so this may be the case.
By the overhead I meant the need to parse the graphql query, run respective resolvers-with REST you are much more low level working with http directly.
Nice that you've wasted your time on this
&gt; This is not ideal though. My IDE (phpStorm) won't help me importing the modules only the names from it. The function name is too generic, other modules might have the same name which is not really optimal. I think renaming them to be more unique is not an ideal solution. Isn't that phpStorms problem? Create an issue, if they're too slow to resolve it, dump it. Depending on how you use it, JS sometimes doesn't lend too well to traditional IDE's because it's moving fast and is more flexible than other languages. Have you tried lighter, but hackable/pluggable editors like VSC or Atom? Other than that, names are up to the importer, i think a module should absolutely not worry about it and keep it semantically simple and descriptive: sound.js export function play() { ... } radio.js export function play() { ... } index.js import { play as playSound } from 'sound.js' import { play as playRadio } from 'radio.js' playSound() playRadio() or import * as sound from 'sound.js' import * as radio from 'radio.js' sound.play() radio.play()
 document.getElementsByClassName Grabs all the elements with that class name and returns an array of them. So in your code you're changing only the contents of one of them (which is probably not the one you're looking at on the page). Try ;[].forEach.call(document.getElementsByClassName('widget-title'), function (el) { el.innerHTML = 'Giraffe' })
Consider using momentjs for date management. Its very powerful. Otherwise, make an array of day names.
JavaScript numbers can store at most 53 bit integers (so-called [safe integers](http://exploringjs.com/es6/ch_numbers.html#sec_safe-integers)). Beyond that, you need libraries: do a web search for ‚Äúbigint‚Äù or ‚Äúbignum‚Äù.
&gt; in JS there is no difference between constructor function and simple function That's not always the case
Could you please explain more?
There are two aspects to this. First, as an industry we forget everything that happened more than a decade ago. There are a load of reasons for this. As an example MVC as a pattern came about in 1973 iirc, and has re-emerged in various guises every decade since (I only remember back to the 90's fyi). Anyway, this does mean that good and bad lessons learned historically are often relearned with the same "eureka!" hyperbole. Second, There are good and bad things in OO, functional and even good ol' imperative code. Certain paradigms from each fit together well and coexist happily, others don't. The best approach you can take is to understand the paradigms and their strengths, weaknesses and use which ever works for you. With JS, you won't be forced into adopting any of the above, you can use the bits you like and leave the bits you don't. 
Not necessarily; The other elements in the array may have the same content. console.log('found: ' + [].filter.call(document.getElementsByClassName('widget-title'), function (el) { return el.innerHTML === "&lt;span&gt;Recent Blog Posts&lt;/span&gt;" }).length + ' elements with that content.') If you open dev tools you can simply select the element you want and see what's up.
I think VueJS comes to happy medium where you author css/scss/stylus etc in the component, but it still feels like regular css. With good enough tooling I think CSS in JS has the potential to be a lot better dev experience than traditional CSS authoring. Scoping css to a module is fantastic though. Going to back to global from that is shite. 
&gt; Not necessarily; The other elements in the array may have the same content. I was about to shoot back that I checked all 5 array elements and #2 was the only one with "Recent Blog Posts" as the innerText. BUT, you were correct--there are two such occasions of "Recent Blog Posts" on this page: one in the sidebar, but also one in the footer. I was editing the one in the footer. I changed the index from 2 to 1 and I then began to edit my desired title. Thanks so much! I learned a lot in this exercise.
&gt; and it lets me cut everything related to css from my build step which is a huge plus. You are contradicting yourself. CSS tooling (preprocessors, linters, formatters) is a major part of CSS workflow. It can be used to highlight possible x-browser issues, provide strict types for your style names, warn about duplicate declarations, etc. Putting CSS into JS only limits your ability to use the existing tool ecosystem. &gt; The author assumes CSS as it is today is good enough and I have to disagree. It is... CSS is not a constant spec. It is constantly mutating to adapt to new requirements. I've listed some of the new developments that happened over the past 10 years in the article. A lot more exciting things are coming to the CSS such as element queries.
I've worked at several companies that do this, and even recruited for them. I'm really torn of the practice because I can see it from both sides, and while I have no data to indicate that it works, it does make sense in theory if you understand the reasoning behind it (and the job market in your area is large enough to validate its built-in assumptions). From the applicants' side of things it's inexplicable and frustrating, because unless you're going full-stack (and these days often not even then) you'll never have any reason to touch Java or C++. From the *employer's* perspective, however, it actually makes a bizarre kind of sense. Due to the fact it's a wildly successful and popular language (especially first language) it's easy to find JS developers, but there's a distinct democratic bulge in the community towards the "inexperienced/clueless" end of the spectrum, and that makes it expensive and costly to filter out the legions of clueless types who learned to slap together a few jQuery calls and think they're rockstar developers now. By analogy, if I'm looking for Haskell developers in going to have a hard time finding any because there are probably only about three guys in my city that know it, but they'll *all* be fucking geniuses because almost nobody learns Haskell who isn't a hardcore programming language geek. If I advertise for a C/C++ or Java developer then I'm going to get hundreds of applicants, but at least a moderate number of then will have a solid grounding in theory and software *engineering* (as opposed to just software *development*) knowledge - OOP concepts, time/space complexity, software architecture issues, etc. Conversely, if I advertise for a JavaScript developer I'll get *thousands* of applications, with a few hundred or so competent engineers lost in the thousands of overconfident newbies and clueless hacks who went straight from gluing jQuery calls together into cargo-culting Angular systems together without the first clue why a framework makes certain decisions for you, or how to tell if/when those decisions are right for any given project or situation. What some employers do, then, is try to cut out the dross by adding in additional requirements that aren't *directly* related to the job, but *are* somewhat correlated with "being proactively interested in your craft" or "generally being a good engineer". Some look for things like degrees or Open Source contributions, while others look for second languages (especially, like Java or C++, with strong type systems, a stronger culture of engineering correctness over hackery, or use in formal academic tuition) to try to weed out the huge bulge at the bottom end of the spectrum and concentrate their limited recruitment resources on the cream at the top. That's not to say you can't be a pretty good dev if you only know JS[1] or that knowing Java or C++ means you can't be a crappy one - these are *overall trends and heuristics* we're dealing with here, not 100% cast-iron guarantees of correctness in every individual case. It sucks if you're the guy who knows JS inside out who doesn't get a callback because he didn't have Java or C++ on his CV, but from the employer's perspective this isn't about you as an individual - it's about needing to find **a** good candidate from a stack of CVs as high as your desk, and it not mattering how many great guys you turn down as long as you find *one* who's good enough in the time you have available for interviewing/recruiting. As I said, I'm torn on the practice personally, but employers do do it for a reason. I'd love to see some hard data on three practice, however, to see whether or really does make a measurable difference. **Edit:** Also, don't be afraid to apply for jobs that list requirements like this as long as you have equivalent skills/knowledge. If the job says "Java" but you know Ruby inside and out and have good OOP theory *don't hesitate to apply* - the worst that can happen is some clueless string-matching recruiter filters out your CV and you don't get the job, but the best that can happen is it comes across my desk, I know that we only mention Java because we want good OOP theory and a second language, and you'll get the interview anyway... so as long as you aren't actively wasting everyone's time, feel free to apply as long as you can provide equivalent skills/experience. ---- [1] You will never, however, be a really great dev - or depending on your standards even a *good* one - until you know at least two or three languages to a decent degree of (idiomatic) proficiency.
Yeah I read it, and many others articles and comments it's basically reiterating. I'm just speaking in general, not commenting specifically about the content of your blog post. Usually I refrain from talking specifically about the article if I disagree with it, there's enough people around here to just bash shit already. But since you accused me of not reading here's what I think. Personally I think it reads like a low effort PR piece. The examples are weak, and I disagree with labeling something as a "myth" simply because you personally disagree with it. If you wanted this article to be taken seriously, and not as fud by an author of libs that follow a different methodology then you should have put a little more work into it. Better examples. Real world examples of when you have used the things you are talking about beyond looking at the snippet in the readme. What shortcomings you and your team felt with each of those solutions, and how your solution addresses those problems. What were the implications of using these different libs/methodologies, how did they impact velocity, did they create/reduce bugs, etc. Developers love to invent and try new things, the web dev landscape will always be like this. People/teams just have to find what works best for them. And let's face it, CSS is the worst part of front end development, which is why so many people are trying different approaches to this. 
Isn't like the first thing you learn in any computer science study to have a separation of concerns? I guess this article agrees with that.
And what specifically makes you think that? That you love css modules and Vue's scoped css that I am talking about is essentially the same thing, but you think I disagree with your overall point (which I have not said)?
Put an id on the element you want to toggle, then use that to target it. &lt;p id='info'&gt; ... &lt;/p&gt; $('h2').click(function() { $('#info').toggle(500); });
I think he means in the context of a single-file Vue component. Those components have the template, JS and css all one one file, but clearly separated with `&lt;template&gt;`, `&lt;script&gt;`, and `&lt;style&gt;` tags respectively. The most popular config (the Webpack build via vue-cli) uses the extract plugin to extract all component styles into a single file at build time. The styles can also be configured to use a variety of well known processors like sass/scss, postcss, stylus etc. You get the advantage of complete familiarity coupled with keeping your styles scoped and organized to a given component. 
Scoping works without reinventing the wheel: &lt;superComponent className="superComp"&gt; you can write the following CSS: .superComp header { ... } .superComp main { ... } or in SCSS .superComp { header { ... } main { ... } } I find it super easy, elegant and achieves much of the pain of what "CSS in JS tries to solve"
I dont think GraphQL will completely replace REST. I think GraphQL will probably (emphasis on probably) replace a lot of data fetching from a client to server implementation, but for a lot of inter-service communications in an enterprise DMZ I think REST will remain to the top choice. For things like sending messages from a server to another service, such as cloudfoundry, Jira, gitlab, bitbucket, teamcity, jenkins, "serverless" (such as AWS lambda) (on and on), IoT, authentication, etc, I think REST makes more sense. We also have Elastic Search, Falcor, etc, which have their own APIs
There's a difference between separation of concerns and separation of technologies. "Separation of concerns" was the initial widespread argument against React. At the time the most popular thing to do was HTML templates tightly bound to JavaScript logic. Just like it's possible to define a component's DOM structure in JavaScript and still have separation of concerns, it's possible to have CSS in JavaScript (i.e., define a component's styles in JavaScript) and still have separation of concerns.
HTML on the page: &lt;script src="/dev/script.js"&gt;&lt;/script&gt; I've confirmed that the JS file is included properly, as I can use it to make modify other elements on the page.
This can break... for example: h('.outer', h('.left', h('.inner', h('.left') ) ) ) I still use scoping but there are things to watch out for.
&gt; Is that line at the very end of the body, This is a WordPress site. So I have added the HTML as the last line of the body in the WordPress editor. But that doesn't mean it is the last line before &lt;/body&gt;. &gt; and do you have two .widget-title nodes in the HTML? Good question. There are five such elements on the page. When I run document.getElementsByClassName('widget-title') in the console, it returns five elements. The element I want to modify has an index of 1. So I have tried to isolate that element by appending a *[1]*. This could very well be my issue.
Some plugin might be creating those .widget-title nodes. Try wrapping all your code in a setTimeout(function() { your code}, 5000). If that works, dynamic mode creation is most likely the culprit. 
I'm also using that techniques sometimes. But using this JSS bulshit as foundation of component-based app is just stupid. You can't make CSS from JavaScript. 
Haters gonna hate. 
Separation of concerns is *exactly* what styled-components provides. It creates components without any state or behavior who's sole purpose is to define the visual representation. It gives you a very clear and explicit seam between view and behavior.
If feel like you've argued against the weakest case for 'inline styles'. Some of this probably terminology. To my mind, the pros for inline are generally: 1. **Avoiding the deep hierarchies inherent in CSS:** CSS becomes unwieldy because deep hierarchies, an anti-pattern in other languages. There are workaround like naming conventions, but it is pattern that is encouraged by the design of css. It's right in the name, CASCADING style sheets. 2. **Better separation of concerns / DX:** Placing the styles themselves inline reframes the concern as the component instead of the technology. The concern is the login form, not the html, js, and css. css modules can indeed address both of these. But it still means touching another file, adding another dependency to maintain, and another build step, and I'm not sure that added complexity is always warranted. If you are using css, I think that making the dependency explicit with an import is a good thing. The main pain points that I see against inline styles are: 1. **Media queries, psuedo classes and vendor prefixing:** This is the main reason why you'd want to use something like Radium. Otherwise, something like :hover becomes an event you need to handle yourself in the component explicitly. 2. **Themeing:** Inline style is going to make your dependency on a particular implementation of css very explicit. css modules can help with this along with the right tooling to hook it up to your components. This is not a general use case however. Not everyone needs to be able to swap out styling willy nilly. 3. **Performance:** ...can be a concern. I'll admit that I've never noticed an issue, but supposedly this is one. The author of Radium goes into much more detail: https://www.youtube.com/watch?v=k3OF4A30jSQ
&gt; when I create an array, for example, do I need to use new No. In the case of Array, and most of the native EcmaScript types, you don't need to use `new`. Even for objects that don't have literal syntaxes (Object, Array, RegEx, etc.), calling the constructor function without `new` will still produce a new instance. // creating new arrays var a1 = new Array(); // using new var a2 = []; // using literal var a3 = Array(); // using function Generally, if there is a literal syntax, you should use that. This especially for primitives because creating new primitives using `new` and a constructor function creates an object version of that primitive which has different behavior than the actual primitive. // creating new numbers var n1 = 7; // number primitive var n2 = new Number(7); // number object n1 === 7; //-&gt; true - primitive comparison n2 === 7; //-&gt; false - object vs primitive comparison n2.valueOf() === 7; //-&gt; true - object's primitive value vs primitive comparison For non primitive, non-literal having types, you'll generally want to stick to using `new` for object creation as it ensures that the instance is getting created correctly. Constructor functions, unless defined in the ES6 `class` syntax (which prevents calling without `new`), would need to be specially crafted to be able to create instances without `new` when called regularly. Otherwise they may have unforeseen consequences. `new` itself does a couple of things. In combination with a suitable function, it: * creates a new Object instance * associates the prototype of the new instance with the `prototype` property of the function * calls the function in the context of the new instance (`this` is equal to the new instance in the function call) * and unless some other non-primitive object is explicitly returned from the function, returns the new instance created Basically it takes a function and uses it to initialize a new object with that function body, and has that new object inherit from the object defined in that function's `prototype` property. There's nothing requiring to use `new`, and some people prefer not to. You could create all of you objects with literal syntax, or using methods like `Object.create()` which allows you to specify inheritance without going through `new` and a constructor function instead. But more likely than not, you'll be working with code that depends on it, especially if using ES6 classes.
Can blogs please stop telling me to stop doing things? 
Which is unfortunate, because JavaScript's ecosystem sort of necessitates specialization in JavaScript. Even *within* JS, it's become difficult to be a generalist, with all the different front- and back-end stacks and the constant barrage of new frameworks and build tools. I get it though, because of what Shaper_pmp mentioned. I used to work at a PHP shop, and we strongly preferred candidates who also had some Java or .NET experience for the same reason.
I think the JS is getting executed well before the document is loaded fully. Can you try wrapping your code inside the "load" event so that the JS will run after the page is loaded. For easy reference, https://developer.mozilla.org/en-US/docs/Web/Events/load Let me know if it worked.
This doesn't make sense to me. Putting your script at the bottom of the body should work. Can you view source of the page and see if the .widget-title nodes are present? The only thing that makes sense to me is if maybe there's JS included after your script that's adding this content. But then again, the timeout should have fixed that. 
This seems like an argument against styled components rather then css-in-js in general. I'd give glamor a try. You just pass css objects in the class name. And it loads the css as a single css file. https://www.npmjs.com/package/glamor
Thanks, I'm not crazy, just a little bit mad üòÇ , interesting reading your thoughts....
We are all here to learn. :-)
I've use both approaches pretty extensively and they both have their merits as you've pointed out. I think a common misconception is that css-in-js == inline styles whereas libraries like Radium provide a "best of both worlds" solution. Lately my css-in-js lib of choice has been [glamor](https://github.com/threepointone/glamor). Glamor has full support for media queries, pseudo classes and vendor prefixing. Glamor also [supports server-side rendering](https://github.com/threepointone/glamor/blob/master/docs/server.md) which I believe would address some of the perf issues (specifically with regards to startup time). SSR for Glamor also provides methods for extracting only the used css by analyzing the output of the React.renderToString. I'd also recommend checking out [glamorous](https://github.com/paypal/glamorous) for a nice theming API on top of glamor. I've been using css-in-js in all my projects (web and mobile) for the last year haven't noticed any perf problems and flexibility of using the full power Javascript to define styles alongside my components has been a great DX. Lots of [interesting things happening](https://github.com/threepointone/glam) with css-in-js, looking forward to the future improvements. 
That's actually a pretty interesting concept.
&gt; Try wp_enqueue_script() as seen here https://developer.wordpress.org/themes/basics/including-css-javascript/ Will do. &gt; As for only including it when that particular widget is on the page, I'm not entirely sure how to do that unless you have access to the widget code. Actually, I forgot that the widget is a built-in WordPress widget. So there may be built-in functions to easily modify this title via functions.php.
I dunno, I quite like CSS in JS having used less, sass, postcss and you name it. I don't have to jump around files and can use the same syntax. And if you use something like fela (highly recommend) https://github.com/rofrischmann/fela it will generate a really small css file with atomic classes. Instead of having some frankenstein language like SASS you can use the full power of javascript (yes I know, it's a frankenstein language too).
I've followed this debacle for quite some time and I've come to the conclusion that we probably need both ways. People come from different backgrounds and problem domains, creating vastly different applications. The big problem is always the question "what is complex, dynamic interaction?" What is the difference between "dynamic" and "complex"? [Complex](https://www.merriam-webster.com/dictionary/complex): &gt;a whole made up of complicated or interrelated parts [Dynamic\(s\)](https://www.merriam-webster.com/dictionary/dynamics) &gt;a pattern or process of change, growth, or activity For instance, adding animations to a static page makes it dynamic but not necessarily complex. I think a great example of this is [Googles Material Design Guide](https://material.io/guidelines/material-design/introduction.html). While all their components look great and have pleasant animations, they aren't exactly hard to understand. Which makes a lot of sense, since the project is highly geared towards mobile applications where the interaction devices consist of big fingers on tiny screens. To quote: &gt; Mobile precepts are fundamental, but touch, voice, mouse, and keyboard are all Ô¨Årst-class input methods. It has to be simple. Decoupled CSS is great for this. It's easy to learn and you can get a lot of things done fast. People don't have to spend a week creating a JS module to have a menu slide in from the side. It can be done in a few lines of CSS. This is great! In the other end of the spectrum we have something like [D3.js](https://d3js.org). While some of the [examples](https://bl.ocks.org/mbostock) are simple enough, a lot of them contain [quite complex levels of dynamic interaction](https://bl.ocks.org/mbostock/4063663). And not only between the user and the interface but also [between objects themselves within the interface](https://bl.ocks.org/mbostock/4062045). It can be quite daunting to interact with, compared to the usual menus and buttons. Some of the examples have a huge amount of objects that all have a ton of individual CSS that needs to change dynamically as part of the interactions. It has to be done programatically and CSS in itself isn't currently even near a solution for this. Nor do I think it should be. If you look at the source code, many of them have a ton of CSS in the JS code and a basic list of colors in a &lt;style&gt; tag near the top. Should people who program in this way set up an entire CSS toolchain for an external CSS file with a list of colors? Of course not. It's also not a surprise that a lot of CSS-in-JS libraries are popping up, since React basically uses the same pattern as D3. And it's probably here to stay. In the end, it very much depends on what you want to do and what level of complexity you require. CSS does not currently support enough complexity for some applications and most likely never will.
Great explanation! Thanks. So if I don't know Java or C++ but know a lot of Python and Haskell. I'm assuming that, that is even better.
React is for defining stateful views. Styles are view layer - so I don't think they're actually separate concerns a lot of the time, especially since modern UIs convey semantic information through design. That is, presentation and content are not separate concerns, as they were in traditional, statically [styled documents](https://en.wikipedia.org/wiki/Style_sheet_(desktop_publishing\)). The author says CSS has evolved to capture these requirements, but why did we need to develop a new language for this via one-off, first-order hacks - when JS already offers a formal means of logical abstraction and combination. As to which file you put what in is missing the point. If you want to put JS defined styles in their own file, go for it. We're after a separation of concerns, not a separation of file extensions. 
Stop telling me who I should or should not be telling to do things!
So can I just avoid using new? It makes more sense to me using the literal way.
Pretty much - when you're doing a first pass over too many CVs, anything that immediately makes a candidate stand out in a good or bad way is often enough to immediately get them through/rule them out. It's not quite the old joke about dividing all the CVs randomly into two piles and throwing away one of them "because we don't want to hire anyone unlucky", but it can get close if you get too many applications. So yeah - experience in multiple languages (the more the better), academic/hardcore languages, big-name companies, respectable advanced qualifications/degrees and the like are all great things to front-load on your CV. Conversely a couple of spelling mistakes[1], conspicuously poor grammar or writing skills, citing shitty "qualifications" (like W3Schools certifications) or other credibility-harming mistakes can be enough to get you tossed immediately. Everyone would like every candidate's CV to be read thoroughly and given serious and careful consideration just like every employer would like a CV/cover letter tailored to the specific company/role being applied for. Realistically, though, for popular positions in crowded fields it's a numbers game, at least for the first round or two. There just isn't enough time in the day to spend hours going in-depth on every applicant (or application) right at the beginning. ---- [1] Particularly if - in my favourite ever example from a real CV I've seen - it's in the phrase "Excellent attnetion to detail".
See the link for screenshots and a GIF screencast, so you'll get what this does. Feedback, issues, problems, suggestions are welcome, either here or at https://github.com/fiatjaf/module-linker/issues, whatever fits better.
&gt;CSS Modules, Shadow DOM and a countless number of naming conventions (such as BEM) have solved this problem long time ago in the community. I feel like the only people who still want to go to bat for stuff like BEM are CSS-wonks upset that some of their specialized skillset has become obsolete. It was a cumbersome stopgap measure. I too learned it and used it for a long time and was proud of my extensive knowledge of CORRECT CSS NAMING CONVENTIONS, but I'm glad to not waste time thinking and arguing about that stuff anymore. 
JQuery's next() targets the next sibling DOM element. In this case that would be the &lt;hr&gt; tag not the &lt;p&gt; tag. You can do as /u/Anitox suggested or you can fix it by moving two sibling elements over: $("h2").click(function() { $(this).next().next().toggle(500); }); In my opinion assigning an id is the better option because it's more flexible. If you use the two sibling elements over code and then decide to add more content on your page between the h2 and the p you'll have to update your code to target the new p position. If you use the id it doesn't matter where on your page that p tag is moved it will always be targeted by the code.
Hmm okay. Thanks.
I'll be honest, I had a lot of fun with the little bit of Typescript I've used. However, the _instant_ I can't find a type file I bail on the project and fork one of my many _working_ ES/Babel projects and I'm back on firmer ground.
You mentioned 9 reasons, none of which are the primary one. Dynamic styles based on props. Sure there are css variables but they're very recent. also.. what a clickbaity title. Who are we hurting with these innovations?
In Javascript, there is no actual difference. The only difference is exactly in this behaviour ‚Äì that's why I've wrote the example.
Great update from the TS team as usual. We've fully embraced TypeScript, so the @ts-check stuff is not super relevant to us, but I think it will do wonders for adoption on the whole. Flow comment opt-in was a very commonly stated advantage over TypeScript, so it's nice to have that parity. Default type arguments is greatly appreciated. This will cleanup library typing definitions significantly, as well as making consumption of those libraries far more pleasurable. It's hard selling TS to non-believers that "it's just JavaScript" when they see Type&lt;number, void, void, number&gt;. Hopefully lowers the redundant visual clutter. _edit:_ I also don't want to downplay how amazing downlevel iteration support is from a technical perspective. Async iterators in ES3?!? Crazy. I haven't personally used the constructs, but you can do some [really cool stuff with streams](https://jakearchibald.com/2017/async-iterators-and-generators/). Impressive level of commitment from the contributors all around.
It is very hard to strike a balance between objective criticism, an article that no one is going to read and using a provocative title. Of the three, the first two are the most important for me: to provide accurate criticism and reaching the target audience. Prior to publishing the article I've reached out to Max (the author of styled-components), gave him access to the draft and we collaborated on removing technically inaccurate content. I've done far and above the average to minimise the damage and to ensure that the content is accurate. With this article my intention is to reach people who are just starting to use React. styled-components is a trending technology now. It is important that there is material that a new user can use to research the pros and cons and decide on what technology to use. styled-components has a large presence in the community (a lot of tutorials, articles, tweets, Reddit posts, etc), which makes it look like a one-size-fits-all solution. Their own documentation makes it sound this way. It is not. It is a technology for a limited use case (cross platform application development). As for the "clickbaity" title, the only thing that is hurt is my personal pride here.
Hi /u/RexarusV, if you have a specific question and have already attempted to answer it, then we're more than glad to help, but we're not going to do your work/homework for you.
I'm pretty biased in favor of React, so let me go ahead and give you my standard advice for learning React. The article "A Study Plan to Cure Javascript Fatigue" ( https://medium.freecodecamp.com/a-study-plan-to-cure-javascript-fatigue-8ad3a54f2eb1 ) is a great place to start. It gives an excellent series of steps for tackling modern Javascript concepts one piece at a time: Javascript, React, ES6, and state management. On that note, definitely don't over-complicate the learning process by trying to learn many different things at once. Some people will say you should use a "boilerplate" to learn React, and they're wrong - boilerplate projects almost always come with too many pieces configured, and are confusing for beginners. Instead, the best advice is to focus on learning React itself first. Once you have a good understanding of how React works, you will better appreciate why a state management library like Redux can be useful, and you can learn about other tools later. You should start out by reading through the official React docs and tutorial at https://facebook.github.io/react/, and I'd encourage you to use the official Create-React-App tool ( https://github.com/facebookincubator/create-react-app ) for setting up projects. It creates a project with a solid build setup, with no configuration needed on your part. There's an excellent post called "Simple React Development in 2017" ( https://hackernoon.com/simple-react-development-in-2017-113bd563691f ) that gives some more specific instructions on the actual steps to follow. Past that, I keep a big list of links to high-quality tutorials and articles on React, Redux, and related topics, at https://github.com/markerikson/react-redux-links . Specifically intended to be a great starting point for anyone trying to learn the ecosystem, as well as a solid source of good info on more advanced topics. It includes links for learning core Javascript (ES5), modern Javascript (ES6+), React, and much more. I also published an "Intro to React (and Redux)" presentation at http://blog.isquaredsoftware.com/2017/02/presentation-react-redux-intro/ , which is a good overview of the basic concepts for both React and Redux. Finally, the Reactiflux chat channels on Discord are a great place to hang out, ask questions, and learn. The invite link is at https://www.reactiflux.com .
It's powered by rails.
I'm using PHPStorm. It's esentially the same as WebStorm with a few extras (like PHP support). I don't think there is a difference (I might be wrong though) I woulnd't dare to change how I build software just because my IDE lacks a few features, but the truth is that I don't really have any experience in writing ES6 modules so what I'm really looking for is the best way to do it regardless of my IDE. :) How does WebStorm offers you help with imports? You say that it "auto completes imports". What do you mean by that? What I meant by automatic imports is adding the complete import statement automatically, not helping me write it. And that only works if I export a named object.
Check out redux-bootstrap. It's a react/redux/react-router/immutable bootstrapping utility written in typescript.
That is a really fantastic addition! I hope this becomes an on-by-default feature in VS Code soon. When I code routes for my current Hapi project, I'm usually defining them in their own module (exporting an array of route config objects), so VS Code hasn't been able to infer those config objects automatically. This new checkJs feature with commented types should improve my experience quite a bit.
If I could please request coverage for those who have already used create-react-app on an existing project with the default react-scripts ... or for those who previously ejected. I assume the process will be adding a typescript loader to the webpack config, then possibly emitting ES6 so everything else will proceed as usual. I think many people will want it on existing projects.
Just use the child combinator and PascalCase for the component. .Foo &gt; .inner .Bar &gt; .inner .Baz &gt; .foo No collisions there.
Will do, thank ya! (also happy cake day)
Check the console (F12 -&gt; Console) for errors.
&gt; It's not realistic to use Shadow DOM Thats the conclusion in the article. &gt; the other solutions are prone to a lot of developer mistakes. Whats the possible issue with the CSS modules?
You should really look at both and go with whatever feels better for you, though you'll find more React jobs than Vue. For Vue I highly recommend [Vue JS 2 - The Complete Guide (incl. Vuex)](https://www.udemy.com/vuejs-2-the-complete-guide/). It's an awesome Udemy course which you should be able to pick up for $10-20 when it goes on sale (Udemy courses go on sale frequently, so just wait). Keep it open in a tab and check it every day, buy it when it goes on sale. It's a great course for a modern workflow in Vue 2, really worth buying, IMO.
Theres over 7k of us on slack, so more than just me have fun with it :) I have to work with react and they do have some good ideas, it's not black or white. For my projects I went with redux like arch because 2way bindings were ugly (went that route with angular 1 - didn't like the results). But no one is forcing you to adopt it I hope. Redux and uniflow (I assume that's the one you mentioned, i think its redux-like too) are ok. Depends on the type of application you build. BTW fo 2.0 you have hybrid mode. So far I was lucky with that. But yeah the new version problem in js world is funny. Imo we have to accept the flaws of whole js ecosystem, otherwise you will be always unhappy. I'm most happy when I can just do python but we have to live with js.
 And make sure your browser isn't caching old versions of your JS files. 
Pro-tip: There is a setting for disabling caching when the dev tools are open.
Question, as you seem quite knowledgeable on Animated, are additive animations akin to [this one](http://alexkuz.github.io/additive-animation/) possible? I'm not sure how I'd go about adding future animations to some sort of queue and which will influence animations in the past. I noticed that it is possible to animate multiple things at the same time, but I wonder how I would apply that concept to a single value ‚Äî rotation on the _y_ in my case. Thanks in advance!
&gt; It is always the dicussion glue architectue vs monoliths. Vue + vue-router + vuex is not monolith, it's modular. The difference is that the essential modules are officially provided, that was my point.
I was referring to the UI libraries, not the framework itself. There is no such thing called switching from one UI library to another, it requires a rewrite.
But the end outcome is the same in my opinion. I think you worry too much about it - diversity means flexibility in this case. Why not use angular then - you would get "everything" out of the box.
True, I would just stop worrying and go with what you like the best. Fun story - One project that was 10 year old was started with dojo, then migrated to jquery + backbone, now its react for few months and people already hate react :) There will never be a silver bullet. 
I know both of those technologies, and my advice - build something useful with one, than do that again with other. You'll learn the differences they both have.
Full disclosure - on the TS team. I think there are two important points to consider: 1.) Build friction is a huge issue for some people. With grunt, gulp, webpack, rollup, babel, and the new hot JavaScript build tool that will probably be unveiled next week, configuring TypeScript into your build can be hard. `--checkJs` gives you a chance to try TypeScript without committing to the configuration. Not to mention Node devs don't really need a compiler anymore, so adding one just for the sake of TypeScript can be a barrier to entry. 2.) Once you have types in some capacity (in comments or otherwise) we can help you refactor up to full TypeScript. So I don't believe `--checkJs` will hinder full adoption of TypeScript, and while I agree renaming `.js` to `.ts` is still pretty easy, I don't believe that it is _easy enough_ yet.
I've built some things but eventually in the building process I just hit a brick wall and don't know how to go any further. And the more I read about JS the more libraries and all that stuff I hear about and I feel swamped 
Can you go into more detail why you would want this? Perhaps there's a better construct for you to use.
&gt; you would get "everything" out of the box. and you will lose 2 things in return: 1. Support for multi page apps. 2. Your sanity. I really cannot put up with the Angular team culture, their history says enough about it. I really wished Google would have open sourced its Gmail javascript framework, instead of making so much hype about Angular. The only open source part of Gmail is the Closure Library, the rest has never been discussed.
Ya this just needs to stop. Don't fix something that's not broken. I honestly don't understand why you would put document styles inside a js file. Just makes no sense.
I haven't really been diving into libraries. I've just learned the basics of javascript html and css. But when I read code online there is so much I've never seen before and I can never understand it 
My guess is that its some kind of compiler bug. I ran it through babel and it seems to work as far as a basic async arrow function public field goes: class A { b = async () =&gt; this; } const a = new A() const b = a.b b().then(o =&gt; console.log('o=a', o === a)) //-&gt; true https://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Cstage-2&amp;targets=&amp;browsers=&amp;builtIns=false&amp;debug=false&amp;experimental=true&amp;loose=true&amp;spec=true&amp;playground=false&amp;code=%20%20%20%20class%20A%20%7B%0A%20%20%20%20%20%20b%20%3D%20async%20()%20%3D%3E%20this%3B%0A%20%20%20%20%7D%0A%20%20%20%20const%20a%20%3D%20new%20A()%0A%20%20%20%20const%20b%20%3D%20a.b%0A%20%20%20%20b().then(o%20%3D%3E%20console.log('o%3Da'%2C%20o%20%3D%3D%3D%20a)) Not sure where your failure point is. Does the above work in your environment?
I've done really simple things like FizzBuzz and I just made a to do list app there admittedly using jquery 
That sounds reasonable for a start, yes. jQuery is not _that_ bad for beginners. I have used Prototype and then jQuery too when getting "really" into JavaScript. Do you have ideas for a personal project? For me, doing something _I want_ helped extremely. I never was interested in "building along" some tutorials.
- relentlessly reading things that i have no chance of understanding - building a tiny project, exploding the scope as i went until it became a monster, then working backward until i could build tiny projects again basically, i failed over and over and then gradually i stopped failing quite so much.
Make something in React!
Jojos bizarre adventure? Has vue.js adopted the ubuntu model of naming releases?
[Get it from GitHub](https://github.com/facebook/react) React is an incredible library for creating web components and can be used to develop for web, iOS, Android, VR and more. Along with Angular, it's a front runner for handling the front end of single-page applications.
Hey sorry I don't see any animation in this example. I'd like it to hide the text, then display when you hover the image. I use a lot of jQuery animations I didn't know it was old school. Really want to learn a better css way if there is one. Thanks for the help!
Yep, that code on its own does seem to give the expected result... I'm pretty confused at this point haha. Would it be possible for the `handleSubmit` function that I'm getting from a library to change the `this` binding of the `onSubmit` function that I'm passing to it?
These exact examples make literally no sense, destructuring or not. `attribute` is passed as an argument, then overwritten locally in `then` and never used. `a` and `b` are never called, and `{results: response.body}` is not even legal JS used like that. Can you at least provide a sensible / actual example so we can judge properly?
This is very cool! I have attempted to use foreignObject before when making a site almost entirely out of SVG, but ran into various rendering bugs (all in chrome). I guess arcane APIs aren't as well battle tested as others.
I don't know if I agree with this. Working on a team with dozens of developers who usually don't communicate much, I've found that BEM tends to cause fewer maintenance headaches than arbitrary CSS classes or CSS-in-JS. The skill levels and backgrounds vary wildly on our team, so CSS-in-JS creates a big road block for less experienced teams. Block-based class names seem to click faster and with fewer onboarding issues. I'm sure it varies from team to team; this is what I've seen in practice in a large, geographically distributed team. 
Tabs are confusingly hidden away under menu, unless there's something missing in their implementation http://react.semantic-ui.com/collections/menu
THis seems really similar to [jss](https://github.com/cssinjs/jss) which I've personally loved in my projects. The only annoyance is having to put quotes around things.
You'll want to use [window.location](https://developer.mozilla.org/en-US/docs/Web/API/Window/location). You can get the current url, parse it, and then assign it to something else.
I guess whether or not tabs are a subcategory of menus is an is an issue of *semantic*s, though I imagine it would be easy enough to just create a convenience wrapper: `const Tab = props =&gt; &lt;Menu tabular {...props} /&gt;` or something like that
enough reading and practising 
I'll chime in with the others - building stuff! The best advice I can give anybody is never stop looking for a better way to do something. Spoiler: there is always a better way to do whatever it is that you're writing right now. 
I dont mind CSS in JS, but it makes my JS files so messy. Most of my components would easily have 50+ lines of CSS and putting all of that in JS files really triggers my OCD.
Are you talking about the informational homepage / collection of landing pages? Sure I'm that one very limited case it is still documents. But what about their logistics ordering systems, their pricing comparison calculators, performance graphs, customer feedback metrics systems, vendor alerting, etc? The UIs for these are hundreds of thousands of lines and often encompass entire business rules chains.
thanks, but I don't always have a handle to the returned promise so await is not an option 
IMO the problem isn't how you write CSS (in SASS, in JS, etc.), it's that the underlying rendering rules are esoteric and confusing. Why does setting the opacity make z-index work? Why is it so hard to vertically align elements? Why is setting height: 100% so difficult? The answers to these questions are... complicated. Hence the FUD.
Yare yare daze.
No and no. You really are better off learning to work within the system then trying to fight against it. If whatever you are waiting for (in your simple case) is not aync then there is no point in using promises. If you are waiting for something that really is async then ... no. There is no code you can write that *would* make it sync. 
Fair points. How do `--checkJs` and implicit any compare? Does the implicit any allow for easier adoption the same way `--checkJs` does? I know TypeScript will still infer types when it can. I feel like I'm missing something obvious.
Thanks :D
Yeah. Seems like countless people still think that css-in-js solutions lead to `style="..."`. They inject stylesheets and return automatic classes, allowing media queries / pseudo-classes / prefixing and keep everything clean for you.
It's barf inducing
It's about separation of concerns. Your coders and designers are different people. You don't want them fucking with each other's stuff. It has nothing to do with the category of the project. Even with application development, your design and code is separate in any good framework in any language.
&gt;You're exactly right. In fact I'd say Meteor came about one year too early. Don't you realize youll be saying this every year as the Meteor monolith can't possibly keep up. The speed of the surrounding environment &gt; the speed of 1 company. And it's impossible to constantly pick winners as a monolith. Most likely outcome from here is they'll make meteor into just a build pipeline for isomorphic code and a really nice graphql boilerplate. It fully stops being opinionated but that kind of eradicates the value proposition.. DDP was great when there were ~2700 packages on atmosphere that all were guaranteed to hook into DDP + blaze. The dream is over though, now they've fragmented the surrounding ecosystem and now are pushing the value proposition of apollo. I actually wish they just focused on faster builds and more tooling instead of being less opinionated (while still way too opinionated to keep up)
ahh I see nice, Ill try this out. I think I was having problems because I already have a title displayed and when I hover over the content below pushes the top content in a jerky way. Any ideas on how to avoid this? I put images below, thanks again for the help! Learning a lot. before hover: http://i.gyazo.com/d14fee3b19f729f017d92a69ea7dbda5.png after hover: http://i.gyazo.com/31f261a75e814e187a48cfa061f0f7ae.png The bottom extra information would appear smoothly but the food name would jerk to the top really fast.
&gt; Is there any solution where i could simple call MR() and assume AJAX will be successful and simply get the server response? No, it's an asynchronous process and must be treated as such. Callbacks or promises are necessary.
Is that from the new Darktower movie?
Those are all valid js. Except for the render function but that's jsx so since I assume he's using a compiler that handles that close enough.
Study and practice. Years of it.
What is the angular team culture?
If I use new it's usually new Promise(), new Date(), or new RegExp('string'), other than that I manage fine without it. 
"Anyone who draws a wall between design and usability deserves neither" - Abe Lincoln
We actually follow that nameing convention ever since v0.11 or 0.12 I think - but it wasn't prominently communicated with the two big 1.0 and 2.0 releases, so it has gone mostly unnoticed for anyone not reading release notes on github.
Basic JS courses online (treehouse/code school/mdn tutorial) --&gt; Free Code Camp curriculum for practice --&gt; advanced JS courses using frameworks (react or vue courses on udemy) --&gt; making my own apps or more Free Code Camp advanced projects All along the way, reading blogs and watching videos from JS developers
Inline styles in any shape and form are a terrible idea propagated by people who don't understand web development. HTML is structure, CSS is looks, JS is behavior. Don't fucking mix them.
Thank you for the help so far! I looked through those docs and I think I am still missing something. I set up a small bin, similar to yours [here](https://www.webpackbin.com/bins/-KinWN7X9i7w5aGLr_jA). What I would be looking for is a something akin to a "spring", but where each 90¬∞ rotational animation on the _y-axis_ is accumulated. To illustrate what should happen if the user were to rapidly click on the cube: Clicks | Rotation (deg) | Duration (ms)^* ---|---|--- 1 | 90 | 1500 2 | 180 | 1500 3 | 270 | 1500 4 | 360 | 1500 5 | 450 | 1500 6 | 540 | 1500 &amp;nbsp; ^* ^For ^simplicity's ^sake ^I ^am ^ignoring ^that ^the ^user ^would ^not ^be ^able ^to ^successively ^click ^without ^adding ^a ^small ^delay ^on ^each ^click ^and ^thus ^increasing ^the ^entire ^duration ^of ^the ^animation. Rapidly clicking would increase the `toValue` of the animation as the next animations accumulate and influence the current running animation. It should not stop anywhere between a 90¬∞ rotation though. I hope this somewhat illustrates the problem I am trying to solve. A working example I created on what this would look like in the experimental Web Animations API can be found [here](https://jsfiddle.net/es8ahepe/). Unfortunately it only seems to work in Firefox (54.0a2, developer edition), so [here is a .gif](http://i.imgur.com/HBZi60J.gifv) just in case. I'll read up a bit more on additive animation, because Animated does seem powerful compared to other solutions I have seen so far. If you have any other pointers, I'd love to hear them. Have a great day! 
I was disappointed to find no pics/illustrations in the article, nor mention of testing.
Can't you just count clicks and set it to toValue: clickcount * 90 on each click, then without interpolating setting rotation.y = Math.PI / 2 * value ? What you are currently doing is stopping the animation to get the last value, i think that could also work but needs for effort. Anyway, you'll figure it out. Crazy that this works with three.js btw. `Animated.createAnimatedComponent('meshBasicMaterial');` What the hell ... 
&gt; try to handle errors as ‚Äúcloser‚Äù as possible to their source I'm not sure if I agree with this. Typically the pattern I follow is to have one catch at the end of everything that does all the error handling. If it's a REST servie, in the blocks above I'll explicitly throw different things if I get something I'm not expecting, as an example, `ValidationError` turns into a 400, `AuthenticationError` 401, `AuthorizationError`, 403 and most everything else (including db errors) 500. In your last example, you catch the db error, then immediately check if the value returned from it is pi. It's pretty innocuous here, as it's a simple type and simply checking equality against undefined will return false and nothing blows up. But let's say the db call returns an object that subsequent calls are expecting - all of a sudden checking any property on the value which you thought would be safe now blows up because you caught an exception too early and it's continuing to run subsequent then blocks.
I used Polymer for a long time actually, i am in agreement with everything /u/m3wm3wm3wm wrote, except the Redux part. Redux in Polymer is complex because of Polymer, not Redux - to the point that Rob Dodson himself didn't understand what he was doing and why, because Redux doesn't lend to imperative structures, which are inherently hard and always have been. I didn't say anything that should get you so rilled up again other than posting statistics that were making the rounds on twitter currently. If you say the missing 6970 users are still using near-dead bower, then if that's the case it explains it and good. ps. Preact is a one man hobby project, a great project nonetheless, but congratulations to the Google conglomerate if they beat it out of the pond.
Pretty pictures and a pointy/clicky thing to do the work for you cause thinking and learning are tooo haaaaaarrrd.
Ouch that is polymer 0.5 - yeah that version sucks indeed - i evaluated it and it was evident to me it is not ready for production - I agree here wholeheartly. &gt; Btw, pitting Polymer against CLI tools and saying it gives "more insight" is laughable If you look at the link again, you will notice that i only used cli packages (not frameworks) - because thats the only part that could be compared on npm (in relation to polymer).
Thank you, I'll try that out! It's more of a fun experiment anyway. &gt; Crazy that this works with three.js btw It really is, it seems really powerful in React, knowing that it can easily drive your UI and 3D scene animations in such a manner. &gt; `Animated.createAnimatedComponent('meshBasicMaterial');` What the hell ... Haha, I used it for react-three-renderer's [`&lt;meshBasicMaterial /&gt;`](https://github.com/toxicFork/react-three-renderer/wiki/meshBasicMaterial) and tried to pass the value at first without the `Animated` component, but it doesn't pass the values that way, I think. The [`createAnimatedComponent`](http://browniefed.com/react-native-animation-book/api/CREATEANIMATEDCOMPONENT.html) function is also used in [`react-dom.js`](https://github.com/animatedjs/animated/blob/6dad5390a189831a5f4db6ac466931f629318505/src/targets/react-dom.js#L49) for some basic components. I opted for an [`addListener`](http://browniefed.com/react-native-animation-book/api/ANIMATED_ADDLISTENER.html) for the _y_-rotation for exactly that reason, as react-three-renderer only accepts a [`THREE.Euler()`](https://threejs.org/docs/#api/math/Euler) object to be passed into the [`rotation`](https://github.com/toxicFork/react-three-renderer/wiki/mesh#rotation) prop. Animated doesn't seem to look for an [`Animated.Value()`](http://browniefed.com/react-native-animation-book/api/VALUE.html) inside such objects. 
While I agree the last example isn't a good one given that the then and catch are reversed (reserving judgment because author said "something like:"?), I think the point is that the initiator of a promise chain should be responsible for handling errors within that chain rather than the operations used within it. In other words, you shouldn't be handing off error handling to the isPi method.
I love the PX visualizations. I ran across them when developing a polymer project, and use them frequently. I have to be honest though, the documentation is quite shotty, and in many cases does not match the actual behavior of the components. There is even contradictory information within the documentation itself. Having said that, the components are very well designed, and elegant!!
Another, similar example would be including async operations in an otherwise sync function. For example, something I'm dealing with now is an API that has something like: updateData(value, options) { data.update(value) return options.save ? data.saveToDbPromise() : Promise.resolve() } Even if I don't want to save, with everything I want out of the operation is sync, I'm forced into getting a promise result. Worst of all, all other operations that "update data" in turn became inherently async as a result of utilizing this function. The effects trickle down throughout the entire program.
I wonder if using something like c3js wouldn't be better instead. Too bad its mostly one-man project. Predix guys claim they have special requirements for their components though.
IMO, angular 1 is better suited as a MVC framework which is what the authors had in mind when they built it (talking straight angular, not 2 which is a different story). So it's a little weird to me that they would use Angular for a component based architecture when there are other fantastic frameworks out there (React, Vue, Angular2) that do it better. Isn't it kinda like saying "we decided to go with a MVC architecture with our react project"? 
Yeah, I would love to have a charting library that can be configured 100% by json in a nice way and not be outdated (and be open source at same time).
Huh I do? No not really.
What do you mean? It's your code. You can structure it any way you want. Also, if some function kicks off some promise without returning it, it's a bug, because you won't know when it's done. Anyhow, here is your example with await: console.log(await Promise.resolve('A')); console.log('B'); This prints A then B.
Check this module: [cron](https://www.npmjs.com/package/cron) p.s. And never use `setTimeout`/`setInterval` for anything more-less important in terms of timings ‚Äì it sucks, especially for long timers.
&gt; some search engines can't utilize JavaScript The one that matters does. Read up on the big G's latest SEO best practices here: https://support.google.com/webmasters/answer/40349?hl=en One changing date on a site does not to Google indicate "relevancy" nor "recency," it just indicates that someone is using a dynamic date. If the updated date also came with a meaningful and site-relevant content update each time, that would bolster the site's SEO.
Yeah, it could be. However what I probably left out of the article here is that the scale of the project wasn't in the initial scope of work that was set out. There was never an intent for it to become as big as it became. It's a typical example of what happens when you have to build a lot, fast with no time to really think about what's existing. It's more of a best use scenario for working with what you've got, should you have to. 
&gt;I'm not sure if I agree with this. Typically the pattern I follow is to have one catch at the end of everything that does all the error handling. I think its bad. it's the same big try...catch for everything which is an antipattern. consider the error similar to the error which is descibed with the code below: const something = 1 try { something = 'd' } catch (e) { console.log('error 500') } with your approach it will be really painful to debug the code. and much more complex thing: your application server shouldn't response with error 500 ‚Äì it make no sense. But I believe it's much broader topic then promises 
Yeah i had no idea createAnimatedComponent exited, looked it up in the source, makes sense now. This will come in handy because i kept making wrapper divs in some cases that wouldn't be needed.
With async/await or promise chains, yes const log = number =&gt; Promise.resolve(number).then(console.log) async function test() { await log(42) console.log(23) }
I don't disagree, I'm only saying that the basic UI has remained the same since forever, and calling CSS a "document" style is revisionist history in the sense that the web wasn't just documents when CSS first came out. I'm not arguing that CSS is more or less powerful, just that it's quite capable as is, without any help.
What about events? That would still need to be done manually, right?
Then you might as well use a callback function. At least you'll have the guarantee the request is finished.
&gt; function MR (cb) { &gt; $.ajax({ data: '', &gt; url: "scripts/my_data_source.php", &gt; type: "POST" }) &gt; .done(data =&gt; cb(null, data)) &gt; .fail(err =&gt; cb(err)) &gt; } &gt; &gt; MR((err, data) =&gt; { &gt; if (err) { /*handle error*/ } &gt; else { /* do something with data */ } &gt; }) So if i run this in a browser it should work? My bad /u/menno btw i was confusing you. 
When it's not readable. I hate clever code.
Depends on the browser. Not all of them support [arrow functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions). If you rewrite it to regular functions, then it should work pretty much everywhere: function MR (cb) { $.ajax({ data: '', url: "scripts/my_data_source.php", type: "POST" }).done(function (data) { cb(null, data); }).fail(function (err) { cb(err); }); } MR(function (err, data) { if (err) { /* handle error */ } else { /* do something with data */ } }); 
I wouldn't worry about it too much. Evan will dominate that contributors chart for many reasons, primarily that he's the founder of it, and that he's working on Vue full time. The money flowing in through sponsorships/pledges on Patreon probably does wonders for his motivation also: https://www.patreon.com/evanyou
scoped css wheel was already invented (and still implemented in firefox)
This is a pretty great list to get started with. I'm in the process of writing a JavaScript testing course and I'd love to help people out with how to start learning about unit and integration testing. I'm aiming it at people just getting started or looking to up their skills to get their first job or to go from junior to more experienced developer roles. I interview a lot of people and I find that sometimes even the senior developers don't have as much testing experience as I imagined. Feel free to join the waiting list and email me with any of your questions. Thanks! http://www.marclittlemore.com/courses/javascript-testing-made-easy/
Sorry about the question, im a newbie, is this something like bootstrap? looks similar somehow (cleaner).
3260ms of scripting to show a mostly-blank page :/ actual payload size is 190k. http://imgur.com/a/V9fCi
My knowledge is very limited but I'm currently doing angular tutorial and they and with it you can have something called 2 way binding. The hero editor has the ability to startup with a list of objects and you can edit them. Hope that helps a little before some js guru comes down :)
No mention of one of the enabling technologies behind this new process: [Ecmarkup](https://github.com/bterlson/ecmarkup)! Basically, we had to find a way to move the spec out of Word and into something plaintext, editable on GitHub, expressive, not overly verbose, toolable, etc. Decided on an HTML "superset" that includes markdown and a bunch of other conveniences for spec authors and readers. 
Could you share your .babelrc config ?
That solves another problem, but yeah it's nice to have options.
Your argument is that because edge case exceptions exist, you should throw away the entire practice. This seems like folly to me, and when people mix CSS, HTML, and code, in my experience (with a tech company that writes complex web applications for the enterprise, for what it's worth), this results in buggy applications (you have people who can't code mucking around in code, and you have programmers mucking around with design, and you get some early Facebook ugliness (their project structure explicitly encouraged this sort of switch hitting), and you end up with code that is hard to read and find the important stuff. &gt;The basis of components is that making the dependencies between these explicit in one place makes them easier to reason about. Complexity is contained by separating functionality into many components. Sounds like a damn fine argument for separating design and functionality components! You don't have to make one CSS file and one JS file for an application. You can have a folder for a component that contains a CSS file, a JS file, etc. This is what we do. Separate components, and then separate those components into their constituent parts. Plus as a bonus if you're looking for a CSS rule and have no idea where it is, you can restrict your search to just CSS files rather than running search on every file in your project. It is just practical to separate your concerns as much as possible. Yeah, for a one-line component, whatever, but if you've got some complicated thing, you are going to utterly screw your team in the long run mixing concerns. I get this sense whenever I'm on this sub and see people booing separating CSS and JS and HTML all I can think of is "God damn React brainwashing people"
Make a cronjob. You could choose to use the npm package to abstract away some of the nitty gritty, but know that cronjobs can also be implemented on a system level rather than server. Google is your friend :) sometimes...
li is necessary for other pieces of the puzzle unfortunately 
You have a typo: `onclick` (lowercase c), not `onClick`
Would really need to see the whole solution, and know what your exact error is. From a purely Javascript/DOM approach, when you want to add an element to a List, you create a new element, then append it to the parent. See example here: https://www.w3schools.com/jsref/met_node_appendchild.asp Edit: Definitely need more context here. Your .append in jquery is being applied to a DOM class, but your window.listings appears to be an array. Are you creating an array from the list? If so, you may have two redundant structures with sync issues. Post your whole solution somewhere and it would be infinitely easier to troubleshoot. ;)
Yes, JavaScript + React would be perfect for this use case. Are you looking for help with this? I'd love to assist.
I like javascript the weird parts on udemy. 
"make them editable," is ambiguous. Do you want someone to be able to click on a field in the LI, type, and have it save? Do you want someone to click on the LI, have it open a new modal and let them enter the values in appropriate text boxes, then save the results back? I'm not clear if your HOW question relates to how you provide a mechanism to users for altering the text of an LI element, or how you replace/edit the LI element once you have the user's changes.
I'd love to help you through this process. I'm confident you'd be able to achieve it with your background. PM me!
I fully understand the logic behind what you're saying, and hopefully it pans out that I fit in with the team in the manner that You're saying. I do overly sweat the details, but I can, for the most part, put that aside and tackle the problem. I think a big part of it all comes from the initial thoughts of being a researcher, when I was way younger, which influenced my thought process. I like to know things, like to know how they work, even if I don't understand it, for some weird reason I can spend hours listening to astrophysicists explain things, with little to no idea what they are explaining or how it all ties together, but I find it deeply interesting. The thing is that that mindset does not always yield a reward, even within the CS world. More times than not, I follow the rabbit down into a rabbit hole, and wind up more lost than Alice, and by the time I climb back out, I've spent 2 hours implementing something that may work, but I don't fully understand. The thing that sucks is that at times in the blind stage of fury that is coding, there are more times than not, that my code works, but I again have little to no idea why, the pieces fit so I placed them together, and since my coding style is strange, I comment after I implement most of the time. I think the reason why I go about the overly researched part is because I want to get to the stage where by looking at someones code, I could see where they may be trying to go, and if possible see that A -&gt; B -&gt; C -&gt; Breaking The Code Base. I do appreciate the insight though, and will likely keep working on this, just need to understand a few manners of how.
well, BEM is the solution for the company as big as Yandex. 
It is because of `g` (global) flag. `RegExp` constructor is extra too, literal will suffice.
Thank you! Why is this potentially causing the issue? 
Yes. Check out 'superagent' or 'requestjs' on github.
http://prettydiff.com/guide/unrelated_dom.xhtml I wrote this, so if it sucks please let me know. I would like this to be education and helpful. Any feedback that could improve the document is appreciated.
Not useful for those who have already used and/or ejected create-react-app (though looks like a neat project nevertheless)
It would be better to put it on GitHub or put it on CodePen or JSFiddle rather than in a zip on Google drive. People could look at your code without downloading the whole project. Also, zip files sometimes virus carriers.
I (and probably many others) intend to continue using a scripting language (e.g. TypeScript or Dart) for scripting and only use Wasm modules for heavy computations such as physics or path finding. There isn't much to gain in the "cold" areas of your application. If you spend less than 10% of the time there, making that twice as fast probably won't be noticeable. Making that stuff harder to write, slower to iterate, and less convenient to debug won't be worth it.
What stops you from using assembly for the desktop frontend and why isn't anyone doing it? Because it is expensive in its own right in that it doesn't easily lend to it. The abstractions in higher level languages produce faster user facing applications because they rely on proven patterns and best practices. If you had to re-create that in the low level you'd end up with so much complexity that your outcome would crumble. You use low level languages for intensive tasks, background calculations, number crunching and so on. Desktop apps can tap into it, so does node, now finally we'll have it for the web, too. I doubt that many would want to write front end with it, or even compile c#/c++ into llvm front end, because that would be quite silly. Modern JS is a suitable and ripe tool for that.
&gt; I define ‚ÄúCSS in JavaScript‚Äù as using styled-components as this is the current trend for styling components in React. You really should use dictionary definitions, not your own. I do not respect arguments that are predicated on redefinitions of terms to suit the person making the claim. &gt; Are you referring to this example? No, I was referring to the example presented in Myth #5: "In this case, CSS is shorter (229 characters VS 222) and easier to follow (subjective)." In this example, you provide an example of a 'better' method than styled-components, yet it uses neither BEM, nor CSS Modules, in conflict with your OWN recommendations: "Use CSS with either of the naming conventions (I recommend BEM). If you are worried about class name collisions (or too lazy to use BEM), use CSS modules.". Such native CSS styles (like "button.primary") can potentially conflict globally, whereas the styled-components example will not. That is why it is a fundamentally unfair comparison. &gt; JSS and CSS modules are not comparable. JSS is most certainly comparable. JSS solves many different problems, including resolving the problem of globally namespaced CSS, which is the definitional purpose of CSS Modules ("A CSS Module is a CSS file in which all class names and animation names are scoped locally by default."). (edit, read "comparable" as "compatible", adjusting statements accordingly)
How does it compare to Vue?
&gt; since some tricks you can do in JS don't translate could you please explain?
&gt; wouldn't it give rise to client-side projects that are written in "NO-JavaScript" Perhaps, but those developers would also be leaving behind all the third party modules written with js. So, one could end up in a position where they have to write all their own dependencies, ie you're doing some type of data visualization but now you have to write your own version of D3 in C. JS has so much mindshare and momentum (especially client side) that I just don't see it going anywhere anytime soon. But, yeah, I mean anything is possible and maybe your scenario would be the one that plays out.
The don't be a dinosaur thing is a bit presumptuous. I'd take that out. Besides the copy at the beginning the site looks great. When you submit a challenge and it passes you're left in a kind of limbo of "What is suppose to happen next?" I had to hit back and then click the next challenge. You should change the flow to automatically bring you to the next challenge or make the current "Next" more prominent if you do have a method of getting to the next challenge after submitting. All in all it's pretty nice. Edit: The phrase "today's ever-changing world" is so cliche it gives me a headache.
To be honest, that codebase is quite confusing - it's hard to figure out what's going on.... BUT it's great you got so much working! If you got this far then I know you will collisions working (The game actually only showed the main menu to me - I had to add `mainMenuSelection = 1;` to get it to enable input and let me start). First thing I noticed: you should *very rarely* need to use the `parseInt` function. It's only needed when you have a string and need to turn it into an number: but your map is already stored as numbers. If you have a float you want to make an int, use Math.floor. If you find that you are ending up with `NaN` or a weird string somewhere then it's a sign you have a bug - you should find the bug and not just `parseInt` everything. The next thing, if you have lots an lots of `if` statement that are basically exactly the same, then it's a good sign you can simplify things: if (parseInt(introMap[y][x]) == 111) { renderer.drawImage(stoneout1, tileX, tileY) } if (parseInt(introMap[y][x]) == 112) { renderer.drawImage(stoneout2, tileX, tileY) } if (parseInt(introMap[y][x]) == 113) { renderer.drawImage(stoneout3, tileX, tileY) } if (parseInt(introMap[y][x]) == 114) { renderer.drawImage(stoneout4, tileX, tileY) } all of these could be simplified to something like this: const tile = introMap[y][x]; const tileMap = { 111: stoneout1, 112: stoneout2, 113: stoneout3, 114: stoneout4 }; render.drawImage(tileMap[tile], x, y); Then you only have to look up the tile index once, and it's easier to add new tiles and the code is heaps shorter. For the collisions... I couldn't see anythign instantly that was wrong - but you have to start with a MUCH smaller map... just use a 10x10 map, with no backgound/mid ground... just make a tiny foreground map and make sure you figure out which TILE the player is standing in and that the rendering of the player is in the correct tile. So make a small map with just stones around the whole thing. Then make sure if player tile is [1, 1] then they are standing on screen in [1, 1]. Then its much easier to see where things have gone wrong! 
Neat project! As for your question, something is wrong with player positioning. Moving one space left of the start position puts me at `(8, 5)`, and moving one space right of the start position *also* puts me at `(8, 5)`. Moving one space up *or* down puts me at `(7, 6)`. I used this snippet to make looking at position a bit easier (I just put it at the end of the render loop in the map file): renderer.save(); renderer.font = "16px Arial"; renderer.fillStyle = "rgb(255, 255, 0)"; renderer.fillText('X: ' + player.x + ' Y: ' + player.y, 16, 16); renderer.restore(); Also, you could cut down your code by a *lot* (I'd estimate ~30-40% fewer lines) if you did something like this for your tiles: // Define tile ids and source images var tileAssets = { 110: "maps/introMap/stonec1.png", 120: "maps/introMap/stonec2.png", // ... } // Create image elements in a loop instead of one at a time var tileImages = {}; Object.keys(tileAssets).forEach(function(id) { tileImages[id] = new Image(); tileImages[id].src = tileAssets[id]; }); // Draw tiles with one 'if' per tile var tileId = map[y][x]; if (tileImages.hasOwnProperty(tileId)) { renderer.drawImage(tileImages[tileId], x, y); } You may also want to look into [classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes) and [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame). A typical render loop would normally look like this, and will render at up to 60 fps (which is the max a browser will repaint at). function render() { requestAnimationFrame(render); // Your rendering code } // Call render once to start the loop render();
Looks that way. In the [demo](http://dassur.ma/things/dom2texture/demo.html) you can only interact with the DOM version. If the canvas and webgl ones worked out of the box I'd probably need several days to recover from the shock. This is pretty nutty as-is.
I'm not trying to show off, I'm just asking for an example code snippet that already does this. :| I could easily adapt that to what I need.
One tiny bug (like not even important) but on the "scales" page when you scroll or click on "opacity" the little vertical line doesn't scroll to signify it.
They aren't rendering against the DOM. It's not HTML, it's a compiled binary that can run in the browser (like a web exe file). More direct access to hardware acceleration, memory management, etc. JS relies on the browsers rendering engine to make decisions about how the CPU or graphics card is used. Games written in web assembly have their own compiled engine that can be optimized to the task, instead of generalized like a JS runtime.
I guess if you like shipping several KB of CSS to your clients then yeah it probably sounds stupid.
I'd imagine that you would be using some sort of component system for your UI if you're using Tachyons. Then you would make a change in one place and it would propagate throughout your system. Problems with BEM are that you're shipping non-reusable CSS and the solution to writing new UI is to write *more* CSS. I like BEM btw I just like Tachyons more ;) Also CSS in JS is really the best solution for software rendered via JS :P
It won't help SEO, and it won't hurt it. Though SEO can seem like black magic, sometimes experimenting alot can have great results, JS date output won't do it though.
ELI5
For CS principles, I find MIT OCW to be useful: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/. Also: https://www.edx.org/course/introduction-computer-science-harvardx-cs50x. 
You shouldn't give him the solution. It isnt going to help him become a better developer.
You're correct, WebAssembly will likely disrupt JavaScript, eventually. Most or all of the code we ship may one day be WASM. What shape that disruption will take is anyone's guess. It could be that a bevy of languages (new and old) enjoy roughly equal popularity. Or, a single language takes the far lead, essentially becoming the new JavaScript. Or, JavaScript itself may change rapidly in response, and stays as popular as it is today. Also, toolchains may emerge that compile JavaScript down to WASM, so you can get the performance without adopting a totally new paradigm. That's all years away, however. In the short term, you won't be able to write React with WebAssembly, so JavaScript will remain essential.
Thanks! I will check those out :)
Thank you! I like Udemy courses a lot, so I'll give that a look.
Your example doesn't always work in the web app world. The example you gave is due to the differing skills of level designers, game designers, and game programmers. Where I work, everyone is a full stack dev, so if we decided to use language z that compiled to WebAssembly we'd have no reason to use JavaScript. If someone works at a place with frontend engineers who aren't particularly well versed in language z you might avoid an all in for WebAssembly. WebAssembly should be smaller file size and faster to parse according to Mozilla, which is another direct benefit outside of code performance. To be fair, there is no reason Dart or TypeScript couldn't eventually output wasm instead of js in a far flung future.
We're not talking about the standard web app world though. Wasm was conceived for the purpose of expanding what kind of web apps were possible or feasible. Where you work is just one example. I have worked on games myself. We have used scripting in other languages due to ease of use, in spite of being quite proficient at c++, the language the engine was written in. Languages are a tool. No tool is better at every type of problem than all others. It is completely reasonable to use multiple tools for different parts of a single project.
Thanks everyone sorry that I couldn't reply earlier but I live in Europe and we have a different time zone... But anyways I get it that my code is really a mess and I'm gonna be honest I didn't really write the code for rendering the tiles because I couldn't really find a guide that would be compatible with what I'm working on and my dumb brain didn't get it so I just copy pasted that for and the condition with the parseInt which I figured out was useless later... I'm gonna try to simplify the code. And if the movement is confusing thats because when you move the player sprite isn't actually moving the tile map is... So then I ended up with negative numbers that I turned into positive and that was my player position variable... And.again with the messy code I was really just testing... If it's going to work I'm gonna rewrite a lot of it just to make it clear... Once again thanks everyone for taking your time and helping me.
Thanks so much for your valid feedback, I will make necessary changes to the flow. I feel that my wording is humerus - I guess it's just a matter of opinion.
Can't stress enough how good my experiences with this are - one of most powerful type systems and web dev. Feels like writing javascript with most of required testing being written by compiler. Refactoring is a breeze. Many companies use it in combination with https://github.com/japgolly/scalajs-react, which is again immensly powerful and typesafe.
The second part is = instead of ==
Good writing.
Finally, struggled to find some comprehensive guide to testing applications ! 
*QUESTION:* WebAssembly runs inside JavaScript engine by introducing a new (separate) runtime. There is an intermediate bytecode created when WebAssembly is compiled and the interpreter executes on-the-fly on top of this bytecode (JS is JIT-compiled but doesn't create intermediate bytecode layer). This would mean that JavaScript engine would stay inside browsers in the long run and WebAssembly will complement JS (multi-threading support + dual runtime). Is that true?
I would argue that what a component renders, what a component looks like, and how a component responds to interaction are not separate concerns. They are defined by different languages, but they're ultimately all the same thing. 
Because points is defined in the global scope as a global variable. So 'myFunction' can sort it. But 'myFunction' should be called once. 
And then it continues for the rest of the array. So now points[1]=40.So the sort functions checks 40-1=39.So a goes after b.
&gt;HTML is structure, CSS is looks, JS is behavior. Don't fucking mix them. Any one of these on its own is worthless, any two without the third is pointless. The concern is the component, not the languages.
tldr;
Thanks.
Thanks for answer! Well latest electron versions don't work anymore in windowsxp. I will research on nw.js. But not all features can't be compiled by Babel for older browsers right?.. Yeah sorry if my situation is quite weird and stupid but that is my situation right now :(
Array sort is implementation dependent. The method's API is standard, but how it works beyond that is non-standard. This is important to know. The sort method receives either nothing or a comparator function. If no comparator function is supplied the values at the two compared indexes will be coerced to string types as aggressively as possible and then compared for ascending sort. That coercion to a string equivalent is implementation dependent. If a comparator function is supplied, like in your code example, it will conditionally determine the direction of sort (ascending, descending, or no change in position) between two compared indexes. The sort method expects the comparator function to return a number value. The standard supported values are 1, 0, and -1 which determine the direction in which the two compared indexes should be reorded. Any number will probably work as they are likely evaluated as positive, zero, and negative.... but this is non-standard and thus implementation dependent. Ascending and descending sort operations are simple to understand as one item is greater or lesser than another item, and so these operations are stable cross-browser. Since the sort implementation is non-standard it is unknown how many times a single array index will be touched for comparison or which other indexes it will be compared to. This makes the comparator's 0 value really confusing and not stable cross browser. For stability always ensure your comparator function contains any number of simple conditions that return only a 1 or -1 value and then supplies a default return value of 1 or -1 when all conditions are exhausted (all evaluate to false). Also don't perform sort operations without a comparator function on arrays containing non-primitive data types. Type coercion to string for primitive types is stable and standard, but this isn't true for non-primitive types and definitely non-stable cross browser in a sort operation.
You can read the source code on Github. Here are some interesting projects to look into: [once](https://github.com/isaacs/once) - learn how to make sure a function only gets called once, and learn how to add prototypes responsibly. [Dat Desktop](https://github.com/datproject/dat-desktop) - learn how to build electron apps [csv-parser](https://github.com/mafintosh/csv-parser) - learn to create streaming interfaces for parsing datasets [pull-stream](http://git.scuttlebot.io/%25xAFKL6PBr1CIzL5xGHZC5DFVWiXmc7R0MMnZnBwq%2Fyk%3D.sha256) - learn how to create a streaming interface with minimal amounts of code and machinery [choo](https://github.com/yoshuawuyts/choo) - learn how to make a functional framework [patchcore](http://git.scuttlebot.io/%253uoPLlaQeWRK5D%2FtlzrjNp%2FgH2X42lLL%2BOJxLZHCDfA%3D.sha256) - learn how to structure a reusable foundation
Look at [jQuery](https://github.com/jquery/jquery) sources, for example (while it's pretty complex since there are lot of stuff).
Very helpful :)
Yeh, it seems to just be a reactive iPython for javascript
use https://github.com/letsvalidate/api - real-time generating a thumbnail preview of a website, it handles all modern web apps, e.g. https://api.letsvalidate.com/v1/thumbs?url=html5test.com
Yeah I started jQuery but then it got complicated soon. how should i read it , should just go top to bottom or should I go through specific functions/methods and try understand them first?
&gt; That coercion to a string equivalent is implementation dependent. Could you give an example of this in a case where it matters? Obviously one shouldn't expect to sort an array of objects or the like with the default comparator. &gt; The sort method expects the comparator function to return a number value. The standard supported values are 1, 0, and -1 which determine the direction in which the two compared indexes should be reorded. Any number will probably work as they are likely evaluated as positive, zero, and negative.... but this is non-standard and thus implementation dependent. This is incorrect. Any numeric value is valid, so the `return a - b` in OP's question is fine. From the [ECMA-262 standard](https://www.ecma-international.org/ecma-262/5.1/index.html#sec-15.4.4.11): "The sort is not necessarily stable (that is, elements that compare equal do not necessarily remain in their original order). If *comparefn* is not **undefined**, it should be a function that accepts two arguments *x* and *y* and returns a negative value if *x* &lt; *y*, zero if *x* = *y*, or a positive value if *x* &gt; *y*." &gt; For stability always ensure your comparator function contains any number of simple conditions that return only a 1 or -1 value and then supplies a default return value of 1 or -1 when all conditions are exhausted (all evaluate to false). The standard (quoted above) says that the comparator must return zero if the two values compare equal, and that the sort is not necessarily stable. If you arbitrarily return 1 or -1 for two equal values, you are invoking undefined behavior. This is definitely not a way to get a stable sort. Consider the fact that the comparator function does not know where in the original array the two values are located; it receives only the values. If you want to return 1 or -1 for equal values instead of the correct 0 return, how do you decide between 1 and -1? You can't, so either return value is wrong. Return 0 for equal values as specified in the standard.
&gt; blazing fast all libs are "blazing fast", but some are more blazing fast than others [1]. so i'll ask as i always do, how blazing fast is it really? [1] https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts/table.html
So this is Jupyter on D3? But JavaScript only, obviously.
Async and Await are still interacting with Promises under the hood. Every Async function returns a Promise. So while using these facilities may look like Promises are obsolete, it would still help you to learn about how Promises work From a usage standpoint, I think it largely rests on how you want your API to be used. There is nothing stopping you from using the chainable Promise syntax in a service layer for example, but using Async/Await in your consuming component or unit tests. I'm sure more advanced developers will chime in if there are some subtle differences in error handling or performance. Also I believe Async/Await are still in some kind of draft phase and could change so use them with some small measure of caution. 
Excellent explanation, just one minor correction: &gt; The callback‚Ä¶must always return an integer indicating the inequality - generally 1, 0, or -1. The return value can be any number; it doesn't have to be an integer. And there's nothing special about 1 and -1; any number is valid (other than a NaN, of course). For example, if you are sorting an array of non-integer numbers, you can still `return a - b` and get the correct result.
Good answer! Thanks!
aha, I didn't realise that it was just more stuff on top of promises - thought it was an alternative implementation! Good to know! There are definitely times when I've wished Promises weren't the way they were, but /u/mikejoro has pointed out a few situations in which, yeah; advantages to each. Thanks for the response!
When you include code in a comment or self-post, add four spaces at the beginning of each line so it is formatted correctly: var points = [ 40, 100, 1, 5, 25, 10 ]; document.getElementById("demo").innerHTML = points; function myFunction() { points.sort( function( a, b ){ return a - b; }); document.getElementById("demo").innerHTML = points; } In addition to the comments explaining how `sort` works, one other point to note is that your code never *calls* `myFunction()`. So the code as written won't sort anything until you make that call. (You no doubt know that already, just mentioning it in case it was a point of confusion.)
It has higher priority in the cascade than a stylesheet (given equal selectors,) and the easiest way to apply an "accessible" stylesheet is to disable the supplied stylesheets via browser controls.
That part reminded me of F# type providers.
I would argue that using async/await with your promises is almost always superior due to error handling. With just promises, if an error is thrown within one of your .then blocks, and you don't have a corresponding .catch, the error is silently swallowed. Isn't that nuts? However, if you await your promises and wrap them all in a try/catch block. all errors will be caught. That's a huge advantage! Plus, looping with async/await is super easy compared to just promises. There's no reason not to use it. Some would say performance isn't top shelf yet ... bleh, async/await is the future and performance will definitely come.
&gt; Could you give an example of this in a case where it matters? It matters if you wanted to sort this array: [{cat:"meow",dog:"bark"}, [1,2,3,5], -0.23432, function () {return;},,,"car"] &gt; This is incorrect Yeah, I have read that, but I don't trust it from my prior experiences wrangling with sort differences cross browser. My preference is to proceed is with maximum caution. &gt; If you arbitrarily return 1 or -1 for two equal values, you are invoking undefined behavior. This is the intentions of the spec. The spec specifies to literally return a positive value, 0, or negative value. It does not specify to return a boolean, which the `&lt;` and `&gt;` yield. Whether undefined or not this approach returns the most stable and predictable results in my experience. &gt; If you want to return 1 or -1 for equal values instead of the correct 0 return, how do you decide between 1 and -1? I think you are misunderstanding the nature of the comparator function. You can put what ever logic in there you want. You can even induce side effects by assigning to closures in there. It is fine and doesn't matter. What does matter is what this function returns, because it is the return value the sort method uses to determine if an index should be shifted forward, backward, or remain constant relative to the compared index. &gt; Return 0 for equal values as specified in the standard. Agreed. 0 is an acceptable value according to the spec. The spec does not specify a sort algorithm or what 0 must mean to that algorithm. It does mean the sort task is implementation dependent and the means by which indexes are fetched from the array are also implementation dependent. The frequency and quantity of access for a given index is algorithm dependent, and thus also implementation defined. This isn't meant to be stable and you even cited such. From experience a return value of 0 produces an array sorted in different order cross-browser. For clarity please see the latest edition of the spec at: http://www.ecma-international.org/ecma-262/7.0/index.html#sec-array.prototype.sort
Describe what you're doing and what exactly doesn't work.
Don't use forms
If you're going to learn ML there are some other, quite large, barriers of entry that would most likely make you already comfortable with using a more powerful language.
Zeit does really interesting stuff. I appreciate how focused they are on making things easy to do. 
Sorry! The site was under üöß. Its working now.
No it's not. It would also catch any regular sync code errors you have between your awaits, such as JSON.parse ... it's great to do everything with try/catch now instead of mixing error catching methodologies and worrying about swallowed errors.
Check your HTML. Thing's looking all wrong. Not sure what JSFiddle actually requires in the HTML block. Go back to the basics and use your reference for that. For JS itself ... you had: function compute() function $() { return document.getElementById(id); } { ... } You tried to define a function in the wrong place. Also, you didn't pass the id into the $() function. Gonna be honest. Scrap it, start with the basics (HTML and JS) and build it piece by piece. Such as building a button that calls compute on-click, all compute() needs to do is alert('compute') or console.log or something. Make sure you get a handle of when/how it's called, etc. Correct the $() function to actually receive and use an id. Test it in the compute(), for example. Start adding the HTML bits you want (input text, make sure to reference the proper usage of the tag). Reference the element by id. And so on.
Building countdown timers is a fairly common JS exercise. You can grab one online and integrate your alarm. Here are some links from a quick google search: * [Creating a Countdown Timer](https://www.w3schools.com/howto/howto_js_countdown.asp) * [Timer.js](https://github.com/husa/timer.js/)\ * [Build a Countdown Timer in Just 18 Lines of JavaScript ‚Äî SitePoint](https://www.sitepoint.com/build-javascript-countdown-timer-no-dependencies/)
I agree with your points, but there are workarounds for what seem like immutable problems. TC39 has said that they won't introduce runtime modes beyond "use strict". However, I think it is still *possible* that it will happen anyway. You can move forward in ways that don't break old apps.
Why downvotes?
Creator here. In the next version, there will be some more changes that make Moon even similar to Vue. The main differences are that Moon is about 3 times smaller, and a bit faster. It is also missing some features of Vue, but they can be added via plugins.
Thanks that worked. I guess others coming to my site may get the old js script loading which would not be good. I found through searching that you can add ?ver=1 to the end of your src='myjquery.js?ver=1' line and just change the version number when your done editing/testing. No need to rename the actual js script to that.
OK sure I accept that -- that's what we ended up doing at my agency when we adopted a Tachyons project. We extracted all individual components into partials and integrated them into a front-end build system. Still doesn't solve the visibility problem (e.g "ok whats this mush of 4 letter class names mean and where the hell is the sub-nav that I need to tweak"), you lose access to things like pseudo selectors and end up having to break out of "functional CSS" for them anyway (like what do you do if you want a box to, say, outline, and then its contents flip around on hover?). You lose nice tools like live-reload which refresh your stylesheets automatically without a page refresh, you end up having a harder time within the inspector because you cant apply a property to, lets say, a button class and see it propagate to all of the buttons in real time... and what do you get? You get smaller CSS file sizes which is a problem already solved through front-end tooling, you get "Low Specificity" which is also solved through BEM, you get an out-of-the-box framework that's well documented and responsive by nature... which is fantastic so i'll give it that. Your argument that with you are "shipping non-reusable CSS and the solution to writing new UI is to write more CSS" is pretty weak. What's non-reusable CSS mean to you... that I have to write `margin-top: $spacing--1;` in ever class that needs it? Don't you have to re-write `mt-1` over and over too? 
Interesting, it's not something I've thought much about, but I got to thinking that if you use a build tool that generates/transforms your js then you'll neatly dodge this problem.
YEEEEEEES.. *breathes* YEEEEAAAAH. I remember doing unit testing when I was first messing around with CS in college for my minor. I'm vaguely aware of mocha and some common modern JavaScript testing woes/paradigms, but I'd love to learn how I can design a program from the ground up to be unit testable. I feel like as I build my portfolio up, having unit tested code adds some credos to otherwise simplistic projects. 
&gt; Previously we also recommended creating a less.Parser and then calling toCSS on the result. However this had 2 serious drawbacks - it meant that our parser was in fact tied to all of less and 2nd it meant that the toCSS call had to be synchronous. &gt; You can still get the less parse tree, but it requires more steps. You can see how this is done in the render function but we do not support using less in this way and may change this function in a minor release version bump (we will not break it in a patch release). Seems that it's not wise to go down this route, sadly. I'm going to look into Stylus now that I can do such on a PC, but as backup I do have $name: unquote("&lt;&lt;test&gt;&gt;"); h1 { color: $name; } 
Surely you could just await Promise.all(...)?
Then I'd say you're using promises by using the Promise api
Of course you are? I don't understand your point. You said you can't async/await concurrent promises. Promise.all allows you to use promises concurrently. You can await Promise.all.
Sure, we can just say that async/await is the same as using promises, then we'd be agreeing. Anyway, you have to use the promise API to do concurrent promises, which is why I'd say you can't do it with just async/await
It can certainly handle concurrent promises using the Promise.all method, which, itself, returns a promise. let promise1 = Promise.resolve(); let promise2 = Promise.resolve(); await Promise.all([promise1, promise2]);
I don't understand your point. I think your idea of promises and async/await are wrong. They're one and the same underneath. Async/await just provides a better interface 
`await` and `async` are just helpers to consume and generate Promises, but you are still dealing with Promises. `async` is certainly a better way to generate a `Promise`. Beside the use of `return` / `throw` to resolve / reject a generated `Promise`, it insures a function always returns a Promise and doesn't throw by accident. I can't think what `return new Promise(...);` could be used for instead of `async`. `await` is a new way to consume promises' values but you will often mix await declaration with `then`/`catch` `Promise` methods. It certainly great for sequential tasks.
[removed]
This might be usable. https://jsbin.com/beruricepu/edit?html,css,js,output
Const asyncPromiseAll = (... promises) =&gt; { return new Promise(async (resolve, reject) =&gt; { let results = []; for (let promise of promises.map(Promise.resolve, Promise)) { results.push(await promise.then(async resolvedStuff =&gt; await resolvedStuff, reject)) If (results.length === promises.length) resolve(results) } })}; Still explicitly uses promises to handle concurrency, but still functions as a nice utility method if for some reason you insist on not using promise.all 
He's saying you can't do concurrent promises without MANUALLY calling promise in some form. Async wraps promises without you ever writing the word promise. It's an abstraction over. Currently, as you can see by my async promise.all implementation above, there is no way to do concurrent promises in async without dipping below this abstraction and manually accessing the promise api 
That depends on the person doing the learning as well as the quality of the book/course. There is no one size fits all. I personally learn well from videos, but have found documentation and blog posts useful for the extra bits, a book to me is useless, I can't learn from reading a few hundred page book, in part as I don't like long winded readings and its also very uncomfortable for me to read books on a computer which is really where you need to be is you want to learn coding. I key part for me is the interaction, lynda.com has a nice mix of vidoe/follow along. Codes cool took that a step further by making it more practical and interactive.. Then you head over to a place like udemy who releases courses so absolutely shot you may as well be trying to learn by discerning smoke signals from the moon. 
Great. Thanks!
This was how my old company packaged deployments of apps. You'd bundle your webapp (Node/Ruby/Python/Java etc) into an RPM file, install that onto a Linux VM and then make an AWS AMI of that disk file, then you had a permanent image with known-working dependencies that could be redeployed at any time, any where.
Probably fanboys or scala haters, just like in the scala-native 0.2 thread from a few days ago. There was a uninformed fanboy post, which claimed scala-native 0.2 was a reaction to kotlin-natives announcement from last month. Clearly without knowing (or just ignoring...) that scala-native was around 1 year earlier made public than kotlin-native, and version 0.1 was earlier announced than kotlin-native as well. Nontheless the post received quite a few upvotes.
Now there is Docker for that kind of thing, no?
Can this be combined with an alarm option (using it on Squarespace)? *edit* something like this: http://www.onlinemeditationtimer.com or this https://theconsciouslife.com/meditation-timer.htm
How is this different from https://github.com/nexe/nexe
True but this removed even that dependency 
Yep, a certain broadcaster... 
I am in the medical imaging domain. I did a PhD on medical image compression and image quality assessment, then a postdoc in computer assisted diagnostic for prostate cancer using DL and now I am building a medical image viewer in JavaScript. I have used itk/vtk, Matlab, tensorflow, scikit-learn and the like. Prior to the PhD my background was electrical engineering so I've learnt everything from programming FPGAs to x86 assembly to high level language such as JAVA.
this is exactly what I need
Wow. Nice and true. Thanks for sharing. 
I'm not sure if I understand what you want. Anyhow, since you're just starting, I recommend to use ES6's classes and let/const. That stuff is way more straightforward than the ES3/5 alternatives. class Character { constructor(name, weapon) { this.name = name; this.weapon = weapon; } attack() { console.log(`${this.name} swings their ${this.weapon.name} and does ${this.weapon.damage} points of damage.`) } } class Weapon { constructor(name, damage) { this.name = name; this.damage = damage; } } let axe = new Weapon('lame axe', 5); let garry = new Character('Garry', axe); garry.attack(); -&gt; Garry swings their lame axe and does 5 points of damage.
Yes, just for how easy it is to get started. 
I don't like how react ditch the Html with their jsx. Angular is top level when you spend a lot of time to learn it and Vue.js is highly inspired by angular (components and 2-way binding)
I love Vue but it definitely isn't wholesale better than Angular or React, there's a lot more nuance to that discussion. If you're primarily concerned about employability of your experience, React looks like the near and medium-term future for developers in the West. If you're looking for something for personal or freelance work, I'd just try out Vue for a project. You can work through the docs in about two hours (the whole documentation!). Vue generally is very good about staying out of your way and letting you be productive - definitely a huge part of its hype right now. If you're a Chinese developer, Vue looks like the future. I think nearly all the giants (Alibaba, Baidu, Weibo) have converged on it. I can go into a more detail if you like. 
Well that one is paid, for instance.
Hmmm... you sure about that? Just tested it out and seems to be just the order regardless of inline or linked... The accessibility thing (or even just theming) is a fair point though.
If you're going to make a blanket statement, at least back it up. As someone who uses React all day at my full-time job and Vue on all my own projects, I think Vue is much better. So now who's right? ;)
Vue has no 2-way binding
You're 100% right but in fairness `v-model` is syntax sugar for (effectively) 2-way binding and they re-introduced `.sync` in 2.3 (again, just syntax sugar). 
Or it was written by someone who isn't technical who either picked that buzz word up or searched it. I see it all the time in staffing company posts. Translation probably means what the previous poster mentioned - be familiar with HTTP verbs and when each is/can be used, familiarity with how to interact with services via HTTP (through Angular / NodeJS according to the description), and general troubleshooting techniques probably wouldn't hurt
Can you go more into detail if I want? 
Now kiss.
Yeah, that worked! Thanks a lot dude.
To help complete your understanding, you should be calling the constructor of one of the weapon objects: this.weapon = new Axe('lame axe'); This creates an instance of Axe. You also need to make some modifications to Axe to ensure it's a descendant of Weapon but doing so is less fun in ES5 than it is in ES6. I would recommend following /u/inu-no-policemen's advice to use classes because derivation is simple: class Axe extends Weapon { constructor(weaponName) { super(weaponName); } } 
Same in Europe tbh, most job ads I see for startups require it. You're positioning yourself nicely if you know it.
honestly i think all these are fine, it's the language itself you should look for an alternative for instead
I swear I'm not trolling, but how could anyone who has understood react/javascript enjoy using Vue? I've seen other people say that as well, and I just don't get it. Vue feels like an attempt to 'make angular great again', but angular from the beginning was not a good javascript framework. Vue/angular seem to be frameworks that are tailored towards not needing to know javascript, while react is clearly made to be used by javascript developers. I can't imagine a scenario where a javascript developer would think, "Instead of using all the power of native javascript to build my views, I'd like to restrict myself to a limited, custom templating language instead." Here's the only thing I can reason about why people might like Vue over react: 1. Not comfortable having to make design decisions about code/not comfortable using modules (where do I put code, how do I organize non-component code, etc.). 2. Not comfortable using javascript in general, e.g. coming from a different language or not being familiar with functional APIs. 3. Never actually used react and say things like "HTML in my javascript isn't separating concerns" (if they have used react and still say this, item 1 applies). I mean really, how can it get simpler than react? Every time I look at vue documentation, I don't understand how anyone could possibly think that is simpler than react. Here's react in a nutshell: 1. Design a render function which returns html you want to render (your entire component could be just a function). 2. Use composition of components in exactly the same way you use composition of functions (props = args). 3. Trigger re-renders by updating your parent component's internal state. That's all there is to react. I don't need volumes of documentation for it because it really is that simple. Can you sum up vue in an equally simple description? Do you really find it easier and more expressive than function composition?
Sure! What about?
I think it's worth messing around with for a todo app or something because it's a good way to experience fully component-based building, i.e. markup, behavior, and styling all together in the same component file. (Although, if I remember right, this is also how React Native does it.) There seems to be a lot of indecision in the frontend community right now about the best way to approach styling in React-like frameworks, and one of the options is component-contained styling. Messing around with Vue helped me discover that, in spite of its merits, that's _not_ the way I like to do it.
As someone who has used both, I just prefer the syntax of Vue. I never liked jsx. Take this simple example and tell me which one you honestly feel "reads" better: // .vue component &lt;template&gt; &lt;div id="message"&gt; &lt;input type="text" v-model="message" /&gt; &lt;span&gt;{{message}}&lt;/span&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; var Message = new Vue({ el: '#message', data: { message: '' } }); &lt;/script&gt; vs: // react component var Message = React.createClass({ getInitialState() { return { message: '' } }, handleMessageChange(e) { this.setState({message: e.target.value}); }, render() { return ( &lt;div&gt; &lt;input type="text" onChange={this.handleMessageChange} /&gt; &lt;span&gt;{this.state.message}&lt;/span&gt; &lt;/div&gt; ) } }); Personally I find the first example less verbose and more readable.
And it is really a shame, seeing as Vue just feels so much more comfortable to use.
Haven't used it myself, I do use React though and it's pretty comfortable as well? It's widely used meaning support is generally better, and lots of good plugins and guides out there. I'm sure Vue has some awesomeness to it, but why should startups(or even bigger companies) pick it over React? Because it's 8kb lighter or something? I haven't quite gotten the appeal of it yet. 
It is returning undefined because in the else part you need to add return. Works for me with: function isEven(a){ if(a === 0){ return true; } else if(a === 0){ return false; } else { return isEven(a-2); } } Edit: formatting
Having recently spent a significant time evaluating Vue, React and Angular. I have realized all frameworks are very close and have their benefits. I ended up concluding: 1. For small to medium complexity and sized webapps I would prefer Vue over both angular and React. It has a small leaving curve and is pretty fast in the cycle of Prototyping to real app. Performance and concepts were enough for me. 2. Anything from medium complexity to high, would go with either react or angular. If working on a multi module app with lots of teams involved, I would perhaps lean towards Angular. TLDR - I would personally like to know all 3 and then choose the one which is right for the work.
Here's how I would write your react example: class Message extends Component { constructor() { super(); this.state = { message: '' }; } onMessageChange = (event) =&gt; { this.setState({ message: event.target.value }); } render() { const { message } = this.state; return ( &lt;div&gt; &lt;input type="text" onChange={this.onMessageChange} value={message} /&gt; &lt;div&gt;{message}&lt;/div&gt; &lt;/div&gt; ); } } I think that's a lot easier to reason about than vue; I know each time my `render` function is executed, it will return that html. I know when the render function executes (when I call `setState`). That's all you have to tell someone for them to understand because it's plain javascript. There's no magic here. What causes vue to render the template? How can I rerender the template? Does it automatically do it for me if I mutate anything in `data`? These are all things I would actually have to understand from documentation even if I can reason that `v-model` is connecting something from `data` in my vue component. React is explicit; I'll take the extra 4 lines of code for that trade off.
I'm using Vue because I had no experience with any of the major frontend libraries and decided to just pick one and learn it. I'm now comfortable enough with it that I can knock up a prototype for an app in a couple of hours. What I should really do now is rebuild something in React so that I can make my own comparison of the two frameworks, but I'm having fun actually making stuff instead of going back to step 1 with a new framework yet again so I haven't done it yet. An anecdote that shouldn't really influence your decision but is still interesting: My company evaluated React, VueJS and Angular 2 and decided to go with React. React and VueJS were pretty close in the final scoring and React won because it would be easier to hire people that knew it and train those that don't. I was not part of this evaluation process.
To be clear if I wasn't before, I think it's almost entirely personal preference :) I do agree React is more explicit, but I just personally have an easier time digesting a vue component at a quick glance, maybe because the HTML is separated and "cleaner"? Like do you still have to use className instead of class in react? That's actually what bugged me the most on the project I worked on :(
You'd still get a stack overflow if you pass something like 1.234. Here is how a somewhat robust implementation could look like: function isEven(n) { if (!Number.isInteger(n)) { return false; } return !(n % 2); } console.log(isEven(5)); // false console.log(isEven(4)); // true console.log(isEven(1.23)); // false console.log(isEven('xx')); // false
Since you're already using class properties there you can drop the constructor: class Message extends Component { state = { message '' } .,.other stuff... }
I found the syntax more likeable. That's, I admit, mostly an issue of preference.
typescript. Basically javascript with types that does static type checking on your code then compiles it down to pure javascript to ship to the browser
Well the main idea behind it is to build something that has a similar feature set in each framework so that you can encounter and solve the same problems. That's the entire idea behind http://todomvc.com/. It's not the best way to get the things you want to build built but if your goal is to compare different frameworks building the same thing in each one seems perfect. If someone announced their revolutionary new framework QwerJS at the same time as someone else released AsdfJS how would you go about determining which of the two you thought were best and what the strengths and weaknesses of each were?
I'm not Sir_Lith but I think this is the biggest question for Vue at the moment. If you are happy with React there aren't really many concrete reasons to pick up Vue. Vue offers better out-of-the-box performance than React (and sometimes Vue even beats hand-optimized React code) but how many people are actually hitting React's performance ceiling? I'm curious how React Fiber will affect this, if at all. To get to your point, I don't see any major, key selling points of Vue over React. There are a ton of small things that I think Vue does better than React, but small improvements aren't going to motivate companies to port their codebases nor developers to abandon (potentially) years worth of experience. That said, a common theme from companies discussing why they chose Vue over React is simplicity ([1](https://isl.co/2016/07/three-major-reasons-we-decided-to-ditch-angularjs/), [2](https://about.gitlab.com/2016/10/20/why-we-chose-vue/)). However, I don't see this becoming the norm especially if there is a large talent pool of developers with React experience. tl;dr good is the enemy of great ;)
Compiling code is not the same as encrypting. Decompiling code, especially something like a node app, is trivial. If your only countermeasure to vulnerabilities is "gee, I hope they cant figure out how I hacked this together", you're getting hacked either way.
whatever you want to do. vuejs IS for sure worth a look. its so simple and efficient that you dont want to miss it. i worked on enterprise apps with angular 1 and a bit when transitioning to angular 2 and i hate both to death (even though i dig typescript and ES7). how people accept the shit the google green tea serves them on a platter is beyond me. vuejs is great for small to midsize apps and can even work well on enterprise size. but for that i rather have a look at aurelia. react shouldnt have a single user with the license they roll with.
How does it work with APIs?
Good point. I normally don't use that or class arrow functions, but I don't want to be up against the whole 'bind syntax is confusing' argument (which isn't really an argument if you understand javascript context).
It's a library and a framework depending on your needs. Vue combines: - the low barrier to entry of jQuery (dump some CDN link into your HTML) - the component-based approach of React/Polymer (and now Glimmer) - the CLI and batteries included approach of Ember and Angular since its companion libraries are maintained by the core team (vue-router and vuex aka redux for vue) I almost see the fact that it's smaller and faster as a nice-to-have, coming from React I could get started and build something without having to think about which companion tools to use (webpack vs browserify vs rollup, redux vs mobX vs setState, boostrapping react-router with v3 or v4).
Yes
Definitely. 
People saying react is easier usually have not actually used Vue to any extent. If you can "reason about" `render` and `setState`, then you can probably "reason about" Vue's reactivity system. You can also use Vue with a `render` function, and even JSX if you choose and then you don't have to learn the template dsl at all.
The way vue/vuex handles state is way more intuitive and easier to understand compared to the rest. Single file components are pretty convenient too. Still sticking with react though!
While I don't contest your point that React's approach is more explicit, it's worth noting that v-model is literally just syntactic sugar on top of the same pattern you are using in your React example. In fact, I strongly suspect that the implementation of v-model in Vue 2 was inspired by React's now-deprecated LinkedStateMixin, because it's functionally doing the same thing.
`isEven(a-2);` contains not just a function reference, but also calls this function. As such, this is evaluated, and the result of this call is passed to `return`. So you're not returning a function, you're returning the result of calling that function, which is exactly what you want here. If you have some other situation where you want to return the function itself instead, then you could do something like `return isEven;`. Note the lack of `()`, meaning the function itself is not called, and thus is passed to `return` as a whole.
I'm speaking strictly in terms of how the html is separated vs. having it with jsx in a render function, that's a factor of the library, not poorly designed components. But again, personal preference.
Like React and unlike Angular, Vue is strictly focused on handling the presentation-layer of your application: things like an http client are outside of the scope of what Vue offers. This means you pick and choose what functionality you pull into your application - a popular http client in Vue's community is Axios (would link but on mobile). You can then interact with a REST API entirely through the HTTP client. Interacting with a Graph API works similarly. People will often wrap popular APIs so they are easier to work with in Vue. If you want to see a concrete example, look up the Vue hackernews demo. Personally, I am using Algolia in an application right now. I am using their Javascript client to interact with their API and storing the results in a central store called Vuex. All I have to do in Vue is define how the data in the central store should be displayed and Vue handles the rest. This is a common pattern that allows you to entirely decouple your presentation layer from your business logic. It makes writing tests for your application a lot cleaner too. Sorry for the long rambling answer to a simple question.
Python isn't a "scientific" programming language per-se. It just happens to have a few scientific libraries written in it. Those libraries may as well could be written in C/C++ as native addons for NodeJS making javascript just as suitable as python.
Haha that's exactly my tech stack for recent projects!
If a graphic designer can write HTML they can write JSX. We keep our graphic designers away from the codebase entirely.
Sure.. you could have native node modules, but what is the added value? JS brings nothing but innefeciencies to the table. If you have the knowledge/capabilities to learn ML, learning python should be trivial. If leaning python looks like a challenge, well.. you are just not up to the task IMO..
Honestly it doesn't matter. In a few years both Vue and React will go the way of jQuery and the dodo bird. Something new and better will replace them. It isn't the tool that matters as much as your skills as a developer. Just choose whichever one speaks to you more. If you know either, you can be trained on the other in almost no time. Any company that will only hire you you if you already know library/framework X isn't worth working for. 
Thanks! Why can't you use PHP to interact with the REST?
Yes. 
With very little vue experience but a lot of experience with base redux and other implementations like redux, why is this the case to you? I know vue is based more on observable getter and setters, but how does this affect managing state that makes it easier to you? 
I have no clue what vue offers over any other syntactical sugary nightmare HTML madness 
Of course, I completely agree. Good companies see right through "one trick pony" engineers. But I, unfortunately, don't have the time to become an expert at every new framework. It's important to know the pros and cons of the popular frameworks at any given time, but I only fully invest in learning the ones that have the highest demand.
By replacing it with Amazon ?
Yes please. I like this.
I think the [vuex lifecycle](https://github.com/vuejs/vuex#vuex-) is easier to understand, compared to redux action switch statements returning modified state. especially when it comes to getters and returning several different types of a state object. redux middleware, which atm has at least 3 diff popular choices, adds more complexity too. although i know it's not needed all of the time, guides and docs routinely go directly to middleware for async stuff.
axios. For promise based http requests (ajax)
A bit late but... Inspired by: https://mobile.twitter.com/errikkxa/status/849349212005421056 Link: https://moe-szyslak.github.io/Schwifty/ Source: https://github.com/moe-szyslak/Schwifty edit: mobile ready
I find CodeTrain pretty good. he has a giant library of both project and tutorials. A lot of it however is in the P5 framework https://www.youtube.com/user/shiffman I went and bought e treehouse subscription around a year ago. It got me up and running with the basics. It kinda depends where you are also I feel
The thing about any of these tools are, they're just that, tools. So you have to ask yourself: "Is this tool worth 'buying' and adding to my toolbox? Will I get a decent ROI by investing in this tool and will it make me more productive over the long term?" If the answer is yes, then go ahead and learn it, you'lll have one extra tool in your toolbox you can use to tackle problems, projects, and tasks. None of these tools will solidify themselves as the de-facto tool indefinelty, only short term/for the foreseeable future. But something new WILL come, eventually. You just have to think critically about what best aligns with your goals and ambitions. Learning the tools isn't an end in itself, your goals ambitions and what you plan to do are. So if you're a quick learner, and pick new things with ease, it wouldn't 'cost' much to pick up Vue (or anything else) but if you like to invest heavily in something and take your time and stick with it long term, perhaps some more thought should go into it. These tools and services are built on the philosophy and ideas of a certain individual or collective group, which is another thing to consider, just because a large community rallies behind it and it's the standard, or hot new tool, doesn't necessarily mean you HAVE to agree with that philosophy and methodology. Some things have been tried and tested, yes, but on the other hand if someone wouldn't have disagreed with the status quo, something like React, Flux, and Redux, wouldn't have ever came about. Sorry for the long winded response But they are just tools, pick it up if you'll benefit from doing so and if you think the time allocated to learning it will be worth the value you derive from learning and adding said tool to your 'toolbox' as a developer. 
"Building a Static Website Using React JS" why?
Exactly, if you're building cool, performant things with it, I'm all for it. I'll use what I like, but won't declare one objectively better than the other. It's a waste of breath.
I'll give you my standard advice for learning React and Redux: The article "A Study Plan to Cure Javascript Fatigue" ( https://medium.freecodecamp.com/a-study-plan-to-cure-javascript-fatigue-8ad3a54f2eb1 ) is a great place to start. It gives an excellent series of steps for tackling modern Javascript concepts one piece at a time: Javascript, React, ES6, and state management. On that note, definitely don't over-complicate the learning process by trying to learn many different things at once. Some people will say you should use a "boilerplate" to learn React, and they're wrong - boilerplate projects almost always come with too many pieces configured, and are confusing for beginners. Instead, the best advice is to focus on learning React itself first. Once you have a good understanding of how React works, you will better appreciate why a state management library like Redux can be useful, and you can learn about other tools later. You should start out by reading through the official React docs and tutorial at https://facebook.github.io/react/, and I'd encourage you to use the official Create-React-App tool ( https://github.com/facebookincubator/create-react-app ) for setting up projects. It creates a project with a solid build setup, with no configuration needed on your part. There's an excellent post called "Simple React Development in 2017" ( https://hackernoon.com/simple-react-development-in-2017-113bd563691f ) that gives some more specific instructions on the actual steps to follow. Past that, I keep a big list of links to high-quality tutorials and articles on React, Redux, and related topics, at https://github.com/markerikson/react-redux-links . Specifically intended to be a great starting point for anyone trying to learn the ecosystem, as well as a solid source of good info on more advanced topics. It includes links for learning core Javascript (ES5), modern Javascript (ES6+), React, and much more. I also published an "Intro to React (and Redux)" presentation at http://blog.isquaredsoftware.com/2017/02/presentation-react-redux-intro/ , which is a good overview of the basic concepts for both React and Redux. Finally, the Reactiflux chat channels on Discord are a great place to hang out, ask questions, and learn. The invite link is at https://www.reactiflux.com .
Well, and I hate to be that guy, but it really depends on your projects. If you are handling lots of dates you might consider moment like suggested by another user. If you need to handle lots of async redux requests, check out redux-thunk or redux-saga. Makes sure you're using the react performance and testing tools, they will make your life much easier. Same goes for redux logger. Redux logger has been the best qol improvement that I've introduced to my react work flow. If you have lots of interesting api queries and difficult data structures, checkout relay and graphQL. Need ui stuff? Semantic-ui-react is decent. Check out the latest version of react router for sure. Want to go the PWA route? Check out sw-precache and the sw-toolkit to get started. It all depends on your needs! Don't worry about diving into all of it. For a basic project I'd recommend: React, react-router, redux, redux-thunk, react development and test tools, react-performance tools, redux logger, and that's a decent start. If you want to look at testing jest as you mentioned in great, enzyme is also neat. You can use an http library like axios if you want, but fetch works and is fairly widely supported now. 
your first example doesn't work if you want to stop execution. await asdf(); .catch(e =&gt; next(e)); //execution continues here...
I don't know the pros or cons of using Jekyll, But no, using React doesn't add much weight, If done right. Once we use code splitting, compress everything and use gzip everything is lot faster and we get all the benefits of React and its entire Ecosystem. &gt; it also affects the perceived performance Yes., In a good way. Everything seems so fast and smooth. Anyways this is my personal opinion. BTW you can just as easily change the title to "Building a Static Application Using React JS" and everything will remain the same. Edit: &gt; It also doesn't seem to be any easier either That's true, But only for the first project, Later on you just use existing codebase or some Framework to make things even more easier., This is also what makes Developing websites with React more fun.
That is brilliant. Would love to see it upgraded for the modern JS ecosystem. Looks like it was originally done about a decade ago.
I haven't used Vue a whole lot yet, but the integration available with Laravel on the backend is really nice. I'm hoping to start using it more in the future, but my big SPAs still use Angular.
I don't think either is "better". It's about the right tool for the job. 
Me too! Now I have been absorbed into the system. We are all Borg now.
I'm currently doing projects in both Angular 1 and Vue 2. Vue wins hands down (and in case the version numbers seem unfair, the same was true of Vue 1). Vue is in a lot of ways more similar to Angular than it is to React (HTML templates are a significant ergonomic factor when you have to work with designers), but it just _better_. No need to deal with a custom module system, single-file components, more consistent data-binding, and far less complexity in the framework itself. I've also found it's more easy to manage state and updates than it was in Angular using services, but that might just be because I am not good enough at Angular. The great thing about Vue is you don't have to spend years getting good at it! I haven't worked with Angular 2 so I can't say how Vue squares up there.
&gt; the integration available with Laravel on the backend As a user of Vue and Laravel, there really isn't much to it. Laravel has a bunch of really convenient backend features, which you only need to take advantage of on the frontend by providing a certain request header when making API calls - and Axios does that, not even Vue! EDIT: unless you mean Mix, which is pretty sweet
An OS can be made in few Megs (if i remember correctly the article i read) but we have OS that need GBs of space. &gt; You can do a blog (markup + CSS) in about 5 KB Yes we can., We can also skip the CSS and only use HTML which browsers will apply default styles to and it might look pretty decent. &gt; You mean like your page? That one was rather slow... It might be, But with my internet connection it loads pretty fast., I didn't see any blank page for more than few ms, but i will check it out. &gt; This stuff is something you can measure And i will, And when i do, I will write a tutorial on it. Anyways you do realize you don't have to use React or Javascript at all, I am using it because i want to. You are free to not use it or use something that's lot better and highly optimized.
&gt; Any company that will only hire you you if you already know library/framework X isn't worth working for. Really? I know only vanilla JS and jQuery and I'm seeing that every job wants you to know X framework, but it's kind of hard for me to learn them when I'm not using them daily/in a realistic work environment. Following tuts and making simple apps doesn't cut it for me :/ 
There is a hardware limitation of the keyboard which determines how many key signals can be sent simultaneously. One trick you can use to detect multiple keys being held down is use the onkeydown and onkeyup functions. This way you can have a bool for each key you care about and set it to true when the key is pressed down and false if it's released. And then the rest of your program will reference that list of key states to see what is currently pressed.
I was just about to ask how the hell this relates to these libraries whatsoever. Thanks for answering my question.
My issue was there was no discernible difference between a function that returns JSX and a function that doesn't.
In NZ many employers/recruiters don't understand this, and framework experience is their main metric. However, if you have 10 years experience like I do, no experience with a framework, or even language, can be overlooked. Less experienced devs will need to be concerned with this in NZ.
Blog posts should stop telling me what I should stop doing.
I didn't mean it as a pun, After all having a good typography with balanced colors will make the readers very happy and the blog/pages very accessible. Then again, Those were the good old days. While things have gotten lot complicated these days, It has also become lot easier to build amazing things. I am not the right candidate for answering Why/Why not, I can only answer for what I like, Personally I develop apps with react and so its easier to use react for the website as well, In future I can easily write and demo components within my website this will make things lot simpler for myself. While the bundle/javascript size does and should matter, In most of the cases everything will load just as quickly. Anyways, We all have personal preferences and biased opinions so this discussion wont go anywhere. Thank you.
I disagree
as teamlead of a dev team i see the point with reacts "fame". but the beauty of vuejs is that anyone with a proper understanding of basic javascript and application development get into it in a matter of an hour. angular, react and co. mostly **require** build tool configuration, code abstraction (angular 2 code is SHIT) and layering. with vuejs you basically write vanilla javascript. so any javascript dev can work on vuejs apps with almost no warmup needed.
Sorry i can't answer to all of you but thanks for the recommandations i have read every response i think i will give Vue.js a shot then
In that case I'd say "ah hell yeah Angular.js? I got shitloads of experience with that".
I personally think the danger is that a smaller portion of developers work with vue.js. That being said, I like alternatives very much, I will try to learn polymer after I finish learning Angular 2 + TypeScript.
Yes it does, I've worked in San Francisco.
Sick anecdote but when we're talking about "Must have Angular 2.0 knowledge" and similar there's always a lot of leniency there. If there isnt just move onto the next guy and let them shit their pants in 4 years when they can't hire a guy who specializes in Angular 2.0 to manage their code-base because the community has moved on to React 32.9-alpha and Emberify.es6 14. 
Since this is a repost, I will repost my original comment: This article is full of half truths and assumptions. 1. Using 'styled-components' is not the only way to define CSS in JS, but the author writes as if it is. 2. The author recommends BEM style css definitions, but then doesn't use it (or any other global conflict resolvers) when comparing the length of styling code between native and styled-components. Since the former will conflict with other styles, this is not a legitimate comparison. 3. The author talks about how global conflicts with CSS are "solved" with technologies that are either not fully supported by a significant number of browsers (shadow-dom), or are themselves predated by other solutions that solve the problem (JSS predates css modules by over six months).
&gt; I was previously told by my professor Javascript did not [classes] "class" was a reserved keyword since the very beginning. ES2015 (ES6) added support for this stuff. Some people say that JS' classes aren't "real" classes, but they are just as real as Python's. class A {} class B extends A {} let a = new A(); let b = new B(); console.log(a instanceof A); // true console.log(a instanceof B); // false console.log(b instanceof A); // true console.log(b instanceof B); // true Works fine for me. Anyhow, always check the console (F12 -&gt; Console) for errors. Be also sure to use a modern browser.
In vue, is there a time where we do need the whole build environment? I have read the docs but never sure when build tools become a requirement (if ever?).
That one actually adds paths to node's native require, which could potentially lead to conflicts (though they seem pretty careful about that). OP's is a separate function.
Recently switched to Vue from 4 years of Angular 1 exclusively. I love it so far. So intuitive. Like react and ng1 had a child. Haven't come across one sore spot so far. It can be simple, but it can also be really fucking well tooled and powerful for large apps. Love the animation support, vuex, and router. Love vue files. Love the 3rd party components/directives/etc from the community -- much higher quality than ng1/react ones. Documentation is top notch, especially compared to the absolute shit docs ng2 has. The vue inspector for Chrome is amazing. I wouldn't listen to people that say it's not suitable for large apps without evidence supporting their argument (real use of Vue in large production applications as well as X other framework, and reasons why X worked better).
The one that's right for the job is often the one that you can use most effectively to Get Shit Done‚Ñ¢.
Ah, gotcha.
[removed]
Yes, and it's just syntax sugar in the parent component, in the child component you still have to explicitly emit events. Most people probably just use it directly on html form elements though and not custom components, in which case it does seem more like real 2 way binding. 
Hey! Just wanted to say thank you! I finally managed to figure out what I was doing wrong and with ya'lls help with the structure it's now working perfectly! Appreciate it!
Hey! I figured out what I was doing wrong! Well, I fixed the error anyway. It insisted there was a period misplaced but I deleted and rewrote the line and now it's working perfectly. Thank you! Using the structure you showed me I now have it up and running 100%! Greatly appreciate it! Do you have any insight on the difference between these "proper" classes and the function object methodology I was attempting to use earlier? Clearly one is more readable than the other, but should they in theory function the same? 
I got about half way down the page and asked myself the same thing. It looks massively overcomplicated and the SEO looks a bit flakey. This aversion to what could be done with some very simple server-side code alarms me, to be perfectly honest. Maybe a simple SPA might have made a better example? 
I've used angular. I've read the docs. It's not rocket science to assume how vue could be less straightforward than react. 
I'll take a look. Thank you! I just don't understand the use of tests when it's purely me just sending values and testing the values. When dealing with real world applications, I want to be able to test user given input. For example, if a user provided a form with a username and password, I expect my task runner to tell me 1.) if that form function was fired 2.) if it passed or failed Right now I feel limited as to what I can do with unit testing.
Middleware _are_ the recommended tool and approach for implementing async behavior with Redux, but you're welcome to put it directly in components if you want to. See http://redux.js.org/docs/faq/Actions.html#actions-side-effects .
Was looking into what's out there as far as perf tooling, this looks like a great resource. Thanks!
Here's a simpler solution that doesn't require adding any modules. app.js global.__base = __dirname + '/'; other.js const logger = require(__base + '/lib/logger');
*Unit* tests are about testing your units ‚Äî smallest pieces of functionality in your app, usually functions. Since they are testing small pieces of functionality, they are easy to write (you just need to know what's the input will be and what output should be) and easy to run (you don't need to setup any external world things, like system or browser environment). This is means that you can, ideally, run your unit tests continuously (e.g. on each file save) and get continuous feedback on how your changes affect the rest of the app. What you are asking for is usually called *integration* or *system* testing, and in browsers world you'll probably end up using something like [Selenium](http://www.seleniumhq.org/) for it. The thing about integration tests though: because they need to create and tear down complex environments, they are usually slow, as in (anecdotally) several hours for several hundred tests ‚Äî not a delay you want to have while writing software. So, in short: it's good that you think that unit tests are not enough, but you should seek to add to them, not to replace them.
Yeah I'm doing the same - but for ES6 love it's template strings :D ``` let logger = require(`${__base}/lib/logger`); ``` 
There are three kinds of tests: * Unit tests * Integration tests * End-to-end tests # Unit Tests Unit tests test functions and make sure the functions do the correct thing -- and don't do the incorrect thing. For instance, you may have a function called `toUpperCase` and you want to ensure the function does indeed upper case a string, but also make sure it leaves numeric and special characters alone. How it handles `null` should also be decided and tested. # Integration Tests These tests check how well different pieces function together. In your example, you may have a `LogUserIn` function which takes a password, updates the database and returns a token. *Some* people also include testing the UI via automation, but I include that in the next step. # End to end tests These tests examine the whole system, often running on a headless browser. They interact with the browser the same way a user would and press buttons and click things. Then they watch the screen to make sure the correct thing has happened. 
Wow thank you good Samaritan! By the sounds of it, I'm looking at unit tests all wrong. I've been trying to run integration tests, when I should be concentrating on unit tests. Making sure the functions work as expected when given certain criteria. Not pumping users input through them to see if they'll pass or fail. 
hehe - it's cool. I was more trolling that adding anything to what you've already written :D But for me, this little bit of extra code does the trick.... I guess if I _had_ to write a module to solve for this I would write one that allowed an overloading of `require()` to take a second boolean parameter. If provided would basically to that `__base` pre append without the need for me to join the strings up myself - but not sure that's even worth the effort involved. 
FORTRAN and MATLAB are better suited for maths and data sciences than Python, yet it's more popular. Could people doing ML in Python not be bothered to learn those either?
I actually have experience with both. Matlab is commercial and expensive, Fortran is ancient and a wasteland. Python is where the ecosystem is best. But do go on.. waste your time in JS.. 
wdym code should go after the HTML? 
If you put code in `&lt;head&gt;`, it runs before the rest of the document has been parsed, which means `document.getElementById()` will return `null`. 
React or Vue. Vue is easier to pick up.
I used to be an ng1 dev and recently switched to vue in my day job. I would recommend it. Try out the [vue-cli](https://github.com/vuejs/vue-cli) to generate a test project and try out the dev process.
http://jsbin.com/dekuja/edit?html,js,output mistake ` welcome_parra.innerHTML = "Welcome " + name.value;` should be ` welcome_parra.innerHTML = "Welcome " + name `
The same would be true if you wrote a try/catch. let response; try{ response = await fetch('some/url'); } catch(e){ console.error(e); } let json = response.json(); // still executed I'm sure you're referring to something more akin to: try{ let response = await fetch('some/url'); let json = response.json(); return json; } catch(e){ console.error(e); } There are many ways to provide this level of functionality using the previous method. You could simply check to see if a value was returned from the promise (await returns undefined if there's an error). let response = await fetch('some/url') .catch( e =&gt; console.error(e) ); if( !response ) return; let json = response.json(); Or using a flag if the promise was never intended to return a value: let err = false; let response = await fetch('some/url') .catch( e =&gt; (err = true) ); if( err ) return; let json = response.json(); Or throw the err again after handling it: let response = await fetch('some/url') .catch( e =&gt; { console.error(e); throw e; }); let json = response.json(); Guess it just depends on what you're trying to accomplish.
If you want to use single-file components with different languages that transpile down to html/js/css (Pug, Stylus, Less, etc.), you're going to use the full build environment.
Knockout. Still gets the job done and I don't see the advantages of the other frameworks. Edit: don't know why the downvotes (Knockout haters?) but granted I didn't explain myself very much. Last project I worked on I went full "web 3.0 mode". I used Typescript with Knockout and Require JS, managed all things Typescript through npm, used Gulp for building and Bower for dependency management and a whole slew of other tools. At the end of it I had created something that was terribly complex to explain and building it on a fresh OS install would definitely be... challenging I think (never tested it). I was not pleased with my solution, main problem being, hunting down TSD files for Typescript can be terribly annoying. The typings command I had to use seemed different every time (I still don't know why some typings needed to be installed with "--global" and why some didn't - sometimes they wouldn't work one way or the other), there were a lot of cases where there were errors in the TSD definitions and fixing them was usually quite a pain. I find the import statements to be confusing at times too. Aside from that there were so many components big and small to keep track of. Not to mention the littering of files all over the place and having to tell various configuration files to "ignore this, include that" and basically do the same thing again but for the IDE I use (IntelliJ Idea). Because of that last project I got Javascript Fatigued and I concluded that the whole npm/typescript/javascript/... world was one big jungle, even a cesspool in some places for lack of a better word. It's one big ass ecosystem held together by ducktape and sacrifices to the gods. This is a nice example: https://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/ I'm surprised things like that don't happen more often. This one is another nice description of how I feel: https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4 and this one is spot on: https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f So for the current project I'm working on I wanted to excise some stuff. I put the axe to Typescript, Require JS, Bower and Gulp. Then I started looking for a "more current" framework to replace Knockout, and what I found was that Vue, Ember, React, etc... all accomplish the same thing, only different (https://media.giphy.com/media/C6JQPEUsZUyVq/giphy.gif). The biggest degree in which they varied was which functionality came with it out of the box. Other than that it's just different syntax to do the same thing. I still liked the fact about Knockout that there's very little mingling with JS between HTML, keeping responsibilities separate. I can just slap a data-bind on whatever HTML I want to get it to do what I want. So here's a few things I'm doing to bring some sanity to all of it: 1) I organize all my website subcomponents into separate directories, each subdir representing a Knockout component containing a JS file with the viewmodel, an HTML file and a CSS file. Each subcomponent is entirely self contained. Instantiate it with the right params and done. Things that need to be kept in sync with other subcomponents I manage through Knockout subscriptions and that's working out very well. 2) I wrote a simple PHP script that traverses all the components and builds the HTML to construct the right CSS link rels and Javascript includes. No more Require JS, and no more building required. When I want to minify CSS and JS and I do it through PHP and cache the result. That allows easy switching between "dev" and "prod" mode, and no need for JS .map files. Plus makes it really simple to construct an appcache file to make the app available offline. 3) To alleviate the soft typing problem with JS, I JSDoc the shit out of everything. My IDE (Intellij Idea) helps out quite a lot with that and its auto-completion is unsurpassed. Plus, I should be documenting everything anyway so moving to a position where you're kind of forced to do it, I don't it consider a bad thing. There are some things I miss though, such as auto-refresh (that is very neat especially when it keeps state) and I haven't solved every problem like managing external dependencies like Bower did. But for now, I'm more productive and I can think what features I want where instead of trying to figure out how to incorporate those features in the first place.
Thanks I appreciate it. I will check out Vue one of these days.
As a shameless self promotion I am going to suggest you take a look at this post on my blog for an overview https://www.pointofvue.net/2017/04/05/7-things-you-should-know-about-vue-js/
Thanks, Ive heard lots of enthusiasm from a good amount of people. Starting to lean React - angular seems to be moving out from the little Ive noticed...
Let's be honest here, how many people who make 'what framework should I use' posts are actually going to read the sidebar?
And you do filter arrays and whatnot in JS. In Vue, to filter an array to iterate over, you would use a computed property. JS: computed: { filteredList() { return this.myList.filter(b =&gt; b.someFlag); } } HTML: &lt;ul&gt; &lt;li v-for="item in filteredList"&gt;{{item.name}}&lt;/li&gt; &lt;/ul&gt; Keeps your view separate from your data (but in the same .vue file).
C# Honestly, I wish I was able to use it more often. 
I don't use filters, personally. The API is small and easy to grasp. I got it within an hour or so. Since we're talking about arbitrary weird parts of apis, what's up with shouldComponentUpdate? Why the hell do I need that? In Vue the component's data is automatically tracked during render.
Completely anecdotal, but in my experience of running this (app-module-path) on multiple production apps for months I've yet to experience a problem.
You are getting undefined because of variable hoisting. When you say var name = 'blah' at line 3 of the function, js actually carries the declaration to the top of the function: var name; then you alert it, so it'll be undefined. Then you assign value to name. To fix it, move your 3rd line to the top of the function. 
Php?
So you're saying it's OK because React has good perf. Vue handles the situation *and* has better performance. Vue has even better perf out of the box without optimizations compared to what you can do with React.
Do you do game dev/Unity/mono?
Using the variable name before it's defined (although not good practice) is fine here. In JavaScript, the definition will be looked at First anyway(hoisting). The problem is that assignment happens after alert. So alert will always say undefined 
Best flair ever. 
Rust, up until I got started with that it was C++ though. I like languages that are built with the premise that the programmer is (mostly) responsible for making things work right. Those types of languages tend to be extremely powerful and feel like swiss-army knives. I feel like JavaScript, especially Node.js, fits in well to that mold. I also do a fair bit of graphics work which is another large reason. ;-)
Python, since I write a lot of dev tools. It's easy to get what you want done, comes pre-installed on all Mac &amp; Linux boxes, and was doing all the ES6 stuff (default args, destructuring assignment, etc etc) before it was cool.
The point is to propagate the return value from `someMethod()` back to the event handler. In older browsers, returning `false` from an event handler prevented the default behavior. The modern way of handling that is to explicitly call `e.preventDefault()` on the event object rather than returning `false`. But this example was written a long time ago and was designed to propagate the return value, if any. 
Elixir üòé and it's quickly becoming my #1 favorite language
Ruby
One advantages for React I see now is how it integrates with everything seamlessly. Want to render on the server using [Spring Boot](https://patrickgrimard.io/2016/11/24/server-side-rendering-with-spring-boot-and-react/) or [.Net Core](https://github.com/aspnet/JavaScriptServices)? Want to develop a [native mobile app](https://facebook.github.io/react-native/)? 
It will become a problem once you have 2 files with the same relative path, maybe one in your project and one in a dependency you have
SWIFT!!! I LOVE SWIFT!!! üòç
Wait a second, you're not MrXyfir! 
Is there a good walkthrough on setting up typescript with react?
Linkedin uses Ember too. Ember is great if you want opinionated framework.
Yup - check out https://www.typescriptlang.org/docs/handbook/react-&amp;-webpack.html
Go
Very biased in favor of React, so I'll give you my standard advice for learning React : The article "A Study Plan to Cure Javascript Fatigue" ( https://medium.freecodecamp.com/a-study-plan-to-cure-javascript-fatigue-8ad3a54f2eb1 ) is a great place to start. It gives an excellent series of steps for tackling modern Javascript concepts one piece at a time: Javascript, React, ES6, and state management. On that note, definitely don't over-complicate the learning process by trying to learn many different things at once. Some people will say you should use a "boilerplate" to learn React, and they're wrong - boilerplate projects almost always come with too many pieces configured, and are confusing for beginners. Instead, the best advice is to focus on learning React itself first. Once you have a good understanding of how React works, you will better appreciate why a state management library like Redux can be useful, and you can learn about other tools later. You should start out by reading through the official React docs and tutorial at https://facebook.github.io/react/, and I'd encourage you to use the official Create-React-App tool ( https://github.com/facebookincubator/create-react-app ) for setting up projects. It creates a project with a solid build setup, with no configuration needed on your part. There's an excellent post called "Simple React Development in 2017" ( https://hackernoon.com/simple-react-development-in-2017-113bd563691f ) that gives some more specific instructions on the actual steps to follow. Past that, I keep a big list of links to high-quality tutorials and articles on React, Redux, and related topics, at https://github.com/markerikson/react-redux-links . Specifically intended to be a great starting point for anyone trying to learn the ecosystem, as well as a solid source of good info on more advanced topics. It includes links for learning core Javascript (ES5), modern Javascript (ES6+), React, and much more. I also published an "Intro to React (and Redux)" presentation at http://blog.isquaredsoftware.com/2017/02/presentation-react-redux-intro/ , which is a good overview of the basic concepts for both React and Redux. Finally, the Reactiflux chat channels on Discord are a great place to hang out, ask questions, and learn. The invite link is at https://www.reactiflux.com .
Yikes... The types and interfaces don't seem like they add much value for React.
I like C++. I think C++ made some great decisions early on, and I think many of the "improvements" other languages tried to make over C++ are turning out in hindsight to be mistakes. Forcing all code into a class was a mistake. Getting rid of destructors was a mistake. Limiting to single inheritance was a mistake. Removing operator overloading was a mistake. It seems that other languages end up introducing new, highly specific features to compensate for the original, general purpose features they removed. Proxy objects to compensate for the lack of operator overloading. Traits to compensate for the lack of multiple inheritance. Auto-closables to compensate for the lack of destructors. And so forth.
I've done a few talks on this exact topic, but in short there are upsides to using a statically typed language, and a framework that supports that safety. The biggest benefit (and the reason why statically typed languages exist at all) is catching bugs at compile time, right in your text editor. Eg. all of the bugs in [this file](https://github.com/bcherny/Talks/blob/master/Incrementally%20Typing%20Angular/src/01-original.js) would be caught at compile time. These are not the sorts of bugs humans should spend time fixing; using a type system lets you work on higher level problems. 
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [bcherny/Talks/.../**01-original.js** (master ‚Üí 271dcb5)](https://github.com/bcherny/Talks/blob/271dcb5367f5a14e1468191437b8131ce0fefbb0/Incrementally%20Typing%20Angular/src/01-original.js) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dgz3vrk.)^.
Can you share an example? It always goes up the directory tree and stops at the first package.json it finds
ES6 = ES2015, btw. Modern browsers support ES2015 aside from module loading. You'll need a bundler for that. Don't be a pussy. Just keep at it. You'll understand eventually. 
They have a lot of the same core issues as Angular 1. Specifically unsafe templates, unsafe component APIs, runtime dependency injector, dirty checking instead of setters, etc. I like React much better for how it handles the above.
Only React has official Flow bindings, but all of those libraries have TypeScript bindings.
Unfortunately not. Even with Angular 4, templates, component APIs, and DI'd services are still not typesafe.
Oh, just like google scrapped Angular 1 and did a complete non-compatible rewrite? Yeah, react in its current form won't be around too long. FB already did a complete rewrite of React. Lucky this time it's compatible, but that won't last.
In terms of complexity, your proposed data structure gives: - Read specific item in a cell: O(log k) - Read all items in a cell: O(k) - Write 1 item to a cell: O(log k) Where k is the number of items in a cell. That seems pretty efficient to me! One simplification you can make is since in JS objects `{}` are unordered maps where keys are strings, and you don't care about preserving order, you can use objects instead of `Map`s.
Start with ES5, or even ES3. No reason to do everything at once, not to mention a lot of companies don't even use ES6 (yet!).
Pretty much! `function(e) {return that.someMethod(e);}` is the *callback* that you're passing to `addEventListener`, which is an API that the browser provides. The way that API works, if the callback function returns `false`, the browser will not continue bubbling the event.
Hey...thanks a lot!
&gt; Give it a year and it'll be outdated TypeScript is 100% aligned with existing, but scarcely supported, and upcoming ECMAScript features. It won't be obsolete by definition. &gt; ...we'll all have to learn yet another **abstraction** language. &gt; Also, why TypeScript and not CoffeeScript.. it's all just **abstraction** anyway. &gt; Calm seas don't make experienced sailors, nor do **abstraction** layers make experienced developers. Define what "abstraction" means for you because these sentences don't make sense. The core benefits of TypeScript are: - Adding a static type constraint system (which CoffeeScript doesn't). - Being an ideal superset of JavaScript, i.e. JS source is also TS source (which CoffeeScript doens't provide). - Providing access to ECMAScript features which aren't yet supported by browsers (which CoffeeScript doesn't). None of those make sense to be called an "abstraction layer", nor it makes sense to say TypeScript and CoffeeScript are the same. Honest question: how long have you used each of those two languages? 
Ruby.. quick, multithreaded..? Don't get me wrong I love Ruby but it benchmarks much slower than JS and it's not multithreaded with the exception of trying to use something like JRuby.
wrong. you can use typescript with anything. vuejs included. and type safety in js is almost impossible. that language isnt typed. period.
Nice! I'm doing something like this on my own, with the aim of understanding everything I do and it's really neat. 
&gt; It's abstract, you write code that transforms to code you could have just written anyway. The most significant code transformation that TypeScript does to code is remove its own type annotations from the final code. Including all interfaces you write. You write interfaces and type annotations, and it removes them from the final code. Now. You state the value is only in the final code "you could have written anyway". The interfaces &amp; type annotations aren't in the final code. Yet people write them. How do you explain to yourself this apparent contradiction between reality and your opinion?
Thank you. I was considering also a data-structure like: Map&lt;string, Items[]&gt; (e.g. &lt;"row1&amp;col1", [Item1]&gt; &lt;"row1&amp;col2", [Item2, Item3]&gt; &lt;"row2&amp;col1", [Item2]&gt;). Basicalli the key-string rapresent the concatenation of row-key and column-key. 
If you're also like me that like using C# for it's types and features, also IDE's showing usage references - I recommend TypeScript with VSCode plugins for js: http://take.ms/QoslB
&gt; I've been writing JavaScript for 15 years. That's not the question I asked. I asked how long have you been using TypeScript and CoffeeScript. Because your responses are so generic and off the mark, I doubt you've spent even one day learning what TypeScript is about. Yet you feel entitled to speak authoritatively about what its value is and how it compares to CoffeeScript. 
Don't sweat it. You don't know what you're talking about. But please say the word "abstraction" again.
Bla bla bla.
React definitely
Python
It's ridiculous really that this isn't built-in. There isn't one analogous system that doesn't have it, and bugs arise from its absence *constantly*. If I can make a suggestion, `npm install &lt;package&gt;` needs to perform the same logic, it may be worth looking to see if you can delegate to their logic.
appears to be even simple than that: the function call is `check_information` the function name is `check_info`
Yup, and same reason why it integrated into people's existing projects better. I don't have "React projects", I have "projects where some components are React". Works seamlessly. Anything that has the ambition to be your Alpha and Omega and control your entire application, like Angular, has zero chance of being so simple and flexible as React is.
I'm not sure that's fair, because while React is one of the better examples of functional programming, Angular like a poster child of how not to do OOP.
You should save the promise from the initialize call and wait for it in your sendMail function. 
Have you ever actually had a job and made friends there?
[removed]
Exactly. I am aware of this and that's the reason i put up that text in my website. I was defending my decision. Nothing more. (Even if its an overkill I want to use it.) I will consider adding the use case in the upcoming tutorials, However I think people are smart enough to know when to use/not use it.
Thank you! I used the fiddle code and it worked perfectly, any idea how to make it so when i add stroke to the canvas text, the mask image doesn't cover the stroke as well?
Does it still get compiled by the webpack (or friends) with that dynamic path?
TypeScript definitions should just come in via node_modules and standard package.json. You should not have to add any types manually.
because c# developers can finally write some javascript :D
the question is react or angular
Mithril :) https://mithril.js.org/ Read this one page you are ready to go 
Kinda wondered the same thing
Angular isn't a language.
&gt;Nine and a half percent of the developers Stack Overflow surveyed Nine and a half percent of the anonymous, random people who clicked on "take our survey" And then there's this: &gt;It‚Äôs easy to view the success of TypeScript as Microsoft bringing enterprise developers who are already in the Microsoft world to JavaScript via familiar tools.
No. First there is the standard. Then there are things like TypeScript that attempt to build on it. You can't make the house the foundation.
It looks more like a compromise to allow other dev to convert their language to js. If you know js, just write in js, for the moment.
Everybody claims &lt;insert thing here&gt; makes life easier. Yesterday it was jQuery which no one can live without and most redditors will still claim that's true. Today's fad among those who can't program is typescript. Five years from now, typescript will join jQuery in the collection of "&lt;insert thing here&gt; makes my life so much easier" while those who study Javascript and understand programming hum along without missing a beat.
Then why are you "real developers" here in a shitty web development JS subreddit? Don't you have a real programmer job to do somewhere?
This is misplaced fanboyism IMO. I don't see a future where JS is used for everything, but if you are right, I won't mind since I am fluent in it a long with many other language. It would be unfortunate since it is the worst language I know. With that said, leaning a new language is easy enough that it is not worth arguing over..
They can of course go through the entire process just like Dart did (ECMA-408). Anyhow, types were part of the ES4 draft. There are now also a bunch of somewhat popular languages with optional types. I guess type annotations will one day make its way into ES, but it will probably take a couple of years.
After registering with it you don't have to manually run Vue instance. It's using power of WebComponents Custom Elements so it will magically work on any HTML you provide. You can even create microservice like architecture where different parts of your app are independent and communicate using vue-custom-element's API or Vuex store. 
My biggest concern is that typescript will impede javascript, as tc39 may be forced into an uncomfortable spot where they can't or have a hard time implementing features due to typescript incompatibility.
What the functor? I have never read that word, ever, anywhere. It's mathematics, apparently. I understood nothing of this article. I feel dumb now.
&gt; Everybody claims &lt;insert thing here&gt; makes life easier. Yesterday it was jQuery jQuery took care of browser normalization. In the past, you needed a lot of code to make even the most basic things work in all browsers. It was also easy to produce memory leaks in IE. jQuery did indeed make your life a lot easier.
As I so said. Now they say the same of TypeScript and this, too, will fall from favor.
Gonna have to stop you there, we don't talk about compilers here this is a *scripting* subreddit not *programming*. I only code in assembly.
I hope it was ironic :)
Do you not use Jest for testing? My team has been using that for a while now, and the support for Typescript has been great. 
We all do of course hope that JS will add optional types, non-nullable types, enums, etc in the future and that TS will lose its reason to exist. That would be great. It would be the perfect outcome. For the time being, to-JS languages and Babel can be used to experiment with new language features. Being able gather real-world feedback like this is a unique advantage of JS. The people who are involved in the standardization process can make informed decisions based on real-world usage and community feedback.
Typescript is a stand alone compiler not a language server like flow. If the typescript parser inside of vscode is crashing for you then that's a vscode thing not typescript. Also mine doesn't crash in vscode so I can't say for sure but I'd guess a plugin could be at fault for the crashes.
I seriously doubt you "only code in assembly", because in 2017 most high-performance systems programming is done in C and C++, with just little islands of assembler code for very specific parts of very specific subroutines. And even assembly is compiled, after all, even if the compiler is relatively trivial. And even more... the resulting x86 (for example) machine code isn't even what runs on your x86 CPU. It's JIT transformed to an internal RISC instruction set, which is what really runs on your CPU. So transformation of code &amp; data is an *inherent part of computing*, from high-level scripts, down to low-level hardware. Saying "there's a transform involved" doesn't really change anything about TypeScript. The important part is **what** transforms are done, and **why** are they done. And the reasons they're done for TypeScript (forward EcmaScript compatibility, static types with autocomplete/error-checking/refactoring IDE front-end) are fundamentally different than for CoffeeScript (a shorter, more opinionated syntax). Web programming has become full-blown programming. Google has a full Office suite running in a browser. Apple's iCloud apps have a browser version which rivals their desktop/mobile apps. And Microsoft has a working version of Microsoft Office also running in a browser (some some, but not many, limitations). All of this requires some very robust, very real software tool chains, to keep clarity and bugs under control in codebases of such big size and complexity. And so we have projects like TypeScript and Flow that do it. And the only thing that could "kill" TypeScript at this point is something that's vastly better than it. But no such thing is on the horizon, while TypeScript is getting better every month. There's a huge support behind it... So try it out. If you don't like it, fine. But at least you'll have some *real reasons* to dislike it.
You're declaring the 'app' variable twice, and in the process initializing the angular app twice. Remove that second "var app =..." line. Edit: you'll also need to rename one of your controllers, or just put both the doctor and patient information in the same controller. 
Me IRL https://imgur.com/a/SkyPY You IRL https://imgur.com/a/UWmYD 
no, I've been using ava, which is working toward support but it's taking a while
For a simple case like this there's no reason to have them in separate controllers. When you're working on larger, more complicated projects it will depend what kind of architecture you're using, there are pros and cons to having large, multipurpose controllers or splitting things up into different files. 
So are you saying I shouldn't use Vue instead of React? (jk)
I wish someone would spend the time on fixing the major issues in es5, and creating a compiler for that; remove the issues in es5, no additional syntax features, just es5 as you know it. The kind of fixes I'm thinking of; doing arithmetic with NaN should throw an error, the `==` operator is replaced with `===`, `===` itself is removed. Get rid of null in favor of undefined everywhere. I think if you get rid of all of JS's major faults, and reduce the surface area slightly in the process, both experienced and less experienced devs will have a far better time.
For me the strong typing is useful, but I don't run into issues it would solve that often. It's good peace of mind. But the bigger thing for me is pairing TS with VS Code and getting the code completion features. I don't have to go hunting around in another JS file to check what keys exist in an object, or what argument order I should use for a function. Couple that with the definition files for browser/Node APIs and suddenly I'm spending far less time checking MDN etc. for answers. For me, the cost to implement TS is near zero - I was already transpiling ES6 with Babel so switching was very simple - so it's a no brainer.
While saying "convert" might not be an exact / very professional way of saying it, in the end it's writing javascript, no ? 
Lisp is alright but I'm more of a fan of the ML style functional languages, like OCaml. I'm old enough now to have developed professionally in almost a dozen languages including Ada, C#, and even a fair bit of Obj-C. I can safely say at this point that multi-paradigm languages that lean functional are far superior to imperative languages.
I would use React because it has a larger ecosystem. Less libraries you need to reinvent. Oops, my pointless preference without any source ...
"vscode is a damn fine editor" r/programming would like to kindly burn you at the stake. I love VSCode, but God do the elitists in that subreddit love to shit on front end devs and all their technologies. 
Why no love for purescript? (Only mostly trolling)
This will never happen because of the need to ensure backwards compatibility, sadly.
&gt; Typescript is a stand alone compiler not a language server like flow. Typescript has a language server ([source](http://langserver.org)); it's what VSCode uses to provide all the editing features for Typescript. The final tool used to output javascript is a standalone compiler.
Have you managed to use their coverage threshold checker to fail tests when (TypeScript) coverage is not met? That's an area in which it showed some rough edges for me...
Wow! An 88 keys piano (with keyboard and mouse support) built with Phasor.js. 
I'm an Emacs die-hard and I open vscode for some tasks -- it really is a good editor.
They've been through some of that already with people using stage 0 features through Babel that had to change syntax afterwards. Luckily enough, though, they _can_ simply change stuff in an incompatible way, as nothing will break for the user. It's only the developer that will have to change something (and in this case, probably almost nothing), and only if they want to update their site (i.e. they still maintain it). That won't be enough reason for TC39 not to break compatibility with TS if there's substantial benefit to it.
Quick, as in it won't take me long to build. 
I usually like to do that as well, because arguing about the pros and cons helps me learn about them :) (Just a fun fact, not that relevant otherwise.)
I'm not sure it's ironic. You spend more time in the article explaining what's **not** a functor, than what it is. And some of this is plain wrong. Arrays with map() are an example of a functor, of course. When you say "it's not a container" the explanation is because the items may have an order etc. Since when is that mutually exclusive with the idea of a "container"? I kind of drifted away after that, because it felt like you're just not happy with words and their meanings in general.
Most Vue fanbois say they learned it in an afternoon. If this is the case, I don't why one doesn't just learn both. :-/
Also forgot to mention my #1 reason! It combines the best of he functional and strongly-typed object oriented worlds. It's really, really neat.
C++ is not a superset of C. There are constructs that is valid C that isn't valid C++. 
You are mistaken. Read this: https://github.com/ryanatkn/react-typescript-closing-the-loop Or scroll down to the last gif which demonstrates the problem.
Having built an app with Polymer no thanks... Web Components kind of sound nice on paper but are a horrible development experience. I build JS applications and I want HTML to be an implementation detail.
People write all kinds of things on the internet. I worked with angular, react, polymer and I wouldn't say any of those can be learned properly in an afternoon (like a reasonable understanding of library). Creating trivial components is usually not enough to master a solution IMO. 
did you know that chromium uses ram, and is therefore bad
Typescript is a language which compiles to javascript. It does not transform other languages to javascript.
We have no idea what you are talking about. You need to define terms before you use them. 
I am still not sure if it is an 88 keys piano (with keyboard and mouse support) built with Phasor.js. 
So does `catch()`. Its literally the same thing, just a different syntax. getTextPromise() .then(text =&gt; JSON.parse(text)) .catch(err =&gt; { // catches async getTextPromise error // or sync JSON.parse error });
JS is my fourth favorite language, after C++, C#, Java (in that order), but ahead of garbage like Ruby, Go, PHP etc.
I hear when you load a slack channel that has a video loaded, it uses GBs! GBs!
Jeez, you better get on that stat, before it turns into an international crisis.
&gt; Reddit comments usually only offer opinions and, often times, source-lacking misinformation on the subject If you extrapolated this logic and really cracked down across the board on this sub, it would turn into just news about the community. The same way you can research around to know the right type of framework is the same thing you could do for figuring out how to approach a specific javascript problem. Then you could go "well we shouldn't have the same questions asking about es6, that can all be answered with a good es6 source, so let's ban those questions". The reality is, is that opinions on frameworks differ from day to day, and todomvc isn't really an accurate gauge of a framework as you don't REALLY start to understand the positives and benefits of a framework until you really start to use it extensively, and for those situations it's usually much better to get an ENGLISH explanation from someone who has used it. The framework questions honestly should stay. They are a huge part of javascript development now given the complexity of applications, the demand for frameworks. Just let people vote what they want to see to the top, and vote what you don't like down.
&gt; I think people are smart enough to know when to use/not use it. Beginners aren't. You don't want to mislead people looking to make their first portfolio site into thinking React gives them some sort of advantage or that's how they "should" do it. 
Couldn't agree more
Why I'm not moving on to Web Components and looking forward: Because web components solve *none* of the challenges of serious scale front-end development. For a toy todo app or a garbage admin dashboard it may fare well, but for front-ends that are seriously complex and large, wc's don't bring much to the table. Think GMail with an integrated shared calendar, group chat, CRM, inventory + user management, analytics and batch / scheduling features, with full fledged accessibility requirements (WCAG AAA), first class screen reader support, zero fidelity mismatch with IE10+, and a release schedule designed to "kill competition" - This is the actual thing I work on everyday (186 screens and counting), with a team that went from 42 folks (SE's + SDETs) to ~70 recently, and I can tell you with confidence that beyond trivial applications, Web Components won't do jack shit for anyone working on non-trivial stuff. As an improvement over a jQuery hell? Sure. But as a replacement for frameworks like Angular 2 / Ember / Vue + Ecosystem / React + Ecosystem, which were designed from the ground up to control the madness I described? Not a chance. I know this is going to get downvoted to oblivion because I bring a very different perspective here ("non-trivial scale", which I have to repeat every now and then, and which has come to shape my outlook over some 15 years), but for me and for what I work with, it's also the truth. 
I did a little digging into the source code and here's what I found: * Keys: 88 * Built with: Phasor.js * Keyboard support: true * Mouse support: true
React.
It kinda does give them an advantage, If they know how to build a website using react, They know how to build an App using react. Anyways I think adding a use case will be good.
Good catch- I didn't see that on first glance. Would imagine that is certainly the issue.
As a contributor: it's pretty far from being usable since many normal rules expect a ES6 tree. E.g. no-undef and no-unused-var don't know at all that ‚Äúdeclare namespace foo‚Äù is a definition and use in certain type contexts is legitimate use. There's even more complex stuff: if you just import interfaces, a dev dependency is of course enough (the import will vanish in the compiled ES code). It will be pretty hard to teach the no-extraneous-dependencies rule that
I'm a pretty big fan of Clojure. You can compile it to JS too. 
you know what's even worse?! they made an electron terminal for people who care more about user experience and ease of extensibility than having a super lightweight experience!! i'm literAlly shaking in anger!!!?
Nope only on those not using InteliJ
&gt; Dynamic typing is mind-blowing for any college grad that was taught in Java or C# OOP. "Dynamic typing" isn't a thing. A language is either statically type checked or it is not. The best you could say is that "dynamic typed" languages are [a subset of static typed languages](https://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/), just like how JS is a subset of TS. &gt; Once you realize that, you can't go back to OOP and definitely not TS. OOP and type checking are orthogonal concerns. Haskell isn't OOP, but it is statically typed, for instance. JS is the opposite (OOP but not statically typed).
&gt;you can't just write typescript and run it in the browser straight. So you're still better off writing js directly. Why? By that logic, we should all be writing nothing but assembly?
What would the read/write complexity be for that data structure?
Does this work with Selenium?
Interesting but there is still some way to go - binaries for a simple _ls_ clone are 27MB...
&gt; I know this is going to get downvoted to oblivion Shows what you know... /jk ;)
Yes via web driver. 
It was mostly because of your quote: &gt; Because web components solve none of the challenges of serious scale front-end development I had a feeling that you and the author were missing the point (while arguing differently), that's why I stated it.
I half agree, and that's why I endeavoured to create a more functional Web Components library called [Switzerland](https://github.com/Wildhoney/Switzerland). I've also tried to add in Universal support to allow server-side rendering, which is almost there, but still needs additional work.
I wrote this library. I'd be interested in knowing if anyone has any quick feedback for improvements?
Heh, now this is not a useless post ;) thanks for the comparison
&gt; This is sure not going forward either. [Specifications](https://developer.mozilla.org/en-US/docs/Web/Web_Components#Specifications) &gt;chained to the browser again as the only ever target and the dom as the central implementation interface. How do you do anything now without the browser or the DOM? &gt;All the hand waving for standards isn't gonna do it this time I haven't heard that line since Firefox came out in the early '00s and then Chrome. 
Interesting approach! I will look into your solution. At this point I would see Web Components more as a truly reusable* components which can be used in react apps. One thing missing from the react though is properly passing variables to Custom Elements by props instead of attributes, but this is likely to be changed soon.
No game dev but I have done desktop application development, CLI tools, web dev, and some other random stuff in C#.
I pretty much agree with this... it's coffeescript all over again. It brings some new features, but it's also another technology in your stack you have to maintain and hire/train for. 
More to the point we love to shit on your technologies leaking out of the front end to places where better options exist -- like, I'm on OS X that has these amazing dev tools and frameworks optimized for it but here let's build an editor that takes 1gb of ram to open a file and does layout with CSS, I mean Christ, you deserve all of it and more.
Take a look at its README, it says that's not possible. Unless I'm missing your point? &gt; ... by design, installed modules (i.e. modules under the node_modules directory) will not be able to require application-level modules ...
&gt; Generated code now needs a ‚Äúsource map‚Äù file along with it, so that when errors occur at runtime, the actual user code causing them can be pinpointed. What? Should've stopped reading right here. Besides what's being said, what's the deal with the quotation marks? &gt; There were no pre-processors. Class syntax, promises, lamdba functions, CSS variables ‚Äî it was all just there. Oh, so you're not supporting IE. That's not an option for the most of us. I'll just stick to vue &amp; react for now
No that's literally the opposite of what he's saying. He's saying VSCode(in your analogy, Chrome) works great but the typescript server(in your analogy, the extension) keeps crashing.
lol at the js people who think it's a good idea to infect the backend and desktop apps with their crap calling anyone else 'unidimensional' 
Take your argument and `s/Javascript/Assembly` and read it back to yourself. Your entire argument is centered around "don't add features to the language, just use it as-is because there's a robust ecosystem around the existing one". Think about where we would be if people actually followed that advice.
It depends what your goals are really. But if you have any interest in web at all, then yes learn it. And even then JS has more application than just web.
Hello person from 2015 and welcome to 2017. Nowadays, we do not care about yet another flux implementation, we got enough already.
Some background: My partner and I are working on a new business and are using firebase. We have a few collections that are becoming absolutely massive, and we both got fed up with trying to CTRL-F through the firebase console to find/debug an entry. I couldn't find any suitable workstation tools that exactly fit my need, so we built this. This is like 2 days old, so a lot features aren't supported yet, it's mostly just basic select statements at the moment. Forthcoming: * Service accounts (for now, your database rules need to be set to read:true) * Nested selects / joins * Updates * Date comparisons We will be working on that^ stuff when we have time, but just the ability to do select * from users where email = "jimbob@gmail.com" has been ridiculously helpful.
Thank you :)
Sorry, what startup do you work at again? Lmaoooo
It's pretty clear from context that the tools immediately surrounding Typescript can be considered as "part of Typescript". Thus why OP mentioned VScode, tslint, and testing libs in addition to the language server. By your logic, even the compiler is not part of Typescript.
Eh? I feel like you're trying to make a point but I can't figure out what it is.
All the things mentioned here are correct: the function is defined in the wrong place no id is accepted into the $() function but even had the code been correct this would not have worked in jsfiddle as the problem is related to the way the JS is injected into the page by jsfiddle. The options in the javascript section need to be changed for "Load Type" from "onLoad" to one of the noWrap options. http://stackoverflow.com/questions/30692921/why-does-jsfiddle-throw-error-that-function-is-not-defined I would also recommend not ignoring the red highlights in the html section, they are indicating errors, such as no need for a closing tag on input tags.
I've worked with both and React wins hands down. When I write angular code I feel like I have to take a shower afterwards because I get this dirty feeling that what I'm doing just isn't right. So many ugly hacks and overcomplicated concepts.
Netflix uses it for internal tools. They sponsored ember conf this year.
I feel the same way about typescript 
&gt; I've literally never had a problem looking at a method signature to figure out what parameters do. I simple don't believe that you've only worked with codebases where every function parameter was so well named that you knew exactly what type it expected to receive and what it would return. Even if you know, your tools don't, which is why they have been garbage for so long. &gt; lol as far as dispatch on arity I used to think this was a big shortcoming! omg, I have to use a different function name if I want to pass in different params!!!!! First you need to learn what arity is I guess you seem to have it confused with method overloading.
Ah, the memories...
The point is to use types to help humans and their tools reason about the code. After you remove the types it pretty much looks just like javascript even before you compile it.
&gt; Also, please don't use this remark, because you are trying to justify your stance by making your opinion look "controversial" when it is not. It's never a merely "controversial" remark that gets upvoted / downvoted at Reddit (this sub included), that's not the site's character. If anything, I've seen lots of rather controversial content get upvoted / downvoted for other reasons (and deservingly so, under their respective contexts). Second, I wasn't trying to make my opinion look "controversial", and it's not, it's the opinion of many. The reason I mentioned that was because there is a populist trend in this sub which has always been strong: new and shiny = good, and any opinion against that DOES get downvoted from time to time. I'm actually surprised here since I genuinely did expect my original post to collapse quickly, with angry replies on how awesome web components are. Lastly, don't try to gauge others' motives too much or offer unsolicited advice like that pesky uncle at a family reunion: it's an interwebz forum, and you're not going to win even half a potato as a prize (and neither will I). Stick to the relevant stuff, and get off the high horse if you're riding one.
Maybe, I don't know, you're not thinking about this _Object Orientation_ in the correct manner. You ask... &gt; say you have a Class that represents a DOM object (or set of them, like a tic-tac-toe board in this instance), and you have different methods for how it changes/logic/etc...) where exactly should you put Event Handlers for that DOM object. And asking this, you're focusing on the question, on "where should I put event handlers?", but maybe it would be much more interesting to focus on the other part of that paragraph. &gt; say you have a Class that represents a DOM object (or set of them, like a tic-tac-toe board in this instance), and you have different methods for how it changes/logic/etc...) Or even better still... &gt; say you have a Class that represents a DOM object (or set of them, like a tic-tac-toe board in this instance) There. Let's focus on that. You've created a `Board` class. What's the _intent_ of this class? What should it represent? You mention that it represents "a DOM object" or a "set of them" and looking at the current code you have, it does look like that is -mostly- what that class... represents. Well, not exactly "represent". To be fair it looks more like it _wraps_... or better, it _manages_ access and manipulation of a set of `&lt;div&gt;` elements. But ignore this detail for now and let's go back to the question: What _should_ it represent? And here comes the interesting bit. When designing your code, you get to the point of thinking about _a Board class_ and what you should think is not that it represents "a DOM object" or "a set of DOM objects", you should think it represents... well, _the board_. The board itself. The _concept_ of the board, what it is, what it does, how it works... But not how you see it on the screen, no. What "_a_ tic-tac-toe board" is. You can have a tic-tac-toe board be a painted piece of metal to which magnet pieces attach. Or you may have a tic-tac-toe board as a _drawing_ on a piece of paper. Or a set of boxes with two differently coloured lightbulbs. Or many other variations. Maybe even a set of `&lt;div&gt;` elements on a web page ;) But _defines_ a tic-tac-toe board? Is it whether it's a metal plank with magnet pieces or a piece of wood with holes and wooden pegs? No, clearly that does not define the board. And that, that _concept of the board_ is what you're looking for, what you really want to represent as a `Board` class (or maybe not a class, but as that is your intention we'll go with a class). So, a `Board` class should represent or _model_ the **concept** of the board, its entities, its rules... but in an abstract way: Separated from _what it looks like_. You could think... Well, a _tic-tac-toe board_ has nine _cells_. And, uh, you've just discovered that there's a smaller entity, the _cell_, which may or may not make sense modelling too. Note that there are valid solutions both opting to model the concept of _cell_ and opting _not_ to model it. But for the sake of going on with this idea of how to model an OO design, we'll go with the `Cell`. A _cell_ is just one position which may be _empty_, _X_, or _O_. Now we have `Board` and `Cell` and we could make some initial sketch (note also that I'm going to try to keep it simple to focus on the general design; there are many details -like using strings for a _cell_'s content, or calling a _cell_'s situation `status`, or throwing errors, or many other details that I'd probably do in a different manner but which simply don't add anything interesting from a general design perspective)... class Cell { constructor() { this.status = ''; } play(move) { if (!this.isEmpty()) throw new Error("Can't play on this position. It's already taken"); if (move !== 'X' &amp;&amp; move !== 'O') throw new Error("Invalid move"); this.status = move; } isEmpty() { return this.status === ''; } // ... } class Board { constructor() { this.cells = []; for (let i=0;i&lt;3;i++) { this.cells[i] = []; for (let j=0;j&lt;3;i++) { this.cells[i][j] = new Cell(); } } this.turn = 'X'; // Say 'X' always goes first, whatever } play(x,y) { this.cells[x][y].play(this.turn); if (this.turn === 'X') this.turn = 'O'; else this.turn = 'X'; } // ... } See that? There's one thing I want you to notice there. All that that sketch of code is modelling is _concepts_, _rules_, what the board (and cell) is, what it can do, the rules it obeys. There's nothing there about actually _seeing_ the board or interacting with it. But you _could_ actually play with that. As long as it is modelling the rules and behaviour of "a tic-tac-toe board" it _works_. You could e.g. play with it from the console, actually writing `board.play(1,2);` and then inspecting `board.cells` or whatever. What's the important thing here? There are two things that are important: 1. When modelling an OO design you should model _entities_ or concepts of the system you're designing, not entities of the final result your building. That is, you don't model a `Board` to represent a bunch of `&lt;div&gt;`s, you model a `Board` to represent the board itself. 2. By doing this, you'll achieve an important goal: separating concerns (separating the workings of the tic-tac-toe from its visual representation). You don't want "random functions all over the place" but you also don't want all those same functions thrown into an object/class. What you actually want, whether you use OO or not, is to not have things all over the place and not have everything tightly tied together. What you want is for each part (be is a function, an object, a class or whatever) to both _only concern itself_ with one thing and to _be the only one_ that concerns itself with that thing. Oh, well, this is getting really long and boring. I better leave it here so as not to bore anyone to death xD Ah, but feel free to ask more questions if you have them (yes, I haven't exactly answered your question of where to put those event handlers... right?)
Read this first otherwise there's no sense in going on: https://github.com/extensibleweb/manifesto This was made because of the webs state, where it was and is plainly evident that it can't compete with native solutions and that it takes way to long to even attempt it. **The problem wasn't just that we had no standards**, the problem was also that standards were often short sighted, made by committees disconnected from the real world, trying to guess what will happen 10 years later once their spec is out. And in many cases such specs effectively *inhibited progress*. So a new proposal was laid out on which our modern web rests. The extensible web isn't controlled by a single committee any longer, it grows with consent from all sides, users, developers, vendors and those that draft specifications. Vendors now focus on the *low level*, they should not meddle with how we make apps or interfere with it. Specs have a faster turnaround and can be discarded if they do not perform, and lots of them have been over the last few years. Googles spec breaks these premises and pushes the web back into imperative dark ages. Arguments for that have been made enough by many influential developers, teams and companies. 
http://imgur.com/a/3z0iQ
I know your work, and it's really quite impressive! Also a big fan of standalone. I think web components are inherently flawed as they are, but your interfaces are the closest to acceptable i've seen, we use it for legacy apps or embedding controls. 
&gt;I've already learnt HTML and CSS please learn JS for your own good
I can turn react components into custom elements to using https://x-tag.github.io/ but at that point whats the purpose? imo this makes sense if you're trying to distribute "widgets" but if you're building apps it's an unnecessary layer
Noob here. Can anyone explain to me what exactly a headless browser is/does? Any help or resources would be much appreciated.
CerebralJS is a cool project.. I think this article is giving Cerebral a bad wrap.
Yep, it was impossible to pull me away from Sublime Text for years until I kept hearing about VS Code and seeing more and more experienced developers talking about it. Now that i've made the switch, it's impossible to go back. Sure, maybe it's takes up some more RAM than other editors, but it's not like I have 20 programs and 100 tabs open at at the same time when i'm working. Also, I'll gladly take a hit to RAM for a much more enjoyable and seamless development environment.
Here you go links to the issues: https://github.com/facebook/react/issues/7249 https://github.com/facebook/react/pull/8755 Cheers!
From my experiences, you would never have the javascript in the front end directly updating the database. You would write a web API for a backend. the backend would update the database and handle security.
&gt; Everyone knows That means I do too. &gt; anything negative about polymer/webcomponents gets upvoted so infact he does know nothing So I'd have to know that too, to manipulate the opinion here, wouldn't I? So I'd know something and not nothing?. All I can say is, the rabbit hole runs deep, and: @disabledlocalization knows nothing. (GoT reference). ;)
Using these rules i'm not able to get my SASS styles working at all. I am just getting a 404 on the compiled CSS that i am expecting.
&gt; where exactly should you put Event Handlers for that DOM object. I would take a little look into [MVC](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller) and see if that clears anything up.
Elm. If that one doesn't count, then Elixir. If you're trying to "branch out", I suggest you don't go for the C-like (C, C++, C#, Java, JavaScript, Python to some degree, etc.) languages. The only case I would suggest learning one of those languages is if you aren't familiar with object-oriented programming, in which case Java or C# would probably be the simplest, given how much resources you'll find. If you already have some familiarity with OOP, all you have to learn is the new syntax and that's it, now you know a new programming language. Before anyone jumps that there is a lot to learn about the language's ecosystem such as libraries, frameworks, best practices and so on, that's, of course, true, but not really necessary to just see another language. On the other hand, functional languages will force you to think differently compared to how you do things in any of the aforementioned languages. JavaScript can be a gateway to functional languages as it allows you to write functional-like code, but it's still not the same, you can still abuse it. If you look around, functional languages seem to be the next cool thing so it wouldn't hurt to at least know what's going on. Now, to explain my choices of favorite languages. First of all, I would like to point out that before delving into the wonderful land of functional languages, I was mostly using JavaScript and, like yourself, convinced that it's a fun language, except a few weird parts here and there. But I also had some familiarity with C, C#, Java, Python and Ruby. Elm is a functional language that is meant for developing web user interfaces and compiles to JS. This got my attention as it's something that aims to replace whole client-side JS and it seems like a bold claim. It's not a general-purpose language, although there were attempts to make it run on "server", but nothing official. It's quite simple to learn, it's DOM syntax is inspired by virtual-dom and its state management is what inspired Redux, if you're at all familiar with those two libraries. Also, it's compiler is something you probably never experienced before, it actually tries to be helpful instead of spitting out some weird errors. Also, its type system will make sure that all errors will be caught at compile-time and boasts with no errors at run-time. Keep in mind that it's just run-time errors, bugs in run-time are still a possibility. But maybe one day... My other choice, Elixir, is functional language that runs on Erlang's VM, the thing that powers, among others, Whatsapp's and League of Legends' servers. Erlang is a very old as far as languages go (31 years in 2017 IIRC) and Elixir is the new shiny thing built on top. Elixir was originally intended to be Ruby-like with simpler concurrency, but the author gave up on trying to build an OO language on top of functional VM and started to design Elixir as a functional language. At a first glance, it might look a bit similar to Ruby, but it's not very similar to it, although there is a framework, [Phoenix](http://www.phoenixframework.org/), that was inspired by the simplicity and power of Ruby on Rails. Elixir mainly used for developing backends to web applications and it's concurrency model enables the developer to create very performant and fault-tolerant systems. I encourage you to try Elixir if you want to move away from primarily front-end languages to server-side languages. There are of course other interesting functional languages, I'm still trying to find some time to learn Haskell. But as of now, these two are my favorite and seem very promising for the future of web development. Edit: downvoter, care to explain? 
And where did you see it being referred to as such? 
Have you tried something like this? const isDark = function(element) { function rgbaAverage(value) { const rgba = value.split(/\D+/) let sum = 0 let count = 3 while (count--) sum += 0^numbers[count] return sum / 3 } return function(color) { element.style.color = color return rgbaAverage(getComputedStyle(element).color) &gt;= 128 } }(document.createElement('x')) Might have a few mistakes, wrote this on mobile. 
Yep, WC are now about Custom Elements and Shadom DOM mostly. It seems like WCs will be imported by js and such solution looks the most sensible. As for the html templates, I think their use without any tool is quite troublesome but I would not underestimate them. PS. Nice try with ReactShadow. I haven't seen this before. Unfortunately unless we have got full browser support for shadowing CSS this can be hard to use.
Sorry i meant scss. It works when I do it in production, but when i am going through webpack dev server no CSS file is generated.
The example in the post is quite ridiculous. It would make more sense for some business tool or service that is not that simple but that you would like to distribute as a single executable for whatever reason. The overhead of the vm and standard library etc will always be there to some extent as the actual code is not natively executed. 
Uh, you can use the TypeScript-powered intellisense with JavaScript projects. https://code.visualstudio.com/docs/languages/javascript
Ha, okay. I hadn't noticed that. I probably would have if I had tried actually testing the code. :P
¬Ø\\\_(„ÉÑ)_/¬Ø I guess that's why everyone can run the test on their own. The temporary variable is (arguably) the most practical.
I would argue that using tagged template literals qualifies as string magic.
Do you have the browser console open? I'm thinking that maybe you forgot to load jQuery on 1 of the pages? But honestly this seems like a really bad way to approach this problem. window.load is not fired until all images / scripts / iframes have completely loaded. So if I'm on mobile, I have to sit and wait for all of the desktop sized images to load and once they finally finish I'm going to be redirected and start waiting again. I don't remember using this before but google said it so it must be true, do this without any function wrapping it &lt;script&gt; if (screen.width &lt;= 800) { window.location = "http://m.domain.com"; } &lt;/script&gt;
Any reason you have it attached to that event? I'd just do $(window).width() without document ready (window width is already set) 
 learn@more-son:~$ nodejs &gt; function foo(x) { return x; } undefined &gt; foo(4) 4 &gt; foo() undefined learn@more-son:~$ racket Welcome to Racket v6.3. &gt; (define (foo x) x) &gt; (foo 4) 4 &gt; (foo) foo: arity mismatch; the expected number of arguments does not match the given number expected: 1 given: 0 context...: /usr/share/racket/collects/racket/private/misc.rkt:87:7
No, the compiler isn't irrelevant when talking about a language because without one all you have is a bunch of random text inside a file that does nothing. A language is useless without a way to transform it into machine instructions; whatever form that is. I also think the arguments about testing are equally inapplicable because the tests have to run so of course the tests are in Javascript or are written in ts and themselves transpired to js. A testing framework can't test code that isn't executed. And linters as a whole are just a patchwork for trying to fix the inherent deficiencies in languages like js. A lot of the things they do are completely unnecessary with a proper type system in the first place. Once you have one a linter is mostly just a glorified code formatter.
&gt;The extensible web isn't controlled by a single committee any longer, it grows with consent from all sides, users, developers, vendors and those that draft specifications. So, iow, like the W3C and WHATWG? What's funny is, those two groups, especially the former, are computer scientists who know far more about how the web works cause they created the web. They are the vendors who write and consent to the current and past standards yet you think some collection of the same people into a different group is somehow better. You also state vendors should not meddle with how apps are made but that's a separate issue that has nothing to do with web standards. You talk of a "Google spec" but I am not aware of any such specification for web browsers other than things like Material but Material is not a web standard that anyone needs to follow or will fail because they don't follow it. That's a choice you make on your own and, in fact, my company doesn't. Your whole post just doesn't make sense. 
What's the motivation behind this? Is there/Are there plans for offline support? Something that was missing from the app at one point at least.
Oh, those were referencing: Interface Builder, Core* (eg. Data, Audio, etc.) Instruments.app, Swift and its libraries, etc.
100%. Example was meant to be over simplistic, just to demo how cool the tool is and how easily it allows to generate binaries from Node...
You can take screenshot ? You can render to pdf or something but you can't take screen shot ?
If you can't figure that out, I'm not going to help you.
Well, thanks for keeping the troll quota up.
I never use raw JS anymore - every new project starts with TS. It's easy to get set up (I copy + paste tsconfig.json and tslint.json from a previous project, but you coould use a Yeoman generator). Typings almost always work out of the box, except for small/unpopular libs which I usually start by typing as `any`s, and fill in types later. Type inference became good in version 2.0 (see [release notes](https://github.com/Microsoft/TypeScript/wiki/What%27s-new-in-TypeScript#control-flow-based-type-analysis)), and is very usable.
http://jsbin.com/wugeverova/edit?js,console,output Might need something more robust depending on the content.
That's what I ended up doing but I dislike having orphan statements like that in my project. I dislike having to manually add references to certain definitions files, but this is more junk in that file as well. Even if the compiler is smarter about finding definitions files, I'll still need links like this somewhere. It's more manual config that's hard to maintain.
The term "headless" is from a server without a monitor being called "headless" so when a browser doesn't use a screen (render) it gets called that. 
I'm now toying with React, is it better to have Typescript in React apps? Or is more oriented to Angular 2? I saw in the article they saying that they are focusing on support to more frameworks but that was not fully clear to me. And how is it better than the traditional ES6 + JSX + Redux?
What is special about notepad++'s text search?
First, typescript is opt-in. You can turn off strict checking and use "any" everywhere and it will be just as efficient as writing plain javascript. Secondly, your 99% is a lot different from other peoples. The use case for compile time type checking is much more common than you think.
a **laundry list** of things: but for context, [here's a screengrab from a wiki](http://mojeprogramy.com/notepad/pliki/images/screenshots/fif_result.png) The most major functionality I miss is that window: * it's selectable: you can copypaste from your search without leaving the line your working on * it's collapsable by file (see the green text, know which file it's not in? you can hide ALL of the results from that file easily, and they're always in tab (left to right) order decending. Sounds minor, but that kind of consistancy is really helpful, imo. * search history: [it will also list all pervious searches](https://cdn-business.discourse.org/uploads/github_atom/original/3X/6/9/693e223e0e050d393145e05689c41aca4a97f68d.png) as a collapsable list (one level higher than by file type). * includes a line number (basic right? but no one else does that) * Find/replace history: the drop down on find/replace/filter input has about 20 past searches stored. *unbelievably useful* I miss it so much. * "replace in selection" rather than "replace all" or replacing one incrementally -I miss this feature *the most*. * They also use a pseudo-regex called "extended" that's really helpful if you know it and don't want to bother with a perfect regex match. (great when using "replace") * you can step through search results in reverse! (this one really should be more universal) * extend search to files *not* open in the editor that, in addition to all the pretty standard search options editors have. The amount of functionality in that search window is staggering, and it's *very* densely packed, which I like a lot. I'd love to see a window like that in VS Code: the search window pane as a vertical column is a strong aesthetic choice but just idiotically impractical for everyday use. I also don't understand why ctrl+F is a separate search from the more useful search you only get press ctrl+shift+f or clicking the search icon. Like, why are their two versions??
[Authentication](https://firebase.google.com/docs/auth/) then [database rules](https://firebase.google.com/docs/database/security/) (see the secure data section). In addition, you can set up a [rate limiter](http://stackoverflow.com/questions/24830079/firebase-rate-limiting-in-security-rules).
I saw the changes for TypeScript 2, but never really tried it. Generators and boilerplates usually don't appeal to me, there's a lot of overhead and "magic" going on. I prefer, as you've mentioned, copying my own config. I did the thing with using `any` type too, but it didn't seem right and it wasn't really helpful over using plain JS. These days, I'm using Elm instead of TypeScript. It delivers true type safety. As in, everything has to be typed and is type-checked at the compile-time plus the language is designed in a way to catch any type errors in the compiler, resulting in no run-time errors. It also packs something similar to what you would get with React + Redux. I think it's refreshing to work on something that is designed for developing web user interfaces and is not just an incremental improvement upon JavaScript but built from the ground-up with one goal and doing it well. But I have to admit that I haven't got the chance to use it on a larger project, not even on a more complex personal project, so I can't comment on how well it goes there. TypeScript still definitely takes the cake when it comes to maturity.
Well that sucks. Exactly what I had planned to do with this. Guess I will stick to Selenium opening Chrome.
Article linked from Twitter post: https://blog.hospodarets.com/native-ecmascript-modules-the-first-overview#browsers-support
The problem with the `if( !response ) return;` is if response returns false on purpose then return will be called even though there's no error... try/catch stops execution: `try { const value = await asyncFunction() } catch (err) { return next(err) } //nothing executes here...`
I think it's beyond the scope of a compiler; it's a pretty complex task in itself. AFAIK Babel doesn't do bundling at all, leaving it up to browserify, webpack, rollup, etc.
&gt; ESM implementation is in all major browsers I envy you who don't need to support IE 11 or apparently anything beyond n - 1 versions of browsers.
Again, context. OP was recounting things he did/didn't like about working with Typescript and included some things that were in the ecosystem. Nobody brought up anything about what is or isn't officially Typescript except yourself.
As said, I can't comment as I haven't reached a point where I would need to use a library. But for most of the stuff, it's already in the standard library. For example, a lot of what you would want to use lodash/underscore for is already included. Also, you don't need something like jQuery, for the same reason you don't need jQuery with React or similar libraries. Same for http requests, managing state (e.g. redux in js). For most of the view stuff, I would use Bootstrap accompanied with [elm-bootstrap](https://github.com/rundis/elm-bootstrap). At the moment, I can't think of anything else that I would find in a web project, but I do realize that this is not nearly a full list of libraries one would use for a web project. What you're pointing out could become a problem in a larger app and I understand why ScalaJS seems like a better option. But there is hope for Elm, the ecosystem is growing and you can already find more stuff than you'd think. Also, the elm-package manager will [enforce proper use of semver](https://github.com/elm-lang/elm-package#version-rules), unlike what is happening within npm and is now finally being solved by yarn.
Can either you or /r/madwill explain a bit more? I am very familiar with React and Redux (and mobx, whatever), and semi familiar with Semantic UI - never used a react implementation and wasn't even aware there is one. Not at all familiar with FeathersJs except knowing that it's some kind of Node library for server side stuff. Can you explain a bit more? **Edit:** Never mind, reading through the docs now. Feathers sounds amazing.
Certainly does seem that way sometimes, doesn't it? 
XOR/Math/temp-var are same speed here. All the others are variations on the temp var, but building more elaborate temporary structures, which is way slower, of course. Also I love how pointless all this is :P
The problem is you broke all the principles for explaining things which you quoted at the beginning of your article :-) Occam would cry.
If someone can tell me how to do a headless print in landscape mode with margins=None I will be forever grateful.
&gt; So the above won't remove the event listener since the internal reference to the function has changed. So it seems when a Callback is tied to an event the function's reference internally must stay static, because if I assign that key to a new function it won't use that key to find the new function but will fire the function that the object pointed to when assigned(I'm guessing). This is really the basics of how JS works (it's the semantics of the language). This behavior is not due to how the language works under the hood. Let's add line numbers to your code to make it easier to talk about: 1. GlobalObjectThing.boxClicked = function(e) {} 2. elem.addEventListener('click',GlobalObjectThing.boxClicked ) 3. GlobalObjectThing.boxClicked = function(e) {} 4. elem.removeEventListener('click', GlobalObjectThing.boxClicked) On line 1 you create a new anonymous function, and assign it to `GlobalObjectThing.boxClicked`. In JavaScript functions are objects, and so are always passed *by reference*, rather than *by value*. This means that from now on, the only way to refer to that anonymous function you created is to look it up on `GlobalObjectThing.boxClicked`. On line 2 you pass that function *by reference* (because functions are objects, and are always passed by reference in JS) as a callback to the `addEventListener` API. On line 3 you create a *new* anonymous function, and assign it to `GlobalObjectThing.boxClicked`. This means that there are no references remaining to the anonymous function you created on line 1, so there is no way to reference it! On line 4 you pass your 2nd function to the `removeEventListener` API. You never passed that 2nd function into the `addEventListener` API, so there is no listener to remove. If any of that is unclear, I would recommend reading through Simpson's You Don't Know JS (available for free at https://github.com/getify/You-Dont-Know-JS/tree/master/async%20%26%20performance).
Same applies to Java developers. And... oddly... PHP developers, because PHP has had a Java-style OOP system with type annotations for over a decade now. That's a big crowd when put together.
Web components pro: framework agnostic. Web components con: WC polyfill/library/framework dependent. Are polyfill-agnostic web components a thing?
- The whole "I'll make an entire article of saying what is not a functor" is more confusing than helpful. The space of things which are not a functor is vastly larger than the things which are a functor. Imagine you've never seen a car in your life. And someone is telling you "a car is not a flower; it's not a bottle of water; it's not a wristwatch; it's not a movie". It's utterly useless. - Saying "this is not X" can be helpful if it's right next to a very similar definition of "this is X" in order to define an edge case. But that's not what you did. What you did is like a sculptor who is walking around a town and waving his chisel in the empty air and saying "my statue is not here, it's not here, it's not here". - If you are explaining what a "functor" is, your audience is not mathematicians, as they know what a functor is. So drop the "category of sets" and so on math lingo. Imagine if someone was trying to feed you linguistics when you were an infant and teach you your first language this way. *"Hey, baby, today we're learning what "syntagmatic" means ‚Äî it's a reference to the linear (or temporal) sequence of elements which contrasts directly with the vertical axis ‚Äî the paradigmatic axis."* - When people say examples (and non-examples) they refer to **simple, working, usable** code with pragmatic usage. That's how people really learn. Like a baby learning to speak - point to a thing, say the word. Do it again. Again. Again. The only example/non-example you wrote in your article was the "identity" **non**-example. That's... utterly insufficient for anything at all. - Don't turn an article into a pointless nitpicking of terminology, where you contradict most of the world in how they define words. As I already said, to most programmers, when discussing data structures, a "container" is synonymous to a "type of collection", where items are not merely an unordered set, the container can be a list, a map, a partially ordered set, a tree, etc. If you do this enough, people will just conclude "this guy just disagrees with English, it seems." **EDIT**: And if I can add one last nitpick, the title "To Functor, or not to Functor?" suggest you will be discussing when Functors should be used, and when they should not be used, but this is not the topic of your article. Smart/creative titles can attract audience to an article, but they should still be reflective of the content, not misleading.
I think this means I can tear Webpack out of my CI and just use TypeScript + Karma for unit testing. That would make me super happy.
That's why I specifically stated that await returns undefined. If you need to be more explicit, you can use `if( response == undefined )`. And if the promise was never intended to return a value (ie the promise resolves with undefined), you can use a flag, as describe in my second example.
Lucky guy. We are supporting IE9 at my place.
&gt; A popular authentication-as-a-service provider, who will remain nameless, publishes a library that displays a login modal tied to their service. Even though the modal only contains a handful of inputs and buttons, it includes the entire React 15 library with it. If your project does not use React, you must include the entire framework anyway. Is this guy serious. The entire React "framework" (library, more like) is 40kb on the wire (minified and gzipped), and only needs to be loaded once (per browser, if you use a CDN, or per browser+domain, if you don't). It feels this entire article was about the author obsessing over those 40kb and ignoring every single thing React was created to address. &gt; ES2015 and custom elements are now supported in most major release channels (even the notorious IE and iOS). Nope: ------- Custom elements: - IE 11: **No.** - Edge 15: **No.** - Firefox: **No.** (can be enabled via a flag, not by default) - Chrome: Yes. - Safari: **No.** - Safari iOS: **No.** And "Web Components" is not just custom elements. It's also Shadow DOM, to be able to even start approaching something like what React offers: Shadow DOM: - IE 11: **No.** - Edge 15: **No.** - Firefox: **No.** (can be enabled via a flag, not by default) - Chrome: Yes. - Safari: **No.** - Safari iOS: **No.** So what are you talking about, OP? You're moving to a platform that's **only supported by Chrome** right now? Nice one. 
No. Your browser cannot control your system settings. It's not allowed as it's a security and privacy risk.
Cthulhu laughs at the thought of mere mortals prodding him with simple pitchforks, for he knows he will not feel them.
&gt;Isn't there a simple way to start something using es6? Yes. Just use it. You don't have to do anything in between writing it and running it. The latest Chrome and node.js both support es6. Maybe you read some older tutorials that mentioned needing to use babel to get it working, but that's not the case anymore. I write and use es6 every day to make various tools and electron apps, no babel or other nonsense required.
Ok, let's see some details... &gt; Sidenote: Would it be in-appropriate to not separately define a cell? That seems almost.....I dunno, wasteful? As I mentioned it _can_ be done. It really depends. You may model your _cells_ as "just an array of Strings". It's really little more than that. So you _could_ do it that way. But then again... Well, if you _do_ model it as a separate entity you can, as shown above, put all that part of the functionality (checking it a cell is empty or not, saving its value, reading its value) together in one place. It _may_ seem like it's not much and separating it may look like unnecessary hassle, but it does have some advantages (separation, order, structure). So... the answer is: It's good doing it, it has advantages. But it's not 100% _necessary_. &gt; Also Im confused because you say this.cells[i][j] = new Cell() how does JS know what each cell is, since they are defined by name... There are a number of questions there. Before we answer how do we know which cell is which, we may want to answer _who_ is concerned with keeping track of knowing which cell is which. In the proposed sketch, all a `Cell` knows is its state (empty, X, O) and how to manage that. One particular _cell_ doesn't really know _where in the board it is positioned_. Instead, that's something the `Board` itself knows about. How? Well, we instantiate the `Cell`s and put them into a 3x3 matrix. And why should the `Board` and not the `Cell` care about that? Easy: because how the _cells_ are laid out on the _board_ is actually _what defines the board_. That is, the board, as a concept in its most basic form, is exactly that: a certain arrangement or layout of cells. Because this is tic-tac-toe the nature of the board is an arrangement of 3x3 cells. Don't get too fixed on the particular detail of using a 3x3 matrix. I did that because it seems, at least at first glance, both simpler and the most natural thing. You could, if you want, store the nine `Cell`s in a linear array... class Board { constructor() { // ... this.cells = []; for (let i=0;i&lt;9;i++) { this.cells[i] = new Cell(); } // ... } // ... } Hey, you could even, if you want, do something like... class Board { constructor() { // ... this.cell00 = new Cell(); this.cell01 = new Cell(); this.cell02 = new Cell(); this.cell10 = new Cell(); // etc // ... } // ... } // (But, seriously, don't do it this way :) ) That is actually, mostly, an implementation detail. The cool thing about it is that if you separate things correctly, then _only `Board` is concerned about this detail_. I mean, no other entity needs to actually know how the `Cell`s are stored internally in `Board`. ( The word _"internally"_ should be enough explanation :) ) &gt; if you ever get bored i'd like to see YOUR concept of it to sort of study it Ah, well... tic-tac-toe is a classic exercise. I'm pretty sure you can find hundreds if not thousands of solutions out there. It's about the right size to allow a number of different approaches. I'd guess _most_ OO solutions will indeed have a `Cell` and a `Board` entities, some also a `Game` entity. All that for the _model_ only. As for actually viewing... oh, but I'm getting ahead of myself... Anyway, there are some fun solutions out there. And I actually happen to have one I did a couple of months back as an exercise at work (no, I don't work making tic-tac-toe xD). [That solution is here](https://gist.github.com/gezeta-id/6dfc058080eca79fae48c1c7fd775b4b) if you really want to look at it, but beware of three things: 1. No, there's no real interface. The exercise was only about the mechanics of tic-tac-toe, so this plays on your console and you don't really see the board at all, sorry. 2. It's not meant as a particularly good solution in any sense. This solution in particular was meant as some sort of _alternative method_ of implementing the mechanics of tic-tac-toe. So this means some silly things like using a magic square to check for winning moves. 3. The _style_ is... well, probably not the style I would recommend. (It was also written in about 15 minutes so it's dirty in many places) &gt; where do we actually do the representing and playing of the board? So, this is _the_ question. In another comment, /u/simyers suggested looking at MVC and that's really the answer you want. Well, that or some similar pattern, but that's what you actually want, not all this roundabout explanation. But... let's have the roundabout explanation anyway... xD Ok, you have the _model_ of the game. That is, you have managed to design a `Board` entity (_maybe_ with some auxiliary entities such as `Cell` _if you so prefer_) that contains the internal workings of the game itself. I'm not using the word _"model"_ casually as you will have gathered already. This _is_ a Model, capital M. That is, it models or represents your domain, the thing you want to implement. But now you need two (probably 2, maybe not) additional things: first you need some way to actually _view_ the model. Not only _the model_. What you want is a way to view the model's _current state_. That is, you want to let the user see the tic-tac-toe board in a familiar way (say a 3x3 arrangement of squares) and see the current situation, that is, which cells are empty, which are taken by which player. (continued below)
(continued from above) You also need some way to _control_ the board, to interact with it. That is, you need something that allows you to make a move, or restart the game, etc. Another note here: What I'm proposing is just _one_ way of doing it. As I said before, there are hundreds of solutions out there and they _may_ take different approaches. Anyhow, let's focus first on the entity to view the game. Again, no casual words: View. You might call this something like `BoardView` or some similar name that gives the idea of drawing the board. In fact, if you've done the `Board` correctly, you might use it with various different _views_. Say, a `HTMLBoardView` which draws the board as a collection of `&lt;div&gt;`s on to a web page, a `ConsoleBoardView` which draws it with some ASCII art to play on the console, a `CanvasBoardView` which draws it on `&lt;canvas&gt;` with some fancy effects... What's the _concern_ of the `BoardView`? Well, clearly it should care about rendering a `Board`'s current state. Nothing more. So we could sketch something like... class BoardView { constructor(container) { this.container = container; this.cellDivs = container.querySelectorAll("div.cell"); // whatever, I don't know } render(board) { // get the board cells, iterate through them, put the values into the appropriate cellDiv } } (Again note that this is very rough and speculative. I'm imagining I have a number of `&lt;div class="cell"&gt;` on the page inside a certain container element. It's just an example) The interesting detail is only that `BoardView` has a `render` method. And probably nothing or little else. Because its concern is just that, rendering the board on screen. Nothing more. It may need some additional helper methods, of course, but the `View`'s concern should be just that: rendering a visual representation of the model. Finally, we need that other entity, the one that will let us actually operate on the game, to interact with it. If we are really following the MVC pattern that would be the _controller_, the entity to _control_ or act on the model. There are other similar patterns and they may use slightly different names. The idea is pretty similar. Now, the `BoardController` (let's call it that for now) is concerned with... what? What should define it? We have the "workings of the game" covered, and also "viewing the board". So the concern of the `BoardController` should be _only_ to get the user's move and _act_ on the model so that the game plays. (I'll get back to that "only" in a bit) Notice that, again, we could have multiple controllers. We could imagine a simple console implementation that just asks you to enter X and Y to play, or a similarly simple `&lt;input&gt;` box with a button where you write your X and Y, press the button and it plays the move. Or we could map the moves to the numeric keyboard and simply let the user tap a key to play a move (or q,w,e, a,s,d, z,x,c). Or many other ideas. Or... we could... sort of reuse the DOM elements the view uses. Which is what you have in your code. This is perfectly reasonable. It _makes sense_. But be aware that even though we sort of _"share"_ those `&lt;div&gt;`s we still keep _view_ and _controller_ separate. That is, the view will put the appropriate values into the `&lt;div&gt;`s and nothing more, and the controller will listen to clicks on those `&lt;div&gt;`s but nothing more. Hey, did you see that? There's your answer... finally! Setting up the event handlers should be done in the _controller_. The Model... _models_ the domain. The View... _views_ the current state of the Model. The Controller... relays the user actions onto the Model. We've got everything now! Or almost everything. Remember the "only" I pointed out a couple of paragraphs above? There's one little detail missing that you could call "tying it all together". Particularly, you need two things: one is someone to tell the View to update when the model has changed, the other is you'll surely need something that instantiates all three entities and initializes them and all that. Telling the view to update... well, there are various opinions on that. Some people will tell you the Controller should tell the view. That is, it acts on the model and then tells the view to update. Others will prefer the model tells the view. Others still will say a different, additional entity should tell the view... As for the second thing, you could call this your `Game` or your `App` or something along those lines. It should be an entity that simply sets things up and wires them so that they work. Stuff like instantiating your `new Board`, `new BoardView`, passing them the appropriate parameters, etc. &gt; If were trying to do functional programming...do we just make some standalone function that does some initialization (like set players and such). And where do we actually like.........make the board? Ah... well, that could be a different approach... with an explanation probably just as lengthy xD But generally speaking the underlying ideas are still similar. And by this I mean the _fundamental_ ideas. Like [separation of concerns](https://en.wikipedia.org/wiki/Separation_of_concerns). This is a general design principle. It _applies_. It _always_ applies. But do be aware that a functional approach does not mean simply using _functions_ (or _not using classes_; in fact you _can_ combine using classes with functional ideas) but also caring about some other aspects. Anyway, that _is_ too long to write here. &gt; Also the event handlers......thats the biggest stumper. I mean it makes no sense to attach it to a "model" like you said, but I guess in your Initialization function or something is what makes sense to me? Hopefully this has been cleared up above, but I didn't make a Controller sketch so... You could have something like... class BoardController { constructor() { document.querySelectorAll('.cell').forEach(function(cell) { cell.addEventListener('click', function() { // imagine cells are like: &lt;div class="cell" data-x="1" data-y="2"&gt;&lt;/div&gt; board.play( this.data("x"), this.data("y") ); view.render(board); // maybe, maybe not, we talked about this :) }); } } } Again the details are unimportant. What you should get from that sketch is that the `BoardController`'s main concern is simply getting the user's actions and translating those into acting on the `Board` so that it works. There are still a lot of particular implementation details left out of these sketches. They're here just to give a rough idea, I insist... to the point of being annoying, I know xD
&gt; i think when you talk about typescript, you talk about the whole tool. you can't just write typescript and run it in the browser straight. So you're still better off writing js directly. You can't just write modern JS and run it in the browser straight either. Almost all JS projects these days use Babel to support ES2016+ features without having to only use the lowest common denominator of features that are supported by the browsers. TypeScript is essentially the same thing, except instead of writing ES2016+ and transpiling to ES5 with Babel, you write TypeScript and transpile to ES5 with the compiler.
I am sorry that this meager upvote is all I have to mask your pain.
Yes, exactly how I saw it. That's one cool thing about Go that you just compile to a single binary that Can be copied over and run everything from one file.. It's nice to have this option available with Node.
IE8 here chiming in. Bloody Banks. 
So guys, you mean that in no time (half of a year-year) - everyone would and should be writing exactly modules, which will be loaded by browser? Without need to bundle everything? You mean AT LEAST people who doesn't like bundling will HAVE to learn about modules and split code into modules?
&gt; So, iow, like the W3C and WHATWG? From the same manifest &gt;&gt; The web platform should develop, describe and test new high-level features in JavaScript, and allow web developers to iterate on them before they become standardized. This creates a virtuous cycle between standards and developers. As for scientists making UI interfaces ...... &gt; What's funny is, those two groups, especially the former, are computer scientists who know far more about how the web works cause they created the web. That literally has no bearing on real world web applications. The web has had more than a decade to come together and it still struggles with the simplest tasks, so something is obviously off despite their scientific capabilities. Innovative developers confronted which huge user facing applications and *real world scenarios* have found solutions that logically and objectively supersede the committees best efforts. They made the web do things that were impossible before, and will be impossible with web components. The same developers have openly spoken out against the WC spec for various reasons. I don't personally care if you go back to imperative oop templates because "scientists made a spec", the rest of the world will not, let it be no surprise to you. &gt; You also state vendors should not meddle with how apps are made but that's a separate issue that has nothing to do with web standards. Web components do meddle with it. They prescribe a high-level components model, one that is outdated and brings many disadvantages we have already solved years ago. **The dom should be an implementation detail** (as in, low-level), that is what the manifest is about. 
or, you know, you could just continue the way you work now with webpack because it doesn't change anything in that regard.
We're supporting IE8, you luxurious bastard
We also have some Firefox 3. Thankfully I think that's going away soon. Doing new things with such a broad user base is !FUN!
&gt;Since class names are usually generated gibberish Not necessarily. I use this format (instead of just hash) in dev: localIdentName: '[local]__[path][name]_[hash:base64:5]', 
It's not gibberish unless you tell it to be. The configuration of CSS modules has an area where you can make it conform to your naming conventions. 
PHP and type systems for over a decade??? It came pretty much with version 7 so like over a year :) but yes it is hard to move to different concepts so people invent languages like TypeScript to avoid a change of mind concepts
&gt; PHP and type systems for over a decade??? It came pretty much with version 7 so like over a year :) It came with PHP 5, 13 years ago. Reference-based objects, type annotations for arguments, exceptions, interfaces, abstract classes and methods. PHP 7 only refined it with scalar annotations and return annotations, which were already wide-spread by then as IDE-only PHPDoc annotations. 
yep you are actually correct..I was thinking about proper support :)
Well it's still not "proper" support. There are no property &amp; variable types, generics, let alone things like unions and intersections. But this doesn't change the way it's used. You annotate what you can, and the rest goes by convention.
Your whole thought is a strict contradiction of itself and shows a complete lack of understanding of how web standards come together.
For the easiest cases there's nothing much to it, just use `import` async function date() { const moment = await import('moment') console.log(moment().format()) } This will resolve at compiletime and add a bundle for the `moment`dependency, but it will only be loaded once you are actually using it, that is, once `date()` is being called. For components there are a couple of helpers, [react-loadable](https://github.com/thejameskyle/react-loadable) for instance. Addy Osmani has made a [whole series](https://medium.com/@addyosmani/progressive-web-apps-with-react-js-part-2-page-load-performance-33b932d97cf2) about it recently, async loading route paths, pre-load hints, chunks and so on. Other than that: https://webpack.js.org/guides/code-splitting-async/
 "https://potato.com/test.png is cool".replace( /(https{0,1}:\/\/((?!\.(jpg|png|gif)).)*\.(jpg|png|gif))/ig, "&lt;img src='$1' /&gt;" ); this will turn anything thats starts with `http` or `https` `://` and ends with `gif, jpg,png` BUT does not contain... into an image tag.
Yes 
Make an argument other than "you wrong, i'm not," otherwise i'm inclined to think i'm wasting my time here, though the scientist nonsense should have made me suspicious already. I don't see a contradiction in what i wrote, and it reflects similar statements that i have cited ([React](https://github.com/facebook/react/issues/5052#issuecomment-145594782), [Ember](https://github.com/emberjs/rfcs/pull/60)). Do they contradict themselves as well and show a complete lack of understanding? Like so many others in this thread i have worked with web components and had a horrible experience. I couldn't care less about how it came together, i care about solving problems and making applications, which is harder with web components than it is with modern solutions.
If you can't alter them to be exported then I guess you'll have to run more end-to-end style tests with Selenium or similar. If you can't refactor in order to bundle them then I can't easily see how you can write unit or integration tests. Sorry I'm not more help there.
You'll need to use a canvas. [This](https://developer.mozilla.org/en-US/docs/Glossary/Canvas) is a good starting point. 
wtf is this
I only have to support the newest release of chrome. It's a god send.
1000 LoC is a TODO list demo, not a small-mid application 
never say never :) These are the types of components that need to be very efficient and to use the full potential of the browser api (dynamic animations where you need to optimize and respond quickly to changes) should be implemented in an imperative way without any intermediate layer. The easiest way to implement them is using pure js, but webcomponents are a nice declarative layer above them. To manage these components on the application level, use the functional approach provided by the frameworks.
The key argument to make this sell, IMHO, is to compare the user base of outdated browsers with the amount of users needing more accessible websites, and then point out that you're not making an effort to make your website more accessible either (as, let's face it, most of us aren't doing).
Neither typescript, which is a superset
&gt; npm is still common-js and it isn't clear if the node community will accept es-modules The node community certainly will, the problem has been on how to implement it and what behaviour to implement. &gt; When will Microsoft deprecate IE11, they still ship the thing in Windows 10 I could have sworn you don't get IE11 outside of the LTS version, since I see it nowhere on my Windows 10.
What blows my mind here is that SAFARI implemented it first‚Ä¶
Safari supports Shadow DOM and Custom elements, they even pushed hard for the changes in the v1 specification. Lots of misinformation in this whole thread.
while mithrill is very well implemented, it's really an underdog. It will never catchup to the likes of react or angular. Don't use it for longterm projects unless you want to regret it in couple of years.
I think it depends on your goals, but being "in fashion" vs "underdog" may not always be the right criterion for everyone. It does let you build an app with router and backend after reading one page, which does not seem to be the case for those other 3 more established frameworks. That is, if you talk about Angular 2. The AngularJS actually had such page and did quite well at the time. But the point of Mithril is to be almost no framework at all :) Basically you write vanilla JS, just better. And given the level of churn in the industry, it may not necessarily be a bad thing.
Hi /u/MultiplayerCheckers, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
What I don't get is why don't these companies just install both--old IE for their legacy apps and new Chrome for current webapps. What's stopping them?
This is not how Firebase works
&gt; #### When Should I Use `const`? I‚Äôm glad you asked‚Ä¶ In my opinion const should be used only when the value of the variable will not change, at all, between the times it is declared and goes out of scope. If you plan on changing the value of an object‚Äôs property, don‚Äôt use const. While this is a syntactically viable place to use const, it fails to convey the correct intention. In fact, **it straight up lies to whomever is reviewing the code.** Kind of disappointing to read a fairly tangent-filled article only to get to a conclusion I really disagree with^[1]. Mutating an object that was declared with `const` is only a "lie" if you define `const` to mean something other than what the language defines `const` to mean. This boils down to saying "the actual definition of `const` doesn't agree with my preconceived notion of what `const` should mean", and saying the solution is that everyone should limit themselves to only using it in ways that match the author's preconceived notion of what `const` *should* mean. It's an understandable mistake; I think most people assume `const` implies immutability, but it makes more sense to me for people to correct their expectations, rather than try to enforce some stylistic house rule about the usage of const (which probably can't even be enforced by a linter). --- Personally, I like the "`const` everywhere" style. With that style, when used consistently, seeing a `let` in the code doesn't just mean "this variable might be redeclared", it means "this variable *will* be redeclared", which is a nice readability aid. (And this style can be linter enforced, via the `eslint` rule, `prefer-const`) Yes, it means that a lot of things are marked as `const` which aren't "constants" in the conventional sense; but it does match the actual language definition of `const`. (Though if you use immutable objects like ImmutableJS, it becomes a moot point; a `const` variable *does* behave like an immutable constant) --- ^[1] The conclusion also virtually nothing to do with the everything that came before it. I don't see why we needed a hypothetical language and a stack diagram just to make a stylistic claim about `const` usage. Maybe the last paragraph is just a side-track, not actually the intended conclusion?
I prefer `pre-push` over `pre-commit`, personally, for both linting and testing. I don't care that every commit be perfectly formatted, but I do want it to be properly formatted before the rest of the world can see it.
If you structure your code by feature the css for that element will exist either next to it or directly attached to it
It supports Mac and Linux as of 59. They say windows is "coming soon"
so IE/Edge represent 20% of the market. is your business good enough to not care about them?
"The market" is dubious. Browser share is dubious because it is entirely contextual. Some HR portal or other work-related site will create an artificially high percentage of IE visitors. Developer-facing tools like github might deliver an artificially low share. You have to understand the nature of someone's business before questioning their need to support IE -- much less affix a random number like "20%". 
We support Edge. IE 11 and older we don't. And they don't command anywhere near 20%, it's far smaller. We have a SPA that's server-side rendered, so there is still a usable experience for people on older browsers, but we encourage all IE users to upgrade to a modern browser. We started off with lower figures for IE (just by nature of our target audience), and over time the prompting has caused it to tumble further. These support decisions come down to the context of your audience. It's naive to just look at global usage stats and say oh, we have to go all the way back to IE 9 or whatever.
So, you made sure x and y are non-null. But, are they out of range for the get(), whatever that is? There's no way to know without knowing what "get()" does (and how). You need to provide more code (preferably in JSFiddle or Codepen.io). 
Could the ```get(x,y)``` call be returning ```null```?
The 20% figure is a grouping of all IE versions and Edge, and based on multiple sources of statistics for 2016. W3C for 2017 so far as all IE/Edge at less than 10%. *shrug* In the end though, many if not most cross-browser compatibility issues have been abstracted way by any number of various JS/CSS tools. With a good testing strategy, supporting all major browsers including slightly older ones, is not an ordeal.
It looks like getElementById isn't finding a DOM element with that ID. You may want to debug or log out the x and y that you are searching for.
You could also use SVG
You're doing it wrong (or if not you, the big fish in your ecosystem). I've worked for web companies in multiple backwards industries, so much so that at my first company one of our biggest challenges was just getting internet in to the offices of our customers! However, if you: * make software that customers actually like, want to use, and need for their business (this is where you need to be a "big fish", to some extent at least) * make explicit what browsers you currently support * broadcast well in advance that you will be updating your browser requirements (eg. with a header at the top of the page of anyone using an older browser) * finally, update your requirements, but only slowly update the actual site, making it clear when things fail that it's because of the user's out of date browser (and don't make anything critical fail for at least a few months) It won't be a big deal for your customers, it will just be something they finally get off their asses and make their IT department do.
Symbols can't be serialized.
Actually I'll usually use rebase (or commit --amend), to avoid trivial commits like lint fixes. (Which are very rare anyway, since I've got an editor plugin) I commit and rebase pretty frequently, so having my commits be nearly instant is pretty important to me. 
getElementById will return null... you are setting the class not the ID In set() get(x,y).setAttribute("class", value); In get() document.getElementById(x+"-"+y); if you are setting the class... then 1) You need to remove the class if the xy changes 2) Chage get() to use document.querySelectorAll() which takes the same input as css so it'd look function get(x,y){ return document.querySelectorAll("."+x+"-"+y)[0]; } returning '[0]' because querySelectorAll returns an array-like object.
ah. I didn't mean capital S Symbols, I meant square brackets. basically they're using string templates exactly like square brackets and it isn't clear what value is added.
Thank you. Going to check it out.
Yeah, markets are application-specific. I work in higher education in the USA. We have a student facing site that sees 1000s of logins a week, and the only IE hits it's seen all year are from our IE 10+ tests. From what I can tell, no Americans under 30 use Internet Explorer.
You might try to test if x or y is out of bounds. function set(x,y,value){ x = x &gt; width ? width : x &lt; 0 ? 0 : x; Y = y &gt; height ? height : y &lt; 0 ? 0 : y; get(x,y).setAttribute("class", value); } This should ensure that x/y never gets out of bounds
Oh but the app is for internal use only, not intended for customers. My bank is saying colleagues are already accustomed with IE8, so they are not changing anything
Lucky you guys. We support [Internet Channel](https://en.wikipedia.org/wiki/Internet_Channel). Key corporate stakeholders insist on browsing via their Wii (I assume right after a thrilling game of networked Wii golf). It's proven easier to just test on a Wii to get it right, than to constantly explain why the site is "broken" at 1pm on the Wii, when it was working just fine at 8am on their desktop or laptop. This guy is grandfathered in. We also used to support the PS4, till we went HSTS and could claim that the PS4 was no longer supported due to it being an "insecure" device that didn't support the latest encryption. Sadly, Internet Channel predates the HSTS RFC, so it simply ignores our efforts.
https://en.wikipedia.org/wiki/Rube_Goldberg_machine
You need to add the .svg loader. https://github.com/webpack-contrib/svg-inline-loader
&gt; Simple beginner guide &amp;&amp; &gt; So glad we made it to chapter 4 already the irony is not lost on me, sir!
Well, if this was a normal market all you'd have to do is wait for your bank to fail (as all dinosaurs do) and get bought by a competitor who actually understands how to use modern technology for the benefit of their business. But given how un-capitalist our current banking system is you might be waiting for quite awhile if you do that ... 
Isn't the debugging experience strictly worse than manually naming classes? Or is the tradeoff worth it?
start making electron apps
You can do either. I'm a fan of styled-components myself. Helps with readability and keeping your styles away from your logic. [Example](http://imgur.com/a/uPGk9)
thanks, but no result here
Hmm, I wonder if it would be that bad. Should be possible to set up desktop shortcuts that open the legacy apps in IE, and disable access to those apps from Chrome and to the general internet from IE. Then you're not saying 'use two browsers', you're saying 'use Chrome as the browser and these desktop shortcuts for our internal apps'. Users don't need to care, Luddites that they are, that those shortcuts open up IE üòä
&gt; second image Instead of second image, we have only one background color image &amp; we are displaying a transparency shadow css class over it to display text nicely, So need to cut through that transparency shadow with this canvas draw tool to see below wallpaper as a color picture, I hope it make sense. Do you have some idea to achieve this effect? This is really helpful. Thanks
I am also wondering if we can use fabric js instead of MDN to achieve this effect as we are already using fabricjs in our app. Thanks
Enjoyed the writing style and the intent of the article. I did go in to it expecting some sort of deeper insight though. Some sort of nuance I was previously unaware of. Really though, it was just a (perhaps overlong) explanation of how `const` behaves. There is maybe not a huge audience for that a year or two into aggressive ES6 adoption, but you never know. Still, for me it would have been nice if the headline or the the opening paragraph communicated a little more clearly that this was just a look at the basic functionality. And yeah, I second /u/Retsam19, you should use `const` almost all the time, and if people are confused into thinking it offers immutability, they should be corrected. 
That probably works for most people, but there's this annoying segment in the middle that *thinks* they're smart about tech, but they aren't. They'll think they're doing something great by using the wrong browser ("It's faster!") and then it's game over for security again.
I'm not saying it's a generalizable pattern. It depends on what you're doing. I prefer to not catch any of my errors and roll them up to a single catch on an outer async function. Then, for instances where I need to do more than report the error and move on, I'll write one off catches. The syntax of the promise catch method is, in my opinion, cleaner than the extra nesting imposed by a try/catch and I prefer it when possible. I'm not suggesting that you can totally avoid try/catches (or should). I'm informing people that there are alternative solutions available, depending on your needs. Most people don't realize that you can still use the same old Promise API alongside async await (hence OP's question).
I see that the React community has their own "Typescript", its called [Flow](https://flow.org/)
Really not sure why we need this over let's say Redux 
And it goes very nicely with functional approach
Just tried it out. Significantly slower in Firefox. From I mouse over the sidebar to the javascript notices and I can actually start scrolling, it takes around a second for me. Same with going back to the main section.
Nope. ES7 is done, complete, and delivered, and [only has two tiny features](http://2ality.com/2016/01/ecmascript-2016.html): the `Array.includes()` method and the exponentiation operator. [ES8 is also feature-complete](http://2ality.com/2016/02/ecmascript-2017.html), and includes async functions and shared memory. Decorators are currently a Stage 2 proposal. There's a list of all TC39 proposals at https://github.com/tc39/proposals , and there's a nice new site that lists just proposal statuses at https://prop-tc39.now.sh/ .
Firefox really needs to get its JS perf up to par. I love using it for ideological reasons, but have to switch to Edge or Chrome sometimes to make poorly made sites usable (looking at you target.com...). Inbox &amp; Keep are a bit laggy on Firefox also. It's also incredible to me that Google still releases sites that work slowly in some browsers, given their vast engineering knowledge and evangelists like Addy Osmani, Paul Lewis, etc... who are always promoting best practices for perf. Do they test? 
The new UI is super fast in Chrome. Blazing fast even. Why is it so much faster in Chrome than elsewhere? 
Missing hypercolon 
which line?
This seems a semantic argument to me. I've worked on very large React/Redux applications for companies like Walmart and Starbucks. Yes, Redux scales. But I would argue it doesn't scale _well_: as application complexity grows, Redux's architecture has a compounding effect on this complexity, rather than a diminishing effect. We always end up with ad hoc solutions to composing sub-apps together, we always end up with messy and home-grown solutions to composing asynchronous state transitions and side effects. It becomes hard to even know which pieces of code interact directly with other pieces of code, because of the ways in which Redux's architecture influences how you structure your codebase. All of these lead to a gradual but inevitable slow-down in our team's velocity and ability to suppress bugs. It also makes test-writing laborious (although _easily_ better than older frameworks like Backbone), and disincentivising test-writing is never good for a project. In other words, I think it depends on what you mean by "at scale" and "well". Maybe we have different standards, or have worked on different sorts of projects. And Redux is definitely a good solution for all sorts of projects. I'd just argue we can do better for large applications! In any event, thanks for your thoughts. And if you have ideas for how Freactal might address pain-points you've encountered with Redux or anything else, I'd be interested to hear about it.
It's one of life's great mysteries... Nobody knows why a Google website works best in a Google browser.
YouTube is made by Google. Chome is made by Google. Other browsers are not made by Google. They're *might* be a connection there.
Hm, what browser do you use? I'm using Firefox under linux normally so it uses polyfills and works great for me. I assume chrome/safari would be better because they don't need any polyfills.
Not by my computer rn but I've checked that and have adblock turned off there... I'll have another look later. Edit: Still nothing. Turned off all extensions... The root site works but not the icons page
I have edited and modified the above regex. before it could not have `jpg` `png` `gif` until the end of the url and would treat any such occurance as the end of the url resulting in. &lt;img src='https://potpng' /&gt;ato.com/test.png is cool now it treats `.png` `.jpg` `.gif` as the end which now results in &lt;img src='https://potpngato.com/test.png' /&gt; is cool
http://imgur.com/a/DbeaY Nothing in ff for Android. Same thing I see on my macbookpro 
Cool, thank you for that tip. My professor is insisting on us using getElementById for now... not sure if he's introducing this other one later in the course or something. Thanks again for the advice!
http://stackoverflow.com/questions/25931810/why-is-document-getelementbyid-not-needed Basically, don't rely on it as it can and likely will be overwritten as it's in the global namespace. Just use getElementById.
It works for me on chromium, firefox and chrome. I wonder if you get some console errors.
Why on earth would it be "likely" to be overwritten?
In the future, you'll want to post the actual code instead of just a screenshot of it so that people can copy/paste it and run it to find problems instead of just scanning through the image. It makes it easier for everyone. You can use something like [Github Gist](https://gist.github.com/) or [Pastebin](https://pastebin.com/) to share your code (just copy/paste your code there and then give us the generated link).
but the error is saying that the values are null, does that mean that because these numbers are out of range that they become null? and if so what is the range and how would i go about changing that? Uncaught TypeError: Cannot read property 'setAttribute' of null at set (javaScriptMain.js:64) at update (javaScriptMain.js:140) at gameLoop (javaScriptMain.js:122) this then sends the error back to the set function
1. This is not HTML5, it's much older. 2. This feature is non-standard, and was merely invented by IE, and later 'copied' (to some extent) in some other browsers. It being non-standard means no guarantee in support, as well as implementation differences. 3. They're still regular variables in global scope which *will* be overwritten by any script attempting to use that same global variable name. This makes it an 'avoid usage if possible' feature as you never know when you (unknowingly even) come across a script that uses a conflicting name. Using the feature isn't inherently bad, but it leaves your scripts vulnerable for future issues, especially when the scripts are intended for use in a larger project. I realise that's not the case for OP, but instead OP is using this as a learning opportunity so I'd argue it's even more important to pick up the right habits, and stay on the safe side. We're using IIFE's for all the same reasons, so why not also apply that same logic of 'preventing possible future issues' here?
Nothing. Like I mentioned before... So weird I wonder if you guys who can see it have the flag for shadow Dom turned on
Underlying tech notwithstanding, this UI is definitely an improvement IMHO.
PM and we can!
Firefox uses polyfills - its shadow dom implementation needs to be explictly enabled. Chrome/safari have this enabled by default. I have no idea why you don't see this - proxy maybe? Polymer sites work even on IE10 for the apps I tried. I'm a bit clueless what might be going on.
I tried using Polymer on a few projects and it became such a pain to work with. Maybe they've made changes since I used it last (version 1.0), but I don't plan on revisiting it. Angular is a much more robust and capable framework which offers everything Polymer does plus more. It seems polymer is trying to build a copy-paste style framework that doesn't require much knowledge of the underlying code and uses weird paradigms to complete simple tasks (eg: &lt;iron-ajax&gt;). Ughh, no thanks.
2017 - Google has built website which is not responsive. At least black version looks nice.
The last time I used Google Maps AI packages on NPM, two of the 3 would throw errors randomly. I think the google maps api just changes frequently that these libraries arn't updated to keep up. The project was only temporary and to be fair, this was awhile ago, but just a warning. 
Yeah I wanted to do that but posting the code directly looked like such a mess, so I'm glad you mentioned those two resources! Will definitely use in the future. Thanks!
You can use ES6 modules just fine, as long as your build pipeline supports that. I've wrapped things like quilljs in web components without issue. Same with sass processing for shadow dom.
Hm, speed wise it is on par compared to alternatives, size wise it is smaller - even with polyfills. But you are right - I think everything "modern" has some sort of component-like solution.
I didn't hit on images being transformed to data uris in the js file. I've never liked how that works -- I'm more referring to just copying the files wherever they need to go (be it CDN or a public directory) and updating the references in CSS appropriately. Doing this manually is a pain.... I'm not saying it's hard to reason about, or do manually, it's just more effort I'm willing to commit to when webpack and css-loader will do it for me. Images in a JS file seems atrociously wrong to me. Ha, having said that, I did create a webpack loader a while back for a personal project that would create image sprits from a glob pattern of images.... there's other things in the ecosystem that already does this - probably better than mine - but the special thing mine did was export a js object in the bundle so you could require the image in JS and get information about where it is in the spritemap (e.g., height, width, x/y coords) - useful for canvas drawing https://github.com/tswaters/webpack-sprite-plugin
Very interesting, would love to hear more about this. In my last team we've had major issues getting git hooks to run consistently across developers with Mac, Linux and Windows systems and some using various desktop GUIs (Kraken, Tower, Sourcetree) have you had any experience running your tool chain in GUI apps and windows by any chance?
He might be talking about how quickly responds to user input, not how well it scales to fit your screen size.
Whatever works most efficiently for you is usually the best solution. [PM2](https://github.com/Unitech/pm2) is generally recommended for production use though. It has some great clustering/load-balancing features, and built-in monitoring solutions.
it's fast tho
&gt; icon resources are being served inside html file. If you're referring to the fact that they have inline SVG for the icons that's fairly normal. They are doing some javascript manipulation of the inner elements of the SVG i would assume. probably the color. 
I think you're missing the point: IT doesn't want browsers to access the clipboard *ever* on any page except for a small list of approved sites. This goes for both public sites (such as the one running my product) and whatever internal sites they have. Asking users to use IE everywhere and Chrome in a small number of cases isn't reasonable for nontechnical users especially if that small number isn't small enough so that they can be represented as a handful of shortcuts.
This is more complicated than just raw react. You have the ability to pass state to children without being explicit, but to me that is a trade off. It's less clear where state is coming from. You can do all of this with vanilla react setState and passing state down as props. Pass effects as functions in props as well. Your container components need to hold state. You can either pull all state to the top or have a tree of container components with dumb leaf components. 
No, Firefox has been a bit delinquent in implementing web components, so it requires a polyfill to run polymer. I don't really think it makes sense to use the new UI if you are running Firefox, Edge, or IE. Mozilla has web components (other then imports) under developments so it should be rectified soon.
Mmmm, a company slowly making their sites work better in their browser... I'm sure I've seen this before...
Aside from being uglified/minified it looks to be heavily relying on WebComponents and ShadowDom both of which FF doesn't support yet and uses polyfills to duplicate functionality. There are tons of domevents that chrome doesn't experience due to using ShadowDom. It really is impressive how fast my 1000+ subs load in entirety and scroll smoothly while loading icons in chrome.
You're looking for Webstorm. https://www.jetbrains.com/webstorm/
You can use [typescript-eslint-parser](https://github.com/eslint/typescript-eslint-parser).
That is what I got. It only lasts 30 days, it doesn't seem to have a console and at points it is extremely slow and laggy. Which one do you use?
I use ST3 and a browser or terminal. Webstorm has a built in console, debugger, and code inspector. If I did more backend work, I would use it or IntelliJ. 
I developed Polymer applications. This has nothing to do with html imports.
x_files_theme.mp3
That is the idea of Polymer, to be a thin layer over webcomponents.
Which events? My polymer sources and markup are the same for all browsers, regardless of polyfills. This source feels like something dynamically generated from python(gwt again?) I'm a polymer user and I feel disappointed by what I saw in sources.
Is 1.2kb for a sticky header 'good' in reactland? I feel justified in my aversion to learning react if that's the case. 
For performance: - https://newrelic.com/ - https://www.pingdom.com/ - https://www.appdynamics.com/ - https://developers.google.com/analytics/devguides/collection/analyticsjs/user-timings For logs/bugs: - https://www.bugsnag.com/ - https://www.loggly.com - https://rollbar.com/ - https://airbrake.io/ - https://sentry.io/ - https://raygun.com/ Personally, I use Newrelic+Bugsnag for frontend, and Newrelic+Loggly for backend.
Polyfills? I know it's pretty unlikely. Might just be gecko/spidermonkey?
Well the only part of web components [that firefox supports fully withouts bugs or without a flag](http://jonrimmer.github.io/are-we-componentized-yet/) is templates, so everything else has to be polyfilled. I'm not saying it's that, but it seems highly likely.
Wow this new one feels slow.
By "console" do you mean a command line, a javascript REPL (like what you get when you type `node` on the command line), or a debugger for the node program you are editing?
Just a couple of quick things... First, I insist that you shouldn't look too much at the details of the code I wrote there. It's just meant as a rough idea. Then, MVC is just _one_ way of structuring things; it fits well into your problem so we use it. But _there are_ other ways, don't focus too much on this. On the other hand _separation of concerns_ is a "fundamental principle", you should focus on that in a general way. Yes, you'll need some place (a `Game` would be fine) where you instantiate the different parts and set them up. You're working with _classes_ so you do need to instantiate an _object_ from them. We could have done it in a different way, directly using objects, but _if you define a class for something_ then yes, you need to instantiate a concrete object from it. Finally (don't have much time today), `this.cells[x][y].play(this.turn)`. I imagined that the _board_ keeps track of 2 things: one is `turn`, which changes from `X` to `O` each time representing whose turn it is when we make a move. var turnPlaying = this.turn; The other is the `cells`. `this.cells` is a bi-dimensional array, that is, we get the _cell_ at position _(x, y)_ doing: var cellBeingPlayed = this.cells[x][y]; Now, the _cell being played_ is an object of type `Cell`. We know those objects have a `play(symbol)` method, so we call: cellBeingPlayed.play(turnPlaying); That line does exactly this but in a more compact way. _Again_: that code is just meant as a general idea. Good luck with your tic-tac-toe :)
I used both Vue and Angular (2+) for personal and professional projects. Angular is much better, if you want to make a SPA that scales well. Its IDE support is also second to none. On the other hand, Vue is super easy to combine with PHP/Ruby/... projects. Plus it is really easy to pick up for frontend and backend devs.
Did you read this article? Husky and pre-commit both install hooks into `.git` for you and the article talks about `lint-staged`
I now what a console is and I've tried and tried but can't find a console on any of them.
lol...
So what am I doing wrong? Or are you just here to laugh at someone asking for help?
It's pretty unfair to blame this on Firefox. Polymer was built around in-development web standards that Chrome already implemented while they were still being defined. To support other browsers, Polymer uses polyfills which cause noticeable slowdown on all browsers that aren't based on Blink. Version 1 of the standard has just been finalised, and is now being implemented by all browsers. (Note that the polyfills also do not yet support this version in a stable release.) Until then, Polymer applications are going to need a lot of optimizations to be on par with other web applications, performance-wise.