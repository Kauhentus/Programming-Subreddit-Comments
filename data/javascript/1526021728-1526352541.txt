&gt; Promises can now be used within IndexedDB code (bug 1193394). Glad to see this finally fixed. This caused a lot of headaches for anyone using IndexedDB transactions.
Take notice this doesn't sort the array.
React is not a framework, there mostly is nothing to learn and you can pick it up--fully--under an hour. Try this for instance: https://egghead.io/courses/react-fundamentals You'll quickly realize why people are liking it. It revolves around the basic premise that views are functions of state, which isn't a flavour of the month but a paradigm. Jquery for instance follows layout-inflating, which is the most troublesome and complex because you are mutating and abusing the dom by dropping state into it. This paradigm was long cast aside for MVC and MVVM, the web was one of the last platforms really delving into this horrible approach. MVC, which consisted of oop and controllers lasted for nearly a decade. We're now going into another. React doesn't matter, maybe it's something else tomorrow, but the concept that drives it will go on - and you can already see it, even native platforms are equipping themselves - thought probably in vain as react has a good chance to drive them as well.
If you need it sorted I'd use array.reduce then on each iteration insert the largest number found using Math.max and mutate original array by splicing that number and have positive and negative counters then compare them.
r/LearnJavascript
As much as people will probably suggest learning theory first, you should start building stuff ASAP. No amount of theory can replace working through a real problem. Don't bother with trying to get it right the first time, get a page done with whatever means possible. Best pick a project with personal stakes (e.g., your CV page), set a deadline (time management and problem assessment is an important skill), and finish it. You will bust your deadline, and that's ok. Finish the project, and then figure out why it took you longer than expected. Good luck on your journey 
Checkout Tensorflow.js aswell. 
&gt; Do const positives=array.filter(item=&gt;item&gt;0); then if positives.length &gt; array.length /2 you have more positive than negatives. This looks awesome. I'm a total, utter beginner so I've never written anything outside of a beginner's tutorial. I'm trying to make sense how to execute this. var array = [1, 1, 1, 1, 1, 1, -1, -1]; const positives = array.filter(item =&gt; item &gt; 0); if (positives.length &gt; array.length); { console.log('You have more positive than negative.'); Jerczu... Thank you kindly and have a great weekend. 
Hi, quick response to get you some idea - maybe other guys will add something also :) Ad.1.: AFAIR it's because of plugins initialization - most of them will not require this but we have already some cases that required a plugin initialization to be asynchronous. It might be anything but simplest scenario is loading some data from a server. Ad.2.: Disclaimer - I'm from CKEditor team so my opinion might be biased ;). From my POV it looks like this - Pros: we're using a custom data model. Cons: we're using a custom data model. In order to add a collaboration to the editor we can't relay on DOM as a data model. You of course load the HTML and you get HTML back from the editor but internally we're using a custom data model that reflects the edited content. This also means that arbitrary HTML is not supported - everything must be a feature. The CKEditor 5 just got first stable release and we're still adding missing features (like tables). If you want a battle-tested editor with more features there's always CKEditor 4 which has tons of features and is actively developed. The CKEditor 5 itself is heavily tested as we have over 8k tests for it (or even more and recall exact number now) and every feature that we're adding will work in collaborative editing environment. Also with a stable release I think that the CKEditor 5 is ready to [handle many of the content editing needs](https://docs.ckeditor.com/ckeditor5/latest/examples/builds/document-editor.html). ps.: the [react integration](https://github.com/ckeditor/ckeditor5/issues/1015) is on the way
No problem mate.
Ok, I am done discussing this. Pointless trying to make some points to people over internet. Do as you wish.
Disclaimer: I don't use any of these services, and IIRC they are all 'free until you get too much traffic'. Alot of people are using 'Heroku' or 'Now' to host applications quickly/easily. And if you use these services you'll need to host your DB somewhere else. The ones I see all the time are 'Firebase' like they said above, or 'mLab'.
Yeah no problem gimme a second
Modules aren't under the ES6 tag/results list: https://caniuse.com/#search=modules Their support breadth is similar if significantly more recent.
That's Microsoft's way, infiltrate governments and Enterprises to maintain market control. Always was.. since the beginning
Why is everything written as a promise? It doesn’t seem like creation of an editor, destroying it, etc would need to be asynchronous. Sometimes it does. One case is creating editor in the iframe. It is a common practice to be sure that styles on your site do not affect your editor's content. However, iframe loads asynchronously and you can not set the content of it synchronously. Another example might be collaborative editing - when the first user shares his content with other users. All users except the first one load the content from the network what is also an asynchronous action. Since these actions might be asynchronous it is safer to have an API which is always asynchronous. Otherwise, the behavior will change depending on the case, what could be very misleading. &gt; What are the pros and cons of using CKEditor? Are there better options out there? (I am using react but I don’t really want “react integration” to be a factor in my choice. Just how good is the editor). The biggest pros of CKEditor 5 it that it joins maturity and the fresh approach which is rare in today's Javascript world. On the one hand, CKEditor is already 15 years on the market, on the other, CKEditor 5 is rewritten from scratch using newest ECMAScript features, PostCSS, multirepo and all goods JS gave us recently. At the moment it has more than 9000 tests, what is more than, i.e. React framework. It implements MVC pattern, has a custom data model, so features like real-time collaborative editing are possible. It is extensible and pluggable: even such basic feature like the way typing is handled or what UI library is used can be swapped if you want to. When it comes to cons, for sure you will find a smaller and simpler editor if stability and customizability is not a priority.
I don't want to work for you. 
Yeah agreed. I loathe IE so much I'm looking forward to the site moving to win10 for edge lol!
You realise that having separate i each cycle creates variable each loop so you waste more memory until garbage collector runs? Variable will not get immediatelly destroyed as in c when you exit the block. Its not an issue in your small teoretical example but it may become issue when you do larger application. But sure ... if you just learning JS you better do as book says. You will learn advanced stuff later.
Thanks for the overview and especially for the link.
And I don't condone ignorance.
Ok my thing didn't work here's working example this will sort the array and give you number of positives and negatives Https://jsfiddle.net/1o8egbeg/1/
Ok my thing didn't work here's working example this will sort the array and give you number of positives and negatives Https://jsfiddle.net/1o8egbeg/1/
To those of you who are looking for the source code or a demo: GitHub repo: https://github.com/henshmi/Classic-Pool-Game demo: https://henshmi.github.io/Classic-Pool-Game/ The thing that I'm proud of the most, is the AI algorithm that I wrote for this game. I challenge you to beat him on the "Insane" level! Let me how it went for you! ;) Enjoy.
Well kind off. Because it certainly in a way affects productivity in some ways. 
But I want to and am trying to understand! That's the whole point of my comment. When you reply with a comment like that all I feel is that you don't know how to explain your point properly, and that you're trying to pass the blame for that on to me. 
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing.
Hello. The difference between our and Twitch's list is that we are displaying additional info like stream's quality, uptime, streamer's main language and we are not displaying any channel that is currently streaming Gaming \(for example Dota 2 in #programming community\).
Ok my thing didn't work here's working example this will sort the array and give you number of positives and negatives Https://jsfiddle.net/382r26xw/2/
Literally? The only active browser that *doesn't* support ES2015 modules is Opera Mini with 0.32% of market share.
Popularity is a great thing for frameworks, more resources, tutorials, libraries etc. 
My teacher is going to teach us node.js, mongodb and ajax. With my own preference of socket.io, without any real knowledge of Ajax. I started googling and checking stackoverflow stats, but havent managed to grasp any real stats. That's why i want to check with the Javascript community!
I don't care about IE but my fucking clients do. I also just found a fun bug in Edge with the fetch api lol.... God I hate Microsoft.
Thats true, but since both are capable of everything, with ajax long polling. It feels like most either use one or the other, rarely both in different projects. That might be a misinterpretation on my part though
Try a compose function
If you truly believe you are entitled to use whatever language to get to people, I'm not sure this subreddit is right for you. Consider this a warning.
Ajax is something that developer must know. For example calling external API, oAuth
You're fine with fetch or similar though right?
fetch is AJAX.
Webpack and Grunt both came out in 2012 and SASS came out in 2006! I think it's very much slowing down on the tooling side and most of the new things have been on the language/framework side lately.
I also have to say, OMG this example just hurts my eyes. He is creating there set of anonymous functions none of which has any variables defined, then you argument well lets put let in the outer block of those functions so they behave correctly ... and you talk about localising variables dude? Why not just make single function with one argument and call that? If this is your common usecase then I understand that function scoping is not sufficient for you .. just use blocks, you will cause less damage.
F
r/LearnJavascript 
I’m fine on ~87% [Caniuse](https://caniuse.com/#feat=fetch) 
I think you have to take these posts with a grain of salt. Not long back the whole thing was "we've committed to Go, we've decided it's the future", etc etc. Netflix open source a lot of their stuff, you can look on their Github, I'm seeing mostly Java. Alongside Python, Ruby, Go, Scala, and yes Javascript. 
It baffles me that anyone still uses Internet Explorer. At first I was a little confused on account of the fact you have to \*deliberately go out of your way\* to get it in Windows 10, much more so than you'd think the average IE user would be capable of. Then, it occurred to me that Windows 7 is still powering a significant chunk of enterprise/educational desktops.
I like the direction their new CEO is taking things. He seems to be eschewing the usual idea of Windows as the stack in favor of Windows being the UX, and porting that across devices. It's kind of a GNU approach to the idea of what an operating system is, and it's rather refreshing.
probably need to refactor some, from what I remember urls need to be absolute, so npm imports and relative urls won't work. 
You know react, you know inferno.
Mystery is called with 3 and return a function that accept one parameter to variable hidden. The mystery3 is called with that function in hidden variable and return another function that accept one parameter to the variable jumble. Jumble is called with 2 so: Parameter param is the very first function recives by mystery. That was passed 3 and incremented by 2. We passed 6 to param so: Multiplier = 6 * 5 return 4 * 30 // 120 Back to inner jumble function: return 120 + bonus // bonus is 2 so 122 the final result. Because the closure. Even when the functions finished. Js keep in memory some values because later you gonna use this values. And the functions inside a functions, can have access to this values with scope above... Thats something called closure...
&gt;If you're not building software that should be feasibly maintainable in 5 years without a complete rewrite, you're doing it wrong. Which is **exactly** why I advocate not using jQuery. There is no reason to use a library that already has been made useless by standards that were incorporated years ago. 
You are missing the point, and yes this is a common use case. It has nothing to do with the function, it's about the declaration with var being hoisted outside of the loop. Totally changing the scope of the variable. Based on this thread it doesn't seem like you are all that familiar with JavaScript design patterns or standards. Anonymous functions are an enormous part of JavaScript. Think about any function that takes a call back. Do you forward declare all your functions to?
For “advanced” CSS, you pretty much answered it yourself - those are basically websites that look amazing. It involves understanding how to get the typography right, how to combine some unusual CSS rules to get a nice result, how to make best use of the space, getting the colours right, etc. As for “advanced” HTML, it’s basically getting HTML right - there are a lot of things that beginners don’t even think about. For example, when designing a website, designers often overlook people with disabilities. To cater for visually impaired users, you might need to use ARIA attributes in your HTML. For some motor disabilities, you will need to make sure you website is navigatable without using the mouse, and so on. Mastering these two together is often referred to as learning UI and UX design for web development.
Actually I fully agree, The new business decisions taken by Microsoft are really new-age and exiting, Hopping to see more!
Sure, but there is a self-reinforcing factor. If few people genuinely evaluate the appropriateness of technologies, they just pick the popular one, where is all that going?
Constructors are special functions that JavaScript will call whenever a new instance of a class is created. You don't need a constructor unless you want to do something right when the object is created or you want the user to be able to pass some properties into the object at time of creation. Classes in js are a little different than in other languages, I highly recommend watching the series on object creation. I think it will give you a good understanding of how things work
RIP.
A bug in fetch? Won't that break, like, everything?
Dude, do as you wish. You will learn eventually that creating complex constructs does not make your code more readable and maintainable. Fact that language allows you do something does not mean that you should use it everywhere and at all costs. In your example you are 'fixing' with let common novice mistake which is caused by using variable without declaration in all those functions you create. You really have absolute no say to tell me that you do localisation of variables better ... not only you do it far worse, additionally you also write much more memory hungry code. Creating million anonymous functions in loop cant ever be considered recommended pattern omfg ... If that ever happens I do create one function and pass just the data to it. I am not against localisation of variables, but you should do it properly and not using 'let' just to fix issues which you have only because you have no clue what is actually happening.
You also apparently dont get difference between declaration and definition.
I disagree. Vue's comprehensive and easy to understand documentation is a big factor, but more than that you are still writing JavaScript, CSS, and HTML. Three things developers have done for decades. Yes you have to learn some boilerplate methods for the JavaScript, but they are clearly right there in the docs. With react you have JSX. It has positives and won't argue if it's better or worse, but it is not HTML. I can't just copy HTML from a source and use it, it needs to be switched to JSX. So now you have added a whole new language to learn. For some being so similar to HTML will make it easy, for others the fact that it's close, but slightly different will make it hard, their decades of experience will make those slight changes hard to adopt. React also seems deceptively simple. Take props as the perfect example. The docs explain them as read-only variables that are passed in to a component by it's parent. Simple, easy, makes sense. Then you work on a project with higher order components, you are reading the render function and can't figure out where these props are coming from or how they are being set. It's not bad once you learn and understand the pattern, but it is far from intuitive. I love react for it's versatility and JS focus, but to say that it is easier to learn than Vue is just not true.
The grammar in that article made it very difficult to read. I gave up after the first couple of paragraphs. Was that even written by a human? I would have guessed that it was generated from a Markov chain.
Exactly why Vue is superior, you don't get shit like Higher Order Components. They make bad practices hard to implement.
Usually courses and books come with examples for you to build. Then see if you have any ideas on your own and try to build them. For the most part, people use prebuilt frameworks to build professional looking websites in minutes. Personally, I don’t find it as useful to know the nitty gritty of css if things like bootstrap, jquery mobile, material design exists. However, if by advanced you mean highly interactive website. You should look into learning React or Angular. I went with React and can not believe how complicated the stuff I can build with it. Angular is older and more famous but I have seen hordes of angular developers switch to react and none the other way 
English grammar is quite difficult for Japanese speakers to master.
I'll care only when I'll be using such language when I'm wrong. Which I am not, I provided objective proof that I am right. Have a nice day.
Which bug?
If you're going that far off the reservation, I'd say [Elm](http://elm-lang.org/) or [Elmish](https://elmish.github.io/elmish/) may be reasonable choices too, depending on the site/team.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](http://elm-lang.org/) - Previous text "Elm" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
You're insulting people by attempting to belittle them. If that's your definition of arguing with logic, I have a hard time seeing you contribute anything constructive. Please don't think that you're doing anything but that, even if you're "winning the argument" this way. Have a nice day.
It's been said before but Javascript looked a lot different when jQuery was in its heydey. The whole point of jQuery was JS's document API sucked: it was verbose, inconsistent between browsers, and not always standardized. But jQuery wasn't and isn't a framework, it's a library. It doesn't at all dictate how your app will be written. Now that JS has improved itself so much, a lot of essential jQuery functions have direct parallels in native JS, which makes jQuery feel very redundant. And it doesn't even solve the real problem: how can I intelligently build my website, with understandable structure, DRY code and reusable business logic? That's what React, Angular and Vue are trying to solve, and currently folks like React best -- mostly because it's the least dictatorial. Don't wanna use Redux? Fine. Don't wanna use JSX? Fine. Prefer Typescript? Fine. Want to use Axios? Fine. Don't need browser history? Fine. I could go on.
Okay, I'll give you a chance. Get that butthurt snowflake who reported me to tell me how I am exactly wrong instead of replying "I think you got it backwards", which is definition of your "belitting", after I double checked that I didn't get it backwards, and then I might care. If you are wrong, and someone tells you that you are wrong, and explains why they are wrong, and you reply with "lol kek you got it backwards", don't expect anything but to be called a fucking retard, that's all.
I'm not supposed to make anybody do anything except from stopping toxic outbursts. That's all. It's fine if you feel he is trolling you, but that doesn't warrant the kind of response you gave him, yet maybe any response at all if you feel like you were truly getting trolled.
hi, my name is /u/oneeyedziggy and my code supports ie6... *sobs*
&gt; You will learn eventually that creating complex constructs does not make your code more readable and maintainable. A for loop is not a complex construct, a for loop that creates factory functions is also not a complex (or uncommon) design pattern. &gt; In your example you are 'fixing' with let common novice mistake which is caused by using variable without declaration in all those functions you create. Look again, the variables are absolutely declared. The problem is that var allows them to be hoisted into a different scope. for (var i = 0; i &lt; 5; i++){...} See the keyword **var** there. That's a declaration. It's also a definition, conveniently in the same place. There is not a single variable in the example that isn't being declared. So, to reply to your other comment, apparently you don't know the difference between declaration and definition. Learn how garbage collection works. All variables declared inside a loop are garbage collected immediately after each iteration of the loop. If my code is more resource hungry than yours it's only the allocation of a single variable, which may as well be free. &gt; Creating million anonymous functions in loop cant ever be considered recommended pattern omfg Most of es6 is **designed** specifically around anonymous functions. In fact they added arrow notation specifically to make anonymous function easier to write. Map, filter, reduce, promises, ect. All are based around anonymous functions. Can you use var, sure. Most people know what they're doing until they hit an edge case. Does var have any advantages over let? No, not a single one. **Should** you use var? No, why use something with no advantages when there is a better tool? Should you forward declare anything, ever? No. No good comes from it. You declare and define variables as close to where you are going to use them as possible. You act like 'let' is some fancy piece of syntactic sugar added for people who don't understand JS. It isn't, it fixes a design flaw in javascript that can cause bugs that are really hard for people to debug. Again, it's clear you don't have very much experience. Keep learning.
Dude I was talking about anonymous functions which you create: function() { return i; } What you expect that should be returned? What actually happens that javascript looks up the scope and finds your for cycle. In 1 example there is just this one context created because i is hoisted to that expressed function. In example with let you create multiple contexts one for each anonymous function, thats why you get 'correct' i value. You should completely refactor your code to make function accept parameter. Thats proper variable localisation. Dont know how more clearly should I explain this ... if you dont want to understand it pointless really discussing.
Yes, but we want to do the linting for the newlines added to the old files. 
Thats tricky, you can do: `/* eslint-disable */` first line `/* eslint-enable */` where you need end disable again
https://tenor.com/search/oh-god-gifs
I use PHPStorm and it lets you select just certain lines and format them. But to be honest, it's best to just rip that tape off right now. We have a policy at work that if we're modifying a file, we format it afterwards and commit. For a while, that's going to be painful, but it's a heck of a lot less painful than trying to be careful not to format the rest of the file.
When you mean by format? You mean linting?
[https://media.giphy.com/media/10maBTCM9o96Ao/giphy.gif](https://media.giphy.com/media/10maBTCM9o96Ao/giphy.gif)
Generators are so ugly it didn't seem like Koa was worth the trouble before, but now with async/await it's just so clean! 
I assumed you were using eslint to reformat the files as well. You're just checking the syntax? In that case, I don't think there's anything you can do. 
Learn AJAX first. I love websockets and use them in side work a lot, but as a beginner AJAX is more general use and you will interact with it more 😀. 
It is. Ajax is just a blanket term for retrieving data over HTTP with JS. XMLHttpRequest, ActiveX (for those remembering the struggle), fetch. That's different APIs doing the same thing with different browser support.
Thanks :)
First, I didn't write that article. Second, it's a simplified, dumbed down example. In reality you'd never return a function that just returned i. It would, however be reasonable to return a function that *used* i for something. I don't even understand what you're arguing for. There are edge cases that cause var to produce unintended behavior, let and const allow you to define things in a more strict and predictable fashion. There is literally no downside to using let/const. There IS a downside to using var. Why argue that people should continue to use var when there is no use case in which var is a better tool than let? It's like arguing that the horse and buggy was fine so why bother using cars. Not just in the sense that it's antiquated, but in the sense that a car is going to be more useful than a horse and buggy in every situation. Do you just not want to learn something new?
My condolences.
Dude... just no comment. Take care. 
What does supporting just es6 modules have to do with removing Babel? You need a browser with full es6 support, not just module support. Try bundling your code without Babel and running it, will break in some way for everyone but chrome and ff.
Yeah, I mean you don't *need* them, but some people like sugar! :D 
While Elm is great conceptually and has amazing ideas, I find the language itself is too restrictive and 'pure', leading to a hinderance of productivity. The interop story, strong typing without type inference, unfamiliar syntax (to js developers), and lack of ecosystem really add up. ReasonML on the other hand has done everything to make the syntax as close to JS as possible, has generous escape hatches when you need them, MUCH more easily interops with JS, and has amazing type inference. It is built on the work of OCAML, a language with 2 decades of work and research, while Elm is something built from scratch. Concepts are great, but at the end of the day work needs to be done, and I would highly recommend ReasonML over Elm everytime. 
Wasn't worth the trouble? It's almost the exact same syntax. function* controller() { const blah = yield somepromise; // this is the context } const orBLah = co(function *() { yield someotherpromise; }) // in non-generator function async function controller(ctx) { const blah = await somepromise; // ctx is the context }
What still why
🙄🙄🙄
Express for the API calls with an Angular service observable. NgOnInIt call the service from your component, have the service return the JSON object. Have express route the api request and res.send the data. 
I'm a programming newbie myself and I'm still learning through online courses but I've found pretty cool websites that offer programming puzzles and challenges. Pretty useful to see if you understood the concepts in what you learned. I know there is many websites that does this but here's some I found : https://www.codingame.com/ https://coderbyte.com/ https://www.codewars.com/ https://codefights.com/ Happy coding!
I would have thought Enterprise stuff. Large corporations like banks are just notorious for their glacial speed of upgrading. Becoming a real issue for them now as when they do try and migrate everything falls to pieces. E.g. TSB recently.
&gt;Web components on the other hand are based on an outdated, impractical idea. Ironically, within the shadow root lurks a naked dom, which, you guessed it, needs a framework---or you're back to dom inflating and class querying. 10 web-components you load will drag along 10 different frameworks, good luck with that. That's a wild exaggeration. You can even get by without a framework for simple components, but in real life only a few different frameworks (like Polymer) are used. This is not a bug, it's feature. It allows web frameworks to evolve independently from components. You can create a new web framework without rewriting every single component from scratch - or writing glue code to use components from an old framework in a new framework. &gt; If they're supported or not, the spec has been around for years now by polyfils, and hasn't gotten any traction This is incorrect. The spec is gaining traction in implementation. Custom elements v1 (the new spec), for example, is implemented in Chrome and Safari and is in progress for Firefox. &gt;I root for a future where react drives every platform that can produce visuals on the other hand You root for framework monoculture? React is perfect and the end-game? Really?
It's pretty far from being "the new IE". Yes, it's stuck back in time a bit, but it's still standards compliant. I'm surprised it renders SPAs at all. There was a time that it didn't.
 else { new Group().children.push(); } What are you `push`ing to the `children` list?
not if you're still using XMLHttpRequest...
Thank you :) 
This comparison makes no sense to me. They are totally different technologies and it's very rare that I'm in a situation where I'm wondering which one of the two I should be using in order to solve a particular problem. Currently, I'm working on a project that aims to provide more granular control over traditional home media center devices. It's comprised of a server device and a handful of "helper" devices that perform specific functions. For example, I've got a device that does nothing but detect infrared signals from remote controls and passes the encoded signal to the server. The server then looks up the defined response associated with this command, and dispatches the appropriate action(s) to other devices, such as another ESP8266-based device that basically does the exact reverse of the first- it watches for a websocket event named "IR" on the network, decodes the associated payload, and flashes the decoded signal via an IR led. Or, the defined action might be to dispatch a command over HDMI-CEC, in which case I have a Raspberry Pi set up to watch for "CEC" websocket events, and drops the payload on the HDMI-CEC bus where it can be picked up by its intended recipient. For this to work well, I need a persistent, low-latency, low-overhead protocol for transmitting data at high speeds to devices ranging from browsers running on full-blown PCs to microcontrollers running custom C code. Obviously, AJAX makes zero sense as a substitute for websockets in this context. Similarly, if you were building a single-page blog, using websockets to do things like publishing articles directly to every connected users' browser whenever a new article gets submitted would be absurd, when the client can just poll the server for updates every so often. Just because you can use a technology to mimic the behavior or another technology better suited to the task doesn't mean that you *should*. Websockets are great, but they're not really meant to compete with AJAX. 
Yeah but those same people sure do complain a lot about how difficult it is to use that sugar 🤔🤔
&gt;object spread operator That's ES2018. &gt;Then consider module pathing. It seems browsers have a different pathing schema to find modules "Module pathing" in the spec does not leave anything unspecified for currently valid identifiers. If you believe you've found a bug, you should report it to the browser vendors. I'm guessing you're mixing Node.js/NPM syntax (a 'bare import specifier') with proper module specifiers. According to the current spec, only those starting with './', '/' or any amount of '../' are allowed, and filenames and extensions are required (unlike Node.js). Thus, there's really no ambiguity there. &gt;so you may still even have to polyfill for that. You can't polyfill that.
Your API surface argument is so weak, you really need to stop touting it. React's "tiny API surface" is only as useful as the size of your project. As soon as you need to do anything besides a Hello World app, it becomes a mess of 3rd party libraries and unclear conventions. I laugh every time I read an article akin to "Here's the best way to bind click handlers in React". The fact that someone has to write a giant blog post to go over the 10 different ways you can bind handlers, all which may or may not be efficient/performant in a given situation is hilarious/sad to me. 
&gt; I think it's very much slowing down on the tooling side and most of the new things have been on the language/framework side lately. You make a very good point here. It definitely seems like things have calmed down a bit lately, and I hope this is *actually* the case, and continues. It almost seems like web development requires an additional part-time job just in keeping up with new technologies, when I feel like it shouldn't take *quite* that much time and effort.
I misrepresented myself through my initial posts, but your response has some good advice. Thanks. However, I respectfully disagree in that exposure to a "everything" is necessarily a good thing, that is, specifically in my situation. But that's on me, and my not explaining adequately beforehand. Besides, this is /r/javascript and not /r/cscareerquestions or a more job/career-oriented subreddit.
People spend 12 weeks learning it at bootcamp.
One last comment ... cant sleep because someone is wrong on the internet ... Try this code : var callbacks = []; (function() { for(let i = 0; i &lt; 500; i++) { let bigArray = new Array(1000000); bigArray.fill(0); callbacks.push( function() { return bigArray[0]; } ); } })(); So we are creating perfectly localised bigArray which we fill with 0, but hey .. we are using 'let' so garbage collector should immidiatelly take care, right? In the anonymous function we are just returning single value of the array ... Open task manager and observe whats happening with memory. Try to reload the script few times, you will see that not only its not garbage collected immidiatelly (it cant be because you reference it in your anonymous functions), but additionally it even stays in memory between page reloads. So you may be thinking ... well I only have 500 simple functions allocated each returning only one value, the truth is you have 500x whole bigArray allocated plus those 500 functions and it all stays in memory for quite a long time. When you do same code with var well you also waste memory but whole scope exists only once not 500 times. Granted code is doing something else, but point is that you should not reference in anonymous function variables from outer scope as they can not be garbage collected while there is some reference to anonymous function in your code and let in this case is really not solving the problem, but making it much worse underneath. This example should make you clear that while fine lets make nice code, with perfectly localised scopes ... but if you overdo it or forget something you very quickly can produce big problems as you are creating many scopes and specially with use of anonymous functions this is memory leaks prone. Dont use 'let' to fix issues which were created because you dont understand how scoping works, use it wisely. Then it is very usefull. Introducing let to novice coders may result in the fact that they will never understand what they are actually doing. Var exposes whole madness so thats what you should start with and when you understant it... then start using more advanced constructs as let and block scopes. I believe that I am certainly not ignorant in my opinion about this.
I think it was just the adolescent stage of javascript, as in when it went from the language you'd use to make an ajax call to the language you build servers/applications with. If you compare the tooling available for Python or Java its relatively similar, as websites increased in complexity the tools you use to streamline the process are going to get more complicated. I mean while I feel sorry for someone who has to learn it all from scratch – its not like it's particularly easy to jump into unity or c++ either.
Es9 is already thing? Wow
You're right. The Web and JavaScript have seen more leaps and bounds in the past decade than at any other point in time. I *loathed* using JS in the late 90s/early 00s, and now I use it almost daily. Thanks for the refreshing change in perspective :)
I see, nowadays skids can get away with "yeah dude I was just acting retarded, I was actually trolling!".
Some features already reached phase 4 so you can have a look at what's coming. I'll update the chapter in case more features are added later 
How would native ES6 modules even work? JS files' contents would need to be read to find out which next file to request, resulting in a lot of back and forth requests/responses; sounds really slow and ineffective.
Solved this myself finally. Using the following I could get it to work: var ticketIDM = document.querySelector('div.partner-warranty-info').innerText; var ticketR = /\: (\d+)/g; var ticketID = ticketR.exec(ticketIDM); 
 I have a mistake there of course. This is not a complete function, i need an advice on how to make the function "understand" that if a group exists, it will refer to rl.question that says "group exists insert a subgroup" than the subgroup name will be channeled to group's children array.
Oh! so the `new Promise()` didn't work before ES6? That's my question.
You should consider fixing the whole file when you have to change it. It will simplify your process (you don't need line linting anymore) and you will improve the codebase. Eslint fix mode, prettier, jscodeshit and your IDE's autoformat should make this process relatively painless.
Dude open task manager in windows and see how much memory is consumed with firefox process. Of course you get undefined in console, but memory will not get reclaimed immidiatelly ... it entirely depends on browser when it will decide to purge the memory. If you have free gigabytes then it might even stay there between page reloads and if you already have low memory creating extra scopes may have performance impact as gragbage collector need to run more frequently. Not sure if you deliberatly trying to argument nonsense omg ... how many years have you been coding in javascript?
Okay so I think I get it. This is using Django and Handlebars. So template extending is being used .. there's a base.html and an index.html. The index.html has a script section with the handlebars script call. Sooo.. I can't really update the base.html with my new checkbox, and adding it to index.html didn't work lol. Sigh .. there's no way adding a new checkbox should be this tricky :) But I've learned new words hehe. 
MDN has that information. I highly recommend going there as a first resource. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise
thanks for epub too.
Correct, the Promise definition was added in the ES2015 (ES6) specification. There are polyfills available for backwards compatibility and libraries that implement promises as /u/nickforddesign mentioned. See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#Specifications
Thanks guys!
Ah, got it, thanks!
Best of 2015 and the worst of 2013 are a little different. And googlebot will be updated in the near future across the board. Not like 90% of googlebot will straggle behind like IE. That's pretty different
Ok, we'll add closures to the list of things you don't understand... I watched task manager and tried this accross three browsers... No memory leak And 6 years c/c++ professionally, 5 years js professionally and was programming in both for about 5 years before that. The fact that you don't understand why forward declaration is an antipattern tells me you haven't been coding for that long.
Before you begin the project, understand the technologies at hand. That was the first thing I did, and I sat down identifying redundancies in the technologies itself, and sieving. Next, identify fundamental problems in the technologies, and begin to address those one by one. Some times this leads to coding, and some times this leads to a coding standard that you follow. When it leads to coding, you eventually end up adding to your tool base. Each tool must solve one problem, and one problem only. The tool must also be normal, which means acting the same on all environments. The tool must also be such as it solves the largest problem set, without having to re code part of the tool itself. Always solve the fundamental problem with the intention that you shall never come back to solving it again. Never skip, and follow a zero technical debt policy. And remember, if it is redundant, it can not possibly be fundamental.
Reason why the output is [5,5,5,5,5] is not problem of var, but problem of you not understanding how scopes are created in javascript. Give to such person 'let' and you are creating disaster. I with all my experience never actually needed let. It is more complicated construct as var and before using it you should completely know what you are doing. If you simply replace in this example var with let, you create 5 identical clones of your function each with diferent outer scope. None of the functions you 'store' have 'i' defined, so javascript looks in outer scope and it discoveres 'i' there. In var case 1 scope exists in let case 5 scopes exist. To sum up, you argumenting that is better to define 'i' with let so its better localised and then immidiatelly you define 5 functions in which you dont even bother declaring 'i' and rely on the fact that javascript will look it up the scope. You creating very twisted code IMHO. Not to mention the last line in your example lol ... that one must be giving headache to anyone lol.
Here I even made a [gif](https://imgur.com/a/x3VFLkm) of me doing the test. What your saying is 100% untrue. 
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/Md8etGn.gifv** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dytn34i) 
There's a bunch of links about how it works on the link you're commenting on...
That's very frequent for language standard releases. I suspect that this will hurt more than it helps as implementations struggle to keep up and implement new features haphazardly. A release every two or three years would be more reasonable.
My question is mostly out of curiosity but since you're improving legacy code base why'd you want to improve new lines for not entire file? If I'm correctly understanding what you're trying to accomplish is a paradox on it's own. Just my $0.2.
You don't really need that backslash before the colon. Or the /g switch. /Job Id: (\d+)/ Should be sufficient. Or maybe .. /Job\s+Id:\s+(\d+)/ .. if there's a possibility that the text your testing against contains whitespace that's not actual spaces.
Thats chrome not firefox. And whole point isnt really about when is the memory purged, but about the fact that you are making exeptionally lots of work for the browser. This is what happes on my pc in firefox : http://www.logicaldust.com/public/jsgraph.png as you can see memory is conserved for seconds, when I paste it into the console it even stays there http://www.logicaldust.com/public/jsgraph2.png. In chrome the script crashes ... I just dont believe that after 10 years of experience you have no clue about how scoping works and you suggest to people to use complete inefficient antipattern ... its not that let should not be used at all ... but it should definetly not be recommended as solution in your example.
It doesn't look like you're escaping the colon in the second expression.
Dude, seriously ... I already explained you what happens. Yes the closure will stay defined and your anonymous function will look up the variable in the closure, not internally. You are advising people to create 5 instances of 2 levels of scopes in which those anonymous functions are completely identical in both var and let case. So you are not solving problem but enveloping it with another level of code where you solve it ... what is so difficult to understand about that?
You have to wrap 'Job ID:' in parens to match it. For some reason the `g` flag is also causing problems. `/(Job Id:) (\d+)/` matches both parts, but `/(Job Id:) (\d+)/g` just returns a single element array with the original string. 
I am done discussing this ... you not only completely dont understand this topic, but additionally also you completely lack self reflection. I couldnt make it more clear to you but for some reason you refuse to even try to understand what is going on ... Have a nice day.
Within the first line of the first chapter there is a grammatical error. My grammar nazi syndrome has been activated and can read no further. [Imgur](https://i.imgur.com/U4rb2O2.png)
Where in this function is i defined tell me big guy : function() { return i; }
[The article on page 9](https://medium.com/@sbakkila/javascript-es-6-let-and-the-dreaded-temporal-dead-zone-85b89314d168) is outdated as of at least node 9, and according to the github issue the author links to, also node 8
And your map example lol .. you are calling function to which you pass function to execute that function for each of the functions you have in your array... You remind me that meme of Ship shipping ship that is shipping shipping ships ...
It's defined as a closure in the for expression. Closures are the only way you can pass values into function definitions. I really don't know what you don't get about this. Here's another example from the MDN which you seem to lack any familiarity with... function init() { var name = 'Mozilla'; // name is a local variable created by init function displayName() { // displayName() is the inner function, a closure alert(name); // use variable declared in the parent function } displayName(); } init(); 
OK, confirmed, you have no idea how map works... Keep the ignorance coming this is validating
So I can opt anyone out by emailing their profile over? What a completely fucking stupid idea.
&gt;Why would that be the case, you think the others will simply die out, because of ... Polymer, the worst possible candidate to drive your dom What? I predict at any given time there's a handful of popular web frameworks. &gt; If you wanted web components in React it would be easy, but there's just no point in this whatsoever. I think React should have a better support for web components. I believe Preact has a better support for it. There is point in it - to enable a common standard for components. You can could use components written in different frameworks and they could interact seamlessly. There would be no need to rewrite all the components if we had a common standard for web frameworks. &gt;Not really, but i am opposed to flawed technology just because a vendor dictates it. Web components is not a flawed technology. It's not dictated by a vendor. The specification was drafted by multiple browser vendors. &gt;This has nothing to do with gaining traction, Google is pouring fortunes into these specs, but no one is actually using it. Many companies are using it. Watch for example the last Polymer summit's keynotes of various companies using it. &gt;And as i said, why the heck would you chain yourself willingly to the browser, to an imperative dom masking spec that can't interact &amp; server-render. I push for web components to have a common standard instead of having to rewrite every single component for every single web framework. Web components can be server-rendered.
stars and claps! thank you.
Already submitted to /r/programming earlier: https://www.reddit.com/r/programming/comments/8ikp72/send_your_email_to_teamstackoverflowcom_with/
you can use setInterval to run a function at a regular interval. For example, given a function: function changeBorderColors() { let newColor = getRandomColor(); document.getElementById('rainbowTable').setAttribute("style", `border: 1px solid ${newColor}`); } you could run it every 1.5 seconds like this setInterval(changeBorderColors, 1500);
could submit a pr ;)
If you trying to point out that javascript is strange sometimes I agree on that with you. Thats why it is exceptionally important to know what you are doing. While you can fix this example with let, disregarding the fact that javascript is passing stuff by reference may cost you a lot so its better to know about it before you ever start using let... 
You're whining because I submitted to a different sub, since deleted, and you wanted to draw my attention to your whining there too? You also can't do text-posts on /r/programming. Here there is a description.
Honestly didn't even realize it was a repo. Just went straight to the PDF. Damn I'm an ass.
Yes you can do it like that or you can use call or apply. Or you can pretty much define function with parameter and call a function: function displayName(x) { console.log(x); } displayName('holygrail'); Have you ever heard about function with parameter?
Was thinking the same thing. In my mind ES6 is still bleeding edge
Thank you! Good job!
I know how it works, but given how cumbersome the passing and finally execution is everyone need to think twice about that is actually happening, you think its better then just having this? You define 1 function which is called once for each data: var callbackData = []; for (var i = 0; i &lt; 5; i++) { callbackData .push(i); } console.log(callbacks.map(function(x) { return x; } )); Sorry but I am simple person and I like simple solutions. Code you suggesting is complex just for the sake of making stuff complex ....
It's because the data you get back from the second endpoint is not an array, it's an object that has an array in it, so you need to get to the array before you can call the forEach. The first endpoint returns an array. 
 let i = 12 function(){console.log(i)} and let i = 12 function(i){console.log(i)} are two entirely different things. The second defines it's own variable called i, the first uses a closure. Again, read the link I sent about what closures are and how they work. And understand the difference between passing a value to a function **definition** and passing a value as a function **parameter**. two entirely different things.
Very very nice!
Dude, such people will create even more bugs because they will not understand what is going on. Debugging thousands line code when someone just redeclare something he shouldnt ... you need to have encapsulated code, then everyone can use whatever variable he wants. I dont think that you create more readable code by producing quantum of closures. Additionally you create quite inneficiant code while doing so even for the machine. Use what you want when you need it, but for god sake ... dont create closure just to pass variables to function ... 
Usually only 2 or 3 things are added a year
Its better than the alternative, which is release nothing for three years and then release so many new features the language is unrecognizable and upgrading is a nightmare. One year all they released was an expo bent operator and Array.includes, lot easier to upgrade your app to use those than when they introduced classes. 
Why do I have to sign up for some website to download the pdf?
You can use HTTP2 Server Push to resolve the module tree in the first request, that way you don't pay the price of a bunch of round trips. You might be wondering what the benefit is, then; it allows you to invalidate the cache on a module-level instead of invalidating the entire bundle as you'd do today. Thus you'll save your clients a lot of data and loading time on repeat visits. There's also the benefit of no longer being strictly reliant on build tools such as Webpack or Rollup, though there's still reason to use them.
cool read, and good to know. i was asked to implement this during a live codeshare session as an interview prescreening at fortune 5 (five) company
So tried /Job\s+Id:\s+(\d+)/ and shows as a value of null. Updated the original post with some more information.
I'm concerned your library is circumventing the primary point of protocol buffers, which is tagged fields. Your schema appears to just be automatically providing sequential tags, so any addition or removal of a field may make the new version completely incompatible. Protocol buffers use tags so that future versions are always backwards compatible - they just ignore tags that their version doesn't use. If you don't want/need tagged fields you should be using a different binary format.
This might work `/(Job\s+Id:)\s+(\d+)/i`. I added the case insensitive flag (`i`) and allowed one or more spaces between parts (`\s+`).
No it isn't that one is "better" or "worse", they're for different purposes. The best example I can think of is with you're dealing with DI. Let's say you have a function that is used to get user from a database you could have something like this. //getUser.js const db = require("my-awesome-database"); function getUser(id){ return db.query("user.id = " + id) } So this would work fine. BUT let's say that I want to be able to unit test the get user function. There's no way to do it. Since getUser depends on my-awesome-database there's no way to decouple these two. This is where dependency injection comes in. Here's an example that's *better* but not perfect. //getUser.js function getUser(db, id){ return db.query("user.id = " + id) } //index.js const db = require("my-awesome-database"); const getUser = require("getUser.js"); let user = getUser(db, 123) OK, in this example when I want to unit test my code I can pass in a fake object that pretends to be 'db'. This will allow me to test just getUser. This "fake" db object is called a mock. It allows me to test the getUser code without testing the my-awesome-database code *Remember unit tests are supposed to just test one thing at a time. There are very good reasons for this I'm not getting into here.* The problem with this example is that based on the number of dependencies that getUser has this function call could get very long. We are also requiring that index.js keep track of all the dependencies for all the entities it's going to use, that doesn't make a whole lot of sense. This is where closures come in. Take a look at this. //getUser.js const db = require("my-awesome-database"); getUser(id){ //db passed by closure. getUser.js can now manage it's own dependencies! return db.query("user.id = " + id) } //index.js const getUser = require("getUser.js"); let user = getUser(123) This is better but not perfect. It still wont be easy to unit test this as my-awesome-database is still directly in getUser.js. How will we pass it a mock? Take a look at this: //getUser.js module.exports = function(db){ return getUser(id){ //db passed by closure. getUser.js can now manage it's own dependencies! return db.query("user.id = " + id) } } //index.js const db = require("my-awesome-database"); const getUser = require("getUser.js")(db); //db is no longer needed in index.js let user = getUser(123) In this example unit testing the get user function is dead simple. And we aren't concerned with passing in a million variables any time we call getUser. True index.js does need to include the top level dependency, but only briefly. Will it still be in scope, sure, but there's only one instance of my-awesome-database and the variable is named well so there isn't really any harm done. If you REALLY want to keep it totally out of scope you could do something like. const getUser = require("getUser.js")(require("my-awesome-database")); But that's really ugly so people generally avoid doing that. So back to the original point, it isn't that one is better than the other. It's that closures and parameters server totally different purposes. Closures provide values to functions at time of declaration, parameters provide values to functions when they're called. It doesn't always make sense to provide all the values a function needs as parameters. Especially if that function has a lot of dependencies.
That example was dumbing things down to a point where, yes, you'd never do that in real life to log out a bunch of variables. But it represents what I sent you in my other message
Well that at least actually pulled data this time, however this is what is shows haha.. JOB ID: 4147271617,JOB ID:,4147271617
an idle game, so I don't think I'd need to use an engine...
I am pretty new to this so I am not exactly sure how, it should be pulling the whole text area which should show: Hidden out of Warranty | 00/00/0000 | Job Id: 4147271617 I can get it to pull the number but want it to look for "Job Id: " first just to be safe and not ": "..
Think I got it, if I just use: /Job Id: (\d+)/i It has no issues and the [1] in my other code actually uses the date it pulls from the group I assume ()? No idea.. seems to work though haha..
The thing is that those regex you put up there, both `/\: (\d+)/` and `/Job Id: (\d+)/` **do** work fine with a string like `"Hidden out of Warranty | 00/00/0000 | Job Id: 4147271617"`. That is: let s = "Hidden out of Warranty | 00/00/0000 | Job Id: 4147271617"; let r1 = /\: (\d+)/; let r2 = /Job Id: (\d+)/; r1.exec(s); // -&gt; [ ": 4147271617", "4147271617" ] r2.exec(s); // -&gt; [ "Job Id: 4147271617", "4147271617" ] So, if it is not working for you, there's only two options: either there's something else in your code that is causing some problem or the string you are getting doesn't conform to that format or has some weird characters in it. (Notice that _case_ matters. `Job` is not the same as `JOB`. Just in case.)
Dude I appreciate your effort you have given to this discussion. It was educational indeed. I am quite new here on reddit and considering how I pretty much did spend all day here today, this is my last post ever here. I am uninstalling /removing / forggetting reddit alltogether. Not that I dont like to hear people opinions and ideas, but this is simply too much time consuming and not much rewarding experience. Also sorry If I was too dumb or harsh .. Thank you for your explanations and wish you all the best. 
Can you share a direct download link please ?
I was harsh too, sorry about that. Happy coding
I decided to try Tyler's course on the one-month basis for $20/mo, so it would give me an idea of is it worth it to buy a whole year or not. I'm not a developer, so for me, it's a very fresh start. And so far so great! — React Fundamentals. It took me about a week to finish it including homework after course. Great entry. — Modern Javascript. It's basically Part 2 for React Fundamentals. Tyler explains all the new features and how to use them, and then he shows how to do refactoring the code from React Fundamentals. — Redux, in progress. The way how Tyler approach this topic and explain things I'm finally getting understanding what this all about. Way better than an official course on egghead.io from Dan Abramov, which one I didn't finish because it was way more overwhelming for me. I think you could finish most of the coursed within a couple of months, so you could go away without year subscription and come back later on monthly basis for updates and new courses. So, just take some notes while you are in the progress so later you would be able to read your notes (including some commands for installing libraries). Also, there is a great YouTube channel http://learncode.academy/ There is a video there about Web Development in 2018 and link the mind-map from the video, where he put all together what to learn step-by-step with links. Also just check his playlist on youtube, it has entry basis videos for pretty much everything that you might need in the beginning https://www.youtube.com/watch?v=gVXcqO9A1vo Another thing that I'm using during Tyler courses it's yarn instead of npm, the commands are pretty much the same using this Cheat Sheet https://shift.infinite.red/npm-vs-yarn-cheat-sheet-8755b092e5cc And instead of Webpack and having a configuration file for that all the time I found another builder https://parceljs.org/ that doesn't require to have a configuration file and most things work just out of the box without any plugins, like Webpack required. This is an example: http://blog.jakoblind.no/react-parcel/
Ask for a refund.
Not just technically; "ES9" is not a thing and the author should not call it that. The off-by-one errors should stop at ES6 and ES2015.
Download it from report below, couldn't sing up as well 
Hi /u/vospit, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/CrashnDShark, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/oxid111, For javascript help, please visit /r/LearnJavascript. Thank you!
How frequently is Koa used? Is everyone now using Koa over express now? Where do we stand on web frameworks nowadays?
Much appreciated, we'll add it to our list... we banned boostlog.io a long time ago.
Np.
Sign up. Wait for the GDPR email. Relax, your data is now safe.
&gt; I push for web components to have a common standard instead of having to rewrite every single component for every single web framework. You're just about to rewrite your Polymer apps from scratch for the third time. No vendor has ever committed to "standards", to the point where i think it is downright odd to trust them once again, and this time with an outdated technology stack that basically just wraps a shadow-dom. Do this with Polymer and web components: https://twitter.com/rauchg/status/955174495593132032 https://github.com/Yomguithereal/react-blessed https://github.com/gaearon/react-blessed-hot-motion What they're doing with the last one is possible on any platform, the eco system is becoming self-sufficient and transcends boundaries like browsers or native applications. These platforms are free-forming and many of them community driven. That this is possible at all, and it would have been crazy to even consider it a couple of years ago, is in fact due to Reacts specification which just works due to its simplicity. You can argue that none of this matters now because a vendor has decided to attach even more complexity to the dom, but do you honestly think that's good, *just* because it's a spec? Discard all merits because the W3C hasn't thought of it first? That would be kind of ... i don't know 
Wow, the plugin looks good. Before I used this article to set everything up (I'll post it here in case if it would be helpful for someone): https://medium.com/@nicklee1/configuring-sublime-text-3-for-modern-es6-js-projects-6f3fd69e95de
I too can write that statement without providing any code. Made a website with technologies made up of weird letter combinations! Gild me! 
as long as there are good compatibility layers like babel, the speed of updates is mostly positive
JS evolves in an interesting manner contrasted to the way most languages evolve. By the time that an ES20XX standard is approved, most browsers have a functioning implementation either already shipping or in progress, and it's been battle-tested by people using babel (which also provides a natural way to use a standard before all of your target platforms support it). Browsers (and node) have kept up pretty well with ES6/7/8, and I don't see that changing anytime soon.
&gt; mostly because it's the least dictatorial. This is good to hear. Dictatorial is a good word for the other two. They work very elegantly when you follow all the rules but they also feel kind of limited in that every quirk of your project's requirements must be solved using their way even if it isn't the best way in that instance. 
I see. But that seems that would cause a different problem; very low first time loads per client. Because remember, it takes a long time for webpack to transpile your project, because of building the dependency tree.
Alright, I just continued with ES7/8/9 as I first called the book ES6 for beginners. No problem, I'll just bring everything to year notation. :) Thanks for the feedback 
``` .on('click', function() {...}) ``` not ``` .on('clicked',function() {...})
yea i changed my code just now and i just realised it, but still its not working
Forgetting to put # when selecting the element with id of done.
In what situation do you imagine sueing stack overflow?
Technically ES6 isn’t really a thing either. The release was called es2015 to reflect the new naming pattern and yearly releases. However, since the release before it was ES5.1, there was a period where it was being referred to colloquially as ES6 and it stuck. 
Thanks for letting me know :) 
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing.
Thank you :)
It seems heavy because you’re paying attention to it in your code but it’s not. The browser runs an event handler every time a keg is pressed anyways. Anything like waiting for a method to recognize submit out of the box would be doing the same thing under the hood 
The new features are usually implemented *before* the spec releases anyway.
It's not the advocacy, it's the hostile attitude. We probably actually agree on many things, but with a combative stance like that, we'd never discover that
https://github.com/AlbertoMontalesi/JavaScript-es6-and-beyond-ebook/tree/master/assets PDF and epub available here 
Thanks a lot :)
Thanks a lot :)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [AlbertoMontalesi/JavaScript-es6-and-beyond-ebook/.../**assets** (master → 279defe)](https://github.com/AlbertoMontalesi/JavaScript-es6-and-beyond-ebook/tree/279defef7723913f32cffe403c7441d0044a3237/assets) ---- 
Thank you very much 
No they existed in JavaScript well before ES6. ES6 introduced multiple things to make it easier to use them such as async/await and for/of
Works for me. I just pasted your code into a fiddle: https://jsfiddle.net/7qfv5wpq/ , applied the two changes mentioned above, and it works. 
Ahahah next time I'll be sure to double check my post, what a fail lol I was sure I fixed the "know/now" last time as another user pointed it out to me. I must have forgot O_O 
Glad I helped :)
Thank you :)
Glad I helped :))
Ahah thanks :)
No. Thank you.
Oh also, adding this domain to a list unfortunately won't help, they go through many domains very quickly.
Yes, that's a known challenge for IE support, but I content that Proxies in production and not for testing utilities are still quite rare, and I doubt many people have been seriously inconvenienced by being unable to Proxy in IE11. I challenge you to name another construct that's similar to Proxy in that it's not polyfillable.
You can prevent the refresh in a form submit event handler with `event.preventDefault()`, so that might be the easiest solution.
It was all in good my man 😁
I'll update and write ES2017/ES 2018
Ahaha I know, thanks :) 
Basically, VSCode can do everything that this Sublime Text plug in does and more. The extensions library is insanely large. There's syntax highlighting for every language under the son, including native react and typescript support. 
&gt;under the son Hot.
You can't get a refund on your privacy 
Thank you 
Link to the repo - https://github.com/astronomersiva/niram Feel free to share your criticism :)
What does "idle game" mean?
That's a very good point. It's polling on an event loop anyway and this is just hanging another notification "if". OK thanks.
I'd considered that. The Ajax would receive the data and callback like it's supposed to. Thanks.
Sure, so let's say they sold your information to a health care company, I could see not wanting the 10 lb massive growth between my legs to be public information, regardless of how at risk for being awesome it makes me. I could also see not wanting my employer to know that I was learning about technologies that I wasn't working with, and I could see a company tracking that. Regardless, don't ask how the information could be used maliciously -- they've got it, and the concern should be damage control if they do. There is a ton of a money in meta-data. What SO has is way worse than that. That potentially have a database of everything that ever interested you.
wat? What information does SO have on me to sell?
If the input focus in on one of the form field except a button which is not a `submit` type, and its wrapped within a FORM element, by default ENTER key will submit the form. So you don't have to listen for keypress event. If you want to submit the form data without leaving/refreshing the current page, follow /u/r3dh3rring to prevent the leaving/refreshing the current page. And use AJAX to submit the form data in the background.
Do you know any good articles where I can learn how to use React with Typescript? I tried to use create-react-app with Typescript but it quickly turned into mess.
I think he's referring to the whole stack exchange family. Although I never really go too far from SO
Yep. Thanks.
Yeah same, they don't really have anything I would care about.
Prolific author that always uses `let`?
 &lt;script&gt; navigator.serviceWorker .register('./sw.js') .then(registration =&gt; navigator.serviceWorker.ready) .then(registration =&gt; { window.foo = () =&gt; { registration.sync.register("foo"); }; }); &lt;/script&gt; // sw.js self.addEventListener("sync", function(event) { if (event.tag === "foo") { event.waitUntil(Promise.resolve().then(() =&gt; console.log("done"))); } }); 1. foo() in console -&gt; print "done" 2. kill wifi 3. foo() in console 4. ... 5. ... 6. turn wifi on 7. print "done" 
So what’s better? What’s available or a new package? I’m gonna say map it. 
I'm very familiar with the history. I've met Pete Hunt (very briefly), and he did not create React. That's Jordan, who I had lunch with at Facebook once in 2013 to talk about React. I've been using React since around that time, and I am currently writing an app using React Native. I understand the point you are making — that all these frameworks use React and are therefore interoperable. However, the fact that a framework also uses React does not confer "cross-compatibility" with React Native. Compatibility implies that software written for one can be run using the other. The Proton Native website does not make any such claims, either. They may have changed some text around since it launched, I'm not sure, but when mentioning React Native it limits itself to saying it has the "same syntax" and "similar components."
Microbenchmarks in all their glory without any regard for _correct_ usage of the functions tested. Meh.
 let ticketR = /Job Id: (\d+)/, ticketIDM = 'Hidden out of Warranty | 00/00/0000 | Job Id: 4147271617', ticketID = ticketIDM.match(ticketR)[1] console.log(ticketID) Logs 4147271617
Already submitted to /r/programming earlier, and despite collecting 47 comments downvoted to 0: https://www.reddit.com/r/programming/comments/8ikp72/send_your_email_to_teamstackoverflowcom_with/
Thus total bullshit was already submitted to /r/programming earlier, and despite collecting 47 comments downvoted to 0: https://www.reddit.com/r/programming/comments/8ikp72/send_your_email_to_teamstackoverflowcom_with/
I found this while seeing some other static analysis tools he used to work on. Any excessive "let" is also in line with some other ES2015+ spec explanations I've read. As a guy that normally does C#, I find that "var" is perfect there; and "let" perfect here.
This book is a good book. But I will not recommned beginner to read it, it is too hard.
You're whining because I submitted to a different sub, since deleted, and you wanted to draw my attention to your whining there too? You also can't do text-posts on /r/programming. Here there is a description.
Es6 syntax, once you learn it, can be almost as fast. So I personally would not like the additional hassle of preparing gulp files or introduce additional complexity to the project, especially when there is more than one person working on a project.
There are too many alternatives. The most trendy alternative is Typescript (which, among others, covers types). There is also Dart and few more. From what I know Coffe does not cover types. And then there is Babel, which let's you ES6, ES7, ES8...and any other EmacScript version. I'd recommend you to stick with that. That's the actual standard. It's really tedious whenever you try to read a source and...suprise! This one is written in Typescript, or Coffe, or... Imo anyway... that's my experience with all these "languages".
Isn't `const` a better practice than using `let` if it is well suited like array or object?
Transpiling and building the dependency tree are two different things. Building the dependency tree takes very, very little time; Webpack is slow because it does other things like minifiying your code with Uglify, which reads your code, transforms it to an intermediate format (the abstract syntax tree), performs a lot of optimizations, and outputs JavaScript again. Try building a library/app with Rollup. With no plugins, it'll read all your files, build the dependency tree and output a bundled file in 40-50ms (depending on machine) and even then, most of that time is spent reading files from disk. Building the dependency tree is not slow at all.
Throwaway emails are a thing.
Thus bullshit was already submitted by the same idiot to /r/programming earlier, and despite collecting 50 comments downvoted to 0 - for good reasons (it's stupid): https://www.reddit.com/r/programming/comments/8ikp72/send_your_email_to_teamstackoverflowcom_with/
The very first chapter introduction says &gt; ... in ES6 we can _know_ better define our variables Then, a few lines later, it states: &gt; `var` are function scoped, which means that if we declare them inside a `for` loop they will be available globally. If that's the level of attention the first paragraphs get, I'm not going to waste my time reading further. Good luck
Former CoffeeScript user. ES6 looks a lot like .coffee does, and that is what everyone is using. When you say CoffeeScript is fast, I'm not sure what you are referring to. It gets compiled to a .js file, what is fast about it? Easy to write and beautiful code -- fuck all the curly braces -- CoffeeScript was a joy to use, but I'm moving on, and you should consider the same if you're going to be looking for work any time soon.
Thanks for all responds btw! I have just one more question. Whats the way to check myself after recreating some webpage? For example, i tried to imitate google page, final result looked somewhat same, but im sure i did lot of things differently than they did in original page. And even though i know i can check the source code and i always do it, but their source code is just way to complicated for me to completely understand it.
I think we're discussing two sides, i didn't intend to imply that you can re-use target-tied components, though we're certainly on the way with that with the View/Image/Text/... spec that's developing, react-native-web, reactXP and now proton, but what i meant was being able able to re-use generic components (like redux, motion, etc., basically all components whose only dependency is 'react') while treating views as native elements. Doing this in our company we've been able to successfully transfer whole applications minus the view layer.
I do agree, and I think that by the time one reaches a different stage, one would rather then reach for the YDKJS series. As dry as it is, I actually think MDN is friendlier.
A few points about this. First, when you are doing performance tests, you have to build in lots of delays. The first test(s) will always be competing with the effects of the process start-up, so you need to build in a longish delay as the first step so that the engine has a chance to settle. And whenever you are creating a lot of temporary data (such as when testing `map`) you have to build in delays between each test to allow for garbage collection as the temporary data falls out of scope. Second, I am pretty sure that running `Promise.all(a, b, c)` means that `a`, `b` and `c` will run concurrently. If `a`, `b` and `c` are not asynchronous, it shouldn't make a difference, but if one of them is, it will mess up everything for your timing. Lastly, this code... return Promise.all([ reducePerformance(posts), mapPerformance(posts), filterPerformance(posts), findPerformance(posts) ]) ...in this case is basically the same as this: reducePerformance(posts); mapPerformance(posts); filterPerformance(posts); findPerformance(posts); If any of those functions returned a promise, then the behaviour would be different. But in this case, you are executing each function in turn immediately and assigning the result to the promise chain. 
Hey guys! After another month of development I'd like to share my progress again with you guys (if you don't mind). I got the following stuff done: - Deferred rendering pipeline - PBR lighting - Point + directional lighting - Deferred shading - Hardware instancing - Environment mapping - Cubemaps - Multiple render target support - Frustum culling - Occlusion culling - Finally got my tangents and bitangents correctly calculated (a PITA!) - All direction fog - God rays - Blur/Bloom filtering
I would say that technically ES6 is a thing because I'd argue it's a "mark" that is present and reused actively in their spec and on their official properties. The confusion is as much their fault.
&gt; the simplicity gained by not having to think about variable declaration This created a shadowing issue one didn't have before. It's not an improvement. &gt; three separate ways to declare variables Practically speaking, there are only 2. `var` shouldn't be used anymore. CS outlived its usefulness. Its tooling also isn't any good. Even plain old JS does this way better nowadays.
Uhm, if I were to write something like this : for (var i=0; i&lt; 3; i++){ var hello = "hello"; } console.log(hello); I would still be able to access the variable outside of the scope of the loop (whilst if I used a let it would throw an error). Maybe I should rephrase it from "globally" to just be able to access it from outside of the block where it was declared. I probably misused the word globally as in that simple example the only scope above the loop was the global scope. I will fix the text. If, instead, you meant something else, please clarify :)
May need some context, it assumes the for loop sits lexically in the global scope; we both know the author means that vars are not block scoped
Yes, var are function scoped. For loops are block scopes so a var declared inside of a for loop will be accessible in the function scope containing the for loop block scope. In the simple example I provided there was nothing above the loop, that's why I made the mistake of saying "available globally". I will correct the text with a better explanation. :) If you feel like, you can always issue a PR to the repo. 
Sorry mate; looked like you were asking for feedback, not contributions.
Don't try to write code you don't understand (yet). Go for something really simple in the beginning, and work your way up. Most professional oages are built as components and compiled into a new page, so what you see via code inspection isn'necessarily what the code looks like, so don't fret too much about that. You will get better with experience. 
Hello, a bit late - I created async task runner with rollback and cancellation capabilities. A bit like futures, but perhaps easier to use. It should be useful for testing because transactions are rolled back automatically after the process completes, unless they are committed. https://github.com/terotests/TaskRoll/
It seems you could do with more lessons on javascript basics, but building something is a good way to learn. You should have a .js source file where all your code goes, and paste in the code by Resig above your code. Then you can use the `titleCaps` function. It looks like you're trying to run a lot of javascript code in the href of an `a` element, or in a bookmark (I see the `javascript:`). This is hard to debug and will cause you a lot of issues. If this is for a bookmark, then I would develop the code separately, and only put it into a bookmark when it's working. If this is for an anchor element, then you should use event listeners. https://devdocs.io/dom/eventtarget/addeventlistener
&gt; IMHO two way binding with those on change strategies in Angular is what makes things overly complicated. (Don't want to start a flame war, please correct me if I am wrong). Why would there be a flame war? Angular (as opposed to the old AngularJS) is one-way binding by default too.
Well, it is webpack that allows you to use modules, but considering build tools in general you would loose non-js resources, module resolution (build tools are node_modules/npm aware), tree-shaking and transpilation. I don't think native modules in browsers are that much of a big deal - in a few years when all browsers support it and IE11 is hopefully gone build tools will simply switch to native modules instead of bundles and code/splitting.
This is an excellent up to date JavaScript book. Really tough but rewarding. However, I'm stuck on chapter "Secret Life of Objects".
Nice.
It’s absolutely their fault, but the new naming and release cycle was chosen to avoid the confusion that came with skipping ES4 and going straight from 3 to 5. Instead of proposing a big release, there is an active language development process, and whatever features are in stage 4 at the time of release are included. It’s worth noting, in the interest of pedantry, that it doesn’t say ES6 anywhere in the spec. Sauce: https://www.ecma-international.org/ecma-262/6.0/
NP :)
What is everyone talking about in regards to 'speed'?! It's a language that compiles to javascript. It's exactly as fast as javascript, because by the time it *runs* it *is* javascript.
Yes, they call it the 6th edition, or edition 6. They use both terms verbatim to refer to their work. They continue on past 8. People aren't getting these numbers from nowhere -- they're straight from the ecma group.
Thanks! This is the best explanation I've seen thus far. 
 function BuildArray2(((size){ this Well just to start, you seem to have gotten carried away with the `(` there, you've got two extras.
That article is not very convincing - point 6 undoes some of the arguments made in previous points. I also think that “linters not saving you” is just a desperate rant against const - in a language like JavaScript a linter can hardly save you from obscure runtime errors.
God, I really hate that angry ranting style so many tech bloggers use these days. It definitely gets in the way of the message.
You’re also doing a lot of unnecessary processing... you can just set your array like: const array = [‘one’,’two’,’three’]
Yea, I'm still not used to Dreamweaver. I meant to remove those! Ty!
The big difference between let and var is scoping. There’s no use case where var is preferable (unless you are deliberately abusing its scoping issues). Why would you want a variable that can be called outside its block before it’s even declared? 
Just follow Brandon Eich on Twitter. Most of his feed is explaining why things are the way they are. Spoiler though, 9 times out of 10 it’s because they had like 3 days to write the original language and shit has just carried forward. 
I just posted the other day about this book. (I was pretty frustrated.) I’m a novice and started with a few intro to computer science/JavaScript on Lynda.com and then hopped into this book. Derailed after chapter four and the squirrel journal thing. You guys recommended some good beginner references (the Mozilla dev site is one of them). So I think I’m going to spend some time with that material first and then take another crack at the book. I found EJS too difficult for a compete novice. 
This week I created async task runner with rollback and cancellation capabilities. A bit like futures, but perhaps easier to use. It should be useful for testing because transactions are rolled back automatically after the process completes, unless they are committed. Under development but ideas and issues are welcome! https://www.npmjs.com/package/taskroll
I explain some things in my books: http://exploringjs.com For example: [Why does JavaScript have both `undefined` and `null`?](http://speakingjs.com/es5/ch08.html#_the_history_of_undefined_and_null)
I like class syntax. I know Kyle Simpson don’t like it since javascript doesn’t have classes and that can be confusing for people coming from other languages. I use it because the syntax is nice and as long as you get prototype inheritance (and the ‘this’ binding) It won’t trip you up
Nice
Right now, by his argument, changing let to const doesn't do anything. What I am saying is that, in regard to optimization, const at least doesn't hurt anything and in the future it CAN be optimized further by the compiler, so if you use const by default then you won't have to change it later. Other languages DO optimize in this way. Scala, for example, will optimize code mode if you use val (const) instead of var. I'm not sure what you're arguing with the rest though. Are you agree with me? Using const should tell devs immediately that it shouldn't change. Also, relying on word of mouth, especially for a codebase, is not a good idea. If you want to ensure that your objects passed by reference will not change then you can easily use Object.freeze which will ensure immutability.
I read "The Good Parts" and "Eloquent JavaScript". It lead me to being a JS Dev. Here's my site: https://spaffnerds.com
I just don't like when people do something because it can be "optimised"... especially on an interpreted language like JS... I still remember people covering their code with final classes, static everything in Java just because it could be optimised... meh I just don't think that should be an argument to use `const`. It's just a nice possible side\-effect. `const` has a semantic meaning and should be used for that. It can also prevent bugs by letting the linter tell you something is changing the value of a const variable. Now, the part in the article where he complains about not freezing the object, that's just being stupid... It's like complaining that you shouldn't use `++` because some people don't really know the behaviour of using it before or after a variable... Please... if you're working with a tool, learn it well... I shouldn't be forced to not use something because someone else doesn't know its behaviour.
I updated my original statement. In JS, let honors scoping, but var is ambiguous. In C#, var can be used to remove redundant statements: ie var variable = new Whatever(); instead of Whatever variable = new Whatever()
Agreed.
I dont see the reason for the BuildArray class. An array is already a native object to javascript with built in methods / properties, like .size, .indexOf(), etc, so you can really just say words2 = new Array() if you wanted to instantiate an empty array. If you ever need to create a class like this you would need a property inside the class for the array, like: function ArrayBuilder(size) { this.size = size; this.array = new Array(); let sizer =size; while (sizer &gt; 0) { this.array.push(null); sizer--; } // an example method this.replace(index, value) { this.array[index] = value; } // no return this; } let words = new ArrayBuilder(5); words.array[1] = 'banana'; words.replace(1, 'orange'); words.array.push('apple'); // words.array [0] == null; // words.array[1] == 'orange' // words.array[5] == 'apple' // words.size == 5 // words.array.size == 6 --------------- You could just do something like this instead: let words = ['foo', 'bar', 'baz']; function random(array) { return array[ Math.floor( Math.random() * array.length )]; } console.log(random(words)); // prints foo, bar, or baz 
In 2016, Chinese live-streaming services have banned people filming themselves eating bananas in a “seductive” fashion. *** ^^^I'm&amp;#32;a&amp;#32;Bot&amp;#32;*bleep*&amp;#32;*bloop*&amp;#32;|&amp;#32;[&amp;#32;**Unsubscribe**](https://np.reddit.com/message/compose?to=BananaFactBot&amp;subject=I%20hate%20potassium&amp;message=If%20you%20would%20like%20to%20unsubscribe%20from%20banana%20facts%2C%20send%20this%20private%20message%20with%20the%20subject%20%27I%20hate%20potassium%27.%20)&amp;#32;|&amp;#32;[🍌](https://np.reddit.com/r/BananaFactBot/comments/8acmq6/banana/?st=jfof9k8d&amp;sh=acd80944)
Nice
I have created this module this week Dialog flow module that simplify the web hook handling for your NLP application using NestJS [nestjs-dialogflow](https://github.com/adrien2p/nestjs-dialogflow)
Noooooooooise. 
Under what conditions is this useful? How many friend requests have you sent that you’ve now changed your mind?
Opinion here: I understand why The term is called CRUD, but really it should just be called managing data. If you don’t build your app to be CRUD and it involves a database of any kind it’s not going to be useful in 2018.
I think that NodeJS and JS frameworks have come a long way. We’re using Meteor and some of the stuff we’re able to do at speed blows my mind.
I did actually place it above my code and my code does actually function normally but the titleCaps doesn't seem to work if I call it in any ways it just says it's not a function. Also yes I am new to Javascript but have had some very minimal experience with it in the past.
I’m building one on the MEAN stack.
I am a programmer and I love automating stuffs. Most of the time when I create automation scripts, it is not about me but the mass people. Many people need this. Again, sending too many friend requests from a personal account is not a good thing, but in marketing \(when using multiple fb ids\) this is very useful. Again, if you have an old facebook account and you sent requests to the ones you knew may, over the years, result in a relatively big \(even 100 is a big number in this case\) list of unaccepted requests. Finally, why do things manually that we can automate? I will automate 10 clicks even that is a very small number :\)
I didn't know I could use the [1] in that area, very nice. Also yes I solved it earlier using the /i from another comment.. On the page it shows as "Job Id:" but I believe it was actually pulling "JOB ID:" which was throwing everything off..
I'm resolving the actual issue here which is your language. I don't care about people being \(as you perceive it\) snarky, I care about being straight up offensive and degrading towards others for no other reason than you being mad. It's a highly immature and toxic way of dealing with issues, especially when it's on a semi\-professional subreddit. If I see this kind of behavior again, I won't think twice about straight up banning you. Now you're warned.
That's like telling someone who is asking a Vue question on Stackoverflow to use React instead.
Why do you keep posting this to different subs multiple times and deleting it when it goes into negative karma? No one cares about your vendetta against StackOverflow.
He's submitted it to /r/programming *multiple* times - he keeps deleting it and re-posting it.
[irony mode: ON] Coffeescript will be remembered like a historical curiosity - it came out at a time when Ruby was the hipster's platform of choice (twitter was originally written in ruby, and so were many others) and the ECMAScript committee was getting nowhere (ES4 anyone?). Many tools were created to make web devs' life easier - things like sprocket, capistrano, haml, sinatra, compass, jekyll ... (ask your dad what they were)... and even vagrant, chef, puppet... ruby-like things were everywhere! After those initial successes, the ruby hipsters got sooo big headed they decided they were going to rewrite the language of the web itself: Javascript! First they started by removing the semicolons (the infamous Javascript "Standard" Style), and then, off the back of that success, they created a new Ruby-like language that transpiled to JS. And it _almost_ worked. ENTIRE frameworks were written in CS (OK, one - Chaplin, itself built on top of Backbone). But luckily just when all looked lost for JS, the ECMA committee came to their senses, stopped fucking around, and delivered ES6. Which copied a lot of ideas from CS, but who cares? At the same time node, golang and others took the shine off Ruby on the server side, and pure js tools like grunt, gulp, node-sass, npm, docker put ruby back where it belong - and with it CoffeeScript. We can now say that web development is virtually Ruby-free, or rather, only ruby-like technologies are only used by people who actually want to. For the rest of us, there is node **TL;DR** CS gave the ECMA committee the kick up the arse they needed to get ES6 out, and has since lost its usefulness. PS: apologies in advance for all the glaring omissions and mistakes
Not really, there aren't actually any practical advantages using one over the other, not in performance nor anything else (except for the obvious use cases like `const DEBUG = true;` at the top of your file) It's purely down to user preference
&gt; it's just a good programming practice Based on what metric?
'var' is pretty much deprecated, and should no longer be used. The discussion is between let and const. I must say - I have never been convinced either way, and I have tried both approaches for a few months as a test. There was very little practical difference, and of course none performance wise whatsoever. Code written using `const` didn't have fewer bugs than that using with `let`, wasn't any easier to reason about, etc. If anything it got in the way - I have to remember which vars I could and which I couldn't mutate, or as the spec changed I needed to go back and change const to let. In the end I find it easier to just use let everywhere (except for primitives like config values, IP addresses, that sort of thing). But if I work in a team that insists on `const` that is fine too.
This book nearly took me away from JS when I was a begginer. Then I found exploringjs and ydnjs
I am reading this. It's a great book but some topics are hard to follow, almost all coding books are. It's definitely not if someone just started coding in JavaScript, I've only read five chapters and I started more than a month ago.. I read it when I feel like it, definitely book make some points that I've never considered, so worth reading and it would prepare you to read "You Don't Know JS" book series by Kyle Simpson. I personally believe learning by reading is far superior than watching Tutorials. Most of time you have to read documentation to implement new technology. Believe me if you just read 4-5 books and understand them, it would give you experience in reading technical stuff. You would be able to go through any documentation like a pro. Thank You
I think VENoM stack is a little catchier.
Is this your homework? ;)
 [...document.links] or Array.from(document.links) 
Principle of least privilege 
Tried learning JS with this, failed miserably. Learned JS on my own, returned a year later, this book is awesome.
Try let linkArr = [].map.apply(document.links, l =&gt; l)
`Array.from(document.links)`
I read this after completing two modules ok CodeCademy. I think that was the perfect time. I knew a lot of syntax, and could write sloppy coffee. This book really bright me to the next level at that time.
Basically a guarantee that I won't read it. Makes me think the author is a child.
Ahh i remember reading this book from someone suggesting it....how to write fibonacci sequence when you finally learned what a variable is the day before....good times. 
Redux is a store that enforces serializable inputs and 1 directional dataflow... RxJS doesn't do anything like that, its simply a very powerful tool for processing data. Perhaps you can clarify more what you think overlaps so we can work with specific examples.
Use `Array.prototype.slice.call(...)` instead of `[].slice.call(...)` since the latter will create a new [useless] array in order to access the prototype method. Regardless of which of those you use, though, both should work as you're expecting them to. I just verified in the Chrome console on reddit: `Array.prototype.slice.call(document.querySelectorAll('div')).length //&gt; 2030` `[].slice.call(document.querySelectorAll('div')).length //&gt; 2030` So not sure why your code isn't working (without seeing more of it)
Keep in mind this isn't supported in IE, so will need a polyfill if IE support is needed
I still don't understand. ELI5?
Hyper hypertext markup language, which genius thought of that? Sorry, I don’t have an answer to your question - just thought that sounded pretty dumb
&gt; I just don't like when people do something because it can be "optimised"... especially on an interpreted language like JS... JavaScript isn't interpreted -- at least not the major implementations which are JITed. 
You need to resolve this by using Sudo in front of your command.
lit-html is a replacement for vdom, and is a little lower level than what something like react does. It may someday be the basis for a framework like react though.
When in doubt, look it up on MDN: https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS Im not an express expert but I assume that there's a middleware that adds access-control-allow origin and access-control-allow-methods headers. btw, if you are fetching just json, without credentials, it should be deemed a simple request and not be preflighted(it depends on the headers).
Totally. I guess it shows a difference between programmers who went through CS degree or practioner. I think using static electricity initialization is always a good practice and manages memory better.
Yeah, there's very little in programming that is truly "personal preference." There might be situations where the pros/cons come out to a wash such that it doesn't matter what you choose, but very few things are purely aesthetic taste. 
I mean...why can’t we just use JavaScript? :/
Okay, I tried that, now I have this going on: npm WARN webpack-cli@2.1.3 requires a peer of webpack@^4.0.0 but none is installed. You must install peer dependencies yourself. So I tried sudo npm install \-g webpack and got: node-pre-gyp ERR! Pre-built binaries not installable for fsevents@1.2.3 and node@10.1.0 (node-v64 ABI, unknown) (falling back to source compile with node-gyp) node-pre-gyp ERR! Hit error EACCES: permission denied, mkdir '/usr/local/lib/node_modules/webpack/node_modules/fsevents/lib/binding/Release/node-v64-darwin-x64' gyp ERR! clean error gyp ERR! stack Error: EACCES: permission denied, rmdir 'build' gyp ERR! System Darwin 16.7.0 gyp ERR! command "/usr/local/bin/node" "/usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js" "clean" gyp ERR! cwd /usr/local/lib/node_modules/webpack/node_modules/fsevents gyp ERR! node -v v10.1.0 gyp ERR! node-gyp -v v3.6.2 gyp ERR! not ok node-pre-gyp ERR! build error node-pre-gyp ERR! stack Error: Failed to execute '/usr/local/bin/node /usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js clean' (1) node-pre-gyp ERR! stack at ChildProcess.&lt;anonymous&gt; (/usr/local/lib/node_modules/webpack/node_modules/fsevents/node_modules/node-pre-gyp/lib/util/compile.js:83:29) node-pre-gyp ERR! stack at ChildProcess.emit (events.js:182:13) node-pre-gyp ERR! stack at maybeClose (internal/child_process.js:957:16) node-pre-gyp ERR! stack at Process.ChildProcess._handle.onexit (internal/child_process.js:246:5) node-pre-gyp ERR! System Darwin 16.7.0 node-pre-gyp ERR! command "/usr/local/bin/node" "/usr/local/lib/node_modules/webpack/node_modules/fsevents/node_modules/node-pre-gyp/bin/node-pre-gyp" "install" "--fallback-to-build" node-pre-gyp ERR! cwd /usr/local/lib/node_modules/webpack/node_modules/fsevents node-pre-gyp ERR! node -v v10.1.0 node-pre-gyp ERR! node-pre-gyp -v v0.9.1 node-pre-gyp ERR! not ok Failed to execute '/usr/local/bin/node /usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js clean' (1) npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.3 (node_modules/webpack/node_modules/fsevents): npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.3 install: `node install` npm WARN optional SKIPPING OPTIONAL DEPENDENCY: Exit status 1
I don’t understand, in 2018, why we as webdevelopers have to concern ourselves with these annoying technical and security related obstructions. It’s like a race car driver having to know the intricacies of how rubber tires are made. Imho...
I don't know, maybe because it's our job and we chose to specialize in web development? I agree some of these things aren't the most fun parts, but that doesn't make them less important and other people will think differently.
Yet most of us don’t actually concern ourselves with the physical network protocols. We “just expect it to work”. My point is CORS sure feels like one of those things, and the less time we spend on low level plumbing like this, the more time we have to spend on actually creating value. That said I realize CORS isn’t going away right now...
what's the alternative? fixing it in http 3 and upgrade the entire internet? cors rules are a patch that fixes a security hole introduced with ajax requests. the clean fix would be to either disallow cross origin scripts (breaking thousands of sites) or allow all of them (leaving thousands of sites with security vulnerabilities). websockets were introduced later, and chose the second route. Its assumed anyone writing a websocket will check origins on the server side. 
...what? JavaScript is definitely interpreted.
Because Typescript has sucked up all of the oxygen in the room named "things that are sort of like JavaScript that compile to JavaScript"?
Have you gone through this? https://docs.npmjs.com/getting-started/fixing-npm-permissions
100% false. There are implementations of JavaScript that are interpreted (SpiderMonkey, which uses bytecode IR that can be interpreted), but, for example, v8 is _only_ JITed. There is no interpreter in v8. Rhino uses JVM, which is only interpreted for uncommonly called methods and is mostly JITed. It would be useful for JavaScript developers to learn about the execution model for the code they write. It's a huge, gigantic misrepresentation to call JavaScript interpreted. 
I personally think closures are easier to refactor. If you need an extra context parameter, you can even wrap things into another closure. You don't need to do the ugly thing of copying constructor arguments to the instance. With "closure pattern", "methods" available feel more transparent as a couple of object packs, instead of "magic" functions that somehow are present there from the class you extended, which you have to navigate up many levels to find out. I'd only use classes \(or even prototypal inheritance\) if the task needed critical performance \(say, an object that is instantiated 60 times per second\).
They really aren't the same, though. `var` is about type inference in C#, and that's really it. It doesn't change scope or mutability in C#.
&gt;You can only make changes to the object that your pointer is pointing to. And it's correct, you can't change the pointer itself, because it's fucking constant in this case, only the object it's pointing to :) Sounds like you're the one illiterate here tbh.
CORS - Understanding the many ways to bypass it
I said you were correct, just that people did not understand that, neither did I, so obviously, you're in the wrong. If your message is received and understood the wrong way by the majority, you fucked your communication up, not your readers.
You think just buy a real world copy of eloquent JS? The YDKJS has a lot of parts to it that I can’t afford right now. Would you say those two are the best?
You may be interested in [`redux-observable`](https://redux-observable.js.org/), though I would recommend against using it. There is also [`CycleJS`](https://cycle.js.org/), though it doesn't use React to my knowledge if that's what UI library you intend to use.
Yeah, I think so. Both of them are fantastic. 
False equivalence, sorry. Phone numbers are a matter of public record, unless you pay your provider to make it private. Ergo, they are *less* private than email addresses, to begin with. Email addresses and Reddit usernames are both anonymous. You're making a mountain out of a non-existent molehill.
Thanks. I guess I should wait a bit until the latest version of Eloquent JS is available then.
I agree. He even says &gt; It's probably still a good idea to communicate that you really don't intend for something to be changed. That’s like 90% of the bindings I use. It you’re reassigning bindings willy nilly then that’s a bad code smell as far as I’m concerned. 
That is quite an apt summary of ruby history.
Not a fan of reverse engineering eeh
This is really impressive piece of work. Thank you very much for the free HTML version.
Dude you are reading the values of the options, you probably set them wrong. INSPECT YOUR OPTIONS AND CHECK THAT THE VALUE ATTRIBUE MATCH THE CONTENT OF THE OPTION
Yes, here's one: [https://michalzalecki.com/use\-rxjs\-with\-react/](https://michalzalecki.com/use-rxjs-with-react/)
&gt; You can only change the thing the pointer of your variable points to. See, that's the problem. It has nothing to do with fucking pointers. We all know what a pointer is, it's literally Comp.Sci 101, there's nothing special about goddamn pointers and you're not special for saying you know what it is, and it gives you no right to belittle people. However your sentence, before I reread it, read to me \(and apparently a lot of other people\) like the following:You can only change what the pointer of your variable points to. Now THAT becomes an obviously wrong statement. Again, rereading it I realized that by "the thing", you were trying to say "the object", and then it made sense, but "the thing" literally read to me and others like either a spelling mistake, an editing mistake or a foreign language mistake. THAT'S why you were getting the feedback you were. You could have used actual programming terms instead of "the thing". You ended out becoming VERY toxic and hostile over somebody who simply stated that they thought you had it wrong due to it not being clear what you meant. That's why I initiated this conversation with you, as you blew this and multiple other parts of our correspondence completely out of proportion with ad hominem attacks.
that was it! Thanks!
Thanks for the info. I just read about it and V8 does in\-fact JIT\-compile the code. I though it was interpreted with some JIT\-interpretation on the most cpu intensive code, but I was wrong. &gt;It would be useful for JavaScript developers to learn about the execution model for the code they write. I do some JS programming but it's not my life... That's why I haven't read much about it. But still, the execution model should not change the way you code... You should always aim for scalability and readability instead of programming for the compiler... That's the machine job. Also, how do you know where your code is going to execute? V8? Chakra? Nitro? Rhino? 
Cheers!
Does const provide "immutability" for all types though?
&gt; There might be situations where the pros/cons come out to a wash such that it doesn't matter what you choose ...which is just another way of saying "personal preference"... 
&gt; always favor immutability Is `const myArr = [];` really immutable?
 const myArr = [1,2,3]; ... myArr.length = 0 How does the principle of least privilege help here?
MDN and Standford.edu both say "JavaScript is an interpreted language, not compiled". You should contact them to correct them.
I haven't, but I'll try it out now. Should I be worried about it telling me to back up my computer or is that just precautionary? And when I call npm in the future do I have to specify the new directory? (Sorry for the the questions, I'm not too familiar with the command line.) 
They're light frameworks based on template literals. hyperHTML has a bunch of [examples](https://viperhtml.js.org/hyperhtml/examples/#!fw=React&amp;example=Hello%2C%20world!) comparing to various frameworks. [lit-html](https://github.com/Polymer/lit-html#overview) has a quick overview and a ~15 minute video that explains the motivation behind using template literals.
I'm honestly really new to these things, thanks for your feedback. All this library does is order the keys of the provided object and use it as a reference to push the values into the buffer \(while assigning them proper tags, e.g. if string/bool/int, with pbf's api\) and pull them out afterwards. The ordered keys allowed me to FIFO the values in and out the buffer and restructure the object on the server\-side and client\-side without having to send the object keys anymore in each requests, hence making the set payloads smaller. So the goal isn't really compatibility with proto files, but instead to take advantage of protocol buffer's encoding of values into the buffer without having to use proto files. Is this a bad use of pbf's protocol buffers api? \&gt; you should be using a different binary format May you please expand on that, what other options do I have?
The fact that you can alter the values contained within myArray means that it absolutely is not immutable. The fact that you can’t redeclare myArr does not mean that it is immutable. I suggest that you make some sort of attempt to understand what immutability actually means before you preach about its virtues.
No, and it isn’t meant to.`const` simply means that that the reference always points to the same object. It says nothing about the values contained within said object.
It really depends on the engine. V8 Chrome JIT-compiles the whole code apparently. Rhino (Mozilla’s engine) interprets it and JIT-compiles the most intensive parts. I was wrong by saying it is interpreted. JS is a language, in the end... it can even be compiled into WebAssembly. Just like python or lisp. They’re usually interpreted but there are a lot compilers out there to generate machine code.
getify (Kyle Simpson) calls JavaScript's classes "fake" because the inheritance is dynamic, i.e., prototypes can be mutated during runtime. Python also allows monkey patching class methods, but you don't hear anyone calling Python's classes fake. Dynamic inheritance might confuse people used to it being static, but it enables metaprogramming. Eich's idea behind the dynamism was to allow users to enhance the language with their own patterns, but the result was that JS had too many incompatible class systems like `React.createClass()`. Adding the class syntax standardized what people were already doing, and it also has the benefit of enabling static analysis. A basic reason for why custom class systems were favored was that the power of prototypes comes at the cost of verbosity. The class syntax beats prototypes if only for being more terse and hence readable. There is a stage 3 proposal for extending the class syntax with instance fields and a stage 2 proposal for static fields and decorators. An interesting aside is that Eich chose prototypal inheritance from Self for JavaScript to avoid competing with Java's classical OO.
It’s rubbing off on the community, too, I think. The comment section here is downright hostile toward differences of opinion.
https://github.com/ngrx
Right, because it's *reference* immutability. This is how JavaScript works, this is how Java works, this is how Scala works, this is how Rust works, and so on. I suggest *you* learn the difference between references and values. If you want a value to be immutable, it requires an extra step.
What OS are you running?
What is the benefit of this vs normal git?
`getElementsByTagName` returns an HTMLCollection, not an element. Collections don't have `href` attributes. Use `querySelector` when you're only selecting a single element: const myLink = document.querySelector('a'); If you need to select multiple elements, you should almost always use `querySelectorAll`, which returns a static NodeList, that can be directly iterated over, which is much easier to work with than an HTMLCollection. Feel free to completely forget about the `getElementsBy*` methods.
macOS version 10.12.6
&gt; I know that Kyle made it clear why the class and prototypal inheritance are kind of faking OOP Though, Kyle was actually wrong about that. He based his claim on the assumption that Java's implementation of classes and inheritance is THE _definitive_ implementation. But actually there's a variety of implementations across a variety of languages, some of which pre-date Java and even C++. In Python, Ruby, and Smalltalk, for example, a class is itself an object (a building, not a blueprint), and inheritance is done by delegation -- just like in JavaScript. Kyle thought JavaScript's implementation was unique, but he was mistaken.
Thank you, you rock!
N00b here I agree. It gets recommended to noobs all the time, and isn't a good recommendation imo.
How does reading MDN and pretty much every source online translate to you to not taking the time to learn how it works? v8 isn't the only engine out there. If v8 is the only engine with compiles JS then it is the odd one out.
 &gt; Yet most of us don’t actually concern ourselves with the physical network protocols. A webdev that thinks they don't need to know the OSI model. I have seen everything. 
Can you explain the syntax for line 3 in your code first code block? It's confusing me a bit. I'd write that like this: `const allCompleted = this.todos.every(todo =&gt; todo.completed);`
It destructures the argument; if you're only going to use one particular property of an object, it can be a good idea to only extract that property, rather than have a reference to the whole object and then access one property of the object.
CORS only supports an explicit host name or a * which is a shame. Anything more sophisticated requires you to write server-side code. Not that it's rocket science, but it's still coding and might have bugs and it means you can't offload it to your web server. Every project I've done required writing a CORS filter to whitelist all hosts for a given domain. If I could just put a wild card pattern in the header, it would be much simpler.
I've been toying around with automatic bin sizing heuristics for histograms, and released a module today: https://www.npmjs.com/package/compute-histogram
No, look, the point is that the ECMAScript specification doesn't specify the implementation. When JavaScript was originally written, yes, it was implemented as an interpreted language. As I mentioned in my original comment, SpiderMonkey still uses an interpreter, however, it *also* uses a JIT. v8 isn't some "minor" implementor. It has a 60% desktop browser market share and 100% of the server side code. When v8 was originally written, it used some kind of bytecode, but at a certain point, it was rewritten to be 100% JIT. The reason this is important is that the OP was suggesting that optimization doesn't matter in an interpreted language. Regardless of whether *that's* true, it's hugely misleading in the context of a JIT. If you are writing a game in JavaScript in the browser, or performant server-side code in Node, it's critically important that you understand the conditions under which your code will run fast or slow. For example, "arrays" have different backing data structures, and the profiler in the JIT is able to tell whether the array is "sparse" or "holely" or "dense". In the first case, it'll be allocated as a hashmap, but in the second, it will be allocated as an actual array, which allows the JIT to perform further optimizations regarding access -- i.e., rather than doing a lookup in a hash table, it could optimize to simply doing pointer arithmetic. Code inlining is another example of an important optimization that doesn't happen in an interpreter. If the JIT sees that a method is super "hot", i.e. run a lot of times, it might inline the code into the call site, eliminating a stack frame and potential additional indirection on the method call. Using a JIT is important for JavaScript, because it's not just a silly language used to do stupid animation. It *needs* to be fast in order to write things like games, or single page applications, etc. For example, when Java was first written, it was an interpreted language, but now it uses 2 different compilers in addition to an interpreter. Java code that is compiled using the C2 compiler can be up to *1000x* faster than interpreted code. While it's not necessary for every JS developer to know all the ins and outs, if you're trying to write fast code, it's important to understand the situations in which the JIT can "bail-out" or fall back to using less efficient code. The OP is right that you probably should not use `const` on the basis of optimization. In general, it's a bad idea to try to trick the JIT into doing something specific, since unless you're intimately familiar with the implementation, it's very hard to predict exactly what it's going to do. However, it *is* possible sometimes to use this kind of hinting to help the compiler. For example, asm.js, the predecessor to WebAssembly, often declares numbers as things like `var num = 100 | 0`, which allows the profiler to basically assume that the number is a certain width (32 bit?), rather than the normal 64-bit IEEE-754 double. Sorry, I was being a bit rude earlier. I've had a bad day.
Transpiling `async`/`await` currently requires `regenerator-runtime`, which is pretty heavyweight - some recommend avoiding it entirely, for now. `async`/`await` *do* still use Promises underneath.
I found that some users don't even know an error occurred. E.g. an ajax request failed and the next paginated data didn't load. I agree you should be using rollbar or stackdriver for non-trivial sites. But showing the user an unexpected error occurred can be nice too.
Yeah, when nested promises require more than one level of indentation, `await` is definitely easier to read. Babel is working on a nicer method of transpiling it, but who knows how long it'll take to get added.
That's okay. Thanks for the details. I'll do some more in depth reading about it. I do, at this point, think that my sources might not be 100% accurate in the interest of simplifying it for people wanting a basic explanation.
Hope your day goes better tomorrow.
You can't run "normal git" in a browser.
In the meantime, tsc with tslib is way more lightweight.
Async / await *is* promises. Promise.all is still useful. Etc.
But why do I want git in the browser?
they both have their places Example 1 You need to get the results of two asynchronous requests (example json data) that do not depend on each other, and then use both to say combine them into one json object. You would use promises to do both requests but not have to wait until the first is finished before starting the second. You could then use an await to wait until both are completed before continuing.
Possibly for some sort of online code editor maybe?
This would be nice for browser-based development environments, except that GitHub doesn't set `Access-Control-Allow-Origin: *` to allow web apps to access it via AJAX. I feel like CORS is the #1 thing standing in the way of moving a lot of desktop apps to the browser.
Github’s public API allows cross origin requests, doesn’t it?
Hi, I made the toast stick around when you mouse over it. Thanks for your feedback.
It looks like there's a GitHub-specific JSON API, but that's not the same as just allowing cross-origin requests to the HTTP Git URLs themselves. But that's an issue with `git`, regardless of where it's hosted.
Just good practice (sometimes) - makes for less syntax noise. If the item being iterated over isn't obvious and you want to assign it a variable name to improve readability even if you're only accessing one property, that's fine.
Sorry, I don't know Mac and Googling it makes reinstalling node on Mac look pretty convoluted. Maybe try the node subreddit? 
What, dude it is our job to know all this, any monkey can write html. 
Thank you, I'll try that, I appreciate your help. :\)
web app that streams media like movies, music, tv etc https://github.com/ridhwaans/homehost
Helps 99&amp;#37; of the time, doesn't cover 100&amp;#37; = not worth using at all. That will lead to a very productive developer carreer.
Why not? Have you seen code written with async await instead of callback promises? You are missing out.
Yeah those were the ones that voted for jquery
None.js 😂
&gt; Its assumed anyone writing a websocket will check origins on the server side. Which, imo, is worse, because that's not always a safe assumption to make. I very much prefer the secure-by-default nature of CORS.
When you open you're console, you only have access to the outer-most scope, and the `object` variable defined in the outer-most scope has *not* been given a value, and any variable without value is `undefined`. The `object` variable you have in `displayWeather` is *not* the same as `var object`, it's scoped differently. You don't need the `var object` line at all. If you wanted to make the object being passed to the `displayWeather` function accessable outside of the function so you can view it in the console, change one of the names of the variables and assign the outer variable to the inner one, like so: var object; function displayWeather(data) { humidity.innerHTML = "Humidity: " +humidityPercentage(data.currently.humidity) + "%"; //More code using data object = data; }
Is the session cookie being correctly saved and sent with subsequent requests by the browser?
Where do you come up with these var names?
either way should work, can you throw an example up on codepen or similar so we can check it out easier? did you check devtools to see if the element was there? might just be a style issue
Sure! Glad you like it.
Brill :) Sorry if I was a bit rough on my review, I've had a shouty few days :)
&gt; Since nothing modifies anything, you rarely have to worry about private data: you know your data you are holding a reference to won’t change. Immutability doesn't alleviate the need for private data. You still need to make sure the new data you produce is valid. For example: const aDate = { month: "Feb", "day": 28, "year": 2018 }; // Somewhere in your codebase, a pure function that doesn't handle the data correctly const addADay = (date) =&gt; { return {...date, day: date.day + 1}; }; const newDate = addADay(aDate); // bad; invalid data
I can tell you that is a Font Awesome icon. You can tell because it shows 'fa' which stands for font awesome. I just happen to know that and it's fairly common, but no one should expect that to be known. There is a distinction we could make. There is a button and rather than having text on it, it has an icon. The button itself is styled to be invisible so you only see the button. You could go to fontawesome and find a way to get the icon, or you could take another route. It's 11:45pm here, so I will leave this page open but I'm going to bed after I post this. I will give you some example code and it should allow you to better reason about it. First, there are two types of clicky-things in HTML. One is a &lt;button&gt; tag and the other is an &lt;a&gt; tag (anchor tag). Buttons are usually used to toggle or activate things on the website. Anchor tags are usually used to link out to another website or another page in your site. In your case, you want to use a &lt;button&gt; tag because you aren't linking out to another site. I want you to try something. I don't know if you are familiar with the Dev Tools Pane or if you even use Chrome, but this works in Firefox too, it just loads in a different spot. Just skim past here if you already know, but in your browser, press F12 and it will load the dev tools pane. This is some 100% next-level shxt. Make this pane your friend 24/7. Assuming you are using Chrome, when that pane comes out, take a look at the top-left of the pane. See that little inspect element button there? Press that. Don't worry, this is totally non-invasive stuff. You can click and clack all day in there no worries. I recommend getting more familiar with all that stuff. Right beside that inspect button is the mobile mode button. It allows you to toggle moble mode and see what the website looks like on mobile devices. It's very handy for testing purposes as you skill up more. Anyway, hit that inspect button and now move your mouse cursor around on the page, without clicking anything yet. Just mouse over some stuff. Do you see how it's displaying some information about each "element" ? You can see the element type, the active CSS classes, the size dimensions, and if you look at the colors, you can even see the margins and paddings on each element. This is incredibly important stuff as you move forward. You will become super good at this stuff. Still don't click anything yet. Let's call this inspect mode. You are just inspecting stuff. While you are moving the mouse cursor on top of elements, do you see how it's kind of changing and highlighting stuff over to the right in that Dev Tools Pane? This is another extremely important thing. It's highlighting the element that your cursor is on top of. This is about to get slightly more advanced, but I think you can handle it. If you already know this, how was I supposed to know :) If not, I will give you hyper-legit data. Ok, now mouseover that pause button and click on it. WHen you click on things while in inspect mode, it doesn't function like a normal click. Instead, it just exits inspect mode but leaves that element in the dev tools pane selected. This is a difficult one for us to discuss because it has the ::before pseudo-class on it. You can Google that to satisfy your curiousity, but it's related to CSS. It means that &lt;i&gt; tag is getting extra CSS properties and they are applied _before_ the element is placed in the DOM. I would like if you could research "what is the DOM". You need to understand nodes and the document. It's the most underlying and most important thing about everything you are doing right now. You are working in the DOM (document object model). I can't explain in terms you would understand. Well maybe I can. The DOM is a tree, so it has a root, which is like the top block on a pyramid. We have to start talking about parent &gt; child associations because thats how the DOM works. I will let you research it and I will give you what you care about related to this button. I can't stress enough how important it is to understand how the DOM works, what it is, why do we care about it. Everything will make more sense. It has to do with how the browser painted that stuff on the screen. There is a hierarchy to it. So, now, the next thing you care about is what we call "nesting". That Font Awesome icon is nested inside the button. In the Dev Tools Pane there, see how it looks like: &lt;a id="play-button"&gt; &lt;i id="pauseplay" class="fa fa-pause"&gt; ::before &lt;/i&gt; &lt;/a&gt; The way we describe that is the &lt;a&gt; tag is the parent of the &lt;i&gt; tag because the &lt;i&gt; tag is nested inside the &lt;a&gt; tag. The id= and class= things are called properties, but everyone calls them props for short. Sometimes, they are called attributes. IDs must be unique but classes don't have to be. That &lt;i&gt; tag actually has two classes on it. That's why the space is in there. It has the "fa" class and the "fa-pause" class on it. We are getting close to as far as I can help you because there is some other stuff controlling that button. It's probably why you are having the trouble you are. Most likely it is some JavaScript or maybe HTML5. I can't tell because I can't see the code. Check this out: https://www.w3schools.com/tags/tryit.asp?filename=tryhtml5_audio See that controls prop there? Try experimenting with that. I have no idea where you are at so try that stuff out and see where you end up lol. It's like puzzle after puzzle TBH.
Hell yea, this is great! Thank you!
What I would have expected from the article is something about: - What does CORS do? - Why do we need it? - How and what security issues does it solve? - Examples What I got from the article is: - The many ways to disable CORS.
HyperHTML was the first use of template strings instead of vdom, then Google decided they were going to do the same and copied everything without giving any credit. lit-html is an inferior clone of HyperHTML.
Do you need to serve over https? Seems your cookies are configured with secure:true
Thanks :)
All of them. They seem to be completely random.
General rule of thumb is that for loop or reverse for loop is much faster than any other loops in JavaScript. This is what you kind of see in these tables. There are advantages to map, reduce, filter etc.
Transpiling it is only relevant if you're targeting IE11. `async/await` is supported in Edge/Firefox/Safari/Chrome/Opera/Samsung Internet, and has been for a while now.
It's a different take on solving the same problem that VDOM solves; declarative DOM construction. You write your DOM how you'd like it to look, and you pass values directly to the elements (either as properties or as attributes) in the DOM (like with React etc.). This way, your mental model of the DOM is simpler, since you don't have to juggle `document.createElement` and `document.querySelector` etc.
YDKJS is free on GitHub on Kyle Simpsons account.
This weekend I created React linear gradient button component for practicing building a modern React component. [GitHub Repo](https://github.com/xxhomey19/react-linear-gradient-button)
This is very helpful, thank you so much!
All of Google's operations (including their data centres) are 100% sourced from renewable energy: https://environment.google/projects/announcement-100/
Then don't nest your promises. Always assign each one to a variable. This is also how you can create arbitrarily complex promise graphs easily. When a promise depends on a previous result just make the new promise variable assignment that creates it depend on the one or many (using `Promise.all`) promises it depends on (using `.then(...)`.
Would be interesting to show the results over multiple Node versions (the article makes no mention of the version used). I suppose a newer V8 version has introduced some optimizations compared to the 2015 situation, which might explain why the tables have turned. For what it’s worth, I don’t think it’s too crazy that lodash was faster, because it doesn’t need to handle shallow arrays and their implementation doesn’t need to cross relatively slow JS/C++ boundaries unlike a naive native `map()` implementation. Of course, a clever JIT could just special-case the `map()` call and get rid of the lambda overhead altogether, which is what I hope V8 did.
Thank you so much. Sorry I couldn't put it on CodePen (too many other files that might be needed).
Isn't the [no-cors mode in fetch](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch) exactly for this purpose
CORS isn't only implemented client-side. 
That is quite a terrible summary of ruby history for anyone whose head isn't permanently stuck in the web
I have no idea why:`dictDefaultMessage: '&lt;img src="logo.png" alt="upload" height="400" width="400"&gt;',` wouldn't work for you.
It’s always better to just read the MDN docs. 
Thanks SOOOOO MUCH! I made the stupid mistake of using double woutes instead of single in JavaScript! Thanks again!
I have another quick question. I solved the scrolling problem and now only the todo elements are scrollable. Before I only had `overflow: auto;` on `.todo-app` which made the whole app scrollable. By adding `overflow: auto;` to `.todos` (the ul that stores todo elements) I solved the problem and now only the todos are scrollable. However, that solution created a new problem: every time I toggle or delete an element and `view.displayTodos();` runs, once it empties the innerHTML before re-adding all of the todo elements, my app always scrolls to the top. That's only happening in Chrome. If I delete or toggle an element in Firefox, the scroll position stays the same. Do you perhaps know how could I fix that?
I’m fairly certain that Mt. Everest is taller than 9.7 kilometers.
When I ran these tests and saw it took 30ms on my machine to map over only 10,000 items in lodash, my bullshit meter broke. Mapping over 10,000 items in any modern library should never take more than a a couple milliseconds at the most (except DOM elements, which are a different problem). If you have more than a million items, I'd believe it. Running it on a mobile device? I'd believe it. You have some crazy complex callback, I'd believe it. This? No way. So, in this case, the total time for lodash **includes the time spent loading lodash**. When you account for that and just test the map, you get much more reasonable execution times and more plausible perf differences. I'd be glad to do a pull-request, but I don't know how to fix these tests because I have never worked with meter. But instead of doing this: // _.js const j = require('./j') const _ = require('lodash') _.map(j, item =&gt; { return item.num }) ...load the dependencies ahead of time and inject them into your tests (and allow the engine a couple seconds to settle after starting any tests, and a second or two between test runs to allow for GC as data falls out of scope): // _.js (_, j) =&gt; { return _.map(j, item =&gt; item.num); } Also, for the beginners reading these things and using it to decide on native vs lodash... stop right now. The performance difference you see here is almost always irrelevant in most applications. Unless you are dealing with truly massive amounts of data or have crazy amounts of recursion, this kind of test is just a fascinating diversion. You may be able to eke out a millisecond here or there, but performance bottlenecks are NEARLY ALWAYS found in your own code.
With ES6 you can do this: const newArray = [...whateverIterableObject]; Pretty sure HTMLCollection is iterable
Good idea, that's an easier name to call
You'd be wrong, it doesn't even hit 9 km.
If you're using fetch or axios be sure to pass `{credentials: true} // (fetch) {withCredentials: true} //axios ` as an option, otherwise you'll get a new cookie each time.
You are correct! I totally had a brain fart. Now how do I delete my dumb reddit comment from before...
Facepalm.
If you can't think of a reason, this isn't for you.
So you mean, with eager loading, lodash is faster than native map?
Micro\-benchmarking is hard. * You should run your test multiple times and average over the results. * You should make sure that you're measuring the right thing. Right now, the measurements for lodash's `map` also include the time spent loading lodash. * You should "warm up" the tested function so that the JIT compiler will optimize it before starting the benchmark. Otherwise, you'll be testing the non\-optimized interpreted version. If you really want to do a micro\-benchmark, use a framework. You can quickly make a test case online with [jsperf.com](https://jsperf.com), or you can make one in Node.js with [Benchmark.js](https://benchmarkjs.com/) \(which powers jsperf\).
I'd recommend react, it's the more cpmmonly used one. Also I like it, it feels pretty neat to use
At work also BBjs and are now transitioning to VueJS. Because like BackBone its more like vanilla JS in my opinion. But react was a close second. 
I tried React before and first thing I noticed coming from Backbone is that HTML is inside the JS files compared to separation I used to do. Is that a good thing?
I did try both. What I didnt like about Angular is Typescript. What I didnt like about react is the inclusion of HTML in the javascript files. 
Well i developed using both and it's really hard to pick one. Here's my take on this. Reactjs is really sweet if you like JavaScript. There's a ton of vanilla JavaScript code going on there, basically a lot of what you know you'll be able to reuse. I don't think it's hard to learn react, i understood what was going on pretty quick. The downsides are that they have their own language for templating (jsx i believe) which you write within JavaScript. Lots of people find that inconvenient, but it doesn't bother me. There are no integrated foreach or ifs in jsx, so you need to get crafty with vanilla JavaScript. Also, i find react is pretty thin in a sense that they don't have their own http modules or routing. Angular on the other hand has all of this and more. It's a complete framework where you get all the best of typescript, rxjs and their own features. Templating engine is really good. The whole development process is pretty strict, you can't just do a piece of code here and there, since angular is meant for SPA, whereas react isn't. I personally am still learning a lot about react and since i love JavaScript i find it more satisfying to develop in react. It goes without saying that ultimately this is a thing of preference. You can do pretty much everything with either of the frameworks.
Sometimes “just because” is reason enough. 
Ive spent a few months working in Angular and React. It seems like React has a bit more of a learning curve (adding redux) but I liked it way more than Angular.
I have heard a lot of good things about Vue. I will certainly give it a try. 
Its the only one among the three I haven’t tried so far. I was a full stack working with PHP and MySQL. I heard a about. MEAN and MERN. Is MEVN a thing? Lol
If its getting to grips with the syntax you want then Code Academy is a good option. Finding projects has always been something i found difficult but then i tend to lead towards server side scripting and creating APPs in node JS that automates stuff on my computers.
It's not really HTML it's JSX. It compiles into JS functions that render elements. Here's a neat article on how it works. https://medium.com/@pomber/jsx-can-do-that-1b2666c23a32
It's a very good thing. Before JSX came along, we were used to using a handful of templating languages which, each in their own way, tried to mimick what JS was already perfectly capable of doing: cycles, conditionals, ecc... The idea behind JSX is to separate code not by technology but rather by concern, and while I myself had my initial reservations it didn't take that long to understand that it does indeed work: a JS(X) file contains a definition of a component, both in how it should behave and how it should render; you can even take it one step further and adopt one the [many](https://github.com/MicheleBertoli/css-in-js) CSS-in-JS solutions and tell it how it should look, but it's not everybody's cup of tea. I remember that there was a talk by Micheal Jackson about this very topic, but I can't find it right now. If you're in doubt, just watch all his stuff, everything he does is basically gold. 
Yep, that's how async/await and generators work. async functions return a promise. Generator functions return a generator object that you repeatedly call .next\(\) on until .next\(\) signals the generator is "done". That's what co is doing for you. It's "driving" your generator, and wraps the final result in a promise.
You get used to it. If you want to you can always put your jsx in a separate file, but you'll pretty quickly enjoy having your jsx, style, and js all together. For larger, more complicated components, it's also common to make a wrapper component that has very little jsx but contains a component that's all jsx. 
Yeah i was shocked when i saw jsx too, especially!! that there are no ifs and fors there. I developed some stuff in angularjs before and ember, which both have these nice templating engines. Also, I'd say that these two frameworks are surely different, but at the same time, have lots of things the same. I learned angular before react and react felt easy compared to angular.
It's not actually HTML, its called JSX which is just a pretty syntax for javascript functions to looks similar to the DOM structure. You (almost) never interact directly with the DOM as react abstracts that for you. The benefit you gain is that it's very easy to use a lot of small components and compose the together. Doing that in Backbone is expensive in terms of boilerplate, complexity, etc. There also also patterns such as smart/dumb or presentstional/functional components which are same idea just different names floating around. Basically you hoisted state up to a common spot and that is a react component with state and business logic. That state gets passed down to child components which are all stateless functional components, which are dumb, no logic. This makes then similar to handlebars templates in a way where given input the produce some rendered output. React is a fantastic framework to learn, massive community and not very complex to get off the ground. Not that angular is bad, but there is a lot more to learn to get started. 
Maybe [this chart](http://www.npmtrends.com/angular-vs-react-vs-vue-vs-backbone) will help you make your decision. React seems to hold the sway these days, but it also might be at the apex of it's popularity.
The two things you didn't like are not mutually exclusive to either library, either. You can use react with typescript, and you can include HTML in your js templates (and commonly do) with angular. If that's all that's holding you back, you might want to dig in a little deeper. Also, typescript is probably one of the best things to come to the JS ecosystem in a long time - I'd definitely recommend reconsidering using it.
I’m doing a Udemy course right now by Jonas Schmetdtmann called “The Complete JavaScript Course 2018”. Starts from basics, dives in neeper, and also shows parallels between ES5 and ES6. Udemy is also having a mother’s day sale and I think all their courses are $10. This course has been really nice, especially for the extra details and comparisons. 
Www.tylermcginnis.com is the best resource
Yes, it is a good thing.
Bugs happen no matter what system you use. This particular problem would be handled by only using functions designed for date handling to handle date modification, plus good testing (as with anything). Depending on context, even private data would not produce “valid data” as a naive user of a date object might code to expect that a day value will always increment, rather that wrapping at the month boundary. In either case, the programmer using the object needs to understand how to use it.
I will take your word for it. Appreciate your response. 
Look at Vue though. It appears to overtake AngularJS in so little time. 
I switched to Vue about a year ago, and haven’t looked back. I evaluated the others. React came in second, but I just couldn’t get past the ugliness of JSX — I’ve been authoring HTML since 1995, and embedding it within a JS function and context-switching like that just feels unnatural to me. Angular is in architect astronaut territory — too many concepts to master to be productive, too unwieldy, and a moving target that’s seems to get more abstract and complex with each iteration. Vue hit the sweet spot — blazing fast, small, easy to learn, well-organized but simple component structure, and my HTML, JS, and CSS are cleanly separated, with just enough syntactic sugar to tie them together. The excellent docs and community also won me over.
+1 for the Udemy course, especially with the sale going on. If you prefer reading your lessons https://javascript.info is really good. Wes Bos has a free course called JavaScript30 that is 30 mini projects.
[Take a look at Wesbos's 30 day JS course/challenge](https://javascript30.com/).
You should look at https://eloquentjavascript.net. I think it’s a pretty good, up to date source.
Coming from MVC like Codeigniter, I hope I can take some of those to Vue. Havent looked at Vue but will certainly do that and hopefully help with my decision. Thank you. 
[removed]
Isn't that comparing AngularJS (the oldest version)? I get that AngularJS is still in use, but it would be a more fair comparison if "new" Angular was used (for better or worse).
If you haven't done any sort of DOM manipulation or really anything with vanilla JS you definitely want to steer clear of Javascript30 for now. Do some of the other ones or better yet read a book like Eloquent JavaScript (will kick your ass) or do Gordon Zhu's Watch and Code, then read the book and do JavaScript30
I wrote an ebook about the new features from ES2015 to ES2018. If it may interest you go here https://medium.com/@c9f1a0db173d/9553f8d3a91c
As someone who recently switched from angular to react (after 3 years), Id keep myself away from angular. The amount of time lost rewriting stuff because they would constantly make breaking changes is just too much. Perhaps angular 5 o 6 (don't know where they are now) is good, but that's what they said about angular 2,3,4,etc...
There are jobs for backend devs. They just usually require a degree or 5 years experience. Very rarely see junior backend developer jobs. If you hate html and css does that mean that all fiddly front end stuff will bother you? Like I started as a native software developer. So to me, HTML and CSS are so nice for designing layout and appearence. If you’re completely unwilling to do any front end you will definitely struggle to find an entry level job somewhere as very few places would ever trust a junior developer with no experience to work entirely on the backend. 
I [forked and modified the tests](https://github.com/oculus42/lodash-vs-es6) to eliminate the script loading, and did a version with benchmark after reading this. I tested three Node versions, and was surprised to see the performance difference in Node 10 is *substantial*. Good to see native getting faster.
It is by design and in theory. That said in many an implementation the rules given to clients in headers can be and often are enforced by backend. 
Why not Vue.js?
&gt; Is that a good thing? There is no right answer to this question. Some people like it because React is supossed to be only the view layer. Other people they that it is a bad idea because it messes with the distinction between design and behavior: Designers create the UI and front end developers are responisble for the behavior, so they feel remembered of the old days of writing html inside php.
I learned about how developers got frustrated about Angular 2 which made them switch to React. I guess that is a headache I hope not to encounter when moving to a new framework. Lol
I came off a large project in backbone into react and it was quite a bit nicer. React felt more natural to me than moving to Angular. Especially because you can use JUST react to build the most basic apps right away. Get familiar with the concept of state management and prop drilling, these are the things that push people to using more libraries such as redux/mobx. BUT! You don't need to reach for state management libraries right away. don't be afraid to use "Render Props" or a child-as-a-function patterns In-fact the React 16.3+ now includes a state management tool called Context - React.createContext is a factory that creates matching Provider/Consumer components that can be used to get around needing big state management from the get-go 
I’m taking the same course too (~41% and counting). So far so good. What I like best is that he takes the time to explain why something works the way it does in JS. Good luck and happy coding! 
The `no-cors` option disables the response from being read. As a consequence about the only use for `no-cors` mode is caching in service workers.
The typing not only allows you declare intent, it also enables powerful inference within IDEs. This enables the IDE to offer intellisense and to identify coding errors. For me, from a productivity and quality standpoint, strong typing is good. 
+1 for eloquent JavaScript (its free) as well as Kyle Simpson's You Don't Know JS series - also free on his github.
They're pretty much always having a sale. It feels a little like a bait-and-switch. They make you think that you're getting a $200 class for $10, but it's virtually always $10-$15 if you open an incognito window and go there.
Follow me my son, I will show you the way to glory and riches. * https://beta.freecodecamp.org/en/
I’m currently reading the “You don’t know JS” series, it really helps in getting a grasp on how JS works “under the hood”.
Honestly I just want to code in JavaScript and let the framework deal with the tedious parts. While react is pretty much like this, angular tries to be a lot more versatile while restraining freedom and forcing a lot of DSL. Again, it depends on the type of developer. I know many developers that won't leave angular ever, I'm just afraid it's because they've become too comfortable and dull.
Is it really separate though? I think we fooled ourselves thinking there was such a thing as separation of concern on the front end. Your JavaScript outputs html, why separate them?
You make a lot of sense. I like you. No homo. Lol
What is it about html and css you hate? Perhaps there’s a different workflow or toolset you’d prefer. 
There is, but I wouldn't use it in production: const createStore = (initialState, reducer) =&gt; { // Create our Observerable const state = new Subject() // Create a reference to state let currentState = initialState // Allow user to tell us about a new action const dispatch = action =&gt; state.next(action) // Allow user to peak at state const getState = () =&gt; currentState // Update our local value each time // the user emits something state .scan(reducer, initialState) .subscribe(s =&gt; currentState = s) // Return a way to emit and get state return ({ getState, dispatch }) }
Only thing with Vue is that there isn't much industry desire for Vue, not for the moment anyway. If you're looking to get a FE Dev position, might be best going with React.
Thank you for this. I've been looking for a concise compilation and explanation of ES6 for a while now. I will check this out asap.
Here we go again...
I've changed to v10.1.0 (I was using current LTS before), and here are what my results are now (this is from a single run, but it is in line with the average): Node version: v10.1.0 native: 0s 169.771374ms lodash: 0s 158.513091ms Here are the changes I made: // vs.js (removing bits I didn't change) const delay = (period) =&gt; new Promise(resolve =&gt; setTimeout(resolve, period)); // removing code I didn't change delay(2000) await pMg.execPromise(`node meter ${fileA}`) delay(2000) await pMg.execPromise(`node meter ${fileB}`) // removing more code I didn't change // for.js const j = require('./j') console.info(`Node version: ${ process.version }`); const start = process.hrtime(); j.map( item =&gt; { return item.num }) const [s, ms] = process.hrtime(start); console.info(`native: ${ s }s ${ ms/1000000 }ms`); // _.js const j = require('./j') const _ = require('lodash') const start = process.hrtime(); _.map(j, item =&gt; { return item.num }) const [s, ms] = process.hrtime(start); console.info(`lodash: ${ s }s ${ ms/1000000 }ms`); 
I would suggest angular (not angularjs) or vue. Because they have a complete environment to build a scalable web app and its is not difficult to get along with those. I had never use react so a can't talk about. I prefer angular, I think is because it relate more with OOP and looks more familiar for java developers
Today I learned that Angular is not AngularJS. I did Google search and when you say Angular, is this successor to AngularJS or the other way around?
React. It's much more marketable these days, and I would argue has a far better fundamental design. That said, I feel it is my duty to always mention [Mithril](https://mithril.js.org/) in these conversations. It still has a smallish user base, but it is fast, easy to learn, and has (in my opinion) an even better design than React.
Just needed something simple to set, with automatic tasking and latest modern JS. So I created this boilerplate in order to start new small/medium projects. It features Webpack 4.8, ESLint and Sass compiler.
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing.
At some point the ugliness of JSX became the beauty of JSX for me.
angularjs is the 1.x, and angular is the 2\+ version, they are quite different from each other, angularjs have scopes and uses javascript \(I think just the es5 and is messy to get the es6\), and the angular uses the typescript, have a CLI and is organized in componnents
It is a shame I can’t edit the title of my post. I am referring to the wrong version then. But thank you for clarifying this for me. 
You need to add permission for the host you want to access. https://developer.chrome.com/extensions/declare_permissions
Go with react it is far more popular than angular or vuejs. I like it a lot because it is very simple and does not force you to use a development style you may not like. Here have a look how much more popular it is: http://www.npmtrends.com/angular-vs-react-vs-vue
Fixed.
You literally just said that the best things about each of those tools are what you didn't like about them 😅 
i am hoping this will change soon. I am lucky to have been able to work full time with Vue for 1.5 years, but my contract is about to end and I will probably have to start using React again. Wish I didn't have to
I know!! Can i take it back please? Lol
It's confusing. but you can't go wrong with angular, vue and react, try they out and pick the one that you like best
Js loose typing makes it easy to get proof of concept prototypes up and running, but typescript is better for long term maintainance , especially among teams. I am currently working on a prototype for my startup, but plan to rewrite the entire codebase in TS before closed beta
Anything public-facing that will require lots of custom design and interaction, stick with react. Angular is better for back-office or other captive user environments where you can work inside the box. Angular is more automated and more prescriptive. That being said, you can totally do either use case with either platform if you really want.
I would say that the better you get with Angular, the better you understand angular. The better you get with React, the better you understand *javascript*
like what? the stack? (i don't know what i don't know)
You absolutely may! My favorite front end stack actually happens to be React + Typescript. I like a lot of things about Angular, and it's what I use at work, but Reacts object templating feels so much more directly effective.
Wat? RxJS does more than help you "process data", are you thinking of lodash? If you set up an Rx Subject, you could very easily emulate the Redux API.
this is really interesting read. I'd never thought of abstraction as a way to make code easier to read.. i guess it's a function of how well you can name your functions and organize your logic..
So I go React, not only will I get on with it faster but it will likely help me understand vanilla js better? Honestly in my company, we haven’t used ES6 and we are not going to use it anytime soon. Maybe I can go with React to get a headstart when the time comes. 
If you are going to micro-benchmark, you might as well add `for`. `for` would out-perform both in 90% of the real world scenario due to all the compiler optimization available (e.g. loop unrolling, memory allocation, garbage collection). 
If it boils down to checking Origin header it isn't but that's not a very effective mechanism for anything other than cooperative clients in which case you could simply go way client side CORS. What I've seen in practice is requesting a cookie or other short term token as a proof that you originate from a web page that's been served by that or a trusted server and then the mechanisms used are essentially authentication, just not user authentication. 
They're always running great sales. Keep an eye out. 
Abstraction should make code easier to read. If it doesn’t, that’s a clear sign it’s implemented poorly. This is true in all programming paradigms, not just functional or OOP.
You can also take a look at the learn enough to be dangerous series, I think they just released a javascript book.
Here’s my recommendation... Build a from-scratch authenticated “homepage” on each of React, Angular and Vue. Do a full login, logout, revoke access, forgot password password, etc. whatever you want until you worked on each for at least a week or two. Then when your done choose React 😂 
&gt; Www.tylermcginnis.com It looks pretty decent. How much is a course?
CSRF tokens don't really have much to do with CORS. 
I agree. I hope it works for you and your startup. 
Absolutely agree.
Nice work with the fork! The Node 10 results are very impressive. I believe this is because V8 can inline `Array.prototype.map` [since version 6.4](https://v8project.blogspot.be/2017/12/v8-release-64.html), and [Node 10 is the first release](https://nodejs.org/en/download/releases/) that ships with V8 6.6.
In case someone interested in outcome of this question. I started a new project, which uses language server protocol to perform code actions. I really like @cthechartreuse project (js-refactor) and probably will get more from it. For now I only supports two simplest commands: convert function to arrow function and backward. You can find source code here: https://github.com/slonoed/jsref 
For just a JavaScript reference [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide)
Way back when I was at the crossroads of choosing a framework, I chose Angular, so I am familiar with JavaScript frameworks, but not JSX. I must say, with regard to the DOM, the whole thing seems extremely bizarre. It is so different from what you would do without it, I wonder if people who go down the React path do not sometimes get nervous they are going to have a permanent "paradigm accent" to the way they think. I am not doubting the existence of efficiency gains using a VDOM vs the native DOM, but I do doubt whether it is worth the price of selling your formative mental construct. Both JavaScript and the DOM are evolving, and the need for a layer of abstraction on top of them is inexorably diminishing. I my opinion, right now, for most websites, the difference in perceived load time between React and vanilla is undetectable. I feel like the justification for learning React isn't mostly just that it is popular, not because it is faster. I wonder for how many more years that will be so.
Pick up a css framework like bootstrap or bulma, and then go for jobs knowing that you’re cutting yourself out of the more creative-oriented jobs (the ones that demand truly custom front end design). 
A job in backend development with a degree in accounting would be a dream hire for a lot of companies. Learn SQL and Python or Go and look for those jobs.
It also really depends on how you decide to structure your components in JSX. You can structure them ugly or you can structure them nice and neat.
You definitely need to move on That being said, my personal preference is React
Well said!
As Wizhi pointed out that graph shows angularjs. If you are starting a new project you should really be using Angular. You mentioned typescript so it sounds like that's what you already played around with. [Angular](http://www.npmtrends.com/angular-vs-react-vs-vue-vs-backbone-vs-@angular/core) is a good bit larger than vue or angularjs according to npm download statistics. But still smaller than react. Of course there's a strong argument to be made that those statistics don't necessarily represent usage of the frameworks for many reasons. But that graph actually has angular on it at least.
Jonas rocks. His advanced CSS course brought my front end skills to a new level
I wrote a book on Backbone, switched to React, and never lookef back. As for the JSX thing, you have a choice. React puts HTML in your JS logic. Angular, or Backbone (with Mustache or Handlebars or whatever) or similar frameworks put logic in their (template) html So would you rather deal with separate template files with their own syntax and hard to debug logic in them, or would you rather do, basically ... renderComponent = () =&gt; makeADiv (makeAButton ()); except with syntactic sugar that makes the "makeA" functions look like HTML?
This. I would start with eloquent js, but you don’t know js is much more detailed.
By making things, then getting stuck when making things, then searching for how to get unstuck making things. Rinse and repeat. 
This is awesome man, keep up the good work and keep us posted on progress!
The issue isn't with how you define class methods in general, you can use either method there depending on your needs. If you need `this` bound, use arrow functions. In this case, the issue os that you're trying to do it with `get` and `set` and that simply isn't valid syntax for how those things work. Look at like this get Cost() { return this._cost; } That's `get` + method declaration Now look at this: get Cost = () =&gt; this._cost; That's `get` + property + assignment It's just not the same thing, it works in standard methods because `methodName = () =&gt; {}` is a straightup assignment of a function to a class property. You can read some more about this here https://stackoverflow.com/questions/33827519/es6-getter-setter-with-arrow-function, and there's a few suggestions on how to do what you're trying to do. 
But Typescript is so satisfying once you know it. Its basically Java, and the IDE points out your mistakes. Never going back to native JS again
The upside of that is the pay is better for Vue since it’s still somewhat niche. 
I recommend Vue over React and Angular for a few reasons. 1. It’s lighter weight and faster than Angular, and on par with React. 2. Other than single page components (javascript, html, css in the same file), there’s not a lot to get used to. Very easy to learn compared to the other two. 3. You can use typescript and/or jsx if you want. This is nice because they’re prescribed in Angular/React respectively. 4. The ecosystem around Vue is unified, whereas with React it is not. Vue-router and their Redux solution (Vuex) are first party and there’s never a version mismatch that has happened with React Router and Redux. This tighter integration also means developing with either feature is safer and easier. 
Yes! I forgot this one. Kyle Simpson is a great resource.
Orly. Ok smartass I'd really like to see how do you imagine server side CORS is implemented 
[You might not need jQuery](http://youmightnotneedjquery.com/): Handy little resource if you want to know how to do a bunch of things without jQuery.
&gt; If you want a value, i.e. the data structure, to be immutable, it requires an extra step THAT IS EXACTLY OUR POINT, YOU DOOFUS
That it helps 99% of the time it's yet to be demonstated, but for the sake of argument - we are discussing _precisely_ that 1% which is not covered.
This is a summary of web development, so I don't understand your point. Out of curiosity, in what other fields has ruby established itself?
&gt; Yes, it is a TypeError to assign to myArr after initialization. **The reference is immutable.** 
I added a for loop to my benchmark version: In Node 10.1.0, map is still faster. ``` native map x 22,775 ops/sec ±19.38% (85 runs sampled) lodash x 7,761 ops/sec ±0.86% (88 runs sampled) lodash/map x 8,874 ops/sec ±1.32% (92 runs sampled) lodash.map x 9,313 ops/sec ±0.97% (90 runs sampled) native for x 18,955 ops/sec ±1.23% (94 runs sampled) Fastest is native map ``` Note that the margin of error is also higher on the map. Subsequent runs were trading or sharing the "fastest" title.
AS others are saying, JSX you see in react files is not the HTML that gets rendered, more like a shorthand that gets converted into React calls, which produces the target HTML.
[Here's a chart](http://www.npmtrends.com/angular-vs-react-vs-vue-vs-backbone-vs-@angular/core) with @angular/core included. It's higher than AngularJS, but still pretty far back from React.
As a followup, try to think of where this would even apply. Your get/set are only ever going to run when you're already reference 'this' directly. Where are you ever going to be using `this._cost`directly where `this` isn't the correct object? The typical answer to that question is the other methods in the class. In that case, you can simply use arrow functions on those methods. 
Almost any language has a chance. The real question is what is the value of that probability? It is hard to topple existing ecosystems because they have already been established. If JS is to supersede Python in this arena, JS needs to offer something that the existing Python ecosystem does not. My question for you is, why did you base your work on JS rather than what the algorithmic trading community currently uses? What do you think makes JS better than Python in this area?
I learn by doing. You can watch all the videos and read all the books, and you will still lack the experience that comes from actually doing the work.
`document.addEventListener("DOMContentLoaded", () =&gt; console.log("It's working"));`
Just because there are "stronger" forms of immutability, i.e. using immutable data structures, doesn't mean that reference immutability is not a form of immutability. This isn't a matter of opinion -- I provided empirical evidence that suggests that favoring immutability prevents errors. Of course, in this case, being *more* immutable is better, but that doesn't mean that reference immutability isn't important. For example, the entire memory safety model of rust is based on reference immutability without any specific concern for immutable data structures. Yes, ownership is a more specific concern than simple reference immutability, but `const` is still a form of the more general case -- preventing accidental re-assignment eliminates an entire class of bugs from your program and thus should not be considered "a matter of preference."
I love TS, but I never ran into the issue you’re describing while using `===` and avoiding using + for concatenation.
If you really want to learn modern JavaScript from the ground up, I can recommend [https://javascript.info](https://javascript.info)
You got a source on that? That has not been my experience working as a full stack JS dev in San Francisco.
How is React not meant for SPA? That’s asinine.
&gt; This particular problem would be handled by only using functions designed for date handling to handle date modification I agree! It would be handy if a language could offer some syntax to express that relationship, like if we could wrap a pair of braces around a data structure and the functions designed to handle that data. ;-)
Practice practice practice I try to read Medium articles in the JavaScript community If I see a topic or practice that I'm unfamiliar with I try and just write out the code in a simple case, then expand around it. Just try! And keep trying! And if you don't get it its okay, just take a break and come at it later!
React has more job opportunities, a larger ecosystem, makes all of the new advances that Vue eventually copies over, and now has asynchronous rendering via Suspense.
For what it's worth I switched from PHP to JS in 2014 and haven't looked back since. I would recommend all of the following, even if they cover the same concepts. [JavaScript Guide](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Introduction) on MDN (this is your most valuable resource I'd say, it's like the PHP manual for JS) [You Don't Know JS](https://github.com/getify/You-Dont-Know-JS) by Kyle Simpson [Eloquent JavaScript](https://eloquentjavascript.net/) by Marijn Haverbeke [JavaScript Design Patterns](https://addyosmani.com/resources/essentialjsdesignpatterns/book/) by Addy Osmani These are not specifically about JavaScript but are things that you'll probably run into and should know: [High Performance Browser Networking](https://hpbn.co/) by Ilya Grigorik [SurviveJS - Webpack](https://survivejs.com/webpack/introduction/) by James Jordan And then for Vue specifically, this course was my favorite but it is a paid course: [VueJS 2 The Complete Guide](https://www.udemy.com/vuejs-2-the-complete-guide/) by Maximilian Schwarzmüller 
Can you expand more? You're trying to scrape the web I'm assuming? So you'd have some `&lt;img src="* /&gt;"` tags and you want to get the list of them in which a criteria is met? If the above is true, I think you should just be able to do a query selector for each source. const listA = document.querySelectorAll(...query1) const listB = document.querySelectorAll(...query2) Those should have a NodeList of both A and B. A basic example but again I'm just spitballing here based off the question
Just relax, you will do fine. The best advice I can give you is to have the right attitude. If you are self-taught, then that shows your initiative, and desire to learn. Continue with that attitude in everything you do. The pace of change in the software world is increasing, and it is impossible for any one person to know everything. Don’t try to be that person. Be the person who wants to continue to learn and grow. 
A very different type of observable, mind.
I mentioned this argument because a lot of people bring it up and I don't know their work environment so I believe them that this is an issue. But you are not wrong either, for me personally it was the other way around: Designer had enough basic knowledge about js to know where to edit stuff and where not or even edit the js themself.
Stalk devs on twitter, on npm, on github.
If you love programming but you hate an aspect of the work, then I'd recommend taking that beast head on. I'm also a web dev and I went through the same thing with CSS, and then unit testing, and finally build infrastructure. It was frustrating, confusing, and made me feel stupid or like I was an imposter and not really cut out for my profession. But after enough squirming and complaining, in each case I finally stepped up and dove in and let my spite and stubbornness fuel my quest to master those things I hated. And in each case I came out either becoming the go-to guy to solve those types of issues (CSS and unit testing) or at least being comfortable enough to no worry too much and get the job done (gulp and grunt build scripting). I have had to learn a larger variety of things as a front end dev than as a back end dev. It comes with the territory. Every year there are tons of new libraries, build tools, and frameworks that shake everything up for those obsessed with the flavor of the week. However the issues I faced in the backed world had a much deeper complexity.
Be humble, work hard, help others. I have 10 years programming professionally and am self taught. I keep learning new things after all these years even though I am technical lead. 
Well, I guess it would be better for me to learn properly Webpack and Typescript. Geez, I'm learning frontend fulltime for more than 5 months and still need to learn much much more. Just to get a junior level. But I can use react + redux now. Like a monkey can use a car but still... :)
With the latest version of Angular you have to code a lot more to do the same thing. Angular is a FULL framework. ReactJS is just the frontend with any backend you want. For me \- I picked React because at that time Angular JUST went to 2.0 and it was a complete rewrite. The internet was pissed and I felt like React was a solid choice. Because maybe you're in a position to hire people later. I would look at the market for your local area. When it's time to hire do you have more React or Angular Devs? What about the other people on your team? If I had to choose for you I would choose React. If you want to learn React you should checkout WesBos [https://reactforbeginners.com/](https://reactforbeginners.com/friend/CHAMBERS) 
Congratulations and good luck mate! how long you’ve been learning? how old are you? just interested in some details as Im basically in the same path and would be happy to hear about experience of others. (:
Woah, what’s up with all of the downvotes on this one? I was under the impression that Tyler McGinnis was pretty well respected.
If I'm learning something new like I am with GraphQL I like to watch videos. We all have different learning styles. Once I understand and start to build things with it I'll do just that. I take the base of what I learned on the videos and modify it for my next full project because I already know the code base.
Have you tried Gordon’s premium content?
Welcome to the world of JavaScript. I want to introduce you to MPJ from Fun Fun Function: [https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q](https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q) In his playlist checkout functional programming in JavaScript. 
Have you tried without 'httpOnly': true? That seems to interfere with secure:true
Just set your compilerOptions to use noImplicitAny and strictNullChecks and you don't need any discipline anymore 
So why was typescript a negative when it reminded you of the good old days? Am I missing some sarcasm? 
Homebrew, fastlane, cocoapods, metasploit, sonic-pi and a ton of other development and system tools are written in Ruby I know it might be a bit foreign considering that JavaScript was literally created for the web, but it's completely ridiculous to call the history of a language in one domain an accurate history of the entire language (especially when it's honestly insignificant compared to the reach it has elsewhere. Consider that literally every app on the Apple Store was created using tooling written in Ruby, for instance). 
I do not truly like any of the big 3 frameworks. Angular is overly structured and oppressive, React is too weird with JSX, and Vue is just React Light. That said, they serve a purpose, mostly to companies, but you gotta get a job. I always felt the biggest difference between Angular and React is how the machinations of data binding work. Angular is more template-like, with its attribute directives inside actual HTML. React is more popular, and probably statistically a better bet if all that matters is landing a job. The suggestion you do a Hello World in both is a good suggestion. It is the only way to know for sure which you prefer. If you have no preference, then it doesn't matter, and you could dive into either. There is no clear winner. You do not have to follow or lead, but you owe it to yourself to make up your own mind. Sometimes it seems the online webdev community is an opinion vortex that sucks away independent thinking and creative thought. Fight that sucking force. Put your foot down, and decide for yourself. 
I signed up for his class Javascript off of this comment. And will probably sign up for his other classes as well. Thanks for the recommendation. 
es = elements ei = element index e = element They all have meaning, ask me when you are stuck, after I answer you will find beauty in the beast ;\) 
Personally I love the immediate feedback I see with the frontend. You could land yourself on a team where maybe 90&amp;#37; of your job could be backend even if they are hiring for full stack. Can you role play with us a little bit about what's so bad with HTML/CSS for you, specifically? 
I have not. 
I'd go with react or consider lit-html which is also a great options.
Nice! I haven’t taken any of his JS courses, but I imagine they’re probably great. I’ve learned a ton from his advanced CSS course and I’ve only complete the first big project. 
SurviveJS is by Juho Vepsäläinen. 
Nice! Gonna give it a try!
With fuckingaround-idis since I think 2015. Full head on since last November ( quit my job and focus full time on learning ). I’m 30 with a BFA, was a director in LA before. 
Test suite done and reach 90% coverage
Ya know, so long as it’s his decision... and one I agree with, it’s all good 😉 
Congratulations! Don't be afraid to ask questions, never stop learning, start networking (people not cables) and always keep your resume up to date.
https://frontendmasters.com/books/front-end-handbook/2018/learning/javascript.html
Thanks. I need some help polishing my linked in. Any tips?
This
I'm a fan of basics and oficial documentations. Javascript's oficial documentation de facto is Mozilla Developers Network. It goes from basic to advanced topics. If you understand the language you will be able to understand any framework or library https://developer.mozilla.org/en-US/docs/Web/JavaScript
Nothing too specific to LinkedIn. I think just connecting with your other developers, especially the ones passionate about programming, is good. If a group asks you to lunch or to grab coffee or whatever, say yes. Keeping in touch with people who go elsewhere can lead to other opportunities.
That is awesome, I quit my job to learn full time and it paid off, I'm now employed at one of the top tech companies in my city.
That's interesting. I will look into this. Thank you.
If you try vue, you’ll choose vue. React is by Facebook anyway, I heard zuck gets a monthly download of your internet history if you use react.
Your jokes are lame
It can be quite fiddly and repetitive. I'm working with React at the moment \(MERN stack\), to create a clone of Reddit \(the beta design\). I've opted for styled components. Styling with react just feels like a lot of extra work tbh. Maybe I need to look at another approach.
&gt; makes all of the new advances that Vue eventually copies over 🙄 implying that Vue somehow lags or looks to React for cues when it’s first commit predates React. 
My experience is strictly for San Diego. 
I'm considering this too. For now I'm pushing on. From reading the other replies in this post, hopefully I'll be one of those web devs that don't do too much styling. Also it could be imposter syndrome? I mean, I don't think theres any job out there that doesn't have an aspect someone quite dislikes.
Ah thanks for catching that careless mistake. Corrected
Appears to be request + cheerio only in one package.
amazing! keep up my friend! 
Yes, react is just a simple Ui library with a ecosystem of stuff to do everything else. Angular is a FE framework
Typescript is awesome. Don't let the initial learning curve deter you. If you're working on enterprise software I would almost say it's a must because it catches so many errors and can be used to enforce smart/maintainable conventions. I spent about a year and a half writing angularjs and was a pretty hardcore JavaScript purist. After working with TS for 2 months or so, however, I was a convert. People have already listed a lot of the benefits but one additional one I'll mention is that it more easily allows sloppy code to be captured during PRs. I work with some guys who are not overly gifted or driven so it's nice to be able to quickly review a PR and reject until it's been improved with declarative types and interfaces.
Because I thought it would make a good scripting language for a web-based platform, given that its already the de facto language of web programming.
Mind giving me a glimpse of some of what you learned? I do a bunch of JS udemy courses and have been doing web dev professionally for a few years now. I feel pretty competent with CSS for the front end even with complex projects but am always willing to buy another udemy course to level up further. 
JSX is not JavaScript.
This looks awesome!
What would you say were the biggest factors that made them decide to hire you? Which skills? Which previous experiences? How much did your attitude help? 
jsdom &gt; cheerio
Resume and github. I don’t feel ready. Still will go in with passion and open mindness. 
You just listed probably the best two things that both offer
Good job! One piece of advice aside from what others have said: don't let them work you to oblivion! Insist on decent work-life balance and if it seems like they aren't willing then don't be afraid to look elsewhere. You, of course, have to decide what the right balance actually is. Some people work 80 hours a week and are perfectly happy. Good for them! Me, I want to put in my 40 good hours of work and then have time for my own stuff (which often involves my own side projects) and of course family. I'll work extra hours when it's REALLY necessary, but I make sure that's the exception and not the rule. Each person is different (and it'll also likely change as your life does too - long hours were no big deal when I was in my 20's with no kids, but in my 40's, while I CAN still work long hours, I don't really want to anymore because there's more to my life now then there used to be and work is just one piece of the puzzle now, not the whole puzzle anymore). Some places will treat you like a government mule and work you 'til you drop. Don't let them! Hopefully you found a good place that understands that workers who aren't burnt out are better for THEM too and it won't be an issue, but be aware is all I'm saying.
Styled components can be a bit polarizing. I don't know if you maybe chose it because that's what Reddit chose for their redesign, but if you're not enjoying working with them then you can swap to a different approach any time you want. Putting all your styles in a style sheet and then adding class names to the components that you render in react works perfectly fine as well if that's what you've been used to up until now. 
My advice is, don't be afraid to ask for help, if you struggle or don't understand don't worry and just ask, it's no shame 
Agreed on mithril. I loved working with it at my last gig. Angular (and angularjs) is my nightmare.
Congrats! That is wonderful :) I’m self taught as well. I decided to go back for a Masters in Computer Science but have learned more on my own. What technology will you be working with?
You can replace JSX in React with hyperscript or even `React.createElement` calls -- what can you replace Vue's HTML DSL with? Genuinely curious.
I was about to link to /u/Labby92’s post about his new book, but saw that he himself already mentioned it! If you know ‘old’ JavaScript, this book is a good introduction to all the new features in ES2018 you might not know about. And as for jQuery, I’d say to avoid it where possible. Especially when your goal is to achieve some kind of animation (e.g. with `.fade()`), letting Js (and / or jQuery) do that is almlst never the preferred way. Use js to add/remove/toggle a certain css class on the element you wish to animate, and animate using CSS.
Exactly this. Tools over discipline.
Great job, I'm excited for you. This was me a year ago. Well a year this coming Tuesday, and I'm being bumped up to Sr. Don't sweat and believe in yourself. Doing so got you this far already. The hardest part is getting your foot in the door and you've done that. Now the possibilities are endless. Congrats!
Congrats. Many of my favorite programmers are self-taught, because when you learn how to do that, you tend to keep learning, rather than rest on what you were taught years ago. I'm also self-taught, but I'm not one of my favorite programmers.
Congrats! You'll do juuuust fine. I'm 4 years in now, was entirely self taught. Definitely struggled with imposter syndrome for a long time. But if you stay on top of it, you'll be the guy that all the newbies find intimidatingly knowledgeable in no time. Nowadays, when I mentor newer devs, the first two things I tell them are: Ask questions - it's better to learn something now even if you feel like a dummy, than spend 6 months or 2 years at a place and still struggle with the basics. People will expect you to not know things early on, so use that to your advantage. I actually find it more worrisome when new folks come in and don't ask many questions, and I've never had someone come in and thought "man he asks TOO MANY questions." That said, there's a happy medium to be struck, put a little effort into stuff. There's a huge difference between when someone comes to me and is like "xyz doesn't work, help" vs when someone is like "hey, I'm having issues with xyz, I've tried abc and 123, but am running into foo and bar." If you're worried about looking like a dummy, it's better to feel like a dummy for a little while and grow quickly then stay there forever because you were afraid to ask. Also, in my experience, people LOVE to teach other people things. If nothing else, it makes them feel smart. And learn your tools. I'm a vim user, and people often act guilty for using something other than vim when it comes up, but honestly, I'm not some vim wizard. I learned vim because I like learning new things and I saw it as a fun challenge, that's all. I've seen people be insanely fast in Sublime, Atom, etc. Learning your tools, regardless of what they are, is so, so important. And that goes beyond just your text editor. Learn and understand the toolchain that enables your dev workflow. Coming into an established company that already has a bulletproof webpack that no one has touched in 6 months and no one really knows how it works? Learn the basics of webpack. etc. Basically, always try to be learning something, it's your greatest asset as a developer. The other thing I've found incredibly helpful is pair programming. Just watching experienced devs do something is so insightful. You'll learn things you didn't even know were questions to ask, you'll learn workflow tips, small tools that save tons of time, and the mindset of someone experienced tackling a problem.
Don't worry about it, there are tons of different technologies that do similar things and all that really matters is that you're able to understand the concepts and learn the APIs as you go. I do think TypeScript (or Flow) is particularly useful as it introduces you to types, type safety, and more maintainable coding patterns.
You can use any template language you want with Vue. If you use something like pug then the directives will still work (v-for, v-if, etc.), as they're just attributes and are parsed as such. If you want to write render functions in pure javascript you can do that (Vue's createElement works in much the same way as React's) or you can write render functions with JSX, a la React. You can use hyperscript too if you want to. Vue templates compile down to render functions internally. There is more info about render functions [in the docs](https://vuejs.org/v2/guide/render-function.html). Vue is actually pretty flexible, a lot of people seem to think you have to use the Single File Components but that isn't required at all. That said, I think Vue's DSL is pretty simple, improves productivity and keeps the code in your components pretty clean. Vue has helpers like ```@click.prevent``` / ```@click.once``` / ```@keyup.enter```and many more besides which can also cut down on boilerplate. Some people won't like it of course and you don't have to use them but I think they're quite nice for common stuff. They're also really straight forward, the whole DSL criticism of Vue strikes me as odd. Apart from the fact you don't have to use it, it's also just about as straight forward as it gets. if ```v-for```, ```v-if``` or ```@click``` is too confusing, I don't see how pure javascript is gonna fix that. The real benefit of Vue, though, is vue-cli combined with really straightforward components. I don't know if people who haven't used Vue realise how quick it is to build a quick prototype. Even if you don't end up using Vue, for that purpose alone its pretty crazy. And it's obviously just a capable as React if you do choose to use it, I mean they do the same thing, are both very fast; it really comes down to tooling, approach, DSL vs 'Syntax Extension' and no-one is ever gonna agree on that.
But I never said this was the story of ruby... it was (a tongue cheek) story of the period in web dev history when ruby was big. The focus is web dev, not ruby So ruby is still big in system tools, good to know, although I wonder whether it's just inertia rather than ruby being the best solution for the job. Regardless, not my problem :-) sonic-pi looks good though, never heard of it before, I'm gonna play with it, thanks for the tip
Backbone Marionette.js puts html templates in the model. Have you thought of looking into this framework as well?
Thanks for this, I really needed it. Can you elaborate how pair programming works? Wouldn’t you (me) feel judge ?
Maybe, just maybe this weekend I will feel secure enough to celebrate. I start the week after. Thanks man. 
Nice!!
Yes. Going through you don’t know JS. Reading JS the good parts. Codewars.com and my mentor gave me udemy pliralsight and udacity access somsome tutorials there. The biggest one is starting a free tutorial in YouTube then hack it yourself with the technology’s documentation and stack overflow. I actually had a notebook and a whiteboard and wrote some algorithms by hand for the cementing of knowledge. 
All of these have their own website where on the root page you can get the description of what is what. Making those google queries will take you less time than it will take for me to write few sentences. Although I would not bother myself with all these libraries and frameworks if I were you. Just start building stuff and experiment. Start simple, focus on achieving something ridiculously easy and only when you succeed move on to making it more complex. My worst mistake when I started programming was that I was afraid of making errors. I would spend too much time just gazing at code trying to make sure it's correct. Fuck that. Make them, fail fast, refactor, recover. Make enough mistakes, fix them and you might call yourself a programmer. 
Great advice. Thanks .
Never worked on an office. What other things should I expect?
As someone whose been programming for 19 years and now consults, invests and has done more than a few startups, my advice: 1. Develop a problem-solving or decision making system that you can write down and later illustrate how you decided to approach a problem. 2. Iterate on that system (improve or redo it completely) as you find problems with the way you approached the design and decision making. 3. Create a system for everything else too (how you handle infrastructure at a meta level, your naming conventions, anything that you do over and over) and document it. I think this is easier for those that start with OSS rather than an academic background. Try to automate those systems in your spare time. 4. The number one rule for career success for any modern programmer or coder is to become a world class psychologist. Be genuine and understanding.., blah blah blah. It’s seriously the worst chore when you just want to blast code but you’re having to delicately step over dozens of people’s babies. 5. Don’t become personally attached to anything that you do professionally. I don’t care how proud you are of it, that type of attachment will only hurt you and your team. 6. Make your Learning everyone else’s opportunity to teach you, scratch that, force them by insisting on a SDLC that involves lots of review and PRs. Try mob programming too. Good luck. Relax. Don’t play dumb, just be confident and accepting of criticism.
It’s $20/month for the subscription. He has a really good Modern JavaScript course that takes you from zero to 100 pretty quick. His React courses are equally solid. He does a good job of articulating React’s underlying programming paradigm, which is definitely the way modern apps are going to be built for some time. 
Probably a bunch of Udemy &amp; CodeAcademy troll-bots... McGinnis all of the JavaScript pieces together for me. Dude rocks
No. Reactive programming is data processing. Look at the official website bullet points: &gt; Functional &gt; Avoid intricate stateful programs, using clean input/output functions over observable streams. Then we have Redux: &gt; Redux is a predictable state container for JavaScript apps Reactive programming is great for taking async data, streams, etc and processing them. It is not a store. Redux is a store that enforces 1 directional data flow. They are completely different tools to solve different problems. 
And this is one beef I have with Typescript: it makes people forget it's not real. It's still linting. There is no "type safety" in Javascript, not in the sense that people mean. It makes too easy to forget that it won't be there at runtime. That, and pretending you do class-based OOP with JavaScript, which is a dangerous aberration.
Too much simplicity can be detrimental. IMO Vue strikes a good balance between React flexibility and Angular structure.
You’ll find there isn’t that much to learn. Implementation and business logic mostly, but the programming aspect gets routine pretty fast. Good luck! 
Im not using fetch. I actually don't know what fetch is. Im using express and rendering ejs.
IMO `create-react-app` is just as fast as `vue-cli`. JSX may be an abstraction, but all logic is pure JS vs. reworked controls in Vue's DSL. Any amount is more than no amount in terms of learning new logic, etc. Thanks for the discussion!
That’s amazing, well done! Success to you and thank you for sharing your story here and inspiring so many of us that are on the same path! I started down that road a couple of months ago and I’m super excited! But let me ask you... when did you feel ‘ready’ to start applying? How long into it, or how good was your knowledge...?
I just tried. No difference. 
Then your middleware is not correctly hooked up at the right spot in the request lifecycle.
You get used to it, I came to react from backbone as well, and I kinda had that "separation of church and state" drilled into me as a selling point for Backbone... It's fin. The interactions between the two are very related and once you do it for a while you'll never want to go back :P
Don't be afraid to ask others when you hit blockers either. Give it an honest effort before you ask for help though, and make sure you keep notes so when you encounter it again you will be prepared. People will respect you for being honest and willing to learn.
It's more opinionated, and it can do a lot of really basic things a lot faster. Simple animations for example come out of the box. I've used both, and I prefer to be a little closer to the metal with React. I build a lot more apps, and have used things like react-native so perhaps if I was building more marketing sites, or e-commerce pages I'd find some of Vues opinions time saving.
Make a project in Angular then make the same project in Polymer.
:( How do I figure it out?
I was in the same boat and it took years for a company to give me a chance. I hated the first company I worked for but stuck it out because I desperately wanted to get that experience on my résumé. In the end it paid off. Now I work for an amazing company. So if you find yourself in the same position keep your head up, don't throw in the towel, and keep the long run in mind.
Experience. There's a limited number of places sessions can go wrong. The usual culprit is the server end, but it's easy to eliminate half of them by making sure the cookie is sent to the browser in the first place.
How does this look? I have removed cookie parser for now while I try and figure out why nothing is working. app.set('trust proxy', true) app.set('port', (process.env.PORT || 3000)); //app.use(cookies('superSecretCookieSecret')); app.use(express.static(__dirname + '/public')); app.use(bodyParser.json()); app.use(bodyParser.urlencoded({extended:true})); app.use(session({ secret: 'superSecretCookieSecret', resave: false, saveUninitialized: false, cookie: {secure: false, maxAge: 3600000, httpOnly: true}, store: new redisStore({client: rds}), proxy: true, name: 'sid' }));
&gt; vuex got all its ideas from redux. vue-router got its ideas from react-router. You can’t go around saying things like that unsubstantiated. Citation needed. 
I didn't see this anywhere else in the comments, so let me toss out this advice. Learn the business. Only part of your job will be coding. A great deal of your job will be understanding WHAT to code. You'll be talking to other people -- non coders -- and you'll have to understand them. The terms a salesman uses to describe a product will be very different from how you think, and his words will be totally alien to you. End users will have their own terms. The business itself will have terms. 
Only complete morons think Vue.js is a fringe framework
Alright, that's fine. I just require that opinions spoken about as fact need proof before I take them seriously.
It's no concern of mine if you take it seriously ¯\\\_(ツ)_/¯ React's numbers speak for themselves.
It’s not even close to a major contender. It’s in the conversation, sure, but as a far, far away third. When real money is on the line you don’t use fringe frameworks. You be an adult and use one of the major choices. Don’t call people morons when you’re blinded by your own personal bias.
&gt; React's numbers speak for themselves. Irrelevant, and a fallacy since that's not what was being discussed.
Hi /u/rharris0127, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
If you take the last of the coffee, make more.
I think fringe framework would be something more like Elm or a framework that only has 1 person really working on it (the Elm creator is one of those Torvalds-esque singular vision type of people). Vue has a smaller community but enough of one to support any issue coming up when money is on the line. If it's good enough for the largest companies in the world, it's probably good enough for us.
This is the exact state of mind I’ll have if I fall in that case. 
Thanks 🙏
Lol. Noted. 
Yes. Absolultely. ES6 still needs to be compiled to ES5. You can learn ES6 functionality in a day.
Tough to say because companies can be so different. The answer would be wildly different if you were joining a startup vs a fortune 500 or something. In general - - Avoid gossip and politics (to the extent that this is possible), it never leads anywhere positive. - Help people when they need it. They'll remember that when you need help, and literally every promotion packet I've ever looked at had something like "so and so is eager to help others". - Show up on time to meetings. Tech specific - - You're absolutely, 100%, guaranteed gonna fuck something important up in your first 12 months on the job. I brought our entire app down about 2 months into my career because I forgot to close a database connection. So don't be too hard on yourself when it happens, because it happens to all of us. - You've learned to write code, now you need to learn to *read* code. Specifically, other people's code. Lots of blogs out there on this subject. - Similarly, other people are going to be reading your code now...sometimes years from when you wrote it. Keep the future reader in mind while writing and people will appreciate it.
Someone responded with precisely what I was talking about that answers the question posed \([https://www.reddit.com/r/javascript/comments/8ixj1a/is\_there\_a\_way\_to\_use\_rxjs\_as\_a\_store\_instead\_of/dywqggz/](https://www.reddit.com/r/javascript/comments/8ixj1a/is_there_a_way_to_use_rxjs_as_a_store_instead_of/dywqggz/)\). Saying RxJS doesn't do anything like it misses the point.
You might as well say JQuery does the same thing as Redux if you count "technically implementing something kinda similar" as the criteria for overlap.
Did you target a company, or did a recruiter work with you?
Oh
because it's not a Koa feature but an ES feature. with babel you can have asnyc/await on any framework To talk about the reasons why one wants to switch to Koa you should use something Koa exlusive or something very hard too to achieve with Express
Absolutely agree.
Senior developer with one year of experience? That's surprising. No offense intended, it just seems odd. I'm a plain old developer myself but I interview seniors and it's hard to imagine anyone can achieve their level of expertise in 2 years, let alone 1.
What do you do with github just put all the programs you’ve made there ? 
If you're the one at the keyboard, yeah, pair programming can be very nerve-racking. Even after 4 years, I still get nervous and forget how to use a computer whenever someone is watching me :p Though, in this case, I mean, watching a more experienced dev and working through the problem together or having them explain their thought process as they go. You'll pick up a lot of stuff that way, like some new keyboard shortcut you never knew about, or a command that saves you a few minutes, or just seeing how they work through a problem.
/u/_Include, Koa and Express, are backend frameworks for building servers and APIs. Both created by the same author, with reason. React, Vue and the other "UI Libraries" are frontend frameworks/libs. All of them have one purpose - simplifing the building of user interfaces, but have implemented that purpose in different ways and have different principles and ideas. There's also something called SSR (server-side rendering) which combines the both worlds of frontend and backend. For example React + Koa/Express. MarkoJS is for building UI again, but seems more like template engine and combination of languages and styles. For example its html is more like the fameous JadeJS (which last year was renamed to PugJS)
Can’t see anything useful in the docs, does this handle dynamic pages with React and such? Which part of it makes scraping simple?
Absolutely. I find it better that you learn the "old" way, the roots of the language, then learn it's modernized version \- it's more work, but you understand the reason why things were how they were/are today. If you, or anyone, is in need of a buddy to help, give me a shout I'd love to assist.
That was one good thing about working at the Starbucks office. We could make it ourselves with an espresso machine.
cheerio is optional, basically we're using jsdom to get html and runs javascript on that page.
I suppose that what I lack in experience (actual time as a professional), I make up in my ability to learn quickly and "go after it". And even though I just started my career I had been eating, sleeping breathing programming for some time before that. I took ownership of several projects, from start to finish, in my short time there. I add a lot of value to a small team. I also mentor new hires for what ever thats worth. I'm not saying I'm Bill Gates or anything but I know my stuff. I might not be a senior at say, Google, but I perform as one where I work. I actually asked for mid and made my case as to why. At my performance review I was bumped up to senior because that's what my lead felt that I deserved.
Thank you for your help. This helped me understand exactly what was going on.
Suggestions here are good, but I want to add a method that works well for me: Pick things apart (such as codepen examples), recreate something similar and google (MDN) things you don't understand. You'll learn important things in practice and theory.
http://docs.phonegap.com/tutorials/develop/hello-world-explained/ I recommend looking into React Native instead, if it suites.
Turns out I can write other cookies but I don't see how to check the session cookie. Its not showing up with I search for my domain name. Does this mean its not being sent?
This is the best advice in this thread. I came out of school with a major only halfway in development. When I started my first job every single person I got hired with knew way more than I did (they were also fresh out of college). The equalizer was understanding the business, knowing what I was developing and WHY I was developing it. A few months after my application went live I asked my boss to go talk personally to the end users, took notes and presented their concerns and ideas back and got them implemented. 
That is in line with what I saw on my own tests. Using the latest from your fork, here's the output with 10,000 items (running LTS): native map x 5,958 ops/sec ±0.87% (86 runs sampled) lodash x 6,393 ops/sec ±1.39% (85 runs sampled) lodash/map x 7,038 ops/sec ±1.34% (85 runs sampled) lodash.map x 7,010 ops/sec ±1.29% (85 runs sampled) native for x 17,691 ops/sec ±0.80% (89 runs sampled) Fastest is native for If I increase the number of items to 1,000,000 on LTS, I get much poorer performance for native. native map x 2.78 ops/sec ±1.45% (11 runs sampled) lodash x 43.31 ops/sec ±2.83% (56 runs sampled) lodash/map x 44.72 ops/sec ±2.83% (58 runs sampled) lodash.map x 44.14 ops/sec ±3.05% (57 runs sampled) native for x 25.58 ops/sec ±4.06% (46 runs sampled) Fastest is lodash/map,lodash.map,lodash On 10.1.0, things are better for native, but lodash still outperforms. native map x 5.98 ops/sec ±1.14% (19 runs sampled) lodash x 44.15 ops/sec ±5.77% (56 runs sampled) lodash/map x 46.41 ops/sec ±5.12% (59 runs sampled) lodash.map x 47.18 ops/sec ±5.58% (61 runs sampled) native for x 28.65 ops/sec ±5.91% (50 runs sampled) Fastest is lodash.map,lodash/map **But** if you also test a form of your `for` test that doesn't use `Array.prototype.push`, you get the fastest results: native map x 5.94 ops/sec ±3.13% (19 runs sampled) lodash x 45.28 ops/sec ±4.23% (59 runs sampled) lodash/map x 47.23 ops/sec ±5.86% (61 runs sampled) lodash.map x 47.12 ops/sec ±4.88% (59 runs sampled) native for x 28.26 ops/sec ±8.54% (49 runs sampled) native for, non-push x 89.59 ops/sec ±1.90% (67 runs sampled) Fastest is native for, non-push The test looks like this: 'native for, non-push': function() { const result = new Array(data.length); let i; for (i = 0; i &lt; data.length; i++) { result[i] = data[i].num; } } 
well it's jsdom not request 😄
yup, https://github.com/egoist/tokio#optionsrequestoptions 
I'm sorry. I'm so sorry. As much as I'd like to say otherwise, I must confess that I found the tone of your post to be highly patronising, despite what I presume were good intentions. A quick glimpse into my other responses in this thread would have probably helped you a bit here. You bring up two excellent points in technical debt and redundancy, but aside from being fundamental concepts, I can't see how they fit strongly into this particular discussion. I'm happy to read your response if you choose to post one. In the context of this discussion, I am not a hobbyist programmer either. As much as one tries to avoid technical debt (for instance) there will inevitably exist factors outside of our control, nor does my team necessarily have time to place every single dependency under scrutiny.
If you ever experience self doubt, tell yourself, if I can’t figure his out, nobody can. Good luck.
Good luck! I'm self taught and I remember the feeling. You'll do fine. Just remember to never stop learning and always treat yourself like you don't know enough yet. I just got a new job and even with 5 years of experience I'm scared shitless and am not the smartest person in the room. It's a good place to be because I know as I get older I'll still be keeping on top of new tech to try to be better.
Good job! 
Sure. Do some tutorial, hack, add your flavor to it and push it up.
I applied to the job and a recruiter contacted me. 
Thanks for the point of view, I'll keep working at it!
Congratulations! Did that for 7 years. Having a bit of difficulty with finding another company to hire me, so I've branched out into creating my own stuff. Currently in Alpha Test on my first app since going solo, and hoping to get into release within a month. :-D 
Congratulations!
The awesome thing about programming is that it’s so vast and the field changes so quickly that literally nobody knows everything. It’s also a little terrifying because non-programmers that you will work with will expect you to know everything and won’t understand when you make a mistake. But that’s whatever, things happen. Point being that you shouldn’t worry about what you don’t know too much. You will always be learning new things; don’t ever get set in your ways. Good luck!
One thing that made a huge difference for me was organization. Try using onenote if it's available to write down chat convos with answers to your questions. Make an organized folder structure for your bookmarks for work related processes and webpages you will need often. Don't be afraid to ask people about stuff you don't know(especially company processes), but always look for yourself first. Tell the person you ask where you looked, so they know that you tried and you aren't using them as google. Organize your env, make folders for code, documentation, projects, etc. When your in a hurry you usually will name the file stuff and stick it in the default folder. Things get messy fast and there is nothing more embarrassing than someone asking for a doc and it take 10 min to find. Since you are doing webdev, make bookmark folders for dev, qa prod, and store your app urls in there so you don't have to remember anything. 
Check the network response tab. Look for your request. Check for a `Set-Cookie` header.
The fixed-length array is a good addition. I've called it "native for, fixed" and added it to the tests, as well as adding the Node version and test length to the output, to make keeping track easier. I think 1,000,000 records is a more uncommon use case, but it is interesting to look at the data points. Someone with more time and interest than I could execute a number of data sizes against the various versions of Node and plot a proper line graph.
Good luck!! If you taught yourself and make this big accomplish. You will doing very well. Yo got this. 
🙏
Function lock-in. You are ignoring the loss of the ability to use methods on arbitrary, yet compatible data, which is far more of a common concern than making sure my dates are valid in my day to day programming. I use date objects, no sense in reinventing the wheel, though their inherent, unfixable mutability is a source of problems sometimes. I even use classes when a library requires it, but in my own code, they get in the way.
how's it different from the dom js that jsdom offers? 
TIL. Not there. Its there for cookies I set manually but when I remove those and have nothing but the session. Nothing. 
Just search for how to make a react type framework from scratch, there are plenty of guided out there
W3school.com its prettt good for that
Ay I seen you in WDG discord duder. Watup it's Chem. 
MDN is a good reference. JavaScript Jabber, NodeUp, or any number of other podcasts can build up your familiarity with current trends even if you don’t completely follow everything. There are also a lot of good videos out there like the ones at egghead.io. Some people do well with code camps or online courses. Others do best by embarking on a project. If that’s you, start with a simple idea and start building. Good luck. 
1 \- Never stop writing code. Write helper code / libs for common patterns in the code you already have. 2 \- Follow smart people on Github. Smart people will star smart projects. That project may our may not be of use to you, but learning about what it problem it solves and how it solves it will expand your horizons. 3 \- Write tests. You will discover a lot of corner cases. 4 \- Try new stuff out. Write a new project on TypeScript or Reason, learn about the pros and cons of each solution and how it fits different scenarios. There's a right tool for everything, but people hardly know how to identify them.
If you’re willing to share, I’m curious about #1 and #2. This is an area I’d like to improve. I’m also a self taught dev who is about to start the job search.
I hope some day you have a chance to tell your journey. Step by step how you get were you are. Thanks for the motivation 👍
Apologies. What I am saying is that by following what I said, a tool set emerges for you, and a pattern emerges per project. The question, per my understanding, is how do you begin work with native Javascript project, and this was how I did it. Another way of putting it, start with the problem, not the solution. If you start with a framework or boiler plate, you are starting with the solution. Now you might say, boiler plate is less than a framework, but now we enter the realm of subjectivity, and one can ask the question, how much or little do you consider to be 'good'. My answer was black and white, and with black and white it is either is or it is not. When you apply this for Javascript for example, and in the context of browsers, you realize that before javascript, there is CSS and HTML. A browser is useful without javascript, but is not useful without HTML and CSS. You then realize that javascript, in the context of the visual, is partial algorithm HTML and is algorithm CSS. Now you dig deeper, and you find much of CSS is also redundant, or ill defined. You dig deeper, and you find the same with HTML. You sieve, and you end up with minimal set of technologies from which you can have any layout and look you want. Now you might be asking, can we simply approximate, and say avoiding a bit of helping code is not going to cost much? Take the following scenario. A client running some CMS, or custom server side code delivering html, comes and ask, I want a new HTML element that my editors, who are not technical, can use. The element tag should be ul2, is a listing element, like ul, and accepts one other custom html element only called li2, acting like li. I want the li2 to alternate between left and right alignment, and should be able to contain anything, including other ul2. The ul2 should have an option such as li2 elements retain a fixed height, where the li2s automatically resize the font of any internal textual elements only, such as the total height of the li2s reaches the fixed height if it is set, before any cropping. If an li2 can not reach it fixed height, other li2s should act accordingly. Now I want a ul3, and li3, with same behavior, but the li3s collectively should try to match a height set on the ul3 which represents the total height of the ul3. A li3 may contain a ul2, but not vice versa. You can likely tell that solving this with boiler plate, or a framework, is not possible, at least not without all sort of hacking, and even then will not be stable, or well defined. Some thing like this requires a true rendering tree, and strong encapsulation. But note that this is already solvable, but you would not have known the extent of what is possible without going along the lines of what I said earlier. This is the cost of a bit of boiler plate. And this problem has been a possible problem to solve since many years. Incidentally, what I mentioned about removing redundancy, includes information saying more than needs to be said. With this principal alone, you should be able to prove every software design principal out there. Perhaps I am not understanding the intent of your question, and my answer was to address what I thought is the intent, and not the apparent question. If the intent is a journey to truly understand the technologies at hand, I have answered the question, and this is what you would have to follow. Apologies if I am sounding offending. It is not my intention, and I am happy to engage you further.
People should calm down about this FP trend. This article it just a simple explanation of some Array methods ...
Yeah I guess it can be. Is it possible that you jumped ahead to programming without spending enough time writing regular old CSS or SASS style sheets? Most people I see that hate CSS just haven’t spent enough time with it. There’s plenty of gotchas and exceptions in CSS that are really frustrating until you know them. I write mostly front end and found JavaScript intimidating at first so I spent a long time just writing CSS for WordPress themes before doing much programming. It started getting fun for me when I’d done it enough that I could write most CSS without using a reference at all. Which just took time and repetition. But having said that. I know that being a solid back end dev is very valuable and I know a couple of guys who have built amazing products in React just using a front end framework. So I don’t think it’s 100% required to be fluent with CSS. But not being comfortable with it will limit what you can do and what jobs you can take. My advice is to consider taking a bit of time to go over the CSS fundamentals and focus on only CSS for a bit. Until nothing unexpected happens and your writing most things without a reference. That’s just based on my experience anyway, results may vary of course. 
JavaScript is relatively inefficient. You can have the web portal be in js but running on python or c etc.
Even if the platform is in js, the runner would be more efficient in python. Maybe with webassembly but then you're working to hard for an existing solution.
http://jstherightway.org/ is a good starting point with a lot of good resources
Hey I'm just starting out and currently work in the film industry. Currently a 1st AC/gaff depending on the job and crew haha 
Even Perl?!
I’m sorry for getting a second opinion, jackass.
Good luck!
So if i build we say some type of calculator or api info based app im going to get 100 NAS or does it need to be more complicated? 
So far I’m very pleased with the performance of the JS backtesting engine. Was thinking about doing some portion in a WebAssembly but we’ll see if that’s warranted as the development pushes forward.
I'm not trying to be rude. You didn't mention if you'd even done a Google search, you didn't mention what experience you have (which it's fine to have none of), or if you have some goal you're trying to achieve. Was there something you already did and had trouble with? Any little detail helps everyone here help you.
One of the coolest things i learned was destructuring assignment. It is a really nice feature addition to the language.
Destructuring is probably my favorite thing in the new iterations of JS. It makes your code so much more readable!
This gives me a lot of hope :) I quit my job as an “implementation engineer” for a SaaS company (not really an engineer, it was mostly debugging installation issues on the front end and some SQL queries) last fall and have been teaching myself JavaScript, specifically using the Node and React libraries, to redo my side business’ website. I’m wrapping up a project that I’d like to use as my portfolio when I start applying for work. Did you have anyone review it before you started applying? That’s what I’m kind of anxious about — showing that I know what I know via my portfolio.
Good to know, thanks.
Awesome. I started as a PA doing movies for Lifetime channel. Feels like a lifetime ago...
Will do. Gracias!
No. But do keep working on it tho.
Thank you. I'm going to learn Typescript right after react and redux. Roughly speaking I understand how Webpack works. But I want to use it properly. Just to be able to create custom configuration.
Congrats! I had your exact same experience. You’ll be drinking from a fire hose for a few weeks.
Congrats!! How much time you were learning until you find a job? Was it hard to find it? Which technologies do you know? i'm trying to get my first job as a web dev haha.
return new Promise.
Haha very awesome! I kinda grew up in the industry but we looking for some change so that's what got me started into programming. I'm loving it so far 
Finally had a excuse to try [redux-observable](https://redux-observable.js.org/). I know I'm a bit late to the party but it's my first dive in rxjs. Oh the possibilities!
So you'll need to sort out why that cookie isn't getting sent.
I'm learning JavaScript and was the last cool thing I learned about it haha
I meant use the word in a sentence kind of elaborate
Leetcode?
Tensorflow.js!
We all were, just don’t lie about what you know and ask for help
Other posts from u/mysliwik in r/javascript: [Apollo GraphQL &amp; NestJS integration is FINALLY here! Create well-structured node.js server-side applications with GraphQL and Nest framework.](http://reddit.com/r/javascript/comments/7n1qc2/apollo_graphql_nestjs_integration_is_finally_here/) [Finally, is there!! Auto-document your Node.js API using Swagger (OpenAPI) module for NestJS](http://reddit.com/r/javascript/comments/7fvseo/finally_is_there_autodocument_your_nodejs_api/) [NestJS is a TypeScript backend framework that is inspired by Angular development style](http://reddit.com/r/javascript/comments/7ejyb6/nestjs_is_a_typescript_backend_framework_that_is/) [Command Query Responsibility Segregation &amp; Event-Driven Architecture with Nest (Node.js)](http://reddit.com/r/javascript/comments/775ibu/command_query_responsibility_segregation/) [Nest - A progressive Node.js framework has a support for pure JavaScript ES6+ BABEL now!](http://reddit.com/r/javascript/comments/759sx5/nest_a_progressive_nodejs_framework_has_a_support/) [Nest.js Brings TypeScript to Node.js and Express](http://reddit.com/r/javascript/comments/74mv5p/nestjs_brings_typescript_to_nodejs_and_express/) [Nest 4 RELEASE is here! Node.js framework built on top of TypeScript &amp; RxJS](http://reddit.com/r/javascript/comments/6zmsqx/nest_4_release_is_here_nodejs_framework_built_on/) [A modern node.js framework Nest 3.0.0 is here!](http://reddit.com/r/javascript/comments/6h66kj/a_modern_nodejs_framework_nest_300_is_here/) [CQRS, event-driven architecture in Node.js with Nest framework](http://reddit.com/r/javascript/comments/6f6yk9/cqrs_eventdriven_architecture_in_nodejs_with_nest/) [Nest FINAL release is here! Node.js framework built on top of TypeScript](http://reddit.com/r/javascript/comments/68zru2/nest_final_release_is_here_nodejs_framework_built/) [Nest RELEASE canditate is here! Introduction to modern Node.js framework](http://reddit.com/r/javascript/comments/61rts3/nest_release_canditate_is_here_introduction_to/) [Build modern &amp; scalable Node.js web applications with Nest (release)](http://reddit.com/r/javascript/comments/5w9xd1/build_modern_scalable_nodejs_web_applications/) *I am a bot and this action was performed automatically. Downvote to remove|[Blacklist](https://www.reddit.com/message/compose/?to=allsubmissionbot&amp;subject=blacklist&amp;message=blacklist)*
[Shameless_plug] https://github.com/polterguy/phosphorusfive [/Shameless_plug] It _"bridges"_ the backend with the frontend, and allows you to almost not care about the frontend at all, since it's a server-side markup language that will automatically _"generate"_ your front end.
Check this web site [http://topjavascriptbooks.com/](http://topjavascriptbooks.com/) it has a list of the best javascript books
From JSDOM docs: &gt; However, this is also highly dangerous when dealing with untrusted content. The jsdom sandbox is not foolproof, and code running inside the DOM's &lt;script&gt;s can, if it tries hard enough, get access to the Node.js environment, and thus to your machine
The guy above is spot on. One additional piece of advice, from my experience doing what you did - you might feel the urge to 'catch up' with others by working late, trying to do 1AM check-ins etc because you don't want to go into tomorrow with the same issue. Stop, leave it. Very little good comes from all night slogs. Take a break, do some non coding, if you have stand ups in the morning mention what you are stuck with. If it's a good place with a good team, someone won't mind giving you pointers/pair programming and you'll probably get it done in 30 minutes and learn from it. Rather than losing 6 hours of your own time and feeling burnt out.
Async/Await, I even wrote a [blog post](https://medium.com/@dejan.dabic32/async-await-or-how-to-make-a-promise-the-right-way-8c5d5ad7ad4b) about it.
[removed]
Do you have an online portfolio? 
Really? This changes everything!
Just be humble, don't give up and never stop learning. I'm 20, two years of experience as a JS/Blockchain dev, fully self-taught. You have a fun ride ahead of you :)
Sure! Thanks!
throw all the stacks and frameworks into the trashcan and focus on the vanilla/core HTML, JS and CSS for at least 2 months. Create something with only those. There's a bunch of opinionated fluff around frameworks and boilerplates that are completely unnecessary and also very overwhelming for a newcomer because you can't tell what's what. You don't have any intuition yet to what knowledge is relevant and what's irrelevant so you're just absolutely overwhelmed by the jungle of noise that's out there. Fiddly is mostly what coding is, and definitely what CSS is, and you should learn to love it and learn to use tools like the chrome devtools to help you fiddle around.
Same here
Lodash can help out here. I think the pick function is what you’re looking for.
i have been working with Angular and Spring this last year and I had a really great experience with Nest. Worth a try !
You could do it like this ([fiddle](https://jsfiddle.net/slikts/dewh8m5x/)): entries.filter(({entries}) =&gt; entries.length) 
You don't need lodash for something as basic; `Array#filter()` works even in IE9. `pick()` would also not be using destructuring.
well that filter function eliminates all empty arrays. But my goal is that let array = [{name:"one", entries:[1,2,3]},{name:"two", entry: [4]}] becomes let entries = [1,2,3,4] and after that, which is doable with the filter function, add a limit like entry &gt; 2 let filteredEntries = [2,3,4]
I refuse adding dependencies if i can achieve it by myself. Although, thanks for the hint. 
[`Element.setAttribute()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute) returns `undefined` by default.
&gt; Feel free to completely forget about the `getElementsBy*` Unless you need a live collection.
That's different from before, but anyway: const flatten = (a, b) =&gt; a.concat(b); const entries = array.map(({entries}) =&gt; entries).reduce(flatten); // -&gt; [1,2,3,4]
Don't worry too much about Redux either, by the way. Understand what it is, sure, but don't worry about shoehorning it into your application - anything you build at this stage won't be big enough to warrant a global state store atop React. Also, take a quick look at other global state stores as well, for example Mobx and my personal favourite react-easy-state. Again, no need to learn them all, don't feel overwhelmed!
oh damn, that sounds logical to me. Thanks for sharing and sorry for the off topic. I guess that was the last cool (JS related) thing I've learned.
Have you worked on bigger projects? If you did I don't think you'd be saying that :P
I've worked with both after moving on from Backbone. Even though there are important differences between react and backbone (mainly jsx and a more functional approach to programming) there are similar in that both cover only the View part. That means that, even using create-react-app, you'll have to choose how to manage state, which library to use for requests, which one to work with forms, etc. If you have the time and work in a small team that shouldn't be a problem, but for large teams or projects you'll end up with your 'own' framework and way of doing this. Angular on the other hand will have a much more steep learning curve, but out-of-the-shelf will provide you the 'right' way of doing things. That means that the code from all the people in the project will be more similar, and getting new people to work with your codebase will be easier. In the end I enjoy a little bit more working with React, even though sometimes I get burned by having yo choose among so many libraries and ways of doing things. That said, you'll be fine with whatever of the two you choose. 
Code your backend Javascript like it is 1999!
"Native" isn't up for discussion. Native is code compiled for the platform, without GC. How can you even ask: "What does "native" mean to you? " It's like asking "What does the earth is not flat, means to you"
Shit, thanks for #4 and #5. Honestly. 
Don't fap on work dude! Just....don't!
I've been doing this for 8 years, and still get the feeling of imposter syndrome so just know that we all feel that way at times.
Please please please try to learn, there are things the comp sic kids know that you don’t and vice verse 
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing.
Does a factory function work well with static type checkers like TypeScript?
[removed]
If it's not too forward, what salary range did you start with? Big city or somewhere smaller? I'm looking for my second developer-specific role and wondering if 70-80 is too high. 
Yeah, it’s not going to work most of the time, but it might stop the few (painfully few!) recruiters who bother to read your profile rather than mass-mailing a set of search results.
Thanks. Favorited on GitHub as well. :-) 
Thanks :)
We have a full Starbucks at our campus. Bam.
I'm gonna give you a biased answer. If you want to be employable learn Node, Express, Mongo and React/Angular. Once you know those learn alternatives but mainly for your own convenience of side projects or your own company. Also having knowledge of SQL databases is also appriciated.
That's funny. I'm using React during my full-time job but I'm only doing Backbone for my sides projects 'cause React isn't "that perfect". But I won't do any Angular ever I hate the way it's done (architecture and mentality about the framework) + typescript. The reason why I'm still using Backbone I guess is because I don't "need" to do jsx (because React without jsx is painful, but with jsx you need transpilation all the time like with typescript and it involve a lot of stuff in). When I'm doing Backbone I feel more "JS and HTML" than I am with React. So I probably keep Backbone to see something different time to time lol. Maybe a Backboner syndrome.
Congrats! I also just (hour ago) landed my first developer job and I am self-taught. Feeling happy, excited and scared :)
More generally if you're not re-loading lodash before every call it's faster than native **in Chrome**. [This is a known problem](https://bugs.chromium.org/p/chromium/issues/detail?id=772154#c1) &gt; The native Array#map was always very slow in Chrome/V8 because AFAIK it's switching execution contexts between C++ and js. […] Previously [nb: Chrome 59 and older) it was 40-80 times slower, now [nb: Chrome 60 and younger] it's "only" 6-40 times slower. &gt; In Firefox 58 the native Array#map is faster than both Chrome's native and FF's custom js 
Oh man so so much! I’m a pretty new JS Developer and I recently got my head around OAuth and Passport.js. I know that’s not the coolest thing but authorization was really hard for me and fun to figure out!
Well it isn’t necessarily cool but is good to know; it’s not possible to bind **this** to a arrow function. Learned about it a few days ago when this was always an empty object regardless of what I bound it to. 
@jerk\_at\_work would disagree
vueJS is probably one the best i've seen, also making the docs compatible with Dash/Zeal is useful too.
beta.freecodecamp.com
Oh, that is surprising. There are quite some Vue jobs here in Berlin.\* I am kind of surprised that this does not apply to other locations. \*However, there are of course much more NG &amp; React positions vacant atm., as far as I can tell.
&gt; I don't get why it continues to be used as a general-purpose database. My reasoning: When I'm testing a theory and I want to do more than save to a JSON file but less than set up an actual database, I reach for Mongo. I also reach for it when I'm saving some text in a general structure but my queries will be from some view of the data, not the data itself. Example of that might be when I am saving some Big Data ( TBs locally ) that I need to save and then build some MapReduce/Some Other Thing out of. So to answer succinctly: if it's a toy project, Mongo is just _easy_. If it's not, Mongo is great for similar reasons to Redis.
Angular to polymer? That's an interesting transition.
&gt; There are three kinds of lies: lies, damned lies, and statistics. For this benchmark we implemented Treap in a few classic (C++, Java, Python) and hyped (JavaScript, Kotlin, Swift, Rust) programming languages and tested their performance on Linux, Mac OS, and Windows (all of them running on different hardware, so the results should not be compared between platforms). Implementing data-structures might be considered as a task that is out of JavaScript scope, but never the less, see how it performes!
Why would you recommend against using redux observable?
I agree with other comments. Learn the old syntax and there is way more that’s the same than different. You will end up working on older code bases in your future career and you’ll need to know both. 
Congratulations! Let me tell you in my 17 years of working in the industry nothing gets you more pleasure and success than self learning. If you love programming it’s the best job! Keep learning and good luck!
Why no Go? It's arguably more widely used than Rust.
https://eloquentjavascript.net
I'm not 100% sure what I'm looking for, but I'm not saying anything indicating it's working on that page. Just a bunch of horizontally scrollable content with my cursor looking as it normally does. 
I am sure there is a good reason, but I personally don't like that after you get a response, that the .json() method returns a promise. Not that it really looks any different if using async/await, but still, since I don't understand it, it just sorta bugs me. 
" Web development is the 'easiest' to get into, as there is a lot of demand and you really do not need a degree to get a job as a web developer. " THIS 
const func1 = () =&gt; this; func1.call({ a: 1 }); // returns { } const func2 = function() { return this; } func2.call({ a: 1 }); // returns { a: 1 }
Gotcha, thanks!
well, check out this talk [https://www.youtube.com/watch?v=JkXZ35MSLaE](https://www.youtube.com/watch?v=JkXZ35MSLaE) They show a usecase in which you cannot use **.json\(\)** 
As far as I can tell it shows an icon only on mobile. And only on mobile, not even in responsive device in devtools.
There is none. Maybe when you can get trough some algorithms and when you follow some tutorial without having a lot of trouble. But honestly is like everyone say about anything, if you wait till you feel you are ready, you will wait forever.
Indeed. 
Yes, big city, and I believe that’s not too high for your 2nd 
30, for about 3 yrs on and off. 
Really, after all that time? How? In what sort of situation?
I just learned you can destruct nested objects. \`const user = { id: 339, name: 'Fred', age: 42, education: {degree: 'Masters' }};const {education: {degree}} = user;\`
Around 2 years. Not really. React. Graphql. Node. Redux. React native. Jest. Good luck, apply and go to interviews even the ones that are out of your league, it’s good practice.
Destructure. Destruction is something else.
Sure, most places I've worked have had a ticket system like JIRA. In the morning (10ish so everyone is in) someone goes round the team and each person gives a really quick summary of three things: what they did yesterday, what the plan is today and anything that's blocking them. The nice part is people will usually chip in with helpful bits and pieces, so it stops you getting stuck in a hole. The idea is to keep everyone on track and move the tickets along as efficiently as possible.
Don't ask questions before poking around to find the answer yourself first. But also, don't poke around for too long and stay silent. Being a successful junior dev is a mix between willingness to explore code and not being afraid to admit you don't know something. Also, own your work. Don't just do it to get it done. Show the leads and managers that they can depend on you to get shit done
Thank you!
Recently learned closure and scopes in depth. Life changing moment.
Hi /u/SilleryC, For javascript help, please visit /r/LearnJavascript. Thank you!
How long have you been teaching yourself/preparing? 
There are a few things particular to `redux-observable`: - I don't care for side-effects being aware of any particular action(s). - Having the store passed as a second argument introduces race-conditions if your store is not immutable. - There isn't a good testing story. I'd say I am more opposed to streams/FRP in general. - RxJS is a huge library to learn. - Streams can have internal state. - Async and sync code are shoved together despite sync code being much more easy to test. - They tend to infect everything since they are so "powerful." And most importantly, I have found I really don't need streams. FP is enough. You could say I have bias because I wrote a [FP JS framework](https://jew.ski/raj/) and want it to succeed. I do but only because everything out there is way more complicated than it need be.
If you learn best by reading then just pick up some intermediate JS books. If you learn best by doing then think of some more advanced project ideas and get coding, learn as you go along (just be sure you’re following best practices and aren’t just hacking your way through). Also it’s useful to understand what’s going on under the hood. For JS specifically check out the JIT compiler and event loop. For more general knowledge, learn about the basics of computer science: data structures and algorithms, big O notation, and general programming courses.
This is more office politics than anything but if your team made a decision to use a tool they should stick to it. We decided on Flow for our team, for the first few weeks I had to chase people around who went into my projects and didn’t bother with it - just had to be “that guy” for a couple weeks lol
Also check out [redux-saga](https://redux-saga.js.org/) for a different take on the side effects issue! 
Or Ionic, if the goal is implementing a web-based app.
For..of can be pretty useful since you can as avoid any unnecessary processing with continue or break
If its any much easier for you, I’ve just been employed as a senior developer in a finance giant (self taught - 2 years) while feeling completely inadequate for the job. My line of thought is that if I went through all the stages of recruitment process and they still offered me those terms, jokes on them! :P
I'm sure a good start would be jQuery. However, I'm an aspiring javascript developer so I could be wrong. 
Is it like a conspiracy or something? Do they meet in secret places and discuss ways to kill the `for`?
WebAssembly is now supported in all the important browsers.
Somehow I never knew about the `element.scrollIntoView()` function. https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView
Also, everything is EXP++ for my leveling up. 
~3years studying by myself while working. 7month full on and giving 100% attention to the plan.
There is no push. The language is offering different tools so that you don’t have to write them yourself. For instance, forEach is when you need to apply something to each element. If you need a break in a forEach loop then forEach might not be the right choice. Map is there if you want to build a new array from a subset of filtered data. Sure you can do all this with a regular for loop but using these tools, the code is often cleaner and shows intent. 
It’s a thorough introduction, but if I were starting to build this today I’d be looking at [SAM](https://docs.aws.amazon.com/lambda/latest/dg/serverless_app.html). The API Gateway/Lambda architecture is fun to tell people that you have, but it’s hard to maintain for any real API. SAM helps with that. I used to run a setup like this. It was hard to consistently get sub-100ms response times because of all the overheads.
If you really need to exit early for performance reasons (note this is almost never true) using a for loop is your best option. 
Well I definitely feel overwhelmed. For about three months, lol. I think to take some rest just to calm down a little. Thank you, I didn't heard about Mobx.
You're missing a semicolon in the second line: const func2 = function() { return this; }; func2.call({ a: 1 }); // returns { a: 1 }
That's not a "push for .map over for", it's part of the Functional Programming paradigm which is gaining some friction now. The idea is to avoid mutating variables, which using a for map usually results in.
Also, for clarification, the first one returns whatever the global object is. So, in a browser console, it returns the *Window* object.
https://nodeschool.io/ I really like their interactive tutorials. LearnYouNode was an excellent intro to node.js
Thanks. 
Thanks for a first of its kind (far as I know) reference for truly modern JS. I'd like to ask, tho if you could see your way to using a more practical example for promises than set timeout. A database call, reading a json file, anything. Yes I realize that it's just an example. However, it would serve the example better to show how returned data is dealt with as well as the wait for the data. Personally, it makes it more difficult to understand because setTimeout would not generally be used in this context. Full disclosure: I've been quiet a while trying to understand promises, yet every example I've ever seen uses setTimeout. Probably because everyone else does it.
It's not necessarily a functional thing. Its really declarative vs imperative programming. When you use map/forEach/reduce etc, are you going to optimize your loop as good as a Google/Apple/Microsoft/Mozilla engineer who optimizes the array methods? I prefer to let them do the hard work and I get nice readable code :)
He might be referring to the eslint rules you can apply.
&gt; If you really need to exit early for performance reasons (note this is almost never the case) What about exiting early for other reasons: this is not infrequently the case. Consider the following loop from a recent project of mine. If I don't `break`, `maxColumns` good very well continue to get incremented when it shouldn't ``` for (let i=0, n=columnWidths.length; i&lt;n; i++) { if (windowWidth &lt; columnWidths[i]) { break; // Used traditional for-loop since forEach does not support break } else { maxColumns += 1; } } ```
As someone else said; break/continue to save cycles is massively helpful. For example when you are setting up event handlers inside a forEach loop it won't get confused which `arr[key]` you meant (often it just takes the last one). There is an issue where you can just grab/set any arbitrary key you want. So you can do `var arr = []; arr[1] = 'foo';` and the length is 1 even though you skipped the 0 index. Otherwise I prefer the forEach/Map because the scope gets locked into the function of the prototype method.
Define “the plan” exactly. I’ve been self-teaching for about 3 months. I’m also a full time college student and work part time, so I’d say I give about 2-5 hours a day, most of which has gone toward learning vanilla js. I plan on attending a front end bootcamp at the end of the year. I know that I could probably do it on my own but I simply don’t have the time. 
ES6 modules and native export/import
Depending on the size of the table you might run into some issues. Rendering thousands of DOM elements is slow no matter what. If all your rows are in the DOM and you try to filter its going to cause thousands of DOM rewrites/calculations that are slow. To get around this you'll need a table plugin that keeps your data in memory and only renders 20-200 rows at a time. Then when users scroll, the plugin will swap in the relevant in-memory data to the existing DOM elements.
Those are very reasonable criticisms however I did lean the opposite way having been in-love with streams since first being introduced to them 3 - 4 years ago using Gulp. Especially working in Elixir and Clojure where streams are built into the languages itself I've found RxJS to be very helpful in modeling complex asynchronous logic. That said Raj does seem like a very impressive project in its own right too, so perhaps I'll give that a shot in a future JS project. I really like the redux-observable approach personally since it allows me to compose actions which maps very naturally to a domain-driven-design approach and can be documented simply in an event-storming diagram. &amp;nbsp; I can't imagine not using an immutable store but that is a good point to be aware of for future use cases. If you use a redux-ducks-like architecture I've found testing them to be pretty painless but admittedly the dependency system is a little lacking. &amp;nbsp; I agree with you that RxJS is a huge library to learn but it's conceptually similar to most stream implementations like Elixir, Clojure's channels and lazy lists, subscriptions and the former FRP implementations in Elm and learning it once has allowed me to make use of it elsewhere. Plus most of our codebase can be expressed in Ramda and RxJS which both have good documentation, I feel it's a consistent means of expressing nearly all the problems we have come across. Unlike Raj which creates a new type of interface that's only applicable to a marginalized subset of problems. That said I do like Raj as a solution to the problems it specifically solves but if I personally prefer to use one library to solve many types of problems in a meaningful way where as you referred to streams\frp as infecting everything. &amp;nbsp; Testing streams as if they are always asynchronous has steered me away from any noticeably troubling waters especially when using a testing lib like mocha that can handle promises: &amp;nbsp; it('Should emit a series of letters', () =&gt; stream .toArray() .toPromise() .then(actual =&gt; expect(actual).toContain(expected)) ) &amp;nbsp; Streams can have internal state, that is true, but the alternative is having to move it up into your store or local component state which requires more documentation and testing where as using streams means only caring about the actual data relevant to my domain. For instance when doing a drag &amp; drop UI I can just have a drag stream that takes until a drop stream or mouse-up\esc stream and only dispatch the app data to the store where as otherwise I would need an isDragging flag and model more state and actions to describe that relationship locally or in the store with a bunch of conditional logic to manage that state which means more tests, more actions, and more self-maintained state even though it's a coincidental implementation due to the nature of browsers' drag &amp; drop API rather than an actual domain or business concern, at least that's how it's played out in my experience. &amp;nbsp; That said those are ultimately sound criticisms you laid out and I'm always interested in tradeoffs between FP and FRP solutions. :D 
Not OP, but I try to explain my rationale for the changes I made in many of my git commits. This also encourages smaller commits. This leaves you with a clear, public record of what you did and why. You'd think that this is standard practice, but... naaaah. In most places I've worked you get people committing one or two gigantic blobs and you can't see their thought processes at work (nor can you infer it from reading their code).
That's kind of a big detail to leave out... I guess it's the result of that mentality some have that only smartphones matter.
And how will I get to know current trend and modern programming practices?
Did you check in an incognito/private browsing window with all extensions deactivated? There are many "extension" mentions in your error message and I suspect these are just error of a browswr extension, maybe not even related to your code.
the plan was to get a job. but i spend ~8 hours a day studying 
What you’re describing can be accomplished with the other iteration options. If not, you have some twisty logic that could benefit from a refactor. 
[This is what it looks like](https://imgur.com/a/We0O4dI), the pointer icon is animated.
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/8rdJ0en.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dyywb00) 
You should check out Max's[Nuxt course](https://www.udemy.com/nuxtjs-vuejs-on-steroids/) as well.
Fun fact: I had to explain switch statements to two bachelors of cs on first day of the job. So, everything is kinda relative. ^^
Can you expand on this? Last I checked a basic for loop will often outperform map/reduce as you don't have the additional overhead of a function.
I understand limiting scope, but isn't that a non-issue if you leverage the new ES6 let keyword?
I use for loops a lot, usually because I am looping through arrays of objects in app model data, and doing something where I want the index. I like my friend i, and his pals, j and k. I also find for loops totally readable.
Maybe the scrollbar is the hint.
Why did you downvote me?
foreach is cleaner if you are calling a function. However, if you just have a single line to execute, wouldn't the addition of creating either an anonymous function create more complexity AND overhead. let arr = [1,2,3,4,5]; for(let i of arr) { //Do something with i } arr.forEach((i) =&gt; { //Do something with i }); In most cases you are probably calling a function on each element, in which case forEach because the simplest option, but if you are doing the work inline, is it really any simpler? 
I have seen it morph from, when leveraging functional programming, use map, to *always use map*. Saw a programmer judge a code submission poorly because they used for-of loops instead of array.forEach(). Which I didn't understand.
TypeScript
Yeah it's definitely just because FP is en vogue right now. They are all a little different, for loops can be broken, the functional versions cannot. One actual reason I would give for preferring .map over .forEach or for loops is that the items are immutable. There is no risk of accidental side effects, which makes code a bit easier to reason about.
what's your GitHub? 
Because I'm really not a fan of whitespace sensitive languages and ES6+ has 99% of the features of CS. The only thing ES6+ is really missing is the inline conditionals (and I can live without them): letTheWildRumpusBegin() unless answer is no
You can first debug your application using the chrome inspector assuming your Node version is relatively recent. Place a debugger; statement somewhere before and after where the session gets created on the server. Boot up your node server with the following arguments node --inspect --inspect-brk ./YOUR-SERVER-SCRIPT.js Open up google chrome and go to chrome://inspect in the address bar. You might need to wait a second or two, but you'll see something pop up in the Inspect section, just click the link and a console window will open up, hit the blue arrow and your server will finish booting up. Then make a request to your server and once the debugger statement is hit, the console will come to focus and your script will be paused at the breakpoint, you can inspect the req and res objects to see if the cookies are in fact being set. That'll debug it on the Node side. 
I didn't know that javascript had a built in Set implementation \(a collection of unique values\). Found this super useful for work task last week.
That’s the point though: different use cases. I would use a for loop if I’m gonna use the ‘i’ later on. For instance, I could use a for loop to iterate through a list of items in a cart. For every item that can earn reward points, ‘i’ would get incremented while skipping items that aren’t. You wouldn’t use forEach. 
I agree, this does not seem possible.
Thanks for the lecture. I do high performance graphics, I know when and where to optimize for performance and when to write something that's more readable instead.
I've refactored it myself though it by no means is "twisty logic" to begin with, see below. Honestly it hardly seems worth it -- I could save 4 lines in the original by putting both the if, and also the else, on one line, they're that simple. onWindowResize: function() { // Modifies the matrix when the window is resized such that this.maxColumns is modified const windowWidth = window.innerWidth; const columnWidths = [360, 720, 1080, 1440]; // see style sheet; TODO, make "DRY" across CSS and JS let maxColumns = 1; // Begin original for (let i=0, n=columnWidths.length; i&lt;n; i++) { if (windowWidth &lt; columnWidths[i]) { break; // Used traditional for-loop since forEach does not support break } else { maxColumns += 1; } } // End original /* * Begin Refactored let index = 0; const numColumns = columnWidths.length; while (index &lt; numColumns &amp;&amp; windowWidth &gt;= columnWidths[index++]) { maxColumns += 1; } * End Refactored */ // Avoid unnecessary re-computation of the matrix if (this.maxColumns !== maxColumns) { this.maxColumns = maxColumns; } }
While I’m not a fan of horizontal scroll I can see this being useful for things such as tables with a large amount of columns or other kinds of information that suffers when laid out vertically. This widget looks good and quickly gets out of the way. Nicely done :)
Looks like the link is dead?
How exactly does that seem useful?
Yep, still trips me up. Find myself occasionally going back to `forEach(**function()** { ...` when I need to preserve `this`
Set a cookie. It will automtically be sent to the server with each subsequent request. 
That's not really true. Using `forEach`, `map`, `filter` and the like is beneficial, because it's much more expressive than ordinary `for` loop, i.e. each of them corresponds to a very specific use case, while `for` covers all possible use cases.
Hi /u/iamrohitsawai, For javascript help, please visit /r/LearnJavascript. Thank you!
lodash
Yep, it was an extension causing the console error.
I learned how to use promises properly. It's the most useful thing
I'm working on documenting my vision for the ultimate CMS. I call it the Web OS. I believe the ultimate software platform should have a Monetized Module Marketplace (basically, npm + git + monetization), that provides the plugin/theme function of WordPress. I'm interested in feedback (regarding the link attached to this post). I wrote a quick post about the big picture [here](https://www.indiehackers.com/forum/best-javascript-stack-for-a-realtime-community-platform-7bd6308454), if anyone is interested.
what kind of NLP are you doing on JavaScript 😗
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing.
that's sick! does it still the track lost or doors that come from an api?
For now no think really advanced ^^ to much things to be done, what are you thinking ?
Is gitbooks offline?
In ES operation semantics are not commutative. Logic you don’t scary me.
I was able to help get a legacy dojo 1 based app to compile with webpack (via dojo-webpack-plugin) and so now we have Babel, async await, arrow functions, etc. Pretty fun!
That's the trick... It's a piece of a bigger picture - the Web OS. Just trying to validate the concepts for now. I can't monetize npm. But if the npm guys wanted to create licensing and monetization options for modules, they could. They'd probably have to do the things I wrote about [here](https://github.com/lew42/web-os/tree/master/m3)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [lew42/web-os/.../**m3** (master → 8d0faaa)](https://github.com/lew42/web-os/tree/8d0faaa0cbe7a125595d8cba67340ec95879cd54/m3) ---- 
But that allow you to get the data from dialogflow to build the result that you want to give to the user
Thank you for the suggestion, checkin' it out now 
Yes exactly, how did you know ? 😯
And of course that provide you a way to handle all the intent without any switch or stuff like that and let you manage you application architecture as you want without any ugly code ;)
Yeah, I'm excited about this as well. Sadly I don't really have much use for it at the moment.
I don’t understand what is so hard to understand about it, nor do I understand this manufactured dilemma over which one we should use exclusively. 
let my_entries=entries.map((el)=&gt;el.entries).reduce((acc,el)=&gt;acc.concat(el));
Just published a module that is an isomorphic JSON document store. It uses the filesystem in Node and IndexedDB in the browser. Made it for another library of mine: \[keya\]\(https://npm.im/keya\)
If you ask the same questions too many times I would understand it. Sometimes you have got to ask though. 
Never asked the same question twice, had a notebook for information to take notes the entire time. =(
What is this, Quora? Ask them, not strangers on the internet.
I really don't know I honestly am so confused.
Firebase and Service Workers
\+
Use const when it makes sense, otherwise use let. Done deal.
About 2.5 months of being there... leaves me really in the dark.
You can use the [History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) to manage history without actually navigating to a new page. Look into using Pjax, which is pushState (part of the History API) with AJAX. When a link is clicked, fetch the page using XHR, render it and apply it to the current DOM, and then modify the history to appear as if it's a new page. 
This book appears to be out of date. The React docs discuss most (if not all) of these patterns and are up-to-date in terms of present-day style.
Another great point I would never have thought of, thanks! 
It just sounds like they needed someone who could do bigger things than bug fixes
In my opinion breaking out of a loop is very twisty logic compared to the refactor you presented. Alternatively I would refactor it like this: onWindowResize: function() { // Modifies the matrix when the window is resized such that this.maxColumns is modified const windowWidth = window.innerWidth; const columnWidths = [360, 720, 1080, 1440]; // see style sheet; TODO, make "DRY" across CSS and JS const maxColumns = Math.max(1, columnWidths.findIndex((columnWidth) =&gt; columnWidth &gt; windowWidth)); You might need to subtract 1 from that index, I didn't actually test it but the idea is pretty clear
One of two things happened: 1. You were given incomplete information 2. You are giving us incomplete information If I had to guess, you were essentially creating more work than you were actually doing. If you asked one question per line of code and never improved, it's simply less efficient to have you on staff than to not have you on staff. 
[Couch CMS](https://www.couchcms.com/) is really easy to get stuff up and running fast. Well documented, and uses intuitive tags.
Whats the state of testing and CI at your company? Maybe you could build an analytics tool to figure out how users use your products and where they spend the most of their time.
Couldn't agree more
Maybe [this one](https://www.robinwieruch.de/why-frameworks-matter/) is a good starting point. The thing you need to figure out beyond is would be implementing your own routing.
what do you mean by "react templates" ? 
We actually have a pretty solid CI, but a tracking and analytic tool is a good idea, we use splunk, google and MixPanel, but there is no standard, and most apps we build don't use any
Hey thanks :) yes, setTimeout is a very simple example. I'll try to come up with something more useful :)
More a mix of vendor, DOM, and JS but the last cool (or mildly interesting) thing I learned was that id attributes become properties of the window. So this: &lt;div id="smashmouth"&gt;&lt;/div&gt; is held in this: window.smashmouth 
Cool thanks for posting, I too didn't see anything on the page.
I mean like component libraries or component templates for new react devs etc. 
Cool, thank you! It's a good starting point for sure
Epic! Will try!
all styling is done by the app. api provides any metadata
Article author here. I copied and pasted the Angular \*ngFor template example straight out of the Angular docs: [https://angular.io/api/common/NgForOf](https://angular.io/api/common/NgForOf). So if it's a poor example then your comments might be better directed towards the Angular Team.
Article author here. The point I was trying to make about TypeScript isn't that it's good or bad per se. But more that in Angular you are pretty much *forced* to learn it right off the bat, before you can do much coding. You can use TypeScript in other frameworks, such as React and Vue, but it's *your* choice.
This is something I've been trying to work on. I saw a piece of advice saying to *never* use the `-m` flag when running `git commit` and to write a short summary on what you did and why in your editor of choice. Suddenly I found myself writing fucking novels in commit messages. Now I'm trying to break my commits in to *way* smaller chunks... I feel like I've been missing a ton of due diligence on my previous work now.
It took me like 10 tries trying to understand promises.
#somebodyoncetoldme