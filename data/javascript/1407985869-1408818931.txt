This is a decent write up on how to write cleaner code using object-oriented style code in JavaScript. However I felt the author had some confusion and kept selling it as "Choosing OOP over functional" whereas what they were demonstrating was "OOP vs procedural"
On this page: https://developers.google.com/gmail/api/v1/reference/users/messages/list The instructions say to use this to retrieve messages https://www.googleapis.com/gmail/v1/users/userId/messages are you including "userId/messages/"? EDIT: can you even use javascript on the gmail api?
I believe it is in beta. You are supposed to be able to use the GMail API in chrome extensions and js is used in building those usually. Thank you. But, now, how do I get the userId after the user has signed in with the G+ sign in / authentication js api?
would you recommend babylon or threejs?
Just made a little one-pager that I hope will become a useful collection of links to React.js components. I've been using (and liking) Reactable (a table generator), so that's my first post. If you guys know of any, feel free to add to the list!
Why no mention of meteor.js?
Can somebody give me a practical example when I would use currying?
The most practical in javascript I would say is if you want to send an ajax request to the same URL with different options using jQuery. You would have something like: var update = curry($.ajax)("/url"); $("#button1").click(function() { update(options1); }); $("#button2").click(function() { update(options2); });
Event handlers when you want to have note params than the standard 'e'
Thanks for the heads up. Fix going out now.
Thanks. That looks very clean.
I'm not going but those are very cheap tickets. 
As Paulrouget mentioned, changing class animates if it has a transition tag. If you have a class ".up" which moves some element up by 10px and has a transition: .xs; css tag, it will transition when the class is added or removed (which can be done in jquery) But the issue is, CSS is not variable its static, so once you move it up 10px with the ".up" class, you cant move it further without more classes, and thus you kinda make the whole process very ugly. CSS would be best for looping animations or animations that can go back to its initial state and look right doing that; such as a sword swing, character spins, etc. You can also animate sprites in pure CSS using keyframes, not sure if you do yet XD
Yep, pretty much!
It's hard to answer to this question... Babylon.js is a game engine, but very recently created. Three.js is here for years now, and you can do a lot of thing with it. My heart goes to Babylon.js, because I think you can do simple things very quickly, and because I feel like I'm contributing to the engine, by reporting and fixing bugs.
Thank you :) I've been thinking about the AI, and I think I will integrate it .
Great post, but my personal preference is to still have single resource pages return an array of data (either length 1 or length 0 if not found). It helps with consistency. Additionally, the meta field should almost always contain information regarding the number of records available and pagination data. I'm the core developer of [FastAPI for Rails](https://github.com/thestorefront/FastAPI) and that's exactly the approach we took.
&gt; I'm confused about who the audience is for this article. Yep. Me too.
Could you please provide an example of something you'd separate? Thanks! (I realize I've been asking for a lot of examples on this comment thread, but I'm more a visual person. It helps me greatly!)
Good updates so far, I'm feeling better already 😉
Wow.... ExtJS is sexy. I've been building my SPA with free libraries and frameworks I've been sticking together manually. I've found JSReport, but it looks like requires its own server. Not really a library unless I've misunderstood something.
Lauren Orsini has a habit of writing these kind of articles. They're highly specific, technical articles written from the perspective of someone who doesn't know anything about the subject. I don't entirely understand why someone would think a developer wouldn't see through this immediately, but it almost seems like she's writing to a "conversational programmer" of sorts. Someone interested in being able to debate the merits of Ember and Angular having never written a line of JavaScript in their life. I can only hope this kind of person doesn't exist... 
Not to be a "Debbie Downer," but considering this quote: &gt; Over the long term, the company’s goal is simply to win over developers. Newcomb and Lu want to get a million developers committed to building apps and services on the Famo.us platform. That’s why the company isn’t charging developers to use of the platform now, and may never. How are they planning on monetizing this to the tune of millions of dollars?
IMHO, currying is one of those things that looks really cool and is fun to think about, but has little use in a large, non-trivial application. Interfaces making use of currying are harder to document and learn compared to more traditional APIs, so the cost usually outweighs the benefit. 
Evidence to your point is I have yet to see a blog post in currying that doesn't use some trivial functions as the example. It seems neat, but the use cases seem very small. Plus my brain has yet to fully grok currying.
haha. This made me chuckle!
Tried but I'm not going to complete it. There are too many missing answers.
No, you shouldn't be excited by a feature like this. Fully mutable data by default was bad enough, now we'll have fully mutable data that can cause external side effects to all observers by changing the data as well. So reasoning about a program that uses this will be almost impossible since you'll never know the full effect of changing an object property at any time. Who the hell thinks this is a good idea outside of the angular team?
Hello, I am the author of Reactbone. If you have any questions or would like to see some code examples, I am here for you. There are plenty of projects in the React-Backbone space, but I believe Reactbone is the right method of integration between the two. I have used Reactbone in multiple applications of different sizes and hope it helps you too.
I added your repo to my new collection of react components... leesalminen.github.io
Hmm, strange. I just tried and it loaded fine for me. What browser are you using?
Chrome Version 36.0.1985.125
Its not working for me either. Do you perhaps have the page cached?
I think the problem is that I've never seen a use-case that actually really helps, yet I see posts about currying EVERYWHERE. I think it's just one of those things everyone wants to post about right now to seem cool, except no one is giving any actual real-world examples.
read the article? Cloud Services.
It doesn't work for me on my works network (not blocked, just doesn't load) but it works on my cellular connection. Maybe a weird DNS issue?
Agreed. It's undoubtedly a cool trick, and good to know what it is. I've never seen it in code I've worked with though. If I could find a smart and useful way to use it I would because I'd feel all cool 'n shit.
Very nice. Impressed at how well it runs, even on my tablet. Also, feel like this ties nicely into Google's new Paper design paradigm ;)
That's like asking for a practical reason to use nutella. Just do it. (actually I'm curious too)
JavaScript? Verbose? Compared to what? Brainfuck? Java is verbose. JavaScript is not.
Very nice, but what is the use-case?
If you don't know JS, we're not going to be able to do anything for you. We can point you to [resources that will help you learn JS](http://www.reddit.com/r/javascript/comments/2d3kns/looking_to_learn_js_have_feedbackquestions_about/), and we can try to answer specific questions you may have, or help you to debug specific code samples, but there's not going to be any silver bullet for your current issue. It sounds like your options are going to be: * start learning JS, and hopefully learn enough in a short enough period of time to resolve your problem * notify your superior that you don't have the skills to implement that feature, so that they can get someone else on the project that can * contract someone to do it for you * just comment it out and hope they don't notice (inadvisable)
https://news.ycombinator.com/item?id=8176672
Interesting. I figured it was Canvas or SVG, but it's actually CSS transforms of one or more HTML elements.
Ruby. Semicolons? Parentheses? `var`? Curly braces to start functions, conditionals, and loops? The information density in JavaScript is pretty low compared to Ruby. Of course it's all relative - your apt comparison to Java for instance. But then you realize how redundant it is to have two characters denote the end of every single statement or expression. I mean, c'mon, it's 2014 already :)
Could you show some examples from the projects you've used it on? Does Reactbone ever get in the way or confuse things? Is it easy to use in tests? 
The unnecessary syntactic sugar make ruby one of the most redundant languages IMO. There's so many ways to do simple things and it really hurts readability. The syntax of JavaScript is much more pure. Most features are orthogonal. The only redundancy I can think of is foo.bar vs foo['bar']
I developed Reactbone within the context of a single page application I built a while ago. I cannot provide code samples, but the [case study](http://chrisandrejewski.com/work/jamarkus/) on that app might shed some light on its complexity. It used Websockets instead of HTTP for real-time data. The rest of the projects Reactbone has touched are either yet unannounced or non-disclosable because of client-developer privilege. It would be very hard for Reactbone to get in the way or confuse things. It only exposes three class methods and those methods do not affect work with Backbone or React APIs. Reactbone is designed largely to be transparent and the data flow from Backbone to React is well encapsulated. Reactbone is incredible for tests. Most tools that integrate Backbone and React blend the two together. Reactbone separates those concerns, taking Backbone and manipulating its data representation into something React can better, immutably swallow. But Reactbone really does not need React, all it does is expose Backbone data as simple JavaScript objects. Using Reactbone for tests of Backbone without using React are easy and again with the small API, there is not much of Reactbone itself to test.
Man, I'm really curious on what the hell they actually wanted.
At most you'll need the built-in `JSON.parse()` ([MDN link](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse)); if you're using jQuery and you specify `dataType: 'json'` in your AJAX options it'll do it for you. But let's say you have the following JSON: { "Results": { "Feature Type": { "Features": { "Geometry": { "Paths": [ [ 123, 456 ], [ 789, 321 ] ] } } } } } You'd do: var data = JSON.parse(json); console.log(data.Results['Feature Type'].Features.Geometry.Paths[0][0]); A tool that I like to help visualize JSON is [jsoneditoronline.com](http://jsoneditoronline.com/). 
Thanks for focusing on this topic. I've wondered how long it would take the community to realize that while async operations fit nicely with generators, it's not the reason these constructs exist and there is a plethora of other exciting applications for them. Great write up. 
wtf 😁 "How do I drink water using a cup?"
Or better yet: bash really needs to get a clue about URIs (yes, I know curl exists)
Never used babylon, and I don't have a ton of experience with three, but three.js isn't a full game engine, its just a renderer. They aren't really comparable in terms of features, other than that babylon includes a renderer (but presumably has several other parts, otherwise its a pretty crappy game engine).
Does this do something Express doesn't do? Am I missing something?
Lib names are just getting weirder.
This is more fun than it looks. I'm not sure it's an issue, but some colors look a bit similar: * dark blue &amp; black * orange, red Maybe that's intended as part of the challenge. You may want to try shapes in black and white, for people that don't have the ability to see all colors. Please change the beep noise. It's very high-pitched. Maybe a subtle popping noise (like the noise you hear when you get a new facebook notification on your desktop browser) would be more suitable. EDIT: More suggestions If I turn sound off, store a cookie or something so that i don't have to keep turning it off every time i start a new game. When the game is over, tell me without using an alert box. It hijacks my browser and I can't switch tabs until I hit "ok".
It's the opposite of `express` - it's a library for building HTTP clients (as opposed to servers).
Here's the /r/tabled version (formats the AMA as a table of Q's and A's): http://www.reddit.com/r/tabled/comments/2dkjyb/table_iama_we_build_internet_explorer_i_know/
I don't know why people are down voting you. Well, yes I do. They're assholes. It _is_ a silly question once you see the solution, but a legitimate question nonetheless. Down let these dudes make you feel dumb. (Answer already in another comment, use that)
Mirror since it's down right now: http://webcache.googleusercontent.com/search?q=cache:NylsaiP-qRMJ:mariusgundersen.net/article/3/Other%2520things%2520generators%2520are%2520good%2520for+&amp;cd=1&amp;hl=en&amp;ct=clnk&amp;gl=us 
It's just chrome. You could make an enable/disable button that animates between a check and an 'X' as you toggle.
Why didn't you call it rebone?? 
Meh, sloppy. The square to triangle transformation shows a lot of sharp edges, and has a *lot* more lines than it should. I'd expect just one pair of corners to merge into one, but it does some strange star pattern intermediary. 
Hmm... it should be noted your code doesn't work in FireFox -- the content attribute is returned enclosed within double quotes while you are checking for just the value. Why don't you just use [window.matchMedia](https://developer.mozilla.org/en-US/docs/Web/API/Window.matchMedia) ?
Buttons that change style are a major part of the Google Material design guidelines. Their term for this is ["delightful details"](http://www.google.com/design/spec/animation/delightful-details.html). 
Fizzbuzz? 
Write function "inherits". like this http://nodejs.org/api/util.html#util_util_inherits_constructor_superconstructor 95% fail the interview :)
Hey, don't I know you from somewhere?
Questions like this only filter people who have specialized knowledge not general JavaScript knowledge. I'd hire the latter before the former. 
http://en.wikipedia.org/wiki/Fizz_buzz#Other_uses
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 4. [**Other uses**](https://en.wikipedia.org/wiki/Fizz_buzz#Other_uses) of article [**Fizz buzz**](https://en.wikipedia.org/wiki/Fizz%20buzz): [](#sfw) --- &gt;Fizz buzz has been used as an interview screening device for computer programmers. Creating a list of the first 100 Fizz buzz numbers is a trivial problem for any would-be computer programmer, so interviewers can easily sort out those with insufficient programming ability. FizzBuzz is also a popular Kata in the Software Craftsmanship movement. Computer programmers who call themselves "Software Craftsmen" will write it and a number of other so called 'Kata' repeatedly, often daily, in order to build muscle memory and practise their craft, much like a soldier, a musician, a doctor or a dancer. The following code is an exemplary [*[citation needed](https://en.wikipedia.org/wiki/Wikipedia:Citation_needed)*] implementation using [JavaScript](https://en.wikipedia.org/wiki/JavaScript): &gt; --- ^Interesting: [^Pseudocode](https://en.wikipedia.org/wiki/Pseudocode) ^| [^List ^of ^drinking ^games](https://en.wikipedia.org/wiki/List_of_drinking_games) ^| [^Surface ^lure](https://en.wikipedia.org/wiki/Surface_lure) ^| [^Pin-tailed ^snipe](https://en.wikipedia.org/wiki/Pin-tailed_snipe) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cjqqjbk) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cjqqjbk)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Prototypes and constructors is the essence of JS
Write a function that flattens a nested object into URLs, so that: { 'index': { 'about': { 'team': true, 'company': ['Jim', 'Barry'] } } } Is transformed into: { 'index/about/team': true, 'index/about/company': ['Jim', 'Barry'] }
Basic logic requirements, covers iteration or recursion, simple variable processing. This code is probably useless in the real world, but it's a good way to demonstrate your basic coding ability and thought process in a 15 minute interview segment.
One can not write anything valuable without understanding prototypes and constructors. IMHO 95% js coders did not understand
try moving 'domReady!' to the end of the require block
I've used it for sprites. Especially when Rendering images to a canvas with context.drawImage(), which has a lot of overloads. Combine that with getting images from a sprite sheet. I'm on phone so I can't just paste my previous usage :&lt;
REPL?
You have a point, but on the other hand "deserialize json JavaScript," "parse json JavaScript," "json to object JavaScript," etc on google would have all given immediate answers on any reasonable search engine. Do you think that/r/javascript should be a place where most posts are just questions about basic functionality that could be answered by less than a second of googling?
That worked, thanks a lot. I probably should have guessed that. Now all the modules load, but for some reason I still can't make the div disappear. require([ 'dojo/dom', 'dojo/mouse', 'dojo/on', 'dojo/fx', 'dojo/fx/Toggler' 'dojo/domReady!', ], function(dom, mouse, on, fx, Toggler) { var myToggler = new Toggler({ node: 'square', hideDuration: 1000, }); //Make square disappear on(dom.byId('square'), 'click', function(evt)) { myToggler.hide(); }); Do you have any idea what might be causing it to not run? 
Currious*
Read-Eval-Print-Loop (see: Chrome's dev tools' console)
&gt; One can not write anything valuable without understanding prototypes and constructors. That is outrageously ignorant of you. Sure you can.
Oh, I thought this was a joke thread and that was the joke. An empty page with nothing whatsoever on it. Thanks for clarifying!
I'm not familiar with dojo, but... it looks like myToggler is the controller, so i would do dom.byId('square').hide() instead of myToggler.hide(), since the controller itself probably doesn't have a .hide() method edit: or you can give a this.hide() a try, since this /should/ be scoped to the current element anyway.
1 how is this problem different for JS then it is for PHP or C. Don't the same solutions work everywhere? 2 why not go mongobd-ish? 3 why not call the mandatory .bind(client) inside the public function? Might even do it as a default when only a callback is provided. A bit silly like this.
So I think I missed a comma or semicolon or something somewhere, because after a bunch of random editing it worked, with myToggler.hide() I'm not sure what I did, but I'm just happy to do something with it for the first time. Thanks a bunch, you've been a big help!
I've run into == vs === a few times as a common warm-up question. Also explaining prototypal inheritance.
Extra paren after evt in the on callback. Here is a working example: http://jsfiddle.net/g5bm77ah/ I would suggest using jshint, it integrates with just about any editor or grunt.
Ive seen the inherits question as well as what happens when you dont specify var.
I disagree, Prototypal inheritance is very fundamental to being a good Javascript developer. No, your code doesn't specifically need to include classes or be necessarily object oriented, but I can definitely count numerous times I've written code to extend a library or edit an existing module function. function SubClass() {} SubClass.prototype.myMethod = function() { SuperClass.prototype.myMethod.apply(this, arguments); // new method stuff here } The implementation really isn't even that difficult and I find super calls to functions incredibly useful. Go take a look at PIXI.js if you want to see a fantastic implementation of OO Javascript.
It should be back up again now :)
do you really need a javascript specific question? many companies ask algorithmic questions to ensure the candidate can solve problems related to what the company is interested in. In this vain you might want to do something related to object orientation (which is would be annoying to require in JS), async programming or functional stuff.
Here is a slightly different implementation, which lets you extend lazy with new methods: https://gist.github.com/mariusGundersen/9695efb270b9a5a056eb
None of your examples show how passing parameters is possible.
If you're interested in this, check out [swigql](https://github.com/civitaslearning/swigql). Same idea, with parameter binding and all the niceties of swig templating.
i avoid those types of questions, unless they are related to the work....but typically they have nothing to do with anything and just want to know if you've studied. I was asked how to detect cycles in a linked list in javascript. Guy should have been shot.
This comes up a lot. I generally use Darcy Clarke's questions as a guide ( https://github.com/darcyclarke/Front-end-Developer-Interview-Questions ) but tbh just asking about closures and bind/call/apply is usually enough to filter out 90% of applicants.
Yeah, what a stupid name.
I'm using Durandal on an MVC project (I've thought about moving this to nodeJS for RequireJS optomisation). All data is being called from a Web API project that provides OData. I'm using typescript, so I've written a generator that calls api/$metadata and generates a typescript domain to mirror what is available to call. I've written modules to handle authentication with tokens from the API, loading languages and some limited caching of data. To try and limit server calls (CORS are expensive), I've wrriten a batch request handler that compiles all recent requests. Libraries: moment, chart.js, money.js, gridster, bootstrap, modernizer, select2.js You're right that its flexible, but sometimes it feels like I have glued too many things together, and they sometimes clash. Usually things just not playing well with bootstraps styles.
As a bonus point, make it able to detect/handle cycles.
Implement a binary search tree.
TIL that understanding how to implement a basic feature of OO is considered "esoteric". Good job, industry.
CSS: @media (min-width: 666px) { body:after { display: none; content: '2columns' } } JS: window.getComputedStyle(document.body, 'after').getPropertyValue('content') You will also need to check for -webkit-min-device-pixel-ratio and min-resolution to be retina-proof though.
This helped me prepare for a swath of whiteboard type questions. [Js Assessment](https://github.com/rmurphey/js-assessment). Another question I have gotten a few times is to recreate the .map method. Then pass in a context. var arr = [1,2,3]; var newArr = map(arr, function(val) { return val + 1; }, context); newArr; // [2,3,4]; 
 function getPost(id){ client.query('SELECT * FROM posts WHERE id=$1',[id]); } That is hard to read? No, it's not. 
 s/Browserify/Bower and Bootstrap and jQuery/ And of course Bower is used in the most obvious and horrible way, as usual.
The "where are you from" options are a bit absurd for Europeans. Northern Europe? I'm guessing this means Scandinavia. Eastern Europe? Central Europe? Poland used to be part of "Eastern" Europe for political reasons but recently I've heard it referred to as part of "Central" Europe because it is part of the EU. These terms may *sound* geographic, but they're political -- and they are incredibly vague while at it. Why not use less ambiguous terms the residents might actually be familiar with: DACH (Germany/Austria/Switzerland), Scandinavia (Denmark/Norway/Sweden), BeNeLux (Belgium/Netherlands/Luxembourg) and so on. Or, y'know, just list the damn countries and group them when you process the results. EDIT: And let's not get started on terms like "Middle East" and "Africa". EDIT2: Okay, nevermind the geography, the survey is pretty useless. The answers are extremely biased to the point they are meaningless. In many cases exclusive options should actually be non-exclusive (e.g. "Where do you usually find new libraries?"), in others the options are so extreme it is impossible to answer truthfully (e.g. the CoffeeScript question: there is no "used it, no longer using it" option that doesn't either imply you're still using it or you totally hate it). In some cases it's not even clear what the question is supposed to mean: I've used Grunt but switched to Gulp -- should I answer that I'm "using" Grunt too or should I only select what I am using *right now*? OP, have you ever seen a survey before? Do you understand how they're supposed to work?
Was reading one of David Walsh's articles related to this the other day. Sounds like one solution to what you're asking. Breakpoints aren't defined in the JS at all, but it's aware of what state it's in... http://davidwalsh.name/device-state-detection-css-media-queries-javascript "Being able to detect device state at any given moment is important for any number of reasons and so it's important that web app CSS and JavaScript are in sync with each other."
Nice introduction. I also found that none of the existing seeds/generators/templates/boilerplates/starters were going to work for me so I created my [own](https://github.com/dkrotts/baldion-seed) as well. A few things: 1) Be aware of the [blacklisted](https://github.com/wbyoung/gulp-plugins/blob/master/blackList.json) gulp plugins (including gulp-connect) 2) gulp-clean is [deprecated](https://www.npmjs.org/package/gulp-clean) - use [gulp-rimraf](https://github.com/robrich/gulp-rimraf) instead 3) Consider a [fractal directory structure](https://docs.google.com/document/d/1XXMvReO8-Awi1EZXAXS4PzDzdNvV6pGcuaF4Q9821Es/pub) 4) [Watchify](https://github.com/substack/watchify)
The intended use case for this library is similar to that of require, so at the top of the file you would call makeQuery('query.sql'), without having to supply a callback. It won't really matter for performance issues, because it really should only happen once per file.
better? http://mherman.org/blog/2014/08/15/kickstarting-angular-with-gulp-and-browserify-part-2
We like to ask "What is `this`?"
Sorta depends on what you think they should know. We can go into "stupid programmer questions" like tower of hanoi or fizzbuzz all day, but that doesn't really show you anything. Are they going to be working clientside or serverside? Both? Should they know internals, or have working knowledge? Idiot/confidence tests: * Get the largest of three numbers * Swap the values of two variable Real tests: * If they're clientside: Have them traverse an XML document, finding elements or attributes. * If they're going to write libraries: Write a class that allows you to increment a variable that isn't visible to consumers of the class. * Ask them how they would profile the performance of their code * If your candidate is doing well, ask them what the 'delete' keyword does. * If you're looking to be a bit tricky to see how they handle not knowing something, ask them what the 'super' keyword does (you may need to demonstrate that it's a reserved word).
did you mess up your link for the post?
TFWIW, but all the buzz is Angular. I have done Backbone for years and am switching to Angular because I feel like that's the writing on the wall. Everyone in my network is going with Angular and it feels very much like Backbone is for old people with lower-back pain.
I came up with something similar to that. Mine applies states via media queries for each specific zone because I prefer fluid websites. I think i'll steal his z-index approach, though. I normally use "visibility" but "z-index" offers a greater range. Thx.
Angular has a learning curve. Once you've gotten to the downward slope of that curve you wonder how you developed frontend applications prior. I have nothing to contribute to the backbone side of things. I went strait for angular and it's paid off for me.
Angular is easy to get into and easy to get into bad habits with, so try and do a little digging on best practices so your ng-repeats(or other template logic) doesnt end up looking like.... &lt;div ng-repeat="item in (filteredItems = items | filter: (accountFilter | parseUnicode)) | orderBy:tableOptions.order:tableOptions.reverse | startFrom: (currentPage-1) * pageSize | limitTo: pageSize track by item.key"&gt;&lt;/div&gt;
Best practices are opinionated, so they will change based on your workplace. This would have been nice to have a single standard but there is no one to enforce it, so it fell to the users to do it themselves.
Come on over to /r/angularjs and join the fun. There's a link in the sidebar with tutorials if you're looking for a place to get started. 
Consider [Ember.js](http://emberjs.com/) as well. :)
I can still access it at https://gist.github.com/antivanov/7a5e32166f9287a644f4
http://bower.io/docs/config/
Should be of some help: http://stackoverflow.com/a/14080568
Speaking of the Date object, I see a lot of people do things like this to calculate elapsed milliseconds: var start = new Date() or var start = new Date().valueOf() Why not just use Date.now()? Why create a new Date object if all you need is millisecond values to perform a difference on?
The time I have to dedicate to this is a real consideration. If I'm spending a month struggling with documentation before I have anything production ready that is a real issue. I have a feeling with backbone I could have something out in a week, my gut is telling me it will be a longer timeline for Angular.
It took me about 3 weeks to know what was going on. First couple of weeks was me getting things working, but not at a great pace.
Are you talking about the jsperf calculation of time elapsed on the tests? I'm not quite sure what you mean?
The FIG audience isn't typical users, it's framework authors. You can do whatever you what in your own code, and FIG enables you to more easily swap out components from frameworks and have them "just work" together. In JS, it might allow you to very easily use `Backbone.Router` _instead of_ Angular's router, or you could use Ember's databinding in Meteor, etc. You can do some of these types of things today, but the interfaces/API are typically so different that it can be a major pain, or downright infeasible. A FIG would help to create unified interfaces that would ease those problems.
Thank you ! It is indeed.
It depends on the person. With instruction you can learn the basics of Angular in a day. The concepts themselves are really easy if you're already familiar with mvvc and JavaScript's prototypical inheritance. 
Ember is pretty good. Personally I prefer Angular because the coding style is more to my taste, but to each their own. I'll say the main thing about Ember that is better than Angular (in my opinion) is their routing, but then again you can get that same routing in Angular using Angular-ui. 
Ah then my point is largely moot. In the instance where something like this was around, I wonder what kind of startup overhead there is and how easily you could take frameworks apart and compartmentalize them.
Neither am I.
When you start a project, you should hop into that folder and run bower init Go through the steps of naming your project etc... The next step is to install your dependencies. You can do this by running: bower install jquery --save This will install jquery and save it in a folder called /bower_components/jquery, relative to your current folder. You can then start working in your project folder as normal, and referencing bower with (public)/bower_components/item 
Oh, thanks!
Google is paying people to create buzz around angular. Look at actual usage numbers. Backbone is used waaaaaaay more, and it is not simply because Angular is new. 
That really has nothing to do with it, those standards govern how the language is implemented in the browser runtime, but not how frameworks are implemented and exposed to users (which the FIG covers)... see [my comment below](http://www.reddit.com/r/javascript/comments/2dn01w/why_doesnt_javascript_have_something_similar_to/cjr4l2z) for details.
I think there's some challenges, mostly since current frameworks are almost fully "all or nothing", and many of the features are part &amp; parcel to the project -- for instance, Angular's templating is highly coupled with its data-binding (which is highly coupled with its overall view management, as well as controllers and directives), and being able to separate those out would likely be extremely hard, and could easily result in implementations that are too inefficient to be practical. Also, PHP frameworks have several years of maturity over JS frameworks, and it's to the point now where feature parity is really high across the board -- most PHP frameworks offer roughly the same featureset (just implemented differently), with a few differentiating features here and there. Whereas in JS frameworks there are fewer common themes, and the implementations are often so wildly different that it'd be nearly impossible to reconcile them in a meaningful way. I shudder to think about creating some standard interface for DOM manipulation, which would be able to cover Angular, Ember, and React, because they're just so different and their usages bleed into other areas of the framework. I'd like to see something like this attempted, though it might take several more years for the frameworks to stabilize and mature before any meaningful interop could be attained.
What exactly would be the reason for them doing that? It's a completely free and open source framework
That article is for **Java**, and this sub is for **JavaScript**.
The closest thing we have to that are Douglas Crockfords opinions and his tool JSLint
It may vary per implementation, but for the most part, yes. Angular only provides you the basic, high-level directives a normal web application would need. The value in custom-directives is being able to create a higher-level abstraction that is specific to your domain.
I've started doing that. I just show them some of our features and see if they can read the code. 
I use both. I would easily recommend Angular over Backbone. I feel like Backbone applications (at least the one I work on) rely too much on jQuery/underscore, and you have to do a lot of things that Angular does for you (like two-way bindings). Also, everything is so nested in Backbone that if you work on a large application (like I do) everything will be so abstract that it will be difficult to maintain. Look into the MEAN stack.
Angular is pretty great. Coming from a heavy jQuery side of things, it has really changed the way I think about building applications. I am enjoying it, but I know I still have a lot to learn.
It's not difficult: 1. Get a bunch of images that "point" to various regions. 2. Get a data structure (2d array?) that maps those images to points. 3. Get cursor position and fetch the image.
Have a look at this video course. Its only a few hours of your time and its a pretty good start to angularjs and should be enough to give you an idea on if you like angular: https://www.codeschool.com/courses/shaping-up-with-angular-js (its free).
&gt; Look into the MEAN stack. Mongo and Node? lol fuck no, I build enterprise applications :)
Javascript is an object-oriented whether you like it or not. Strange not to benefit from the opportunities that the language provides. You use the objects all the time. Perhaps not even know it.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Loss leader**](https://en.wikipedia.org/wiki/Loss%20leader): [](#sfw) --- &gt; &gt;A __loss leader__ (also __leader__) is a [pricing strategy](https://en.wikipedia.org/wiki/Pricing_strategies) where a product is sold at a price below its market cost to stimulate other sales of more profitable goods or services. With this [sales promotion](https://en.wikipedia.org/wiki/Sales_promotion)—[marketing](https://en.wikipedia.org/wiki/Marketing) strategy, a "leader" is used as a related term and can mean any popular article, i.e., one sold at a normal price. &gt; --- ^Interesting: [^Warner/Reprise ^Loss ^Leaders](https://en.wikipedia.org/wiki/Warner/Reprise_Loss_Leaders) ^| [^List ^of ^Major ^League ^Baseball ^leaders ^in ^career ^losses](https://en.wikipedia.org/wiki/List_of_Major_League_Baseball_leaders_in_career_losses) ^| [^Freebie ^marketing](https://en.wikipedia.org/wiki/Freebie_marketing) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cjrd3gy) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cjrd3gy)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I don't know. All i remember from I/O this year was Polymer, Polymer, Polymer.
Let your JavaScript maintain objects that can be rendered without much processing. So if you need to sort and to filter a large list of objects before rendering, do it in JavaScript and put the resulting list in the scope. This will also speed up the application because the JavaScript can watch the fields that affects the resulting list and only rebuild it when necessary. I suspect that the expression above triggers a lot of unnecessary processing in every digest loop, and could easily be slow. 
... and then React React React. These forums are getting to be an echo chamber.
My workplace requires all questions to be identified ahead of time, with sort of expected answers. Your way is better.
I don't have thoughts, because I'm on mobile with only a few minutes, buuuut, I have a question, hope that's cool. Are you the dev (or one of the devs)? I'm wondering how fun/frustrating it is rolling your own framework like this. Were there so big issue you didn't foresee? Last, how much time did you put into it?
Steve Regester here (@egeste on github, twitter) Rolling out a framework/rallying support/fostering adoption, turns out, is really difficult. I've just been trying to get the work out as much as I can to as many places as I can (hence this post). Those issues aside, creating a framework is actually incredibly rewarding. When I have an opportunity to solve a common problem in an abstract way that everyone can benefit from, I'm immediately excited to release to the world at large. In development we're constantly faced with similar problems, and being able to share simple solution feels great. Looking back into my git logs, the first commit on Oraculum was a little over a year ago. The project grew organically as our needs grew/changed, so it didn't really consume a lot of personal time - it grew out of our needs here at Lookout to build the App Intel Console product in our line of platform products. Answered in a hurry, hope I answered your questions adequately. * Edit: Q: "Were there so big issue you didn't foresee?" A: Not yet, but I truly hope that the open source community cares to come contribute criticism and ideas - or even better - insights and knowledge around where it's weak and where it could be better. Better software for you, better software for me, we all win. * Edit: Used my real name
Kidnap some people and force them in a room. Use WebSockets to transfer mouse movements in real-time. Force the people to follow the mouse movements they get, if they ever want to get free. 
Good call -- you can easily fall prey to The Curse of Knowledge when you write a question like this. I've had interviews where it was clear they were struggling to abstract a problem so much that the question itself was almost total gibberish. The whole interview would've been much better for both of us if we just sat down and talked about what we're interested in.
Then you might want to switch to node: https://blog.appfog.com/node-js-is-taking-over-the-enterprise-whether-you-like-it-or-not/ Not that I like node- I could rant for too long- but there's plenty of support and capacity for enterprise applications. Unless, of course, you think paypal, netflix, Dow Jones, Yahoo!, eBay, and many others aren't enterprise. Or, maybe you were sarcastic...
true, but this implementation does use canvas. http://www.pointerpointer.com/js/VoronoiGrid.js
I think the reason people think it's cool is because it *is* slow. It gives you the impression some heavy calculating/searching is going on behind the scenes. I'm sure it's just a timeout + time it takes to load the .jpg for the grid position that the cursor in.
Thank you for your reply. I did what you say, and thanks to the link of skitch920, I have now all the dependencies in the app/js folder. 
But I still have all the deps in the same folder as the app when I try to install my app :/
If you have a strong server side MVC do you really need a full MV* frontend framework? What if you switched your backend view renderer over to a javascript template engine like handlebars exposed the necessary models through endpoints, and just re-rendered the exact same template server side when you need to?
Because IE8? Also, +new Date();
"I inspected some elements and found a sweet looking graph that maps position to JPEG. Not sure how it works, though." Thanks, Paul.
This. 2 seconds to be exact, through two timeouts - relevant code at line 102 of http://www.pointerpointer.com/js/Flasher.js Dig through the sources tab of developer tools on the site, most of the custom code looks to be unobfuscated.
I used Backbone for a while on several projects. Most recently, I've joined a team whose project is entirely written in Angular. &gt; Backbone requires jQuery and Underscore. Those two things already do a lot of heavy lifting To me, it's because of this that Backbone makes a nice wrapper for jQuery code, if nothing else. That is, if you have a bunch of existing jQuery that you rather not wholesale re-write, or you're dead-set on using jQuery, Backbone gives you a nice structure to wrap up the different concerns (models, views, routes...) and a clear way to clean up and refactor that code. Backbone basically just gives you a REST wrapper, a conceptual model for building an application, and not much else. Having used both, I can tell you that Angular has a lot more "isms" - meaning there is an "Angular way" to doing things that don't really translate outside of Angular. The flip-side is, once you subscribe to the Angularisms, it's not a bad system to build with. With Angular, you'll probably end up re-writing and scrapping most of your existing jQuery code, partly because you'll need to subscribe to the Angular way, and partly because Angular will give you a lot of what you need out of the box, so you won't have to write it yourself. It ultimately depends what you want out of using something more than raw jQuery.
Easy. Javascript captures cursor location. Teams of volunteers are on standby in the server room, although backdrops are set up to make it look like various scenarios. They see a large TV with flying spot indicating where your cursor is. It takes them about two seconds to get the message and move into position. A picture is then taken and returned to your browser.
Maybe even center the picture's point location with the actual point location to make it look more precise
Cool. How many enterprise level applications have you built that are running in production in MEAN stack? None? Then fuck off with your stupid hipster shit. 
In regards to FIG's goal of creating interoperable libraries, the JS community has been fairly good about adopting consistent patterns and api contracts already, at least on the NodeJS side of things. The middleware pattern, promises, node streams, event emitters, commonjs and AMD modules; these are all standards that evolved within the community. The former Express maintainers are also in the process of [creating an organization](https://github.com/jshttp) to manage a core set of libraries that all frameworks can rely upon for common tasks related to HTTP. They'll be migrating libraries from the expressjs organization and other personal accounts as new versions come out. Hapi has already adopted at least one of these packages and will likely adopt others in the future. Now lets consider the PSRs individually: - PSR-0 defined a standard pattern for implementing the autoloading of PHP classes, and has since been deprecated for PSR-4. JS does not have an equivalent to PHP's autoloader, so this wouldn't be relevant, but the CommonJS and AMD standards are pretty much universally accepted. - PSR-1 defined a loose set of naming conventions and practices to avoid causing problems for other libraries. Again, JS doesn't suffer so much for the need of this. The perils of global variables and altering the base prototypes are pretty well known, and then there's http://www.jstherightway.org - PSR-2 was a full on code style guide requirement for all of members of the FIG. Resistance to PSR-2 has been very high and, despite the authors stressing that it's only meant for members of the FIG, a lot of developers are vocally opposed to it. JS has even more fluctuation of style than PHP has; JS developers can't even agree on the use of semi-colons, much less the whitespace or brace format. There's even a war over callbacks vs promises. No single body could ever come to an agreement that the entire community would accept. - PSR-3 defined a common interface for logging classes. Front-end JS has no need for this. Node JS could probably benefit from it, but a lot of libraries already use TJ Holowachuk's `debug` module, and the rest just send to `console.log` and `console.error`, which then gets piped to server logs in production. Additionally, JS doesn't have interfaces or abstract classes, so this isn't as relevant. - PSR-4 was an update to autoloading practices, clarifying ambiguities in PSR-0 and reacting to Composer. - PSR-5 defines the PHPDoc specification. JS could benefit from this a lot, the different documentation generators out there all have their own subtle differences, and frankly they all kinda suck. - PSR-6 defines a common interface for caching. Again, no interfaces in JS, but it could be nice if CommonJS defined a contract for caching libraries. - PSR-7 defines a common interface for request and response objects. Node has already defined a lot of this for server side JS in the built in HTTP module, and on the front-end its defined by the W3C, so this doesn't apply. So we've got a bunch of stuff that doesn't relate to JS at all, a few things that no one would ever agree on anyway, and a few things that already have standards.
this is cool.
complete waste of an hour and a half.
Take a look at ReactJS from facebook as well... it's a similar-to-shadow-dom approach that takes some getting used to for classical "html separate from code" people, of which I was one... but the beauty of putting an API on a component and composing components easily is quite attractive.
Great idea!
Best idea so far. Low cost, speed to develop. I approve it. 
Yea the more interesting work would be the image processing to train a computer to recognize a pointed hand.
So, a Voronoi Diagram is basically a way to define regions based on a set of points, in this case the json list. Each colored segment is an area that is closer to one particular point than any other. This prevents from having to calculate the distance to each point and select the minimum. Instead you precalculate the regions and whichever one your cursor is in defines which photo is shown.
Don't ask about javascript or CS trivia. Ask them what they've built. Ask them how they built it. Don't let the candidate's own ease or awkwardness with talking about their work be the main differentiation among candidates. You should attempt to get each candidate to show themselves in the most positive light, but you shouldn't expect that it comes naturally to everyone. If they have open source or a portfolio you can look at, take the time to read through it. If not, ask for samples of code they can share privately. Let the candidate tell you about how they built those programs.
It's worked great for PHP, there's always been a lot of PHP frameworks, but never really a consensus on a 'best' framework. So, a common practice was take the framework that was the closest to what you wanted, and make it what you wanted by bringing in code from other frameworks (including your own custom framework). This was time-consuming and risky, both initially and during upgrade migrations, because either you'd have to alter their code or write a custom abstraction layer to handle it. Now, it's trivial to mix &amp; match framework components, even easier than it was before if you also consider `composer` (PHP's `npm`); you can easily scaffold a full application from various sources in a matter of minutes. A nice benefit is that framework tools (static analysis, testing, deployment, etc.) have improved as well, since they can focus on a single implementation as opposed to many slightly-different ones.
Couldn't you just draw a bunch of regions and link them to a particular region. Of course that is just the conceptual level but writing code wouldn't be that hard.
I would use an [image map](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/map), because I'm hard like that.
If you want to start on about callbacks, that is the general way of programming in JavaScript. Except for jQuery, most Web frameworks are relatively async with callbacks. Promises/A+ have been on both the Web and Node for a while. Also, window.setTimeout() and window.setInterval() are very often used on the Web for the same reason why process.nextTick() and setTimeout() are often used in Node. It scales, and it enables concurrency with less processing overhead (they aren't OS-level threads). As a side note, it surprises me a little that the Web Worker idea hit the browser quicker than Node.
To a large extent, but not completely. It also features quite a bit of Python, since PyGTK is one of the main GTK interfaces. You are correct in JavaScript being their main language. (Their implementation is based on the SpiderMonkey VM.)
Very well put, but with a few nits: 1. Inheritance is deeper and more native in ES6. When you copy the prototype in ES5, you're effectively inheriting from an instance, not a constructor. In ES6, it's handled a little more like Java, where you can't define instance properties (`this.foo`) outside of the constructor, you have to call super() before any other statement if applicable (b/c of the underlying machinery), and so on. 2. In the shimable stuff, WeakMaps are probably almost as hard to implement as the syntactical changes because of one reason: the GC itself isn't easy to implement. 3. For-of loops are easy. You initially parse them like for-in loops, and you evaluate them like this (with the length in a variable if you're smart): for (let i = 0; i &lt; array.length; i++) { // do stuff... } 4. On your last point, I have a lengthy counterpoint. It's actually less backwards compatible for the Web, simply because people had to make their own module system using async imports and runtime-added script tags to implement it for the Web. It was more or less hacked together, and this has no native equivalent in the browser. Node has a native module system that itself is a implementation of the CommonJS 1.0 Module API. The native framework evaluates it at the instant the method is encountered, loaded synchronously. The `import` statement is equivalent, and the only runtime differences are that the statement itself isn't an expression and that the dependencies are more static. Dynamic loading is done through the `Module.Loader()` builtin API (which could viably provide an ES6 polyfill to the `require()` function). The `export` statement is almost identical to module.exports, with the only difference being its more static nature. Here's some examples of its equivalence. module.exports.foo = function () {}; export let foo = () =&gt; {}; function Foo() {} Foo.prototype.bar = function () {}; module.exports.Foo = Foo; export class Foo { constructor() {} bar() {} } module.exports = function (greeting) { console.log('He said: ' + greeting) }; export default greeting =&gt; console.log(`He said: ${greeting}`); var _ = require('underscore'); import _ from 'underscore'; // if it is an ES6 module define(['angular'], function (ng) { var Controller = ng.Controller; }); import {Controller} from 'angular'; These should serve a pretty good idea of the two's equivalence. Also, an example of how it isn't complete sugar: var that = this; $('div.foo').each(function () { console.log(this === that); // lots of falses }); $('div.foo').each(() =&gt; console.log(this === that)); // lots of trues In the latter loop, the `this` isn't bound to a new scope. It is bound to the parent scope. This won't fix it, either: $('div.foo').each(() =&gt; { console.log(this === that) }); // still lots of trues In case you're interested, search for "lexical scope ES6". It may get you started in the right direction about this. As a side note, I know that the last example won't happen because of how the Angular devs are redoing the entire organization of the library for 2.0 in support of ES6. The latter example would more likely be written as the following in Angular 2.0/ES6: import {Controller} from 'Controllers';
Cool. Thanks for sharing. 
Great example, twit is as really good resource. 
Check out durandal. It's easier to learn than angular. 
Thanks, twit is pretty cool. I'm going to look into stream events next. 
Glad you liked it!
Not really. Still references bower paths in HTML directly, the use of browserify for the ng dependencies is also pretty pointless (Angular is just not a good NPM citizen). It's an okay introduction to using gulp, bower, browserify and angular, but not very representative of real-world usage of the four. EDIT: To be clear: there is no good way to use AngularJS with browserify. There's really no point in using the npm version of angular if you're just going to use `window.angular` (or `global.angular`) anyway. Hopefully Angular 2 will fix this, but until then angular is in the same boat as jQuery.
The thing that throws me through a loop is how he/she/they mapped the Voronoi region to the photos. It seems like there's a sort of sweet sport where it would be equally difficult to manually map the photos or to rig up some machine learning algorithms. The difficulty (in my mind) is not just learning whether a picture has somebody pointing, but to calculate an x,y pair of where they're pointing.
Direct link: http://www.addyosmani.com/resources/essentialjsdesignpatterns/book/
Ah Mechanical Turk would make sense.
Not a design pattern, but the following helped me understand JS a little bit more: http://www.objectplayground.com/ (visualization of prototypal inheritance) https://github.com/getify/You-Dont-Know-JS (you may also buy the book(s)) --- If you use CommonJS for JS code in node.js, or organize your code for client-side such as browser (via browserify or webpack), you may find the following useful: http://bites.goodeggs.com/posts/export-this/
Oh this is great. I'll for sure he picking up the books. Thanks!
In my opinion, learning design patterns should be completely separate from learning a language (theoretically most good design patterns should be language agnostic, but there are edge cases where certain things are much more difficult to accomplish in a given language). That being said, Javascript has some properties that make it more difficult to implement some of the patterns developed in other languages, as well as some that are simpler or more applicable because of its design. Have you checked out this book yet? http://addyosmani.com/resources/essentialjsdesignpatterns/book/ Also the obligatory plug for /u/homoiconic https://leanpub.com/javascript-allonge/read (please consider buying a printed version in both cases!) that one is less about design patterns (but I get the feeling you don't mean that in the traditional 'gang of four' sense) but if you work through it (recommend doing so with code pen, repl, or even use dev tools/scratchpad open and playing around __a lot__) you will definitely start grasping the language. 
Thanks a ton. I guess my root question is 'how can I solidify understanding?' And I figured playing with design patterns would help. I've got some book money, I'll pick them up
Use this, the main link tries to make you download "Java"
http://www.html5rocks.com/en/tutorials/device/orientation/ You want to detect changes in the compass heading. 
I agree with you, there is absolutely a recruiting problem. There are a lot of people with impressive resumes that can talk their way though the phone interview, and then bomb fizzbuzz. I will stop asking it when people stop failing it. I don't care if people solve it, or they just had it memorized. It should only take 5 minutes of the interview. Once they have a fizzbuzz function, then they write tests, refactor, and on so on. It's not like we are going to hire someone just because they passed fizzbuzz. I just don't want to waste a day interviewing someone who can't pass it.
Removed as blogspam. OP, in the future, please post the direct link.
Note they are free to read online at the links I posted. I just think they are pretty valuable and worth supporting too (for folks who agree). 
I've used stream events recently. Work really well. Thanks for your post!
I can't stand reading anything other than docs online. I look at the screen enough, so whenever there is a print version available I pick it up.
That channel is packed full of useful stuff. Looking forward this segment of 2D game dev.
As far as I can tell, there are no changes in the compass heading when I slide the magnet. Like I said, getting the orientation is not a problem. I'm talking about [the sliding magnet on the side.](http://spectrum.ieee.org/img/GoogleVRblogphone-1403898781380.jpg)
First of all I've not touched anything of angular yet, so take that into account if someone who has more testing-angular experience tells you another thing maybe he is right and you should do what he says. Anyway, I do TDD and I have always used mocha (for runnning the tests), http://visionmedia.github.io/mocha/ sinon (for mocking and stubbing) http://sinonjs.org/ and chai (for asserting). http://chaijs.com/ I've been using them in node.js and frontend. They solve all my testing situations in node. Whoever, I have found myself some problems in frontend when using jQuery. Sometimes I have to fake it with global.$ = function() {}; which is pretty ugly. All my classes are the prototyped type of class and in the frontend I do if(typeof exports !== "undefined") { exports = classInstance; } in all of them to be exported when running the mocha tests. Sorry for my english, is not my local language. I hope it helps.
My (and presumably lichorat's) assumption was that the magnet slide works because it induces a change in the detected compass heading due to the proximity of the sensor to a moving magnet. The magnet slide obviously doesn't add any new hardware to the phone, so the magnet must be changing the input of an existing sensor on the phone. Maybe the accelerometer is sensitive to magnetic fields? Just make a test page that has the output of as many Android hardware APIs you can find, and see what changes when you move the magnet.
Have you taken a look at the chrome experiment cardboard sample code? http://vr.chromeexperiments.com/example.html
I found learning the basics of angular and backbone about the same, but with backbone the result seemed to be a far messier app. If you come from a background of using an mvc framework on the server side, especially one that uses dependency injection, then you'll work angular out fast. With backbone you might be learning a dieing technology.
I'm on my phone so I can't find the post, but I had a conversation on the G+ Community with Boris Smus about this. You'd probably have to write a native daemon to capture the events and a web socket library to shuttle them into JavaScript. There's currently no magnetometer API in JavaScript. But, with this technique, you could prototype one and propose it for standardization. 😀
Would like to find a solution to this too. All of the examples that have some 'button' functionality do it by having the user look down, or staying in one position for a while or something along those lines. When I pull the magnet it does cause a sudden rotation, so I was thinking maybe a very sudden change in rotation could be detected. This is on an old Samsung S4 I have for testing. Does it do the same on the Nexus?
I have _never_ seen a good explanation for the necessity of CORS. Every other language is free to curl resources. 
That doesn't look like it uses the activation event at all. There's one click to full screen the viewport, but that's a MouseEvent.
In case you missed them, there's been a couple posts recently regarding testing: * [Getting up to speed on unit testing &amp; e2e - please recommend good resource](http://www.reddit.com/r/javascript/comments/2cyp63/getting_up_to_speed_on_unit_testing_e2e_please/) * [javascript testing: where to begin?](http://www.reddit.com/r/javascript/comments/2dcccm/javascript_testing_where_to_begin/) And this SO answer does a really good job as well: [JavaScript unit test tools for TDD](http://stackoverflow.com/a/680713/84473) ---- And since you're using Angular, you probably want to start with [Karma](http://karma-runner.github.io/) (formerly known as _Testacular_): &gt; On the AngularJS team, we rely on testing and we always seek better tools to make our life easier. That's why we created Karma - a test runner that fits all our needs. It's a "test runner", which means that it's a framework for running tests, and it includes many of the most popular components used in other runners like chai, sinon, mocha, etc.
From my very brief play with the Cardboard app, without the actual cardboard frame - I'm sure I was able to trigger the "click" of pushing the magnet down, by swiping down on the actual screen. So there may be sort of touch event that you can listen for instead. (Or possibly not) 
I have found that Firefox works for local file:// site previews where Chrome will not. So if I send out a sample AngularJS demo directory with external template directives (fetched with XHR), it will only work with IE or Firefox but not Chrome. Ironic.
in the FAQ page they mention that if your phone doesn't support the magnet sensing (in this case your programming environment) that you can use copper tape which comes into contact with the screen as a way to replicate the functionality. "Not all phones will be able to detect magnet pulls. You can use Cardboard without the magnet by sticking copper tape along the side of the viewer and having it come into contact with the phone screen. When you tap twice on the copper tape with your finger, the phone will react as if it had detected a magnet pull."
There's no need for anything like voronoi meshes or whatever; it's a simple iteration over a list of known images with targets, then picking the best match and letting the user blame the slight error on that it must have caught the mouse earlier than when they stopped it. There's also no need for websockets. Just set a rAF or a timer, then watch the mouse's movement. If it's further than you expect for no movement, and if a certain minimum time since the last one hasn't been past, screw it, you're good. Change the target of an &lt;img&gt;. Canvas? Why bother? This is being way overcomplicated. This is a simple client side thing. 1. Watch mouse. 1. If mouse moves too much, update image. 1. On image update, look at known image list for best match. Use it. https://gist.github.com/StoneCypher/856f36aa3be2b25c2a25 The more images you put in there, the better apparent job it will do. I would think enough images to chop the screen being used into a 15x15 grid is probably good enough, so on the order of 225 images if you get some good samples (more like 300 with real world data, probably.) I haven't tried it; it's probably buggy. But it's honestly pretty straightforward. Usage, after including the script: var PPC = new PointerPointerClone();
This is a decent workaround. I haven't been able to get this to work with aluminum tape, but maybe copper will behave differently.
I'm on a Nexus 4 and it does not.
I totally disagree. Javascript being a dynamic language allows you to easily compose functionality onto objects without ever accessing the prototype or newing up any new objects. I find the use of inheritance to extend features to be an anti pattern in a lot of cases with js. When you can decorate your object with everything it needs - why pretend it's necessary to create subclasses? 
EXACTLY!!! Extension through composition greatly exceeds the utility of extension by inheritance. JS does not really need inheritance to create structures of any kind. You also avoid the dependency hell of packing functionality into superclass subclass chains. 
Ask about the use of Promises Ask about how to create a Y combinator Ask to create a factorial method - if the recurse ask why they chose that instead of a loop. Ask to create an object with a private variable with public accessor. Ask about hoisting Ask about "this" Ask about libraries they've used
&gt; Ask about how to create a Y combinator so this is a CS thing? Not just a hackathon funding site?
Good to know that. I suspect the magnetometer in the S4 is not behaving as it should. I also get sudden jumps in the values coming out, even when moving slowly and smoothly. It affects the demos as well as my prototype. Really impressed with cardboard though in general. Amazing how immersive it feels with such a simple tech setup.
doesn't load for me.
I would accept - I can't make one but I can explain the idea. Or just jumping into an explanation of functional ideas would be good. These questions are not meant as a filter - fail does not exclude a candidate - but knowing something about monads, the idea of a combinator, currying, etc - helps to show that the candidate is not just a jquery scripter. Closures and manipulation of scope is so fundamental to js that questions exploring a candidates knowledge of these features is necessary. I also ask really simple things like reverse a string without libraries, create a multiply function, and compose it into a exponential function. These basic things should be doable by anyone. 
Google JSON pretty print
The internet is full of smart assets. Google pretty print json - it's been done a million times. 
I would GTFO as soon as possible. Fighting with an architect that does not understand the technology is doomed. I left a company over something similar. 
checkout DaftMonk's generator-angular-fullstack. https://github.com/DaftMonk/generator-angular-fullstack I use it on a project. It is a good starting point with a basic app stubbed out for you. Also checkout the phonecat sample app for Angular. Durandal looks promising. But Angular (when done right) can really simplify things.
I know what you mean. There is just something about having the physical book with you that technology has not been able to replace for me. 
Maybe it's vimeo, try this link https://www.behance.net/gallery/14700923/Lost-days
TFWIW?
start chrome with the option: --disable-web-security
So, lemme get this straight. * You click on an 'li' * your script runs, removes the current class from all 'li' tags, then adds it to the one you click * then a new page loads, but it's still the same active li as before If my list is accurate to what you're experiencing, the answer is right there in the 3rd item. Your javascript is probably working just fine, but the issue is that you're leaving that page and going to a new page. The state of the classes is going to refresh with each page reload, it's not going to carry a state created by your script on a previous page. You want to do this with server-side code. You'll need to maintain active states with PHP, and I'm pretty sure WordPress has some functions available already to do this easily. 
A crappy attempt at "take it for what it's worth".
You are correct, they have prebuilt in classes such as current_page, current-menu-item, current_page_ancestor, etc. No need to attempt to do this in JS that wouldn't have persistence across pages.
Did you get that html from the raw html, or is that from an actual browser with javascript executed? I believe that is one way of [wistia](http://wistia.com/doc/embedding) to embed videos in a site. An example from that page is &lt;div id="wistia_479268413a" class="wistia_embed" style="width:960px;height:540px;"&gt; Could you elaborate on what you mean by "link to another website"? Do you want to embed the video in another web page, or do you want to be able to send a direct link to the video?
Thank you for the reply. I'd like to be able to embed but also send. It is from the webpage where I right clicked and clicked view source.
Given that the url for embedding an iframe is something like http://fast.wistia.net/embed/iframe/479268413a You probably can send the video by replacing the last part of the url with the id you removed. The &lt;div&gt; method used above is using their [Javascript Player API](http://wistia.com/doc/player-api) to show the video. I suggest you use the simpler method of embedding an iframe, which would look something like this &lt;iframe src="//fast.wistia.net/embed/iframe/479268413a" width="960" height="540"&gt;&lt;/iframe&gt; into your HTML.
There are a few ways to embed a video from wistia, two of which are to use a div with the javascript api or to use a iframe. Not too sure why the video is not found since from the examples, the id used in the div and the iframe are the same.
Checkout the json viewer plugin for chrome. 
Speaking of regexps, here is a little exercise which illustrates a number of cases people rarely think about: predict the result of the following /^(a)?b\1$/.test("b") /^((a*)b)*c\2$/.test("aababcaa") /^((a*)b\2c)*d\2$/.test("abacaabaacda") /^((a*)b\2c)*d\2$/.test("abacaabaacdaa") /^((a*)b|(a*)b)*c\2$/.test("aababcaa") /^((a*)b|(a*)b)*c\3$/.test("aababcaa") /^(\2c|(a*)b)*$/.test("abac") /^((a)*|b\2c)*$/.test("abc") /^((a)*|b\2c)*$/.test("abac") /^(a|b\1c)*$/.test("abac") Many of these will give different results under at least one major regexp engine — GNU egrep, Perl/PCRE (in fact, in obscure cases, Perl and PCRE don't even give the same result), Java, Python, .NET.
&lt;div class='wistia_embed' data-video-height='400' data-video-width='900' id='wistia_y*********'&gt; &lt;/div&gt; Darn yeah I can't find any combination of the url you provided to get this video to work. It is working on the host page though :/
Hey friend. Dave from Wistia here. Without knowing the hashed id of your video, it's tough to say why you'd be seeing that "Video not found" error when loading the fast.wistia.net/embed/iframe/********** URL as u/tra95 described. That's how we'd display the video if you were using an iframe embed code, however I wouldn't recommend using that URL to share your video even if you get that URL working. It's better to share a video by linking directly to its page in your account area. I'd recommend logging into your account and grabbing the URL of your video's page in Wistia, which will be like youraccount.wistia.com/medias/*********. As long as the video is in an unlocked project, you can direct people to that page and they'll be able to access the video. If you have more questions, drop a note to support at wistia.com with a link to the page your video is embedded on and we can help you get things sorted out!
It would help to see the code in context -- provide a link. 
send me a link.
You're describing CSRF attacks that CORS doesn't protect against. CORS doesn't stop `bank.com`'s servers from fulfilling the evil request, it just means browsers are forced to discard the response. CORS is a half-hearted heavy-handed stopgap measure, not a coherent secure policy. 
silencing errors is probably the worst thing you can do. Unless it is an expected error.
&gt; CORS doesn't stop bank.com's servers from fulfilling the evil request Sure it does. Any non-safe request (one that would have a side effect or would cause a permanent state change, such as a POST) requires a preflight request (an OPTIONS request with special headers) before sending the actual POST/PUT/DELETE/whatever. In the bank scenario the preflight would be denied as invalid and the actual POST would never happen. The only kind of requests that don't require preflight are GET and HEAD, which should be completely stateless -- they can't cause a message to be posted, a balance to be modified, etc. The only thing they can do is leak information, and the browser makes the responses unavailable to the attacker if the CORS headers weren't part of the response such that there is no leak. 
Ohhhh!
If you prefer to work with CSV, you can use this [json to csv](https://json-csv.com) converter.
Jasmine is a popular choice for unit testing in the frontend. For Angular Karma is also something you can look into. For Node testing i can reccomend Jasmine-Node.
Well, the other part that's required to make CORS secure is the server-side Access-Control-Allow-Origin header option. In the article's example, the server will send Access-Control-Allow-Origin: * as the author requested. This is fine if you're dealing with a public REST API, but generally you want to limit responses to known domains. I think CORS is wonderful, but the part of the article that makes me cringe is how the author suggests that server owners should wantonly open up their machines to untrusted domains without any justification other than "It doesn’t take much effort to enable cross origin resource sharing on a server." I hope he understands it's also easy for him to give me his credit card information, too, but that's also a bad idea.
Sweet! Another reason to avoid regex like the plague :)
nice work. thanks for sharing
This needs a browser bookmarklet.
Wonderful article. Would love to see more of this type of thing on /r/javascript. 
mocha + chai + sinoid works well for both node and browser. there are a whole bunch of runners for it, like in grunt or phantomjs.
What good does this existing do? Why would you track people which don't wish to be tracked?
I was creating professional sites in 1995 and I would tend to agree. While client side programming is largely the same the ecosystem has improved. The primary advance in client side has been CSS, not JavaScript. JS is the behavior glue for the real visual work of CSS in many cases. The advance in JS has been performance and xmlhttp. The debugging tools are starting to get better. The DOM interface has improved, but these are mostly responses to CSS.
For internal APIs you shouldn't open your machines to untrusted domains, but I'm referring to public non-internal APIs in my article.
*CoffeeScript
He can look this resources, they are free and they are available in Russian https://github.com/vhf/free-programming-books/blob/master/free-programming-books-ru.md#javascript
I'm sorry lots of it was boring, I was trying to be thorough. :) 
I hope I can find the time to write more. It took me nearly all week to write that, when I could find the time.
The biggest mistake the web made in the early days was thin-client. As JavaScript has matured and with AJAX and dynamic HTML we can nearly get the client-server architectures of the 90s which is a far cleaner design and a far richer experience for the user. Another thing client-server architectures do is scale better. With thin clients, every new user is a liability. With thick clients, every new user is also an asset since they bring the computing power of their device. 
Wow I just learned something, I didn't know you could use \n where n is a number inside the actual regular expression. I would have put that in the post, although it's long enough. O_o http://jsfiddle.net/btipling/k51t85aa/
you could, but that is a glorified single image mouse cursor, sorta. This app appears to have 688 images fyi, good enough so that each image covers about a 32/32 pixel area on average. Also the reference point is not the finger tip, it is a little way off in the direction the finger is pointing. It is clever, not computationally intensive image processing (unless you count the author's brain as he searched for and examined 688 images and figured out the best datum for each).
I actually use \1 etc in vim regular expressions where they are useful, I just never thought they'd be available in other places. I don't know why I didn't make that connection.
Subscribed! 
I think that if the author isn't altering the position of the photos on the fly, he's got to be cropping the images he did find to account for each one of those 32/32px areas. It just seems impossible to find that many photos of people pointing at just the right coverage area! In terms of efficiency, it'd be easier to at least crop them (if not move them on the fly). I suppose anything is possible, though! He/she must have been really fricking dedicated to finding and categorizing finger-pointing pics :S
Thanks for the heads up! I worked a lot on `func` and the other combinators and types, and I think now are all idempotent. Regarding the `subtype` name, I was referring to this meaning: &gt; If S is a subtype of T, the subtyping relation is often written S &lt;: T, to mean that any term of type S can be safely used in a context where a term of type T is expected. [1] but maybe you are right and "refinement" would be a better name. Best, Giulio [1]: http://en.wikipedia.org/wiki/Subtyping
I disagree. /g being stateful is a source of confusion for a lot of people and can lead to surprisingly broken code that isn't immediately debuggable
That feature is called a [back reference](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#special-backreference), and I use it all the time in my editor as well, mostly for finding quoted strings, e.g. `/('|")text\1/`, as this will match quotes properly so that you don't have to do 2 searches or get false matches (such as if you used `/('|")text('|")/`).
Wow, it's really non-obvious how this works, what this is or why I should care. The website does a very poor job of explaining it, so I had a look at the source, now I'm even more confused. What is a "hope"? what is a "monster"? what is an "attack"? This is a great example of a library crippling itself with a joke name. If you find yourself creating a class called [BitterStruggle](https://github.com/sloosch/destoroyah/blob/master/src/destoroyah/main.coffee#L49) you've probably taken things too far. 
Absolutely! And it's not the only language with the problem either - I once saw a JavaScript program that could play chess! I didn't understand it at first glance (or second or third), so now I know to avoid JavaScript like the plague :)
Why you should care? Because whether you not me can think of all possibilities that can happen to your functions. Bad arguments like NULL, an empty string, empty array... in combination with good arguments. A quickcheck framework knows these edge cases and tests them. Even further it generates hundreds of test cases for you. The function will by tested with all possible cases - not just the ones we thought about. Why those names? "awake", "rampage", "calm", "angryness", "attack", "hope"... "BitterStruggle" :) Because writing tests should be fun! "A monster is going on a rampage on your functions by attacking it with arguments. You can just sit there and hope that your function withstands these attacks." No this is no joke, it is a fully working simple to use QuickCheck testing library. You may have to play around a bit to understand the concept of QuickChecking after that your welcome to contribute examples, documentation, ideas, concepts, request for changing names... Other frameworks you may want to look at: JSCheck http://www.jscheck.org/ JSVerify https://github.com/phadej/jsverify or the father of all https://hackage.haskell.org/package/QuickCheck
Yeah the problem is that you don't actually explain any of this stuff anywhere. It's not possible for anyone to contribute to your library because it's not clear to anyone other than yourself how it works. Normally this isn't a problem because people can just dive in and see the code, but you've managed to thoroughly obfuscate your intent by using joke names. You can keep your joke names if you do a really, really good job of documenting them. Without that, this library is unusable. Which is a shame because I really like the idea.
Alternate solution: choose a few bandwagons *not* to jump onto. This whole package manager proliferation is like somebody who keeps switching between tabs and spaces every 50 lines of code. Yes there are pros and cons, but none of the pros or cons matter as much as just being consistent.
agree....very basic stuff
http://developer.mozilla.org/ and done.
MDN (Mozilla Developers Network): https://developer.mozilla.org/en-US/docs/Web/ For your specific example (`document.getElementById`), you're going to find a lot in the `document` interface docs: https://developer.mozilla.org/en-US/docs/Web/API/document I frequently use their docs, and installed their search engine in Firefox. Searching works great: https://developer.mozilla.org/en-US/search?q=getElementById
Thorough is way better than a fluff article, good job.
Alright alright, shitty attitude on my part. I shouldn't avoid things I don't understand, it's just too easy nowadays to have all the common regexes I need already written, thus my lack of every trying to grok the details.
Perfect! Thank you very much.
and if you want to know what browsers support what JS methods or APIs go to [caniuse.com](http://caniuse.com/)
Thanks!
I gotta recommend http://devdocs.io . it combines docs from lots of sites (mostly MDN) into a single page app that is easily searchable. I have the tab open all the time on my dev machines.
This is also the first thing I thought of :)
Very cool. This is something I've been meaning to do in javascript for a while. Back in the day, I made a single player Pong clone in Actionscript, where the paddle was controlled in a similar manner. The louder the sound, the further up the y-axis the paddle would go. Listening to people playing it was hilarious. I suppose you could make a Flappy Bird style game the same way, if it hasn't been done already.
Option for the poor: &lt;a href="mailto:someone@example.com?Subject=Hello%20again"&gt; Send Mail&lt;/a&gt;
R-Tree index
he's getting paid, right? secondly, this is not something too small to hire out for, as he cannot do it himself. he is getting paid. thirdly, this is *not* simple. this needs to hook to a backend mailer script, not just plain JS. so this will depend on his server set up. sure, you could send an ajax POST with js, but something on the back end still has to catch it. if by 'constant email', you mean sending the info to a constant contact list, you need to go to them for the info. also not strictly js related. lastly, there is no info here. nothing about what has been tried, nothing about the server set up, no indication that you have put any more effort into this.
If you don't have the expertise to achieve something, you don't have the expertise to estimate the difficulty either. You've under estimated the task, it'll be harder than you appear to think.
The lack of communication is at my fault. He was quite frustrated and isn't the most open person to help. He ended up solving the problem using PHP apparently he was trying to embed the PHP code in the html5 file. All is good now. Thanks for the help
Just because a problem is easy to solve and is relatively routine does not mean it's easy for a non-programmer to do. HTML does not really do anything with forms but allow you to create them. If you want to do anything with the form data, you'll need a programming language like JavaScript or PHP. For this particular problem, you need a programming language that resides on a web server, because you cannot process emails directly on the client side of the browser for security reasons. So the basic solution is this: * Create the page in HTML with the form elements in it * Set the form's action attribute to a program on the server that can read the email. * of course, you'll also need to write the program. We'll use PHP because it's free and available on most any web server. * The PHP program will read the data from the HTML form, then sanitize it looking for possible injection attacks, set up an email string, pass the email to the sendmail function, and trap for any errors or exceptions that may have occurred. There are a couple of other alternatives. Most CMS systems have this sort of functionality built in. Your hosting program may already have an installer for the more common CMS systems (like wordpress or Drupal.) However, setting up and managing a CMS is its own kind of complicated. The easiest solution for a non-technical person is to create a form on Google Docs. You can then set that form to send an email to any address you use. You can then provide a link to the google form on your main site. There's a couple of problems with this approach: * The form will not be formatted like the rest of your site, so it will be obviously a second-party solution. * Google has access to all of the data sent through this mechanism, so this is not an appropriate way to handle any potentially delicate information. This is not an amateur job, and it will be quite challenging for a beginner to accomplish without help. A good developer could do this in under an hour. But it will take a lot more time to learn how to do it yourself. 
it uses emscripten. No wonder they don't build it for you. I mean they could, but everyone who uses emscripten should know what to do.
Why not just use yeoman? This seems like it just adds more to the problem it is trying to solve
I tried installing emscripten, and it seemed to work. However, when I try to "make" this, I get this error: /bin/sh: emconfigure: command not found make: [configure] Error 127 (ignored) cd pdftex-1.40.11/build-pdftex/texk/web2c/web2c &amp;&amp; emmake make /bin/sh: line 0: cd: pdftex-1.40.11/build-pdftex/texk/web2c/web2c: No such file or directory make: [compile_bc] Error 1 (ignored) cp fixwrites web2c pdftex-1.40.11/build-pdftex/texk/web2c/web2c usage: cp [-R [-H | -L | -P]] [-fi | -n] [-apvX] source_file target_file cp [-R [-H | -L | -P]] [-fi | -n] [-apvX] source_file ... target_directory make: *** [compile_bc] Error 64 
This is very easy to use. Thanks for the help.
Oh not everything, just the common stuff that everyone has done 1000 times. For specialized things I limp through it until I get it to work, pretty ugly process. Fortunately I haven't run into anything terribly complicated. Yet. I'll check the links out. It's very likely I don't value regex as much as you do because I've only every done it for trivial things. I don't know any cool shit you can do with it, or handy ways you can use it. I'll peruse the links and maybe I'll give it a solid go. Worse case scenario is I learn regex and I have one less thing to dread.
Yeah, this is probably a bad place to start. The project also uses Git submodules, which can be a headache. Try running `git submodule update` in your cloned repo, or else you'll be missing the `promisejs` dependency.
Is it inspired by [QbQbQb](http://qbqbqb.rezoner.net/play/)?
Absolutely
Yes, the semicolon tells the browser that the statement is finished, so it can process it and then move onto the next one if applicable (at least that's my understanding of it). 
That makes sense. Thanks for your help!
What kind of data are you hashing?
Yeah, performance in Javascript can be very counter-intuitive. Once you know that strings are (mostly) read-only, and extremely cheap to do copy/substring operations on, I think it makes more sense why the slicing version is slightly-faster. It's definitely true that JIT-compiled JS code can be very fast, but the Date constructor is well-understood, fairly simple code, so it's probably optimized all to hell.
In most languages, whitespace characters (space, tab, newline, carriage return, form feed, vertical tab, etc.) are not significant. That means that the fact that you have one statement on one line and another on the next line is completely meaningless -- it's as if they were both on the same line, because the newline is not significant. Hence, a semicolon or some other terminator is required to delineate between the end of one statement and the beginning of the next. Without that, some expressions would be ambiguous, for example: a() + b Is that to be interpreted as `a() + b;` or `a(); +b;`? They are both valid expressions which mean different things, although in this case the difference wouldn't be observable since the result is discarded. But the point is that the grammar is ambiguous without them. Anyway, that's why you have semicolons. However, Javascript has a set of special rules where the language will pretend that you typed a semicolon in certain circumstances if you leave it out. This is called [automatic semicolon insertion](http://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi), and this means that you can occasionally forget to terminate a statement with a semicolon and it will work fine. Some people even use this to write code that's largely absent of semicolons, relying on ASI to do what they expect. However, there's a lot of debate as to whether that's a good idea. Most people would agree that you shouldn't do that, because if you aren't absolutely sure of the ASI rules it's possible to make a mistake and introduce a bug. It's ultimately a matter of personal style, but it seems pretty logical that if you aren't intimately familiar with the ASI rules you have no business leaving off semicolons, so most people should consider them mandatory. 
hmmm...you can try this? :P I've just been fiddling.... requires underscore https://gist.github.com/blakev/f6c1fc1b59fb318c0e84
&gt; if you aren't absolutely sure of the ASI rules it's possible to make a mistake and introduce a bug It's also worth mentioning that not all tools comprehend or respect the rules either. Tools that concatenate files and minify code can cause unexpected behavior if you don't use semicolons, especially if they don't create an AST of your code and rewrite it. For example, you may have seen code where every begins with a semicolon, like so: ;(function() { .... })() That's specifically because concatenating several of these files together will convert the wrapping parens into a function call, passing the function as an argument rather than invoking it.
That goes from dead easy straight to impossible
so it's good practice to leave a semicolon after my functions to prevent any bugs since I'm not familiar with these ASI rules.
It's an interesting idea. But I worry that this part: ```javascript if(_.isArray(data)) { _.each(data, function(e) { hashStr += innerHash(e) + ',' }) ``` ...might get bogged down with the size of the arrays in these objects. Might be worth benchmarking, though.
You could probably optimize it for your data set -- for example, if you KNOW the types of all the data in the arrays, just use a `join` ~ I was trying to be super generic, and it seemed to work "pretty good" for that. use it as a starting place, or don't :) doesn't hurt my feelings \^_^
That is cool!
Fun.
Since we're both on github, this is an example of the object that gets hashed: https://github.com/daemonburrito/js_ecs_engine_1/blob/master/level1.json And, if you're curious, the current implementation with the browserify port of node's crypto: https://github.com/daemonburrito/js_ecs_engine_1/blob/master/tilemap.js (the engine is just up on github for fun and sharing... definitely not ready for production.) So you can see that the issue is me wondering if crypto's md5 is totally overkill for this. Maybe something like your approach might be okay. Hell, maybe just stringifying and comparing would be good enough.
Ahh ok, well imho the crypto library is overkill and will bite you later. Given that JSON right now, the JSON.stringify is probably sufficient; I wasn't sure if you were storing functions/objects in there as well (which mine accounts for). For caching, however, you should consider something like I did to create a hash "key." Something small that represents the whole data, that way you're not just shoving the whole data in the cache.
Thanks for considering touch controls!
(Rose-colored glasses) Hopefully, it presents the series of technologies that privacy advocates have to overcome in order to present true privacy. Otherwise it's pretty damn creepy, I'll grant you that.
I think my only suggestion for the game is to ease up on the transition from easy to hard
had to translate it from coffee script to js... missed some bits
I would say the biggest improvements have come in the last 5 years. All of the tools you mention and more do make a real difference to the experience, and that is the main reason why I say it is the future. JavaScript has a real momentum behind it now. There are more talented JavaScript developers than ever before and it use is becoming ubiquitous. But I also agree that the primary advance has been CSS rather than JavaScript. With the exception of NodeJS we are mostly using JS in the same way as we did 15 years ago. As you say it wouldn't be a good thing if the language changed too much. However unlike server side languages such as C, perl and lisp, we lack alternatives for client side programming if we don't want to use JavaScript. Regarding design patterns yes they should always be considered but in the early days of the web, there was more hacking away without a good understanding of these things. In other words the use of the language has matured.
No worries!
On desktop I could achieve 9000+. The pieces fell a bit slowly at the beginning and combos seemed to be appear later in the game. On mobile (a Samsung Galaxy Tab 4) it was much faster, some parts felt impossible, I scored around 3000-3500. Make the buttons responsive to screen size (on a 10 inch tablet the Help, Pause, Restart buttons are very small.) Don't add new colors, or have a classic mode and another with extended colors. Overall, it's a great game, I would definitely play it more!
Well I don't advocate regex for anything terribly complicated. It quickly becomes inscrutable after a certain point, especially with the limitations of the JS flavor and the fact that JS won't let you comment a regex. I don't think even a true expert would want to read a 200-character uncommented regex. What I mostly use it for is validating/parsing strings that have a bunch of different requirements. For example, an input string (maybe from a query string parameter) that is a list of numbers, let's say comma-separated, each between 2 and 64, and between 1 and 10 long. A JS parser is straightforward but frustratingly long if you want to be safe about it; on the other hand, you can validate it with a very short regex, then be safe in using a naive parse, like `list.split(',').map(Number)`. As for "neat tricks", I'm not sure if it qualifies as a trick, but I love this pattern: 'a=1 b=2 c=3'.replace(/\b([a-z])=([0-9])\b/g, function (m, name, value) { // use `name` and `value` like we're in a forEach // `m` is a convention to name the entire match }); It's true it constructs a useless string as it goes, but, like they say, never make performance assumptions without testing. Especially in JS, where every little thing is slow yet it's built on a blazing backend. In every case I've tested, the above approach is faster than parsing and looping separately, even with the extra output.
See [here](https://github.com/less/less.js/blob/master/lib/less/parser.js#L1598) for an example. There are quite a few occurrences of this construct in the Less codebase.
See [here](https://github.com/less/less.js/blob/master/lib/less/parser.js#L1598) for an example. There are quite a few occurrences of this construct in the Less codebase.
See [here](https://github.com/less/less.js/blob/master/lib/less/parser.js#L1598) for an example. There are quite a few occurrences of this construct in the Less codebase.
You've convinced me that Access-Control-Allow-Headers are a poorly thought makeshift solution. I didn't say CORS wasn't an improvement. Is it irrational to want something better? Right now you're saying that a _good_ solution to the problem is a) evil.com can still send credentials to the server, b) that server will therefore process the request as completely valid even though it is not, which is fine because c) the server doesn't tell the browser it can use the response, so d) the browser discards it. Or... browsers implement an option to send a GET that doesn't send credentials of any kind. Again: **every other sensible environment is free to curl resources.** Look, I'm not arguing that we roll back CORS and start from nothing. I just think the current solution is pretty terrible, and I don't understand why we're putting up with it. The Internet is _built_ on the idea that you can fetch resources from any publicly available address!
No problem - good luck with it!
Oh yeah, that's not addictive at all. I can just play one game of that. What year is it, again?
Christ that is evil :-p
Wow! The moment you hit 15k points, that game quickly lets you know that training day is over.
Check out CoffeeScript or ToffeeScript. You don't put semicolons and some other things in those languages.
Which would have made the `new` pointless since you can't construct a function, so `namespace.ClassName()(...)` gives the same result as `(new namespace.ClassName)(...)`
How have they converted the JS app to a native app on IOS and android? Is it though phone gap or something?
For completeness you might want to consider also supporting * properly URI encoded parameters and values * multiple values for a property (e.g. foo=bar&amp;foo=baz) * ; as a valid alternative to &amp; (e.g. foo=bar;foo=baz) The first of these is pretty important I'd say, while the other two depend on your needs.
non-creepy reason: Let a user begin using your web app, let them save things/etc and use things as normal. Then when they register - can seamlessly move all of their data from the anonymous account to a real/registered account. But really - marketers/advertisers/etc want to track you - no matter how much you don't want to be tracked. They will find a way to do it. 
Too many things don't actually depend on the user's choices, so the game isn't actually enjoyable.
Thirded, 'Hey this is pretty cool, nice and simple! Just put this one here, that on-AAGHHHGHPANICPANIC, ABORT'
Most of the time, no. Semicolons in JS are optional, and the [rules about parsing][1] are quite clear. [1]: http://inimino.org/~inimino/blog/javascript_semicolons
Hi :D
I really enjoyed it, I was laughing out loud, I would get addicted to this game. Job well done !
Wow. well done. Definitely ease on the transition from 'oh this is neat' to 'AAH FUAAACCCKKKK'
I would guess something like [CocoonJS](https://www.ludei.com/cocoonjs/) or [node-webkit](https://github.com/rogerwang/node-webkit)
Can be useful in concatenation/minification of separate scripts.
JSHint, a code linting tool, generally says that function() { }; that semicolon is not necessary; generally speaking, it's correct- assuming, of course that you've investigated and are using some sort of modular approach to writing JS. http://www.jshint.com/install/ will point you in the direction of how to install jshint and use it in various text editors and IDEs; you can adjust many of the rules to suit your coding style. Other options include jscs and eshint, though I'm not sure if the tooling / integration support is as good for those with the various IDEs as with jshint.
Ah all of them `prototype` extensions .. :/ Array.prototype.wtf = alert.bind(window) // i never understood this.. :o I remember seeing code like this: [1, 2, 3, 4].each(function(key, value) { /* heheh */ }); // Can't stop laughing of ppl who fucked up like this :D
Thats one of the reasons why I use sublime text ( not intended as an ad )
It prevents massive flamewars between the altJS and vanillaJS tribes, and protects against the summoning of Crockford.
If think you missed a { after `if(choice2 === "scissors")`. When you fix that, you should try moving `if(choice1 === "paper"){` to the outside of `else if(choice1 === "rock"){ ... }`.
maybe, pdf.js will be valuable?
If all your pages are png files, then you don't need a pdf viewer. You are displaying pictures...and there will be no single framework to do all of that for you. You need to start looking for individual components that you can wire together. * If you want side/side action, look for carousel components. * Touch/swipe actions using Hammer.js * Playing inline-movies: wire that yourself using MediaElement.js * If you want to actually use PDF files, then checkout pdf.js from Mozilla. But a lot of what you want is not possible with a pdf. * For image zoom, just start looking at various canvas libraries. Fabric.js might be helpful. Also, if Android 2.3 is a requirement, stay FAR away from anything SVG, it wont work. 
too late http://nelm.io/images/shop/wear/jsmofo/douglas-big.jpg 
It's really pretty. It get disorienting really fast. With Tetris you really only have one thing to worry about at a time. I'd work on the difficulty curve. 
adler-32 perhaps. https://github.com/SheetJS/js-adler32
This is really well done! Performance is great, on both the desktop and iPad. Too bad Android is still lagging behind b/c I noticed some framedrops after playing for a while. 
&gt;There might be web sites with sensitive data accessible only from PCs within that internal network, but under this plan all that private data is able to be accessed and exfiltrated to a remote server just by viewing an ordinary website on the external internet run by an attacker who knows the URLs of those internal sites. Something like $.curl alongside (not necessarily in place of) $.get wouldn't make this situation inherently insecure. You wouldn't use $.curl to access these resources; you'd want to actually make the effort to protect them. The point is to make it an easy default to expose resources publicly. 
Nice. Thanks for the tip.
It's unbelievable that they never made this kind of function as part of the web standard.
YESSSS! That's it exactly, thanks very much. Such a pain to search for - tried every combination of 'tiny javascript interface dashboard javascript developer' I could think of. 
the hell? why not just assign rock/paper/scissors a number from 0-2, have the computer choose a number randomly and compare it to the input from the user prompt?
&gt; You wouldn't use $.curl to access these resources You may not, but any random webpage I visit might. It's extremely insecure. You keep wondering why browsers work in a certain model and I keep telling you and you keep brushing it off as if it's not a real concern, but it is, which is why browsers have the security model that they do. It's not browser implementers just being obstinate. 
If developers hadn't been "banging their head against the wall because there are legitimate use cases for making cross-origin requests" we wouldn't even have ACAHeaders. I'm not required to be happy with the current model just because you can describe the real concerns behind it. &gt;You may not, but any random webpage I visit might. Maybe I mispoke: those resources shouldn't be available via $.curl. &gt;It's extremely insecure. Ultimately? So is running any code that you've downloaded from the Internet, regardless of whether or not it's in a browser. Security is difficult. That doesn't mean we can't have basic things like publicly available resources being publicly available. 
&gt; those resources shouldn't be available via $.curl. And how are you going to enforce that? You can't. If you're trying to say that there shouldn't be intranet applications with sensitive information that use IP addresses for access control, then you're just going to be laughed out of the building, because that's incredibly common and it's not going to change. 
**This conversation isn't about sensitive information**. It's about the difficulty of accessing obviously public information under CORS. You've concocted some scenario in which my hypothetical $.curl is applied to IP-restricted information, and I never suggested that. If a visitor within an IP-restricted network visits evil.com, evil.com's $.curl to the restricted resource would fail because the resources would not be exposed _to $.curl_. You _elect_ to provide a publicly available resource. The only difference is you don't add a header explicitly allowing a browser to use the resource; it is permissable by virtue of its accessibility. The class of resources hidden in an IP block is **not my problem with CORS**. I don't care about side effects (though I believe until recently GETs to gmail's logout would work regardless of origin): it is **bad design** to waste computational resources processing requests that you are marking as "don't read." All I'm suggesting is replace ACCESS-CONTROL-ALLOW-HEADER: * with _browser functionality_ to send unauthenticated, assumed unsafe requests to public resources that the public server can fill without having to mark its requests as public. 
impossible!!
haha, I got through 2..that is really hard. I think if the easing was off it'd be a little more doable
Although if this is the only reason you're using jQuery, then it's a bit like using a sledgehammer to crack a nut. $("#hover-div"); could just as easily be: document.getElementById("hover-div"); and hoverDiv.on("mouseover", function(){ could just as easily be: hoverDiv.addEventListener("mouseover", function(){ DONE.
Python with the beautiful soup library would be much easier. 
I would deeply reconsider the term 'app' here
API isn't friendly. Maybe you should think of: `convert.fromKilometers(5).toYards()` instead of `convert(5, 'kilometers').toYards()`?
Flappy bird is insanely easy compared to this :)
I'm pretty sure you're the devil.
Way easier than flappy bird. http://imgur.com/yXFFzog
fuck this is hard.
Needs touch support.
If you want to be impressive, try to write the interpreter as a compiler such that the Browser's own JIT compiler can get this running super fast. Especially with the long runs of `+` and `-` commands that are common in BF, you should be able to optimize that. 
The Dead Fish.
The first game I ever wrote was nearly identical to this. I made it on a TI 89 graphing calculator in the back of calc class during my junior year of high school. That's one of the things that really got me into programming! My graphics weren't nearly as spectacular as yours, though. I commend you for using beautiful fish instead of arrows, carrots, smile faces, and lines. Thanks for taking me back to that memory and good luck with your future programming endeavors!
Awesome! Brainfuck is a guilty pleasure. It's my favorite novelty language. I just wish it was named differently, there are certain people I can't discuss it with without them getting all offended.
Oh yeah? http://i.imgur.com/bGv3l9G
 var bgImage = new Image(); bgImage.ready = false; bgImage.onload = setAssetReady; bgImage.src = "images/Background/sky.png"; var playerImage = new Image(); playerImage.ready = false; playerImage.onload = setAssetReady; playerImage.src = "images/SwimmyFish/SwimmyFish.png"; // Plus five more like this Any time you see repetition like this, you should start thinking about making a function. setInterval(main, 1); Use `requestAnimationFrame` instead. Also, performance isn't great. Learn some profiling tools, and figure out how you can make this do less work. I recommend the chrome dev tools, but any modern browser will have something more or less comparable. `drawImage` is really dominating in terms of CPU usage, so I'm guessing you will probably see a lot of benefit here if you either draw your images to an offscreen buffer canvas, or make multiple canvases, one for each layer (http://www.html5rocks.com/en/tutorials/canvas/performance/).
That's not even the slightest bit realistic. You're talking about opt-in safety. All internal web servers that might be serving sensitive documents must be updated to look for this header. Some of those could be ancient machines that nobody even has the source code for. Moreover, access control at the IP or network level is completely different than access control at the HTTP header/application level. It's very easy to set up a network such that a certain segment is only accessible from another segment. It's much, much more difficult to change that into something that looks for HTTP requests, parses them into headers, checks their content against some whitelist, etc. That requires stateful packet inspection which is in a whole different league then simple network segmenting/VLANs. As currently implemented, a server that knows nothing whatsoever about CORS remains secure. That is the *sine qua non* that any proposed change has to have.
Very well! I recommend (as part of learning and as a good dev practice) to put the app's code in github/bitbucket so suggestions for your code and even fork requests can be done easier :) Congrats and keep on practicing! 
Thanks for the tips! I tried to make functions for setting the images to variables but they didn't work out for me; i'll probably make another attempt at it. I'll also take a look at improving performance start with your suggestions :)
This is awesome! So awesome, in fact, that I made a [github repo](https://github.com/swimmyfish/swimmyfish) for it (under the MIT license, if you don't mind), playable [here](http://swimmyfish.github.io/swimmyfish/). Let me know what your github username is, /u/meiskooler, and I'll add you as an admin! This way, Swimmy Fish players can send you a pull request (which you can optionally merge) if they want to try to get some some code changed!
At least when you download desktop software or install a mobile app you know that you're downloading software, and you might pay some attention to where it comes from and the fact that it might be malicious. Clicking on a picture of fluffy kittens on the other hand is not something that people generally associate with downloading and running software, but that's what it is. The browser is supposed to provide a sandbox for that execution, so that merely clicking a link should never be dangerous. That means there are just going to be classes of things that you can't do in a browser that you can do in other languages, like read arbitrary local files or make arbitrary socket connections. 
Wow, of course I don't mind. I had absolutely no idea what github could do and i'm that that you set it up for me! My username is also meiskooler on there.
Although it seems innocent, this might be taken in the wrong way. You really shouldn't post another persons work on github without their *prior* permission. 
Hint: function makeImage(url){ // do some stuff // maybe return something? } var bgImage = makeImage("images/Background/sky.png"); Also, `gameCanvas` isn't doing anything except adding some padding to the top of your real canvas. You've got some bad quotes in there. These aren't allowed there -&gt; ” ”, you can only use these -&gt; ' ' or these " " Also, also, look into object prototypes. Basically, this function Cloud() { this.randomize = function() {/* Do stuff here */}; } is usually better to do like this (although the former can do certain things (having to do with closures and 'private' variables) that the latter cannot): function Cloud() { } Cloud.prototype.randomize = function() {/* Same stuff as above */}; I hope I don't sound too discouraging. There's a lot of room for improvement for sure, but you're off to a good start, so keep it up!
It's fucking impossible. The fish doesn't move fast enough and it changes direction too slowly.
Depends on what browsers you need to support. Older versions of IE use attachEvent instead. So, if that's the case, it's better to let jQuery handle the cross-browser support.
No man you're helping me learn a lot! I always forget about returning. It just never crosses my mind that I can do that so I just sit there trying to figure out the impossible by trying to use variables as parameters and other dumb stuff. Thanks for the hint. Wow, changing the quotes on gameCanvas really made a difference. I guess I still have a lot to learn about css and that resizing tutorial. I did see object prototypes when I was exploring javascript, but I never really understood the use. Another topic to add to my list to understand!
This guy's so good the game just knows what he's gonna get before he plays it
A few things: If you navigate away from a tab, `requestAnimationFrame` will pretty much put everything on pause, so you're not using a lot of resources unnecessarily. It also tries to animate at your monitor's refresh rate (probably 60fps). There's no point in doing more work than that for animation, like OP was doing with `setInterval(1, update)`. I'm not sure of the internal workings, but I believe it tends to generally perform better. E.g. I did JS1K, and I tried to use `setInterval` or `setTimeout` to save a few bytes. It worked fine in chrome, but everything got locked up in firefox. I switched in `requestAnimationFrame`, and everything ran smooth. But yeah, I'm not sure why this is, but now I'm really curious to find out. And probably some other stuff. Edit: [This](http://dev.opera.com/articles/better-performance-with-requestanimationframe/), and [this](http://www.nczonline.net/blog/2011/05/03/better-javascript-animations-with-requestanimationframe/) both explain it better than I could. &gt;Second, not only do timers continue to run for invisible animations, but when their time is up they also always enqueue their callback functions. Let me explain why this can sometimes pose a problem — say you didn’t do your job particularly well and for some reason the callback function takes more time to finish than you have set up your timers for. Once the timers are up they will enqueue yet another callback function, even though the previous one hasn’t finished running. As this process repeats itself over time, you can quickly enqueue a virtually infinite amount of timer code, causing the browser to stall. 
Your game just ruined my marriage.
`requestAnimationFrame` tries to optimize frame rate for the current system, which **should** equate to ~60fps on a decently powerful device. However, if your hardware's not up to snuff, things will probably run more slowly (but frame rates will remain consistent). With that in mind, a benefit of using `requestAnimationFrame` over a plain `setInterval` is your animation loop is less likely to freeze the browser. Not sure about the inconsistent timings between browsers, as I've yet to see such a discrepancy myself.
+1 for the codeschool angular intro. just finished it myself
Hi! I tried to find you before releasing, but you're never on #bbg anymore :( I love your work!
https://www.youtube.com/watch?v=ViGNBLQpGWE
Nicely done! It may not be the prettiest thing, but the controls seem to be pretty tight. It also seems to run pretty smoothly. One easy thing to add would be some sort of score counter, so people can compare how terrible they are at this game with each other.
Good points. Still seems a shame as it will undoubtedly be used primarily by marketers.
How come when I write this into JSFiddle it doesn't show anything? Would I have to give the 2 div's properties (like height, width, colour etc.)?
This is a Blend4Web tutorial. Proceeding with interactivity in 3D apps, we'll look at the implementation of the "Playroom" application, in which the user will get the possibility to furnish the room with furniture items.
Another update - one of my colleagues now has the actual Cardboard headset so we've been message around with it a bit and trying to work out what the magnet actually does. It looks like one the phone's sensors can detect strength of a magnetic field. At resting this value varies from about 10-15ut, but once the magnet moves closer to the phone this value leaps up to around 150ut. So I'd saying measuring that magnetic field strength would be the way to go.
Now take a look at the next game from Dong Nguyen (creator of Flappy Bird) https://www.youtube.com/watch?v=wuoCeze0B3c It has basically the same mechanics as your game. Not bad for a foreshadowing.
Demo isnt working for me.
This was more to demonstrate the idea- I mean, yeah- you'd have to add background-colour or it would be changing the height of an invisible element. Also the #hover-div doesn't have any dimensions so you wouldn't be able to hover over it as-is... I was just showing that you don't need to do anything crazy - just add/remove a CSS class and let the CSS take charge of the animations.
I mean, you could do ALL of this with CSS if you wanted to - no JS needed: &lt;div id="hover-div"&gt; &lt;div id="target-div" class="box"&gt;&lt;/div&gt; &lt;/div&gt; CSS: .box { height: 0px; width: 100%; overflow: hidden; transition: height 1s; } #hover-div:hover .box { height: 400px; }
True, but if we were supporting a browser that didn't have addEventListener we wouldn't be using CSS3 to control the animations ;)
I think this is the first post in a long time which claimed to use a brute force method and actually did.
Some of the speeds are a bit fast, but other than that it's quite an addicting game. Changing `fish.maxSpeed` to around 150 and `pipes.speed` to 100 makes it a lot easier, but still fun.
You should just have read the Readme. (arg, arg2) { ...} Creates an anonymous function, and Name: (arg, arg2) { ...} Creates a named one. Also some of the testcases are pointless /wrong on purpose. That's why they're tests.
Assigning a licence is something that only the copyright holder gets to do, so exactly that. You'd never put MS Office on github and decide that it should have an MIT license so why do it to someone smaller and less experienced?
Ok, thanks :), I thought it was missing something haha
Yeah, and being free with other people's code is a terrible habit to get into if you ever want to turn professional.
Maybe you could implement a fixed frame rate for the game?
Who would have thought? That's basically it, though there are 147 other words under this section which explain further. If you want great detail there's even links to 3 other articles included that you could follow!
Hey! After removing the type declarations and fixing some typos it runs just fine. Give this a shot: function Car(make, model, year, color) { this.Make = make; this.Model = model; this.Year = year; this.Color = color; this.FullName = this.Year + " " + "&lt;b&gt;" + this.Make + "&lt;/b&gt; " + this.Model; } var myCar = new Car("Subaru", "BRZ", 2014, "Blue"); alert("My car is a " + myCar.FullName); Hope this helps! Good luck!
Thank you! I was unaware mycar would not work while myCar would. I appreciate your help with this! 
I second this, PDF parsing is a bear and Mozilla has put a ton of work into pdf.js. They also have an included viewer, a similar one used in the Firefox browser which works very well. The viewer has a lot of features similar to desktop apps and also downloads PDF files using range requests, which has the effect of loading in slides individually, so you don't have to wait for the entire stack to download before you can start viewing them. The one downside is that if you host PDFs on a different domain, you'll have to setup CORS, since the javascript is doing the loading of the pdf. Edit: Err I probably should have read your entire post. Pinch to zoom may work with their viewer, although I'm not completely positive off the top of my head. pdf.js is readlly just a pdf parsing library, the viewer has to do the actual heavy lifting beyond anything just canvas. For example, the viewer packaged with pdf.js will render text in text field overlays instead of in canvas. This allows users to highlight, copy and paste pdf content. The pdf.js library simply gives you access to the text content/coordinates of a particular page. You could add you're own features for things like videos or hot spots (depending if that data is actually imbedded within the pdf).
Yeah right :D I was about to comment that this game needs a text showing your current score before I realized that it's impossible to get more than 3 points
It's a good example of what flappy bird got right. It was a simple mechanic but it felt good to play.
Hey, I've managed to score 52987! It was about my 20th round, at 40000 I've felt like I could do it forever and by 50000 I got bored with it. Still, it's a very cool game, got me into the zone for sure!
Were you trying to program something that makes people hate you? If so, great job. :P I see a lot of code that looks cut-and-paste-y. Whenever you see yourself doing that a lot, it's generally a signifier that you should encapsulate whatever it is in an object or function and then call it with params. var bgImage = new Image(); bgImage.ready = false; bgImage.onload = setAssetReady; bgImage.src = "images/Background/sky.png"; var playerImage = new Image(); playerImage.ready = false; playerImage.onload = setAssetReady; playerImage.src = "images/SwimmyFish/SwimmyFish.png"; var pipesImage = new Image(); pipesImage.ready = false; pipesImage.onload = setAssetReady; pipesImage.src = "images/Pipe/pipes.png"; var cloudImage = new Image(); cloudImage.ready = false; cloudImage.onload = setAssetReady; cloudImage.src = "images/Background/cloud.png"; var waterImage = new Image(); waterImage.ready = false; waterImage.onload = setAssetReady; waterImage.src = "images/Background/water.png"; var titleImage = new Image(); titleImage.ready = false; titleImage.onload = setAssetReady; titleImage.src = "images/GUI/Title.png"; Could be rewritten as: function make_sprite(src) { var sprite = new Image(); sprite.ready = false; sprite.onload = setAssetReady; sprite.srce = src } var bgImage = make_sprite("images/Background/sky.png"); var playerImage = make_sprite("images/SwimmyFish/SwimmyFish.png"); … There are also more elegant ways to do event handling than setting the `.onload` attribute on an object. I'm also not at all crazy about how you are using `now` and `then`. It's especially weird for you to declare it *after* it appears in a function above. I would actually look into how you might use something other than a global variable to track `then`.
I can't get past the first pipe :-/
Good point. Didn't see the transition.
Javascript is case sensitive, so name =/= Name
Yeah, this article is really light on content. Not even a mention of requestAnimationFrame, which usually comes up if you're talking about layout thrashing. So disappointed.
[Ugh.](http://www.youtube.com/watch?v=cG1K6oZjdBc)
Instead of using replace, he should have called substr(1) to get rid of the question mark from location.search. Using replace will be slower to get the result you're looking for since it has to traverse the whole string just to get rid of one character.
Slightly off-topic but it's important to note that Angular.js is a full front-end framework and Knockout.js is simply a data-binding library. Admittedly my experience with Knockout.js is extremely slim but it seems like a great tool for folks who want the powerful data-binding features that popular frameworks such as Ember and Angular provide without being confined to the rest of the framework. 
I agree w/ /u/oefig , comparing KO to ng isn't appropriate. I am not a huge fan of KO, in my limited exp. it's been buggy at best. There are lightweight alternatives popping up like https://github.com/gwendall/way.js
Knockout is useful if you only want something to do the data binding for you and want something slightly less magical than what AngularJS does but something more full-featured than Rivets. I considered using Knockout in a recent project instead of AngularJS because I needed to support IE8. In the end I decided to go with React instead. I have used both Knockout and AngularJS in the past and I don't think I would use Knockout again. For me using observables was more cumbersome than just using scopes in Angular while still providing me (via computed observables) with too much rope to hang myself with. I'm not going to blame Knockout for what might just be my own incompetence, though.
Yeah, I figured it might be hopeless, but thought I'd just throw it out and see what happened. Thanks for taking the time to respond! I'm just going to start reading up more on JS. I've already told my supervisor that I probably can't get that functionality up and running with everything else.
Only inject what you need, anjular is very nice for databinding and if you find you need more it can deliver. 
Hey thanks for such a detailed message. Again I'm just starting out and only have a grasp of the basics, so far most of the time when there's something wrong it's due to newbie mistakes. Again thanks for the info, looking into all of it now.
Yeah, no problem. You can hit me up any time if you need help with anything.
Like others have mentioned, it's really apples and oranges when comparing KO to Angular. If you want a full-featured front end framework for building a large app, then Angular is a great option. However, if you just need data binding, KO might be a better fit given its relatively light set of opinions and smaller footprint in comparison to Angular. I use both on a day to day basis for two separate projects and they're both fantastic, provided you can recognize their strengths and weaknesses and play to them. I'm building a large SPA in Angular w/ CoffeeScript (using Yeoman to automate a bunch of stuff), and it's a joy to work with. It can be a little heavy-handed at times, but it makes code re-use a snap and has a lot of build in features that make it a no-brainer for this particular type of project. My KO project is a little smaller than my Angular project (and not an SPA), but I'm able to choose my own architecture, which really allows us to tailor the app to fit the project requirements. We chose to go for a more pure MVVM architecture, removing all DOM manipulation or calls to external services from our ViewModels. It's become really nice to work with as well, but wasn't without its growing pains. At the end of the day, I don't think anybody needs to sell you on anything. Just let the requirements of the project take a front seat in the JS lib decision making process. Need to retrofit a legacy app with some fancy data-binding to make it feel more snappy? KO would be a better choice. Starting from scratch and want to build a SPA that talks to a REST back end? Angular would probably be better in that case.
Having noticed that all popular Node.js facebook pages are dead, I decided to create a new one and am committing myself to deliver news about Node.js on a daily basis. If you want to be up to date, like it! Let me know what you would like to see there either here or through fb. Enjoy!
You could start a new subreddit. Explain Like I'm Much Smarter Than I Am, where you explain things.
now convert the interpreter to this! http://patriciopalladino.com/blog/2012/08/09/non-alphanumeric-javascript.html
As most have said here, Knockout is fantastic for data-binding. Have built a few D3 heavy applications and its a perfect compliment to something like D3 where everything is driven by data. I've also built a few ng applications and still feel that people call it a framework, where I like to always address ng as it does on it's homepage - "...a toolset for building the framework most suited to your application development." - ng has some great pieces and can be used as part of or foundation to a larger framework.
Knockouts observables are super super handy. It is about *far* more than data binding...it is about dependencies and data management within your models/viewModels, in addition to binding those elements to the UI via data-bind attributes. I don't care what kind of application you have, you will have state management and things in various parts of your application that need to know about and modify that state (and other types of data in your application)...observables provide a very handy way to cleanly hook into that logic (when done properly). Using observables (and it's variants) to track your data as it flows through your application really is a thing of beauty when finally grok'd. I have been working on a framework based on Knockout 3.2 (began work on it a couple months back actually) which, with provided examples and documentation, will help other people decide they want to take a second look at knockout (and my framework in particular, hopefully - I will be providing significant features on top of KO 3.2).
Yep, I'm the author. It's for speed / performance. The hit of invoking the JIT compiler on a sort call is far less than the hit of running the sort function it compiles with references to "key" of the parent scope. In the latter, every time JS compares two elements it has to do a scope lookup.
Or, if you think any framework is magical, you shouldn't use it until you understand it to prevent future headaches. 
You can use as much or as little of angular as you like.
It's been a few years, but I was comparing KO vs Angular and Angular didn't have a way for me to independently bind multiple templates on a single page. KO will let you pass a dom element and only parse templates in that element. But angular (maybe just back then) would only let you parse the entire page as a whole. 
If you end up using KO, look into the mapping plugin. Made creating the model much easier than typing out ko.observables for a complex class. Also in KO, This works: viewModel.Property("new value") This doesn't: viewModel.Property = "new value"
I went from angular to knockout, as I really do not like the coding style and magic inherent to Angular Zen, and knockout was quite easy to ramp up on. However, Knockout has a lot of it's own idiosyncracies, and doesn't handle hierarchical data well (in fairness, that's also a complaint I have with ng). After not really feeling comfortable with the way KO handles observables, and never really getting subtemplates to work intuitively, I moved towards backbone for MVC. I honestly can't imagine using anything else at the moment. It's trivial to plug in a template engine to do your data binding (I use handlebars at the moment) and it is an extensible library rather than ng's "your application code plugs in to our framework" approach.
Object.keys(obj) will give you the keys of the object as an array, which you can then use to loop and index into your obj.
My recommendation is that since you always have N markers, keep N markers in an array. When someone inputs something, you loop through the markers and call `marker.setPosition(NEWLATLNG)`. No need in removing and adding markers to your map if you don't have to.
Same here. We used knockout in production for about 8 months at work and now we're switching to angular- the code is just overall cleaner, and it stops pollution of the DOM code (since you can do data-bind: click: function(event) { .. }) all in the HTML part, and knockout will happily do it.
nice abstraction 
#6 please
Keep calm and Catch them all
"Angular culture"? In my opinion, if it works well, it's testable and another developer can come in and use it is a good practice.
"KO dependency tracking is a clever feature for a problem which angular does not have." http://stackoverflow.com/a/9693933/20003
Since you seem to be using jQuery you can use [jQuery Each](http://api.jquery.com/jquery.each/) to iterate through the object. For in loops do the job, but there are cross browser issues(I've been using each in libraries/frameworks or arrays so long I've forgotten specifics). [for in loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in)
Thanks. Creating a parallel array seems like a waste, but it works, so for now I'll use it.
I tried a FOR IN loop, and can see the data in the object via console or alert, but the link between the object data and the marker isn't clear to me. When I create a parallel array and look at the console, there is quite a bit of data there, but I'm not clear on the information used in the interaction that actually closes the marker. Is it Lat / Lon? A unique ID created when the marker is created? If it's the latter, I don't see any way to close the marker without using a parallel array.
Can you elaborate on the issue here? What do you mean 'the information used in the interaction that actually closes the marker?'
Sure, but Knockout-style observables aren't the only way to solve that. AngularJS solves the problem via dirty-checking and explicit watch functions (and scope update triggers). The result is actually even cleaner than what Knockout does (by separating the watcher logic from the computation logic), IMO. React solves the problem by avoiding two-way-binding altogether and instead having explicit state updates and abstracting away the DOM to make event handlers a lot cleaner.
TBH, I think if you can live on the cutting edge, Rivets is a much cleaner solution (using the native `Object.observe` or an ES5 substitute).
Object.observe doesn't have all the features that you get along with knockout and observables unfortunately. But it is nice that browsers are starting to implement that, and if your needs are met by it then by all means - use it.
Thanks, and I'm not limiting myself to jQuery for this. I'm only using jQuery for ajax and parsing.
apparently it doesn't have anything to do with synthesizers and webAudioAPI :/ Does the name has been suggested by the same guy who came up with prototype.js?
I haven't worked much with Knockout, but looking at it in the past I found a lot of opinions that Knockout was built for creating UI components, as opposed to Angular which is built for web applications. Angular is quite opinionated and used idiomatically doesn't really seem to provide you much alternative to doing things the 'Angular way'. That's not necessarily a bad thing; frameworks are supposed to have opinions; but it might make KO a more obvious choice if you have an existing codebase and want to start 'adding in' UI elements built to some kind of MVC design.
I think I understand your question now... You can store a reference to the marker in the object that stores your data. So as you are looping through your object that stores the lat/lng, just add a marker to that object. Something like (obviously pseudocode): for (var i in Object.keys(data)) { data[i].marker = new Marker(data[i].lat, data[i].lng); } and then to clear, you know which marker is associated with which object. However, this still isn't what I would think you'd want to do, because you will be creating and deleting markers every time someone searches. It seems like the separate array of N markers is the way to go. If the only operation is to set all N markers, then you never need to find a specific one to be able to clear it from the map, you would just change their locations.
By reference. When you put a marker into the array you are storing a reference to the marker. Later on you just access the marker again via the reference. To identify the marker later you might want to store the markers in an object instead markerObj['key'] = new marker blah blah markerObj['key'].setMap(null);
No one yet??? OK fine, I'll do it after the commute ;) 
You are doing prototypal inheritance wrong. Child.prototype = Object.create(Parent.prototype); Child.prototype.constructor = Child; Child should also call the the constructor of the parent: function Child() { Parent.apply(this, arguments); } And this is not an option, *this is how you do prototypal inheritance in javascript*. Accessing variables on the prototype is *not* counter-intuitive. A prototype is not *yeah, my object should have these default properties after it is created* (like a java class definition). A prototype is just an ordinary object, try this: var foo = { bar: 1337 }; var baz = {}; baz.__proto__ = foo; console.log(baz.bar); If `baz` has no `bar` property, the engine moves to the prototype (until it finds it, or the root is reached). *Javascript is not Java*, that's my point.
WebPageTest has the relevant code for rendering timelines, and you can right-click and load timeline data just like in chrome devtools - [example](http://www.webpagetest.org/chrome/timeline.php?test=140819_WB_ZX2&amp;run=1) WebPageTest is [open source](https://code.google.com/p/webpagetest/source/checkout), you'll just need to find the timeline.php code and any of its dependencies.
Thanks. That's what I (thought I) was doing, but it wasn't working. I'm using a parallel array to clear them for now, when I have time to experiment I'll go back and try again.
Limited scope and features make it easy to integrate without adding overhead, and knockout's templating syntax is much friendlier, imo.
&gt; you will be creating and deleting markers every time someone searches The database contains 2000+ locations, and we only want to show the closest locations. When the page loads, the N locations closest to the user's geolocation are shown on the map. The user can then manually input an address which is geocoded, and the N locations closest to that address are shown. The old object is destroyed and a new object created. If the address used is only a few blocks from the geolocation, there would be duplicate rows and markers in the array. I could check the siteid and not add it to the array if it already exists, but it seemed simpler to just remove the markers and plot new ones. Thoughts? Thanks for all the help.
Ractive.js is a very nice library. With two way binding templating. And it is quite fast. After an year on angular I feel the same angular is too much "the angular way". I really like it but I would prefer having a standard to glue micro framework toghether after all.
Yep. We're using require.js as well. The require module that wraps each ViewModel takes a set of dependencies, so when the ViewModel needs to fetch or persist data, it just delegates to that service, which is backed by jQuery's promise API.
What is asked here, like do you need code for making an interview process or ?
No, I just get asked algorithm questions a lot on interviews and I don't have a CS degree, so I'm looking for a collection of common algorithms that are implemented in javascript. For example, binary tree traversals, linked lists cycle detection, merge sort, bubble sort....that sort of thing. I am only doing 100% javascript these days.
I think it's true but a bit misleading to say Angular is a full framework while Knockout is simply a library. It seems to me the main reason Angular/Ember/Backbone are referred to as frameworks is that they all include a router, and consequently they will 'call you' (when a route is matched). Knockout doesn't come with a router so you always 'call it'. The inversion of control is what separates 'framework' and 'library'. But 'framework' sounds somehow more serious and feature rich, after all aren't we trying to get away from stitching things together with 'libraries' like jQuery? This is understandable but in fact Knockout solves a lot of similar problems to Angular/Ember and I think it should be considered alongside these. This new 3.2.0 release adds 'components' which I think has been the missing piece. You can nest them as deep as you like all the way up to an entire 'page'. Now you could grab [a router](http://millermedeiros.github.io/crossroads.js/) ([or write your own](http://krasimirtsonev.com/blog/article/A-modern-JavaScript-router-in-100-lines-history-api-pushState-hash-url)) and wire your whole SPA up into a single element: &lt;div data-bind="component: routeObservable"&gt;&lt;/div&gt; ...and if you're using require.js, it'll even lazy-load the page templates and logic with no extra work! So that's me trying to sell you on Knockout 3.2.0 :)
hey all i understand your comments on pricing but to demethvin's point it costs a lot to put on a conference. I have run www.devnexus.com in Atlanta for many years now so I get the costs. we could lower the ticket price and have no breakfast or lunch and photocopied programs etc but all that adds to the conference experience. Also i know the costs of other dev conferences and they do go from $150-$1000 (no fluff just stuff). the big AWS conference costs $1900 for a ticket (but you do get a nice hoody). Its an interesting dynamic with running conferences and pricing. costs go up as the number of attendees go up because you need more stuff from the venue (as an FYI the AV and wifi alone for this show costs $10K). Having sponsors helps keep costs down in the long run as well but as this is a new show we wont have much $$ there to help keep tickets down. 
I don't know a collection of implemented algorithms for JavaScript. But with an algorithm in mind, google it's pseudocode and then it's fairly simple to implement it yourself!
It was pulled out of the Chrome project so they likely didn't care about cross browser compatibility.
there will be 40+ sessions at this conference. if you read the website carefully it says "The conference will feature a total of 40 sessions over 2 days. Here are some of the sessions:" - the CFP has not been closed yet.... 
npm install request is what you are looking for. Or you can use connect which is a native nodejs library
I've just used node.js with cheerio and request, but @JavaScriptDaily tweeted this yesterday: https://github.com/ruipgil/scraperjs It might be worth checking out
Ah, it was a pretty niche situation, as I believe most of the time someone would be happy if all their templates parsed at the same time, but I had a weird case where I needed to parse a majority of the page, and then would request an external template and parse it for a side bar on the page.
Yeah I realized that after I posted it. haha. If you don't need DOM parsing then just an HTTP request in Node will work. http://nodejs.org/docs/v0.4.11/api/http.html#http.get One thing just to note since I dealt with this as well. This will just grab the source the server sends. If the page generated by javascript like an angular site then you won't get what you think you will. Something like PhantomJS is a headless browser so it runs the javascript and you can grab the text that way as well. If you need to take this approach and have questions just let me know.
You can't get the contents of a page from client side unless you are on the same domain, or have access to add a special header to the target (These limitations are for security). You will have to do this either locally or on a server. Note: If you are making a chrome extension, you can also request any domain you have permission to: https://developer.chrome.com/extensions/xhr (Sometimes I wish there was a way to request this permission on a webpage ha)
This sounds possible as well. Either way, if you ever need any help with Angular, feel free to ping me. 
Cofounder of Eager here (copying my response from the article itself): Eager is targeted right now at helping the 100 million non-technical website owners in the world use the all great open-source libraries and tools which are out there. For technical people the biggest opportunity is the ability to get the javascript and css libraries you may have built out to a much wider audience. As much as we'd love to make life easier for all the other technical folks out there, we just don't need as much help (and it's a smaller market). The long-term plan is to create an ecosystem where free and paid apps (like Disqus) can more easily get what they've built onto more websites. The hope is that by creating an ecosystem, we can help the best quality apps get a much wider release, while improving the quality of the websites which have access to them in the process. We have plans for supporting dependencies, but we haven't been able to tackle that just yet. We very much want to solve it. We also want to solve testing your app when dependencies change, upgrading library versions painlessly, and a half dozen other things. Most of our time thus far though has been focused on the reliability of our infrastructure and the quality of our app itself. Start using Eager now, and you'll get it all when it comes! Our pricing is far from set in stone right now. The assurances we have on the home page are the minimum we're committing to providing in the future. As we learn more the number of free page views might go up, but it will never go down. We don't actually want to charge sites at all, we want to collect a portion of the revenue app makers get when they decide to charge for their app (while we help them to be installed on 10x or 100x more sites than they could before). Unfortunately, it costs us some amount of money to serve every request, and we're not in a position to commit to being free forever just yet. Please reply with any other questions.
Appreciate it! This takes place over my birthday...maybe I'll treat myself early..
If I understand correctly... You are doing this in the browser... It appears you know how to include jquery via your comment, so just use the $.ajax function and the success function will receive one parameter of a string; the entire page. The docs should be better then I can here
when you say buggy, what do you mean? The only issue I've found has to do with rate-limiting observables. 
If I were given a task like this, I would go straight for d3.js, but that's just me. Have a look: http://d3js.org.
Thanks for your submission! Unfortunately, it appears as though it doesn't meet our [guidelines for self-promotion](http://www.reddit.com/r/javascript/wiki/index) and has been removed. If you would like to resubmit, please take the guidelines into consideration. Thanks for your understanding.
I'm looking and, to be honest, if it was possible to fall in love with a set of code I think I'd be writing love poems right now. that stuff is _gorgeous_. that said, 99% of it is beyond my grasp at the moment so I'm looking for something to adapt easily -- I'll look deeper. I really like that they seem to expose everything so it's kind of infinitely manipulatable. thanks!
could you write a book about distributed systems with socket.io? I would read the shit out of that.
Thanks to all for your suggestions. But, if running client-side, none of them will work, I guess I'll have to stick with my perl -&gt; json -&gt; javascript kloodge.
hmm I should check out backbone
Agree everyone is using d3 professionally these days, so if your trying to learn something extremely useful that is the best place to start.
4 and 5.
I don't know too much about require.js, but on a related note, have you heard of [Browserify](http://browserify.org/)? Might be helpful.
Just a thought on optimizing performance and this may be a drastic change, but you actively iterate through the data a lot. Most of the time, this is using a 'key' that references some variable on each object within _data. It may be good to keep a LRU cache of sorted arrays that match up with a particular key, only creating a sorted array if necessary. For example: max('id') - ask for sorted array for 'id', creates sorted array for 'id', caches array, returns array, retrieve _idData[_idData.length - 1] min('id') - ask for sorted array for 'id', returns array, retrieve _idData[0] filter - could bisect, using binary search distinct - http://stackoverflow.com/a/4833835 Cool library none the less. Would love to see some comparisons with Crossfilter or Pourover
IMO, the easiest charting framework to use is highcharts. The 'hover balloons' are called tooltips in HC. It takes ~10 min to do this in HC. Here's a fiddle of what you need http://jsfiddle.net/davidpmcintyre/e8exu2n2/ D3 is more suitable for HC if you are inserting &gt;500 plotted items. If not, stick w/ HC. There's tons of samples at the HC website and if you have any questions, the HC tech support guys do a great job of responding at stackoverflow within a matter of hours.
&gt; after all aren't we trying to get away from stitching things together with 'libraries' like jQuery? Speaking for myself, definitely not. Frameworks like Ember and Angular have their upsides, especially when you need that structure for keeping less-seasoned developers on a good path. But, the holy grail has always been clean, composable systems that neatly tie together a variety of libraries without being quite so opinionated about the whole. For example, see how the Node ecosystem absolutely exploded out of no where by following that sort of approach with its module system. See also: http://en.wikipedia.org/wiki/Unix_philosophy
Nice share... Is there any other tool you use for JS static analysis for mind-map
Just because older versions of IE don't support it doesn't mean it's useless -- there's a polyfill for requestAnimationFrame that is fairly useful. It's not going to be as useful as the native version, but it's better than having events not invoking callbacks or having a sluggish browser. If you have little DOM manipulation, you might not need requestAnimationFrame, but it's handy when you do. EDIT: I'm on my cell phone right, and I just read that you said requestAnimationFrame can't handle the thrashing of a single element, which makes no sense since a common technique to handle any sort of layout thrashing is to have an array to store the callbacks, and then invoke them in requestAnimationFrame. This will handle one one element just fine as it will handle the whole DOM tree. If it doesn't, there's a problem with how you're implementing it.
Actually, I forgot; if you're just doing it on your machine, you can [disable the security feature](http://blog.nraboy.com/2014/08/bypass-cors-errors-testing-apis-locally/) in your browser. 
Way.js isn't that "lightweight". It's about twice the size of knockout and also comes bundled with jquery and underscore. https://github.com/gwendall/way.js#installation If you are already using underscore and jquery then it would make sense. If not, I would checkout this microjs site. It has some cool stuff. http://microjs.com/#Binding
I totally know what you mean. It is so lovable, but pretty freaking dense. Spend some time with the examples, and eventually you'll get its idiosyncratic way of doing things. Als, to echo u/shibby13ird, it won't be a waste to sink some time into something so many people are excited about right now.
Its much easier to just use grunt or gulp to concatenate all your files on save/change
I've been using knockout every day for over two years now and I've never encountered a single bug. Can you please elaborate?
wow... that's so nice of you to punch that up! I did look at HC and struggled through that as well. this always happens to me with a new framework (I haven't conquered this problem yet) -- I just get totally turned around and can't quite concentrate on the right piece until I feel I've unlocked what's going on. HC looks awesome -- seems similar to d3js (not sure which has more support / users). I'm going to fork your example and see if I can tweak it a bit. and thanks again! 
I just came of a few months of using Durandal and Knockout. I've heard people say a lot of good things about Durandal, but I've never been able to understand what they see in it. Overall, working with it was not a fun experience and I don't intend to use it again. I found the documentation lacking at times, especially in reference to a few of the more conery cases. And, there just doesn't seem to be that large a community around it. (The Durandal Google group being the exception.) Additionally, about halfway through my project, the lead Durandal architect announced that he's now working with the Angular team, and there seems to be the possibility that [they will be merging somewhere down the road](http://blog.angularjs.org/2014/04/angular-and-durandal-converge.html). I don't want to risk dealing with whatever the migration path will be. All the more reason I'll give it a skip next time.
I know. I was really surprised at the low quality, too. I expect a lot more from O'Reilly. Maybe try these: https://github.com/nzakas/computer-science-in-javascript http://www.nczonline.net/blog/tag/computer-science/ I haven't actually looked through these myself, but I've never been disappointed by Zakas. He's extremely knowledgeable, and his writing is very clear and informative.
I've always steered away from Javascript transpilers for fear that extra debugging confusion caused by code obfuscation would not outweigh the benefits of extra/better language features. But using ES6's class pattern does seem like another good way to get around this trap.
Find a transpiler that supports source-maps. Traceur has it, so does `esnext`.
I have asked a friend to help me on the Scala example as I don't know a single thing about that language. I am not sure if you could use an authentication library like AuthStrategy with Satellizer. Most auth libraries provide a full login flow from start to finish via a page redirect whereas Satellizer does half the work by obtaining authorization code via a popup, and then exchanging it for an access token on the server. Then using that access token you can obtain profile information about the user or perform actions on behalf of that user. All you need on the server is a JWT and a Request libraries.
Really bad advice, do not follow it. 
I am literally stuck on page one? According to the home page I didn't need to know anything...I didn't...and I still don't. :(
http://lhorie.github.io/mithril/ is another good, lightweight library for that kind of stuff 
&gt; Angular/Ember/Backbone are referred to as frameworks is that they all include a router, and consequently they will 'call you' (when a route is matched). Knockout doesn't come with a router so you always 'call it'. For Angular at least, you really don't have to use the router if you don't want to. For our big project at work, we just use server side routing. Directives are so awesome, I'm using it for my hobby projects now as well, mostly for just the databinding, services etc... basically anything but the router :)
adding static analysis (Compile time type checking) to your development process will improve your code quality and help you to reason about your code. I personally think typescript does not go far enough, but that is why I use the closure compiler.
wasnt really promoting, as its a stupid game i will never finish but meh.
Yep, exactly the same problem for me. With no context for syntax, objective, or how the site itself works, I'm left bewildered. EDIT: But skipping ahead, it's a lot more explicit in what the damn hell it's asking you to do. So... maybe ignore question 1?
Unfortunately, it's for a full-rendering of LaTeX, formatting and all. 
Clojure is a beautiful fucking language on so many levels. It kind of sucks that Clojurescript is such a pain to develop in because of the awkward tooling (JVM? No thanks) /interop story with existing js code. David Nolen and the whole Clojure community is rediculously brilliant and practical minded though, so I wouldn't put it past them to make things much smoother in the future.
That is incredibly cool. I can pinpoint the exact moment when it made sense to me: http://clojurescriptkoans.com/#functions/9 I fought that problem for at least 5 minutes, closer to 10 most likely. Then I had the most satisfying ah hah! moment of my entire life.
&gt; it looks like an implementation of ES6 Their goal is to be a superset of ES6 (which means compliance with ES6). In addition to ES6 features and type checking, TypeScript offers interfaces, generics and function overloading. When the TypeScript ecosystem is mature enough, I don't know why anyone would want to develop in JavaScript. Until JS catches up with TypeScript, that is. Anyone who claims that the overhead introduced to workflow by TypeScript outweighs the benefits hasn't researched the subject enough. Type checking and static analysis alone are huge boosts to productivity.
These constructors are much slower and cause issues when another class tries to use them via `TheConstructor.call(this)` (handy for mixins). Other than that, they are definitely better and lead to nicer require statements too: `var mesh = require('gl-textured-quad')(gl)`
Why do you need require.js and Angular? If it's because lazy loading search Google for solutions for Angular like http://ify.io/lazy-loading-in-angularjs/ If you need some better project stucture use pure Angular - NGP (ng boilerplate) or integrate Angular and Browserify 
&gt; When the TypeScript ecosystem is mature enough, I don't know why anyone would want to develop in JavaScript. Sidenote: there are other, compile to js tools out there, with different syntax and tools. More precisely i think about Dart, which will be more familiar for guys coming from a Java background than coming from C#. I personally didn't use TS so far, but recently had an opportunity to hear a technical presentation about it, and i was not amazed. I wasn't amazed, because i have a good Vanilla JS background, and an affordable Java background. Typescripts syntax made me crazy, i personally found Dart better. Here, better means more familiar, easier to understand, etc.. 
I think it is great. I've been using it on some personal projects and hope to introduce it to my colleagues at work. We have a large product with 10s of thousands, may be already 100s of thousands of lines of JS. We have JSDoc but could really use the extra tool support. The typing itself is the best part of course. What I like about it is that it is optional and has type inference. Being optionals lets you choose how much type information and checking you want to add and when. (At the start of a project you might not be interested in worrying about types so much, but later you may want to 'nail down' the types and APIs.) Type inference means that you don't have to spam your code with type info to get large type safety coverage. You really get to choose the mix of dynamic and static typing you want and you can turn that dial up as you go along which is vital if want to migrate and existing JS code base. The other ES6 features are great too, but they will slowly show up in JS given time. The typing is what it is really about. For small projects you might not need TS, but for big projects it is a huge boost. (The fact that the JS output resembles the TS input is very nice too.) 
Not far enough in what respect? More typing? More syntax sugar? 
The compiler has several weaknesses imo, it cannot create a final product and apply dead code elimination, also you cannot write your own compiler passes. Its typing is inferior to closure I feel. The closure eco system is a lot more mature, having been in production at google for a very long time now.
Not sure about integrating directly with a Dropbox link, but I have IFTTT sync all my Instagram photos to a Dropbox folder, which gets put on a simple static file server, which I can then use with http://weisjohn.github.io/autoindex/ to scrape and show on another page.
It is actually 'JavaScript', not 'Javascript'...just sayin'
Oh I think it might be doable, Scalatra's AuthStrategy is more of an interface for standardizing auth than a full fledged auth module. You specify how session works, implement isValid() to ensure the auth method is viable, and then implement validate() and return a User -- the rest is up to you. Satellizer seems like it will fit in perfectly since it's only providing information from the oauth provider and depending on the server implementation to get the access token/find and return user information. I think I can easily implement the authorization code exchange inside AuthStrategy. In fact I'm already using it with a rudimentary token auth system I built myself. 
It's the compatibility with JS that makes it special. As very often, google plays with what's cool and useful for them, while microsoft offers something that has real added value for even the smallest shops. 
&gt; After using Angular for a bit, I feel like it's overly complex and makes problems out of things that should be trivial - while still providing a lot of benefits of course. Yep, angular is certainly a trade off. You get a lot of magic, but at the cost of a little less flexibility in how you code your app... but flexibility isn't always a good thing either, just look at perl ;)
I don't think Dropbox offers a method to do this (at least not yet). Dropbox does, however, offer [an API](https://www.dropbox.com/developers/core/docs) which handles authentication and access to files. An option might be to scrape the public album page (the link you provided), and pull the images that way; however, I don't know if Dropbox would be OK with that. 
I've always been really torn on the third pattern (exposing a regular function). On the one hand, you're making your code safer, as there are fewer ways to mess up. Great. On the other hand, you're making it MUCH harder for people who are using your library to learn JavaScript. Consider: // your code var a = new MyConstructor(); var b = MyConstructor(); They behave the same, great! // other code var c = new OtherConstructor(); var d = OtherConstructor(); They didn't behave the same at all, what gives? Perhaps this is pie-in-the-sky thinking, but I'd rather focus on sticking to a convention- say, only constructor functions are capitalized, and always use the new keyword- than attempt to teach someone to use JavaScript in a way that it doesn't normally work. JavaScript is not the most natural or elegant programming language, which is why I typically recommend would-be developers start with a different one before attempting to master it. I don't mean to say that throwing an error or providing additional safety for your code is wrong, but I worry that the third option encourages developers to rely on that safety, rather than get a deeper understanding of the consequences of the new keyword itself.
Thanks for your link. It would be nice to integrate them directly from Dropbox, then you can skip some steps... like syncing and creating a gallery with fancybox. :)
JavaScript intended for the browser should be run in a browser. Not in Node.js. You might be able to create a build profile with PhantomJS since it's a headless WebKit browser.
Thanks! I searched Dropbox and Github for example libraries, but couldn't find anything.
Sweet. We ran into this problem immediately. Also, if this is truly complete, why shouldn't the ionic team polish it up? As they mention, ngCordova mocks will be provided "soon". http://forum.ionicframework.com/t/announcing-ngcordova-simple-cordova-plugin-wrappers-with-angularjs/5168
&gt; [Dart] will be more familiar for guys coming from a Java background than coming from C#. Dart is closer to C# than Java. C# has things like `var`, named optional arguments, fat arrow functions, `await`, and operator overloading. Also, C# was a direct influence: http://i.imgur.com/CKvCrCW.png
This post doesn't say anything about Node at all. The number of people using JavaScript is far greater than the number of people using Node. I don't know a lot about Node but most sites will have a build and/or deployment step of some sort, the compilation can be part of that. 
TypeScript is a big improvement over ES5. You get vastly superior tooling and the type annotations are very helpful. Unfortunately, it lacks some of ES6's features like `let` and `const`. It does, however, interact seamlessly with JavaScript, which is a huge plus if that kind of thing is important to you. Personally, I prefer Dart. The syntax looks (subjectively) nicer, it got straightforward semantics, and since it isn't a superset of JavaScript, it didn't had to copy its quirks. Anyhow, if I had to chose between ES5 and TS, I'd of course go with TS. The decision between ES6 and TS wouldn't be that easy, however. I really like block scope and constants.
Thanks for your submission! Unfortunately, it appears as though it doesn't meet our [guidelines for self-promotion](http://www.reddit.com/r/javascript/wiki/index) and has been removed. If you would like to resubmit, please take the guidelines into consideration. Thanks for your understanding.
Microsoft intends to track ES6 as it finalizes so let and const should appear in TS some time in the future. 
You need a spider to crawl through the site and extract what you need. http://www.example-code.com/csharp/spider.asp This might be a bit old but the idea is the same.
Yea, I'm aware of that. Anyhow, ES6¹ and Dart support that stuff today. [¹ Traceur currently generates try/catch blocks for that. It's prohibitively slow.]
If the data on the page is rendered via js, you'll need to render it somehow first before you can pull out the data. You might find https://github.com/lukekarrys/spa-crawler useful, at least as an example. There, phantomjs is used to render the page and then the page can be scraped. If you want to build this in node and are familiar with the jquery syntax, cheerio is a useful module to check out. If the page is served up with the data you need without needing js to render it, this becomes much easier, and the request module and cheerio module will get you very far. This library looks quite promising as well: https://github.com/ruipgil/scraperjs
People using Node *are* using javascript... I was more referring to npm, which is making some big changes in the way people write, distribute and re-use JS libs. ;) And node compatibility is always a +1 for any JS library. 
d3 is great, but a higher level library for charts specifically will likely get you results faster. Dimple, flot and c3 all look like decent choices, and their APIs are pretty easy. Highcharts is a good choice too it seems, but not free for commercial use (maybe you don't care though).
It will probably be a long time before most devs can use this stuff natively (i.e. without transpiling to ES3). My group, however, intends to drop non-ES6 browsers by EOY 2015. That's six months after formal ratification by ECMA (and iOS 9's release, which should, by all rights, be fully conformant).
You can't go wron with Zakas. 
I don't know about the specific case in question and i don't really want to investigate it, but my qualified guess is this is a result of them implementing their own links without inheriting from the default link object. This usually happens because a developer wants custom functionality for some case and it can sometimes seem easier to just inherit from the most basic element and build your own custom element on top of that. This has the downside that the basic elements often have a lot of behavior associated with them the developer might not know about, sometimes it may be browser specific, and in general its very easy to miss something when taking this approach, which is why its recommended developers don't use this method and instead inherit from the default objects that most closely resemble the desired behavior. Unfortunately it is very easy for new developers to fall into this trap of creating your own elements basically from scratch, since it can sometimes be difficult to overwrite certain behavior and nobody wants to read the manual on how to do it. This is also rarely something developers feel the negative effects of since they are likely never to use or have used accessibility tools like screen readers, which depend on a lot of the features from the default web objects. If you really want them to fix it submit a bug report or send them a mail about it, they might fix it. TLDR: developers try to jump over where the wicket seems lower, and inadvertently destroy functionality and never realize.
Cool, thanks.
It really should be what do you want to write on. 
When you call geocoder.geocode, the function you are passing in as a parameter is executed asynchronously. This is normal and expected. If you want to have the ajax call always execute after the anonymous function in the geocoder.geocode call, you are going to have to explicitly setup your code to do so. There are several ways to do so - events, pub/sub, promises, and just restructuring your code so that the ajax call is inside the anonymous geocoder.geocode function parameter.
Better to use constants/keys so typos fail hard.
Thanks. 
Did the magnet input get registered by your Nexus 4 consistently? I need to get a phone for demo purposes and figure the 4 would be less expensive than the 5 to buy used. It works great on the Nexus 5 although someone does need to come up with a more universal input mechanism. 
Perfect. Thanks!
I like how require makes it to where your real JS is an attribute instead of a URL. However, most people that would want to reverse-engineer my app would probably know how to snoop through require.js anyway. I just like that extra hidden component of not having a "js" file in the source that exposes everything right away. Lazy loading is not what I had in mind because I don't care if everything loads on every page.. the code is light enough to handle it. I just want the code to be very difficult to steal.
I actually just built an app that does this. I used a success callback to get around the synchronicity of the ajax call, so: $.ajax({ type: 'POST', url: '/your/url/here/', dataType: 'json', success: function(e){ // All that good stuff that needs to happen // after a successful ajax call. } });
Well, the first one is not correct. `setTimeout` expects a function. Try this: for (var i = 0; i &lt; 3; ++i ) { var msg = txt[i]; setTimeout((function (foobar) { console.log(foobar); })(txt[i]), 999999999999); } You're executing the function and passing `undefined` to `setTimeout`, so the `999999999999` tiemout won't do anything; you're basically doing this: for (var i = 0; i &lt; 3; ++i ) { var msg = txt[i]; (function (foobar) { console.log(foobar); })(txt[i]) } Which is just: for (var i = 0; i &lt; 3; ++i ) { console.log(txt[i]); } Now, your second example is correct, and it will work. But it is unnecesary, as you can simply use `forEach`, and avoid this problem altogether: // print a letter every second txt.forEach(function(x, i) { setTimeout(function() { console.log(x); }, 1000*i); });
thanks for this. it's non-commercial. I looked at Dimple (which also seems awesome) but I'll check out flot and c3. thanks!
Using success doesn't 'get round' the problem at all. you simply resolve it in one valid way.
Looks a bit overly complicated, how about this: var title = function(str) { var articles = [ 'i ','l\'','il ','lo ','la ','gli ','le ', 'un ','un\'','uno ','una ','a ','an ','the ' ] var re = RegExp('^('+ articles.join('|') +')(.+)', 'i') return str.replace(re, '$2, $1').trim() } title('The Lord of The Rings') //=&gt; Lord of The Rings, The title('Il Barbiere Di Siviglia') //=&gt; Barbiere Di Siviglia, Il title('Woah Dude Awesome Title!') //=&gt; Woah Dude Awesome Title! 
I haven't tested that yet, so far I've only played with browser-based Cardboard experiments.
With all due respect, but wouldn't this be better solved using a function, extending it's prototype for instance methods/properties and adding properties to the function object for static methods? That solution looks like a lot of artificial overhead for a problem that's been solved before - or am I missing something? 
[Look Ma, no JavaScript!](http://jsfiddle.net/rc7c2fgd/) This should work in everything but IE8 (which will still display the content on hover, albeit with no sliding). 
TL;DR: If you want to protect your code, don't use JavaScript in the browser. If obfuscation is your goal, you're in for a rough time. While obfuscating code may mitigate some plagarism / copy theft of your source code, there's plenty of ways to un-minify code- the chrome source code view in the dev tools even has an option to beautify code. It won't change variable names, but it'll break code into multiple lines and add indentation. AngularJS complicates your efforts, because anything that goes into the DI system (directives, controllers, services, etc) all have to have strings as IDs, which means that even when the code is minified, the actual names will remain their original human readable format. There are plenty of good reasons to minify your code. Preventing people from snooping around the source is not one of them. Put a license on your code and move what ACTUALLY needs to be protected to the server; beyond that, there's not much you can do.
You may want to take a look at [terrific.js](http://www.terrifically.org). There's not many tutorials out there for it, but the documentation is good and it's meant for this exact kind of problem.
These are all topics I'd be happy to write on. What I'm trying to do is find a subject that serves the most readers out there. That said, I have a personal goal of being able to live off passive income so that I can devote more of my time to open source and personal programming projects so I'm trying to gear myself to a subject I could make a living off of.
You may also look at the network traffic that is going on when you visit that site. Chances are it requests data ftom their api, and you might be able to do some calls of your own on it.
If I were tasked with this problem I would go about it one of two ways: have an offline ajax page, or a client application. They would both have the same functionality of accepting data locally and posting it to your web service when it's available, but you'll have to decide which you're comfortable with.
Also, I hope you aren't giving clients direct access to your SQL server.
node is actually REALLY GOOD for restful apis. 1. node's event loop really optomizes performance around io bound tasks. ie: retrieve data from database, send data to user. 2. the tooling is top notch. express 4 has a router that makes it really easy to create nestable routers for different resources. If you need a more wholesale solution, there's loopback which is built on top of express and brings an acl and orm for interacting with your database. 3. great libraries for working with jwts which in my opinion, are the future when it comes to authentication. 4. its javascript, there are plenty of developers and growing. Lastly, if you're worried about scaling; Unless you're doing something really cpu bound like image processing, there are a few third party hosting providers that automate scaling out. heroku and nodejitsu come to my immediate thinking. They automatically create process pools and load balance your requests. If you are just doing rest with http calls and no websocket/persistence tcp connections, scaling will be pretty automatic. (to a point, but we're talking millions of requests per second. Those are good problems to have and you'll have proven the business case enough to bring on a consultant to help you from there.) 
Surprisingly a solid path for learning vanilla js and no jquery.
He specifically advises against node for beginners. Is this necessary? Aren't we at a place where young developers can realistically come up with JavaScript outside of the browser?
Your post seems (partially) critical of Angular because it's a google product. So is Polymer :-P
It is? Aw damn did anyone other than google make something directivey?
Mozilla has a custom elements wrapper called x-tags. Or you can ditch Polymer and just use custom element polyfills (that's how I roll, I don't get much value from Polymer's sugar).
Actually I don't even use Polymer to be honest. I just noticed that people tend to praise angular for two reasons: 1. You can type in an input box and it shows up where you type in some other div. 2. Directives. Obviously fuck typing in an input box and it shows up somewhere else. Woop-dee-doo. But directives---ya see---directives are cool but it's not like angular invented it.
I agree, especially with something like Meteor. 
Not everyone who wants to bite the bullet and learn JavaScript is a beginner. I know a few programmers who are solid engineers on the backend who think writing JavaScript is some magical talent best left to wizards until they finally "bite the bullet" and pull the curtain back. It's not magic, and it's fun.
I think he means learning js without incorporating jquery, which is a common approach. In fact, [s]he's emphasizing your point that learning javascript should be separate from learning various abstractions to the DOM api. Also, could you try to speak to other people like you would speak to other human beings? 
So what you want are Web Components (directives) and bi-directional binding ("typing in an input box and shows somewhere else"). Besides those angular also gives you a module system (factories, services and so on), dependency injection (good ol' DI), scopes (execution contexts) and some useful services (like $http and $route). I don't like angular much, either, but I know it would be way worse if I went without it for some projects.
There is plenty about JavaScript that is fancy. First and foremost the number of devices in and out of production that ship with an interpreter.
read the spec and write a javascript implementation in javascript. see you in a few years
Yeah, it's got a project threshold where it's overkill, and then suddenly it's exactly appropriate.
I would squeeze [Javascript Patterns](http://shop.oreilly.com/product/9780596806767.do) in there before the Ninja book, though both books are solid gold and belong on anyone's shelf.
John Resigs earlier book was good too.
JavaScript enjoys a unique position as a language because it is so ubiquitous. It runs on virtually all web browsers, and this includes phones and tablets as well. It's also the only language that runs on all three mobile operating systems: iOS, Android and Windows. It's also used by Node, one of the most popular web servers. Finally it's used by databases like MongoDB. The wide usage base alone is a reason to learn JavaScript. Now, the fancy parts. It uses one of the simplest data formats: JSON. This format is a mixture of {"key": value} and ["arrays", "like this"]. JSON mimics the object and array literal notations in JavaScript, which is elegant and simple. Functions create their own nested scope. Functions can also return objects when using the 'new' keyword. Objects have a property 'prototype' which is a way to accomplish inheritance. However this is out of the way unlike Java or C++ where classes and inheritance are required to accomplish much of anything in the language. Also because you can reference closures you can do things like [currying](https://medium.com/@kbrainwave/currying-in-javascript-ce6da2d324fe), which is really elegant. To end on a funny note, this a good lampooning some strange parts of JavaScript: https://www.destroyallsoftware.com/talks/wat Edit: Thanks for the gold, kind stranger :-)
You're just the misunderstood gadfly
What you want is a DOM Mutation Observer.
Alright thanks, that seems like exactly what I need.
I think you forgot one of the best parts: first class functions! Though, you kind of touched on it with currying.
What about testability and dependency injection?
I started with mostly backend experience when I did something similar using angularjs, and I find it very useful. The two-way data-binding appears like magic at first, but the principles are quite simple and I recommend reading up so you understand the concepts before using it to something serious. Angular is designed to live for the lifetime of the application (this is a nice way to say that it lacks (as far as I know) functionality to release its own resources), so I decided to put it high up in the DOM tree where I knew it would live forever. I started by putting routing and view logic under angular control, then moved on to refactoring the most complicated views to get control over those. I still use jQuery to manage some parts lower down in the DOM tree, and I don't mix any angularjs stuff into those parts.
Shouldn't we include Functional Javascript?
I'm not sure I agree with the author about this either. Well, I think one of JS's main strengths as a beginner language is that the programmer can almost immediately create visual, interactive output. It's probably why Khan Academy uses Processing.js to teach programming. Trying to learn node right away puts JS head-to-head with every other programming language (this is how you open a file, this is how you print to the console, etc). Not that this is a bad thing, but it removes JS's key advantage.
I think this post is mostly shit.
Much better. You can improve it a little by moving the regex outside the function: var articles = [ 'i ','l\'','il ','lo ','la ','gli ','le ', 'un ','un\'','uno ','una ','a ','an ','the ' ] var re = RegExp('^('+ articles.join('|') +')(.+)', 'i') var title = function(str) { return str.replace(re, '$2, $1').trim(); } Also worth noting is that string.trim is not available in IE &lt;= 8. 
Have you had any progress on this? I'd love to be able to run this over an entire node.js project instead of on a single file.
I definitely see your point. The polyfill originally began as a side-project to https://github.com/mortzdk/jsCache/. As I am in the makings of v2.0 of that library as well, I figured that this one deserved a rewrite as well. As the different mechanisms is available in the global scope, you could also use this polyfill to have more than one way to save data persistenly. This would be helpful if you were to track you visitors uniquely.. 
Thank you to you both! It's much better now. I knew that my version was too complicated. 
That was reqlly funny. Nannannnanna Batman!
Tabs lets the developer decide how wide the indentation should be. Some prefer 2 spaces wide indentations others prefer 4, my preferences vary after which computer I'm working on. Smaller screens makes shorter indentation preferable. But that's only a preference, it's far more important that the project source code is consistent in it's indentation style. My current job we use spaces and I'm fine with that.
You wrote both examples above with IIFE ( http://benalman.com/news/2010/11/immediately-invoked-function-expression/ ) so this functions will newer be invoked in setTimeout as you run them already. 
Not trying to be nitpicky, but JavaScript doesn't use JSON, because JSON is JavaScript, as it is the JavaScript Object Notation. EDIT: yeah I was a bit lazy. what I wanted to say is that JSON was 'based' on JS in contrast to the idea that there was JSON as a data-exchange-format and then they decided to use it in JS. I didn't mean to say that JSON is a subset of JS, my bad.
Interesting! I did not know this. Thank you. A very good thing to know.
I think I got the highest Game Over score.
Perhaps change the way you think about writing games if you wish to use JS? As a language it is extremely efficient at maximising available resources but at the end of the day it is designed to run in a constrained wrapper. 
I don't believe it was 'hating' on jQuery but more as a guideline to first learn the basics before working with higher level layers. Edit: word
Yeah I agree with that. But I think the two game engines I mentioned just use Emscripten to port their games. And thus can't utilize many of the "by hand" optimizations that you could do when writing JS. That's at least my assumption since the Epic Castle demo was 82MB large and I have heard rumors (I don't have a source) that even the smallest games are going to need around 32mb space for the engine ports. Perhaps I should add an exaggeration to what I wrote? Something like "I don't want Crysis 3 running on the web"
I'm sorry, but this is just downright bad: &lt;iframe src="http://free-tools.in/free-tools/Gadgets/DigitalClock" height="70" width="260" frameborder="0" scrolling="no"&gt; &lt;/iframe&gt; And to make matters worse, the "script" includes Google Analytics code. 
Claiming that deciding to learn vanilla js is hating on jquery is like claiming that deciding to learn how to implement string operations in c++ is hating on the STL.
hey... you should check out www.devnexus.com in March next year
I still like this better: var extend = function(A, B) { var sur = function() {}; sur.prototype = A; B.prototype = new sur(); B.prototype.constructor = B; return B; }; var ClassA = function() {}; ClassA.prototype.print = function() {}; var ClassB = function() {}; extend(ClassA, ClassB); (new ClassB()).print() 
I think your examples are overly complicated to address the issue you are interested in. Here's a simplified version: http://jsfiddle.net/onbL1ckv/8/ In example A, the anonymous function passed into setTimeout has a closure over the variable i, but closures are by reference and not by value. The loop finishes before those functions are called and so the value of i has now changed to 3 by the time those functions are called, therefore it spits out 3 three times. In example B, an Immediately Invoked Function Expression (iife) is used to capture the value of i during the for loop. The function returned from that iife has a closure over the parameter j. Since the iife is called each time through the loop, j is a new parameter with a new value each time. This will spit out 0, 1, 2. Example C works the same as example B, but it uses the bind method (which returns a function), to specify the parameters to use (and "this" which is passed as null).
Thanks - that's very helpful.
Maybe this will help you: * https://stackoverflow.com/questions/13760805/how-to-take-a-snapshot-of-html5-javascript-based-video-player * https://stackoverflow.com/questions/6066111/compare-two-images-in-javascript * https://huddle.github.io/Resemble.js/ * https://tcorral.github.io/IM.js/ I have no experience in this at all, but please feel free to make a blog about your "journey" :)
Have a look at this http://webrtchacks.com/baby-motion-detector/ . Same concept as what you want.
You could try something like this: https://github.com/ReallyGood/js-motion-detection Divide your screen into a grid of boxes and add a border to the box where movement is detected in.
i can confirm it's fun :)
I would imagine that some type of lazy loading would be involved and, until larger caches are available, a lot of attention will need to be paid to cache management. There are already performance workarounds across the internet as its commonplace to have multiple sub domains pointing to the same data so it's loaded concurrently vs sequentially.
I'm so green when it comes to js I have no idea how I'd go about doing any of that, let alone which I'd be more comfortable with. :\^\
Whether it's a library or plain alert, a modal notice is disruptive. It steals control from the other elements on the page, demands the user's full attention (often unnecessarily), and must be dismissed before the user can attempt to respond (often requiring the user to *remember* what it said). There are very few situations in which an alert is the ideal user experience; it's almost always used out of laziness.
* Prevents user from switching to other tabs / using other features in their browser * If you are on another tab in your browser - and a page does an alert, it pulls focus back to that tab * The look/feel of the default alert/prompt/confirm boxes often do not fit within the overall look &amp; feel of the website 
Just tested it out in Chrome - and alerts pushed the focus back to the tab that caused it. 
yeah I was a bit lazy. what I wanted to say is that JSON was 'based' on JS in contrast to the idea that there was JSON as a data-exchange-format and then they decided to use it in JS. I didn't mean to say that JSON is a subset of JS, my bad.
Mh?
That's not learning JavaScript though, that's learning an opinionated framework/platform.
Thanks for your comment! Well, in my opinion using the prototype mechanism of JavaScript is not very intuitive - although it is a useful feature. And I think using the prototype brings up a big problem for complex objects: Correct me if I'm wrong, but when using the prototype to extend an existing object, there is no way to define a private function, that can be used by more than one public function. If you define a (private) function within a public function added to the object by using the prototype, it is only visible inside this public function. And this may cause massive code duplications in complex objects. Do you know, what I mean?
I think the fact that AngularJS and Backbone don't need to be used as single page application frameworks is undersold, especially Angular since it uses the available content (the markup) to define the application structure, rather than the other way around. This is really handy if your work involves a mix of SPAs and others, for example working with CMSs. It's been awhile since I've looked into it, though from what I've heard trying to make Ember work in a non-single-page application context is pretty painful.
No, it works for any modules that browserify can import
Most popular seem to be SublimeText and WebStorm. Subblime is just a code editor but with many plugins, while WebStorm is a fat IDE with a shitload of features built-in (and also plugins). Where do you run the JS? In a browsers or in Node.js? Node runs as a CLI command so is very nice if you just want to run some bare code: most IDE's have a embedded terminal or output window, so you could use/configure your IDE to run your code in there. For browsers you could look into a LiveReload plugin if you must have one-click reload. Otherwise just [save], [alt-tab], [reload] by hand.
&gt; I just want something basic I just type into and hit run and I get to see what I've just done in action The easiest way to try JavaScript is to use an online editor, such as [jsFiddle](http://jsfiddle.net/) or [JSBin](http://jsbin.com/). You can also run JavaScript with [NodeJS](http://nodejs.org/), without a browser. Once you have installed it, edit your files in your favorite text editor, then save it and run it from the terminal: node file.js In Vim (and other editors I suppose) you don't even need to save the file, you can just run the current buffer through Node with: :w !node
If you are looking for an IDE webstorm is currently the best paid $50 option and Aptana is the best free option. You do not sound like you are looking for an IDE. You are probably really looking for [chrome dev tools](https://developer.chrome.com/devtools). Chrome dev tools are hidden inside of chrome and will give you control over the javascript execution. Javascript is not like most other languages where you debug inside of your IDE. I have never encountered a good way to execute javascript inside of an IDE. You use your IDE to write your code and you use a browser to execute and debug.
As both a JavaScript and ActionScript veteran I like it a lot, and it works great with existing JavaScript libraries (like from npm or bower). I'm sure you are aware of [DefinitelyTyped](https://github.com/borisyankov/DefinitelyTyped)? It is a community drives repository for typings for regular JS libraries, so you can use AngularJS, JQuery and over 600 other popular libraries with compile-time type checking. See you at /r/typescript :) 
It's a bit backwards maybe, but you could abstract your notifications to a worker task, which should at least fix the blocking issue. Though sometimes (very, very rarely) having the ability to halt execution until the user restarts it can be useful.
Funny that, because C# is also a strong influence for TypeScript. It's the same language designer at the wheel, and I heard it being said that one of their goals is to make JS more approachable for C# style programmers.
I'm very curious how TypeScript syntax can make you crazy if you have a strong Vanilla JS and Java background. It is the same curly-brace stuff, same lamda's, same everything except the post-fixed types (which they took from like ActionScript, another very successful JS upgrade language).
If it is so ugly to rebuild they'd definitely should publish a working package. Apparently this guy never heard of npm or bower.
not if you're not comfortable in python, as OP posted in /r/javascript
with for example [cheerio](https://www.npmjs.org/package/cheerio) to query the DOM. of course this only works for the original html text, it won't actually run the webpage like phantomJS does.
Keep in mind AngularJS became popular thanks to Google. This does not mean it's a great framework and also doesn't mean its bad (but that is totally why it got popular). Here are a few things I think this article should have touched on. 0. Why are there no performance metrics? For client-side applications this is the most important thing to focus on. Angular may be great for fast prototyping and copy/paste but how does that scale? 1. AngularJS has the same issues as Prototype.js. I don't want to duplicate business logic in the html and in the javascript. (Why was jquery made again?) 2. The ng- name space breaks html validation and as a result breaks older accessibility applications. (why was this even a thought for the default be ng- vs data-ng-blah=). I know you can change this but by default its like that and all the examples use this method. 3. This article says it works well for large scale applications. Really? I have seen first hand the performance issues with memory leaks and the module system does not allow for lazy loading. I.E sending a huge javascript file means you evaluate that whole file at runtime which means more space is needed on the heap. BAD. 4. Angular is a framework.. not a library. I got past the framework thing awhile ago since there are so many options for different routers, template engines, data binders.. etc. Why limit yourself? Plug-&amp;-Play with backbone allows for extreme flexibility. Remember the metrics back in the day of how many people could write rails applications but didn't know how to write a ruby lib or proper ruby code. This rings a bell for me. 5. The article didn't touch on the performance work that has went into backbone to make it scale (http://marionettejs.com/) or the theory behind ember coming from sproutecore. 6. Are there any large google client-side application built with Angular? All I can find is small mobile applications or google chrome apps and imho.. that is a good use-case for angular. I can dig that. What about backbone? http://backbonejs.org/#examples epic amounts. Anyway, Just a few thoughts. *edit forgot to add the issue with parallelism. With a larger team working on the design/markup and frontend business logic in tandem is a great way to speed up the process. In my experience with trying to scale Angular in that way it was a nightmare but this really depends on the team I guess.
Dart is a bit closer to C# than TypeScript is though. Dart's syntax is closer, it also got block scope, and `this` is lexically scoped, too. If you know C#, you can be productive with Dart on your very first day. If you need Dart developers, you can just get C# developers. That's how similar those languages are. TypeScript isn't as straightforward because JavaScript is full of surprises. Well, you can of course just read *JavaScript: The Good Parts* and be almost done with it, but it isn't quite the drop-in solution Dart is. You still have to know about all those quirks and how to avoid them. That said, TypeScript's JS integration is much tighter. They went for this set of trade-offs for this very reason. That's also a perfectly valid strategy, no doubt. It just doesn't align with my own priorities. I don't have any JS code I want to keep around. Anyhow, just having classes and decent tooling does indeed make it a whole lot more approachable.
&gt;especially Angular since it uses the available content (the markup) to define the application structure sorry, I'm kind of an ng-noob, can you explain to me what you mean by this? thanks
I'll take a stab at it. Ember and most other frameworks rely on JavaScript code to determine the application architecture. Things like Routes and templates are all predefined; to use any of them in a multi-page application typically requires figure out loading different code for different pages. Angular flips that on its head (for the sake of simplicity, let's ignore the router for now). Angular doesn't have an entry point that says this controller and this view should run using the DOM element with such-and-such an ID. It parses the DOM, and lets the DOM define the architecture of the application- which controllers and directives should be on the page, the nature of the $scope hierarchy and so on. This makes working with mutli-page applications much easier. It's even better for CMSs- backend frameworks like rails and symfony at least have an MVC structure that let you define per-page applications; CMSs essentially allow users to arbitrarily define how much and what content might appear on any given page. Because Angular scaffolds the application based on what content is available, rather than what content is assumed to be present, it's a better solution by far than Ember for these types of applications. Backbone can be made to work like this too, but you'd have to hand-roll the whole scaffolding bit. Basically, it's like comparing Flex to raw AS3 (if you know flash), or a very broad implementation of Inversion of Control if design patterns are more your thing.
Word, but that also comes with a performance cost. (i.e nosql structureless vs structured/defined). However, with backbone you can do all of that as well.. the only difference is... you also have the option to not do that.
Before the 'not another package manager' circle jerk flamefest appears, and the Dark Lord of Unix /u/substack comes to lecture on the misgivings of relying on GitHub for everything, let's all just agree to give it five minutes and try it eh?
ah I get it now, thanks
I just asked around on their IRC channel and they do support other servers such as Bitbucket or private Git repos.
The performance metrics would be nice, but you have to believe the community behind a given library or framework will improve all of the little issues that sprout up over time. The fact that ember and backbone are both on a downward trend vs angular which is shooting up should give you hope for angular to have more people working out the issues. I'm not sure what issues you're referring to with the prototype.js comparison. Prototype.js was always trashed because it extended the native objects and (in some cases) broke expected behaviors. As far as Marionettejs, this is totally unrelated to the backbone core work. If you want to talk about all of the things built around backbone to make it more of a framework than library, you'd have to list about a dozen others in there. It's beyond the scope of that article. One of the examples on the backbone site is USA Today, which uses an in-house framework on top of backbone (similar to marionette, really). I'd hardly say that's a backbone thing. There was a ton of code written on top of it to make it work as it does. If you stripped it down to pure backbone and what you can do out of the box, it's not very much.
1. Its gaining popularity because of google vs just being a better, more performant way of writing client-side applications. Much like the popularity rails got over php (although php sucked hardcore).. guess what.. rails is awful from a design perspective and regarding server-side scalability. Its very hard to fix frameworks and changing anything will become a nightmare in the future once it's adopted. 2. Prototype was intrusive javascript. I.E business logic was deeply coupled with markup and design. 3. My point with Marionettejs was the work done to remove as many memory leak issues with backbone as possible. I wouldn't even consider Marionettejs an attempt to make backbone a framework.. just stuff mostly extracted out of wallmarts mobile backbone application and the problems they had scaling it. 4. Backbone is a lib.. not a framework.. there will also be code written to make it work. ? what do you mean? * Note, these as mostly engineering concerns.. if you are just doing one of apps.. or stuff for fun or SPA.. angular is great.. not trying to put it down.
Spot on. I always like to stay away from dependency. Not saying that Ember doesn't have it's place (think htmlbars should be out already) but easily building on top of current technology is what most devs target for long term. 
&gt; Angular may be great for fast prototyping and copy/paste but how does that scale I use it on a very large single page application that loads in tens of thousands of data points. The only place that Angular isn't used for rendering is the WebGL portion (a small portion of the application); everywhere else, it performs quite well. In fact, it works better than the original backbone version of the application because dirty-checking models is so much better than naive re-rendering based on events triggered by changes to models. Sure, maybe something like React could do better, but I'm extremely happy with my decision to use Angular.
&gt; i.e nosql structureless vs structured/defined The only performance cost is parsing the DOM at startup. That **still** happens with an imperative application, especially backbone where (most frequently) jQuery is used to parse the DOM to look for the elements needed to generate Views. In my experience, there are several ways in which Angular applications can perform much better than Backbone. The tradeoff is that Angular uses quite a bit more memory than Backbone does (due to the dirty checking mechanism) but the total memory usage has never been a problem for me (see a description of my project in your other comment thread below).
Sublime can be made into an IDE too. Just need to hook it up to a compiler. 
Huh? when the javascript engine loads javascript into memory.. it will evaluate it and store it. Angular some how compresses it completely to be negligible..? or are you just saying words?
Is the save state saving locally or to a remote destination? If remote, could this utilize an incremental saving/loading mechanism? If the data structure is too large to reasonably send and/or it isn't feasible to break the structure into multiple requests, maybe something like oboejs or another SSE driven model could work? Maybe I don't understand the question?
Try Atom: Looks just like Sublime, works very similar to Sublime but it's running on Webkit. Hit Cmd+Shift+I and you get a JS console. 
If you are loading in tens of thousands of data points at the same time and you don't see anything wrong with that.. then i'm afraid its not worth arguing performance with you. Hopefully you mean a json request with just numbers passed directly to a graph or something.
https://github.com/component/component/issues/594 An interesting discussion on this has been going on on component/component for a while.
Enter [Gulp](http://gulpjs.com/).
Thanks for the submission, but can you please add some details? A gif alone is not a suitable post, as it gives no supporting information. I've temporarily removed this post but will reinstate it if you can provide additional information about the project. Thank you for your consideration.
I just went through like 20 pages there.. and the only site I saw that could be considered large was msnbc. Looking at the source I don't even see where angular is being used.. but.. regarding performance.. AWESOME. http://cl.ly/image/2k0Z300u313H &lt;-- thats embarrassing for a few images and text.
I'm gonna be *that guy* and say that Emacs is pretty fucking sweet. 
That image is completely unreadable.
One note.. Webgl depends on the browers.. but more so the hardware and graphic/gpu. How many nodes?
You can zoom-in. In Chrome, for example, it's built-in functionality.
Hahahah. 
Just a side note that chrome store apps will soon (already do?) have unlimited storage if allowed by the user. I expect that to become the norm for indexed db stores on all platforms in the next couple of years. Also I think the limit you are talking about is local storage? The most constrained browser for this is currently safari and the websql limit there (will not support idb until ios8) is 50 mb. I don't believe apple has announced what the idb limit will be in ios8 but I wouldn't be surprised if unlimited is available once we have a use able quota querying api. 
Seems like quite a good tutorial, thanks for that. I've been struggling to understand just what's so great about Angular for a while now, but from what i've read of the beginning of it it looks to be written in a way i might continue reading it.
Package manager is bit generous it's more of a build system 
I use and love Ember.js, but anyone trying to do something other than a single-page application with Ember would be making a mistake. That is not what Ember is good for. That said, Ember is incredible for single-page applications. Since Ember interprets state based on the URL, it may seem as if the application is a multi-page application. It is nice being able to reload a URL and not be taken back to the starting point. Also since the URL is relevant in Ember, I would assume that this would help Ember's SEO.
500-1000 (I used the graph structure 'vertex' to mean node). It's not 60fps (yet) but there's plenty of room for improvement in my code. The node count isn't the limiting factor on performance; it's the 10k-40k edges (links between nodes).
&gt; It does it you're an engineer.. using whats hipster is not a good way to design a project. Angular's core team are all engineers. Things like Services, Dependency Injection and transclusion are all terms you'll rarely find outside of a software engineer context. The fact that it was made with automated (especially unit) testing in mind is a good sign that Angular isn't the hipster devstack of the month. Just a thought. Also, there are a few talk from the ng-conf on youtube regarding some of the very large client-side applications written in Angular, though I found them to be less interesting than the more narrowly focused ones myself.
Found it: https://www.youtube.com/watch?v=62RvRQuMVyg The DoubleClick Campaign Manager was built on Angular.
Hm, but when I hover the post title, the link is http://i1383.photobucket.com/albums/ah307/rgtbctltpx/js-notification-libraries_zpsd8d178be.png~original, which is the real full size image. By the way, what is CSI?
I assume you're talking about shift+enter in the console command line. If you use the editor on the sources tab, plain old enter is a new line.
This is great! I'm going to try to play around with this at the next opportunity. It really is a shame that someone didn't do this before now. 
True, but does it execute immediately without having to create new file or workspace?
What does this even mean? That node is the only way?
What I like about Angular is that you don't have to use it for everything. It's got just what you need to make the majority of your site, but if you really are concerned about performance in a particular component, it's very easy to step back and create something non-Angular. Angular won't mind. 
So, for me the biggest issue is $scope vs this... Which is the "best way"? When I first dove in with codeschool's intro they used this, but most of what I've seen online uses $scope
I'm still learning Javascript and Node.js, would you mind giving a brief overview of the packages you use in place of these frameworks?
You can do stuff like that with objects. var foo = {}; foo.x = 5; foo['x'] = 5; // same as above console.log(foo.x); console.log(foo['x']); // same as above There wouldn't be any point in programmatically naming some variable since that name wouldn't be visible from the outside. They are confined to the innermost function they were declared in. You can't pass them around or anything.
Do I take it after a year of BB and a year of NG, you recommend NG over BB?
Yes! PR welcome to support ['Dep', function (Dep) {}] style :) 
It can only go up!
Please let me know how it works!
Keep in mind that at any given time, I can swap out these packages for other packages with little or zero refactoring: 1. **Task Management:** Gulp + many plugins for every type of build task 2. **Packaging:** Webpack 3. **Testing:** Karma + Mocha.js + Should.js + Sinon.js 4. **Flow Control:** Async.js 5. **Event Management:** (rolled my own) 6. **Template rendering:** lodash.js templates 7. **AJAX:** xdomain.js polyfill 8. **Analytics:** segment.io 9. **Authentication:** oauth.io
There's no way to do that with variables directly. But, it looks like you're wanting to store/retrieve 3 different locations - you could do this using an array. You can define your array like so: var locations = []; And then you can set individual locations like this: locations[1] = 'some location'; And if you wanted to set a location chosen by a variable, you can do something like: var index = 2; locations[index] = 'whatever'; Using an array has the added advantage that you can store unlimited locations this way, and also it's easy to list your stored locations: for (var idx=0; idx&lt;locations.length; idx++) { console.log(locations[idx]); } 
Bah! Whitespace is overrated. We need something that warns about using loops and mutable state, when there's a simpler, more declarative approach to writing that function: var hashCode = function(str) { return [].reduce.call(str, accum, 0); function accum(hash, char) { return (hash &lt;&lt; 5) - hash + char.charCodeAt(0) |0; } };
Thanks, I'll be looking in to a few of these :)
Are you serious?
Since AngularJS uses templates in the HTML, which is where the design/markup occurs, your experience that "it was a nightmare" coupled with your concern for AngularJS' (a browser technology) scalability leads me to believe you know not a fucking thing of which you are speaking. The best way to work in parallel with a design team is to give them a marked-up HTML template and let them do what they gotta do to make it look good.
But how do you feel about Angular?
"Grunt will support existing 0.4.x plugins via optional adapter, and will also support Gulp and Broccoli plugins." - Mind Blown.
That would be more of a JSHint rule :)
Webpack is the truly amazing piece of tech, IMO. It's a "packager" which allows you to use Common.js modules in the browser exactly as you would in node.js This allows you to have a single-paradigm workflow for both the browser and server. In addition, because of the lite nature of these libs, when you package up, you can get your entire SPA into less than 100kb deliverable total. Imagine that your app is loaded and ready to go before the browser is done rendering. If you're doing test-driven development (you are testing your code... *aren't you?*), Karma will blow you away.
Could you please give some examples of: "routers, template engines, data binders" I need this website http://youmightnotneedangularjs.com/
Definitely picking up this philosophy. I can't marry my website to any specific framework if I can maximize on some of these libraries.
It's never a question of *whether or not* you will end up replacing a library. It's only a question of *when*. I wouldn't dream of using *any* library that I used 5 years ago, which is what my old monolithic framework choices forced me to do. I'm always looking for smaller, faster, and easier to work with alternatives.
I've been using Browserify on a recent project and have been blown away with how much it simplifies front-end dev work. Would you say that Webpack is substantially better than Browserify? You said you can swap out these packages with little refactoring. Is this facilitated through your custom event manager? If you have any example projects that you'd be willing to share I'd love to see how you are utilizing all these packages.
Glad to hear about this! I know Grunt isn't exactly a paradigm shift in coding, since there's been similar toolchains in other languages forever, but Grunt really did help usher in a new era of JS development IMO. It's not even a question now as to whether or not I'm going to have a build step.
You presentation link seems to be broken. 
Thanks for your submission! Unfortunately, it appears as though it doesn't meet our [guidelines for self-promotion](http://www.reddit.com/r/javascript/wiki/index) and has been removed. If you would like to resubmit, please take the guidelines into consideration. Thanks for your understanding.
Assuming you have return as one of the keywords in the config (which you are free to define to your liking) It will not force a new line in the first case because the return is the first statement in the block. It will force a new line above return in the second block though.
No problemo. I should have clarified in the post that you would configure it like this: "requirePaddingNewlinesBeforeKeywords": [ "if", "for", "return", "switch", "case", "break", "throw"] So you are completely free to select whichever keywords you think should have padding above them. However, your second use case brings up an interesting point. Do you think I should add a configuration for a minimum block size before the rule kicks in? This would allow you to say don't force any padding in code blocks of 3 or fewer lines.
Webpack is great. It's a little challenging to get started with it because the configuration can be complex, but it's worth it. The loader system is especially cool because you can bundle and transform ALL of your code and assets on the fly -- from compiling LESS/CoffeeScript, to wrapping legacy code with CommonJS (taking care of imports and dependencies). You can then have it split your code into chunks (dynamically loaded), optimize everything, run the dev server with hot code swapping, and so on. I'm not really doing it justice, so just go try it.
There are a few very specific things that we suffered under Backbone * While I originally loved the models and collections, the sync portion was useless because we don't have a RESTful API, and it was much easier to write our own * I eventually grew to dislike the models and collections as well. The most frequent performance problems were from the sheer volume of events that would get triggered on model changes, especially when related models caused cascading updates to views or other models * The problem with collections were especially egregious; there's an inherent cyclic reference between a model and the collection that it gets put into. This means that model can really only belong to one collection; if, for example, you wanted to create a collection that represents a filtered set from a master collection, you're out of luck; the best you can do is get an array of filtered data, and lose all of the nice built-in methods as well as your custom methods * To get around the fact that Angular does not provide models or collections, we wrote a very simple model concept (they should have no methods except to and from json) and a set of collection type classes loosely based on Backbones. They don't trigger events (a model triggering an event collection was BB's reason for the cyclic relationshiop) BUT with Angular's dirty-watching, that wasn't a problem. In the end, our model layer is much cleaner, we don't have to worry about zombie views, we get free dependency injection for unit testing, and we cut down the size of our code base by a pretty decent chunk. There are some things that I liked about Backbone, don't get me wrong. It was even my framework of choice for quite awhile. Having shaken off the 'this looks like obtrusive javascript' impression and getting over the learning curve was probably one of the best decisions that I've made for the project, and it's gotten me to think about how I write JS a bit differently as well.
Full disclosure: I don't use JSCS (haven't had a chance to try it yet), just throwing out some cases that might be contentious. If I were to use it, a minimum size would be nice I think.
Great list
yup
The best way: var yy = 2; var scope = {}; scope.location1 = "canada"; scope.location2 = "usa"; scope.location3 = "mexico"; console.log(scope["location" + yy]) The answer you're really looking for is eval(), but please, PLEASE don't. It's a bad idea. var x = "usa", yy = 2, location1 = "canada", location2 = "usa", location3 = "mexico"; if (x == eval("location" + yy)) { console.log("DONT DO THIS"); }
&gt; First of all, you need the actual $scope variable since it's a dependency injected module that allows you to tie a controller together with the view. Can you point me to where you've seen the usage of this? Google's own style guide for one http://google-styleguide.googlecode.com/svn/trunk/angularjs-google-style.html. 
This might get the work done for some projects but do any of these take care of routing and two way bindig or provide any other MVC like structure and logic without doing all of that hard work from scratch.
This was posted today: http://www.reddit.com/r/webdev/comments/2e8f1b/scraperjs_a_complete_and_versatile_web_scraper/
Off the top of my head: * Routers * Backbone Router * page.js * Director * Aviator * Template Engines * Mustache * Handlebars * Hogan * Dust * Data binders * Knockout * ractive * reactive * ripple * way * etc etc etc...
Scaling the (size of) front end application itself as opposed to scaling performance etc... 
http://gruntjs.com/plugins How I typically use it, roughly in order of operation: * run JSHint on custom Grunt config files * run JSHint on the code * compile HTML templates to JS * run CSS processing (LESS/SASS/etc.) * package all code (js, css, templates, static assets, etc.) into modules * minify modules (uglify js, mincss, images to sprites) * run unit tests * clean output dir * promote code from temp to output dir * run e2e tests If you wish to use any of the altjs flavors (Coffeescript, TypeScript, etc.) then you'd also add the step(s) for their compiler/transpiler where needed.
I didn't mean for that list to be comprehensive by any means. None of the libs I listed above do any of that by default, but there are individual libs for models, views, and controllers available from npm. I rarely roll my own. I did so a few times in this project in order to learn some more advanced patterns for future reference. It's generally a better idea to utilize somebody else's supported pattern, rather than inventing your own; with rare exceptions.
I find it interesting to see on slide 4 "To automate repetitive tasks in very small projects." because that has been my experience shopping around for a javascript/web oriented build tool for use with TypeScript and running unit tests etc. These tools like Grunt, gulp, etc, and even Jake seem to be limited to running tasks but don't really aim at being build tools proper. I keep on coming back to Make. It seems to be the only one which works with source files and dependencies and tries to effeciently convert them into the final output. i.e. by rebuilding only what is needed. That and the fact that I can easily add custom target and tasks to automate other things which I may need to do during development. Being able to invoke commands and tools directly without having to go through some plugin is also a big plus. The only draw back with Make is that it assumes a unix style environment, which may be a barrier for some people (thinking mostly about people using Windows). A JS based, cross platform Make style tool would be great. Does one exist? 
No, the best way is to avoid this kind of approach altogether. The OP is clearly a beginner, and instead of answering the question you should show to correct approach (which is to use arrays or maps).
I think you should try as many appraches as possible to see which one suits your needs, the needs of the application or the needs of the team. The last one being most important since I feel that if I rolled my own combo of the listed libraries and others keeping everyone in line with the workflow would be a nightmare. Angular is strict enough, but not too strict, about how it wants you to do things that delegating tasks and working in a team is very intuitive. My conclusion was that pretty much everything Angular has to offer we can make use of. I'm not sure about the performance argument since our app is already quite large and I've yet to see it prefrorm unsatisfactory on any system I've tested it on. You can write shitty underperforming app with any approach.
&gt;In my experience with trying to scale Angular in that way it was a nightmare but this really depends on the team I guess. Could you elaborate on that? How is it bad and how are other better in comparison? I've had the exact opposite experience.
Very cool... Off topic, why does stuff like this add history events to the browser... I opened it and scroll down and up a couple times, now I have over 250 history events in my browser.... Stop it!
1. If performance is your number one concern on every line of code that you write, it is certainly better to work at the lowest possible level without any frameworks. Low level programming let you shave off cpu cycles, although the user wont notice the difference once you get below a certain point. Angular can usually get you below that point, and it gives you the chance to hand optimise bottlenecks. Backbone doesn't give you any data binding mechanism, so it is more natural to hand optimise everything like you would do with plain javascript or jquery. 2. Why do you duplicate business logic? It doesn't make sense and there is no need for that. 3. You can decide to always prefix ng- with data-ng-blah=. They are equivalent and there is no default. 4. I have seen performance issues with memory leaks with backbone as well, and it is easier to get there since you have to keep track of everything yourself. It is possible to lazy load angular modules, but it is not taken care of by angular. Same as backbone in that respect. 5. Yup. Angular is a framework, backbone is a library. I would also prefer a library if I had to chose between two comparable technologies, but angular and backbone aren't really comparable.
This is great. I consider standardizing line spacing to be important for homogenization of a codebase, and this is the first viable solution for enforcement I've seen.
Every extra newline is an extra character that has to be typed, and an extra character that increases page loading time. Do we really have to use newlines? /sarcasm
Yeah, that redirects to [the tiny one](http://s1383.photobucket.com/user/rgtbctltpx/media/js-notification-libraries_zpsd8d178be.png.html)
Quite useful. But still too non-automated for my taste. I'd prefer a Yeoman generator for this.
That's not what scale means.
You're right that we must choose what's best for the project and team. Some things are real concerns, while others are not real. Workflow is one of those "not real" concerns when it comes to microlibs because there are numerous methods to keep a team on track autonomously, and it's the primary role of the team lead in the first place. An incompetent team lead will muck it up no matter what the framework. There's also the practice of wrapping 3rd party libs so that you can swap out the private functionality as much as you want without disturbing the outer API (which the team uses consistently). This method makes it effortless to switch between libs, and this affords us the ability to use any tool written in javascript, not just the ones that are compatible with our existing setup. Another primary advantage to picking your modules a la carte, is that there is no such thing as a "core team", any longer. There are dedicated teams to each individual library, and if you don't agree with a team, you have every option written in javascript for alternatives. Pull requests are dealt with faster and more objectively than in large core teams. Some people like that, some people don't. I only argue that there are more people in charge in the distributed system, than in a centralized one. Compatibility with virtually every javascript library ever written because of an absence of enforced workflows is useful every single day. You can get something to market extremely easy with 3rd party libs, then replace those libs with lite functions later, with zero refactoring on the application level. You can replace your entire authentication system with zero cost to either your team or man hours, and sometimes you really will do that. We did with oauth.io, and it was painless. Then, in the end your code is incredibly lite. Our entire (non-trivial) SPA is less than 100kb, complete with all templates, models, controllers, views, router, dependency injectors, and 3rd party dependencies. It's compacted all into a single file which gets downloaded and loaded into memory faster than the page can render it's simple interface. When something works, I agree that you should use it, but I also dedicate time every week to learning what's new so that I can get more done in less time. I now get more done with my team than if we used a monolithic framework, because everybody can be involved in the improvement of all parts of the application; not just the ones on the application layer.
So.... var a = 'myKey'; var foo = { myKey: 1 }; f.a // undefined??? Please show OP how to use variables as keys in objects! foo[a] === foo.myKey; // true foo[a] === 1; // true 
Thanks for the examples! I added my own "wrong" example too. I need to re-read the MDN article on bind now ^^
&gt;there are numerous methods to keep a team on track autonomously That's exactly why I wouldn't risk it. It disperses and amplifies the likelihood of people doing it wrong. No way you can be all over it as a team lead if the project is large to any degree and you let separate teams make such choices independently. Smaller projects I can understand. Newcomers also need to be taught your way of doing it instead of having people understand a tried and tested system already before joining the team. Too much flexibility here again increases the likelihood of bad code or practice entering the project. The rest really doesn't speak against using Angular at all. Having a build system compile everything into a single javascript file so it renders quickly is normal with any framework or choice of libraries so that's nothing special. I understand and agree with you to an extent but I've tried the approach you're talking about and am much more productive using a framework, as is my team. I'm also yet to see a downside of using it, truly. Anyway, it's great that it's working for you and I'm sure I'll revisit this in years to come to see if I might find a different way to be more productive as a result of a different approach to application development.
If you're looking for just time numbers for a single function or limited set of functions, consider using [JSPerf](http://jsperf.com) or its library equivalent, [BenchmarkJS](http://benchmarkjs.com). These are better for cases when you're doing timing comparisons for functions with calculations. CPU profilers in JavaScript, like the one in Chrome, are mainly meant to track what percentage of time a specific function is being called out of the many functions called in a specific time period. It's to help determine CPU-intensive functions that might be the bottleneck in your application. You usually use them by recording a period of time where your application is being interacted with, but it's meant to be used with applications calling lots of different functions or with libraries. Heap profilers in JavaScript track objects, and determine the number of objects created, the size of each object in memory, and the type of object. They're meant to be used snapshot-style, where you basically freeze a specific time and you can inspect all of the objects in the heap at that particular time. You can then take two snapshots at two different times and compare what objects grew a lot, or if there's any memory leaks. Hope this helps, and let me know if you have any other questions! 
You could replace data binders and template engines with React as well.
What's the license?
Thanks
Creative Commons Attribution (BY). I'll put in a disclaimer in the JS code. Would be fun to see the results of any further development, so ping me when you've put something together if you want to :)
It was a good idea to put it in, never built anything someone would actually fork before. Thanks. Fun hack. 
They never mention ember CLI. It's still in early development but it is really cool! It builds a Railsy folder structure and gives you a lot of build tools out of the box. Things like stylus, less, etc support, handlebars precompiling, and a testing suite. They mention Script tags in the markup. This is a naive approach, all ember shops I'm aware of use precompiled templates. Also, I'm surprised they didn't mention Ember can be hard to test. 
Hello, I am the author of Smithsonian. If you have any questions or would like to see some code examples, I am here for you. Smithsonian just hit version 2 and the biggest feature is that it now works as an attachable Express router. Before v2, it provided it own authentication and a lot of other features that distracted from handling Metalsmith. Now Smithsonian fits into any application and can be used just like any other middleware.
Issue \#590: rule should have been called putSomeFrigginNewlinesInYourSourceCode
No I'm suggesting that there shouldn't be a newline between the two, which this rule would seem to require. I'm suggesting that newlines inside functions should be used to break apart related statements, rather than just being arbitrarily inserted before certain control flow statements.
Pretend I said non-single page applications. I was describing the benefit of a declarative architecture for them and disagreeing with mephux that the nature of a declarative architecture is inherently less performant. Pretty sure I mean to say non-single page applications there.
A reddit post about increasing readability and you post a borrowed reduce call, hoisted function declaration, and bitwise operations on character code operations. /beautiful
Did you try using `--stack`? Hopefully that's all that needs to be enabled by default in most cases.
I'm fixated on the background photo. Why am I looking at an upside down forest?
https://developer.chrome.com/devtools/docs/cpu-profiling Everything JS does will show up on the profiler; however, profiling is as much a skill as it is a task. Some of the tools listed above are really only good for DOM interaction an memory analysis; if it's testing raw speed that you're looking for, consider utilizing console.time and console.timeEnd https://developer.mozilla.org/en-US/docs/Web/API/console.time One final note: JS engines like V8 may behave differently over time, as it is able to verify certain assumptions that it made originally about your code and create better optimized versions. Therefore, before you perf anything, make sure to run the test itself outside of the timer, then re-run the test with the timer turned on. This 'warm up' will ensure more accurate representations of how the code will actually perform.
I've all but switched over to gulp, but I see some exciting things on the horizon for grunt. Whenever either one innovates, we all win. The fact that these tools even feel necessary shows you how much pressure there is to be on the bleeding edge.
This is a pretty huge straw man, and did you really just use event delegation as a con?
FWIW, Gulp was released after we announced our [in-progress node-task specification](https://github.com/node-task/spec/wiki). That said, they arguably improved on it... and we didn't have to write it, either. So, everyone wins.
Take a look at Broccoli.
Excellent!
In the case of jQuery, yes, especially for these purposes because we no longer care about event handling. What we care about is setting up a front-end application with proper architecture that enables us to build larger and stronger applications. Make sense? Not much of a straw man, just a discussion on how the two libraries are used differently. **EDIT** Just to clarify, jQuery's event handling gets clunky when dealing with larger applications. AngularJS allows us to side-step event handling and deal with the front-end almost as if it was a back-end app.
so, is this like a random act of masturbation, or something?
For those that didn't get my point, what I'm saying is that we should worry less about style, and more about abstractions and the actual code. When I look at the code posted, it is not the whitespace that bothers me, I even prefer the first version with no whitespace. What calls my attention is the leaking `l` variable, extending the prototype, the unnecesary parentheses and extra semicolon, using `==` to compare to zero, and the use of imperative, hard to refactor code.
Short answer: because it's hard to do right, ie. be useful, without breaking existing code. That said, Brendan's Value Objects strawman includes some form of operator overloading for types you create.
Do you need to be online to build?
I think they're getting the release of ES6 specs as soon as possible. I didn't find anything on the oficial channels of the TC39 group but check [Brendan Eich's](http://www.slideshare.net/BrendanEich/value-objects2) slides.
Probably the same reason Java doesn't have operator overloads. Because some people are strongly opposed to it. Operator overloading can be useful, but its usefulness is somewhat limited to certain types of problems. I personally have never subscribed to the "Well, people could use it wrong!" arguement. I'm more on the side of "If it can be useful, why not?".
&gt; would screw up tons of code that we include and just assume works. I doubt it would screw up tons of code. You keep the default behavior to what + does and only change behavior if it is specifically overloaded. In that case, unless some library goes out of its way to overload + on stupid things, everything should work fine (But you would be in the same boat if something decided to overload common string functions). I agree that the average joe programmer probably shouldn't deal with operator overloading. However, for someone making a matrix library, some number cruncher, or some data structure, operator overloading is a god send. 
I think the number one reason is that they're trying to keep the release as small as possible. When you start piling on too many features, it becomes hard to actually get it out the door (see ECMAScript 4 or PHP 6). Since ES4 was cancelled and ES5 was such a small update, I think the ES team was just looking for a quick win in ES6. Will operator overloading make it into a future release? Possibly. But I can bet that it's not in this one because of it's complexity. Let's all just enjoy what they've given us so far and acknowledge the fact that it means there are many more updates to come. :)
Mitigating that risk is an automated task, today: 1. Test-First-Development 2. Continuous Integration 3. jscs to enforce homogenization 4. Gitflow for managing the repos amongst many teams 5. Wrapping 3rd party libraries * This allows you to swap out any microlib you want without affecting the team at all. * The wrapper has a standard API that your team uses * You can swap out the private functionality of the wrapper with any 3rd party lib without affecting the team, or tests. 6. CodeClimate checks your quality against the ecosystem's standards of quality 7. Proper agile management techniques mitigate the risk of team members being caught unaware of anything. There isn't any serious reason why using monolithic frameworks is "bad". That's why you'll likely never see the downside of using it. In this case, it's how much "better" microlibs are in practice. You just don't even know what you're missing, and nobody will be able to explain it to you. You owe it to yourself to spend a weekend writing a tiny blog with node.js microlibs. You also owe it to yourself to be rid of the phrase, "No way", because it's your job to find one.
That's really cool, thanks for sharing! There's an error though when clicking "add user": Uncaught ReferenceError: getUserInput is not defined app.js:200 But I can still add users by just putting something in the empty box and hitting update. edit: Meant to mention some possible features: * Auto-update: every T seconds it fades-in new comments. Should be pretty trivial to implement, just be mindful of reddit's [rate limit rules](https://github.com/reddit/reddit/wiki/API#rules). * Speaking of API rules, you should probably also set a UA header for the AJAX calls. **You should probably do this regardless** since you're using the API endpoint (rule #3). * Subreddit filtering: I could see taking on many forms so probably isn't "easy", but what they heck... 1. A global subreddit filter, you just type in a sub and the results only show that sub 2. This option would be just like #1, except there'd be a UI to handle multiple subreddits (something like tags, where you could individually add/remove subs). You could even go so far as to have it inspect the currently displayed comments, and offer suggested tags based on the ones preset. * Color could also come into play here, e.g. generate a color to apply to each comment for each different sub, and/or color-code by author.
Haha, I'm totally for it, but I was trying to think of arguments against...and something like that where even included libs hinge on people "doing things right" could seem reckless. I'd certainly miss it if it was gone from languages I use more regularly.
:) Yeah, there definitely seems to be a strong divide in language designers. On one extreme you have C++ which has just about every feature to support every language paradigm under the sun. On the other end you have the Go or Lua which people have to viciously debate and battle to get any new feature into the language. Which is the better language design philosophy? Who knows. But for me, I appreciate that I can program in just about any style in C++, even if that means code can go horribly wrong.
The project is named Smithsonian because I like the wordplay, Metalsmith -&gt; Smithsonian. The Smithsonian organization writes mostly PHP and Ruby and none of their projects seem to be as popular as my Smithsonian. Searching Github, the repository is the top result and the "smithsonian" package name on NPM links to the correct repository as well. Of course, if the Smithsonian ever legally involves itself in attacking an open-source project, a name change will still be on the table.
Maybe I've never truly grasped the potential of operator overloading, but to me it sounds like syntactic sugar. In fact, what I have seen (I've toyed with c++ years ago) it just makes code harder to understand because you need to check the implementation to determine the operator's actual behaviour; it's entirely possible to make a + operator do subtraction or division or whatever. Augh! Feel free to enlighten me. :) 
So if you had a larger development team, you're saying all of the above would be stuff you would do after they're all done and committed / code complete for a particular project or sprint? This wouldn't be stuff each developer would do, rather the final person would run before promoting changes to servers? 
&gt; Are you supposed to put your .gruntfile in source control? yes 
thanks :)
Generally, what is often the case when bundling/minifying comes into play? Something run as a last step before deployment? Or something every developer is doing before checkin? 
Yes, I would put it in. Things like IDE/Text editor settings (ie: things that really represent your personal configurations for the project) should not be in source control.
Runtime type checks are a problem inherent in dynamically typed languages, and JS operators are already "overloaded". Given the code: x + y; What's actually happening here logically is type checks are done on x and y to see if they are both numbers, strings, objects, etc or some combination thereof. The compiler can (and in some cases may) just generate a bunch of branching logic along with calls to appropriate functions like *toNumber*, and then some primitive integer/float/whatever add operation, but there are various optimization techniques like [tracing](http://en.wikipedia.org/wiki/Tracing_just-in-time_compilation) or [basic block versioning](http://pointersgonewild.files.wordpress.com/2011/08/bbv_paper.pdf) that will just generate specialized code for certain types and then detect when it can be used. (along with any number of other optimization tricks/techniques like static [type inference](http://en.wikipedia.org/wiki/Type_inference), [loop invariant code motion](http://en.wikipedia.org/wiki/Loop-invariant_code_motion), etc) The main hit would be the cost of the lookup of the appropriate method, and the actual call itself. For the first one, property access is another thing engine implementors are familiar with optimizing; using strategies like V8's [hidden classes](https://developers.google.com/v8/design#prop_access). The second one could possibly be solved by inlining the function. So yes, it would involve more work in the optimizer but not too much, and it's composed of problems implementors are familiar with. Spitting out fully-optimal code is pretty hard, but they have a host of techniques they could use to trim some of the waste involved. If anyone is curious about any of this check out [Higgs](https://github.com/maximecb/Higgs) and/or come talk to us in #higgsjs on freenode or [our subreddit](http://www.reddit.com/r/higgsjs/).
I'm more curious about the duck-typing problem, I suppose. I know JS has typed arrays, but are the actual types themselves exposed independently? Perhaps I'm more curious as to how the overloaded operator would be optimized for Number types when it's difficult enough to control the representation, short of asm style representations. Overloading could be applied only to custom types, but then the original problem remains; you wouldn't be able to overload the + operator for typed arrays.
fucking awesome
After the first install, no. EDIT: If you have local only components (why would you), you will never need to go online.
Minification would be deployment only, you need the non-mangled source code for debugging (yes, there's source maps to combat this, but it's easier to just skip minification entirely) Bundling depends on what tools you're using. CommonJS based systems like Browserify require full bundling all the time because the code executes synchronously and has to be loaded at run time. AMD based systems such as RequireJS can load files on demand, making the bundling process an optional optimization to be done upon deployment. Linting would be done before checkin, but the files generated by the other steps would not go into source control, as they're transient files pre-deployment.
FWIW, Dart has operator overloading and it looks pretty nice: class Vector { final double x, y; const Vector(this.x, this.y); Vector operator - () =&gt; new Vector(-x, -y); Vector operator - (Vector v) =&gt; new Vector(x - v.x, y - v.y); Vector operator + (Vector v) =&gt; new Vector(x + v.x, y + v.y); ... } var a = new Vector(1.0, 2.0); var b = new Vector(5.0, 7.0); var c = a + b; print(c.x); // 6.0 var d = -c; print(d.x); // -6.0 You can override: &lt; + | [] &gt; / ^ []= &lt;= ~/ &amp; ~ &gt;= * &lt;&lt; == – % &gt;&gt; I like this a lot. It makes working with vectors or SIMD stuff a lot easier. At this point it's pretty unclear if JS will ever have something like that. There are some proposals and ideas, but none of that looks very pretty: http://wiki.ecmascript.org/doku.php?id=strawman:value_types http://wiki.ecmascript.org/doku.php?id=strawman:operator_overloading_with_double_dispatch
I'm not wrong, but I do accept that there are a handful of JavaScript programmers here on reddit who think that "scale" means when a program grows in size. Learn you some computer terminology: http://en.wikipedia.org/wiki/Scalability#Examples
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 2. [**Examples**](https://en.wikipedia.org/wiki/Scalability#Examples) of article [**Scalability**](https://en.wikipedia.org/wiki/Scalability): [](#sfw) --- &gt; &gt; &gt;* A [routing protocol](https://en.wikipedia.org/wiki/Routing_protocol) is considered scalable with respect to network size, if the size of the necessary [routing table](https://en.wikipedia.org/wiki/Routing_table) on each node grows as [O](https://en.wikipedia.org/wiki/Big_O_notation)(log *N*), where *N* is the number of nodes in the network. &gt;* A scalable [online transaction processing](https://en.wikipedia.org/wiki/Online_transaction_processing) system or [database management system](https://en.wikipedia.org/wiki/Database_management_system) is one that can be upgraded to process more transactions by adding new processors, devices and storage, and which can be upgraded easily and transparently without shutting it down. &gt;* Some early [peer-to-peer](https://en.wikipedia.org/wiki/Peer-to-peer) (P2P) implementations of [Gnutella](https://en.wikipedia.org/wiki/Gnutella) had scaling issues. Each node query [flooded](https://en.wikipedia.org/wiki/Query_flooding) its requests to all peers. The demand on each peer would increase in proportion to the total number of peers, quickly overrunning the peers' limited capacity. Other P2P systems like [BitTorrent](https://en.wikipedia.org/wiki/BitTorrent_(protocol\)) scale well because the demand on each peer is independent of the total number of peers. There is no centralized bottleneck, so the system may expand indefinitely without the addition of supporting resources (other than the peers themselves). &gt;* The distributed nature of the [Domain Name System](https://en.wikipedia.org/wiki/Domain_Name_System) allows it to work efficiently even when all [hosts](https://en.wikipedia.org/wiki/Server_(computing\)) on the worldwide [Internet](https://en.wikipedia.org/wiki/Internet) are served, so it is said to "scale well". &gt; --- ^Interesting: [^Scalability ^testing](https://en.wikipedia.org/wiki/Scalability_testing) ^| [^Plasma ^scaling](https://en.wikipedia.org/wiki/Plasma_scaling) ^| [^NonStop ^SQL](https://en.wikipedia.org/wiki/NonStop_SQL) ^| [^Virtual ^Extensible ^LAN](https://en.wikipedia.org/wiki/Virtual_Extensible_LAN) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cjxvcfz) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cjxvcfz)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Because colloquial language is never right! It's not limited to JavaScript developers, I've heard 'scaling a code base' more times than I count
Good lord, that first link is awesome.
&gt; What calls my attention is the leaking l variable, extending the prototype, the unnecesary parentheses and extra semicolon, using == to compare to zero, and the use of imperative, hard to refactor code. Extra parentheses and "hard to refactor" are both entirely arbitrary. The rest of those would all be caught by JSHint.
I think your point is very valid but you are missing the forest for the trees. Having a style rule to get a uniform codebase out of 10 developers can be done at the same time as improving the code quality. Having style rules should not remove the need to write good code and vice versa. I wrote this because I came into a team with lots of developers and a big JS codebase that needs to become more cohesive. I can't fire everyone who writes a leaky abstraction and I certainly am not using this one style rule to replace other good practices like introducing JSHint, code reviews and just general training. You seem to have the impression that this is replacing all of those. I just wanted to paste a snippet of code that had nothing to do with my actual project or company intellectual property.
I'm curious what you mean by breaking code. Can you give me an example in which this would happen?
Insofar as you can make the function "highestElement" return the lowest element, I'm not sure how it inherently makes code hard to read. It is basically syntactic sugar but allows for the beauty of user defined types to be used like primitives (in the code at least). Vector a = [1,2,3] and b = [1,2,3]. As vector types, a + b = [2,4,6] But without overloading you are forced to iterate through elements or use map every time you want to add vectors. It's not too much to ask for and a lot of languages have it. With the advent of class and extends in es6 I would have assumed this would be included.
&gt; [ES6's] class keyword [is] merely syntactic sugar It's more than that. Having a built-in way to do classes/inheritance means that your tools will know what's going on. Secondly, it makes things more interoperable. Another important point is that you won't have to compare a dozen libraries anymore. Choice is great, but having to compare a dozen different options which are all sorta kinda (but not quite) the same is super annoying.
You're drunk, yes?
You could try something like this: [http://jsfiddle.net/Ldnw3rxp/1/](http://jsfiddle.net/Ldnw3rxp/1/) It's all classic javascript. I tried it with .disabled and it didn't work for me either but this seems to. I'm sure there's a more efficient way to do this. And of course, if the user can disable javascript and still submit the form then it's not really useful. Hope it helps!
No, what did I say wrong?
I would highly recommend having your developers use Grunt before every commit, why would you want to write all this great logic to ensure a quality codebase and then only use it on deploys and then realize everything is broken. Always lint, always test, and always have a happy commit when you're bisecting.
right?! everyone is trying to shove a class system down javascript's throat. enough already, just learn the prototype system.
I prefer CommonJS as I much prefer the syntax and I use it in node so code sharing is possible. One example might be text processing functions where environment isn't as important but code duplication is undesirable (most of the time).
Javascript is a broken dysfunctional language. Adding operator overloading is going to make it even more broken.
CommonJS. Works 'out of the box' with NodeJS, makes more sense to have require statements that have predictable cross-platform behavior. The whole AMD structure is predicated upon having some framework-dependent mechanism to inject scripts, leaving transport through an unreliable third party. Pretty much this: http://tomdale.net/2012/01/amd-is-not-the-answer/.
how?
Terrific article, thanks. I'm convinced
I did yes and it doesn't show anything... I'm not sure, maybe it's a specific case for when it gets run in jenkins, it's all a bit over my head... I've noticed the same thing with the webstorm console output, it just fails to report errors sometimes -- the only way I know it's failed is when it stops working (sync task) I did find that when I opened powershell on the server and ran the same script and noted that the errors were shown -- I was able to fix the issue and subsequent builds were successful. 
Every Grunt project that I've ever seen has had a gruntfile in source control, are you sure that they weren't talking about committing the downloaded npm dependencies? Because there are some who say that you shouldn't commit those, and others disagree -- Addy Osmani does a good job [covering both sides of the coin](http://addyosmani.com/blog/checking-in-front-end-dependencies/).
* You can use CommonJS in node * Following from that: you can just require CommonJS modules server-side for very quick unit tests run * CommonJS modules handle the enclosing function for you * CommonJS translated (relatively) nicely and directly to ES6 module syntax* The only advantage of AMD (async loading in development) comes with the disadvantage that your app's behavior in development might be fundamentally different than outside of development. AMD was an interesting but ultimately terrible idea and can't die quickly enough. &lt;/rant&gt;
Hi! We do miss you on #bbg :)
I found this a pretty nice explanation btw: http://www.slideshare.net/BrendanEich/value-objects
I got confused reading your posts here, first you said you didn't know anything about operator overloading, in the next paragraph you said it's a code smell (it's not) and in the follow up comment, said you were in favour of it. It was like a crazy roller coaster for me ;) Figured you'd been at the liquor cabinet!
Hey, I coded my startup with requirejs. The structure I wanted to have is this: 1 common script, 1 custom page script (for a total of 2 js request per page). If I had to do it all over again, I wouldn't use AMD. These are my reasons. - The [main] advantages of AMD over browserify is that you don't need to compile for development. The browser will fetch them asynchronously. This makes for a pretty fast development cycle (no need to wait for compile) - As you can imagine, this is a shit scenario when you modularize everything, because you'll have tons of requests... which then leads to: - you need to compile it to serve. R.js is a shitty pain in the hole - configuration nightmare. Just trying to figure out the dir paths and stuff was such a pain in the arse. - The structure/configs of the require calls depends on how you want to serve it. Again, these works like magic in development.. The headaches comes when you want to compile it.. compare the structure/config from the tutorial, and these links: - https://github.com/requirejs/example-multipage - https://github.com/requirejs/example-multipage-shim - https://github.com/requirejs/example-jquery-shim - https://github.com/requirejs/example-jquery-cdn - Sometimes it works in dev, but not in production. When dealing with shims, if you don't configure it correctly, you'll get hurt. - You need to include require.js, and it has to load first (16kb). Almond will only work if you output 1 big file. So, for our scenario above, that's 3 not-really-asynchronous-requests. - (not the fault of requirejs but still a point) Some viruses, Anti-viruses and Extensions sometimes breaks requirejs. (see: Adguard). Try explaining to your CEO why your site doesn't work, while other works, because you used requirejs ;_; - Finally, there's too 2 ways to require stuff. You can do: define(['a', 'b'], function (a, b) { }); or you can do define(function (require) { var a = require('a'); var b = require('b'); }); It's the same shit when you do development... but totally different when it comes to compiling. arggg. Do yourself a favor, just use commonjs and don't look back.
As somebody who is just looking to modularize my JavaScript, this thread has been immensely helpful.
I think you'd be better off tracking form state in a javascript variable; I'm assuming you want *something* to happen when a form is disabled or enabled, whatever logic is changing that form should be able to trigger something else.
Most commonly, you wouldn't check `=== true/false`, but in the case where you need special treatment for undefined you should use: if (typeof booleanVariable === 'undefined') { ... } else if (booleanVariable) { ... } else { ... } **Edit** : There's a reply stating that you can just check `(booleanVariable === undefined)` which is correct *but with a caveat*: The below code will print `is undefined` because `x` has been declared. var x; if (x === undefined) { console.log('is undefined'); } BUT: If you can't be certain whether the variable has even been declared yet -- this *shouldn't* happen if you're following good coding practices, but there are cases where you need to account for this -- then checking for `(x === undefined)` on a variable that has never been declared will throw a ReferenceError. if (y === undefined) { // Throws ReferenceError console.log('is undefined'); } [jsfiddle example](http://jsfiddle.net/6gn7vtjn/) It may also be worth mentioning, as u/escape_goat points out: `typeof` cannot differentiate between cases where a variable is declared but undefined, and an undeclared variable. As far as its result is concerned, `typeof` would not see a difference between `x` and `y` above.
Hey, though, everybody.. What about [Ender (github)](https://github.com/ender-js/Ender)? [This place](http://blog.brianbeck.com/post/10667967423/node-js-require-in-the-browser) says that Ender is really popular. But can we really trust a technology that has a penis on its [homepage](http://ender.jit.su/)?
You can use [MutationObserver](https://developer.mozilla.org/en/docs/Web/API/MutationObserver) for this. The [support is OK](http://caniuse.com/#feat=mutationobserver) in my books (IE11 supports it). Here's an example in jsfiddle showing how to do it : http://jsfiddle.net/s2f6088g/ 
Could you also do the following? try { if (!booleanVariable) { // action for false condition } } catch (e) { if (e instanceof ReferenceError) { // handle undefined } else { throw e; } } This code of course assumes that the only `ReferenceError` will happen on `booleanVariable` so it might depend on your coding style and what you're doing with the code.
CommonJS means one less level of indentation too.
 Right now - CommonJS style + jspm FTW. jspm allows asynchronous loading of any of the 3 big module styles - CommonJS, AMD, or ES6, as well as packaging. http://jspm.io/ 
There's also if ( booleanVariable != null &amp;&amp; !booleanVariable ) { // double-equals here checks for null OR undefined // add stuff here }
I'm just trying to help you avoid confusion and make googling your project easier. Like, you wouldn't name a javascript package "Pepsi", right? Do whatever you want though, just speaking from experience here.
The intepreter/compiler does not know the type of every expression in your codebase. That's a consequence of dynamic languages. That does not free *you* the coder from the responsibility of knowing it. If `booleanVariable` can only ever be `true` or `false`, just use `if (!booleanVariable)`. If you're not sure what `booleanVariable`'s potential values are, figure that out first.
what is changing the disabled attribute? I can't think of a way off the top of my head the disabled attribute would change without JS doing it.
I tried Ender about a year and a half ago. Would not recommend it; it was immature then and barely supported now. Browserify and AMD are better.
I have actually had a case where a value could legitimately be null, false or true, and I needed to treat those cases differently. Only once, and I wasn't really thrilled about it, but it can happen. So I guess I can imagine the same case for undefined. Ah, JavaScript, where a boolean variable can have four different values. (I know, it's not a boolean *variable*, but you get what I mean)
I would avoid [coding by exception](http://en.wikipedia.org/wiki/Coding_by_exception) where possible. In the case you gave, the only exceptional circumstance we can see (evaluating `!booleanVariable`) is one that we know how to avoid. The rest of that block is evaluated within a `try` block and there's not really a good reason for that. My inclination--not a rule, just how I like to code--is to use `try` as rarely as possible, and to put as little as possible into the `try` block. To me that makes the code cleaner and it's easier to understand what the developer's intentions are. As you suggested, this will catch every ReferenceError within the block, not just the one you're thinking of. And I know I make enough typos when I code that I really want those things to bubble up.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Coding by exception**](https://en.wikipedia.org/wiki/Coding%20by%20exception): [](#sfw) --- &gt;__Coding by exception__ is an [accidental complexity](https://en.wikipedia.org/wiki/Accidental_complexity) in a software system in which the program handles specific errors that arise with unique exceptions . When an issue arrises in a software system, an error is raised tracing the issue back to where it was caught and then where that problem came from, if applicable. Exceptions can be used to handle the error while the program is running and avoid crashing the system. Exceptions should be generalized and cover numerous errors that arise. Using these exceptions to handle specific errors that arise to continue the program is called __coding by exception__. This [anti-pattern](https://en.wikipedia.org/wiki/Anti-pattern) can quickly degrade software in performance and maintainability. &gt; --- ^Interesting: [^Exception ^handling](https://en.wikipedia.org/wiki/Exception_handling) ^| [^Structured ^programming](https://en.wikipedia.org/wiki/Structured_programming) ^| [^Base ^pair](https://en.wikipedia.org/wiki/Base_pair) ^| [^Dopamine ^transporter](https://en.wikipedia.org/wiki/Dopamine_transporter) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cjy36fa) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cjy36fa)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
That "in development" is such an important part. The whole "A" part of "AMD" is a problem, not a feature, in production, but the amount of external configuration and boilderplate you have to include to make it work... ugh, wish we'd made a different choice a couple years ago.
Great post. I never really looked into it, always used CommonJS, but this convinced me I made the right decision. 
Of course the answer is: it depends. If I'm checking an argument that is passed in to a public function, then I prefer type coercion and would use the less strict `if (!booleanVariable)` If I'm checking the value of a private variable that can't be modified from the outside, then strict checks are preferred. If I'm checking for the truthiness of a global variable, then I've got bigger problems...
I always use positive boolean naming because it's generally clearer. isVisible, isValid. (Opposed to isHidden, isInvalid) It has the benefit of being false if it is undefined and you haven't explicitly set it to true.
...or `!!booleanVariable` if you don't want to read the negated form.
For the record... Using Gulp (possibly Grunt as well) means 'compiles' take less than a second or even a few milliseconds...
But double negatives and [yoda conditionals](http://en.wikipedia.org/wiki/Yoda_conditions) are so readable!
This is basically "Look Before You Leap" (LBYL) vs "Easier to Ask for Forgiveness than Permission" (EAFP).
I use CommonsJS so I can re-use code between the backend and frontend. Also RequireJS is pretty horrible to work with.
Great write up, matches my experience exactly. Browserify with source maps works great, makes debugging easy, and has the simpler commonjs syntax. Really liking it so far!
I bought the idea of AMD early on because of that idea of only loading what a page needs, but I found in practice it helped very little. Once you load the framework type libs (jquery, bootstrap, backbone, that sort of thing), and a few core files for your own pages, you really don't save that much (10-15 percent is what I saw). Now maybe with a bigger and more varied app this might go up, but really with minification, gzip, and browser caching are you really saving very much? 
I hate Yoda style. 
That is interesting. The big draw for us at work to AMD was because it allowed us to do software engineering in JS. Instead of having a mess of script tags on a page somewhere, we could have JS modules which specify what they need. Improved front-end performance or the promise thereof wasn't really a consideration. 
I'm fairly confident there isn't a way to get a null boolean without explicitly setting one in javascript. You check for undefined parameters at the top of a method, and then you are golden. I would hate to read the code that people are writing that produces all the complaints about javascript. Also if you really cared, you'd start using TypeScript
Well you really shouldn't be using try/catch in javascript except as a last resort. It won't optimize correctly.
CmmonJS/Browserify also gives you modules, it just bundles them into one big file as a build step. It's easier to use than RequireJS too (in my experience at least)
If you're sure it's a boolean, using === is just plain silly. I'd also *never* use === if there can't be a meaningful falsey value other than false. I'd just use if(!blah) ...
Events are definitely a double-edged sword, when used improperly they're a pain. That's when I just turn the profiler on and see what's hitting, then add some breakpoints and log statements.
No, it's main purpose is to prevent assignment in ifs by mistake. if(true = x) is an error where as if(x = true) isnt in most langs. 
CommonJS. I use it with webpack which is similar to browserify but allows you loading modules asynchronously even if you use CommonJS (I've never used browserify so it maybe also allows that)
Look into FRP, functional reactive programming. There's a great library called Bacon.js which could save you a lot of headaches. Events themselves aren't the problem; trying to handle complex event networks imperatively is.
not only that, but there's a performance penalty for `try` statements.
always always always always always always always always always always always always always always always always always always always always always always always always always always always always always always always always always always always always always always always always always always always always use ===. always.
It's not that far a stretch... if in a view model, you initialize everything to null and paste over it with data from a web service -- if the boolean value doesn't exist it could still be null -- or true/false from the service. (and in that case, it'll probably be a string true/false... what joy)
Use AMD when you want to load thing dynamically, like a part of the javascript only when needed because you want to keep initial page load minimum. Else use commonJS
I guess my point is that the range of objects that this would make most sense for is rather limited (perhaps I'm lacking imagination). I can certainly see your point for vectors, matrices and complex numbers, but I see very very little merit (imo) for most types objects I can think of; event listeners, DOM objects, canvas / widget related objects, Ajax, and most design patterns. From what I've seen in my exposure to operator overloading, it's just way too easy to add side effects that just aren't apparent by looking at the operator alone. Code should be clear. Picking meaningful and unambiguous names for methods is challenging enough as it is.
You should check out lodash.
I agree and use this style myself. When you end up dealing with many languages, scripting environments, etc., I find it's always best to be explicit about your intentions. Sure, "if (booleanVariable)" might always work as intended in one language but will it work the same way in another? Maybe, but what about the custom boutique macro language added to some tool that you write scripts for 3 or 4 times a year? I think of it this way, any other evaluation and you spell it it out: "if (A == 3)". So why in this one special case of "if (A == true)" would you deviate from the pattern? It just makes for clumsy looking code in my mind.
Don't work with shitty js developers: problem solved
welcome to kindergarden 
Why not just always use === and then use == when that's actually what you mean?
the typeof isn't needed, you could do: if (booleanVariable === undefined) { ... } else if (booleanVariable) { ... } else { ... } It doesn't cost as many cycles and its shorter.
Adding hard to use and hard to comprehend features just because someone will find it useful doesn't really make for a very good language design principle, in my humble opinion. Maybe I'm wrong and many people will find it to be very useful; I just suggested that as a reason it may have been dropped. Other things have been dropped because the performance overhead made them almost impossible to use; Mutation Events were completely deprecated because the implementations didn't hold up. Now mutation observers are available instead; I'm not really sure that there's an analogous fallback solution in the event that operator overloading is added but causes similar problems.
By custom event, it seems you mean a function being called in response to something happening. I don't think this is avoidable while programming a variety of things. Please clarify if you mean something different by 'custom event'. As for the 'is there a better way' question, I think 'yes' but obviously I don't know the full details of your system. I think it would come down to better general software engineering techniques as well as JavaScript ones. Encapsulation of functionality seems to have been an issue in your codebase, that can be a problem in many languages. Sometimes people need to take the time to understand the lower level details of what's going on (and I don't mean low level like on the CPU, just having a thorough understanding of what JavaScript is being called and when), rather than relying on a programming abstraction which is not fully understood. Building a thorough understanding of a system is something managers don't always like, as they would prefer to see you producing code with the goal of solving the task. It's also hard to estimate how long it will take you to understand the codebase, and open discussions on the codebase could be difficult as people do not like to be told that their work is of a low quality or flawed, which may be the case in a broken codebase, so it's sometimes hard to have a truly objective discussion on what is going on. Also, is the expectation at your workplace that you work over the contracted number of hours when there is a task yet to complete? I understand if you don't want to say too much about workplace issues and want to keep the discussion more technical. I do think that someone before you could have been under pressure to get something working soon on the codebase and there was not the expectation that the codebase should be / stay coherent, rather than getting some specified functionality implemented. I wonder if this has to do with 'User Stories' being the most prominent goal to attain in some Agile development methodologies, where coding goals are set by making a really small story such as 'The User needs to be able to sort pending print notifications by file size' then carrying out the coding is higher priority than 'Maintain an understandable, efficient and concise codebase'. That one can be solved by making a User Story like 'User needs to be able to use the app without it unpredictably going wrong [in situations ...]', or 'User needs to be able to get fixes for problems within the contracted timeframe', giving the way to solve this as being having a well understood codebase that won't require untangling to make a change (implicitly rather than requiring developers to work unpaid overtime). 
JSLint/JSHint will catch that. In general, most IDEs will highlight it with a squiggly line if you try to do something like that.
Your booleans should always be `true` or `false` and never be merely truthy or falsy. If you need `undefined` as a third state, rethink what you're trying to do.
Should've been a node.js based script instead of bash.
Javascript absolutely **IS** an object oriented language, and always has been. It is a [prototype based objected oriented language](http://en.wikipedia.org/wiki/Prototype-based_programming). Not all object oriented languages are class based, just a good number of the popular ones.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Prototype-based programming**](https://en.wikipedia.org/wiki/Prototype-based%20programming): [](#sfw) --- &gt; &gt;__Prototype-based programming__ is a style of [object-oriented programming](https://en.wikipedia.org/wiki/Object-oriented_programming) in which behaviour reuse (known as [inheritance](https://en.wikipedia.org/wiki/Inheritance_(programming\))) is performed via a process of [cloning](https://en.wikipedia.org/wiki/Cloning_(programming\)) existing [objects](https://en.wikipedia.org/wiki/Object_(programming\)) that serve as [prototypes](https://en.wikipedia.org/wiki/Prototype). This model can also be known as *prototypal*, *prototype-oriented,* *classless*, or *instance-based* programming. [Delegation](https://en.wikipedia.org/wiki/Delegation_(programming\)) is the language feature that supports prototype-based programming. &gt;A fruit bowl serves as one example. A "fruit" object would represent the properties and functionality of fruit in general. A "banana" object would be cloned from the "fruit" object, and would also be extended to include general properties specific to bananas. Each individual "banana" object would be cloned from the generic "banana" object. &gt;The first prototype-oriented [programming language](https://en.wikipedia.org/wiki/Programming_language) was [Self](https://en.wikipedia.org/wiki/Self_(programming_language\)) developed by [David Ungar](https://en.wikipedia.org/wiki/David_Ungar) and [Randall Smith](http://research.sun.com/people/randy/) in the mid-1980s to research topics in object-oriented language design. Since the late 1990s, the classless paradigm has grown increasingly popular. Some current prototype-oriented languages are [JavaScript](https://en.wikipedia.org/wiki/JavaScript) (and other [ECMAScript](https://en.wikipedia.org/wiki/ECMAScript) implementations, [JScript](https://en.wikipedia.org/wiki/JScript) and [Flash](https://en.wikipedia.org/wiki/Adobe_Flash)'s [ActionScript](https://en.wikipedia.org/wiki/ActionScript) 1.0), [Cecil](https://en.wikipedia.org/wiki/Cecil_(programming_language\)), [NewtonScript](https://en.wikipedia.org/wiki/NewtonScript), [Io](https://en.wikipedia.org/wiki/Io_(programming_language\)), [MOO](https://en.wikipedia.org/wiki/MOO_(programming_language\)), [REBOL](https://en.wikipedia.org/wiki/REBOL), and [Lisaac](https://en.wikipedia.org/wiki/Lisaac). &gt; --- ^Interesting: [^JavaScript](https://en.wikipedia.org/wiki/JavaScript) ^| [^Self ^\(programming ^language)](https://en.wikipedia.org/wiki/Self_\(programming_language\)) ^| [^ECMAScript](https://en.wikipedia.org/wiki/ECMAScript) ^| [^Io ^\(programming ^language)](https://en.wikipedia.org/wiki/Io_\(programming_language\)) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cjyajgu) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cjyajgu)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
You can split your commonJS bundles into different files if you must; not sure if Browserify can do so but this is easy to configure in Webpack. You could have one bundle with your main library stuff and a few different ones for other parts of your application.
You could do that in C++ just by implementing methods with the same name. The benefit to operator overloading for templated parameters is that they are more likely to be overloaded (no guess and check on method names). That being said, I'm all for operator overloads. I think it can make certain classes of code much more readable and easier to manage. Nothing I hate more in java than the fact that operator overloads don't exist so the likes of bigdecimal have to use clunky "add" methods.
Webpack is a lot more powerful then browserify.
Here's a relevant video from lodash's developer (John Dalton): [Unorthodox Performance](https://www.youtube.com/watch?v=NthmeLEhDDM), he touches on forEach and friends
You could do the same thing with an "add" function or a "compareTo" function. There is nothing that says a well named function has to be well behaved. The usefulness of operator overloads is primarily for numerical structors or various data structures (a map/dictionary for example). While it isn't necessary, it does make code a lot cleaner in the cases where you have those data structures. You can see other useful cases, though, when dealing with things like the equals operator or the comparison operators. I just don't see the complaint. C#, for example, has operator overloading. I've never heard of someone complain about that feature existing. The only language I hear mentioned when it comes to operator overloading is C++, and usually it is sort of a passing "Yeah, it has it and it can be bad sometimes!".
Sounds like you need documentation 
The setup for RequireJS is significantly more code and config than most browserify apps. But yep, there are indeed plenty of options on how to use browserify, some more complex than others (gulp, grunt, beefy, CLI, etc). Personally I use beefy since it allows me to jump in immediately with zero config. The main benefit of browserify is to make use of npm modules and it's versioning. Duplicate code is actually a benefit, as it ensures your app won't break because of dependencies. In most cases it's negligible when compressed (especially since npm philosophy encourages small modules). The alternative, "require conflicting versions and wait until your app breaks," isn't quite as effective... The toughest part of browserify is getting into the groove of small and composable "unixy" modules (see [stackgl](https://github.com/stackgl) for example). This is a pretty drastic shift for most people. 
see [this issue](https://github.com/joyent/node/issues/8104) on github
Note that, although it never happens, *undefined* is a variable you can change and your code would break if you do, which is why the typeof is used.
The reason it's faster is that you're skipping `hasOwnProperty` checks. The native implementation tests for the existence of every index before triggering the callback, so that it can work on sparse arrays. For example: var arr = []; arr[5] = 5; arr[100] = 100; arr.forEach(function (x) { console.log(x); }); // logs 5, then 100. nothing else. Frankly, I think writing the spec that way was stupid. They should have optimized for the 99% case, not the 1% case, especially given that the 1% case has a better alternative. But, it's set in stone now, and overwriting it with something subtly incompatible will lead to insanity. I would suggest moving your code to its own function, not overwriting `Array.prototype.forEach`.
That's only the case for old browsers, the variable is now read-only
Yep; but if your webpack-specific application is written by composing many small npm modules, you will inevitably end up with some of them depending on webpack-specific functionality. And that's where you run into problems not only during development, but also when re-using those modules on another project. The problems become more evident when your application has 30+ dependencies, and continues to produce new dependencies as it grows. 
You may be interested in http://danieltao.com/lazy.js/ and http://jsperf.com/
&gt; The setup for RequireJS is significantly more code and config than most browserify apps I'm a little skeptical of this line; grunt-requirejs and grunt-browserify invariably look right around the same size and complexity (from my limited experience with browserify) &gt; Duplicate code is actually a benefit No, not when they're the same versions. You're wasting server time rendering it, and client time loading it; that's your money (running the server) and their money (data plans). Maybe it's negligible for small sites without much traffic, but for me (personally) that's not Duplicate code is actually a benefit. &gt; npm modules and it's versioning Not all modules on NPM are exclusive to node; unintentionally loading multiple versions of jQuery, for example, will cause no end of headache.
Not particularly.
Wow. So, what you're asking here is really one of the most fundamental, basic concepts of programming in general. This is really not a very specific question (like: "Why is my event listener not being triggered?" or something along those lines). This is more like, "How do I program?". I/we could easily give you a brief on what a variable is, but then that's like 0.001% of what Javascript is. You would still need to learn a thousand things after that. You should pick up a book on JS or do some Code Academy tutorials or something. In the meantime though, the ELI5 answer would be: a variable is like a box you can put things in, but you might have a hundred boxes that each hold different things, so you label the box so you can easily remember which box holds what. You can also easily take things out of the box and put something else in.
You have to debug in all of them but Chrome and Firefox supply the best debugging tools with an edge given to Chrome. Both far exceed anything in IE. A simple Google search will give you the documentation for the developer tools in both those browsers. &gt;I know that everyone bags on IE(why?) You're going to get your thread way off topic by asking that question but, suffice to say, IE is almost always the last to support standard properties and APIs and, at one time, ignored the standards if it didn't benefit Windows and other Microsoft software. Even today, IE11 is years behind every other major browser in some areas. Just a couple of days ago, there was a link to a Microsoft article bragging about their joining the WebGL group; a board that's been supported and a technology used by every other browser for a decade or more. They would also do battle with others on standards committees and some properties, while they were supported, weren't properly implemented, requiring workarounds, polyfills and so on. You can peruse these if you wish: [HTML5test](http://html5test.com/results/desktop.html) http://css3test.com [caniuse.com](http://caniuse.com/#compare=ie+11,firefox+34,chrome+39,safari+8,opera+25)
I added an edit explaining my reasoning for using `typeof`, but your point is valid. Using `typeof` is a little slower, but in certain situations, you'll need to account for whether a variable has even been declared or not.
Sounds identical to a bug I had to hunt down yesterday at work. I'm checking an attribute on an object, and it's supposed to contain "isOverrideable" boolean (the application is a CMS with two levels of permissions). Well "isOverrideable" is being used a flag for styling. Aside: I'm a front-end software engineer, recently hired under contract, and I've been there for 2 two-week sprint cycles (so a month). So I see that this particular element isn't being styled correctly, check the conditions on which it should be styled, and compare it to the object. I see that this flag is null. There's no condition checking for null, it's check for true/false explicitly because it's only part of a conditional (there's various combinations for paths). Had to verify that null was 'not' an acceptable value - because there's no condition in which that value is not passed from the service. If there was a condition in which that value would not be passed from service, it would have complicated the conditionals even further. Ultimately a defect in the service, but I implemented a temporary patch in the front to treat null values as a false by checking specifically for null, because I couldn't use falsy because the boolean was really a string "false". 
Why on earth would somebody downvote this? Somebody must have had a bad day. *Upvoted.*
Opera has [Dragonfly](http://www.opera.com/dragonfly/) built-in. I don't know enough of the different offerings to compare. I use whatever is in the browser is having a problem with a script, except when some specific is needed (eg Safari for remote-debugging the iOS browser, or Opera to remote-debug Opera Mobile). Dragonfly has a few features for inspecting images/pixels on the screen that I have not seen in the other tools, but that might be because I have not looked hard enough.
Fair point tho that is a very narrow case, the only time i can think it would be even some what probable to arise would be loading JS files, that depend on each other some what, in a random order. Tho i can't really think of a practical reason to use such an architecture.
Meh, I just `hardlink -pot ~/work/*/node_modules` in my cronjob and that's it.
Always use === when you don't understand the type conversion going on with ==. I've interviewed Javascript developers who believed that == doesn't check type, that it just ignores type and throws it out. Actually, == checks type more rigorously than === does, because it's converting types to numbers. In fact, if comparing x == y, and x and y are the same types, it behaves exactly like x === y.
[This article](http://readwrite.com/2014/08/22/nodejs-node-js-tj-fontaine-version-10) pretty much sum's up why they are not calling it v1.0 yet TLDR: They don't want to rush calling it v1 and a lot of users staying on it if ever they do a major re-do of the code similar to python v2 and v3 (a lot of people stick with v2)
Interesting explanation. I guess being a standard though and the fact that "sparse arrays" exist means there's no alternative but to implement it in this way. 
Pretty handy, I think. It's a little hard to scan the list with all the extra stuff around them (tags, date added, etc.). 
They [revised the streams API](http://blog.nodejs.org/2012/12/20/streams2/) for example. It wasn't supposed to break too many existing implementations, but it almost certainly would have been unacceptable for a post-1.0 type of project.
The nontechnical explanation is a variable holds a piece of information. Information could be a word, a number, or a big complex thingy, but a variable is just a place for you to put that information into so you can pull it back out when you need it.
What kind of stuff are you having trouble testing?
I feel like it's 1996 and I'm reading Matt's Script Archive.
Ah! Perfect then. Keep with the class. I don't want to be an alarmist or anything, but if you're finding variables confusing, it only gets more complex from there. That said, (I'm going to ignore the inner workings of the CPU and all that and how variables actually work behind the scenes), all a variable is something that stores the value of something else. Let's say you need to keep track of some details regarding a user profile. Not only do you need to store that user's info, but you also need an easy way to access that data later. So what you do is you create a variable, which is just a small bit of text that acts as a pointer to the value of that data. So in this user profile example, you might create variables named: firstName lastName email age sex etc.... Let's give our fictitious user some actual data. Let's say his name is John Doe, he's male, and he's 38. We want to be able to remember (and have access to later on) that data. So we store it in variables like so: var firstName = "John"; var lastName = "Doe"; var sex = "male"; var age = 38; Now, later on in the program, if we ever need to reference any of that data, (let's say we need to output his name), we don't need to actually write down "John Doe", but rather fistName + " " + lastName. Make sense?
Ah that sounds familiar... I was looking at some code the other day and there was a check to see if something exists before doing something with it... I had to bring the guy over to look at it -- `if typeof(obj) === 'object'` ... hey guy, you know `typeof null === 'object'`, right ? A lot of these issues though are appearing only in local_developemnt and it comes down to using a schemaless database with incomplete data.... in my case(s) anyway.
Remember this moment the next time someone tells you that vanilla js is good enough. Asynchronicity is a mindfuck without a library or (gasp) framework to help you out. 
and that doesn't even get into javascripts insane scoping.
Ok, so I can create a variable for what suits my need then? Thank you for your help. Javascript and java are my first programming classes. All the rest of them were full and I didn't want to wait another semester 
In prevents null pointer exception in java, eg "52".equals(foo)
The version numbers are pretty arbitrary at this point. They might as well do a J2SE and just drop the major version number (J2SE 1.4 was followed by 5.0). The Python/Perl argument doesn't hold much water: distros have been updating node versions very slowly (just as any other software) and what keeps devs from switching from Python 2 to 3 is the breaking changes (at syntax level -- which is a problem JS simply doesn't have and node.js doesn't even have anything to do with) and the amount of code that is affected by those changes. In practice you'll find any even (stable) version of node since at least 0.6 running in production, sometimes also the odd (unstable) versions. As long as the upgrade path from version to version remains as easy as it has been (with few backwards-incompatible changes), those apps will still be able to upgrade to newer versions eventually -- regardless of how those versions will be numbered. What's preventing major version upgrades in other projects (aside from laziness/inertia, which can't be avoided) is backwards incompatibility. It takes effort to port Python 2 code to Python 3. And nobody wants to risk subtle issues by casually upgrading PHP from one minor version to another (because PHP has a history of breaking changes being introduced in minor versions, or even bugfix releases). But as long as node's changes remain clear, straightforward and predictable, it simply doesn't matter what the next version number will be. At this point going from 0.x to 1.x is just a matter of psychology. It's almost dishonest to call any upcoming release "1.0" because node.js has practically been in "1.x" (or even "2.x") land for ages. Devs think of a "1.0" release as a special moment, for node.js most of what we associate with that release has already happened, just a lot more gradually.