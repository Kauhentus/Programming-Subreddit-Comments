Gotcha - It's a little bugged and somewhat annoying in mobile - your finger obstruct your view too.
I think your arguments are fair, the only one i really disagree with is if it will be around. ReasonML might be a fad but the more functional style type systems are beneficial to learn, more and more languages are adopting features from them. 
[More clarification here](https://www.reddit.com/r/programming/comments/8qqhlz/office_365_ms_teams_skype_code_and_the_edge_debug/e0ll1dt/) Parts of the UI (at most) is being rewritten to use Typescript and React, the services/APIs/etc still remain C++/C# though. Whether the rewrite will actually land in production is another question. The MS dev also didn't specify what exactly he means when talking about Office 365. The web UI? The desktop UI? Maybe /u/TheLarkInn can shine some more light onto this.
/r/quityourbullshit
This is what happens when your signal sucks and it posts twice cus it clicked twice. ;) 
Rewriting office. It went from we’re incorporating JavaScript for Excel, to re-writing office. That’s a rather large jump. They’ve had competition with google for years with the online version of office 365. But that’s not new nor are they switching the windows code base. https://www.bleepingcomputer.com/news/microsoft/microsoft-adds-support-for-javascript-functions-in-excel/ Honestly how did you go from this toner-writing the entire suite? Also, You might have missed all the latest WPF news recently. But 4.7 added a whole lot of WFP updates and improvements. https://www.infoq.com/news/2017/04/net47 And now MS has announced the .net core desktop stacks, as they are adding WPF and win forms to the .net core family. https://www.c-sharpcorner.com/news/net-core-3-roadmap-announced 
All I can imagine now is what Russian laughing in text form sounds like pronouncing it as though it's English. Also, life insurance.
- Normalization of Javascript APIs on the browser. - Pixel measurement, and other pixel related, functions. - CSS Scoping. This, along with strict CSS, removes the need for web components for the majority of cases.
The appropriate response is “thanks, bitch!”
Laughing? Oh, ack-zuh, you're funny, zuh zuh zuh zuh... ^(Oh wait)
PGS looks super impressive so far! Any schedule for the main game’s release and/or monetising the engine and tools? Can’t wait to play it. 
mostly for DOM manipulation &amp; ajax is pretty awesome - I tried using `.fetch` as a replacement and found working with POST variables to be *terrible* with it, especially arrays. jQueryUI has some really nice features too, nothing that couldn't be replicated obviously, but the whole point is to save myself time &amp; effort.
This is great. As a dev that uses Angular it is super handy to do this for all of the older applications that I deal with.
Looks like I have some homework to do... Thanks for all this!
So it runs on hype?
It seems to me, as the person cited as igniting this post, is that you've now learned and support the idea that informed criticism is good. What seems to be missing is that you've still raged against me and yet not acknowledged that I did, in fact, have an informed criticism.
So many things to do such simple things.
No, look for another one. [This one](https://github.com/InvokIT/js-untar) would probably work, I just googled "unpack tar browser" to find it.
So it would be a breaking change for a minority, no? I don't mean to only hold Ember's feet to the fire on this. I see a lot of projects sneaking in breaking changes, sometimes my own. I only noticed this case because "removal" is almost always a break. When minors can have breaking changes, we lose the little value SemVer gives us.
What do you recommend for learning design patterns in JS? I'm having difficulties planning and structuring my code but I'm not exactly sure if design patterns will help me with that or if I should look into something else instead.
how does this differ from graphql subscriptions?
Love and hate are strong words. Not sure why people are so quick to default to extremes, whether they're new or experienced. I like JavaScript well enough. It has a good few features that were ahead of its time for a mainstream language (features that are now popular in other mainstream languages). It was pretty slow in the beginning, but the JS engines of today are quite speedy because they actually compile the code with JIT techniques and do all sorts of optimisations for hot code - faster than things like Python and Ruby last time I checked (though you usually directly pair Python with C/C++ more so than you do in JS). There are things I dislike about JS too, though, but they're problems that are being remedied - and the ones that can't be are pretty insignificant unless you're learning for the first time. These days, my biggest complaint is that I don't get the kind of beautiful type hinting I want, because I'm not a fan of the Typescript syntax, but I get that it makes sense to go with something that compliments the C-like syntax of JS. You're never going to get a perfect tool, because there are two sides to the "perfection" that everyone always talks about: 1. Power &amp; Expressiveness 2. Simplicity (or lack of complexity) When you have a powerful, expressive language (and platform), you end up with a bunch of complexity that is difficult to break into as someone new to it, and is difficult to write due to the multitude of options available for any one problem. But if you reduce that complexity, some will inevitably want/require the options that were taken away to accomplish that.
I wouldn't go that far. But if your design requires singletons then there is *probably*, but not definitely, a significant problem with your design (it may not work, and if it does it probably won't scale well).
Hi, I'm William, CTO of Canner. Let me elaborate on what Canner does. Canner is built on top of React and Apollo GraphQL. We use graphql to connect different data sources, including Firebase, Restful API and GraphQL(e,g. Prisma). We found that front-end developers having a hard time using current CMS solutions (wordpress, drupal...) connect to their own data source, no matter it's firebase or restful api. Building a CMS from scratch will also take lots of time. Canner provides them a universal framework that they can build a CMS with simple JSX and write simple resolvers in graphql that connect to their own data source. Hope it helps you understand more about Canner.
I'd imagine that older applications probably have issues with being able to support a browser where web components exists unless you are polyfilling as well? 
`const img = new Image(); img.addEventListener("load", () =&gt; { /* can use the img as a value to add to a canvas */ }); img.src =dataURI;`
Actually, the framework itself uses React and Apollo GraphQL. Prisma, GraphQL, Firebase and Restful API are the data source we support. Building a CMS is pretty hard, especially for a large application. Before we created Canner, we tried to use wordpress and drupal, but they're not working well with modern front-end framework (React and Angular). It also took us lots of time trying to connect wordpress with our own restful API. Therefore, we decided to build a universal CMS framework with high flexibility and reusability. It saves us lots of time on many projects. After months of development, we decided to open source it and share with the community.
Your initial comment, that caused this, was along the lines of "Just JavaScript alone causes overhead". Now that's hardly criticism &amp;mdash; my question was about JavaScript, I was asking for JavaScript help, JavaScript semantics. The follow-ups, however, were more educating. Edited accordingly.
I didn't say there were superior languages that can run in the browser. I'm referring more to the crossed out "idiot" and "bitch" and link.
What kind of limitations are there? Is there any reason I can't do this to every single one of my components?
Okay, that's taking it *waaay* too personally. The crossed-out "idiot" was you, but the "bitch" wasn't. Also, what else *were* you saying? I couldn't understand anything better than "use WASM instead of JS, it's beter and faster and (you can't access the same APIs with WASM and JS)."
Are Angular Web Components suitable for sprinkling javascript on server rendered html, the way we used to work with jQuery widgets, or is it still only suitable for SPA?
You said no other languages could be used in the browser. I pointed out that WebAssembly enables using all other languages. You've been doing this for 3 years and you're a student. You should be working to understand what I say, not pick a fight with a 40 year old timer. You just didn't get it the first time. No problem with that.
Material Components for Vue.js https://github.com/matsp/material-components-vue
Prove it, or didn't happen ;)
&gt;WebAssembly enables using all other languages. Okay, I was wrong, and I apologise for making false claims. Not picking fights, but it *was* a question about JS. Anyway, sorry for offending you.
What? Its painfully slow now. I hope that web assembly or death of IE will finally kick things up a notch. There are 3 frameworks, all couple of years old.
They are on path of no return.
"RESTful API" isn't a data source really. But anyway, I did miss read CMS as blog. Since I see alot of things labeled as CMS, but are really just blogs with a lottle bit of extra plugins
You're looking at fetch or axios then.
No
Sorry if my words misled you. Maybe I should say "interface". I get what you mean. Canner is actually more like an admin dashboard than a blogging CMS.
&gt; Not discrediting this benefit of angular but I dont see how it would apply to "older" applications per se. Typically AngularJS apps are "older".
I do not understand this data at built time thing with Gatsby. Does that mean that Gatsby is not suitable for an e-commerce app where you have to add new products dynamically, without rebuilding the app? For example, is that what they do in this app? https://www.gatsbyjs.org/blog/2018-06-14-escalade-sports-from-5000-to-5-in-hosting/ They keep rebuilding their Gatsby app every single time they add a new product?
To be honest I acknowledge there is an obvious lack of good literature about _design patterns_ that applies specifically to JavaScript. The main problem is that writings on the subject tend to focus on a OO _only_ approach and so, a lot of it, doesn't translate well when you have additional options that the context in which the original book from Gamma et al. is based didn't have. (e.g. first class functions, which Java didn't have and does simplify a lot many of the original DP) It is also very hard to give you generic advice, not knowing where you're currently standing. Maybe the best advice I can give you is: - Search for Fundamental Principles (separation of concerns, clean code, simplicity...). Those always apply, so great. But they can be a bit _abstract_ so they will take time to fully absorb, so not so great. - Do learn about OOP, its principles, its goals and its mechanisms. But do _also_ learn about other paradigms, such as functional programming. Many of the goals are the same, but their principles and mechanisms will differ. Be patient. Take your time to understand each well, and then compare each approach's strengths and weaknesses. - When you have all of the previous, then _do_ read about design patterns. I don't care much if you read a Java book (HFDP is a pretty good one) or Addy Osmani's that uses JavaScript or one that uses some other language/platform. It won't matter _that much_. **But** you should approach the subject with a critical eye. Understand that, most probably, the patterns you're going to read about make sense in a particular and specific context. Compare that context to yours. See if your context provides alternative, simpler solutions. It may very well be so. So keep that critical perspective and don't assume too much. When in doubt, seek alternative sources (specially those that apply better to your context, of course). (For the first 2 points, there's a lot of literature. And the good thing is that it's pretty much language agnostic.) In any case, I will repeat that it is hard to give you such a generic advice without knowing where you're currently at nor the needs or goals you have. I hope this helps in some way, but I'm afraid I can't be more specific.
Can’t be done, and it’s infuriating.
So I have to upload them if I use drag and drop?! That's such bullshit -.- I don't want that.... Can I assign the files to a single, multifile input?
Can I post a whole GitHub Org.? https://github.com/webextension-toolbox
Yeah but, and I love to be wrong here, the files won’t be submitted along with the form.
https://github.com/hyperhype/hyperscript
Nice work! looking forward to more examples or demos.
Step 1 - Duplication Just duplicate the code, yes. Then modify what you need in the second copy so that it works on the second element. Step 2 - Comparison Compare both pieces of code. Focus on what varies between them. Mark those things as candidates to be arguments. Step 3 - Abstraction/Extraction Write a third version of the code where those things that vary are extracted as arguments. (e.g. the id of the element, the shape used, the colour...) Step 4 - Clean up It happens when you're trying to do step 3, that you'll have some amount of internal, local duplication. You may have things like... if (shape === 'square') { ... } else if (shape === 'circle') { ... } else ... ...and there will be some duplication there and besides code like that is ugly. So give it another go. Do steps 2 and 3 but now on a local scope. Compare the blocks, extract the appropriate abstraction, re-write. Rinse, repeat. ---- In time, when you've done this a number of times, you can avoid Step 1 and do Step 2 in your mind and go for Step 3 directly. Until then do as explained, even if this seems tedious.
Thanks for the feedback! Adding examples is already on our roadmap. We'll add more demo code in the following weeks.
I didn't really get from the article what exactly Angular Web Components are and where exactly they would fit in. Anyone care to give me your two cents on what is this is and where it might fit in? 
 function removeSmallest(numbers) { const min = Math.min(numbers); return numbers.filter(item =&gt; item !== min); } 
I really like the background sound of your game. what is this song?
Thnx but this dosnt work ,because if this instruction f there are multiple elements with the same value, remove the one with a lower index. This was the result Wrong result for \[2, 2, 1, 2, 1\] - Expected: '\[2, 2, 2, 1\]', instead got: '\[2, 2, 2\] 
http://www.computinghistory.org.uk/userdata/images/large/47/64/product-104764.jpg
You might want a promise-reduce, which would look like this: const assignCustomFieldsToProduct = (product) =&gt; { return axios.get(`${CUSTOM_FIELD_URL}${product.id}`) .then((response) =&gt; { return { ...product, custom_fields: JSON.parse(response.data) }; }) .catch((err) =&gt; { // Do something with this error. // My behaviour here just skips the one that failed return requestPromises }); } const assignCustomFields = (productsMissingCustomFields) =&gt; { return productsMissingCustomFields.reduce((requestPromises, product) =&gt; { return requestPromise .then((productsWithCustomFields) =&gt; { return assignCustomFieldsToProduct(product) .then((productWithCustomFields) =&gt; { return productsWithCustomFields.concat(productWithCustomFields); }); }) }, Promise.resolve([])) } This will do all the requests in order, but also shouldn't lock up your javascript thread. To use it in your code, it would look something like this: let finishWizard = async () =&gt; { console.log('selections:', wizardSelections) const CUSTOM_FIELD_URL = `hidden` let wizardContainer = document.querySelector('.wizard-container') removeEl(wizardContainer) const API_URL = 'hidden' let products = await axios.get(API_URL) .then((res) =&gt; { return JSON.parse(res.data).data }) .then(assignCustomFields) }; Note, this is going to be slower than `Promise.all` which I see recommended by other friendly users. Implementing that could look like this: let finishWizard = async () =&gt; { console.log('selections:', wizardSelections) const CUSTOM_FIELD_URL = `hidden` let wizardContainer = document.querySelector('.wizard-container') removeEl(wizardContainer) const API_URL = 'hidden' let products = await axios.get(API_URL) .then((res) =&gt; { return Promise.all(JSON.parse(res.data).data.map(assignCustomFieldsToProduct)) }) }; I'd recommend only loading the data as it's used. I can't speak for how your app is structured, but if you're using some component-based framework like React or Vue, you could have a product component that loads it's own custom fields as it's mounted/added to the dom. Also, are you able to do your filtering, as mentioned in your PS, before grabbing the custom fields? That could definitely reduce your request count.
Yeah I finished reading the whole spec then updated my post! Try now
So, may be you'll provide some info about your browser, device?
Maybe they see it as removal of non-public API. They mention "stale" which suggests that this is likely the case. In essence, this is still a breaking change.
&gt;Awesome thnx, but can you tell me why where is the problem in my solution(except the lack of modern js)
&gt; compare === [] This will always be false. If you want to check to see if its an empty array try compare.length === 0 Although, as compare only needs to be a boolean value (as its basically a "look ive found it so dont take them out anymore") it could just be a false value that is set to true instead.
Thank you
NativeScript is not there, I'm about to crai
If by angular web components you mean angular elements that's supposedly the plan. I haven't used them yet so I can't say how well it works. Also note though that to be used like that the components have to have been specifically compiled as elements. You can't just grab any random angular component.
This looks fantastic. Thanks for sharing!
It's angular internally but externally you can just treat it like a random web component. No need to actually use Angular yourself. As I mentioned above I haven't used them yet so I can't say how well they work. I've only read the idea behind them.
Material Components for Vue.js https://github.com/matsp/material-components-vue
So youd still need to add a polyfill for web comlonents. i dont get the gain
👍🏻 cheers
&gt; I guess so you dont need to rewrite the app in angular 6? Yes, and the recommended upgrade path is basically "run two version s of angular and try to sync them" which can be pretty chaotic. This way you can incrementally rewrite components (hopefully you're using AngularJS1.5+) into modern Angular, compile to web components and iterate. With all that maybe one day you won't have to AngularJS.
i wish we stop refering to it as angularJS and angular, what happed to just using versioning? :(
Yea I guess use-case does exist out there with all the angularjs apps. I guess I've been fortunate enough to be able to start some projects from scratch recently.
That's pretty good stuff. I just had a quick look and it'd be good if the "chips" components would be "button" elements. :) That's more accessible. But apart from that 👍🏻
Untested code: const pattern = RegExp(` ?(${arr.join('|')}) ?`, 'i'); wordArr.map(s =&gt; s.replace(pattern, ' ')).trim(); Basically, first create a RegExp pattern like `/ ?(of|the|it) ?/`, then map all strings to new strings that's been replaced and trimmed.
Problem is I also want to create a tar file.
It's possible they do it that way if they have a catalog that doesn't change often. You can also use the route to fetch data on-demand on the client side.
They are completely different frameworks.
Have you tried stackoverflow?
then give them diffrent names? &gt; if it quaks like a duck and walks like a duck one of the things people where complaning about when the angular 2 version where anounced where that it had nothing to do with angular 1. why not just call it somthing else then?
I’ve used the same components (literally just functions written in a reusable fashion) in many of my projects. Then the rest of the code is just glue to stick it all together. Or new components I need for this particular project. 
Not OP. The visual difference between default and custom is minimal. The custom one grows a little when hovered. I guess that's why some people may think it doesn't work.
Twilight techno by Dimrain47
I never understood the purpose of a pure static generated web 'app', other than a demo on github.io. The problem is that, your client who pays you to develop the web app will eventually need some change. There is no such a thing as a static web app/site that will stay static forever. At that point, they have to pay you again to simply rebuild the web content for them, for just adding a product or a page, that could be done by the client itself with a dynamic app.
Hi ifyday It looks like you're already *almost* there. Have you tried moving the **embed.init** lines into the event listener function? e.g: let show = false; triggerBtn.addEventListener("click", function() { console.log("Clicked"); embed.init({ show: show }); });
Ultimately the why was because of marketing. At the time, it was "angular vs react". They had the brand recognition, they didn't want to lose it. Plus they probably saw Angular 2 as fixing all the mistakes of Angular 1. And it still sort of is "angular vs react", so their marketing worked. But you're right. I haven't met a dev who doesn't feel the same way as you regarding the name. 
``` wordArr.map(phrase =&gt; phrase.split(/\w+/).filter(word =&gt; !arr.includes(word)).join(' ')) ```
Nice post, thanks. I have a question, how do you do the conversion for .333 to 0.01010101. I get the part where you can make numbers up to 256 using a byte/8bits, but not so much about how you go from .333 to 0.01010101. &amp;nbsp; Also I could probably google this, but you explained everything else so well I figured I'd try the lazy way. 
Happy News, you are wrong indeed :D it worked (allthough, I only tried in chrome)
 console.log(`name: ${this.name} relaxTime: ${this.relaxTime}`);
No schedule, but I have been thinking that a combat demo of sorts could be feasible soon. 
Some people don't like Typescript. 
A lot of people just don't realize they can transpile plain .js files using TypeScript. Or they assume they're using a Babel plugin for something TypeScript can't do. Which is sometimes true, but usually not. (at least in my anecdotal experience)
You need to have CORS enabled on the S3 bucket itself: https://docs.aws.amazon.com/AmazonS3/latest/dev/cors.html#how-do-i-enable-cors
lots of reasons 1) they might have bought into babel long before typescript existed 2) babel offers a lot more than just es6, or even later es versions. you can add plugins that cover things that aren't supposed to be in javascript. 3) they might be in flowtype 4) they might be relying on other things that rely on babel 5) they might be part of the react ecosystem, where it's normal
because many of us doesn't come from world of strict typed languages. There's plenty of pros and cons for both approaches. Simply if strict typing was best solution - you wouldnt find loosely typed ones. I for example don't use strict typing. Such discussions end up with flamewar based on prefferences because of the reason above. It's basically apples vs oranges. Either has pros and cons.
Sorry. What does this give me that styled-components doesn't?
In short, it is no halves, one quarter, no eighths, one sixteenth... 
Don't worry, floating point numbers don't really work the way he explained, so the bit representations aren't really what he said they are. You can read about [floating point arithmetic](https://en.m.wikipedia.org/wiki/Floating-point_arithmetic)from wikipedia.
Non-Mobile link: https://en.wikipedia.org/wiki/Floating-point_arithmetic *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^197228
I know, it was an example of how inconsistent his code is. Why not use template literals, but do use Class while they're in the same spec? Using require, having a *very* inconsistent code style, etc. just screams bad exple imho.
 const myList = ['The abominable bride' , ' The last man standing' , 'Last of us']; // Create an array of arrays of words const splitList = myList.map(s =&gt; s.toLowerCase().split(' ')); // Flatten the array so that you have an array of just words const allWords = splitList.reduce((out, src) =&gt; out.concat(src), []); // Make sure that each word in each array only matches once const undupedList = splitList.map(wordArr =&gt; wordArr.filter(word =&gt; allWords.indexOf(word) === allWords.lastIndexOf(word))); // Create strings from each array of words const outList = undupedList.map(wordArr =&gt; wordArr.join(' ')); console.log(outList);
Well, there has got to be a better solution, but this [seems to work](http://jsbin.com/jafagiyeba/edit?js,console). First, turn the array of phrases into a 2-dimensional array of individual words by `split(' ')`. This gives you something like `[['the', 'last', 'supper'],['house', 'of', 'dreams']]` Then the rest of the code is just looping through each of the items in each of those two arrays, and comparing them to the list of 'stop words'. We remove the words if they're on the stop list, and at the end of the whole thing we smoosh what's left of the arrays back together to produce our output. const stops = ['of','the','it']; const phrases = [ 'the last supper', 'house of dreams', 'it', 'the last of us'] const splitPhrases = phrases.map( phrase =&gt; phrase.split(' ')); const filteredPhrases = splitPhrases.map( splitPhrase =&gt; { stops.forEach( stopWord =&gt; { splitPhrase = splitPhrase.filter(word =&gt; word != stopWord); } ) return [splitPhrase.join(' ')].reduce( (accumulator, currentValue) =&gt; accumulator.concat(currentValue)); } ); The output of that is: `["last supper", "house dreams", "", "last us"]` I would not stand by this, but it's my day off, so that's the best I'm gonna do. :)
1. You can use both together, the 2 projects are not antithetical 2. Babel supports some early features that haven't made it to Typescript yet, such as [optional chaining](https://github.com/Microsoft/TypeScript/issues/16) or the [pipeline operator](https://github.com/Microsoft/TypeScript/issues/17718)
Glad you liked it! =) The reason 0.333333 is `0.01010101010101010101` is because this decimal fraction happens to produce an infinite binary fraction. You can recreate it on paper by doing this: * Take the number and multiply it by 2. * The result will be 0.666666 * Take the whole number part (what's before the decimal point) and it will be your **first** binary digit. * Take the factional part (what's after the decimal point) and multiply by 2 again. * The result will be 1.333332 * Take the whole number part and it will be your **second** binary digit. * Take the factional part and multiply by 2 yet again. * The result will be 0.666664 * Take the whole number part and it will be your **third** binary digit. Keep going until you run out of numbers and reach zero. You will end up with: `0.01010101010101010101`.
I'm almost sure that he watched demo from phone/tablet, where scrollbars are really browser's default (and not displayed when no scrolling happening)
It's the same math as you would in decimal, just in binary. It's weird, but you can do all the same math using a different base. It's hard to show in text, but doing it "long division" style is easy if doing it by hand. Step | In Decimal | In Binary --- | --- | --- | Start| 1 / 3 |1 / 11 Add decimal places| 1.0 / 3 | 1.00 / 11 Divide and separate remainder| .9 / 3 + .1 / 3 |.11 / 11 + .01 / 11 Simplify| .3 + .1 / 3 |.01 + .01 / 11 Repeat for remainder | .3 + .03 + .01/3| .01 + .0001 + .0001/11 Simplify | .33 + .01/3 | .0101 + .0001/11 Repeat | .333 + .001/3 | .010101 + .000001/11 Etc. | Etc. | Etc. Side note: in the academic game ["Equations"](http://agloa.org/equations/) in advanced versions you can say certain numbers are, say, base 8 or base 12. What NORMAL people do is convert those numbers to decimal then do the work that way. One guy decided to do several steps of work in base 8, and when the judge came to see if his answer was correct, the judge couldn't begin to follow his written work and awarded the point to the other team. 
Yes I did and it works until I try to click the button once more to toggle it
Thanks again, appreciate you taking the time.
Thank you!
7) they may simply not think that strict typechecking and all the rest is actually that useful 8) they may think that TS is not quite production ready
This is really cool, but from Mozilla’s pages it seems like there’s no full browser support for Web Components yet
already do &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;CORSConfiguration xmlns="http://s3.amazonaws.com/doc/2006-03-01/"&gt; &lt;CORSRule&gt; &lt;AllowedOrigin&gt;*&lt;/AllowedOrigin&gt; &lt;AllowedMethod&gt;GET&lt;/AllowedMethod&gt; &lt;AllowedMethod&gt;POST&lt;/AllowedMethod&gt; &lt;AllowedMethod&gt;HEAD&lt;/AllowedMethod&gt; &lt;MaxAgeSeconds&gt;3000&lt;/MaxAgeSeconds&gt; &lt;AllowedHeader&gt;Authorization&lt;/AllowedHeader&gt; &lt;/CORSRule&gt; &lt;/CORSConfiguration&gt; 
That's not how floating point arithmetic works, and your bit representations are wrong. First of all, the way you explained it, computers would store the place of the decimal poimt without using any space. In reality floating points units consist of sign bit, exponent and significand. When adding 100, you can't just slam the bit representation of 100 as integer on the float. 
Just so were on the same page...you know youre never changing the value of show, right?
5 is irrelevant. TSX is first class citizen now.
8 and 9 contradicts itself. If you're that cautious that such mature thing as TS isn't production ready, how the hell you use stage 0 features.
What’s one pro of loosely typed that doesn’t boil down to developer laziness?
Gatsby's working on a cloud infrastructure allowing modular/incremental builds instead of traditional atomic builds for statically-generated sites/apps. Might be smart to keep an eye out for it!
TL;DR: avoid non-integers unless you know what you are doing.
&gt;Except unlike us, they counted not the fingers themselves, but the phalanges in each finger. We have 12 of those on each hand (excluding the thumb, which they instead used for counting.) And since there are 5 fingers on each hand, 12 \* 5 = 60. I dont understand this bit.
Just to add some clarity to my question. The effect trying to achieve is similar to what intercom has with their chat embed script. But instead of loading the app with the app launcher, a button on the host webpage is used to initialise the script and another button within the close app is used to close the app.
Ahh, just noticed that you are using the S3 Rest endpoint not the website endpoint. Try using one of the website endpoints like: `https://&lt;bucket_name&gt;.s3-website-us-east-1.amazonaws.com/test-dash/test.mp4`
See how each of your fingers has 3 bones in it? If you use your thumb to count them on the remaining four fingers, you will get 12.
That's converting it to base2, binary, but that is not how computers do floating point math. You couldn't even store what you do in 64 bits, because you'd also need to store the place of the decimal point. Instead of downvoting, you should probably just delete your post instead of spreading misinformation. If you disagree, we can solve this in easy way. Would you mind converting this to binary for me? 1.7976931348623157e+308 It's the max number you can have in javascript. It's also stored with just 64bits, so I think you see the problem with your way.
I'm not downvoting you, unbunch your panties. Be as it may, this is the simplest way I found how to explain this. Please feel free to write your own article where it is explained to beginners in a better and more approachable way. I will be the first to give you an upvote.
5 fingers x 2 hands = 10 hence base 10; 3 phalanges x 4 fingers(thumbs are excluded) x 2 hands = 24 ..how did it become 60?
3 phalanges * 4 fingers = 12 Once you reach 12, you use a finger to "store" that 12. 12 * 5 fingers = 60
Oooh. They used a fsd.
If you know that this isn't even close to correct, then why post it? Especially since you're saying that senior developers should already know this, when in fact most of what you posted is false. There's already tons of material on how floating points numbers work. If you wanted to make it simple, you should have just skipped all the binary representations, as they are all incorrect, and will just read to confusion if someone thinks that floating point numbers really work the way you describe.
That's exactly why it's not for seniors. You have no need for heuristics. Now, since you obviously are in fact the type to go after schoolteachers for "lying" to their class, let me just post an update to appease you. Hopefully then people will quit downvoting you for being obnoxious. =)
Why are you trying to play some kind o victim here? You explained something completely fictional, which can't really be put to use in any way I can think of. No one can use it to anything useful, because it's so far from the truth. Then you act like it was obvious that you're just trying to make it simple. Anyway, you're clearly speaking like this is the truth, "computers store", "computers do", which they don't. You should make it clear that this is not how computers work, but this is just to simplify things. As you can see, there's already people who think that this is how computers really work, and that probably was not your intention. After all, not knowing something is better than thinking that you do, while you really don't. If you're trying to teach people something, you shouldn't be offended if someone points out that you're doing exactly the opposite.
Dude, once again, calm down. =) I'm not a victim, I'm not mad at you, everything is awesome, life is good. You complained about being downvoted, so I told you why I think it's happening. I don't care one way or the other, but you seemed to be upset over it, so I tried to gently explain why that might be happening. =) Relax. This stuff is useful. I understand it's not useful to you. Nor was it ever intended to be. As I said twice now, you are not the target audience. And for real, not being sarcastic or anything, I am actually interested in how you would try to teach this in a simple way.
different people can have opinions that are in conflict
whether tsx is a first class citizen in babel won't matter to whether react people will choose babel over react
Interesting opinion! I've never disagreed more. Writting good code in dynamically typed language requires more awarness, consistency and knowledge from developer. I am more keen (if I have to) to call the other side lazy. But I'm not going to join pointless flamewar of pointing finges and calling people names. Instead I'll leave a link that explains quite a lot and (mostly) contains gentlemans discussion https://softwareengineering.stackexchange.com/questions/38002/what-arguments-are-there-in-favor-of-weak-typing
In Babel? What? I said that using TypeScript with JSX (tsx) is perfectly valid and even preferred way to write react (for example, Reddit here rolls here as react redux on typescript). You then ditch Babel for ts compiler. TS does your JSX transforms.
In JavaScript everything is a floating point number 🤔
Real TLDR-- floating point arithmetic has always had precision errors in every language, and testing for equality with them has always been futile. There's a reason why in every test suite for many languages there's a prebuilt assert function for testing if two floats are almost equal with a default epsilon of 1e-6 or 1e-7-- because they almost never are exactly equal because at some point you get loss. This isn't a javascript thing, it's a programming thing that beginners have to get used to. It's usually one of the first things taught (how integers are held, binary, hex, sometimes octal, and then the composition of a float/double)
I have no idea how to teach this simple way, I'm sure you'd be better at teaching it, I'm a horrible writer. Overall this post was nice to read and kept things interesting, but it would have probably been better to stay at integers. Or maybe by explaining the same thing about floating point numbers without bit representations. You said that people could apply this to real life, but I'm not really sure how? They can't apply this to bit twiddling, as that's not how they're represented. This could lead to many false assumptions though. In that sense this isn't the same thing as Euclidian postulate at all, since if you expected the bit representations to be like that, you'd always get wrong results.
Very late reply commenting on the non-hoistability (cool word :D) of `const`. At first, I was very annoyed by this fact but I just couldn't resist using arrow functions that way. Over time a specific pattern emerged to emulate hoisting: const MY_CONST = 100; const globalValue = 'hello'.repeat(2); const main = () =&gt; { const r = foo(2 * MY_CONST); const s = bar('x'); console.log(r, s); }; // ... definitions const foo = (n) =&gt; { const x = helper(n + 1); return x * 2 / anotherHelper(n * 4); }; const bar = (c) =&gt; { // ... doing work return anotherHelper(c.charCodeAt() - foo(9)); }; const helper = (n) =&gt; { /* ... */ }; const anotherHelper = (n) =&gt; { /* ... */ }; // ... definitions main(); `main` is the obvious entry of the whole program. It's actual execution is on the bottom of the file though. This means that every single arrow function has been declared just before `main` is executed. All those functions can reference each other regardless of their position. Of course, this might be a totally different coding style you have to adopt but I find it quite neat! Greetings
Love the simplicity. 
Give the LI elements a different background colour to see where they actually are. Where you get the UL, there is no LI so you won't be able to get it's data.
what does that have to do with a react person choosing babel for react, which was the #5 you were saying was invalid
Did you try changing the value of **show** in the click handler? let show = false; triggerBtn.addEventListener("click", function() { console.log("Clicked"); show = !show; embed.init({ show: show }); });
Sure, I'm happy to explain my line of thinking. Let's say someone is just beginning to dabble in JS, tries to compare these two numbers, gets a `false` and doesn't understand why. Armed with this simple heuristic they will at least be pointed in the right direction. They will become aware of the fact that decimals don't always play nice, they will know that it's because of how computers store numbers, they will become aware of binary as a concept. Most people in this sub aren't computer scientists. They are mostly just some folks who are trying to dabble or maybe went to a bootcamp at the most. This is why I didn't post it in /r/programming where it would in fact be useless. People who sat through 4 years of algorithms and data structures, don't need primitive explanations. I think this angered you because you took it as misinformation. And again, you are right, if we approach this pedantically — this really isn't how float64 values are stored. But heuristics are still very valuable and valid educational tools. Think about when you were little and wide-eyed and sat in class and believed EVERYTHING your teacher told you. Was your teacher a liar? No. And yet a lot of the stuff she taught was wasn't, exactly the truth. It was enough for you as a newbie human. Eventually it served it's purpose and you went on to learn the truth. Or maybe just the second, third, etc. level of a heuristic. You weren't deceived and betrayed, you were just taking it one step at a time. Anyway, I hope you get where I'm coming from. There's nothing at all malicious about my post. I really do believe it would result in quite a bit of good and very little harm if any. Cheers, man!
https://www.sitepoint.com/event-bubbling-javascript/
so... whats the reason you guys can't build it ? lol There are plenty of javascript courses and tutorial online
Well, as long as they are not-too-big integers, then you know what you are doing. For example, instead of working with dollars and storing cents as hundredths, work with cents instead.
too many javascript developers flooding the market.
Developers _should_ be lazy.
My friend learned it in 3 months and she got hired with a 6-figure salary. She's also generally incredible so I'm not sure if that's an indication.
I don’t think anyone was arguing that all of the above apply in very situation.
[removed]
In a choice between spending time writing code according to strict types and spending time building features, I'd go with the latter. Assuming I'm working with an api I don't control, where I may not even know the schema (not as uncommon as you'd think), fighting with types instead of building the project is a sure fire way for me to get burnt out and frustrated before I've even got going (especially for proof of concept ideas and prototypes).
Xaxaxaxaxa is what is often typed as the English equivalent of hahahaha... Besides, I'd say it's more of a 'zah' sound.
\#javascript on freenode would be a good place to ask.
I thought that using js objects to define style info was already a common practice? It's one of the default ways of styling components in react and react native (but without wrapping anything in a CSS function).
yes, but there's different kinds. there's being okay with an upfront cost now so you can be lazy later (TypeScript), or being lazy now and having to do extra work later to make up for it (vanilla). one is smart laziness, one is dumb. even the dude above who's all about non typed says it 'requires more awarness, consistency and knowledge from developer'. once you compound that with being on a team that kind of thinking easily leads to a mess that no lazy developer is going to fix.
The range of knowledge of JavaScript each job needs varies a lot. There are places where just knowing html + css and a little JavaScript will carry you through and places like where I work where you NEED to know the language pretty well and six months probably wouldn't cut it unless they were intense. The first kind will make you comfortably lower middle class - middle class. The second pays A LOT better. You can definitely work your way up though. 
Being a great developer will get you a job. New developers never have enough experience to be successful right away so when they are hired, they are hired on aptitude not current skill set. At least that's how I do it.
For professional JavaScript developers there is only one relevant answer in that link, and the only benefit it talks about is writing less code.
For proof of concept and prototypes I am working on solo, I might be inclined to agree, but I've had the opposite experience when working on a team on new projects. I find using strong types forces everyone on the team to agree about the concepts and the shape of the data and that it is easier to review as the early project progresses.
That's.... I didn't know. 'Zazazaza' is jarring, though, like straight out of a manga...
Thanks !
I think the Express, MongoDB, NPM, Node, etc... side of things are really stable. I think that building an API with these tools is so convenient, popular, easy to find resources for, and well documented that only something really big would destabilize it. I think the chances of front end becoming destabilized are much more realistic and immediate. Especially since most of the people in that space seem to, themselves, clamor for these abrupt and sudden changes.
Your experience may vary, but I did a 3 month intensive full stack web dev Bootcamp and got a job making close to 6 figures after a month of completing it. I had no previous coding experience, but a lot of other professional office experience doing marketing/social media. I’m also a people person so being able to talk to people probably gave me an advantage. Also, I was able to devote a TON of time to the Bootcamp (50+ hours/week) while my wife supported us and was one of the top students in the class. Programming just clicked with me, and I took learning it seriously. You get out what you put in. 
Yes, is it possible! :)
But most of them are "developers"
most of them are pompous "fullstack" ass clowns who don't know their own ass from a hole in the ground.
this doesn't make any sense to me when i read it.
If everyone else around you is an ass clown...
naah. its a millennial thing for sure.
TIL that phalanges is a real word and not something that Phoebe made up to stop Rachel from leaving for Paris.
What in the name of Donald Knuth are you trying to do with this?
You have a loop in a loop in a loop... that’s an O(n^3) algorithm. Best to put those blacklist words in a hashmap, and check the map for their presence while walking the original array. That’ll give you O(n) performance. 
Dude... You are really negative and aggressive in a majority of your posts on Reddit. From your comments it really seems like you are hurting. I'm sorry about your dog, but taking it out on other users is not going to help you at all. If your comments are any indication of how you treat people in real life, then you need to do some serious self evaluation. You may come to realize that maybe you have been the cause of the things you are upset about. Do I know anything about you? No... I can however see the anger you convey in your comments and I know that is not a good way to live. 
[fs.readdir](https://nodejs.org/api/fs.html#fs_fs_readdir_path_options_callback)
Which bootcamp did you take? If you don't mind me asking. 
2018 June\* overview. This is already out of date.
Just want to gauge this subs opinion: Does anyone agree that we should *not* bundle npm with Node? npm is a private, for-profit company and it is my opinion that we should eventually move away from npm infrastructure. Also I’ve used pnpm quite a bit and it is excellent. Much faster than the latest version of npm (and Yarn is still faster than npm too, and has yet to fuck me). 
Simple answer, will the following lines work? fs.readdir(dir, files); Then, in the command I use the following. var imageId = Math.floor(Math.random() \* files.length);
Well, you'll have to learn HTML, CSS and JavaScript. If you go the full-javascript route (which you can with React) maybe it'd be easier for you, given your background.
Y u heft to be mad.
Can you elaborate a little more by what you mean by full-javascript route? Do u mean to learn javascript, jQuery and react ? 
fuck you nigger.
Regina Phalange
Use behavior subject for map, and simply use next when you need to update the value.
May you please specify which parts are misguided in Addy's book?
First of all, TypeScript can only transpire a small number of the JavaScript features that TypeScript can. See the Kangax table: http://kangax.github.io/compat-table/es6/ Babel 71%, TypeScript 59%. Secondly, if you're using Visual Studio Code, you can turn on TypeScript type checking on plain ole JavaScript with a user setting: "javascript.implicitProjectConfig.checkJs": true Then you can add type information to your JavaScript using JSDoc comments. You can use it to define custom types, union types and event type casting. Because they're comments, no need for a build. And because they're just comments, they go away during minification. In fact, Microsoft uses JSDoc comments in the core d.ts files they provide to enable richer intellisense. You get all the benefits of types, including intellisense, refactoring, code completion, in regular JavaScript. That means you can use the latest features supported by Babel today, instead of having to wait a few years before TypeScript supports them.
The underlying logic doesn't really matter, but there are a few things to note here. The handle function returns the argument which is an object that is returned by on(). unhandle() does the same thing. The main takeaway is that the callback function is closing over the variable that represents itself. It's very clever, but it took me a while to understand. I wasn't sure if this was fairly common in the javascript world, but I'm starting to think that it's not.
if you wrote code like this for me i'd take you out back and shoot you in the back of the head.
In hindsight, it's not very complicated at all. Imagine assigning setTimeout(cb,s) to a variable, and using it in cb. I don't think I would go that far.
You need to learn good old. Vanilla. Javascript. If you want to go with react, don't even think about jQuery. You don't need it. What you do need though is a solid foundation in HTML, CSS, and Javascript particularly ES6.
He'll educate you on how this is proper too. lol
Can agree with 7. Strict type checking know helps at dev time and don't do shit at run time. At least not in the TS World.
Just to clarify, I don't know if this is all that common in javascript. Hence my uncertainty if I should even advocate something like this. However, to simplify what it's doing: Imagine assigning setTimeout(cb,s) to a variable, and using it in cb. But take that up a notch and have a similar function return an object or a function, and do stuff with it inside cb.
I'm currently enrolled in a coding bootcamp and while its kicking my ass, I do feel good about what I am learning. I also have an arts background and I can honestly say being able to speak to your work, background, portfolio (both personal portfolio website and github) will help you a long way.
Where I work as a technician the devs are switching from a lot of c# to more Javascript (less server side work now that we are running more computers) so that's what I'm learning to keep up. 
&gt;He is correct in saying that floating point numbers are actually stored differently than the way in which I described it. Which is exactly why I said that senior developers are not the intended audience. I will accept that your post is fine for beginners who just want a surface level of understanding of this all. But in reality, knowing how floating point numbers work in binary is something that any Junior or Mid level developer should be able to understand, and I would urge anyone at this level to read up on exactly how it works. A great resource is [the wikipedia page](https://en.wikipedia.org/wiki/Double-precision_floating-point_format), but if you want to go even deeper take a look at [What Every Computer Scientist Should Know About Floating-Point Arithmetic](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html). Your post sounds very assertive of how things work without mentioning where you leave out details along the way and I can see a lot of people coming into this post and reading it without knowing all the mistakes/omissions in the post and they will carry this into their careers with an incorrect mental model of how it all works. In addition, while your explanation of why `1/3 !== 1/3 + 100 - 100` is fairly reasonable, it doesn't explain why `1/3 !== 1/3 + 1/4 - 1/4` or why `0.1 + 0.2 !== 0.3`. After all, these numbers are very close to each other, so their inequality is not because you've lost 6 decimal places by adding a larger number.
Post a fully working code in jsBin or jsFiddle. i.e. without missing anything.
Once you know the basics and are confident enough to learn on your own, I would just start using web resources. Unless the grade matters to you, I wouldn't bother retaking it. There are a lot of nuances to JS just like any language, and sometimes you just have to build with the tools you know until you run into a problem those tools don't work on. Then you will start to unravel other parts of JS that you didn't think you knew.
With that given code... Replace: let show = false; With this: let show = [false]; Toggle it with: show[0] = !show[0]; Within the `init()` function, check it with: if (initArg.show[0]) { //... } else { //... }
I think the best language to know is *English*! (Assuming you know your native language well) 😉
I am sorry but as I read this the first thought that went through my mind was **How much wood would a woodchuck chuck if a woodchuck could chuck wood? ...**
Your code doesn't illustrate or match the title of your post or it's description. What's the source code for `this.handle`? You're basically handing us a locked box and asking us what we think of it's contents.
Cause I may not care for next layer of bs that’s stand in the way of writing code. I also came from strongly typed language and I like a freedom that I have now - no it does not translates into uncountable errors.
1. You can find these answers easily on Google, why are you even asking here? 2. It's two lines of code, why don't you run it and see if it works as you intend? 
Thanks for posting that link, and I'll be the first to admit, those theorems are above my head right now. I'd have to spend some time studying up to them.
Yeah, the second link I posted is very high level, and I wouldn't say you need to understand that. I just posted it for those who wanted to learn more.
Look at the position you want to work as. Look at where you want to live. Look at companies you like in that area. Look at what languages they're hiring for. Learn that one. 
When I got back into JS I paid for a subscription at egghead.io to learn modern JS. How I first learned JS is a little harder to answer because I've been using it for really minor stuff since the late 90's.
Better syntax. The name is pretty bad though, he must have heard about electron and this doesn't have much to do with it.
Congratulations JavaScript community, you have discovered floating point numbers.
Large web development teams continually need junior developers - some of which don’t even need any JavaScript skills.
Those are inline styles, so the style is duplicated for every component (worse performance).
Java
didn't make a screen of it, but here's one with mouse used [Imgur](https://i.imgur.com/B2dAGtt.png)
How do you test boot camp devs for aptitude?
I specifically dislike type checking, interfaces, classical inheritance, and the like. Those systems encourage massive amounts of boilerplate code designed to prevent errors I rarely, if ever, personally make. If you can’t program without them, then by all means. But then, if you want to use all that, why not write it in Java, c++, or some other, much more vetted language and then compile that to js for browsers?
Don’t ignore the costs associated with types, interfaces, classical inheritance, and the like. Spending a lot of time on designing and coding the boilerplate for your type hierarchy, only to have to rebuild it due to unforeseen needs or refactoring. Without those things, there is no hierarchy to maintain, and while you will have to change things, boilerplate will not need to be changed because it isn’t there. If you can design it all perfectly the first time, that’s great. But so too can we build our non strict programs correctly the first time.
On the job.
I think that's a succinct example in why IoC containers are pointless cargo cult boilerplate. The next step from this 122 char container is to just start writing basic factory methods and thus ditch the string identifiers and magic.
I learned on the old Free Code Camp curriculum. Their algorithms really kicked my ass when I was first starting out. After that I read You Don’t Know JS a bunch of times.
Just to piggy back on the idea of if the grade doesn’t matter there are a bunch of free resources online that really go in-depth if you have a foundational knowledge of JS. You Don’t Know JS and Eloquent JavaScript are two that come to mind right off the bat. 
Do remember that with Angular Elements you can use Custom Element inside your AngularJS template - this is the coolest feature in my opinion:) With nginx approach you need to rewrite whole page, with Angular Elements you can change just a part.
On the side as a hobby while doing my CS major. 
As I wrote in the article you need to be aware about few things: * output is dispatched as Custom Event - you need to prepare rest of your code for that * Angular Components are self contained, i.e. they cannot share the state or service Aparat from that I've not encountered any issues with this approach. 
Ah yeah, you're absolutely right. I've seen setups using components which include their own style files in the same folder as the component index.js. Does that have the same performance implications?
Sure. React allows you to build a javascript-only app, since you can create both HTML Nodes and CSS styles with it. It is usually written in JSX (an "extension" of the JavaScript language), but it can also be used in a normal JavaScript environment. JSX has a slight different syntax than JS, cause it allows to write HTML-like code in the JS, but it is transpiled to JS, so React can be used just like any JS library, taking away the burden of learning JSX specific syntax and leaving you more time to focus on JavaScript. I hope it was helpful. Cheers.
TBH, if any programmer do not know about this, he is screwed, sooner or later.
I've not tried it out, but after some googling I've found this project: [https://github.com/skatejs/ssr](https://github.com/skatejs/ssr) Example is using standard Web Components, but Angular Elements is just a wrapper, so it should work.
If they import some kind of style object and assign it to style atttibute, then yes, otherwise no. So if you import css file, that's not inline anymore.
There's probably an NPM module for "close enough" comparing.
&gt; .split(/\w+/) This should be an uppercase W I believe. Or a lowercase s.
Check the examples on StackBlitz (links in the article) - you can play around and see Angular Elements in action. This clears a lot of mystery :)
Ohhh! Forgot that she used it for her fake name too. Never made the connection 😂
You need to use Polyfills - [https://www.webcomponents.org/polyfills](https://www.webcomponents.org/polyfills) If you go to examples in the article (StackBlitz) - please check the Dependencies -&gt; External resources (1st example) or inspect &lt;script&gt; tags in index.html (2nd example).
Looks like it inserts an ad and a tracking script.
Just a regular ad? Nothing sketchy or smth? 
You didnt learn shit if you got a C.
The moment someone writes: arr[0] = 'something'; they lose all credibility.
I'm not really able to tell as I don't know much about how these ads and they're tracking works. To me it seems weird that it makes the ad background transparent and that it loads a different script if the site is running on wordpress. But it might be harmless. It's loaded from blueantmedia.net so if you want to know if it can be trusted you can research them.
I wouldn't bother. I hated my JavaScript courses in college. Learned way more through working and on my own.
[http://eloquentjavascript.net/](http://eloquentjavascript.net/) [https://www.udemy.com/understand-javascript/](https://www.udemy.com/understand-javascript/) [https://github.com/getify/You-Dont-Know-JS](https://github.com/getify/You-Dont-Know-JS) And mostly on the job. 
&gt; They will become aware of the fact that decimals don't always play nice, they will know that it's because of how computers store numbers, they will become aware of binary as a concept. Yes this is the part I agree with. Talking about binary was fine until you moved to floating point numbers. When multiple people asked about how you ended up in something, you should have at least at that point say, that it's not worthwhile to focus on that, since things don't really work that way. While I see what you were trying to do, I'm not really sure it worked that well. Your explanation makes it seem, like you just lose some digits when you add larger number. Like that the numbers were just 64 bit integers with magical decimal point. Which is of course weird, since all numbers in javascript are floating point numbers. It's also not as good example, because 1/3 === 0.3333333333333333 and 1/3 + 100 === 100.3333333333333333, meaning that the error doesn't actually happen in the point where you described. In my opinion, a better example to show the problem would be this: 0.1 + 0.2 !== 0.3, or 0.1.toFixed(56) === "0.10000000000000000555111512312578270211815834045410156250" it would make it clear, that you can't avoid these problems by just using less than x digits. And no, I'm not trying to be pedantic, I'm just saying that you probably could have started form how things really work, and then try to explain that simple way. I'd consider that constructive criticism.
Seems very needy to post such an update here. Keep them for actual exciting features
Thanks for the feedback
Glancing at this, I think it's better to use an event listener and pass in 'e' as a parameter (can be anything, but e is convention). So divclass.addEventListener('click', function (e){ console.log(e.target) } You may find that clicking the button gives you a different result than when you click the div that the button is in, meaning you have to run an if statement. Event delegation is the term if you need to google I'm no expert but I've had similar issues to the point where I avoid onclick= now
Well, this has been discussed a number of times, but the problem is that it's mostly the whole book. Or almost all of it. The book starts with a theoretical introduction to DP. _What is a Pattern?_ is a section of that part and a crucial question to ask, of course. And, unfortunately, Osmani fails to give a good answer. A pattern is composed mainly by 3 parts: - a _problem_ - a _context_ in which the problem occurs - a _general approach_ to implement the best solution for the problem It is _extremely_ important to understand this. Understanding the problem itself is, naturally, essential. It doesn't make sense to apply a solution to a problem it does not apply. It is also equally important to understand the context, because it is the context the one that restricts and defines applicability. The same problem in a different context may simply not occur (e.g. Singletons in Scala are already supported by the language itself, you don't need to implement any solution to achieve that). Finally, it is very important to understand that the third part is not, generally, a precise solution, but an approach to implement such a solution. Instead, Osmani's explanation fails in two main points (it will fail on the third later; keep reading). First it simply ignores context; context is rarely if ever taken into account in the whole book. This results in applying some foreign patterns without questioning if they are applicable at all. Then it focuses _too much_ on the solution. _"Pattens are proven solutions"_, and _"A pattern usually reflects an out of the box solution"_, and similar ideas. He even goes as far as separating the solution from the problem by arguing that they are solutions which "are not tied to a specific problem". Even so, not all is bad in that first part. It is true that DP form a common vocabulary we can use to communicate approaches, and the full structure of a DP (including a mention, the only mention, to context) is shown. The worst thing about this part is that it contradicts itself in various ways (probably because of how it was built from collecting and mashing together various existing writings and blog posts). I've seen various people commenting how this part is too long. I don't see that as _necessarily_ a bad thing. I understand the criticism and understand that some people may want to "jump for the meat right away" but I actually think it is good to spend some extra time explaining the concepts first. It's just that it is not a very good explanation. Then, finally, we get to the patterns themselves. And here the author completely fails to follow his own advice. He presents a collection of _things_, some of which _may_ be DP and some of which are clearly not DP at all. In general, he fails in the same way throughout the rest of the book: Most of the time he just jumps into showing some code without either mentioning what the problem is or what the shown approach aims to provide. Again, DP are _not_ pieces of code. And you need to set up both the problem and the context before you try to offer an approach (not a direct _out-of-the-box_ solution). Not only that, but there's an underlying problem with the patterns presented themselves. As I mentioned, some may be DP, some clearly aren't. It is a collection of some of the original GoF design patterns mindlessly "ported" to JS without care, and a few "new" _patterns_ added by Osmani. Let's just look at a selected few. The first one, the so called "Constructor Pattern". This is absolutely not a design pattern in any sense. It is just a presentation on a number of ways you can create an object in JavaScript. There is no _problem_ to solve here, just a description of the language itself. Similarly the "Module Pattern" is just an overview of various variants on using closures to achieve some _privacy_, as implemented in various libraries (some now outdated) such as Dojo, ExtJS or YUI. A companion to this, the "Revealing Module Pattern" is simply writing the previous thing in a slightly different manner (instead of inline functions you just put the reference of the function that is written above). To think that this trivial change makes it a different thing is absurd. This whole section presenting different module structures written by various (some outdated) libraries, is -again- a blog post inserted here without much of a reason to do so. Following is Singleton. I think I don't need to talk about this one. But in any case it is a typical example of how the whole book goes in general: It completely ignores the change of context. In the original context where Singleton was suggested you just couldn't create objects directly, you always needed to instantiate a class to obtain an object. This is not so in JavaScript (hey, it was shown just a while ago in that "Constructor Pattern" section), but is ignored by the author. It also has a number of additional problems (of various importance): - It doesn't really explain the approach, just shows some code - The code it shows is **bad**. Instead of showing _a Singleton_, he decides it is a good idea to confuse things by directly showing a "good singleton vs bad singleton" as the first thing. The code for the "good singleton vs bad singleton" is unnecessarily complicated and what's more, there are differences between "good" and "bad" which are unrelated to the "goodness" or "badness". The only meaningful difference is lines 42-44 vs line 79. Also, the solution presented is rarely the _best_ approach. Let's jump to, say, the _Command Pattern_. Leaving aside other things (such as the command pattern not being _exactly_ necessary in a language which does support first class functions, as it is, basically, "a polyfill for first-class functions"), the solution presented is a _"[stringly](http://wiki.c2.com/?StringlyTyped) based solution". This is **bad** code. Code like this is routinely rejected in professional environments. I mean, if you really wanted to do the Command Pattern in JavaScript, even [Wikipedia has a better solution](https://en.wikipedia.org/wiki/Command_pattern#JavaScript). One that is still unnecessarily complicated, but at least is not _stringly-typed_ (and it uses modern ES6 syntax). I won't go over the whole book; I think this already exemplifies the general problems that persist throughout the whole of it. There are some other, maybe less important, problems. The thing I commented about just inserting some "interesting" blog post here or there happens a number of times to some extent. He goes on a tangent explaining a more or less related subject for a while. This is not so bad, but it does add to a general poor structure. It's weird, to point out just one example, to casually mention in the explanation of the Singleton how "`getInstance` becomes a little like a Factory method" assuming some fairly non-trivial knowledge on the subject when Factories aren't presented until much later and _Factory Method_ is only ever mentioned in the explanation in one comment in the code. There's also a lot of inconsistency in the examples. Sometimes a pattern will be presented with, say, an example about hobbits and orcs, then a first example shown is about vehicles and colours, the second example about macbooks and memory sizes, and then the final one is an example on interfaces and to-do-items. This is not _terribly bad_, I know, but it does not exactly help compare the various parts. I don't think _everything_ is bad in the book. And the effort spent must be acknowledged. It's just that the result obtained from that effort feels, well... _misguided_ is the best word that describes it. It _is_ an important effort, time was spent writing that, but in the end the result is less than good.
sweet. thanks man!
Now I know the point of using assert() instead of manually writing an if statement...
getElementByClassName returns a HTMLCollection. You need to loop over all elements: Array.from(document.getElementsByClassName(formname)).forEach(function(x) { x.remove(); }); Also make sure that you pass foo as a string, not a variable as you do right now.
&gt; const logs = []; &gt; module.exports = logs; Noob question: How logs would be filled if the function populating it isn' included? If i understand module pattern, you deliver a bundle JS with all the modules and their code on it. Then i don't understand how the array will be populated without the function included in the bundle. 
Yeah, I've taken several. Since I was a JS developer at that time already, I really did not learn much (if anything). I just wanted to have something i can show off. The prof was an old school programmer, but it's obvious that he has never used JS in his career. The course "Advanced Web Development" was basically an introduction to JQuery and nothing else really. 
If this works on other browsers as well I will eat my hat.
The best book on design patterns I have read is [http://gameprogrammingpatterns.com/](http://gameprogrammingpatterns.com/) . The web version is free. This book might not be using Javascript, but the way it is written makes everything very easy to understand. Everyone can imagine what happens in games, so the examples all make sense (at least to me). I tried the gang of four Design Patterns: Elements of Reusable Object-Oriented Software, but it did not work well for me. The head first one [http://shop.oreilly.com/product/9780596007126.do](http://shop.oreilly.com/product/9780596007126.do) was quite a bit better, but Game Programming Patterns is the best. There are a LOT of patterns, and as a previous poster said, the context is everything. If you are using framework then you probably have all the patterns you need built in.
I always wanted to ask if these hours per week are "hours in front of the computer" or "hours of active learning".
&gt; var imageId = Math.floor(Math.random() * files.length); there are better ways to create entropy
I'm not sure I understand your comment. TS's type checking is compile time not run time.
It's an array, it has push.
Basic javascript i learned in 2010 with help of w3schools to use in my php project, time by time it got improved with help of stackoverflow and other work experience. 
Do you mind explaining the floating point part? The Wikipedia page wasn't really helpful at all :/ I understood nothing. Something like OP's style would be helpful.
const canvas = document.createElement("canvas")
Which part were you stuck on? I can explain specific parts but writing up something like OP did would take me a long time.
what do you mean?
I judge enthusiasm, ease-of-communication, and life experience.
The determining factor here is that the put function is checking if chan.length == 0 So if the return value is a reference to a function then the value of the array won't be altered until the go\_ functions invokes it with step.value() Since it doesn't immediately alter the array, the for loop yields 10 items to the array. However if the return value isn't used then the put function will add to the front of the array straight away. The put will then ignore it for the rest of the for loop because the length is no longer 0, so you'd get only 1 item added to the array, not 10. The generator would have one iterator and would immediately resolve to done
Well there's still 6 months to go in 2018
https://www.reddit.com/r/ProgrammerHumor/comments/8tlqo9/javascript_is_getting_real_tired_of_your_jokes/
I like English, it's so clean and very easy to understand most of the time. Just look at the if/else statement. "If you don't know English, then learn English. Otherwise continue with life." I use "otherwise" like a "else" here. But you can just skip that last part and stop at "then learn English".
can you explain why? Doesn’t this just modifies the first element in arr? 
I think jQuery can do it.
Did the same thing sort of. But took a 2 years thing that was very "practically oriented". Got work before the last term started (did finish my education though, no point in missing out of the points when only 1 term left). Didn't go for the job with the highest paycheck though, because I found a place where I really really like the people and the thinking. Never thought a job would be something I would miss over the weekends... Always seen jobs like something half boring that you have to do 8 hours a day. But there where people in my class that struggled, just as you said though. It just clicked. (PS. It doesn't always click after the first week for everyone, some people in the class didn't figure out the concept until the 2 term. Give it time and just keep seeking information/knowledge).
It's the same reason why 0.333333 and 1/3 are not the same number.
That's how canvases are dynamically created. If you want to use the ones you have already in your HTML, you wouldn't dynamically create them since they're already there. Instead you'd just pull them from your canvases array. const canvas = canvases[i]; Which is what you're already using for ctx - something, by the way, you should also have a declaration for in the loop: const ctx = canvases[i].getContext('2d'); or if you assigned the canvas variable from earlier (which isn't even necessary with the above code): const ctx = canvas.getContext('2d');
You don't have to iterate till factors_stop. The factorisation is inversed after sqrt(input) function Factors(input) { input = parseFloat(input); var factors = []; for (var factor = 1; factor &lt;= Math.sqrt(input); ++factor) { if (input % factor === 0) { factors.push(factor); var inv = input / factor; if (inv !== factor) factors.push(inv); } } factors = factors.sort(function (a, b) { return a - b; }); for (var i = 0; i &lt; factors.length; ++i) { var new_element = document.createElement("div"); new_element.innerHTML = factors[i]; document.getElementById("output").appendChild(new_element); } } 
Because it shows that they learned from a book and probably don't have any actual experience. There is literally never a reason to set a specific element on an array. If you're defining one: const arr = ['something', 'else']; and if you're adding to it: arr.push('something');
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
So I don't get it. Why would I use this? It seems like it contradicts itself by saying its framework-agnostic but its built on Express.
It's mostly about how much they've learned in a short window, how they approach problems and if they are passionate about the work, vs just trying to get a paycheck. It's a bit of a fuzzy assessment
It is modular and does not depend on any framework. There is however a module (called "hadron-express") that greatly simplifies creating routes in hadron when using express. You can write plugins for hadron fairly easily (the hadron-express repo is pretty self explanatory) but we plan to create modules for different backend frameworks in the future.
Looks interesting - I see it uses MySQL. Any plans to extend it for mongodb?
Sure you could. I would however rethink the goal a little bit. do not "Learn JavaScript". rather you should "Learn Programming". While JS is incredibly usefull it's quite rare for projects to be 100% JS. If you can jump between languages (just having some fundamental familiarity) then you're a lot more valuable to a company (and a whole lot more employable). I've seen people who "learn a language" or a singular piece of tech (like Angular V1) and become stuck with it, because what they learned was how to use a specific tool (not how to program and be able to switch tools comfortably) meaning that as the development community moves forward they either find it hard to get jobs or only find jobs working on old code-bases
There are APIs in JavaScript (DOM) where objects passed in are also returned, for example appendChild and removeChild. They accept a child node and then return that same node. Doing this allows you to perform some operations with multiple calls in a single expression newParent.appendChild(oldParent.removeChild(child)) But there are no callbacks in this case, which isn't exactly what you're showing. I think your setTimeout example is a better example of this (?) - or setInterval since that would make more sense. setTimeout/setInterval return an interval id that is used to clear the timeout/interval. You may wish to use this within an interval callback to stop the interval from continuing further. let counter = 3; const id = setInterval(() =&gt; { // do something if (--counter === 0) { clearInterval(id); } }, 1000); Here the callback passed into setInterval needs to use the return value of setInterval to be able to clear the interval to prevent it from ... more _intervalling_. What's different here is that id is not passed into setInterval, it's created separately (internally) and returned back to you. But if you look at setInterval as the on function in your example, then imagine some wrapper utility for it (handle/unhandle) then you can start to see a similar pattern. const idList = []; function handle (id) { idList.push(id); console.log('Added interval. Total intervals:', idList.length); return id; } function unhandle (id) { const i = idList.indexOf(id); if (i !== -1) idList.splice(i, 1); console.log('Removed interval. Total intervals:', idList.length); return id; } let counter = 3; const id = handle(setInterval(() =&gt; { // do something if (--counter === 0) { clearInterval(unhandle(id)); } }, 1000)); I wouldn't call this _common_. I can't recall the last time I've seen something like this myself (though that's not to say I haven't). I would think it to be more common that a new function (or _functions_) created from composing the other two would have been a more likely solution.
I think you just got to work on the elevator pitch a bit more. A busy dev like me looking at this stuff is not going to just dive into building stuff with this right off the first page unless you can sell me on why my current SOLID approach is not as good as yours. Also change the name, I keep reading hard-on, which I do not have for this software...yet.
Yeah, nearly every market in every city in the United States will have Java jobs at all levels. Enterprise software loves Java IME. There may be some minor differences where certain regions prefer C#, but Java still reigns supreme. If you want to work in web development, JavaScript is useful to know and continually learn. It really depends on your career aspirations.
As sQu1rr pointed out, you could save a few iterations, especially for larger numbers, by using the square root and inverting the factors The biggest issue that I see with your code, is trying to do too many things at once in a single function. You're parsing user input, doing some math, and then outputting results to the DOM, all in one function. You could also potentially reduce some layout thrashing by building the new DOM tree and then inserting it all at once. Obviously this isn't a big deal for such a small example, but it's not a bad practice Let's refactor a bit :-) ``` function calculateAndPrintFactors(inputElement, outputElement) { if(!inputElement || !outputElement) { throw new Error('Invalid input or output elements') } const number = parseFloat(inputElement.value) const fragment = document.createDocumentFragment() calculateFactors(number) .map(factor =&gt; createTextDiv(factor, factor)) .forEach(div =&gt; fragment.appendChild(div)) outputElement.innerHTML = '' outputElement.appendChild(fragment) } function calculateFactors(number) { const factors = [] const squareRoot = Math.sqrt(number) for (let factor = 1; factor &lt;= squareRoot; factor++) { if (number % factor === 0) { factors.push(factor) let inverse = number / factor if (inverse !== factor) { factors.push(inverse) } } } return factors.sort(function (a, b) { return a - b; }); } function createTextDiv(value,id) { let div = document.createElement('div') div.id = id div.textContent = value return div } ``` 
I don't think its the creators' fault that you can't read well.
This looks super interesting to me. I'm definitely going to look into building something with this in the future. The easy access to typeorm repositories sold it for me, really.
I like the fact that a (P)R is behind that name 8-)
I agree (and it possibly does support it already), but it won't be long before the pitchforks and torches start streaming in because you mentioned Mongo 
&gt; What do you recommend for learning design patterns in JS? write and read JavaScript. stop trying to apply patterns (especially patterns from strong, statically typed languages) to JavaScript _just cause_. if you're having trouble structuring your code, i'd highly recommend you check out a book like clean code or code complete. those will get you way farther than trying to learn specific javascript patterns.
Wow the arrogance 
I learnt using Codecademy + using it in projects. The best way to learn is to use and then learn.
there are many ways to implement a singleton and i dont think there's a best way in javascript. you can inject a single instance of an object into a class hierarchy. you can use a service locator. you can export an instance of the class like you're doing. a better question to ask would be what about your design justifies using a singleton here? especially in the case of a logger in the context of a [12 factor app.](https://12factor.net/) logging is typically done in a way where the logger outputs something to `stdout` or `stderr` and then a log collector picks it up. a singleton is much less valuable in that case because printing to stdout and letting something read from that is already decoupled and actions of a logger don't really need to be coordinated, which is what a singleton is used for. if you're writing to a file a singleton makes a little bit more sense, but i'd argue that having a singleton logger be part of your design exposes implementation details about your logger. the point is, you need to think about why you'd use a pattern and what it means for the design of your system, rather than just _using patterns_ cause that's what good software engineers do.
I think it uses Typeorm which should support Mongo.
Ahax Like Mexico in Spanish 
Come on reddit, you guys don't see sarcasm much around here do you?
TypeORM supports MongoDB. We plan, however, to add modules for some ODM for mongo and eventually, modules for many other DBs
yep
At first, by proper indentation.
4 hours of in-person instruction 5 times per week, the extra hours were completing homework assignments/projects/reading documentation, it was all active learning for me. 
Thank you mate. I have to sit down and get good then!
It was through a college’s continued education/ professional studies branch. 
Express is barely a framework. 
I'd second this. Definitely take *something* again, but don't waste your time/money on retaking college courses, especially not if it's likely to be the same material or same instructor. Do something else, take an online course. 
I just recently started to learn React after 1.5 years or so of picking up web development. I'd advise that you begin with HTML / CSS. You should be able to get your head around this fairly quickly. Then you'll want to start digging into JavaScript. Once you've got the hang of it you'll need to start looking into ES6 (The most recent version of JS), as some of its features are typically used quite a lot in React. Once you've done this, then I think its safe to dive into React. Personally , I found this video tutorial series very helpful: [https://reactforbeginners.com/](https://reactforbeginners.com/) If you're feeling brave, maybe even give the course a go first, find out where your shortcomings are and fill in the gaps yourself. Best of luck! 
My inner dyslexic is coming out because when I saw the title I read it as "HardonJS" lmao
You just made my day :D 
What does this replace? Express?
I read that as HardonJS
It doesn't replace express, it extends it for you. 
&gt; Simple answer, will the following lines work? no
I like it.
I sort of realized that it’s pretty rare from the other comments in the thread. Again, the logic isn’t so much of a concern as much as the fact that you see that the callback function is closing over the assigned variable. I’m glad someone finally saw it! However, now that I understand it better, I think I might use it whenever I see a similar situation where I need to close over a variable that determines when to stop some function or remove listeners.
I also read it like that. Kinda disappointed now.
Me too. Thanks. 
[removed]
You're right I didn't challenge the fact the logger was a singleton. I was challenging the pattern implementation which is really convoluted imo. It could have been simpler by using static key word too.
eat it. firefox worked too
Same here
You'll love this t-shirt then I made a while back: https://www.redbubble.com/people/hayko/works/2592085-particle-physics-gives-me-a-hadron?p=t-shirt /shameless plug
Because if items isn't an array, then you wouldn't be using the array prototype.
A quick google search turned up [this result](https://hackernoon.com/javascript-performance-test-for-vs-for-each-vs-map-reduce-filter-find-32c1113f19d7), which TLDR; says that a \`for\` loop is most performant, probably because of the lack of overhead of having to execute a callback function. However, you should analyze [the dataset](https://github.com/dg92/Performance-Analysis-JS) yourself. The are probably differences in speed when comparing Node.js and the browsers (as well as different browsers). At the end of the day, you should consider why you need to optimize performance and whether it's necessary or not. 
That’s good news. Have you tried our pal Microsoft Edge and his good old friend IE?
Babel has a typescript plugin, the issue doesn't exist any longer =&gt; use Babel. Babel is a better transpiler plain and simple, it supports more specs, is always up to date, actually follows the transition of specs going through draft phases and then stages, has a gigantic eco system that doesn't just consist of ecma specs but anything from postcss, lodash helpers, hoisting, etc. 
Hate to downvote, but this isn't actually JavaScript Related.... But you might want to look up MarkText. It's similar to what you're looking for.
Nope xD I'm still ignoring their existence. But I'll try them ansld also safari and will give you feedback
Exactly, if it was globally added this would require all types to have their prototype extended to support it, including scalars. Then you also have to consider both the `null` and `undefined` use cases. By using `Array.isArray()` we can pass any type including `undefined` and get our Boolean result.
No, but we do see people trying to hide their idiotic comments behind "sarcasm" or "it was just a joke" all the time.
I’m all ears, also, good luck out there private!
This makes perfect sense now. Thank you so much!
Why would i need to extensions express? 
&gt;Array size: 1000000, JS native - 276.729 ms, for loop - 8.491 ms mind = blown This means for small data and obscenely large data, the traditional for loop wins, and for data in the middle range, the for loop falls behind. Since my case is obviously very limited, I will use the for loop when I am sure that the array is small and the forEach loop everywhere, else, sound good? Much thanksly :)
Php frontend + css database. I service my car with peanut oil only. 
I mean, technically if it were on the Object.prototype, then everything would have it. I don't think that's the appropriate thing to do, but it's not all that hard to do: Object.prototype.isArray = function() { return Array.isArray(this); }; [].isArray(); // true [1].isArray(); // true ({}).isArray(); // false This wouldn't work with undefined or scalar values, but itr would cover the OPs use case.
 null.isArray(); // error
He’s choosing random images for a chat room bot. I don’t think he cares (or should care). 
Motherfuck. Thanks a lot for that brief response! I was really thinking of skipping GoF's book to read straight ahead to Addy's but what you said just gave me second thoughts about it - I really have to pay attention to details and be mindful on these fundamental stuff.
I got too tired of writing variations of this function on my projects: https://github.com/m1el/better-cmp
Yup, `undefined.isArray();` and `9.isArray();` are also errors.
&gt; 9.isArray(); Well we're assuming variables, right? This would be fine
Also, `(9).isArray()`
To all the dyslexic and/or potty-minded out there, I am sure you had the day of your life when LHC was activated. 
 (1,2,3,4,5,6,7,8,9).isArray();
That's what us old timers are trying to tell you.
 [9][+[]].isArray(); (1,2,3,4,5,6,7,8,9).isArray();
Read, Beautifull Code it's a great general book.
While I appreciate the time taken to describe higher level abstractions, I really hope nobody uses the advice in this article. Implementing Maybe/Optional in JS is an exercise in futility: It already has the ability to indicate that a value is present or absent (`undefined` or `null`). * *Without static analysis*, the `Just`/`Nothing` constructs are needless overhead and can cause additional problems, as there's nothing preventing references you expect to be `Just` or `Nothing` to be simply `undefined` or `null`. * *With static analysis*, you could get some additional safety, but it still is needless overhead: the best in class static analysis tools ([flow](https://flow.org/en/docs/types/maybe/) and [TypeScript](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#--strictnullchecks)) *already* have nullability checks in them. Also, these dependencies are not free. Building the following code with Webpack 4 (for production, so it's minified and tree-shaken) produces a bundle that is 18,670 bytes (copying the article's recommendation to use `require()` and not `import` syntax, you don't get tree shaking so the production bundle is 64,753 bytes): import Maybe from 'crocks/Maybe'; import safe from 'crocks/Maybe/safe'; import prop from 'crocks/Maybe/prop'; import { compose, isNil, not } from 'ramda'; console.log(Maybe, safe, prop, compose, isNil, not); I suggest adding a disclaimer to the article indicating that this is for educational purposes and *should not be used*.
Fake quotes in action. Incredible.
Okay I get it now.... ^(But the for loop is still run in JavaScript)
WTH happened with the line breaks in your post?
Highly recommend https://github.com/chriskrycho/true-myth for this.
Nice example in favor of functional programming!
Well to be fair, it doesn't matter, then you'd just do if(obj.isArray). Obviously the problem is polluting the prototypes.
Look up what Hadron means you idiot https://en.m.wikipedia.org/wiki/Hadron
3 hours?!:O I can build a CRUD app backend with SailsJS in 3 minutes. OK, I'm exaggerating a bit - but in 30 minutes easily. So what's the point?
I'd like to agree, with Express I could create a CRUD app backend in 3 hours as well...
I guess I’m not the only one who read something else... I was already curious what would they call the lite version, or the minified one... 
You can downvote him all you want but the arguments are still valid
 var x = 5; x.isArray(); // Uncaught TypeError: x.isArray is not a function
i think youre better off learning from tutorials on the internet and learning the best practices from there. If you teacher was anything like mine, who was a old school developer and still used jquery, id stay away from that and just stick to vanilla js
I don't understand dependency injection in JS. Service locator pattern ok, maybe that's what being meant here. But the promise of "The dependency injection pattern enables you to easily change interface implementation." does not solve an actual problem in a dynamic language.
Less than that if you already sat down and thought about what you were going to write. 
&gt; isArray() will ultimately be found in Array prototype, right? so, why can't we just use items.isArray() ? No, it's on the Array constructor function as a static method, not on the Array prototype. That's why it's `Array.isArray` and not `Array.prototype.isArray`
As someone who uses Sails, how do you like it vs. plain Express? Any killer features? 
It's a Web Router, it's a web framework, although minimalistic. framework =/= ruby on rails.
Unless you move it to WebGL Shader or use WebAssembly. Have a look at what forum I created 8 years ago.
dependency injection =/= IoC container. IoC containers make absolutely no freaking sense in a dynamic language. Just fucking build a big factory, it will make your code clear as fuck. Dependency injection is useful still in a dynamic language. Unfortunately JS lacks a standard way to write class mixins.
I never even took one in college. It was just a few chapters in my web programming class. Stanford recently replaced their Java based "Programming Methodology" course with Javascript and the professor, Eric Roberts, who is famous for his Java Textbooks is creating a new Javascript textbook. I can't wait for that to go on sale on Amazon. I get a lot more out of formal university textbooks with exercises than I do video tutorials or books with no exercises. To my knowledge his will be the first rigorous Javascript textbook written
you can't polyfill the shadown dom. https://caniuse.com/#search=web%20components and the support is absolutely shite. So no, there is no polyfills, there are libraries that are inspired by web components but do not work exactly like the standard. I wish people actually tried before saying "there are polyfills". There aren't.
Except the server is a broker for the peers, so if the pipe breaks on the receiving end your message just gets lost. Unless I am massively misunderstanding something.
ALL LANGUAGES SUCK.
Hey have a look at dom99: [https://github.com/GrosSacASac/DOM99](https://github.com/GrosSacASac/DOM99) * Templates are pure HTML * No build step required * Separation of concerns Open any issue you want
I don't believe class mixins solve this problem in a new way. You might as well pass dependencies via the constructor of swap/register them after instantiation. Class mixins solve the same problem in a less straight forward way (i'd even say more obscure) in my opinion.
Thanks 🙇🏻
I know that it technically is a framework, but it’s more just some syntactic sugar over some native Node functionality. 
Also Clean Code, overnight you'll become a better dev.
for loop is also the only one that does not require polyfill for es5
It's not actually about writing Markdown. It's about how to share it's html output securely (without worrying about malicious JavaScript) and conveniently. Sharing documents directly is more convenient than hosting them. So the Jupyter on demand rendering on server (by link or upload) is a good thing. But design lacks and you should write a notebook instead of normal Markdown. But on Gitbook you have a nice design, plugins, maybe even security and normal Markdown but need to host a whole repo. Moreover: it's better to write Markdown in offline editor like Atom/VS Code. So it would be nice to have best of all: style, plugins, security and design from Gitbook, render single file on demand online like Jupyter, edit in Atom offline. If to implement it all together as a ready to use solution - that would be a killer.
IE and Edge don't work at all
It's poetry.
Whole point of the function is to differentiate between arrays and non-array. You are making the assumption that what you are checking will always be an array.
Cheers 🍸
You can easily use higher-order classes and composition to mimic mixin behavior. const compose2 = (f, g) =&gt; (...args) =&gt; f(g(...args)); const compose = (...funcs) =&gt; funcs.reduce(compose2); class Base {} const mix = (...ctors) =&gt; compose(...ctors)(Base); const Barker = ctor =&gt; class Barker extends ctor { bark() { console.log('woof'); } } const Pooper = ctor =&gt; class Pooper extends ctor { poop() { console.log('ew'); } } class Dog extends mix(Barker, Pooper) {} const fido = new Dog(); fido.bark(); fido.poop(); I think you're right in a way, but doesn't the IoC container handle class instantiation/singleton etc for you? Is that not a benefit that doesn't require a type system?
Yeah - but I am not sure why... I had to learn it :-D - kind of like it now...but that does not mean I don't value my years of SQL
Thanks!
Thanks!
I like to think that it would just send random sexy ASCII content to the console.
http://i.imgur.com/XJkKPmf.gif
He claims it is sarcasm ...
Your code didn't run because you forgot to close it with "/s"
Only the last part with the name. I am pretty sure that the first part with the advantages was meant just as he wrote it.
Poor guy...
I feel like I ask that every time something only supports Mongo ;)
I'm voting for Minion.
Could you tell me the reason why you see the need to get personal?
Understood - didn't think about that when I wrote it, but yeah I am more of a traditional SQL dev. TIL mongo(NoSQL) and SQL devs have a gentlemen's quarrel going on.
I don't know what you mean by that.
Yup, they're both tools. It's weird, they have their advantages, but generally I stay out of tech fights as ... I don't see much reason to get into it.
How's this different from HapiJS? At first glance, it seems to be a configuration-driven way to make server routes (which is basically what HapiJS is IIRC)
`\` character is not one of the valid characters for a variable name.
What's one pro of strongly typed that doesn't boil down to developer laziness? Strong static types are a poor man's unit tests. Unit tests: - Show intent of how the code is supposed to be used. - Give example values and structures of expected input and output - Cover edge cases and values at the extremes. - Keep you from introducing bugs that break the logic. 
exactly, me too.
https://www.amazon.com/You-Dont-Know-Js-Book/dp/B01AY9P0P6
Thanks for your time but yeah did not include it as dependency of the package. The idea was to let user upgrade his expressjs if he wants too. dinoloop should not stop user from updating to higher version
Funny, I didn't find my passion for work until I actually started working and got stuck into the development process. 
Thanks, will check it out! 
Thanks
Forgot about this series, thanks. 
I have gone through nestjs project but I really feel they are some problems which are still not addressed. 1. Does nestjs have configurable DI framework? Can developer use his choice of DI framework available in the market? 2. Does nestjs support filters and middlewares at controller level? 3. Does nestjs middlewares support custom data or metadata? 4. How easy is to set up content negotation in nestjs? 5. How east is to set some controllers respond XML and others with JSON? 6. Also, I have noticed Middlewares are quite confusing syntax to pick up. Not use if we can use express middlewares in nestjs. 7. I do think nestjs uses angular principles (replaced component with controller), I find no practical use of modules. Modules are great at UI side but I dont find practical usage at server side 8 MVC do not require modules. I see no usage of modules in nestjs 9. Can I mount on nestjs and express on same instance on different mount paths? I Think these are some key issues dinoloop solves. Dinoloop is highly configurable, switchable and pluggable. 
It's in my opinion a very interesting post. Though, who doesn't compile dependencies when they compile application code? Usually Browserify, Webpack, Rollup resolves modules and only after babel runs. On the other hand, as of now, as [Google highlights it](https://developers.google.com/web/fundamentals/primers/modules), browsers supprting module also supports ES2015. True that it shouldn't be the baseline and that's why `preset-env` is awesome. Whatever the source is coded in, we compile for a target environments. The assumption that shoudn't be made though, is that node modules are coded in ES5. To me, modules should be coded in ES6+, with CJS in `main` and ESM in `module` if it's a module aiming the browser and that's it. In 2018, should we really warn users that it's not widely compatible without a compile step?? ES5 is far now, people should know about compilation. Unless there's a special `dist/` directory for direct inclusion via a `script` tag, I don't really see why we should either pre-compile our modules or warn users. Did I miss something?
It can keep a pretty loose version then. It just doesn't follow conventions, and makes it more complicated to manage the dependency. Plus what if you have breaking versions then? Where the person has v5 or something installed, and that breaks the package?
Babel?
&gt; don’t want to add a transpiler to my stack
Totally valid! +1 from me, for minion.
Take it easy on OP friends. We have to do a better job of being inclusive and welcoming of people at all skill levels.
&lt;3
Ah. Went over my head. Though it makes me wonder, why are you against using a transpiler?
I think that somehow inserted itself while copying... That's definitely not in my code.
I would definitely look into it, since it is still in early stages, I want developers to understand its ability with minimal set up. May be in future versions 2 or 3, We might package the express as dependency. Thanks for your valuable inputs
Let it die
Hey, fellow noob. I'm on the opposite end of your JQuery sentiment. I'd rather go the route that'll teach me more as apposed to what's easier. This prepares me for future challenges. Once I found out that JQuery was no longer mandatory, I opted for VanillaJS mostly because it'll make me a better JS programmer. Though I prefer VanillaJS, I still learned JQuery because older programmers are typically a few years behind the curve when it comes to a programming language's capabilities.
I've edited it. Still unsure how every \ made it in there. Have any reasons why the last three Else If statements won't work?
less code !== legible code. The following Scala code is terse. Is it legible though? (n: Int) =&gt; (2 to n) |&gt; (r =&gt; r.foldLeft(r.toSet)((ps, x) =&gt; if (ps(x)) ps -- (x * x to n by x) else ps)) 
Wholeheartedly agree. A proper JavaScript packages system is long overdue. Everyone just seem to have settled for NPM despite its glaring flaws and, frankly, its dubious maintainers.
Because when I debug in the browser I’d rather my client side code be the code I wrote and not some mangled JavaScript.
If it works with the raw values but not variables, then the variables are not what you think they are. Try logging them to the console or using a debugger to see what value they actually are.
I hear you in regards to transpilers, but the way you described JQuery is the definition of crutch.
your example though, still doesn't sell me on using jquery again. i'm ok with an iterator, over importing a library that i'm only utilizing a minor portion of.
It's implied that jQuery provides both.
The method is available to help prevent error when u trying to operate on type array, however been type safe or using type safe technique is the way forward
I get that. Especially if you're not doing anything extensive. My rule of thumb has been if my script file hits 1k lines, maybe take a glance at jQuery.
I started using JQuery because of the cross browser functionality it offered. I kept using it because I didn’t want to write my own DOM manipulation toolkit when I had one already in my code base; I have, however, read and understood every line of JQuery core, and have written it from scratch myself for fun to see how I would write it differently. But I mean, if you want to call JQuery a crutch, then we can walk our way all the way back to assembly language or further back to logic gates. It’s something that simplified a task I would have to solve myself. ES6 is the opposite of that; it literally gives me no new functionality, solves no problem, and complicates my stack. Yes, the idioms and syntax are more pleasant and succinct, and I’d use it if it didn’t make my stack more complicated. When it’s supported in all browsers I need to support, I’ll switch over (or for when I’m writing server side JavaScript). I literally added JQuery to my stack to solve multibrowser issues, and adding ES6 to my stack cases them. 
&gt; In other words, if a computer is doing something other than what you asked it do to, you are simply asking it wrong. I think you mean something more like: &gt;In other words, if a computer is doing something other than what you *thought you asked* it to do, you are simply asking it wrong.
Why does it look like that? Did you actually thought of ux/design before the system architecture? Good job anyway! 
Hiya! I am not understanding your comment "Why does it look like that?" haha. I did most of the architecure before design, but had to switch things up at the end.
Hi /u/Unseenmonument, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/andfra100, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/kiwi0fruit, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Hi /u/frontjes, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/django_noob, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/sachtech777, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/sanprodev, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/luxorium, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/wannalearncode, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Hi /u/wannalearncode, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Hi /u/kmball11, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/ApprenticeQs, For javascript help, please visit /r/LearnJavascript. Thank you!
Maybe front-end build tools run everything through Babel and maybe they don't. It's not a safe assumption to make, so library authors only publish ES5 to be conservative. This is the current "best practice", and most tools and blog articles advocate doing it this way. I agree that this is not a sustainable approach going forward. It made sense a few years ago, but there have been 4 more official standards since then. The question is, how do we convince library authors that shipping code for the latest ES standard "OK", without breaking a lot of long-standing ecosystem assumptions? I think that's what this article is trying to address. As a library author, I would prefer to ship ES2018 if only there was a safe "best practice" way to do that. There isn't, so I still ship ES5. This sucks, but it keeps everyone happy for now.
&gt;if my script file hits 1k lines not that either. to me it would maybe be time to refactor and break it up so it easier to digest. i would think if you need to use a specific set of methods jQuery has, then sure, but in 2018, what does jQuery do that there isn't another, possibly smaller, library that can cover it? sure, a long time ago i used the animation stuff, but CSS has caught up, as well as better animation libraries available now. i can use their AJAX methods, but why when we have fetch now? i'm not trying to hate on jQuery, but its time has passed. it was fucking rad when it was the new hotness (and got me tons of work), but javascript has advanced, and its time to let some vestigial things go. we're getting to a point where things are getting broken up and modularized, and if jquery was broken up into individual modules like lodash is, maybe they can continue to be 'in the mix'.
No, dont get me wrong! The app is working and is super fine for the mvp; let me rephrase the question: What was your selection process for the look and feel of the frontend? Do you preger to use some bootstrap, kendo ui or any other kind of framework, or do you prefer to style it your own way? And why?
Gotchya gotchya haha. I was just a bit confused there! My selection process was just personal experience with UI/UX. I didn't want to make it super bland hence the gradient and pops of green. I also wanted to make sure it felt warm and care free because you have this timer counting down in front of your face which could be super intimidating haha. For these projects I always tend to use my own stying as I am trying hard to get better with CSS. My skills could definitely use some work! Thanks for taking a look, I appreciate it!
Wholeheartedly agree. A proper decentralized JavaScript package system is long overdue. Everyone just seem to have settled for NPM despite its glaring flaws and, frankly, its dubious maintainers.
&gt; Example: In plain JS, you'd most likely have to use an iterator to attach an event handler for multiple elements of the same class. However in jQuery this is incredibly easy to achieve. (Stack Overflow Example) No, you wouldn’t. Technically, you *never* have to do this, nor should you desire to. You attach *one* event listener to a common ancestor and wrap your listener in a conditional statement that checks the target elements class: handleClick (event) { if (event.target.class === ‘btn’) { console.log(’Clicked’) } } document.addListener(‘click’, handleClick()) The same concept would apply with jQuery as well, obviously, but I think it’s less that obvious at that level of abstraction that adding an event listener per element rather than delegating to a single element become very inefficient very quickly. 
This doesn't look like a good idea. I'm not sure why, though. 
I really love it! I’d love to rewatch the twitch streaming; I really think your objective and phrasings are great and you do inspire! Looking forward to your next project and I have an idea - whatever the next project is, try to integrate payments; that could be great tutorial!
I can _kind_ of see the argument (don't depend exclusively on Express or Koa or whatever) but: 1. it only works with Express right now 2. how often does one _really_ swap out those lower-level frameworks? I've built apps with both Express and Koa, but once those apps were built, I was never once tempted to switch up the parts that directly depended on one of the lower-level frameworks.
Btw you can use this with Quasar on the front end for maximum particle physics flavour.
Thanks for this! I have all the videos for my first project located at https://youtube.com/c/PixelogicTV :) Feel free to check them out there or come by the stream one day! Would love to have ya
It can get unwieldy if you’re using doing too much delegation, but that’s just about the only real issue with this approach. For the sake of sparing oneself headaches down the road, you probably shouldn’t attach directly to the document root, I was just trying to convey the concept. Ideally, you’d attach to the closest common ancestor. But this is why event propagation exists. Unless explicitly instructed not to, all UI events “bubble” up the DOM tree. You can listen for them at any node along the way, and for performance reasons, you generally should not use multiple listeners for the same type of event.
Jesus, I thought it WAS HardonJS until I read your comment. Then I had to re-read the title 3 times.
I don't really get it. Looking at the code most of it just looks like typical express code but express-isms are swapped out with `hadron`. CRUD is basically the easiest type (and the most common) of application around and I'm pretty sure I can do that without HadronJS in way less time than 3 hours, especially if you are using pretty much any ORM. 🤷‍♀️
The ES6 way to accomplish that would be to write your own way of applying an `eventListener` to all elements that match a given`querySelector` (or finding a package online that does the same thing). That way you are only including the code that you need, and it will be easier to make changes later on. jQuery is nice for the shortcuts, but you can write those yourself if you use them a lot.
Hey, thank you for the comment, much appreciated. I'm on my lunch break now so I'll try that. I had the variables printing in the Alert method... would the values shown there be any different than the one that would show on the console?
Alert won't tell you anything about the type of the value or its structure. What if you were to alert 123 as a number, then "123" as a string. Do you think you would be able to tell the difference?
Looks like it's down.
no its not had to push a change as the input field wasnt clearing after submitting the form
wait nvm it is
Couldn't I just use: $('.btn').click(function(){ console.log('Clicked') });
But you are making your users download a library. Sure that saves you a line of code on occasion, but does it really save you enough to tack 30 kb (best case scenario) to every single http call that gets a page? As to legibility, what jQuery does is obscure certain parts of the code from you. Anyone reviewing it will have to either know jQuery (and also ideally know what it actually does on the inside) or they won't understand what it does and will have to spent time looking it up. jQuery was a necessary tool 12 years ago. Since then it pretty much died, so far as any serious project is concerned. In the modern world, a person using jQuery is most likely doing so because they haven't learned modern JS or are simply used to doing things a certain way. Which is hardly a good reason.
You just helped me solve it. I forgot the values in were being stored as a decimal. I used parseInt and that fixed my problem. I still don't know exactly WHY the problem occurred, but at least the code is working as intended now. Much thanks, stranger!
Just to clarify... Is this sub not for asking for help with code, or I did I do something wrong somewhere along the process?
??? http://paqmind.com/tutorials/async-programming/promises/challenges/7.tsk/ Click "Done" at the bottom (or the "Solution" tab if you've already unlocked it), then look at the note at the bottom.
You could. It’d be a lot more concise than doing the same thing in vanilla JavaScript. But it’s also a lot less efficient under the hood, and it can quickly become perceptibly worse performance-wise.
If you keep the entire page source below a certain threshold, does it matter? And if it helps speeds along development, why not? Just seems to me modern JS is a bit clunky. 
Thx
I recently got a job as a entry full stack developer after completing an internship at the company. I had very little experience with javascript from school but my ability to logically go through problems and my willingness to ask for assistance from more experienced workers helped alot
If you are working with a single HTML page that has a few hundred lines of JS code, then nothing matters. If you are working on serious web apps that have to serve hundreds of thousands+ of customers, then yes, it does matter. Your application will likely have a whole bunch of developers working on it simultaneously, span many dozens (perhaps hundreds) of files, have a whole bunch of dependencies that are actually necessary, etc. Adding more junk to it is a really bad idea. As to modern JS being clunky, I disagree. Once you take the time to learn it well, it's really quite a pleasant thing. I'm not saying you can't get away with using jQuery. I'm saying you should seek to avoid using it for your own betterment. If you are locked into it, you will have trouble getting on without it. But if you are used to not using it, you can pick it up anytime if an occasion arises. (Although I can't think of any such occasion.)
Huh, so if you have 100 elements that you wanted to listen for clicks on, you might want to listen on a container instead of the individuals. That makes sense. I see that working in some scenarios, but maintaining a complex project with that method could lead to issues. Someone could stop the bubbling somewhere in the middle, and inadvertently cause it to stop working for some of the elements. Good optimization trick to keep in mind, though. Thanks!
The guidelines need to be updated, but in short, most of the common help posts don't belong here anymore. 
Most the time I comment here its brigaged. I don’t care about fake internet points. Yes the elevator pitch sucks. I know what hadron is. It os still a bad name. The sarcasm is the last part of that sentence. Maybe if I wrote it in javascript these nerds would get it.
Gotcha
Possibly (my books, which cover JS in depth and are free to read online): http://exploringjs.com
Multiple problems with that code: * So-called *smart* quotes will cause a syntax error. Use straight quotes instead. * `event.target.class` If you were looking for the class name of the target, use `className` instead. But, rather than checking the class name, it would probably often be a bit more understandable if you used `.matches` instead, which accepts a selector string as an argument and is much more flexible (allowing for similar syntax as jQuery event delegation) * Don't *invoke* functions when trying to pass them as parameters - just pass the function name instead, or it won't work properly * To add a listener, use `addEventListener`, not `addListener` The general idea is definitely sound though - use event delegation with a single listener on the container, rather than attaching a listener to each individual child.
&gt; I see that working in some scenarios, but maintaining a complex project with that method could lead to issues. Like what? This is not a “trick”, it is how the DOM API expects you to deal with events. You *should* be doing this in a complex project. Look at how React deals with event handling, for instance. Are you telling me its developers went that route because they didn’t consider the needs of other developers building complex applications? &gt; Someone could stop the bubbling somewhere in the middle, and inadvertently cause it to stop working for some of the elements This is why you’d typically attach to a parent or at least the closest common ancestor, rather than some distant ancestor way up the DOM tree. Stopping event propagation is something that is done out of laziness or ineptitude. There is *almost never* a good reason to do it, as there is almost always a better way to achieve the desired result. Its really bad practice and if you use it, you are bound to break things in a way that can be very difficult to troubleshoot, as it breaks the standard event model by design.
I’m not at a computer and i was just trying to throw together a quick example to get an idea across, not code ready to be cut and pasted into a production app. But I do appreciate the corrections, I’ll edit my comment accordingly.
Use typescript and forget about this. 
So basically they're closing down their public bug tracker on GitHub and replacing it with... a discussion forum? I'm not sure I understand the rationale here. Sure, it's nice to have a forum so people don't resort to using the issue tracker for things that aren't actual bug reports. A lot of larger projects I know of encourage posting on forums first to make sure the problem you're experiencing is really due to a bug before filing a full-fledged issue. But getting rid of the bug tracker entirely? Seems like a really unorthodox decision to me.
This is stupid.
This is so stupid...
Yeah, it's an important lesson and we've all been there. And it's a great example of how people learning can rightfully use logic but miss some aspects that are obvious in hindsight.
What's the point of development then?
ForEach was added in es5
Thank you! This is actually interesting and good to know.
Not true at all: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays. Also, see asm.js. You just only get access to IEEE 754 doubles as literals. There are ways to get the JIT to do what you want, though. 
Oh yeah you are right! I mixed it up with IE lack of support for NodeList
Uh... this really feels like spam. =/
Especially from a user with "Marketing" in their name. 
I've used rails, how's sails?
I would not do any date/time modifications without moment.js (think it has recently changed its name). It takes all complication of day/date calculations and modifications, the type of stuff that I find a pain to terrible shoot.
Cool article. Great!
To be honest, typescript. Every project I start developing since the last year has been with typescript. I simply love it:)
Can anybody please explain how in the example above getName(people[i &amp; 7]) returns last name property? Thank you in advance! 
&gt; I spent about 2 months learning all this auth stuff at work I'd love to read an article about what you've learnt.
&gt; isArray() will ultimately be found in Array prototype, right? so, why can't we just use items.isArray() ? First question: no, isArray is a method from the Array function (functions are also objects, so it can have its own methods/properties), it *isn't* on the Array.prototype object, which contains methods/properties that are inherited by new Array instances. Second question: there is a pretty simple answer to that: you would need every object and primitive to implement an isArray method. I mean, if you want to know if x is a number or an array, and you use x.isArray(), it will throw an error if it's a number.
I wish it could all be summed up in a single article. :)
`9.isArray` actually throws a syntax error, because if you start with `9.` the interpretor doesn't know if you are calling a method or writing a decimal number. `(9).isArray()` would work
Well you can have a function's code by calling `.toString()`: var x = function(){ console.log('test'); } console.log(x.toString()) //"function(){ console.log('test'); }"
I suppose its personal preference more than anything, but im not a fan of decorators. Is it possible to use dinoloop without? Can decorator be used as "plain" functions? E.g. `HttpGet('/someroute', get() {...})` instead of `@HttpGet('route')` `get() {}`
'esm' for widely and transparently working `import` and `export` statements.
You can do this: var f = () =&gt; 5 + 5; alert(f.toString()); // function () { return 5 + 5; } This is a browser/JS feature, not TypeScript, and you'll get the JS output code, not the original TypeScript. Another way to approach this is check decorators, which can be configured to output meta information like typehints as readable JS structures. That's not the full source, though. **That said...** let's take a step back and start thinking. If injecting code in DOM works somehow, then you don't need to inject the entire function, but only a one-liner invoking an already defined function (defined elsewhere and loaded). I'd strongly recommend you do that, rather than dump entire functions of source in DOM.
value of the case is the variable which you tested in switch means if a particual case is getting excuted then tested varibale is equal to the case value grab that tested variable 
Agreed, this will work but you really shouldn't need to be doing that. That code shouldn't see a production server
fuck i'm dumb
Thanks for your time, I really love what you have proposed, we will definitely look into with our contributors, to have additional support like you have mentioned. We will put it up in feature request list. We have added decorators to be in-sync with angular and having seen decorators heavily used in java and C# world where OOP programmers are much aware of. We really want our developers to behave as per their intuition instead of making them learn new way of but we will work on it &lt;3
It's called a template literal, it came in with es2015. Es2015 brought lots of gd stuff with it, arrow functions, scoped variables etc etc. Just watch out for browser support our use Babel.
template literals
I truly thought for a second we were talking about the Nintendo Switch and was wondering why anyone would want to get the value of the outer casing. Good morning to me too! 
 const getName = (person) =&gt; person.lastname; is pretty much identical to: function getName(person) { return person.lastname; } and simply extracts the last name from the passed object. People is an array of 8 Star Wars characters. By taking the bitwise and (&amp;) between i and 7, we are only looking at the first three bits to make sure for any value of i [0, 1E9] the resulting index is kept within [0, 7]. It is equivalent to using the modulus operator for this (i % 8).
Pretty sure that this solution would not work if you add other elements of that class later. The jquery equivalent would be something like $(document).on('click', '.btn', callback);
Realistically after the first visit the jquery file is cached and should pretty much never have to be reloaded
It's binary form of `Math.max(i, 7)` example: 000 (0dec) &amp; 0111 (7dec) = 000 (0dec) 001 (1dec) &amp; 111 (7dec) = 001 (1dec) ... 101 (5dec) &amp; 111 (7dec) = 101 (5dec) 111 (7dec) &amp; 111 (7dec) = 111 (7dec) ... 1001 (9dec) &amp; 0111 (7dec) = 0001 (1dec) 1011 (11dec) &amp; 0111 (7dec) = 0011 (3dec) ... 100100101011 (2347dec) &amp; 0111 (7dec) = 0011 (3dec) You basically cut off everything from left side until **3 last bits** (leaving 3 least significant bits).
I got the message "undefined" after reaching 19 balls.. and you can place the ball off canvas ;)
The main benefit of using maybe is for writing FP style chained functions without needing to guard against null values in any of the steps. Static analysis without maybes means your code won’t compile unless throw in some guards. 
The `&amp;` is the [bitwise AND operator](https://en.wikipedia.org/wiki/Bitwise_operation#AND). They are using it to loop through the `people` array a billion times by using a bitwise trick where when `i &amp; (array.length - 1) === (array.length - 1) // the last index` then `(i + 1) &amp; (array.length - 1) === 0 // the next iteration will get the first index`. Some actual numbers may help you understand this: // i = 0 (the first iteration) index = i &amp; 7 // 0 people[index] // "han" // i = 1 index = i &amp; 7 // 1 people[index] // "luke" // ... // i = 7 index = i &amp; 7 // 7 people[index] // "obi" // i = 8 index = i &amp; 7 // 0 people[index] // "han" people[i] // undefined -- people is only length 7 so has no index 8 // ... // i = 16 index = i &amp; 7 // 7 people[index] // "obi" // i = 17 index = i &amp; 7 // 0 people[index] // "han" // and so on a billion times This was a neat trick that is acceptable in this PoC benchmarking case, but the `&amp;` operator should almost never be used in real production JS and definitely not in the way they're using it in the OP as it's not immediately obvious what's going on unless the person reading the code is familiar binary operations/bitwise logical operators, which most people that are coding in higher level languages like JS aren't ever going to use them or need them as there are better methods. They're really only useful in low level languages like C that has a true `Integer` type and `int` operations are really fast. Unlike JavaScript where there is no `integer` type only `number`, so bitwise operations aren't fast, so there is no performance benefit to counter the harder to understand code. 
I think that titling this post with "build a crud app in 3 hours" was a bit of a miss because with Hadron you can build a basic CRUD in 3 minutes (or if you're using collider, you can do it in about \~15 seconds because the boilerplate is included).
This is not true. 8 &amp; 7 == 0 Math.max(8, 7) == 8 What /u/Geo_Dude says is correct. The &amp; operator works more like modulo.
&gt;Maybe front-end build tools run everything through Babel and maybe they don't. Maybe the developer should be responsible for the final code he ships. Because of this, we're forced to ship some parts as ES5 (which is way heavier after transpiling) even if we'd like to ship ES2015 because our target supports it. Not all the modules are automatically transpiled to ES5 though, so the assumption that the `npm install a-module` will be ok for everything is a bad one IMHO. Personally, I'd love every module to be shipped in whatever 'version' of JS they've been coded and then the developer shipping the final code decides what's good for whoever is the target. Some modules already ships ES6+ only (just gave a look at the sources). But yes, a lot have a npm scritp on install that transpiles the thing :/ Again, IMHO, this should be the case only when source is .ts or non native JS. As far as I'm concerned, when I publish to npm, rollup only to convert ESM source to CJS module for those using things like Browserify that aren't ESM aware.
Have followed this guide myself while learning Ethereum. Personally I used Github Pages to host frontend code ([using gh-pages](https://www.npmjs.com/package/gh-pages)). What's great for frontend devs is you can build a proper Dapp where the only cost is domain name (Github Pages hosting, Ethereum backend). Will post about the app I built in next few days if anyone is interested.
lodash. I spent a couple of days once reading through all the methods to get a mental model of all the things it can do. Has saved me so much time and effort since.
You don't need to sum up all, just the essence and maybe a few lessons learnt.
A non-hacky dependency container based on destructuring arguments. https://github.com/adrianhelvik/container const container = new Container() container.provider('message', ({ who }) =&gt; 'Hello ' + who) container.constant('who', 'world') container.invoke(({ message }) =&gt; { console.log(message) // Hello world }) container.get('message') // Hello world And another nice feature is that you can extend a container. const childContainer = container.extend() I've used this to have the child container contain the public API, which I expose using childContainer.keys(). Makes for a very testable backend.
Arrow functions: const hello = (who) =&gt; console.log('Hello', who) Rest arguments: const hello = (who, ...others) =&gt; { console.log('Hello', who) others.forEach(who =&gt; hello(who)) } Object/array and argument destructuring: const foo = ({bar}, [baz]) =&gt; { // ... } const bar = 'some' const baz = 'thing' foo({bar}, [baz]) Async/await: const getArticles = async () =&gt; { // Treat a promise as if it's synchronous const users = await fetch('/users') } Object methods: const say = { hello() { console.log('Hello') } } Proxies (can do much more): const sayOrApologize = new Proxy(say, { get(target, property, receiver) { if (! target.hasOwnPropery(property)) return () =&gt; console.log('Sorry.. Not here.') return target[property] } }) sayOrApologize.hello() // Hello world sayOrApologize.something() // Sorry.. Not here. And it is okay to not use semicolons on every line as long as [ and ( are prefixed with semicolons, as ASI (Automatic Semi Colon ainsertion) works. I'd say that's about it.
I saw your talk at enterJS, I really liked it!
If I am manipulating a Buffer in Node.Js and need to do operation on bytes, what would be better than using bitwise operator in this case ? I am genuinely curious, because I could improve the code later.
How is its performance in production? Is it still better to transpile it away? I know babel-polyfill isn't recommended
Moment - its heavy but does a lot of good date formatting. Babel Isomorphic-fetch
Are there any tools to find bottlenecks like this during execution?
Thanks, that was a very informative guide 👍
Well written and amazing presentation. This is the kind of articles we need. Thank you *very much*.
Looks good and small. But move \`webpack\` to devDependencies. ;\]
I've only played with Node, never anything significant, and I'm definitely not an expert on bitwise operators. I've just done a fair amount of reading on them every now and then because I think they're cool. However, the big reason to avoid using them in JS is they're hard to understand unless you're already familiar with them, and you rarely will get any significant performance gain for the added complexity. Like in the OP, they should've just used `i % 8` instead of `i &amp; 7` as most programmers will immediately recognize what the modulo form is doing, and probably not the bitwise AND form. If you're working on raw bytes, then by all means use bitwise operators as that's what they're made for. But for little hacks like in the OP, use something else so you're not coming back 6 months from now going "what the fuck is `(n &lt;&lt; shift) &amp; mask` doing". The reason bitwise operations don't give you the performance gains you would see in a language like C is because in JS [both operands to a bitwise operator are converted to signed 32-bit integers](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators) before the actual bitwise operation occurs, this is where you lose the performance gain, as once the conversion occurs the actual bitwise operation is still very fast, unlike in C where it doesn't have to do the conversion. However, it's entirely possible that V8 is smart enough to know that when you're working with a `UInt32Array` that it can skip the conversion, but I definitely don't know enough about V8 to actually confirm that's what it will do. While not Node related, you may find this article from Mozilla on [Faster Canvas Pixel Manipulation with Typed Arrays](https://hacks.mozilla.org/2011/12/faster-canvas-pixel-manipulation-with-typed-arrays) interesting.
Using other libraries might get it. I use jstree - https://www.jstree.com/ How are you going to replace this without jquery as dependency?
I agree with you, you should definitely use the right tools for the right job to make your code more maintainable. Even for what I am doing Javascript might not be the best tool, and I am looking into the C++ Extension that you can do with Node.js. Thanks for your reply, and thanks for the article, I actually have been playing a bit with canvas to display marker on a map (better performance than svg) so this could be interesting!
Try date-fns instead. It's a lot more compact and it is functional.
* me: Libraries authors don't trust frontends, so they transpile "just to be safe". * you: Frontends shouldn't trust libraries, so they need to transpile everything "just to be safe". The first step to fixing a problem is realizing it exists. I actually agree that your version is better, but it's not how the ecosystem operates right now. Convincing everyone to change is hard, but that's what Babel is working on. They want to make your vision the default so libraries can safely ship modern code (yay).
Sorry my bad, should be Math.**min**(i, 7)
If you do memorize this table. Please still use brackets so the rest of us can read your code
Right tool for the right job. For manipulating bits and bytes (as found in such buffers) bit-wise logical and shift operators *are* the right tool, that is their job, so you are perfectly right to use them there. They are often used for performance and/or code conciseness hacks, particularly by people with a string C/C++ background. Even in C/C++ these tricks are often frowned upon outside of the obfuscated C contest and other code golf, because breaking readability/maintainability for the case of brevity isn't a good trade off and modern optimising compilers can usually do the other job for you anyway.
Rest arguments are the bestttt. I've been using them excessively for constructing WS packets with an indeterminate amount of arguments in a new project. One of the biggest things I missed in JavaScript.
There's a good write up on some of the newer features in ES: https://babeljs.io/docs/en/learn Generally, if you want to use it, you probably would want to transpile with Babel, or else older browser won't be able to run your code. With Babel on the other hand you can run all of these features, up to drafts and staged specs.
Is the controller in Area 51? If so, forget about it, it's heavily protected.
I'd just like to say that this sounds like a terrible idea.
We both agree on where we want the ecosystem to go. me is rather: Frontends shouldn't trust libraries, so they need to transpile everything __only to match their target env__ (= maybe only 7to6 not down to ES5, that's a huge difference). But sure, thanks to your clear explanation, I realise there's a problem. 
And as of [last month](https://www.ecma-international.org/ecma-262/9.0/index.html) Object spread is added to the spec. [Here's a great article introducing new features from each year.](https://medium.freecodecamp.org/here-are-examples-of-everything-new-in-ecmascript-2016-2017-and-2018-d52fa3b5a70e)
Yeah, that's nice. Throw parens around everything that you're not sure of and let prettier decide whether they belong there or not!
great article 
If the nature of the request is such that the response can be cached, then you shouldn't be hitting `serviceB` every request in the first place (you're doing `serviceB` and yourself a disservice by doing that), and you have no need for a circuit breaker. Just continue serving from your cache during an outage. The circuit breaker pattern is really only useful when you need a fresh response for every request.
Wow it would be hard to find an article I agree with less. I mean, the basic premise is that single page application development has inherent challenges that aren't well suited to using something like jQuery. Which is pretty much a ridiculously obvious statement to make. The vast majority of the rest of it is simply unsupportable. &gt; As you can see in above diagram, using an opinionated framework is like driving a car with automatic gear system. You cannot control the speed or acceleration, nor can you synchronize the clutch action, its the black box of the automatic gear that does it for you. This is the sort of analogy that provides no actual explanatory power. It is simply a claim, and a ridiculous one at that. "Using React is like being set on fire and then beaten with sticks until the sticks are on fire and then the sticks are used to kill your children." Do you **want** your children killed? Then don't use React! Don't get me wrong, I don't actually think all solutions for SPAs are equal. I think Angular (note not AngularJS as the article suggests) or Ember are better choices for complex and highly interactive single page applications. The more binding-library-based frameworks like React and Vue don't - IMO - provide as easy a path to CRUD style interactions as something like Ember. But regardless, the suggestion that using React to build even a complex application you will be "hit with a wall" is not in any way credible. I was initially suspicious of all of these claims. I mean, they're absurd and easily dismissed even on their own merits, but the real question was... what's the alternative. Saying *x* is bad is only interesting if you can provide *y* as a better option. And the better option presented here is: ## Backbone. Holy shit. Backbone. Advocating Backbone in mid 2018 takes a healthy blend of ignorance and arrogance. Backbone is frankly a legacy technology. It is heavy on boilerplate, slow as all hell, and provides very little utility. Moreover, I would say that using Backbone will make your application **vastly worse in every possible way**. The reason for this is made obvious by [looking at its website]() and saying hello to JavaScript in 2009. Note the narrow, non-responsive layout - even the website hasn't been updated, do you think the framework has? (Hint: no, it has not) If you're wondering where the NPM install instructions for Backbone are, you're starting to see my point. There's literally a "download" button and the instructions are "(Right-click, and use "Save As")". Yes. Really, that's a quote from the website. It gets worse than this, though. Of course if you're using Backbone there go all your modern tooling. Building with Webpack? That can go. Transpiling with Babel? That's out. You no longer have access to ES6. No more classes, no fat arrows, template literals are literally gone, and destructuring got destructured. Gone is any concept of a modern and progressive approach to JavaScript. While you're living there in 2012 buy some Bitcoin. Don't listen to this article. Don't use Backbone. There is **nothing** Backbone can offer you that React, Vue, Ember or Angular can't do better, faster, more reliably, more supportably, and with an active and vibrant community.
As soon as I see an article with a title like "The right way" or "This is how you should", I choose to completely ignore it. How about, "My take on architecting Single Page Applications"? That would seem like a healthy place for opening a discussion, not with absolute statements like "This is the right way because I think so".
`Object.create(null)` has no prototype. This is great for using an object as a hash table; there are no prototype values to accidentally consume. Packages like [has](https://www.npmjs.com/package/has), a wrapper around Object.prototype.hasOwnProperty, exist because you can't guarantee everything inherits the Object prototype.
Hahaha me too! There's been a lot of Switch homebrew news in my feed.
Indeed, it's similar to HapiJS regarding configuration, but Hadron is not limited to it. The user will get much more power to work with requests, responses independent of original framework (like hapi)
Ah, nice catch. Forgot about that!
Build a DApp on Hyperledger the Easy Way: [https://medium.com/@mycoralhealth/build-a-dapp-on-hyperledger-the-easy-way-178c39e503fa](https://medium.com/@mycoralhealth/build-a-dapp-on-hyperledger-the-easy-way-178c39e503fa)
You don't.
As I mentioned before, this post with "build a crud app in 3 hours" was a bit of a miss, because with Hadron you can build a basic CRUD in 3 minutes (or if you're using collider, you can do it in about \~15 seconds because the boilerplate is included).
More gambling is just what cryptocurrencies need to improve their image...
heard about those guy modshipping a switch ? there is a writeup on hxd
Yup, not really necessary though, it's just a little USB guest device that triggers a bootrom exploit. They're simply hardwiring it. Usually it plugs in via USB, can be run from PCs and some Android phones too. Team Executor made a cute portable dongle for it with their "SX OS Pro" release, but they don't deserve your money. Slightly risky but you can force the console to do this completely on its own by intentionally corrupting the boot loader.
You do not know the type of \`items\`. Therefore you do not know if it provides a method \`isArray\`.
It's funny but when I started learning JS (not so long ago) I had this feeling there has to be some better way to include variables in your string... doing "text" + variable + "text" was such a PITA that I started to google straight away and found template literal, made my life so much easier from the very start! Now I'm curious, how long before did it take you before finding out? 
I believe `nuxt generate` already does what you're asking. First the actual generated page is loaded, and subsequent navigations happen SPA style.
moment.js babel
here are some good links Best place to start is Practical Javascript on https://watchandcode.com https://www.theodinproject.com/courses https://www.freecodecamp.org/ https://github.com/P1xt/p1xt-guides/blob/master/job-ready-javascript-edition-2.0.md https://github.com/P1xt/p1xt-guides/blob/master/wd-cs.md https://github.com/getify/You-Dont-Know-JS https://eloquentjavascript.net/Eloquent_JavaScript.pdf https://developer.mozilla.org/en-US/docs/Web/JavaScript https://addyosmani.com/resources/essentialjsdesignpatterns/book/ YouTube channel Traversy Media - https://www.youtube.com/channel/UC29ju8bIPH5as8OGnQzwJyA For the other parts of web development I really liked these 2 Udemy courses https://www.udemy.com/the-complete-web-developer-in-2018 https://www.udemy.com/the-complete-junior-to-senior-web-developer-roadmap
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [P1xt/p1xt-guides/.../**wd-cs.md** (master → e65cc0d)](https://github.com/P1xt/p1xt-guides/blob/e65cc0d15ff94532ee6d02c48207198c309d67fe/wd-cs.md) * [P1xt/p1xt-guides/.../**job-ready-javascript-edition-2.0.md** (master → e65cc0d)](https://github.com/P1xt/p1xt-guides/blob/e65cc0d15ff94532ee6d02c48207198c309d67fe/job-ready-javascript-edition-2.0.md) ---- 
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
Thank you so much for your effort I definitely will check them out
Look up any tutorial on calling an api from Js and it will work just fine 
That was awesome, I wish I had more internet points to give.
i dont know jimp package, but : * if the image function returns a promise the catch function have to return a promise or an error too * if not then the catch function have to return a value like null or undefined Think that the return value must be consistent. 
Nope. I'm not sure what the issue you're having is, but this looks fine to me. `pHash` will return the hashed image you created. ``` ImageProcessor.prototype.pHash = function (source) { return jimp.read(source) .then(image =&gt; image.resize(16, 16) .quality(100) .greyscale() .hash(2)) .catch(err =&gt; console.error(err)); }; // You can use it like this: const processor = new ImageProcessor(); const processor.pHash('./path/to/image.jpg') .then(hashedImage =&gt; {...}) ``` That is a normal thing to do with promises and takes advantage of the ability to chain promises together. 
How did you get to 19 balls ...
The real LPT is always in the comments.
is this a question?
It will just resolve to undefined, you don't have to return Promise. It's still probably not good idea to catch the error there though.
Modern browser support is almost 100%, just gets sketchy with some mobile browsers and ie11 back
No, I was able to drag the ball to the right of the canvas. Sorry! 👼
Ah, are you using mobile? I haven’t figured out a reason yet - are you using android?
People new to JS tends to find and use cool new features first :-)
You haven’t seen this before because... it didn’t exist before. It’s new, it’s not just you.
Also worth noting that the bitwise and only works here because the array has 8 items (a power of 2). If there were 7 or 9 the `&amp;` couldn't be used. Modulus (%) does work for non-power-of-two values however.
Chrome on Android.
Www.tylermcginnis.com That’s the best way to learn JS &amp; modern frameworks
Gotcha. I keep a score tab.. I’ll make sure to remit you from it :) 
Do that! :) Actually, I think it may have opened in Samsung Internet. Embedded stuff. Anyways, I got 400+s and only did it once :)
You know it all depends. I recently got recruited to average sized software house with a good renome (100+ employees) and got there because as recruiters said of my above average knowledge of JavaScript. If you’d ask me what kind of resources did I use, I’d tell you none. The only thing I’ve ever done was doing tons of projects, reading through Mdn docs and playing in code wars. Adjust ur learning experience to yourself for best results :)
1 week ago. I have been working with js for 10years, on and off small code projects at work. 
I haven't used plain Express much, tbh. SailsJS is good with different databases, it has pretty decent ORM. Its blueprint API resources are very good point to start when you're getting to know the framework. The request policies are killer feature, I guess. Other than that - it just works and it works good.
I haven't used rails much but sails is good :) It's fast, easy to learn, easy to get going fast. For a rails user it has scaffolding feature (generates code templates etc).
You are correct.
Dapp?
TypeScript lets you add type annotations to js files. Since it's plain JS, all the annotations live in comments. Check out `/**@type {} */` annotations and see if that does the trick. Having said all that, I'm not sure why intellisense isn't already handling the situation you described.
If I understand correctly you want better intellisense but *dont* want to use typescript? Perhaps look at flow: https://flow.org/en/ although I can't say of the top of my head if it would catch your example
Interesting. I've already found that trick here: https://github.com/Microsoft/vscode/issues/31590 but nope, /**@type {}*/ doesn't work. &gt; Having said all that, I'm not sure why intellisense isn't already handling the situation you described. Oh is it supposed to handle such cases by default. Maybe I need to configure something? I have the latest version of VSCode.
For one, if you’re using `await` you don’t need `.then`. This is sufficient: let username = await getUsername(); This will set `username` to the value passed to `resolve`.
Ok, thanks, that's exactly one of the things I was looking for!
https://github.com/Microsoft/TypeScript/wiki/Type-Checking-JavaScript-Files#properties-are-inferred-from-assignments-in-class-bodies The property type should be inferred, since you're assigning it in the constructor.
Please post the exact annotation syntax you are using; it will help debug.
This is the exact annotation. I've opened a folder with VSCode, created the three JS files with their content as described. If you reproduce it, can you get Intellisense working on `m["special_key"]` ?
If blocking isn't an issue for you, there's a package on npm called `syncprompt`. It's written with c++ using the standard library for console input, so it will completely block your program until you receive your input.
I'd still have compile to JS code right ? I'll look at the Flow extension for VSCode but not sure VS Code will let me use type assertion like with TypeScript's `(* as X)`
Is there anything unique here or is this just the same as the general [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence) version?
Have a goal of building a small project that you are proud of and can show to a future recruiter.
I got it working with `/**@type {}*/` . In fact it should be followed with a declaration. import Module from './Module'; import MyClass from './MyClass'; let m = new Module(); /**@type {MyClass} */ let obj = m["special_key"]; obj.print(); Thanks ;)
Angular and React are two very popular frontend frameworks for JavaScript. They are fairly different from one another, and you'd do best to just go look at their respective documentation and tutorials to get a feel for them. Node is a JavaScript runtime for running JavaScript on the server (or anywhere else outside the browser - embedded, desktop, etc.). It is not necessary to learn PHP for web development. PHP is just one of thousands of programming languages that you could use to write a web server (the "backend" in web development). You could use Python or Java as the backend if you like. Some popular web frameworks for Python are Django and Flask. Some popular web frameworks for Java are Spring and Spark. You could also use JavaScript for the backend as well, using Node as the runtime. Some popular JavaScript backend web frameworks are Express and Koa. There is a whole world of options to explore for getting started with web development. I would recommend picking a language you like, looking at the popular web frameworks available, picking one that looks nice to you, and running through a tutorial.
however if I have something like this: function input(msg) { return new Promise((resolve, reject) =&gt; { rl.question(msg, (answer) =&gt; { resolve(answer); rl.close(); }); }); } let test1 = await input('test1: '); let test2 = await input('test2: '); let test3 = await input('test3: '); It ask correctly for test1, it ask correctly for test2, but then it seems to get lost somewhere. The program don't exit, neither it throws any error, but simply don't ask for test3. Can't figure out why
I _hope_ precedence and associativity doesn't change based on the server.
the dictionary is a good sourse 
In general typescript inference ignores string accessed object fields. I could be wrong about why but I believe it has to do with the possibility that the code might need to be executed before the value can be determined. For example say you had an object: const foo = { x1: false, x2: 0, x3: [] } And say you wanted to access the x1 field and store it somewhere else: let x1 = foo[`x${++0}`]; In order for typescript to know that your code is going to access x1 it would have to execute the statement to determine that the string resolves to 'x1'. Furthermore, it could be possible that the string isn't actually resolvable even if the code is executed *unless* other code is also executed alongside it, or it receives a message from a server, or who knows what else that could cause the evaluation to be impossible just by simply executing the code. So rather than try to make typescript infer the values when the string is constant, like foo['x1'] And resolving that cleanly to the same thing as: foo.x1 It appears that the typescript team decided to err on the side of caution and just never infer anything from string accessed fields of objects **unless** there is a directl piece of typing information, or typing comment, or other static and easily read piece of information that explicitly tells typescript what type foo['x1'] actually is.
I'd add [https://eu.udacity.com/courses/web-development](https://eu.udacity.com/courses/web-development) \- they have a few good and useful courses, but otherwise spot-on list. "You don't know JS" is really good and concise for more in-depth knowledge!
Great reply; thanks for posting this!
Try a decent grammar course
That's neat. I didn't know React listened for events at the Document level. I've definitely run into scenarios building modals where I've had to stop a click event, especially for accessibility work. It seems like an event like that wouldn't trigger a function call in React? Something I need to read more about. The way React _presents_ events is the same as how I typically like to do things: keep the function as close to the element that triggers it as possible in your architecture. You end up with more reusable and maintainable code that way. Having that abstraction layer that React provides would be key so you don't need to manually register and destroy each event in a service or something. 
I've built `react-shimmer` 🌠this week! It is a small experimentation project from an [**@Jotform**](https://twitter.com/jotform) intern. (that's me!)⚡️ TLDR; Check it out: [**Github + Live Demo**](https://github.com/gokcan/react-shimmer) react-shimmer 🌠 is a **powerful**, **customizable** React *&lt;img&gt;* component that simulates a **shimmer 🌠** effect while the image is loading. (with zero dependencies!). * Written entirely in next-gen JS. * Designed for both React and React Native. * Exactly zero-dep! Only few KBs. * Animation duration, delay and color options are fine-tunable. * Better error handling compared to default *&lt;img&gt;*. * Same feel of the shimmer effect on different aspect ratios and sizes.
/u/NovelLurker0_0 ^^ this is the answer.
Typescript still compiles to JS code, so I'm not sure what you're avoiding here.
Why, exactly?
Hi /u/dinoloop, this post has been removed. Please do not repost the same project or topic _unless_ there has been significant updates. Thank you.
Hi /u/Shivam_RawatOxox, this post was removed. Please see our rules, and do know that 'Java' !== 'JavaScript'.
Hi /u/maxahd, For javascript help, please visit /r/LearnJavascript. Thank you!
I ran the code in the article with their `i &amp; 7` and then with `i % 8`. On my machine I got about 1.7s using the AND and about 2s using the modulus. I completely agree though that it makes the code harder to understand, I just wanted to point out that in the article's code using the AND does seem to be faster.
Ok
Stop vilifying poor eval! It takes very specific situations to utilize it maliciously, and I doubt this situation qualifies.
You think thats a PITA until you use c++ and have to write "string1" &lt;&lt; int1 &lt;&lt; "string2" or "%s %d %s", string1.c_str(), int1, string2.c_str().
Latest WebStorm EAP supports PropTypes 
It's currently pretty expensive to deploy a contract to the main net. 
You see a fully decentralized platform running a completely transparent casino and all you can come up with is a comment about cryptocurrencies? 
Commonly it’s better to leave the error handling to the caller (user) of your function. So rather than binding a rejected promise to a Promise&lt;void&gt; you’d better leave the catch out and handle it somewhere higher up the call stack. This allows you to present (more) meaningful errors to your users.
So in doing this I would need to create the text file and then have the file be read. Also it would need save the latest number and that would be the thing be reading every-time I login? Using the link how exactly would I do that?
C++ is the winner! 
To be clear, while the example above wouldn't have any obvious side effects it should be noted that `const getName = (person) =&gt; person.lastname;` is actually identical to: ``` const getName = function (person) { return person.lastname; }.bind(this); ``` Which may get one into trouble if they're not clear on that when they go to refactor the `getName` function and start to use the `this` keyword in it thinking it bound to one scope but is actually bound to another. 
You're right - I paid $7 just now for some ridiculously simple code. Ethereum is orders of magnitude more expensive than traditional infrastructure. It's not really useful yet for anything more than fun projects. It's cool to play with though - hopefully in the future it will scale!
Your first example \`\`\` \['B', 'D', 'F'\].replace((subjectArray) =&gt; { return \[ 'A', subjectArray\[0\], 'C', subjectArray\[1\], 'E', subjectArray\[2\], 'G' \] }); \`\`\` can just be (introducing a local var since we aren't calling replace on a hard-coded array, otherwise we can hardcode the replaced array just as easily): \`\`\` let arr1 = \['B', 'D', 'F'\]; return (or w/e) \['A', arr1\[0\], 'C', arr1\[1\], 'E', arr1\[2\], 'G'\]; \`\`\` In another of the smaller examples, \`\`\` const subjectPerson = await getPersons() .replace(createFindOne((maybeTargerPerson) =&gt; { return maybeTargerPerson.id === 1; })); \`\`\` why can't you just \`\`\` const subjectPerson = await getPersons().map((person) =&gt; [person.id](https://person.id)); \`\`\` if that doesn't work there, and you indeed need X find ones executed, imo you could just batch that entire findOne so you aren't introducing X db calls since I highly doubt you can't afford to wait until all the person data is found before continuing. I guess I don't understand your use-case. You mention solving the need for an intermediate variable but \`.map\` and \`.reduce\` should account for what you need especially since both of these give the base array as an operand to their callbacks.
Out of curiousity, and this is meant to be helpful, what part didn't you get? Maybe someone here can help you out. Also, do you have other programming experience that you do understand and feel comfortable with?
Frankly, this sounds terrible. It's functionally equivalent to just calling the function with the array, except that its idiomatic usage encourages god functions. One can argue that considering proposing this to TC39 is a perfect example of "missing the forest for the trees" / "death by a thousand paper cuts" / bloat. 
I would definitely omit your catch. There’s very little that you can meaningfully do to recover from this error, so you should give the caller the opportunity to do so. Imagine a case where someone is using your code for a user app. However, let’s say the source doesn’t exist, and there’s an error. In the UI, we want to tell the user, and prompt them for a new path so they can retry, but we can’t! We don’t know that there was an error, because it was caught, and the end user won’t be looking at the console, they’ll be looking at the UI. In programming it’s tempting to say “error handling sucks, how about we just make them not happen.” But in reality, an error is an error, and _someone_ may need to know about it and act on it. It’s just clearly not this function, because it can’t determine the intent of its caller. Lastly, I’d like to point out that the real “work” here is the work you do “on the image” in the anonymous function. That’s the core of it, and that’s unlikely to cause an error. The rest is just conveniently bundling it up in a way that people probably want it. However, you might just consider exposing that function, because it can then be composed with other processors.
Webstorm has slightly better intellisense for regular javascript. Still nowhere near typescript levels though.
Lodash debounce 
&gt; Your first example This is a visual explanation of the ins and outs of the function; not a practical use-case example. Added a note to the code snippet to avoid confusion. &gt; why can't you just It is unclear what you are proposing here. You've probably meant to use `Array#find`. The reasons for not using `Array#find` are explained in the article. &gt; You mention solving the need for an intermediate variable but `.map` and `.reduce` should account for what you need especially since both of these give the base array as an operand to their callbacks. I give practical examples in the article that demonstrate that `reduce` cannot be used without introducing intermediary variables.
&gt; god functions What is a "god function"?
Functions that do too much (which typically come with the side-effect of making them hard to name)
[A nightmare.](https://iwanttocode.wordpress.com/2012/12/13/god-functions/)
You'd be correct. OP can confirm this by throwing something in vuex on one page, navigating to another and seeing that the state is the same. If it did a full refresh, the store would be cleared.
You'd be correct. OP can confirm this by throwing something in vuex on one page, navigating to another and seeing that the state is the same. If it did a full refresh, the store would be cleared.
Most, maybe all, of the limitations I've experienced with TS come down to the fact that everything is still JS at the end of compilation. So run-time type checking and a few other things I've run into have been a bit of a pain. But that's not TypeScript's fault. Ultimately, I think people who complain about the lack of flexibility with TS either don't really get the trade-off between static type checking and flexibility, or simply haven't really bought into the benefits of such a language. For the former group, the salient point is: you should prefer to experience a bit of pain / inflexibility during development than to experience serious issues in production. For the latter, I guess it just comes down to preference. But I personally wouldn't want to work with someone who is on the flexibility uber alles wagon. 
where are the .reduce examples? The word reduce is used 5 times not one of which is a method call.
are you suggesting I go with the 2nd option or are you just simply recommending lodash if I should choose that option?
In all honesty I had quite a few absences from class that probably cost me. I had an old school instructor who heavily taught around jquery and she was bombarded with teaching 4 other programming classes so she was never really around to help. We rushed into the jquery part of the course and I was absent during that time. She would always say “if you don’t understand this you can find free online tutorials”. She just wasn’t very reliable or available. 
How is `array.replace(a).filter(b)` any different than `a(array).filter(b)`? This seems like a step backwards considering the [pipeline operator](https://github.com/tc39/proposal-pipeline-operator) and [function bind operator](https://github.com/tc39/proposal-bind-operator) proposals.
I have mixed up "reduce" and "replace" multiple times throughout the article. Fixed. Thank you for pointing it out. &gt; I give practical examples in the article that demonstrate that reduce cannot be used without introducing intermediary variables. Here too: `filter`. Which examples do you suggest would avoid an intermediate variable using `.map`/ `.reduce`. 
This could be said about any part of JavaScript. It is up to the user to write functional code. Language cannot enforce it. The sole purpose of `Array#replace` (or the pipeline operator) is to avoid breaking method chain, i.e. so that instead of: const getVenues = async (countryCode) =&gt; { const foreignVenues = await get('http://...'); const countryVenues = foreignVenues.filter((foreignVenue) =&gt; { return foreignVenue.countryCode.toUpperCase() === countryCode.toUpperCase(); }); const duplicateForeignVenues = findDuplicates(foreignVenues, (maybeTargetForeignVenue) =&gt; { return maybeTargetForeignVenue.id === foreignVenue.id; }); if (duplicateForeignVenues.length) { console.log('duplicate foreign venues', duplicateForeignVenues); throw new Error('Found duplicate venues.'); } return countryVenues .map((foreignVenue) =&gt; { return { guide: { fuid: foreignVenue.id }, result: { fuid: foreignVenue.id, name: foreignVenue.name, url: foreignVenue.url } }; }); }; We could write: const getVenues = async (countryCode) =&gt; { const foreignVenues = await get('http://...'); return foreignVenues .filter((foreignVenue) =&gt; { return foreignVenue.countryCode.toUpperCase() === countryCode.toUpperCase(); }) .replace((self) =&gt; { const duplicateForeignVenues = findDuplicates(self, (maybeTargetForeignVenue) =&gt; { return maybeTargetForeignVenue.id === foreignVenue.id; }); if (duplicateForeignVenues.length) { console.log('duplicate foreign venues', duplicateForeignVenues); throw new Error('Found duplicate venues.'); } return self; }) .map((foreignVenue) =&gt; { return { guide: { fuid: foreignVenue.id }, result: { fuid: foreignVenue.id, name: foreignVenue.name, url: foreignVenue.url } }; }); };
&gt; How is `array.replace(a).filter(b)` any different than `a(array).filter(b)`? It is not. However, that is not the example either. The example is: array.filter(a).replace(b).filter(c); which you can achieve with: let intermediateVariable = array.filter(a); b(intermediateVariable); array.filter(c); 
Where’s ~? I use ~~num to truncate numbers and forget when I need parenthesis around it
Or: `b(array.filter(a)).filter(c)` Aside from being slightly easier on the eyes, I don't see the benefit of a `replace` method.
The function itself looks good, except for the `catch` others already pointed out. It returns a `Promise` so you need to `then` it. ``` pHash(source).then((hash) =&gt; { console.log(hash); }); ```
The mention of "god function" (a function that breaks all the functional programming paradigms) came into this conversation without any context. &gt; [..] its idiomatic usage encourages god functions This was stated without any arguments. `Array#replace` can be used in a with pure or non-pure functions, the same way that every other Array prototype method can. The method method itself either by its name or API does not encourage either. The only difference is that this method encourages working with the entire array at once over an item of an array, but the same argument could be made about `Array#reduce`, `Array#map`, `Array#filter` and others. Please don't spread FUD just for the fun of participating in a conversation. There are better ways to participate.
I do agree with you that the way Angular forbids you from manipulating the DOM is bogus as hell.
Have you considered writing arrow functions without `return` statements (when they are only doing one thing)? You can go like this: `foo =&gt; foo * 2` or `bar =&gt; bar === idParameter`. And if you need to return an object, just wrap it with parentheses: `(foo, bar) =&gt; ({ a: foo, b: bar })`. Thanks for the article!
The primary advantage of `Array#replace` is (as you pointed out) that is makes easier to read the code. array .filter(a) .replace(b) .filter(c) .replace(d) .filter(e) .replace(f); Is a lot easier to read than: f( d( b( array.filter(a) ).filter(c) ).filter(e) ); or you will need to introduce intermediate variables. I don't think it is worth playing with one-line examples as this does represent real-world usage, esp. when we have examples that do (in the article). By the way, you've mentioned pipeline operator. I absolutely agree. I actively participated in discussions about that proposal (https://github.com/tc39/proposal-bind-operator/issues/24) and even created a Babel transform for it (https://github.com/gajus/babel-plugin-transform-export-default-name). It will be a useful operator. The appeal of `Array#replace` is that it abstracts equivalent functionality without introducing new syntax. 
I don't want to discourage anyone making an earnest effort, so first off: thank you for writing this thoughtful piece and encouraging discussion. Every idea that inspires interest moves progress forwards, no matter what comes of it. Second, and I say this with the utmost respect: this idea is terrible. 
That's a shortsighted refactor IMHO. Here's another one: const getVenues = async (countryCode) =&gt; { return getVenueDTO(errorOnDuplicate(byCountryCode(await get('http://...')))); }; const byCountryCode = foreignVenues =&gt; { return foreignVenues .filter((foreignVenue) =&gt; { return foreignVenue.countryCode.toUpperCase() === countryCode.toUpperCase(); }) } const errorOnDuplicate = (self) =&gt; { const duplicateForeignVenues = findDuplicates(self, (maybeTargetForeignVenue) =&gt; { return maybeTargetForeignVenue.id === foreignVenue.id; }); if (duplicateForeignVenues.length) { console.log('duplicate foreign venues', duplicateForeignVenues); throw new Error('Found duplicate venues.'); } return self; } const getVenueDTO = (foreignVenues) =&gt; { return foreignVenues.map((foreignVenue) =&gt; { return { guide: { fuid: foreignVenue.id }, result: { fuid: foreignVenue.id, name: foreignVenue.name, url: foreignVenue.url } }; }); } With this one, one can use `compose` or pipeline operators, and one can reuse the logic about throwing on duplicates on non-foreign venues. It quickly shows if variable names are too specific. It lets you unit test the logic for a requirement in isolation. It makes it clearer for later refactors which architectural layer each snippet belongs to. Etc, etc. You started from the premise that naming things should be avoided, but that's actually not a very good axiom. The underlying message behind the saying about naming things being hard is that you should put extra care into naming things properly, not avoid doing it altogether. Naming things properly means one gave it thought to what the pieces are and how they come together. Avoiding it means you're likely not giving enough thought to the long term maintainability of the project as much as you could be.
Thank you for the suggestion. I adhere to the following style guide: https://github.com/gajus/eslint-config-canonical The are pros and cons to both arrow function body styles: one is more succinct at the cost of readability in certain cases (I have seen variations of `x =&gt; y =&gt; (z =&gt; (e))` all too often), while the other is more verbose with the benefit of clarity.
Sweet. I’ll take a look at that. I particularly like to have no return on arrow functions for single line problems (it makes them easier to my eyes). Thanks for the link!
TypeScript can infer a lot about the types without you explicitly defining anything. I have multiple, large services that utilize TS and I really don't see a "pain point" beyond the initial overhead of TS as well as understanding its purpose. Knowledge of the represented data types and structures and being able to fix those before encountering a JS type error is indispensable on larger projects. For those wanting to assign anything to anything, I find it hard to call this flexibility as it requires a deep understanding of your code's context. Most simply, I have found it to be the kind of thing that is hard to go back from. It can help you keep shooting yourself in the foot.
From what I have seen, many people use TypeScript as if it were Java. But you can profit tremendously from using features that it borrows from functional programming languages: interfaces for objects, discriminated unions etc. And `--strict` is a must.
&gt; You started from the premise that naming things should be avoided, but that's actually not a very good axiom. It is more about avoiding unnecessary variables and it has to do with code style as well. Someone could get away with: let venues; venues = foreignVenues.filter(a); venues = b(venues); venues = map(c); However, my style guide pretty much enforces no use of `let`. As such, I would write: const filteredVenues = foreignVenues.filter(a); const deduplicatedVenues = b(filteredVenues); const normalisedVenues = deduplicatedVenues.map(c); Someone else could get away with: const normalisedVenues = b(foreignVenues.filter(a)).map(c); But of all these options, `Array#replace` provides the most consistent and easy to read expression: const normalisedVenues = foreignVenues .filter(a) .replace(b) .map(c);
I am not a native English speaker, still working on it.
Yep, this is correct. Go to http://bikeva.com and use the menu to navigate, you'll see it just fetches a new .js file/webpack chunk instead of going to the index.html file for that directory.
Scam. Reselling PDFs from Humble Bundle ebook bundle.
In cases like: `['B', 'D', 'F'].replace((subjectArray) =&gt; {return ['A',subjectArray[0],'C',subjectArray[1],'E',subjectArray[2],'G']});` It seem like you could use a reduce function with a signature like: `array.map(toWhatever).reduce(withInterpolatedArray(externalArray))` I think what you're proposing would sometimes be convenient (like the `let` or maybe `switchMap` operators in rxjs), but it seems like it could easilty lead to anti-patterns of doing stuff really literally rather than functionally, like manually destructuring and reassembling parts of an array, as you did in your example 
I felt the same way learning Python, which uses various things but a lot just has stuff like C's `printf()` JS template literals are the best! Kotlin's are good too, same syntax I think.
In addition to the other already good posts here I think a lot comes down to developers who have never used a type system before and don't understand how to use one. Parts like generics are *extremely* useful, and even more powerful in ts than in say C#, but many developers unused to a type system have no idea how to use them even if they know they exist. To be fair there are some things that aren't expressable in typescript as well. These generally boil down to **really** generic functional style programming and are mostly the concern of libraries like lodash but they do exist. For the average developer writing an application you can usually easily define how generic types flow through somewhat constrained functions but it can be impossible for very particular use cases that, again, generally only come up when writing pure library type code. From my limited understanding this has to do with typescript not using a variadric type system. Typed functional languages like Haskell can express these behaviours but not ts. In the end though for your average application I think it comes down to not knowing the type system well enough more than real limitations in it.
Most of these examples are using the wrong data type (if you're trying to do a look-up for something, please use a hash like object). Regardless, I don't see the upside to this. It's almost just `map` or is `forEach`.
I personally love flow-oriented programming. This is basically the pipe operator, but just for arrays. I would rather the pipe operator be a first-class citizen of JavaScript than just offering it as an odd method for just arrays. Compare: ``` arr .filter(f) .replace(r) .map(m) ``` with ``` arr .filter(f) |&gt; r .map(m) ``` or am I misunderstanding?
To me the whole premise of the article is wrong: Those examples don't need Array#replace, they need some extract method/variable refactorings to make that code readable. Naming things is hard, but that doesn't mean you should avoid naming things by all means. You should instead spend more time choosing good names. Don't optimize for writing code - optimize for reading code. You do that much more. Especially in a team.
You are absolutely right. I am surprised few people are familiar with the concept (or with the [pipeline operator proposal](https://github.com/tc39/proposal-pipeline-operator)). However, that proposal has been around since 2015. The `Array#replace` is what I always thought would bring most of the same benefits and it would a lot let controversial than a pipe-operator (in terms of the scale of the change). The former is simple to implement/ polyfill and does not introduce new syntax.
Right. On a personal level, I perceive a much lower usecase for `Array#replace` in particular compared to the pipeline operator (which can work on any operands), perhaps because `Array` already has so many amazing methods already. I don't know that I would vote against it if I had a vote, but I doubt I would champion or argue for it either. I might vote against it because of my next point. Have you considered making it an `Object#replace` or `Object#pipe` rather than `Array#replace`? I have trouble believing that would be any more controversial than `Array#replace`, but it would be much more general purpose and, in my opinion, *much* more valuable.
&gt; It can help you keep shooting yourself in the foot I know this is a typo but I find it hilarious anyway. :)
Reddit needs more people like you.
Very cool! Are the matrix transforms handled by WASM? How often is WASM called? Every frame? How do you minimize the latency of passing data back &amp; forth between WASM &amp; Javascript?
Greatest improvement I've seen in my work was from understanding and applying map, reduce, filter, etc. and applying functional programming principles in my code. 
Even better if people explain *why* things are terrible! This code: Array.prototype.replace = function (map) { return map(this) }; Is completely redundant. It's literally the same as `const array2 = someTransformationFunction(array1);`. This way you don't pollute the Array namespace either.
&gt; Have you considered making it an Object#replace or Object#pipe rather than Array#replace? I have trouble believing that would be any more controversial than Array#replace, but it would be much more general purpose and, in my opinion, much more valuable. I can see value in what you are proposing. In general, the sole purpose of this article is to share my thoughts out loud and to see how it clicks with the development community. If it had received an overwhelmingly positive feedback, I might have started tinkling with a proposal. Thats about it.
I'm a fan of TS. Wish I used it more, as I'm also a fan of a more functional style JavaScript so having static typing on everything would be great. Which brings me to the biggest pain point I've encountered, library typing support. If you're using a fairly popular library, there's more than likely typings available that are very good if it wasn't already written in TS. This isn't always the case though, for example, my favorite and most used library Ramda.js (the last time I tried) had terrible typings. Aside from it constantly throwing fits about argument types and just having to keeping throwing in `any`'s to get it to compile, it didn't even have all the available functions defined so TS wouldn't compile if I tried importing a function that wasn't defined in the typing. So, then I wasted about **6 hours** fighting with TypeScript trying to just augment the typing module to add the declarations for the missing functions myself, and eventually I just gave up that endeavor. Fortunately, I haven't checked up on this yet, one of the biggest issues with typing Ramda was that all it's functions are curried, and TS didn't have a way that could elegantly type a curried function, however I believe one of the more recent TS releases added some typing features that would actually make typing curried functions possible. So, I guess my point is, TS is great especially for large projects (oh my lord VSCode TS intellisense makes working with my largest JS/TS project so much easier). However, if you've got a library that you are really tied to and love to use (like me with Ramda) make sure you check out it's typings support, so you don't run into a bunch of headaches trying to use it.
I see. You seem to be getting a lot of backlash for what I believe to be (and what you argue is) completely invalid reasons (like "Oh but what if the function has side-effects" or whatnot). I think maybe if you word it as a "less controversial substitute for the pipeline operator", it'll resonate better. I also believe it will be less misunderstood, as the pipeline operator tends to be understood marginally better.
Example from docs: router.get('/', (ctx, next) =&gt; { // ctx.router available }); Your code is the equivalent of: const callback = (ctx, next) =&gt; { }; router.get('/', (ctx, next) =&gt; { callback(ctx, next); }); Examples in the docs are well written. Your code isn't. It's redundant. 
Valid suggestion. I will keep an eye on how the pipeline operator proposal progresses (I hope it does!). If we are in the same situation 6 months down the line, I will take the learnings, repackage this and propose it again.
It occurs to me that the problem with `Object#pipe` is that many classes override it already. I don't know why this didn't occur to me. I find this extremely unfortunate as, come to think of it, I think I would prefer a `.pipe(f, a, b)` syntax over the `|&gt; f(a, b)` syntax. 
you do know that replace function is just a named reducer, right? it just doesn't reduce the array down to an element, but to another array. So you can just write tat reducer and not break any chain
But if you read the article you'd realize the advantage of `replace` over calling `m` directly. Not saying I support it, but I can see where the author is coming from. It's basically return x.filter(filterfunc).replace(replacefunc).map(mapfunc) vs return replacefunc(x.filter(filterfunc)).map(mapfunc)
Our Team uses React and honestly it's way better than Angular especially at scale. In my opinion one of the reasons why React scales better is due to the fact the framework is actually used in Facebook's core product, where as Angular is not used for anything at Google and only exists to sell consulting services to Enterprises. **Reasons why React is better:** 1. It scales better and has been proven to work on large popular projects used in core products from companies like Netflix, AirBnB, JIRA and more. Angular is new, is getting very little adoption, still making breaking changes and completely unproven. 2. The generally API pretty much never changes, only different between versions are added features or performance improvements under the hood. 3. React's design patterns make code super easy to reason about and refactor. 4. Since it's super popular there are so many libraries and online resources for you to use. With Angular you need to sort through results for older previous versions that may not be relevant to the version you're currently using. Fact of the matter is Angular was built simply for consulting, which is why you see so many sales people calling Enterprise companies trying to get your teams to switch over. Also if your team really really likes ng-1.x then just move to Vue, it's more similar to the old Angular and wasn't designed to be a "service". 
"Designed for both React and React Native." &lt;-- I like that part. Looks promising, grab a star :)
Wait, what language is this? "JavaScript"? WTF is that "#"? Something they just made up? Fuck'em.
It's probably a flurry of reasons. 1. Many people that use open source projects like NPM are just plain stupid or have never heard of Google. Even if you truly find a bug, you can most likely find the bug you were going to report already mentioned in a bug report somewhere. This problem is exacerbated by the fact that JS makes development very easy, so you get a bunch of people who have never programmed before spamming issues. 2. They probably get tired of the attitude of the JS ecosystem which seeks to compare every framework and library in existence. I'm sure the comparisons to Yarn don't really help either. 3. People that add no substance to issues and bug reports are the bane of maintainer existence. It makes me mad seeing "+1" in it's own comment. Just upvote the original comment. This again lends itself to retarded open source users that don't understand how to properly use an issue or bug report. You can imagine that all this gets amplified in big projects like NPM. I don't really put too much blame on them, although there have been instances where I've been surprised at their negative attitudes. You just have to remember all the bullshit they have to deal with. I'm sure there are better reasons as well.
That’s fair I think my thoughts on this just stemmed from Kat on twitter being extremely hostile about the idea of a package.json standard claiming the dude was “some rando” and was big enough to be allowed to do an RFC spec, wasn’t very positive, and went out of her way to be negative to somebody https://twitter.com/maybekatz/status/1014270528209555456?s=21
This was very cool! Thanks for taking the time to write about this!
Yup, makes sense. Thanks for the help.
Yeah I'd agree that it was an unnecessarily rude and hostile way of addressing the issue. I'm sure she knows her stuff, but it was just an excessively mean way of explaining what could have been constructive feedback. I don't like how she pulled gender into it - being rude is being rude, and it's fair that this was pointed out. I'm a woman too, and examples of rudeness and extremism associated with feminism are harmful to all of us. 
I think this case can be solved by the pipeline operator instead of a method on the Array prototype. 
Couldn’t get it to work in RN. 
I'll try to avoid -to the extent I can- repeating arguments that have already been made, though, really, the arguments already given are enough. I think there's a salient problem with this idea: You fail to make a compelling case. This is clear by the responses you got, but it should make you ask yourself: Why? Why doesn't this sound like such a good idea? I see two main potential reasons: - It is indeed unnecessary. Is this so? I think it is. You may not agree, of course. But trying to be somewhat objective, I can't really think of any real situations where I'd want this particular operation. You say "This becomes useful anywhere when you require to operate on the entire array within a method chain", but really, I'd say this happens very rarely if ever. Generally, you want to _iterate_ over the collection (see below for more on this). There may of course be some situation where you _might_ need something _close_ to this, but then we come to the second reason. - You don't make it compelling. That is, the examples you used, don't really justify the need for this. In particular they are either _dubiously_ oriented (meaning that the general initial approach to solve this is already dubious and that one should probably focus on doing it in a better way), or they fail to make this method justified enough. Personally, I think the code you present is not such a good subject for _chaining_. I mean, wanting to throw _explictly_ in the middle of a chain means you want _branching_. It may be debatable whether it is a good idea or not to introduce branches in a chain, but even if we were to agree that we wanted it, your proposed solution does not reflect this idea. It is a too coarse solution. What's more, I think your example clearly reflects this. You insert a call in the middle of the chain that just passes the whole array... and _what for_? To then iterate over it on your own, _out of the chain_, and "hide" both the iteration and the branching. I think a much better idea would be, depending on the actual intention, to use either a `tap`/`intercept` or a `reduce` over the collection.
A styleguide that prohibits the use of let isnt a styleguide, its and misunderstanding. If you meant the linter, then it fits better but I still think its a stupid choice. Just because someone decided its bad to reassign variables you ended with a poluted Array prototype, which has far worse consequences commonly agreed among the community (in contrast to using let, which is merely a preferrence)
No.
At least someone knows what they're talking about in here. +1
No.
What is your opinion regarding the usefulness of the pipeline operator (https://github.com/tc39/proposal-pipeline-operator)? Do you see it as something that provides different functionality then `Array#replace`? (and what are the functional differences)
It's a fairly common notation in documentation. JavaDoc is probably the first. Rdoc uses it as well. Guest what also uses it: [JSDoc](http://usejsdoc.org/tags-inline-link.html)
This is a great introduction! Short note on tail calls not blowing the stack: While proper tail calls are in the ES6 specification, browser vendors have resisted that part of the spec. As far as I know, Safari is the only browser that handles tail calls the ES6 way today. Chrome had support briefly in canary, but they removed it later.
It's been a year since we transformed the project that I'm on into TypeScript. I'll just give a few tips that might be useful for newcomers. Firstly, TypeScript has a much more powerful type system than languages like C#. It wasn't obvious for me at the time but you can actually describe very complicated things with TS type system, so in many cases you keep the best of both worlds and the flexibility of JS doesn't go away. Another thing is that while gradually converting an existing project into TS you learn a lot about how your code actually works. In most cases, when I failed to describe certain logic it turned out that the code itself was kindof wrong. E.g. it wouldn't work in certain cases or have a minor bug. All in all, the flexibility of the language is the main buying point I think. The only thing you might want to resolve with is that you are ready to start thinking in types and grasp the idea how they can save you from tons of bugs and refactoring issues in the future.
Other than the extra overhead of using TS, the only "pain" I've run into is with class decorators not automatically getting the type signatures from the decorator class. But even that appears to be getting resolved [https://github.com/Microsoft/TypeScript/issues/4881](https://github.com/Microsoft/TypeScript/issues/4881) On a large scale project it's a huge boon to productivity and bug reduction.
I despise Typescript. Or rather, I dislike how it is implemented. I've used C++ for a long time, writing apps with Qt5 (awesome lib BTW). I've also wrote Unity Games with C#. Typed languages aren't the issue here. Working with them was a breeze. Pure C can be a pain sometimes but C++ &amp; C# are truly fine. I however never managed to appreciate and work with TypeScript. It's too much trouble for a very, very small gain. I really don't see the gain in working with TS as it is now. I've tried to adopt it. I did my best to be friend with it, but all in all I just notice I'm wasting time. Last month I had a full vanilla project I needed to update from the ground up. I setup a basic webpack + babel project and then I though, how about I seriously use TS for once? Haha the joke. I had the doc opened, the handbook, everything in order to "learn and apply" TS the VERY right way. It took me hours just to write a couple of modules...I soon gave up because I know it wouldn't worth it to spend years fixing "errors" that I know run perfectly well in vanilla JS. Too much trouble for a small gain. I settled for ES6 + JSdoc and that's SO much better. VSCode Intellisense is already very good and you can fit some jsdoc comments to help it. Unless TS is made more passive, I'd not ever even try to use it again. With this setup, I really don't see the gain of TS. I did my best, I really did, but always I end up wasting my time, so no...TS, I pass. For reference, never once while coding with C++ or C# I thought I was wasting my time. I hope I won't have a job that involve working with TS. I did PR to some TS projects, it wasn't the end of the world but God the frustration...I can't imagine myself make a living with that. I find working with PHP5 even less frustrating although it is a language I despise too.
I personally am not _too interested_ in the pipeline operator. I'd say I have a _neutral_ opinion on it. I can (and do) live happily without it, but I _might_ use it some day... occasionally, not really that frequently. That said, I do think the _general intention_ may, to some extent, overlap with your Array#replace idea. The approach of the pipeline operator is, however, more consistent and uniform. (IMHO, of course)
You know you can add the library type definitions yourself, right? If you find a library with terrible typings, improve them and contribute to the public typings repo.
Tbh even seasoned veterans of types languages often struggle with generics when used poorly. That isn't such a issue with TS as it is with generics.
Just make sure to slap redux and typescript on top and you'll be golden.
I guess everyone who uses Angular is a bad programmer then. 
I strongly prefer the function bind operator. It is basically the replace method on every type... function makeGreat() { makeFancy(this) makeBlazing(this) } document.body.somethingelse::makeGreat() This way you can chain on every type with any external libraries. 
Generally the issues I run into are areas where code has been abusing JS's loose morals and/or added typings as an afterthought and suddenly TypeScript has a fit with JS that *works* but isn't properly typed. You'll find no shortage of github issues with people sharing hacks to get typings to work properly for some edge case in &lt;insert your library&gt;, and that can eat up time that could be better spent adding features and fixing bugs. That said, you can create typed portal functions that encapsulate that tricky logic or break the emergency glass and beat the code into submission with `as any as TheTypeIWant`
Oh yeah, it was something I considered, but the most used typings for Ramda (I believe) where made by some other person, so not official, with the message that they likely weren't going to be maintained. So, I actually just wanted to rewrite them from scratch, but I figured I'd wait until some of the new typing features were released so I could actually get good typings on the curried functions (and then naturally have been caught up with other shit that I haven't even had the chance to think about it). TypeScript 2.8 I think is what I was one of the releases I was waiting for (conditional types) after I quick google. May give it a shot this weekend and see how it goes.
I totally agree, which is why Reddit needs more people like you, who go on to explain why!
&gt; It's too much trouble for a very, very small gain. Out of curiosity, what's the largest JS codebase you've worked on?
The flexibility/dynamic typing of javascript is great for very small things but developing and maintaining medium to large project becomes a nightmare. I use js for about 70% of my code and I generally love it, but damn it was nice to be using C# again in the past weeks. Having proper code completion, knowing what types an external function expects as arguments, etc. are awesome.
Thank you
Maybe it was too toxic because they made it that way. Maybe them jumping ship was really just gas lighting.
Can you tell me why React scales better? We’ve found angular and typescript (angular 2-4) to be very easy to work with. 
Well Typescript is all the more reason to use React over Angular since in React all code can be Typechecked whereas Angular's templates cannot. In fact our team uses TypeScript with React: Here is a good starter: https://github.com/Microsoft/TypeScript-React-Starter
So scalability wise what does React have over angular?
Thanks. I tried that and it doesnt work. Instead of cors I get shaka-player.compiled.js:305 HEAD https://blah.s3-website-us-east-1.amazonaws.com/test-dash/test.mp4 0 ()
I can't link the repo because of privacy but the largest JS codebase I've been working on would be that one I started 2 years ago which is now 20 000+ lines of code, including the core and all the plugins that goes with it. Not sure how big that is, but that's it. It is that project I said is going to be reworked. I've found just a plain webpack project for modularity and ESlint + JSDoc was enough. I've tried to work with TS as I said but failed to see the gain. 
I like resolving errors instead of rejecting them. It allows me to send the front end an error: true and a custom error message without having to reject anything. Yes if it's asynchronous you'd have to check if error is true, so that's an extra truthy check, and yes - the function will always return an object instead of a regular variable but that's actually a pattern I try to enforce, the RORO (receive object, return object). Is this a bad idea?
This is one of the reasons that writing libraries in TypeScript is awesome for consumers of you’re library. Even if they aren’t using TypeScript, a lot of IDEs will import the definitions and provide intelesense.
Stop spewing bullshit. Angular is used in over 600 apps at google. Just watch latest google I/O about angular, where they will boast about it.
You’re misusing your stream reader there: you’re closing it after you first use it! Once closed it won’t read anything further and so `question` will never call your callback. Close it only after you’re done with it.
20K is very small; still beneath the point where I'd consider TS an absolute must. (For context, I wouldn't consider the largest app I've worked on to be particularly huge in the grand scheme of things, and it's over 400K source lines of JS/JSX and counting). Also you being the only person (I'm assuming) on the project is a different situation from one where a dozen people are working together. In addition, building a game engine (you probably have zero dependencies) is different from building an app that consumes a bunch of third-party libraries. Of course _you_ are not benefitting from the API discoverability that TypeScript offers, but anyone using your engine probably would. (All this being beside the fact that you do benefit from TypeScript anyway - VS Code is built almost entirely in TS and its "very good" JS intellisense is powered by it)
Postgraphile is like 5 minutes
Yeah, the whole "naming variables is a pita" argument goes to the trash with the pipe operator.
But do you practice algorithms?
Her points are extremely valid, though, and given the situation I think she has pretty good reason to be very annoyed. The person making this spec is making grandiose claims to projects that they apparently aren’t working with and so are at best insignificant and at worst actively harmful.
Okay. I'd have to wait to work on such large codebase than reconsider TS. Thanks for the comment.
I would tend to disagree about the "easy to read" argument. `a`, `b` and `c` are not really related to each other in any way other than the fact that they operate on a list of venues. The fact that they need to be abbreviated is a very strong hint that the parent function (getVenues) has too much subroutine logic inlined into it (i.e. it's kinda of a god function). In functional programming terms, what you're trying to achieve when you talk about reducing variables is called point-free style. Using `compose` as I had mentioned earlier (or maybe `pipe`) would be a standard technique to get closer to point-free style. The reservation I have about making this a proposal is that there's not much substance in terms of semantics. Something like `arr.replace(arr =&gt; arr.length = 0)` could just as well throw as it could do completely crazy things, for all I know. I wouldn't really mind if you monkeypatched Array.prototype in your own project (other than maybe being slightly annoyed if I ever had to maintain that), but I think a TC39 proposal needs to be held up to higher standards (no pun intended) when it comes to unintended consequences and design weaknesses. For example, I could argue that array.toSet() should be a standard and I can give you plenty of examples where it would be nice to have, but that doesn't mean making it a standard is a good idea: `new Set(array)` already exists, and I haven't gone through the effort of making sure my idea doesn't do weird things in unforeseen cases, e.g. sparse array handling). 
I 100% understand where the hostility comes from. What I can't understand is how such a large project can let such critical bugs through to production. What is the problem with NPM's performance? Why is it SO much slower than Yarn up until recently? Even then it's noticeably slower. What's with the cross-platform incompatibilities (package-lock.json and the filesystem stuff)? How do they let bugs through that literally destroys the host machine? I feel like the NPM maintainers are somewhat mediocre at what they do.
The demo crashes on mobile safari.
What you are looking for is TypeScript’s other, slightly less understood ability to just infer JavaScript. TypeScript supports a jsconfig.json configuration file that you can configure (I’d suggest non-strict in your case, based on comments in a separate thread) to provide what autocompletions it can and help you catch silly errors. You can stay in this mode indefinitely, but you would easily be able to convert to full TypeScript over time.
I think that’s not something I wouldn’t do, but it allows a caller of your function to distinguish an error from a success and act on the error, which is the most important thing. Why I personally wouldn’t do it: - I can’t trust that I don’t have to catch anyway. - I now can’t assume that I have “good” data when I add continuations. It’s nice that errors “hop” over code paths that aren’t for it anyway. - Other libs won’t do this, so I have to wrap them if I want this behavior. - Ultimately this just means you have to check for errors in more places. JavaScript error handling is just kind of a pain. It’s very hard to know what _can_ go wrong, and when trying to recover from an error it’s hard to know what _did_ go wrong. It’s one of the prices paid for its dynamicness.
That's because if you look at the source, the RN part isn't implemented yet :D
Pro tip. MDN has all of this already
I think omitting the catch like others said is a mistake. In service or library logic which this looks like, prefer to log or handle the error AND allow the user to deal with it. Just throw it again from catch. 
I preferred this write-up, personally.
I recently attempted to rewrite some code that generated SVG elements to create UI components in Typescript. I was hyped about the type system at first. Then I discovered that some methods that should be on the Node and Element types in the standard type def are instead defined on HTMLElement and couldn't be used on SVGElement types. My consensus is that Typescript isn't useful in every case. FYI: Flow has the same issue.
Yeah I saw that after. I have a perfect project for this. Thanks for sharing. 
Although npm does have a large user base, I don't really see how any of those points are specific to to npm.
&gt; uses condescending tone, but says something completely irrelevant I'm not sure if you are in the wrong thread or what. Nobody is talking about Redux.
Maybe I’m completed missing something but I feel like all the problems mentioned in the article and in the comments can just be solved with ‘Array.prototype.reduce’.
Debouncing is the best option that could be thought of that prevents unnecessary AJAX calls 
&gt; I soon gave up because I know it wouldn't worth it to spend years fixing "errors" that I know run perfectly well in vanilla JS. If you were getting errors then, no the code wouldn't work perfectly
babel express lodash ....
For runtime data type checking you could use import ‘metadata’ I believe that’ll add some form of reflection to your code. It might take a performance hit though
JFC. How much of this would you actually have to learn? I'm studying full stack webdev right now and it seems impossible to reach a level of competence if you need to keep up with the ever expanding toolsets. How do you guys do it?
you need userInputBase27.length in your for loop
Lol I hate you. 
Writing types for ramda is really not a trivial task. Currying and variadic functions are still difficult to write types for even if you're writing Typescript ([for example](https://github.com/gcanti/fp-ts/blob/master/src/function.ts)). The Typescript team has to strike a balance though; Scala for example has notoriously long compile times.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [gcanti/fp-ts/.../**function.ts** (master → c3ef83e)](https://github.com/gcanti/fp-ts/blob/c3ef83e00c068a502109680da2e1041441118dc5/src/function.ts) ---- 
Or they could use \`reduce\` and not bother with multiple iterations like this...
The biggest pain is mentoring team members who have never worked with a type system before.
I had similar thoughts and dont see the advantage over just using reduce. Not to mention you can cut down on one iteration of filter + map just by using reduce. It's not like these are lazy sequences. Anyway, I must be a pleb. If this is about a "threading" operator I don't see why it would be on the Array prototype but Id imagine something that works across "collections" similiar to thread-first / thread-list work in clojure would be great in javascript.
Many electrical engineers would not consider opcodes to be low level. Many physicists would not consider NAND gates to be low level. Most web developers do indeed consider C++ to be low level :)
XD thank you!
I said nothing about your function. I explained what a god function was. And they are nightmares. Stop being a defensive little shit.
Learning to search for solutions - done 
I don't get why this one tweet from Kat is getting all this attention given it's frankly more restrained than she often us on anything a male touches.
&gt;I feel like sometimes the beauty of JS is the flexibility of variables / parameters. I don't really get this. Are you writing functions where the parameters are undefined and it acts on whatever it gets?
All of these: 1) Wait until the user finishes typing 2) If the current input is larger than 2 characters in length 3) If the current input is not the same as the previous input You could *technically* implement request abortion as well, but I find that it's far too complex when combining the above 3 gets the desired result. Here's an example in vanilla JS: // a debounce function will only call `callback` after `ms` milliseconds have // passed since `callback` was previously called. function debounce(callback, ms) { var timeout; return function () { var args = arguments; var context = this; clearTimeout(timeout); timeout = setTimeout(function () { callback.apply(context, args); }, ms); }; } // a place to store previous searches var previousInput; // a debounced function that will only execute 750 milliseconds after it was // previously called (so, 750ms after the user has stopped typing). var handleSearch = debounce(function (event) { var currentInput = event.target.value; // ensure input is at least 2 characters long (there's no sense in sending a // request for just 1 character of input) if (currentInput.length &gt; 2) { // ensure current input is not equal to previous input (otherwise, we'd be // sending two identical requests) if (currentInput !== previousInput) { /** * MAKE YOUR REQUEST HERE */ // update previous input previousInput = currentInput; } } }, 750); // finally, attach the event to the search bar. document.querySelector('#search').addEventListener('keyup', handleSearch); As you can see, there's still quite a bit of complexity going on. We can simplify this with ES6 and RxJS Observables (version 6): import { fromEvent, from } from 'rxjs'; import { debounce, map, filter, distinctUntilChanged, flatMap } from 'rxjs/operators'; fromEvent(document.querySelector('#search'), 'keyup') .pipe( debounce(750), map(event =&gt; event.target.value), filter(input =&gt; input.length &gt; 2), distinctUntilChanged(), flatMap(term =&gt; from(fetch(`https://api.host.com/search?q=${term}`))) ) .subscribe(searchResult =&gt; { // do something with the search result });
ahh typescript, the square peg in the round hole of web development. i avoid it when i have a choice. compilation time, keeping typings up to date, constraining a language whose strength is flexibility. i just don't see any benefit from it whatsoever.
If you wrote out all of the steps to learn how to paint a painting, it would seem more complex than this. 
&gt; I love when men tell me to be more polite. I usually tell them to fuck off, in so many words. https://twitter.com/maybekatz/status/1014318140216389632?s=19 What the hell.
&gt; /** * Obtains a list of venues from a remote API, filters out venues beloning to * a different country than `targetCountry`, ensures that all venue IDs are unique * and describes venues in a local venue format. */ I don't get it. Why 3 iterations over the array (filter, filter, map)? What is the purpose of an interrupted method chain in this particular case? const getVenues = async (countryCode) =&gt; { const foreignVenues = await get('http://...'); countryCode = countryCode.toUpperCase() let ids = {} let venues = [] for (let foreignVenue of foreignVenues) { if (foreignVenue.countryCode.toUpperCase() !== countryCode) continue if (ids[foreignVenue.id]) throw new Error('Found duplicate venues.') ids[foreignVenue.id] = true venues.push({ guide: { fuid: foreignVenue.id }, result: { fuid: foreignVenue.id, name: foreignVenue.name, url: foreignVenue.url } }) } return venues } Where's the verbosity?
Honestly, that example reads fine, provided you grok higher-order functions. But maybe it’s a degenerate version of something truly gnarly. Either way, I prefer old-school `function(x) { var y = x.foo(); return bar(y); }` for anything past a trivial lambda. Nothing in between. I’m not sold that `(a, b) =&gt;` is “more readable” than `function(a, b)`. It’s very much potato/potato. Except one potato is supported by Netscape 4.0. *and* Chrome. 
Knowing about the useful algorithms is much more useful than knowing the algorithms themselves. Soft lighting, sorts, dithering, etc. Algorithms are one of the few code snippets that professionals would copy-paste.
In VSCode when you have CheckJs set to true and you escape a property name in [""] that property is also escaped from the TypeScript engine, so it can't know about it to give you intellisense. Instead change it to: this.special_key = new MyClass() If you are going to write plain JavaScript in VSCode and want intellisense, you'll need to provide the type information through JSDoc comments /** @property {MyClass} special_key */ this.special_key = new MyClass(); This will give you intellisense when you hover of the special_key property on a class instance. 
it's just a misunderstanding of why javascript is "flexible" javascript is flexible because 1. javascript is a multi-paradigm language (imperative, functional, object-oriented) 2. javascript's prototypal inheritance model is simple and powerful, and it can emulate classical inheritance that second point is pretty cool, it's one of the key things that makes javascript so versatile, and has been able to evolve with the times (such as implementing class syntax as sugar, fabulous)
&gt; *I really don't see a "pain point" beyond the initial overhead of TS as well as understanding its purpose* exactly my experience — it can be a pain to learn and set up ultimately, fully understanding typescript and using it effectively can lead to an amazing codebase — especially when paired with the vscode editor **typescript's straight up best feature: interfaces** once you start thinking in terms of interfaces, it can open up the door to more lean functional-style code typescript is excellent for library authors, as your interfaces act as a source of documentation, they keep your code in check, and your downstream typescript users stay informed via code-hint features and compile-time errors
my favorite web application tech today: * **typescript** — create clean, rigid, self-consistent code * **preact** — react replacement, very lightweight * **mobx** — redux replacement, fancy decorator observables * **browserify** — bundle up code and npm modules into one js file * **jest** — nice testing framework by facebook * **uglify-es** — minification, code compression * **http-server** — instantly run a quick http server * **node-sass** — compile scss code more details in this example: [github chase-moskal glorius-frontend](https://github.com/chase-moskal/glorious-frontend) for backend apps, typescript and jest are still awesome
In what setting are you studying full stack web dev? Generally, you’re continually learning throughout your career, so it’s rare that a recent college graduate would know all of this. Pretty decent advice is to try to really understand the foundational stuff of programming and software engineering and learn the more specialized stuff as you need it. Even if you don’t know all the tech, writing robust, easy to maintain, well designed code goes a long way. 
One of my favorite Google Easter Eggs is searching for recursion. I like this blog and the continued interest in these concepts.
for frontend and backend projects, these cross-platform npm tools are available to be used in npm scripts to replace unix-specific commands: * **npm-run-all** — run multiple npm scripts in parallel (cross platform replacement for unix `&amp;`) * **mkdirp** — make directories (cross platform replacement for unix `mkdir`) * **rimraf** — delete files or directories (cross platform replacement for unix `rm -rf`) * **shx** — full suite of unix replacements (cross platform replacements for unix `ls`, `cp`, `rm`, etc) using these tools allows your project's build routine, and other routines, to run cross-platform, on mac, windows, or linux additionally, i must say — shx is looking pretty sweet since i last peeked, i'll probably start using it instead of the ol rimraf/mkdirp
We have forgotten what a roadmap is. I appreciate deviating from metaphors, but I think roadmaps should show rest stops, not endless detours.
although if you're super cool, you'll [dockerize your project](https://nodejs.org/en/docs/guides/nodejs-docker-webapp/) and your build so that you don't have to worry about cross-platform solutions, and can use bash commands at your whim
Realistically, it's pretty overblown. This should be seen as a flow-chart for when you're looking to solve a specific problem. Not a from-scratch study guide. I think it's disingenuous to try and be that, and it's setting a lot of people up for failure if they try to follow it as such, so many of the tools build off one another, and you wouldn't have a good functional knowledge of the base tools before you start trying to build that house of cards. How it usually goes is something like this: You need to make an app. Pick a frontend and backend framework, hack away, run into issue, fix it with one of the tools listed in that post, learn just enough to get it working, move on. Do that 5 or 6 times and you will have enough base knowledge of your toolset to not think about it very much. You'll know enough to structure your projects the right way _for you_ from the get go. I emphasize "for you", because everyone does things differently. Everyone has different preferences in tooling and how they like them set up. Anyone who claims to be deeply and intimately familiar with everything on that list has been using that exact stack for many years, or is lying to you. I'm a "full stack developer" and I've touched and used almost every tool listed there (besides alternatives), and while I know how to use them, I for sure would not consider myself an expert in many of them. Granted, this list is specific to front end, and if someone was a front-end dev, I would expect them to be better than me at every tool listed. It's a trade-off of time. The most important skill for a full stack developer is the ability to deliver. Do that by creating a project in react or whatever, add when you run into a problem or feel you have a functional grasp of your current toolset.
I appreciate you are trying to push this out there. Your website is attractive enough on mobile, but what feedback are you hoping to get?
From your #1 I recall the adage &gt; select is not broke
A bit harsh on the stack, I think, but I agree with you. The repo should have done a better job of clarifying optional paths.
You're right. As for the stuff listed, I think it's a good list. I just remember being on the other side years ago, staring at all the technology and just going 'what the hell' without realizing how little of it is _mandatory_ and that it's mostly _helpful_ when you get to the point you realize you need it. And that was when you could still get away with serving rendered html from your web server
react is more focused it's just an efficient rendering framework, and that's all you need it for and forget react, just use [preact](https://preactjs.com/), it's way leaner and meaner the fact that react does one job is really cool, because then you can choose your own state system — you could implement a redux monstrosity, or use something smooth like [mobx](https://github.com/mobxjs/mobx) in my opinion, typescript, preact, and mobx, can combine to make the best developer experience these days angular sticks you in a box, and it's an ugly box
And both of those are supported by typescript so...
Idealism affects us. Personally, I would be hard pressed to say "you've gotta learn *". It is hard. I let junior devs know they will have different opinions than me.
&gt;*Well Typescript is all the more reason to use React over Angular since in React all code can be Typechecked whereas Angular's templates cannot* \^ if this is true, that's a slayer point against angular react's jsx templates is fully supported in typescript (preact too) typescript and jsx in vscode is a great experience
There is potential confusion with `String.prototype.replace`. Arrays and Strings are sequential data. The string version replaces values found in the string while the proposed replace method replaces the entire thing. Putting them side by side: var newString = "abc".replace("a", "A"); var newArray = [1,2,3].replace(arrayProcessingFunction); When I read the title of this post I first thought the function would be an Array version of the current String method.
&gt;&gt; [..] its idiomatic usage encourages god functions &gt; This was stated without any arguments. You are replying to the wrong person!
Continuous learning is important whether it be algorithms, DOM, or other APIs. A lot of programmers do not come from classical CompSci backgrounds, but they do learn algorithms situationally. It is great to learn BigO, but it is persistance that will make or break you.
you actually can't use them together, that's always a mistake you should only ever use one, or the other — they are mutually incompatible yes, you *can* run code through both compilers — but you're probably being an idiot somebody see if you can point out an edge case where it's a good idea, good luck
The current framework no longer satisfies your needs and it’s not cost prohibitive to move.
Why do you need to know jQuery to learn React?
Web pack 4 is still broken
Hard to argue with that. How is the cost of the move determined?
This is why you should use Yarn. 
You're definitely right about currying, as that's the area I also have had the biggest problems with writing typings for. However I think with the latest couple of releases that has improved dramatically, but I have yet to test it.
uber cool. Could you elaborate the tech stack used through.
How is someone saying "Hey, I see some issues we can/will/have run into and came up with a solution" bad here?
Kat has made some cool stuff, but i have them blocked because of things like this. It isn't new that every problem is somehow both not their fault and because of gender. I'm surprised anyone takes them seriously anymore, Kat's not worth your time.
*woosh*
I would have not used the "bad" typings that came with the library and just created only what I needed myself, method by method. Not time wasted
You don't. But I think it was just grouped together with the basics of JS. It seems a lot of people would consider knowing at least a little bit of JQuery important. That's because you'll run into it in older (and some more recent) codebases. Me personally, I don't use it anymore. But I did learn to make stuff with it when I was starting out just to be more familiar. 
Many, many typings are "unofficial" and not made by the same person. That's part of the point.
Right? What a barrier to entry. I know very little of this (granted, I work in Angular right now but it's similar) and have been a developer working IT/corporate for a few years. You can find a software company that expects you to know all of this, but you can also find a company with a smaller team that doesn't even use unit testing. Don't get scared that every developer needs to know this much. It's all good to know, but it's not a requirement.
Hey how can one create that kind of flow diagram in general ?
Very well said.
That's an interesting point. There seems to be a fine line between demanding dynamic flexibility of types and flat-out lazy hacking.
Saying something is terrible without saying why is not respectful at all. 
I agree. I understand the use-case, but OP is missing the bigger picture. If we were to take this a step further, why do we just have `replace` on Array. It's useful on any type. Why would we implement it specifically for arrays? Really what we'd want is the `|&gt;` operator from Ocaml, which has been proposed many times. OP - try giving OCaml, Purescript, or ReasonML a go. JavaScript is slowly turning into a bastardised version of ML anyway, might as well skip the middleman. ReasonML in particular is a really nice blend of JavaScript-ish syntax with OCaml semantics. 
Yeah. The army is also a great example of this. You think setting up a tent with a couple radios, a couple computers, and a projector sounds fairly simple (and really it's not so bad). But, if you break out the training outline, its about 2 pages of checkboxes. Those checkboxes are roughly at the 'section' (read: 3-10 man groups) level. Therefore, each checkbox could be broken out into quite a few more checkboxes for intermediate tasks. Finally, those can be broken down to individual level tasks (fill radio, operate radio, turn off radio, etc), which frequently contain equipment level tasks (how to fill radio: move selector switch from off to load, press menu, ...) I bet if you delineated every task from every soldier in every section for the HQ element, you could come up with 75 pages of checkboxes, which would look like a stupidly daunting task, but most of which is either common sense or easily learned. 
The struggle is definitely real in some cases, but it is sad to see that the movement has been devalued due to a growing reputation of rudeness on the internet. It makes it more difficult for others to be heard and believed when they do raise serious concerns. Kat's great work and intelligence make me happy, but it's important for any adult to be respectful during discussion.
&gt;I would have not used the "bad" typings and just created only what I needed myself, method by method Sure, I would've created them too myself had the problem not been that TypeScript (at the time ~2.2-2.4) didn't have a way to correctly type curried functions. The typings I were using were "useable", except for when you actually tried to use them as curried functions, then things like type inferencing of params would get fucked or it would interpret the returned type of applying an arg to the curried function (the same function with -1 arity) completely wrong. &gt;Or used no typings just for using that library. And this is what I settled on doing, as I'm obviously not going to rip out a general purpose function library used in 90% of my files because typings weren't working. But, it defeated the purpose of what I was looking to achieve, have a fully type codebase. &gt;I can't see any reason to spend anywhere near 6 hours You've never felt so personally insulted by a problem you couldn't solve that you dedicate a large chunk of time to try to find out why it isn't working? That's fine. Even though I didn't solve my problem, I learned a ton about the typescript compiler while I was working through it, so it's not like I just was just slapping my hand on the keys hoping something would eventually work instead of doing something "productive". During that time I also found out that new typing features were on the TS roadmap that would eventually solve the issues in the typings I was trying to use. So, once I figured out that it literally was just never going to work, I uninstalled the types, decided I'd wait until those features were released, and moved on with my life.
Cool thanks
The RxJS version is such a joy to read! 
&gt; Are you writing functions where the parameters are undefined and it acts on whatever it gets? Even if they are, that's.. not exactly hard to do in TypeScript just the same. Hell, you can even make it typesafe if you're willing to write the boolean types for it.
He tells you at the bottom of the page
Sounds very unofficial to me.
Ok, here’s a terrible way to do it now. ``` array.reduce((acc, val, i, array) =&gt; i === 0 ? acc : [...new array stuff...]) ``` It would suck, because it would needlessly loop over all values. But it would give you the inline replacement you are looking for.
This is so March.......It's already July now!!
Been learning React for a few weeks. For someone that knows the basic web dev stuff, has a CS degree, and think he's a decent programmer in general, this shit can get confusing.
She explains what’s bad about it in the Twitter thread, albeit in a not super professional way. The proposal she was responding to goes well beyond “I see a potential issue” in that someone who apparently doesn’t work on maintaining the projects decided, without consulting anyone who is a maintainer, to write a “spec” telling the maintainers how to do their jobs. That’s not how specs and steering committees work. I agree she could have and should have been more diplomatic but I fully understand her frustration over this. If the person wanted to create a spec, he’d have been better off approaching the various stakeholders.
That's untrue. TS whine for every small stuff that works 100% fine and that has always worked fine in vanilla JS. Let's be realist. 
broken?
React developer... :(
uh.... huh. 
Hey, TypeScript PM here. Please feel free to file an issue on our issue tracker if you'd like to see this supported. I'd say it's technically a bug.
Because they're toxic children who apparently can't code for shit
* The cost of maintenance is greater than rewrite. * The old framework is discontinued, or so different as to effectively require a rewrite anyway. * Fundamental paradigm shift to the structure that provides more advantages than the cost of switching, or has a feature not feasible in the old framework.
You'll have to change your definition. Types are community. Almost no typings are written by the same author - underscore/jquery everything - see https://github.com/DefinitelyTyped/DefinitelyTyped
React only scales well in a team that knows how to do it. However in a different scenario, where the team is less experienced, it won't scale at all. In this case I'd go for angular any day... Angular has a more or less "right" way to scale apps and helps the devs, not screwing it up so much. I've experienced it myself, and it's quite painful to work with.
Thank you, we’ve been wondering the same thing. Obviously as our first React project there would be a learning curve and angular certainly feels like a safer option.
Tail call optimisation is not opening this link in a new tab.
We really do need to consider scalability. We’ve had no problems with developers using angular in the past, it’s been quite good using angular. I don’t want this to become a React vs angular debate. I’m looking for peoples experiences with using the library on large scale projects and the kinds of problems they’ve encountered as well as things that have gone well. 
How on Earth has the creator of this project insulted developers or "told them how to do their job"? The project was only created 3 days ago and doesn't have anything other than name and version specced yet. The project readme itself explains it is intended to create a cohesive, consistent pattern for extending the package.json format. It's not hostile, it's not telling people how to do their job. It's saying "here is an outlined formula for how we can all work together, follow it if you want". To address the concern of "how specs are created", this is exactly how they can happen. Design by committee is actually less frequent (and normally disliked for some of its faults). A few people, heck even one guy, coming together and saying this is how they are going to build things can cause a ripple effect for the greater good.
Wait, what language would want this? What language is functional but has no recursion? 
imo you just need to read the docs, install create react app and start hacking away. At our company we use a lot of CRA for products, maintaining build tools worksflow can be a major pain and we like to let CRA do that for us. Also we've been using graphql and apollo for every product and having touched a state management library is a long time, it's great. We throw CRA at the interns/juniors and they pick up all the other stuff naturally. Learn the basics, the other stuff will come when you need it, though it's good to know about the other stuff.
It's what happens when a critical part of the modern JavaScript toolchain is run by a bunch of embittered oddballs.
They're a bunch of toxic junior devs who think they are gods gift to the world despite NPM being a steaming pile of shit
Apologies for berating your 6 hours spent. I have indeed spent time like that trying to use the "best" option instead of the "backup" one. I just didn't want anyone to think you're inevitably going to be doing this when using TypeScript
I didn’t say it was an insult. I think it’s worthy of discussion and the way she responded was unhelpful. I’m simply saying that I see where she’s coming from and thinks she makes some valid points. These different projects made specific design decisions for what they deemed suited their project best and it seems unlikely that a single person not affiliated with any of the projects would know about or understand all those decisions at a level that would allow them to write a good spec. She was overly harsh in dismissing the idea. But I think a more productive approach would be creating an issue on say the NPM repo to raise the idea of writing a spec. Even if it ends up just being one person writing the spec, it would probably go better if you had some sort of working relationship with maintainers to discuss the spec with and understand why the projects made various decisions. That’s all I’m saying.
At least I haven't seen anyone complaining that yarn killed their prod server by removing system files when run with sudo. So it's got that going for it :P /s
Npm is a mess. So, so many problems. They have TWO PEOPLE working on the core product. Two.
For my company I think the answer is : Why not ? Sure npm has improved a lot and most "yarn killer feature" are now available with npm. But Yarn still works perfectly and we don't have a big enough incentive to migrate to a new product. And to be honest I prefer the yarn nomenclature even though it's really a detail.
I found that the only way it made sense was to just actually use it. Tutorials and docs were helpful, but it didn’t come together until using it in a big codebase. 
Are you sure you’re using NodeJs to run the code? NodeJs interprets JavaScript and bundles it with a bunch of I/O and networking tools. So Node doesn’t run inside of browsers because they have their own JavaScript engines that don’t give you access to those same libraries, instead you get all the browser libs (like accessing the DOM and stuff) If you are running it in NodeJs then make sure you have the latest version of NodeJs (something like 9.x.x) 
Use the all new flex tape!
As with all estimates, you make your best educated guess. The reality is there are volumes of books and methodologies dedicated to that single question.
Ah, I understand. I don't think we agree 100%, but I wanted to thank you for the polite discussion (sorry I was a tad abrasive) today. Cheers!
&gt; You should instead spend more time choosing good names. One of his points was to spend less time on naming things. I don’t know how much of a productivity boost that would actually be, but spending time on naming was something he was explicitly trying to avoid. 
Which is my whole point: to me making your code harder to understand for some questionable productivity gain makes no sense and just hurts you in the long run
Is one of them that kat girl thats blowing her reputation away on twitter?
I think piping a series of distinct little array operations is almost always more readable than saving the results of intermediate operations to variables. No matter how well named they are, they are an incidental distraction. 
You can do this with Lodash's thru method: https://lodash.com/docs/4.17.10#thru _(['B', 'D', 'F']).thru((arr) =&gt; ['A', arr[0], 'C', arr[1], 'E', arr[2], 'G']).value() Using that syntax you can chain filter and map before or afterwards. The case you described could probably be solved better by using uniqBy, but thru is a "fallback" if there isn't a more clearly named method (similar to reduce). 
OPs code to me no longer fits the definition of a "little array operation". Also please don't ad absurdum my statement. Never did I say you should extract *every* single array operation into its own variable. That's obviously just as wrong as inlining every variable and function.
Sounds very unofficial to me.
Few of this stuff is exclusive to a framework though, you use routers, rest, graphql, redux, etc. in Angular as well if you have to. It looks more like a very generic map of what's out there. React itself is maybe 0.0001% the learning effort you spent understanding Angular. Things like redux on the other hand can get hairy, fortunately there are many easier solutions now like mobx or plain context.
I just want to get the data from an API and show it in a table. I'm using axios to fetch the data which is not working because I have to require axios.
Are. You. Using. NodeJS. 
Agreed on both points. Indeed, what I am waiting for is `|&gt;`. But that proposal has been tossed around since 2015 and little traction. It is a major change that requires new syntax, i.e. it cannot be polyfilled. I am all _pro_ `|&gt;` making into ES. However, I don't see that happening any time soon. `Array#replace` has been something I have been kicking around as a lightweight alternative. ReasonML is nice. As an employer, the only reason I wouldn't use it now is simply because of rare/ high talent cost.
 // set the value: num(43) // get the current value: num() Seems like a risky pattern.
Wow, do people actually run npm with sudo on prod!?
&gt; Most TypeScript @types are community contributions. **Sounds very unofficial to me.** Moron.
Thanks, you're welcome.
In node, you could use --trace-ic and then afterwards search for IC types with the ICE explorer which is part of the V8 project. I am still looking for ways how to visualise megamorphic ICs in Chrome. Haven't had any success so far. Please let me know if you find out more.
Apparently they did because it doesn't or didn't set file permissions properly at the time
As author of that article, let me add that I used the bitwise operator just for performance reasons. My example should show the effect of Inline Caching and therefore I tried to remove or reduce any operation that might slow done the execution.
Why?
Yes
Typescript complains when you have code that could cause problems. I think you might be confusing code that has no problems with code that appears to have no problems so far
Now I am feeling better :D I was scared
Says the anonymous tosser who can't read.
Can you share the code? There’s no reason for require to not be defined. 
&gt; Typescript complains when you have code that could cause problems. The key word here is "could'. TypeScript compiler is a bot, with defined set of rules. There are times however, you know better JS then that bot, and there are times where errors, are truly not ones. That's it. And the issue with that, is that you have to spend a non-negligible amount of time to make TS compiler understand it's truly fine. And people do that a lot à la (* as any), among many other hacks and such. That's my point here. It's a waste of time when you already know the code is fine, and yet you still have to do something in other to dismiss the error. As I said again, TS puts typing BEFORE JS, which doesn't suit my needs by far. &gt; I think you might be confusing code that has no problems with code that appears to have no problems so far Potentially any code may cause issue in future, may it be a from a typed programming language or not. What you're saying doesn't really make sense, as it is, from you point of view, any "working" JS code is a code that passes TS compilation. And this is absolutely wrong. People have been build huge libs since years and years with vanilla JS. And many of them are truly stable. As a developer that's an achievement and that means the code IS working and IS behaving as expected. Just because TS whines doesn't mean in any way that the code is certainly wrong. It may be, but it also may not. And this makes the difference.
That's a good way to turn somebody new off of web development.
Tons of stuff stand out as bad advice here. If you want to learn react, here is a real roadmap: 1. Install create-react-app 2. Successfully edit App.js 3. Read the guide on reactjs.org 4. Buid something with just react as a dependancy. 5. Put the app into production. 6. Evaluate what in your application worked well, and what didnt. You’ll have learned a lot by just doing that, likely more than most devs. But now you should have a good direction of where to go. Supplementary material: kent c dodds, ryan florence, dan abramov, michael jackson. Search for them on youtube, twitter, etc
Hey. Okay I see but first, just that I understand. The test I set up is supposed to work from the ground up, right ? No need for any additional config than the one by default? Because I got it working with checkJS to true.
Started playing with Flutter and think it will bite into use of React Native. The development experience, IMO, is superior. The hot reload is incredibly fast and does not seem to slow down as the app gets bigger. It also has some unusual features. One is that it keeps state between testing sessions. So you write some code, test, and write some more code and the next test picks up from where it left off last time. Seems small but makes you much more productive. The other I really like is being able to click on any screen when testing and the editor goes to the code behind it. 
&gt; The key word here is "could'. TypeScript compiler is a bot, with defined set of rules. There are times however, you know better JS then that bot No, you really don't, there are times you know the code you wrote works because the N call sites currently have the correct inputs. That doesn't offer any future guarantees. &gt; That's my point here. It's a waste of time when you already know the code is fine, and yet you still have to do something in other to dismiss the error. As I said again, TS puts typing BEFORE JS, which doesn't suit my needs by far. You don't know that though unless you are creating proofs for all the code you write. Which is more exhaustive than strongly typing it. &gt; Potentially any code may cause issue in future, may it be a from a typed programming language or not. A strongly typed language isn't going to cause a runtime error because you called map on a number, in javascript you might. &gt; from you point of view, any "working" JS code is a code that passes TS compilation. And this is absolutely wrong. That's not what I said, thanks for putting words in my mouth. However if you actually want to be pedantic, then yes. if you can get code through the TS compiler it's probably going to 'work' (as in not crash) the same can't be said for code you write. &gt; People have been build huge libs since years and years with vanilla JS. And many of them are truly stable. People have been writing stable code in COBOL for longer than I've been alive, that's not an argument for COBOL. &gt; Just because TS whines doesn't mean in any way that the code is certainly wrong. It may be, but it also may not. And this makes the difference. No, it is wrong. The question becomes does it matter and in any large environment the answer is yes. If you write unit tests,integration tests, manually test your code or have a qa team then you should be able to see why type checking saves time. You get to find many bugs at compile time instead of at any of the later phases of development/testing.
`require` is a nodejs specific thing and is not natively supported in a web browser. You can use or insert a script loader of sorts in your web browser that does supply *a* `require` function (for example [requireJS](https://requirejs.org/), but there are other alternatives as well). Usually the whole front-end part of the application is concatenated and minified into one big file and that one big file is included in the HTML page you serve to the user with a `SCRIPT` tag.
Better read a book about it. Much better learning experience. There are Manning books about React which I highly recommend.
Built an electron app for reverse-finding images on your computer, based on an adjustable fuzzy comparison. Got tired of manually looking up where an image is after a client sends me a unnamed small version of it.
&gt; You don't know that though unless you are creating proofs for all the code you write. Which is more exhaustive than strongly typing it. What are you talking about? Of you course you know it. You know it because the code works fine as expected and because you designed it that way. If I make a (a,b) =&gt; a + b function and only calls that function with numbers in my code than the code WORKS as intended, and this is by design. If an idiot puts a string somewhere, that's its own fault for not reading the doc, that I presume is already live and well written. Just because it didn't go through TS compiler doesn't mean it is trash. What a nonsense. &gt; That's not what I said, thanks for putting words in my mouth What? But this is exactly what you said. "If you were getting errors then, no the code wouldn't work perfectly". Didn't you? You're assuming that if TS compiler throws and error then that automatically mean my code doesn't work perfectly. And I'm telling you this is WRONG and false. I design my code however I want and if it works based on my design and how I expect it to work, then it works perfectly FINE. And that's irrelevant how TS expect it to work. &gt; You get to find many bugs at compile time instead of at any of the later phases of development/testing. No sorry but I have not "found many bugs at compile times". Even prior to ES2015. Again, most of the bugs I've encountered comes from failing logic. Not because I didn't know the type of my variables, which actually never happen because I DO know them. From the comments, notes and from the doc I always keep up to date. I'll end with this: If TS is the source of truth and so much smarter than you then why are people still suggestion ways to ignore certain errors, like JAVA does with @SuppressWarnings?? Anyway it's useless to talk with you. Have fun with TS.
 // Initialize: num(42) // Later: num(myVar) // Still later: num() // Value is unexpectedly 42 because myVar happened to be undefined But more than that it just feels weird to have a function be both a getter and a setter like that.
For those who have an interest in blockchain technology: [https://lorenzoongithub.github.io/blockchaincalm/index.html](https://lorenzoongithub.github.io/blockchaincalm/index.html) Leaning on a great (still great) graph library: [https://github.com/anvaka/VivaGraphJS](https://github.com/anvaka/VivaGraphJS)
&gt; What are you talking about? Of you course you know it. You know it because the code works fine as expected and because you designed it that way. But if the TS compiler is giving you warnings then it's probably not working the way you expect. &gt; If I make a (a,b) =&gt; a + b function and only calls that function with numbers in my code than the code WORKS as intended, and this is by design. Sure, and it works as intended in TS too, but can you prove you are only calling it with numbers? &gt; If an idiot puts a string somewhere, that's its own fault for not reading the doc, that I presume is already live and well written. Just because it didn't go through TS compiler doesn't mean it is trash. What a nonsense. If an 'idiot' puts a string in it still works, strings are also monoids in javascript. &gt; No sorry but I have not "found many bugs at compile times". Even prior to ES2015. Again, most of the bugs I've encountered comes from failing logic. Not because Well you don't use typescript, of course you haven't found bugs at compile time. many 'failing logic' bugs are actually just bugs that a strong type system can catch. &gt; I didn't know the type of my variables, which actually never happen because I DO know them. From the comments, notes and from the doc I always keep up to date. But why? a type system does the same thing but needs less work to maintain since it tells you whenever anything is out of date. &gt; I'll end with this: If TS is the source of truth and so much smarter than you then why are people still suggestion ways to ignore certain errors, like JAVA does with @SuppressWarnings?? @SuppressWarnings works around issues with generics, which isn't the same. You can write generics correctly in TS. why are you writing java code? i though you hate type systems. &gt; Anyway it's useless to talk with you. Have fun with TS. Yeah, it usually feels useless when you are unwilling to listen to other opinions. Your arguments just read like typescript frustrates you and you rationalize doing more work to get a similar but less complete result.
are you really suggesting we use NPM?! Right, okay... nah I’m good thanks. 
Use let and const instead of var. Use camelCase for everything except classes/constructors. Use the single responsibility principle.
You're advice is totally orthogonal. The article lists technologies and skills, doesn't say how you should go about learning them.
I think TS is not worth spending any time on for most projects. Personally, I think that code should be self explanatory. If you have a component that takes a `user` property, then I'd expect that to be an object. If it's `users` then it's an array. If it's `userId` then it's whatever identifier we use in the system (integer, guid, etc.). If it's `userName` then it's probably not going to be their date of birth. Naming variables and methods goes a long way. - `getUser()` gets you a user object - `getUserDateOfBirth()` gets you a DOB on whatever date format you agreed upon - etc. Whenever I see TS being used it's 90% being used to describe the very obvious. The kind of obvious that would instantly break the entire software if you misuse it. - `getUser(user)` would break if it expects the parameter to be an integer instead of an object. - `saveNewUser(objUser)` would break if the user object is incomplete, since our database, or backend, or our middleware should be validating the input. So for developer comfort I think and I've experienced that TS is a step back. It's a lot of trivial work for very little intuitive benefit. I've seen CODE taking huge steps backwards in terms of quality just because TS interfaces take care of everything. Suddenly you get shit like: `user` being an ID sometimes, sometimes a username, sometimes an object. Because wherever it's being used TS enforces its type. So would you then need to enforce naming conventions for variables, methods, objects, and properties ON TOP of forcing the use of TS? That seems a bit superfluous. --- That said, I do love TS. If it's configured to be COMPLETELY optional then it's absolutely great. It can be added WHERE YOU NEED IT, not everywhere you don't want it. Projects that force strong typed JS all over the place are terrible to work with. Such a pain in the ass.
I created a podcast: [JS Party](https://changelog.com/jsparty)! 🎉 We record live every Thursday and have so much fun hanging out and discussing all the cool stuff you can do with JavaScript and the web. Some recommended episodes if you’d like to give it a listen: - [Node’s survey, Ry’s regrets, Microsoft’s GitHub](https://changelog.com/jsparty/29) - [Cool, depending on your definition of cool](https://changelog.com/jsparty/24) - [Oh, the places JS will go](https://changelog.com/jsparty/21) 
Have you developed something more complicated?
Where is the tutorial?
The javascript files that your express app sends to the webpage don't run in node, they run in the browser, so you can't use require.
Seriously, fuck Kat. https://twitter.com/_baxuz/status/1014418994017767424?s=09 And fuck anyone who is silently approving of this sort of behaviour. Any sane company would've sacked her years ago. Kudos to ArenaNet for sacking Jessica: https://www.oneangrygamer.net/2018/07/guild-wars-2-devs-fired-by-arenanet-for-antagonizing-gamers/63124/
WebUSB API. Going to try this out 
Lambda calculus More of a theoretical concept than a real programming language. 
My read of OP’s article and examples was that it was certainly about a series distinct operations which would be appropriate for chaining. The proposal of `replace` doesn’t make much sense otherwise. 
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
Oh OK. So like, Haskell has recursion, Python has recursion, all modern (especially functional) languages have recursion, and only lambda calculus has none? I know the 101s of lambda calculus, on paper it's practically the same as lambdas in python or arrow functons in js. But, like, for real, is there no contemporary programming language where you couldn't recur a function without the Y combinator? Because if you're getting at the fact that the Y combinator was "invented" (for lack of a better term) in the context of lambda calculus, I already knew that before your remark. Your answer only half answers my actual question. 
Added. Thank you, license-bot.
&gt; How much of this would you actually have to learn? To start build useful web front-ends using React, here’s a reasonable starting set of things to know: * Basic development skills * HTML * CSS * JS and a few everyday browser APIs * HTTP * React The number of solutions looking for problems in the JS ecosystem is insane. My advice is not to engage with the hype at all. Obviously when you find situations where more tools would help, learn and use more tools, but use something because you have a need for it, not because someone’s tweet told you it was this week’s shiny. &gt; I'm studying full stack webdev right now and it seems impossible to reach a level of competence if you need to keep up with the ever expanding toolsets. How do you guys do it? I don’t. I keep a general eye on potentially interesting developments in the industry, but that’s about it. In general, I recommend concentrating on solid foundations and prioritising understanding the underlying technologies. As your experience grows, you will realise that most of the apparent rapid evolution in web development is an illusion. Certainly the basics do evolve, but slowly. Certainly genuinely new and better things do come along, but rarely. The important thing is that if you have a decent understanding of those basics, you can always pick up whatever else you need when the time comes. In contrast, if you have no idea how to design larger-than-tiny software or write good code, you’ll struggle to build and maintain substantial web apps no matter how many JS libraries you use ~~NPM~~ ~~Yarn~~ this week’s package manager to install. If you rely on tools like `create-react-app` but don’t understand what they’re doing and why, you might find yourself with hundreds of lines of boilerplate config files and someone else’s idea of where to put your files and directories, when maybe you could have just set up everything you needed exactly how you want it in a handful of lines and five minutes anyway. My final piece of advice (though certainly I’m not the first to say it) is never be an “X developer”. The emphasis is all wrong, in everything from mindset to career development. Be someone who develops solutions to problems, who happens to know how to use X or Y to get the job done, and who can quickly learn Z as well if that's a better tool for the current job.
I guess we'll have to agree to disagree on this
why the FUCK websites NEED to scroll-jack? this one forces scrolling to be "smooth". WHY? WHO IS IT FOR? i get motion-sickness from this usless shit.
Thank you! Will do :)
Finally a viable way to write your business logic client side.
Why is it that when you actually nail down what the disagreement is, so people can no longer argue against points you didn’t make, that’s when that want to agree to disagree?
Hate to be that guy. You have a spelling mistake in your message field in the contact form. Looks great
Interesting, my feeling was that you were the first to try and argue against a point I never made. Anyways: since neither of us seems to be willing to change their point of view and I see no middle ground, I suggested to stop the pointless discussion there. Not sure why you'd paint that as wrong or a personal offence against you?
Please be the guy! This is why I published it here (;
My jaw just dropped... What in the heck is that?
The code is using the various ways Javascript auto-converts variables--in this case, only an array--for comparison to generate numbers/letters/booleans to perform logic on.
Oh yeah, and if someone asks how you got your code to work like that, you say "I was taught to write it this way" I expect a mix between disgust and deep sympathy
In your _blog_ ( https://www.inspiredwebdev.com/courses/the-complete-guide-to-modern-javascript/ ), it seems like you have some assets (CSS and JS) linked through HTTP (no HTTPS). These are blocked when loading the page through HTTPS. You may want to have a look at it.
Great idea! Made a fork for Vue at github.com/flaviocopes/vue-developer-roadmap
How does it start writing letters though? Is there a transpiler to transpile your code into this form?
Here's essentially what it looks like: [https://github.com/aemkei/jsfuck/blob/master/jsfuck.js](https://github.com/aemkei/jsfuck/blob/master/jsfuck.js)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [aemkei/jsfuck/.../**jsfuck.js** (master → 6b7e2e9)](https://github.com/aemkei/jsfuck/blob/6b7e2e9ef44941e028ddf16a793a6c8902da2ae3/jsfuck.js) ---- 
http://www.jsfuck.com/
This is why trying to filter out specific strings the prevent XSS doesnt work
I made the mistake of commenting the same observation when this was posted in r/reactjs. Got clobbered for it.
Serverside node
I'm assuming it's just adding ascii hex numbers, which is very common when working with embedded systems (but you wouldn't ever run into it in javascript) Every character is just a binary number in reality.
 [][[]]+[] == "undefined" +(![]+[])+[] == "NaN" I'm not going to find them all, but eventually you can spell out what you want and start calling functions. Consider this bit of valid javascript: "undefined"["substr"](2, 3) == "def" Now just construct all parts of that code with a long sequence of [, ], (, ), +, and !. I don't know if there is a compiler, but it shouldn't be too hard to make one.
I've had some fun in the past writing JS in subsets of the language too. In the following examples, the objective was to move lines on a canvas: Here's one with [no numbers, only letters](https://www.dwitter.net/d/7147). ``` for(g=delete no_numbers_only_letters,a=g+g+g,c.width|=o=a*a;o--;x.fillRect(k+o*d+S(t)*a*d,k,q+q,d*b))b=g+g,p=a+b,q=p*p,d=q&lt;&lt;b,k=d&lt;&lt;b ``` Here's one with [a RTL char](https://www.dwitter.net/d/6892). ``` c.width|="‮";for(i=9;i--;)x.fillRect(400+i*100+S(t)*300,400,50,200) ``` Here's one with [variables that aren't letters](https://www.dwitter.net/d/6827). ``` ǀ=[],ᛁ=-~ǀ,ⅼ=+ǀ,ⵏ=ᛁ+ᛁ+ᛁ;for(c.width|=ꓲ=+[``+-~ǀ+ +ǀ]+~ǀ,ߺ=[!+ǀ+ⵏ]+ⅼ+ⅼ,_=-~ǀ+``+~~ǀ+~~ǀ;ꓲ--;)x.fillRect(+ߺ+ꓲ*_+ⵏ*(S(t)*_),ߺ,ߺ&gt;&gt;ⵏ,ߺ/[ᛁ+ᛁ]) ``` Once you start exploiting JS's weak typing, you can write some pretty ~~cool~~ horrible code! Bonus, wavy code: c . width ^=0 ;for ( i= 9; i-- ; )x . fillRect ( 400+ i * 100+ S(t)* 300 , 400 ,50, 200) 
Yeah, i noticed that. I think I've found a better plugin to write markdown in WordPress, I'm gonna try and see if that will fix it. Sorry for the issue
Lol, just saw that. Wonder if when you are react developer you can not be good angular developer. Also what about all of those jQuery developer ?! 🤣😭 
I created a web application: **Pair &amp; Compare** to help developers and designers (including myself) find the best fonts and font pairings for their next project easily and smoothly. Pair &amp; Compare is like a font playground that removes the hassle and struggle from font selection process. **URL**: [https://www.pairandcompare.net/](https://www.pairandcompare.net/) Watch the 3-minutes video: [https://youtu.be/fsaMakGNgTE](https://youtu.be/fsaMakGNgTE) **Technologies Used**: JavaScript, Vue.js, Google Fonts, HTML, CSS, JS, JQuery, Select2, Spectrum, Web Font Loader, etc.
Like you said - it’s a toolset, so just use it. If it’s not solving your problems maybe it’s a wrong tool for a job
Someone should make this into a cool obfuscation library.
I didn't look through the whole book, but I edited the comment above to include a couple of issues more.
Why is `index.mjs` not named `index.js`?
Yes; she's extremely toxic.
This makes it so easy to reason about. 
Because it's required to use ES modules in Node.
During the write permission debacle, I remember them saying that they have only 2-3 active maintainers on npm. 
now what do we have here...the r/javascript male virgin force back at it again....pathetic...get a life losers
seriously, fuck you. you pathetic male virgin typical r/javascript male virgin behavior, grow up
got you covered: http://www.jsfuck.com/
I'm fairly sure, but not 100%. Is this joke about security through obscurity? 
I have Stephen Grider's videos on Udemy. So far I hate everything on Udemy, they just have you copy code --- but Grider does it a lot less. He actually explains concepts ahead of time. I've read the React docs but the main concepts of props and state didn't make sense until I watched the Grider videos. So for now I'll just keep pushing through that and find a book afterwards, unless others can definitively say Grider sucks.
Thanks for the additional feedback. Since this is my first time writing a book, I'm always looking at ways to improve it :) 
[How about js in emoji?](http://utf-8.jp/public/aaencode.html)
its the typical reddit r/javascript butthurt male virgin force, aka bunch of pathetic losers
`client side` means running in the user's web browser, `server side` means it's running in your backend server (e.g. a node server) `require` only works in node (the server side) If you want to use `require` for client side code, you'll need a bundler that mimics the way node's `require` works and combines all your modules into a single bundle. Examples of bundlers are webpack, rollup, parcel, etc. Since you seem really new to all of this, parcel would likely be the easiest to pick up
Just a note: not OP, I looked into the source on github.
npm maintainers don't deserve a userbase in all honesty
I created a React Single Page Application for Trello: React-Trello-Multiboard. Display selected Lists and their Cards of multiple Trello Boards. Combine them all on one screen and plan ahead. You can also filter preferred Members and only see the upcoming tasks (Cards) for them. You can find the source code on Github: https://github.com/natterstefan/react-trello-multiboard. An example is available here: https://multiboardfortrello.com. Let me know what you think 😀
PLEASE. JUST. GO. FUCKING. KILL. YOURSELF. YOU. PATHETIC. male. VIRGIN.
So less jQuery, more Java. Mkay… I find myself drifting away from frontend coding more and more. I used to like it, because you were getting results quicker. Nowadays it's even more opaque than the server side IMHO. Guess I should take a look at Haxe finally. Just my 2 cents. Yeah, I'm old.
Yes
Once the [pipeline operator `|&gt;`](https://github.com/tc39/proposal-pipeline-operator) is part of the language, you'll [only need 5 characters](https://speakerdeck.com/masatokinugawa/shibuya-dot-xss-techtalk-number-10) …
Maybe this can suit your fancy: https://medium.freecodecamp.org/a-real-world-comparison-of-front-end-frameworks-with-benchmarks-2018-update-e5760fb4a962
obfuscation lol
Finally, someone with some sanity! This code is much more efficient, and I would even argue it's easier to reason about. I feel like the people on this subreddit have purely academic backgrounds or something. The code above is something I'd write in a few minutes and move on, not stare at for ages thinking "if *only* there were some native array method or pipeline operator that would avoid me having to name a variable". I know someone might try to throw a "testability" argument at me, but there's a diminishing return on function abstraction in a production environment, especially when it's as blatantly inefficient as OP's example. Also, a quick tip. All of the variables in the snippet could be declared as **const**. Adding properties/elements to objects/arrays are mutations, not reassignments. The **for...of** can also use it, too.
The fact that I can use `yarn &lt;script&gt;` instead of `yarn run &lt;script&gt;`, and can pass more args to it directly without the separating `--` are a couple reasons why I've preferred yarn. They seem like minor features, but when you're running package scripts all day, the extra typing is really noticeable
Jsfuck.com is the official converter that lets you encode any plain code to those 6 chars [this talk by Martin kelppe lays out his discovery](https://youtu.be/RTxtiLp1C8Y) 
toxic junior devs = all men = male VIRGINS = steaming pile of VIRGIN shit
But can it be written well even with all of the characters?
If I hear the word GraphQL one more freaking time, I’m going to loose my shit. 
# [ence](https://github.com/g-harel/ence) &gt; automation-friendly json schemas * Deterministic result ideal for diffs and snapshot testing. * Full address output convenient for grep analysis. * Missing/inconsistent object key detection. * Compatible with any tool outputting to stdin.
No transpiler needed. You can use those weird array operations to get strings like "true", "false" and "undefined", then you can access each letter (ex "true"[0] is "t") Once you get all the letters, you can access everything in the window object.
Good bot
Just like the \[Tokyo Flash watch\]([https://www.wired.com/images\_blogs/gadgetlab/2010/09/time22.jpeg](https://www.wired.com/images_blogs/gadgetlab/2010/09/time22.jpeg))!
Just read the source, look under mappings https://github.com/aemkei/jsfuck/blob/master/jsfuck.js 
Noap, https://github.com/aemkei/jsfuck/blob/master/jsfuck.js read the source.
You're one of today's lucky 10,000!
Misery loves self-reinforcement.
Sounds like you're in the wrong sub then.
I've been building a Vue.js 2 component library for the past few months. It's styled primarily based on the Atlassian Design Guidelines. I finally pushed an initial public commit yesterday. Github: [https://github.com/nvms/vue-atlas](https://github.com/nvms/vue-atlas) Documentation: [https://vue-atlas.com/documentation](https://vue-atlas.com/documentation)
Doesn't GraphQL break the paradigm of loose coupling? Should a frontend developer even have intimate knowlege of the data schema? If you are going to have roles on a team building an app, shouldn't the API be a magical realm I'm don't know about?
Oh fuck off with this political drama already
[https://codepen.io/gunderson/full/GJJPpV/](https://codepen.io/gunderson/full/GJJPpV/)
One of reaktor.com's "treasure hunts" or whatever they call them used this as a challenge. It was pretty cool, unfortunately the site svalbard.reaktor.com seems to be down now.
Great, I just can't wait to use it with other 500 microlibs to achieve functionality of complete libraries.
Oh, that's what those questions were ._.