encrypted ??? you mean minified / obfuscated?
There is a lot of people learning JS, but not enough solid expirience devs.
Guy uses, commas, worse than, your average, reddit user
Yes correct!
Reading books is definitely the best way to learn in my opinion. You get all the context and little details, and it's that kind of knowledge that separates the better programmers. That being said, sometimes people need something more experiential to learn, and that's where these coding websites and boilerplates come in.
From a London perspective, salaries are great. Entry level salaries are lower than what you would get with other languages but once you’re proven it increases dramatically. If you have a computer science degree, solid work experience (1-2 years), and some personal projects then you’ll be laughing. With a year’s experience you could easily earn £40,000, which is more than most languages would pay at that stage, plus there are way more JS jobs out there. 2 year’s experience and you’re on £50-60,000, after that it’ll keep rising until you’re on or very near six figures (and higher if you work in the right industries). As for other programmers thinking JS is a toy language, anyone who says that about the language nowadays is just exposing themselves as an idiot. Sometimes I think it’s hard for people to shake old habits. We had an old C# developer come in and he was very sure of himself, he was a good problem solver but stuck in his old ways. Since he was so sure of himself he never bothered to learn, as a result working on his projects was a nightmare. The code was this functional/OO incestuous lovechild that made us want to cry. He was a brilliant bullshitter though and since the managers couldn’t see his app was held together by a shoestring nobody cared. I got put on the project and I was constantly fixing bugs with hardly any time for features. I use WebStorm because it has everything I need built in. No need to go and download a ton of plugins, not that I can’t if I don’t want to. Always keep a lightweight editor on hand like VSCode but that’s it. React Native is without a doubt better than Cordova, Xamarin, etc. Unlike Cordova and co which are just websites wrapped in a native web view RN is totally native, it takes advantage of Swift/Android’s ability to execute JS so you’re running a totally native app. For things where being inside the JS runtime is unhelpful, you can talk to the native layer. This is useful for things like animations, where with Cordova you’re stuck at 30fps but with native code you can reach that golden 60fps.
Why not?
http://jsbeautifier.org you might need a bit more than $100 for this..
Perhaps it's not idiomatic in quite the same way, but I've never liked the functional style used for auto currying. In js you can idiomatically curry with arrow functions and personally I think it is a better notation. It's also more flexible, because you aren't forced to order arguments in a particular way. In js notation, it's easy to bind the first and 3rd argument, for example. Write your functional normally, and let clients curry as they like.
Yes, but "literally" literally means literally.
Yes, but prescriptivist linguistics, as a school of thought, largely died out among the people that actually study this professionally years ago. Languages change with their usage. It's how words are invented, change, and disappear. If we're going to insist on using the original, correct meanings of words rather than those in common usage today, broccoli is a kind of meat, awful and awesome are synonyms, nice means silly and silly means holy, flirting means flicking someone, and an egregious bachelor is a particularly distinguished Knight. 
Vue is mostly a UI framework, functionally similar to React. Angular includes/requires things like an HTTP client and RxJS. It can be seen as a self-contained ecosystem.
They do different things. Vue is better compared to angulars directives than with the whole of angular.
Thank you!! 
`this.targetElement` sets a `targetElement` property on an object referenced by `this`. Properties in JS does not have to be declared by `var`. `this` is a special keyword in JS, it points to a "context" of function invocation. How `this` works in JS can be fairly complex for people that are new but there are many tutorials that should explain you what that is. 
what new things should I learn? data structures/algothrims? 
1) Just be the better than the competition, you'll be paid accordingly. 2) I don't think it's anything to do with OO vs FP. No one considers Scala or Haskell toy languages. Javascript isn't really a true functional language. It isn't really a true OO language either. Don't worry about what other people think. 3) I use sublime, eslint, and ESlint Autoformatter; it works for me. I've used different setups before, and I'll probably change at some point. Tools aren't as important as people think. 4) I prefer it.
Angular? Or angularjs? 
I just want to say its beautifully layed out and has a great colour scheme good job!
I didn't say it is, but never say never. Most apps i run today are js driven (Atom, VS-Code, Spottify, Skype, Hyper, Discord ... for instance). And on the server it may not be the majority, but node is big, and it's been getting there with competing languages all around it. It tells you something, javascript is an incredible language today. If i had the choice today between any language for an app, it most certainly would be javascript. 
?
Vue has vue-router
If it is minified: jsbeautifier.org Then if it is also obfuscated: jsnice.org ( js nicify techniques probably won't work 100% of the time, though ). Well how about posting that file publicly here, and anyone who solves your problem first will get the money ? 
That's just a formal way to define the model. The key to getting there is the previous figure (figure 4). Basically, what it says is: First we define a bunch of things that represent the state of a program. Not the full state, but just the part about promises, of course. So we have these things: - A _heap_. Don't care too much about this. It's just a space in which to put values, calculated values. - Promises. A promise is just a thing that can have one of three states. We define the set of all of them. - Promises can have associated "reactions", or callbacks we add either as success handlers or failure handlers. Again, we define the sets of those, we define FulfilReactions and RejectReactions. - Handlers or callbacks or _reactions_... well, they've decided to call them _reactions_. And so we define the set of all _reactions_ irregardless of what type they are (Fulfil or Reject). - We'll also need a _queue_ of calls waiting to be made. That is, at any point in the execution of the program we acknowledge that there may be some calls to reactions that are waiting to be executed. Such a call involves a reaction and a promise value. - Finally, we just define the three states in which a promise may find itself. P for Pending, F(v) for Fulfilled with value v, and R(v) for Rejected with value v. All this is pretty standard. It's just a formalization of the entities we find involved in evaluating the "promise state" of a program. That is, with these five things we can determine uniquely that state: `S(Heap, Promises, FulfilReactions, RejectReactions, Queue)`. In other words, if at a certain point in the execution of a program we know: - Which Promises exist. Which values exist. - Which FulfilReactions exist. Which RejectReactions exist. - Which calls are in the Queue waiting to be executed. Then, we have all the knowledge we need about the "promise state" of that program. Now, we get to the part you pointed out. What is all that about? Well, given that we know how to define the "promise state" of execution of a program, if we want to be able to use that model for anything, we need to determine what are the _rules for going from one state to another state_. This is exactly want the figure you showed does. I won't go over all those rules because it's really boring, but let's see a couple of them to understand what they mean in general. Let's take the `[E-PROMISIFY]` rule. The name should give you a hint. What the rule says is that if we are in a certain given state `S(Heap, Promises, FulfilReactions, RejectReactions, Queue)` and we find an expression that _builds a promise_ i.e. `promisify(a)` (which mostly corresponds in real code to doing `new Promise(...)`), then we will arrive at a new state where: A new promise is added to `Promises` with state P (pending). Storage is prepared for that promise to have both FulfilReactions and RejectReactions but for now they are left pointing to empty lists. The Heap and the Queue are left untouched because this transition doesn't affect them. So, then the new state should be: `S(Heap, NewPromises, NewFulfilReactions, NewRejectReactions, Queue)`, where: // pseudo code: Let NewPromise be new Promise(a) // a new promise is created over the expression a with state Pending, so... NewPromises = Promises.concat(NewPromise); // The new set of promises is the set we had before plus the new one NewFulfilReactions = {...FulfilReactions, NewPromise: [] }; // The new set of FulfilReactions is the set we had before plus a new empty list for the new promise NewRejectReactions = {...RejectReactions, NewPromise: [] }; // The new set of RejectReactions is the set we had before plus a new empty list for the new promise If you think about it, it is just a formal way to say that _the creation of a promises, creates a new promise with state Pending, and reserves some place to potentially store reactions_. Now, that second part about "storing reactions" don't take it literally; it is a _mental model_ so it does not mean that there's an actual underlying storage or anything, just that we have now knowledge that the new promise can have associated reactions but it does not yet have them. Ok, another easy rule... Actually, let's see two at a time: `[ON-RESOLVE-PENDING]` and `[ON-RESOLVE-FULFILLED]`. These two rules are _similar_ but have one difference and so can be a good example to explain. Lets see the first one first. What the rule says is... given a certain state `S(Heap, Promises, FulfilReactions, RejectReactions, Queue)` and given a particular existing promise A that is in Pending state, when we find an expression that adds a fulfil reaction FR to A, then the new state is composed by: A new promise B is created with pending state // this is because existingPromise.then(...) returns a *new* promise as defined in the ES spec Again empty reaction lists are added to RejectReactions and FulfilReactions for that new promise B. // the same as in the previous rule And again the new promise B is added to the set of existing promises. // the same as in the previous rule For the promise A, the reaction FR is added to its list of FulfilReactions (of course), and maybe not that obviously, the return of FR is linked to either fulfilling or rejecting the newly created promise B The Queue remains untouched Now, `[ON-RESOLVE-FULFILLED]` is a similar rule. We start from almost the same state, but this time the promise A is in Fulfilled state and we encounter the same expression of adding the reaction FR to A. We do go through most of the same changes, with the difference that now, instead of adding FR to A's FulfilReactions and linking the return of FR to resolving or rejecting the new promise, we directly add the execution of FR, passing the value F(A) -that is, whatever value A resolved to- to the Queue for execution. Some words about the notation. There's a big horizontal line. Above the line you have the _restrictions_ or definitions of the rule. Bwlow the line, you have the result of the rule. So, for example, in this last one we've seen `[ON-RESOLVE-FULFILLED]`: - Above the line, you have the restrictions or propositions for the rule. They say things like: `a ∈ Addr`, which you can read as "a is a value", or `a ∈ dom(σ)`, which you can read as "a exists in the Heap" or "a is allocated" (in contrast to `a' ∉ dom(σ)` which means a' is not allocated yet, we're creating it new), or `ψ' = ψ[a' -&gt; F(v)]` which you can read as "the new ψ (set of promises) is the same set we had before plus a new promise with state `F(v)` (solved with value v)". - Below the line is the rule itself. You can read it as something like "Given a certain state where we find an expression like `a.onResolve(λ)`, then the new state will be one where you substitute that expression for a` and σ for σ', ψ for ψ', etc following the definitions given above the line". ---- I acknowledge that explaining all this in such detail gets very long and tiring quickly, sorry. I'll leave it at this point. But actually, that's the whole point of the thing: Using a formal language (which is generic and common) we can define all the ideas formally and avoid having to explain each expression. Even so, the paper actually does explain most of it. The pages that follow Figure 5, pages 9-12, do explain what each rule means. If you translate the formal language to a more common language, what you'll get is, mostly, things like "When you create a promise, a promise is created with Pending state" or "When you find an expression such as `aPromise.then(f)`, and `a` is in Pending state then `f` is added as _success handler_, a new promise is created and it is made dependent on the result of `f(resultOf(a))`". That is, you'll arrive at the specification of Promises, or how Promises work in ES, because that is just the goal, to describe that in a formal way.
If you are interested you can send me a PM.
Sure is. Code Review on stack exchange. https://codereview.stackexchange.com/ I posted there before and got pretty thoughtful answers. People have also posted on this sub and asked for feedback. 
PM'ed you.
You can try the code review [Stack Exchange](https://codereview.stackexchange.com/), but I am not sure if it will be suitable for your needs (don't know what happens if you post too often). 
Are you trying to use code for which you do not have a license?
1. Never mind JavaScript, no field or technology right now has an excess of *good*, experienced developers. You will always be competitive as long as you're on top of the latest tech and actually know what you're doing. 2. People like being in their comfort zone and will lash out at anything that threatens it. I'd be lying if I said the fact that the Internet still has this sort of infantile attitude towards JS didn't annoy me, 3. I don't think this is a very useful answer to anyone, but right now I find myself using either Atom or PhpStorm, plus whatever build tools are standard for the tech I'm working with. But I think there's a whole lot of room for improvement in my dev workflow. 4. I can't speak for Xamarin, but it's immeasurably better than PhoneGap and other tools that do "cross-platform" by just sticking your app in a WebView.
mh.. &gt; 100k as front-end engineer and the market is desperately looking for more, but I live in Zürich so adjust for crazy expensive life ¯\\\_(ツ)\_/¯
As far as I understand it, it works relatively well if you have designers crafting up HTML+CSS, as Vue's template support makes that easy to integrate. Otherwise I'd guess that it's mostly detrimental and I'd stick with React.
my top advice is for-in and for-each are slow, use a regular for loop wherever possible look up singal var pattern and at least get close, definitely don't define variables inside of loops and don't use multiple returns in a function (unless you're defining a separate function), you can always replace them with if/else logic and make your intent way more readable there are a ton more, but those'll make a dent, I highly recommend the book "Javascript patterns" to learn more 
Thanks!
I’d like to point out that RN is not *totally native*. Your logic still runs on JS and even UI animations were handled by JS last time I used it (although that was over a year ago).
I published a dependency free focus point based image cropping utility that is ~2.6kB gzipped. I plan to write Angular, React, and Vue wrappers for it in the future! :D [Here's the demo](https://image-focus.stackblitz.com) https://www.npmjs.com/package/image-focus
I don’t wish for anything – I’m merely pointing out that two useful features are at odds: currying and parameter default values. Your first sentence is a good summary of my point. Thanks for the digging! I had seen that ReasonML (which is based on OCaml) supports parameter default values, alas clumsily (IIRC).
Sure, but if html/css is slowing down your learning, then take it out of the equation and just work on javascript. 
I published a dependency free focus point based image cropping utility that is ~2.6kB gzipped. I plan to write Angular, React, and Vue wrappers for it in the future! :D It's adapted from [jquery-focuspoint](https://github.com/jonom/jquery-focuspoint) [Here's the demo](https://image-focus.stackblitz.com) https://github.com/third774/image-focus
I’m a technical lead hiring senior Node.js backend devs and paying over 100k here in Raleigh, NC for a privately held company. (seriously PM me, relocation is possible). I don’t really see salaries as a problem but I think it’s more of a positioning problem. I don’t tell people I’m a JavaScript developer, but a technical leader who can use a variety of languages based on technical requirements. This gets you an entirely different class of JavaScript jobs. 
Front end JS projects are exploding since the web is becoming more and more sophisticated. I think once Web Assembly is commonplace and has access to the DOM a lot of people will leave JS for other languages. I’ve been writing JS since the late 90s and while the TC39 is doing a great job lately until it gets some form of static typing I will always feel like writing JS is like walking on ice. On the server I’d say Node exploded a couple of years ago but it has reached a plateau. IMO other than SSR and front end workflows I don’t think Node is a great choice. Even Ryan Dahl has abandoned the ship.
I'd consider Vue and React to be libraries that you can use to build your own framework. There is a lot of choice around routers, type systems (optional), state stores, etc. Angular (2+) starts as a framework and while parts of it are pluggable, it's far more opinionated.
I fully agree with the first part – it’s a good summary. With “non-idiomatic” I mean “isn’t a good fit within the current JavaScript ecosystem”: * If you omit a parameter, you can normally rely on the function still being executed. * You don’t make function calls like `f(1)(2)(3)`. * Many functions and methods don’t have signatures that work well with currying. * You can’t meaningfully do parameter default values. I use them often to keep APIs flexible. They are especially useful with named parameters. With the proposal for partial evaluation I mention, you actually can have the best of both worlds: you get both partial evaluation (which, IMO, is the point of currying) and parameter default values. If you argue that “idiomatic” means “expect the unexpected” then currying is idiomatic (I mean this non-sarcastically!). 
Imagine this: your "friend" sends you a link. You click on it because Hey, it's your friend after all. The Javascript on the site then starts to read some files from your computer. Maybe a poem you wrote, maybe some legal documents that you have stored. After that, it starts writing random bytes to your harddrive until it's full. Do you like that scenario? Probably not, and that is why every browser runs code in a sandbox. That means, that there is no way for website Javascript to leave this sandbox and access your computer. However, of you just want to store some strings for a user, you can look at localstorage: this is a browser api, that allows you to store a couple of MBs in the user's browser that will be accessible next time they visit. 
1) No. The opposite is true in the competitive urban tech hub in which I work. Salaries are very good and it's challenging to find a skilled, experienced developer. 2) Why would I hate other developers bringing their experiences to a team? Diversity of thought is an asset. The developers with whom I've worked that came from a traditional OO background have often been big proponents of testing and improving our tooling and have been an asset to our teams. 3) React, Webpack, NodeJS micro services, GraphQL in an environment with a lot of legacy java, soap, and IBM services. We reach across a broad range of services that assemble our graph. The graph provides our clients with a performant, flexible, single point of entry to backend services. 4) No experience to weight in but is X framework better than Y or Z is usually a bad way to frame these questions. Frameworks will always have strengths and weaknesses. Pick one that works for your team and product goals.
[removed]
It’s JavaScript running from native Swift code, so I guess it’s arguable that it is actually native. Swift creates a JSContext, which is a core Swift API, and runs your app inside it. Nothing like the jiggerypokey Cordova uses, but you’re still calling on native APIs and can access any native API you want. RN has had native animations for a while now with useNativeDriver
I don't see demand decreasing. It's really not a skillset that anyone can pick up, like what you've seen in other job sectors that hit a bubble. Businesses are also getting a lot better at seeing IT/Software Engineering as a competitive differentiator and less as a cost center. I work at a fortunate 100 company that employees thousands of developers and is hiring a ton more (and it's certainly not one that people would associate with software development). I've also not been impressed with anyone coming out of a code school. They are going to be very junior and require years of experience before becoming a strong developer. I don't think there is anything fundamentally wrong with code schools and encourage anyone interested in pursuing programming but those schools leave out a ton of the basics; instead focusing on popular frameworks/tools. Those folks will have a lot of catching up to do.
“this” refers to the ProgressBarLibrary var that was already set, so yes this is already set. It looks like they set the loop var to false there to make sure it is not looping when the code starts, but then once it’s run it starts looping. I’m not sure, but by setting it there it’s a global variable that can be used inside any function
&gt; 2 year’s experience and you’re on £50-60,000, after that it’ll keep rising until you’re on or very near six figures (and higher if you work in the right industries). Which industries apart from finance?
Check out JSHint. 
You could try using a Linter - I've learnt a lot from using it one. I really like the Airbnb rules, but Google have a good set too. You can even integrate it in to atom or vscode for hints on the fly. Have a few links: https://eslint.org/ https://github.com/airbnb/javascript https://google.github.io/styleguide/jsguide.html https://atom.io/packages/linter-eslint https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint
thanks a lot for your reply. I need somehow to put a file into one folder. but after all i will use downloads folder.
I'd love to move to Switzerland one day. Where should I look for front-end jobs based over there?
Was this just a learning exercise? It doesn't seem to add anything except a lot of *engineering* on top of youtube-dl which is already able to convert to mp3. It even depends on ffmpeg, which is already a part of the youtube-dl docker image - not that it's necessary. 
Bleh - thanks for testing! Unfortunately I don't have an iPad, but I'll open an issue for it and keep trying to figure it out. Can you tell me what version of iOS Safari you're using?
1. I think the market's been flooded with a lot of JS students and Jr level devs lately, but every industry has a pyramid structure. There will always be demand in tech for someone who knows what they're doing. There are still FORTRAN jobs out there. 2. The best devs I know with 20+ yrs exp. have their complaints about EVERY language they've used, no one language can solve all problems or should be used for everything. I tend to think of javascript as a utility glue that holds other parts of an application together. It NEEDS to be weakly typed, etc. p.s. if you didn't know, JS isn't a purely functional language, it works great with OO, prototype, and several other styles. I love using OO with JS because it keeps the scope from being polluted in a larger environment. 3. Depends on the job. I work with React Native, PHP, Node, and a lot of custom API work on the front end. Homebrew is helpful, so are webpack, yarn, npm, and grunt. Honestly the MOST useful thing I learned when I got seriously into dev was how to write my own scripts for the command line. Git autocomplete and aliases are a godsend, scraping pages and running security tests are a breeze, and I haven't had to pull a production database and convert it to local with more than a few keystrokes in a long time. Second most useful? Linting. Nothing more humbling than linting your project. 4. My team built a RN app for a global publishing company. It's definitely better and more robust than trying to wrap a webpage using something like Phonegap, but you can run into some real device end environment specific headaches working with RN. React native is still pretty new, but the updates are coming in quick and a lot of early adopter problems are going away. It's also nice to write a few js components rather than a huge blob of Objective C for everything. Overall I think it's a great tool for web devs to get into creating apps with the ability to add real functionality. To answer your original question, I worked in audio tech before I worked in code. There was a "become a recording engineer" boom about 5 years before there was a "become a developer" boom. Many people went into recording thinking they could just get a job, not realizing that you work unpaid like a dog for years just to get your name on a few records. Unfortunately there's a lot of that in the "become a dev" boom. i've had a few friends who didn't really take academic learning seriously and really struggled with learning coding, they ended up frustrated and quitting after realizing this shit is fucking hard. So if you're serious about working with this stuff, treat the craft with respect, stay savvy, and work your ass off. There will be jobs. The people who flock to any industry for a quick buck will always fail. Hope this helps!
$15... I know they almost never actually sell for the listed price of $192 but it's still $15 and you get more than $15 worth of value from the courses. I've found some very good ones.
Yalla need Jesus! Is setting the `innerHTML` of an element terribly inefficient?
Thanks, the second link seems interesting. KeyboardEvent.keyCode is being deprecated though, I used that first, but switched to .key... Btw, the easter egg triggers when you've pressed 76 keys, which is the number of keys on without the numpad :) 
Im always surprised when people say that, i as a german dont see that.
You might try exercism.io. It has predefined exercises that you submit, and then people critique your code. Or at least that's how it worked last time I looked at it, which was as while ago.
You can try posting it here in this subreddit. People have done it in the past. Response can be varied, but you sometimes get good feedback.
$(window).scroll(function() { if ($(this).scrollTop() &gt; 500) { $('#ID').css({ 'visibility': 'hidden' }); } else { $('#ID').css({ 'visibility': 'visible' }); } });
&gt; It’s JavaScript running from native Swift code, so I guess it’s arguable that it is actually native. If that argument was valid then it could be argued that any JS runs natively, or any interpreted language like Python, Lua, etc. After all, with very few exceptions, most JS engines are written in C++. JavaScript core is written in C++ which is what RN runs on, and yes, also Safari and ultimately WKWebView which is what Cordova uses. Of course that argument is wrong. Interpreted code is not native, even if it is JITted. I also think that the argument is irrelevant. Unless you are making CPU intensive operations the raw speed of JS is good enough in the vast majority of cases, and expensive operation can be offloaded to C anyway with a native plugin. I'd also like to point out that the notion that Cordova "is slow" is pretty much a thing of the past. Rendering engines are faster now than 5-7 years ago and devices are so much faster. Not only that, but CSS allows you to create intricate responsive UIs which would be extremely complicated to make in any other UI library you can think of (Cocoa, Android, Qt, wxWidgets, Juce, etc). Apple uses webviews extensively in its own software, which is what Cordova is in the end, but here's a Cordova app that runs butter smooth and also shows how much more powerful CSS is than native Cocoa: https://medium.com/missive-app/our-dirty-little-secret-cross-platform-email-client-with-nothing-but-html-aa12fc33bb02 I'm not saying RN or NativeScript do not have its advantages, and I'm not saying either that Cordova is perfect for all use cases. Just that the idea that Cordova is crap and RN is awesome is delusional at best. Pick the best tool for the job.
Why are you **spending hours** with basic HTML and CSS? Better yet, why are you doing any CSS? If you want to learn javascript for front end you only need a little bit of HTML Worry about the looks only after the functionality (javascript) is done.
It's totally fine, yallajs is actually using it for parsing static strings
Next bullshit in the userland, but okey if it serves what you need.
Cool!
Haven’t checked yet, but yeah. Thanks for the "{". Typical stuff that.
missing a closing curly bracket after else
Yeah, I noticed that after the previous comment. Thanks anyway.
[Exercism.io](http://exercism.io/)
Look into the FileReader object for loading data from a client, and then use the HTML5 tag to do downloads (Chrome only) or use native browser downloads like msSaveOrOpen(). 
What do you mean with “next bullshit in the userland”? I would’ve really preferred not to go down this route in order to strip our bundle from code we’re not using, but the standard webpack + uglifyjs simply weren’t cutting it. Maybe I should’ve opted to contribute and improve those tools instead of creating a new tool. Unfortunately there was a business to be run. Was this what your critism was referring to?
/r/codereview Please be a subreddit please
Sure, but CRA is one of the quickest ways of getting that going. Beginners shouldn't start by wrangling `webpack.config`. I got the impression from the op that they feel comfortable with basic HTML / CSS, and that they want to learn basic JavaScript too.
OP, ignore this poster.
Send me a link, I'll do a free code review today.
Don’t get me wrong - I love CRA and AngularCLI. There just seems to be a trend in this sub with suggesting full blown frameworks to people who can’t even console log hello world. Your comment probably triggered me haha :)
Just wait a few months, then read your code. If then you think "who was the moron that wrote this code?", it means that you are improving.
Probably all of them except smaller agencies. That’s just the standard salary for a full stack JS developer in London. I work in publishing, previously it was retail.
Post your code anywhere and people will immediately tell you everything you ever did wrong and why their way is better
Fair point :)
And https://www.codacy.com/
If you post very often, you will get lots of reputation points. If you reach 100000 you get a nice package with a mug and stickers from them. So there's no problem with posting very often, of course provided that your content is very high quality. In the case of questions on CodeReview.stackexchange.com, this does not mean code quality, but a nicely laid out and sensible question. See [their extensive FAQ](https://codereview.stackexchange.com/help/how-to-ask) for more information.
As a junior developer too, who's been working with/learning both Vue.js and React, I'd recommend Max Schwarzmueller's Udemy Vue.js course, if you have a few bucks to spare. It is quite comprehensive for the price. Use it as a reference for when you're stuck on an issue while working on some small projects, rather than watching the tutorial from start to end, kind of like a movie. Of course, I'm assuming you've been at least acquainted with the tech but that is not an issue as the course covers the very basics. 
How did I NOT know about this?
The guy's great!
In the `Init` function, `this.targetElement` gets defined like so: `this.targetElement = document.getElementById(id);` - after this happens it is (presumably) not null. I'm not sure why they did it this way - you could go either way, really - setting `targetElement` via a var outside, or setting up `loop` as a property on `this` inside the constructor. Best practices kind of dictate that you shouldn't declare loop on the outside. Reason being - it makes it a global variable and any other scripts depending on the same variable name could conflict with it. Usually you want to expose as little as possible to the global namespace -- in this case, probably `ProgressBar` Then again, you could wrap the whole thing in an IIEF and set `window.ProgressBar = ProgressBar` at the end to avoid any potential global scoping issues. IIEF is "immediately invoked function expression" - it's a way to a fresh scope in a function. (function () {})() // function wrapped in parens that is invoked.
RN uses native APIs to construct an app’s interface and uses native APIs wherever it’s beneficial. Cordova constructs a website and runs that website through a native web view. The two are very different. I stand by my point that RN is arguably native. As for Cordova being slow, I wasn’t saying it was slow in general. I specifically mentioned fps, and Cordova is restricted to 30fps due to the fact it is run through a web view. There’s no getting around that fact. The fact you think UIs would be “extremely difficult” to create without CSS shows you have little experience with RN and do not fully understand the benefits. Styling in RN is basically CSS anyway. I’ve been working on cross-platform apps for half my career and since RN has come on the scene there are very few reasons to use Cordova. Really, the only reason is because you want a single solution to solve web and both mobile platforms.
There's a big difference between an actual engineer who knows JS and UI developers who write HTML and CSS and sometimes JS. These are some of the kinds of questions we ask to figure out the difference: What's a JIT? Describe JS's performance profile? What are some things that cause de-opt? What's a hidden class? What's a transition? What's the difference between sparse and fast arrays? What's an event loop? Do you know what libuv is? How it works? 
In an effort to get better with react I’m starting to publish some of my components I️ use frequently (tabs, accordions, sliders, carousel.. etc) to github. https://github.com/austinpickett/react-ui-tabs
My own experience from applying and hiring is that you can easily get in at £40-50K as junior, progressing to £55-60K as a mid, then £70-80K as a senior. Unless you work in the finance sector, where the limits are substantially higher. But, it's London, so everything is inflated :-)
Can you explain what is poorly written about it? Would love to improve in the future. 
Er, what's detrimental to what? If you're saying that Vue's template system is inferior to JSX, Vue does also support JSX. 
I made a web app that let’s you swipe or use keyboard shortcuts to manage your saved posts on Reddit. [snooswiper](https://snooswiper.com)
note that codereview is strictly for reviewing working code. if you need help fixing code that is not working use it's sister site stackoverflow.com instead
Wow, thank you for taking the time to explain this. You've done an amazing job at decoding the what was alien to me. 
I know, but it's the support that makes it slower, the code more complex, and the API larger. I should not overemphasize the downsides of that, though - it's more that the templates are what, if I understand it correctly, primarily sets it apart from React. If you don't need that, then it's probably not worth sacrificing the advantages React has over Vue.
not possible, but you can write data in cookies, the broser localStorage or even create a pouchDB database inside the browser for reading/writing data purpose, but it would be a critical security hole if this was possible, you could write trojan to disk, grab passwords hashes .... nope browser run inside sandboxes nowadays for the better.
+1 for linters - they've definitely helped me develop a more consistent coding style. I know you mentioned Atom and VS Code, but most editors should support linting on the fly AFAIK. I've been using [ALE](https://github.com/w0rp/ale) to lint as I code in vim, and love it.
I'm a native English speaker and I thought it was well written for a blog post. I thought the use of "jank" was funny, but mostly because I always say that, and I've never met someone else who says it.
Sublime also has support for linters.
Thank you for these tips. Im in the same situation as you. Learning to code is hard without help.
Its a syntax error that I can't figure out after combing through it. Like a need a second set of eyes to find it..you know? Like the missing "&lt;div&gt; " 
Still need help. 
Whatever comes with iOS 10.1: &gt; Mozilla/5.0 (iPad; CPU OS 10_1 like Mac OS X) AppleWebKit/602.1.50 (KHTML, like Gecko) CriOS/60.0.3112.89 Mobile/14B72 Safari/602.1 You know, there should be a touch input simulator in chrome devtools.
Yessssss I love the way the possible states are listed.
&gt; I stand by my point that RN is arguably native. Well, first you said that "RN is totally native" which is simply false. When I pointed that out you said that it's "arguably native" because it seems ok for you to ignore the fact that your interpreted logic is written in JS and it is running in a JS engine on a separate thread which is actually consuming CPU. This is all explained in the [RN docs](https://facebook.github.io/react-native/docs/performance.html). &gt; I specifically mentioned fps, and Cordova is restricted to 30fps due to the fact it is run through a web view. There’s no getting around that fact. Which is also false. WkWebView can perfectly run at 60fps. If you actually looked at the link I provided for you that should have been crystal clear. I'm not even talking about theoretical benchmarks, but about a real product that was featured by Apple itself in the App Store. FYI there are actually game engines running at 60fps on WKWebView. &gt; The fact you think UIs would be “extremely difficult” to create without CSS shows you have little experience with RN and do not fully understand the benefits. Styling in RN is basically CSS anyway. It actually shows how little RN you know since it only implements a subset of CSS. For example: can you do CSS transitions in RN? No you can't. It seems that you are quite prejudiced about tech and you prefer to stick to your opinions rather than facts. It is pointless to keep on arguing.
What advantages? Vue is lighter, faster, yes, even with templates , nicer to read, especially with SFCs, supports pug for templates, type script, has no brainer preeendering and SSR. Another strong point is that it tries hard not to reinvent the wheel, it functions well as a framework on it's own and as a stepping stone toward web components because as I said it goes out of its way to have compatible syntax. These are all advantages over React.
google :) big financial firms accept English speakers more easily than small businesses, if you know german you are good anywhere 
I guess it's a bit off-topic to go too deeply into them here, but since you asked, off the top of my head: being supported by Facebook, being as widely used and tested as it is, having a more extensive ecosystem, having a smaller API, clear design principles, to name a few.
Not true at all, your friend doesn't know what they're talking about
Your friend is dumber than a bag of rocks. 
JS is rapidly supplanting PHP, Ruby, Python, Java, and basically everything else for backend development thanks to node.js. It is also doing the same for the front end thanks to frameworks like Angular and React. I'm putting my money on JS to be *the* language to know going forward for web &amp; even mobile development, thanks to nativescript. I can't find any information on this announcement by Apple, either.
I thought it was finely written. Great job.
This is really cool. The performance improvements are exciting too!
Ever notice when you write bad code, everyone will tell you what a fucking idiot you are but when you ask for a code review, no one cares?
&gt; JS is rapidly supplanting PHP, Ruby, Python, Java, and basically everything else for backend development thanks to node.js. JavaScript is growing fast and has a lot of community, but that might be overstating things. Java is long way from even being endangered in the enterprise world. There are clearly more Javascript jobs now than there have ever been.
What the heck are these new Apple products anyway? 
Is your friend thinking of the few years old announcement of removing support for flash? Because yeah he is a bedrock of everything online. For better or worse. If you want to do any online programming, honestly I'd highly recommend it. 
If we insist on the original, 'correct' versions of words, then all of the pedants are misusing "literally" too! The *original* "literally" meant "verbatim, word-for-word". A medieval monk would be very careful to copy the Bible *literally*, as even the slightest transcription error would make the whole work unacceptable. 
Nice. I'll give it a try one one of my projects and see the difference. What kind of differences did you experience file size wise?
Write a blog post about how good your code is and post it somewhere people can leave comments. They will rip it to shreds.
care to explain? granted, it's not directly code review related but how does that warrant being ignored? 
We saw great improvements in our mobile/desktop bundle. We moved from a single bundle to a separate bundle for mobile and desktop and were extensively using named imports. This meant that a lot of desktop code ended up in the mobile bundle and the other way around. We also have a rather large "core" library from which we import often, but we don't use it completely in every project. We saw a 20-30% decrease in bundle size on average. Please do report back on the results you got :)
Well it comes down to which of the two lists one values more. Tbh, none of the things you mentioned seem very appealing to me apart from extensive ecosystem but I needed very few third party components or plugins in my projects (and the ones I did were pretty good) and the bit about design principles where we'll have to agree to disagree. 
1. Anecdotally, I haven't seen it happening yet. We keep hiring more, and increasing salaries. I don't know about the market as a whole. I agree there are a hell of a lot of JS devs getting trained up, and they have to go somewhere. So far, the demand has matched the supply. 2. I know some who hate it, mostly because they hate not working in a typed language, or they like 'real' functional programming, or they hate being reliant on NPM modules for everything, or they don't like that there aren't many good JS IDEs. All of those are addressable concerns, but that doesn't stop people from being bothered by them. On the other hand, I know people who came out of other languages into JS, and prefer it in many ways. 3. Well, depends on the project. Right now I have one project that is React with Typescript on Node and Python, and another that is React with Flow on Node. I usually use Atom or VS Code. Based on, ahem, client preferences, we've been working with Azure services lately. The module selection varies, but usually it's going to include redux, react-router, webpack, babel, and so on. Github, Travis, Jest... 4. I have not used Xamarin, but in general those things all have the same set of pluses and minuses. There's no clear winner, so just pick the one you like the best. If I had to guess, I'd say you are weighing the possibility of becoming a hybrid mobile JS developer? It's probably better to just be 'a good programmer' without lashing yourself to some particular set of technologies. I'm old, and I've seen trends cycle through a few times. In five years, there will be a whole new set of technologies to care about, and if you're a good programmer, you'll just pick them up in stride.
Yeah you should be using length to check if the array is empty, if your array is undefined for any reason before you check the length it will throw an exception so just be careful of that, easy way to check if it’s not null is If (myData &amp;&amp; myData.length === 0) Also most cases it’s best practice to use triple equals check because that checks for type as well
I offer code reviews and lessons if you're interested but they're not free. That being said, anyone who shares their solutions or questions on my YouTube channel usually gets a response from me... for free. It's not what you asked for but if you're looking for a JavaScript specialist with teaching experience, then I'm your guy :-)
If we insist on the original 'correct' versions of words, I'm going to need a new keyboard because mine is missing æ, ᵹ, ſ, Þ, and ƿ
Yeah, I used that and it works. :( I think iOS Safari handles touch events differently than other browsers.
That's not true at all. Congrats on not doing any research whatsoever and putting the entire future of your career on a friends word.
&gt; get tips on improving how I code Another great option for this is to contribute to open source software. Find a bug or feature request and submit a PR.
No. 
The other thing maybe the friend is confused about is that JS a dialect of ECMAScript. Flash used Actionscript which was also a dialect of ECMAScript. So perhaps they saw "killing flash" - translated in their mind to Actionscript. Saw that both JS &amp; Actionscript are both variants of Ecma and just assumed that meant JS is killed off. That's the most charitable explanation I can think of. Or your friend's just full of shit.
Plugins like this make me nervous. They're advertised as "just add this and your bundle size will go down!" But when things break (e.g., because of side effects that get unintentionally removed), it's almost impossible to know why they broke. Solving module resolution problems in webpack bundles is a nightmare as it is; I don't know how these sorts of problems would ever be solvable. I use a library that parses EXIF metadata. Turns out it patches `Buffer.prototype` in its `index.js`. I was unlucky to be stuck figuring out why the library sometimes threw an error about missing methods on objects that would otherwise be `Buffer`s when certain images were processed. Solving this took me two days. This exact sort of problem would have been _even more_ difficult to debug, had I not been able to even see where the patching happened. Back in the early (earlier?) days of Babel, Rich Harris started ["buble"](https://gitlab.com/Rich-Harris/buble) out of frustration for Babel's verbose output and poor performance. Turns out, the "ES2015" it generates isn't exactly spec-compliant. Rich says so himself, with comments like &gt; This allows us to continue generating lean code that performs well at runtime while satisfying the bores who value spec compliance over end user experience. It's easy to not see the problem here. Imagine, for a sec, that you buy a USB cable to charge your phone. It's advertised as being the fastest cable on the market! You get it, and it only charges your phone when you connect it to an AC adapter. It doesn't work when you connect it to your laptop or anything else. You call their support and they say, "Out of the box it solves the use case of almost all of our customers. You can make it work with your laptop, albeit at a slower charge rate, if you add this configuration that satisfies the bores who value spec compliance over end user experience." That sucks a lot. I'd encourage the maintainer to add a more obvious warning, and perhaps even publish a list of popular packages that could be affected.
I don’t know shit and I know your friend is wrong. 
Thanks for the feedback. This is definitely a good point and I am certainely not trying to convince everyone this is a magical bullet. It will definitely not work for everyone and you might have issues if your code relies on side effects. Just before you posted your comment, I realized I didn’t make this clear enough in the README and added a section to the FAQ about this. It also states we recommend not running it over external modules to avoid the kind of problem you described. Do you think we should make that more explicit? Again, I really get your point and those kind of bugs are a major pain in the ass. I just dealt with one myself and wasted a similar amount of pain. On the other hand, I also wasted a lot of time trying to get tree shaking to work properly. I found webpack/uglifyjs, and even rollup to be too conservative. In our case, we didn’t have a single line of code with side effects in it and we didn’t care about external dependencies, just about our code since it accounts for the majority of the code. This plugin is not conservative and is rather aggressive. It transforms everything babel passes over and although it doesn’t decide on its own when to drop something or not, it could cause the next plugin or optimizer to make the wrong decision. Again, I totally get your point and any feedback to make this more obvious would be greatly apreciated.
There are great jobs out there just take your time... Don't be desperate for a job either...
&gt;for-in and for-each are slow, use a regular for loop wherever possible This is negligible in 99% of cases. Doing this just to do it is premature optimization, and forEaches tend to be easier to read / less declarative. &gt; look up singal var pattern and at least get close, definitely don't define variables inside of loops There are plenty of cases where it's acceptable to assign variables inside loops. Again, premature optimization. &gt;and don't use multiple returns in a function (unless you're defining a separate function), you can always replace them with if/else logic and make your intent way more readable While it's true that too many returns can indicate a god-function, there are many common scenarios where it's common to return early. Throwing a generalized statement like that out there can be confusing for newbies. In general, it's nice that you're trying to help, but it's important to provide the right information right off the bat so people are less likely to get discouraged. 
Your friend means Flash, not JavaScript. JS is up and will continue to go up in the coming years.
Popular https://github.com/WebReflection/hyperHTML looks very similar. Care to explain what are the differences ?
There are several issues with the code sample above. What are you binding an event listener to? Given the library you'd have something like a game object or something that you'd be binding the listener to... game.addEventListener(). Also within your event listener, you define a function that is never called, you likely meant to define the function outside of the listener and then call it within it. function receiveCopyData() =&gt; ... game.addEventListener('copydata', receiveCopyData);
The warning has certainly addressed my FUD! Thanks for being responsive and open to suggestions!
Unless I'm mistaken I'm pretty sure React has a react-router module, too.
I have no clue about how this works. Want me to upload both Leader / Helpers files to pastebin? Currently the leader writes a message into the game chat to tell the helper what to do such as "Kill 243". I would like to change it from sending it in game chat to sending it through the window(bot talking to the other one via game window) Leaders script : https://pastebin.com/p0mEpMJe Helpers script (Helps with multiple leader scripts) : https://pastebin.com/jfeMN73J Here's a thread on github explaining how to do this but I don't know how to do it. https://github.com/kolton/d2bot-with-kolbot/issues/294 This shows you how to change Say with sendcopydata
I've only posted my code there once, but no one commented on my code when I did. However, I did receive 3 upvotes, so maybe there just wasn't anything worth commenting on.
Your friend is laughably ill-informed. Javascript, html, and css are all intimately interconnected and none of what most people consider 'the internet' would be possible if they did not work together.
&gt; ur code is bad and u should kill urself faggot /s
Jobs are still viable. That said, I'd encourage you to expand your vision. I love JS, but I don't call myself a JS Dev (nor a .Net dev nor an anything else dev.) I'm a dev that knows JS. If you can get to that point, you become a lot more marketable.
Going to agree with this guy right here. Interviewed a bunch of JS devs with a bunch of concepts and buzz words, then ask them to write a simple JSON object and a simple for loop and they choke. Learn it, and learn it well and you'll always be employed
You can also try pissing off some black-hat Russian state-sponsored hackers. Free pentesting!
The biggest difference is the API, yallajs only have 3 api, render, html, and htmlCollection. Why its so simple, because we believe this library in future will disappear once browser adopt their own templating engine. YallaJS is not a framework, and probably this is the only library that the author wishes to be disappear. The reason why we have this library because this is the missing piece of #usetheplatform campaign. Moreover i don't see the actual benchmark result of hyperHTML, and i'm not really sure how to use them. Please take a look on how the HeroEditor angular project, rewritten with ES6. https://codepen.io/yallajs/project/editor/AxKoNY Im sure youre gonna love it :) take a change to read the complete story here https://medium.com/@yallajs/how-it-feels-to-learn-javascript-in-2018-6b2cf7abb6aa
I was looking at the main tutorial on the React site where they make a tic-tac-toe game with time travel. I implemented it with [Composi](https://composor.github.io). Almost the same code, only some minor differences. And then I made it so that it would show the winning moves on the game board: https://codepen.io/rbiggs/pen/POpMMz
Hi /u/D2PvPm8, For javascript help, please visit /r/LearnJavascript. Thank you!
To save everyone some time from listing all text editors, pretty much every text editor has an eslint plugin. Just google "&lt;text editor&gt; eslint"
JavaScript is always going to be the foundation but it is useful to learn more advanced user friendly languages like python or ruby.
well anything to do with d3 should avoid for-in and for-each, where it makes the difference between handling a few hundred data points and a few thousand If youvd read the second part carefully, you'd see i didn't say don't ASSIGN variables in loops, I said don't DEFINE variables in loops, which is a big difference... If you weren't aware of it please look it up, more good code in the world helps everyone single var pattern is helpful besides just hoisting declarations out of loops, it more closely represents the situation at runtime where all declarations using var are effectively floated to the top of their functions anyway, so why not make your code resemble that ( yes, it sometimes helps to compartmentalize when you can't refactor it immediately ) And without examples, I disagree and maintain that early returns imply implicit if/else logic that would be more clearly understood (especially by new developers) if represented explicitly with if/else... I'd love to see counter examples if you have any...
I would love to see apple drop JS support. The world would melt. 
I think I'd rather just continue doing this manually on a case-by-case basis, where I can be sure it won't cause any problems.
&gt; tuhg
Books, podcasts, school, the internet. You're welcome.
JSContext running in a separate thread is entirely besides the point, I’m not sure what you think you’re proving by that. And that it’s “actually consuming CPU” is just auts on another level if you have even the slightest about what’s going on under the hood. What doesn’t consume CPU. About not knowing enough RN, surely you are aware of the Animated API that handles that stuff instead. Or is “basically CSS” === literally exactly the same as CSS in your thick skull. Because “basically” does not mean “exactly the same as”. You seem a little tetchy about all this, so I’d say calm your tits and do some proper reading before going online and looking like a tool again 
Is there a forum where I can make $5 to review someones code and give useful tips?
Yes. 
Personally, I don't care for transpiled languages (ORMs fall in to this) for the most part, since it seems that you are writing a sitcom for an English speaking audience in Spanish only to have it translate it back to English. So, some things just don't translate as well. So if I ended up working at a place that did this, I would want them to really convince why I should do so and well, I would test them on their actual knowledge of the base language.
Post it as a tutorial for how to write great code on medium, then share it on various subreddits and Twitter. You'll get the feedback you want pretty quickly.
You know you could have posted the code as text, linking to images.
Airbnb used Coffeescript in prod for many years AIUI, might still do. TypeScript, Flow and Babel are standard parts of the JS stack these days, even if you're just writing ES2016. ClojureScript's surprisingly popular.
If you use React, Angular(2+), or if you use any ES6 at all, you're going to compile/transpile to ES5 - So, Facebook, Google, Netflix, Reddit, AirBnb, and probably thousands of other companies are doing that. If you want to have 0 build steps, just write the ES5/jQuery code and run with it. But as soon as you add minification or anything like that, you might as well write ES6 or TypeScript or anything else you like because adding that to your build steps isn't that much extra work.
Well as of right now, writing ES6 is effectively writing code that needs to be transpiled, so if someone questioned me saying that ES6 is unnecessary and I need to convince them why it is a good idea - I guess I would direct them to the TC39.
Instead of writing C# should I instead write MSIL directly? x86 is a pretty common language and is used by a large number of processors so maybe I don’t need C either.
So you're iterating through the entire list multiple times. Hence your bigO complexity would be O(n).
Where n can be n, 2n, 3n.. it's all considered as O(n)
Is this for a homework assignment, or to get a better understanding of the behind-the-scenes of specific language features? Each array method runs a function on each array element. There are a number of object property lookups and assignments; object property operations are essentially hash table operations (setting aside the fact that objects are sometimes optimized to classes by the JavaScript runtime).
At first, that was the approach we took as well. As our code base grew, we started to experience the pain of maintaining that and there were always cases we missed, that could’ve been optimized. The automatic process does a better job and it gives us more time to worry about other things. We considered not doing this, but since we have a strict code review process and do not allow code with side effects to go in, the risk of it causing problems seemed minimal.
Also make it sound like you're really full of yourelf
because we are iterating the list twice with map &amp; reduce.. time would be O(2n) right? and space is not O(1) because a second copy of the list was created?
Thanks for the input. This is not a homework assignment, just new to CS fundamentals. 
As n gets closer to infinity, n becomes approximately the same as 2n, so you usually just simplify O(2n) to O(n), as cooldude0609 mentioned. Same thing sorta applies to space complexity in this case, O(1)
I did say:"...for the most part". I can see where it can be beneficial to transpile back to a more supported version of JS, and when the support for ES(whatever) comes out, you just release the code. Well ES Next will be out, and you would update your code to that, then transpile it back to ES(whatever).
Well I don't know C# nor MSIL, so I can't comment on that directly. x86 is a CPU infrastructure description, which includes an instruction set. x86 Assembly would be language. Now I was talking transpiled, not compiled languages, or JIT languages. Also said "...for the most part".
[Vue is 7 kb lighter](https://pbs.twimg.com/media/DOGR7spWsAAyMFo.jpg:large), makes about no difference. Notice that you can alias React, at which point it shrinks to 3kb. Vue is under no circumstances faster. It competes against Fiber, the webs first scheduled renderer. As for templating, it's just a preference. For me it's the other way round, but good that there's the option to be able to choose among both.
Linters are nice, but it irks me that most focus on style and not on logical issues or performance.
ES6 for web all day every day. Technically compile to JS.
Has anybody ever tried something like Codementor.io? Could get expensive over time but it seems like it could be helpful? Curious if anyone can comment on the general quality of the "mentors"? I'm in a similar boat in that I'm trying to learn/teach myself but don't really know many coders that I could ask for that kind of help or time.
/r/iamverysmart
No, no API in Axure, i manualy enter data in. I didn't look this way...you are right. But for code to go in production, how long do you code? You must be quite advanced in knowledge. Forry if i allready ask this, are you using any Angular, React or Vue framework? Do you search google for components or you allways do all from scratch? Components like sort with draging or dragable timeline with clickable elements on etc.? Where did you learn to code and that do you recommend?
https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API There's some tutorials here. 
Big-O notation isn't about runtime, but understanding how runtime will *increase* as n increases. For example, if I double the size of the input, does runtime double? quadruple? something better? something worse? For this reason, O(n) and O(3n) are considered the same. In both cases, if you double n, then runtime doubles. Similarly, O(1) and O(2) are considered the same: if you double n, nothing happens. For simplicity, we usually omit constant factors, and prefer to write O(n) over O(3n).
I work at a financial software consultancy, where we have around 150 developers building software for banks. These are typically large-scale applications, such as research and trading platforms. Every six months I send round a technology survey to see what the various teams are using. Right now I can tell you that more than 75% are using TypeScript, for mission critical production apps. We've also been using it for more than 2 years now. No - it is not a fad! (By the way, the other 25% are also compile-to-js, most typically from ES.next to ES.old)
As chrome now supports every es6 feature except tail-call optimization including the module system you should definitely start by learning es6. Not only it is a better language than the previous version of javascript, when you decide to use it in production you can safely take your modular code and transpire it into es5. This means that you can just write es6 javascript and use it in a browser using the script tag. If you want to start with Typescript you will have to use node. Even if only for the transpiling I think that if you are a beginner adding the overhead of having to configure your environment is not needed. 
Yes, that's why I said "if you value x go for Vue, otherwise React".
Coffeescript here. Internal apps for a telecoms company. 
I will explain my case. I need to put a text.inp file into some folder. This folder is scanned by this printer every 0.5 seconds. I can put this file into downloads without a problem, but i wanted to avoid this so the printer does not have to scan other downloads and thus creating delay in near future. Any suggestion or i should go with download folder?
Thanks for this. You posted a link to a Google style guide. But does Google actually provide a linter I can install/use while coding?
Plus the benefit of using modules in your js
Short answer: if you're serving content to the user's browser, there's nothing you can do to control how they use that content. As you've already mentioned, putting "private" code server side, and interacting with it via an API is the best way to protect, and hide, logic or algorithms you don't want the client to see. No closures, minification or obfuscation will stop someone reading or modifying their local copy of your code, when it has been served to their browser. The biggest thing to think about here is: would anyone actually steal my code? Unless you're publishing never before seen algorithms that have commercial impact, I would not worry. If you believe there's a serious risk that people could steal your code, and use it in a way that damages your efforts, then you should put the effort in to secure it. Moving it server side, or having logins and even NDA agreements for your users.
No such thing as O(3n) - or rather, it's the same thing as O(n). These are asymptotic classes of functions, which are closed under multiplication with constant numbers. The literal definition is: "f(n) is in the class O(n) iff there exists a threshold n0 and a constant c such that f(n) &lt; cn for all n&gt;n0."
yes I’m using typescript on prod.
The transpiling is one good thing of a build system like webpack. But there is so much more good stuff. We are auto generating styleguides for all of our components. Automatic documentation generation with typescript. Lintchecking. Not using a build system these days is pretty ridiculous tbf. Since it is very easy to set up and comes with alot of great devtools like the webpack dev server wich does hot reloading for you.
We are using ClojureScript for 3 or so years already. IMO there are two main reasons why you’d want to switch to such a language: 1. Current language choice doesn’t satisfy your need (safety, expressivity, idioms, maintainability) 2. You have backend devs who knows X and it would make sense to use X on the frontend so a product could be developed faster
Thats a stupid analogy. You write something a browser doesn't understand wich transpiles to something a browser understands. Knowledge of the "base language" is a stupid note aswell because you are talking about the dom api. Wich doesnt change with transpiling. It mostly just polyfills new features for you. But if you think that you can do a better job at polyfilling every es6+ feature than the guys at babel... Go ahead and be stubborn.
There are no reasons to write vanilla code in a super high-level language like JavaScript just for the sake of it, unless it meets your needs. JS have one of the best tooling ecosystem there is, not taking advantage of it is wasteful.
Programming languages are all about abstractions. I truly see no difference between running JS code straight vs having a transpilation step inbetween.
You can create modules with requirejs too. Not saying I recommend it over TypeScript, just that you don't need ES6 to modularize your code. 
So the normal workflow is that you'd install a Linter in to your text editor, and configure it with ESLint. You can also set ESLint up and just have it scan your files. If you're using npm: ``` npm install --save-dev eslint npx eslint --init npx **/*.js ```
Where is the JavaScript?
Most if not all companies transpile and/or include build stage transformations like babel, typescript, webpack, jsx and minifiers. Without babel or ts and javascript is a very crude language to work with. Without bundlers you'd be cut off node, npm and modules in general. It would also cause gigantic payloads (script tag monoliths). 
Maybe he meant Steve Jobs, who was indeed removed from everything Apple.
yes, i use it a lot on prod.
Wouldn't the worst case space complexity be O(n) as well, as you have to store the duplicates array
But if I want a job with javascript is Es5 still the standard? Or is everyone using es6/ts?
That Elvis operator though. 
Why is the table of contents on the site not a list of links to page anchors? The table of contents serves little purpose without it
Lots of Rails-based websites use CoffeeScript, even though even back in the day it wasn't very useful and now it's completely useless. I personally use Typescript for backend and its great, the type checked parts were mostly bug free. There are huge products written in TypeScript e.g. Jupyter Lab the successor to IPython
It says “internet of things” and we all know internet is synonymous with JavaScript.
Pretty far. h/createElement shouldn't return return target elements but v-dom descriptions. The renderer takes that are casts it into the target, for instance the browsers dom. There's a nice description of how it works here: https://ryanfunduk.com/articles/react-from-scratch/ If you follow this, then even JSX would work with your implementation. This stuff has actually been abstracted now, via the [reconciler](https://github.com/facebook/react/tree/master/packages/react-reconciler). That means you just [fill in your element creators, removes](https://gist.github.com/drcmda/cbc77a30681bf41791ccc29ee0f5d855) and so on, and the reconciler schedules, diffs and deals with it otherwise.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [facebook/react/.../**react-reconciler** (master → acabf11)](https://github.com/facebook/react/tree/acabf112454e5545205da013266d8529599a2a82/packages/react-reconciler) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dppcq40.)^.
Depends, on my job we use typescript and es5, and compile typescript to es5. Anyhow, you would compile your es6 to es5 anyhow.
A lot of Google teams are using TS, Dart, or Google’s older JS static typing system. You get so much benefit just from types alone, let alone the other language features.
Assuming that I'm trying to just solving render and keep out patching DOM elements logics and stuff like mounting events. What you think is needed to be production ready? And JSX working?
I mean if that's how you want it it's fine too. As long as you fulfil (props, attrs, children) JSX should work. It has been done before, you could look into [dom-chef](https://github.com/vadimdemedes/dom-chef) for instance. 
From my experience the fact that I knew es6 was always considered an advantage when it comes to job interviews. These days major companies like Google or Facebook push developers to use the latest language specs. When it comes to the most popular front end libraries / frameworks React and Angular both take advantage of es6 classes for example.
You don't know what you're talking about. 
Can you post some code on codepen.io or similar so i can take a look :)
I believe most use es6 with babel and polyphills
always been writing js, switched to es6+babel early on. i like some things in typescript and might use it sometime in the future. i don't think, this is about hype. it is mostly what your team feels comfortable with. languages aren't there for being cool, it's about being productive and writing maintainable code
Small agency. We use whatever is compatible with most browsers. Doesn’t matter the workflow/tools, but when we do Laravel apps, if I’m using Webpack/Laravel Mix I use ES6 which is compiled down to JS/ES5. If it is a Joomla/etc. website, plain Javascript. We have a rather “odd” process (compared to other places I suppose) where we work off a hosted dev server and upload as we go.
Basically any shop using react is also using ES6 and compile to JS. This isnt new as coffeescript also compiled to JS.
There are many ways to do this. You can do css-only using transforms and pseudo selectors to trigger the animation, you can use minimal vanilla JS to hide and show your annotation div, or you could reference jQuery and use something like toggleDiv.
You don't want to learn Java but JavaScript. Besides their name the languages don't have much in common. Like ham and hamster. What you have there is a malformed snippet of HTML markup which describes the content. You need to add JavaScript to handle the functionality. You most likely want that JavaScript to be able to construct that list of regions and the corresponding of countries for each of them from JavaScript data. How you do that depends on whether you want to use a library or not, and which library. Possible choices are e.g. * No library: Write it in plain JavaScript using the [DOM API](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model) built into each browser * A library like jQuery, which you would use to attach JavaScript functionality to already existing HTML markup and attach event handlers etc. * A moder modern JavaScript library like [ReactJs](https://reactjs.org/) where you would write a react component that renders it and handles all the interaction. This is mostly a matter of style and/or philosophy. Strictly speaking the latter two options are kind of overkill for this and more to learn, but then again, you most likely didn't want to learn JavaScript to keep writing such mini-things, but larger apps. 
In my area (Oslo, norway), the standard is es6. You should definitely focus on es6 rather than es5.
This is not my whole HTML, this is the order page of my underdevelopment ‘webshop’ but what can I do here the best? 
There is no one solution that is "best" it depends on your goals and the amount of learning you want to do in the end. 
https://gist.github.com/atif089/25c7b6f43b10fdbab0eb4420001409c8 1. Warning : Untested Code 2. I only spent 10 mins refactoring it for performance, there is a lot more that can be changed.
Yeah, I think a big part of the reason all this stuff became commonplace so (relatively) quickly is that once you introduce a build step for one thing, you might as well make your life exponentially easier by also taking advantage of the multitude of other things a build step allows you to do with little to no effort. Sure, I _could_ write my code in plain ES5 without any sort of build step, but as soon as I start using Webpack, it's a no-brainer for me to also use it to write ESNext instead of ES5, to do linting, to have a dev server with hot reloading...
Yes. We use Typescript in some of our projects. It is largely at the discretion of the developer.
Awesome thanks. I’ll compare it to my original when I’m on my laptop and learn from the changes you made
I use CoffeeScript in all my projects simply because it pisses off all the junior nerds who throw a fit whenever someone makes their own choices.
My company still uses GWT..
Still, you have to admit that's a pretty solid collection of buzzwords :p
I’m really dedicated to learn html/js. But thanks.
Things are being labeled "quantum proof" now? 
Good to hear. Do you have any prior experience with programming? if not you could take a look at [a pure JavaScript course first](https://codeburst.io/best-courses-to-learn-javascript-in-2017-fc3a254638cc) and then advance right to the aforementioned [ReactJs](http://reactjs.org/) to start with a modern JavaScript library that encourages good practices.
There is a LOT of variation in what code is used and managed by companies out there. There are plenty of companies where web is not their main business, or actively maintain what we would call a legacy codebase, or just have very different ideas of what technologies are a good idea. And there are many, many, many companies out there that are doing things a "suboptimal" way. Ancient sites written and maintained in VB and nobody at the company even realizes that VB has a bad rep. Archaic versions of CMSs you never heard of before (perhaps custom) in languages that make you shudder. Sites with no CMS and no admin area, but which are backed by a database, which is either manually updated or is updated with some complex esoteric import script from a CRM that's hundreds of lines long and nobody understands. Sites with both a CMS and an admin area with separate authentication and containing different data. Databases with plain text passwords. And of course the ubiquitous sites that are years behind in the framework and/or CMS. These are all things I have either heard about from other developers, or seen myself. I am 100% certain there are companies out there that don't transpile, bundle, or minify their JavaScript. Maybe the better question is, do you really want to work for them?
Just write like any program, compile, make sure you don't expose anything you shouldn't, make sure it doesn't break anything outside of your library. You basically want to expose a global variable that can be called by anyone using your script. ES6's import/export syntax makes this pretty easy, read up on that and maybe take a look at other libraries and learn from what they do.
TIL. Thanks!
&gt; but on the other hand if you don't usually read formal papers, this one is easy enough to serve as a good exercise to familiarize yourself with the style. I gave up on my Master's Thesis in Polisci to start my programming career to avoid reading/writing papers like this
Promises promise to return things
&gt;My website isn't special by any means, and I'm sure an experienced person could recreate it without any trouble. I just dont like the idea that if someone wanted to, they could scrape all my data in a formatted, all-in-one place way, and do something similar within a few weeks or something. Why would anyone go through all the bother to do that when they can just go to your website and get what they want? This thought pattern is common with inexperienced entrepreneurs too who worry about people stealing ideas. That's not even worth wasting time thinking about. 
Definitely one of the few things I miss from CoffeeScript. Thankfully, we have proposals for it! - Optional chaining: https://github.com/tc39/proposal-optional-chaining - Null coalescing: https://github.com/tc39-transfer/proposal-nullish-coalescing
Well, he did ask it here if that was true, so that's some kind of research at least
Given that the annotations file will grow over time, I'm not keen on opening up all the pages to insert them individually. O take it that means I'm looking at the jQuery method then? 
I wouldn't say it's ridiculous to write on code that you can directly see in the browser. It's a trade-off with many advantages, but you will have to jump through a few more hoops if something is not working.
I’d venture to say it’s more common than not nowadays. 
You don't need a build step for es6. You could bundle/transpile/minify for production only. That being said, if your goal is to speed up development, avoiding awesome tools like JSX and TypeScript in favor of a no-build workflow is not worth it.
While this is very informative code style regarding semicolons makes me ill. Avoid semicolons for some stupid reason, but still needs to put them in front of line. Yuck.
I believe Messenger.com is written in about 50% [ReasonML](https://reasonml.github.io/).
Chrome supports modules natively. There's no module loader though so all the specifiers will need to be absolute or relative paths.
ES6 and JSX for that matter.
If I may offer unsolicited feedback: Look into the data structure that's called a [Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set). Your current implementation, while technically correct and has a O(n) runtime, does a lot of unnecessary work. It also creates a hashmap for each item in the input array, which is pretty inefficient space-wise. Consider this implementation: function findDuplicates(list) { const seen = new Set(); const duplicates = new Set(); for (const item of list) { if (!seen.has(item)) { seen.add(item); } else { duplicates.add(item); } } return Array.from(duplicates); } We basically create 2 sets, a list of items we've seen, and then a list of duplicate items. We traverse the input list once, and for each item we ask if we've seen it or not. If we haven't seen it, we add it to the list of seen items, otherwise it means we've seen it before and it's a duplicate, so we add it to our set of duplicate items. At the end, we convert the set to an array. Adding and checking to see if an item in a set is an O(1) operation (i.e. constant), so it's easier to reason about the runtime of this algorithm.
 It's better to ask who do not use "Compile to JS" language in production? There are a few number of companies and js products who do not use WebPack, Babel, TypeScript. We at FancyGrid (https://fancygrid.com) do not use any "Compile to JS". We use self OOP library. But since trend we will soon port our library to WebPack + ES6 too. To be honest, I do not like ES6, since it is too limited and raw. For me "Compiling to JS" is like "JS on steroids". The one more reasone I do not like "Compiling to JS" - I am with JS for 11+ years and I do not see sense to use limited ES6 syntax about OOP. OOP in ES6 is bad about: defining properties, no way to use mixins. Dynamic modules loading is not good in Babel.
That's fair. To each their own. Personally I do think there's a lot of very interesting things to learn everywhere. I do like _some_ academic papers. Others are often boring. This one is simply not too interesting. On the othet hand, _being able_ to read and understand such a paper is, imho, a good thing.
Depends, I just think things in this field (at the syntax level at least, not the inner workings) move too fast to be bogged down by academia.
https://learn.iota.org/faqs 
Is there a text version anywhere?
A very similar ES5 approach using simple JS objects would be: function findDuplicates(list) { const seen = {}; const duplicates = {}; list.forEach(item =&gt; { if (!seen[item]) { seen[item] = true; } else { duplicates[item] = true; } }); return Object.keys(duplicates); } However this would not work on arrays of numbers since JS keys are strings, so findDuplicates([1,2,3,2]) would return ["2"]. But for strings of names, it would work.
I would also like one!
That is a very good point. I mean, technically if someone wanted to do it, they wouldov done it already. The only reason why I even think about it is because, there are several websites like mine, but mine does what none of them do. One could argue that they wont stray from what their website is popular for, but it's not a guarantee. My only concern is, because those websites are already popular and are already built, I'd imagine if someone wanted to add my feature to theirs, that scraping all my data would make it vastly easier than if they had to do it from scratch still, and might be enough of a reason to do so.
Thank you very much for your response. For some odd reason, I kinda knew this was all true, but needed to read it from someone else to sink in. I really appreciate it.
Cost of living index in Zurich is 36.41% higher than in New York (city). It would be fairly difficult to have a decent lifestyle there with only 100k salary.
This is a nice declarative wrapper around `document.createElement` but it's a long way from being a production ready React-like implementation. Most declarative DOM based library needs to start with this kind of implementation of `h`/`createElement` but almost all real apps need a reconciliation strategy. Try to implement an app that uses an [uncontrolled input](https://reactjs.org/docs/uncontrolled-components.html) and watch what happens when you re-render. You'll be replacing the entire component tree from the root node and there's no state which would allow you to keep `input.value` between updates. Eventually, you'd need to implement a mechanism that would allow you to update based on state changes (or forced updates) and this will require either component local state or subscription to a global store. - [Preact](https://github.com/developit/preact) - [HyperApp](https://github.com/hyperapp/hyperapp) - [HyperDrive (my own implementation)]https://github.com/danprince/hyperdrive) HyperDrive will never be a production ready React alternative, but it is possible to build [simple apps](https://github.com/danprince/hyperdrive/blob/master/examples/examples.js) with it, and more importantly I learned a lot whilst writing it. Like your implementation (and [MorphDom](https://github.com/patrick-steele-idem/morphdom)) I decided not to use a virtual DOM and instead [patch](https://github.com/danprince/hyperdrive/blob/master/hyperdrive.js#L148-L157) directly against real DOM nodes. I'd recommend starting from a really simple patch implementation, then get uncontrolled components working, then let other features start from there.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [danprince/hyperdrive/.../**examples.js** (master → 300cf6f)](https://github.com/danprince/hyperdrive/blob/300cf6f608079f30bc3de71aff52eb74c4882253/examples/examples.js) * [danprince/hyperdrive/.../**hyperdrive.js#L148-L157** (master → 300cf6f)](https://github.com/danprince/hyperdrive/blob/300cf6f608079f30bc3de71aff52eb74c4882253/hyperdrive.js#L148-L157) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
An example that might help: [https://stackoverflow.com/questions/19290407/change-margin-top-on-scroll](https://stackoverflow.com/questions/19290407/change-margin-top-on-scroll)
1) I've been lucky enough to just fall into some really great gigs lately but am currently in the market, interviewing and talking to people. From my perspective ( ~10yrs JS/Web Dev experience ), the market is over-saturated with jr devs which means more mid/senior developers are in much higher demand. If you have been in the game for over 5yrs, you are almost promised a job making middle/upper-middle class income ( US based ). If you have experience leading/mentoring, you are almost guaranteed upper-middle. That income will only go up as you learn more parts of the problem space ( DB design, microservice architecture, etc ) even if you never switch out of javascript. Will at some point we reach critical JS developer status? Maybe but that sounds like after I retire so I'm not worried. What I am worried about is being a _purely_ JS developer. I do not want to tie my income to a single language ( JS ) but instead a platform ( the web ). Learning PHP, Go, Python, etc, even for a single project or toy problem, is the only way to ensure that you will always be employed. 2) I would have a hard time tying JS to Functional Programming in anyone's minds outside of the JS community/recent WebDev world. I love FP, I use it in every project I make, but the people that shit on JS are not shitting on it because JS is in the same category as Haskell in their minds. I would think of the "hate" like the same disdain I have for working in PHP. It's not a bad language, it can actually do a lot of things better than JS ( probably? maybe? ) but god it's so much easier to write my code in JS than it is in PHP because _javascript is what I started with_. I would assume that the "JS is a toy language" feelings are the same but the people that shit on JS are just more vocal about it. 3) Editor: VSCode Transpiler: Babel, Webpack Terminal: Terminus Chrome: Browser 4) Very limited experience with any of those but have had better performance with toy applications with RN than Cordova/Phonegap.
look at https://redom.js.org/
You can use decorators in jscomet (https://www.npmjs.com/package/jscomet) to create mixins, private functions/properties, typed parameters validated in runtime and you can create a library like a browserify to load fast, pre-compile ahead-of-time and be happy, dont have all ES6 features but is useful e fast to build and easier to configure than babel. I just think ES6 syntax is better than ES5 syntax.
You don't need the leading one. Maybe defensive programming? You'd likely never write those two statements together in anything but an article.
The difference between adding a minification as a step in your production pipeline, and swapping your team over to typescript is a bit bigger than you let on.
Thanks for the response! I figured that learning version control would be the best option to begin with. Also opted to pick up courses on Angular 5, Unit testing Angular and an ES6 course to fill in the blanks.
With source maps I can view and debug my TypeScript files right in the browser.
Maybe they just updated it but the article has the entire text below.
They definitely just updated it. I checked an hour or so ago and everything below the SoundCloud link wasn't there before.
With the new twitter limits you can put 16x16 characters with 24 characters to spare. If you use the braille character set, this puts you at 32x64 available pixels. Realizing this, I figured the best use of my saturday was to make tetris. If anyone has any questions, let me know!
I'm a full supporter of learning ES5 first and then moving to ES6 will be easier and make more sense on why these things were implemented and how they are improvements. Interviewers may want you to understand ES5 even if it's an ES6 position since you'll be transpiling the code to ES5.
&gt; Maybe the better question is, do you really want to work for them? Good way to put it.
Don't use MongoDB use a relational database.
I'm currently building a "video-player" that shows the user a video. Except the "video" is not always a simple .mp4 file, but it can be anything... even an HTML file that has `div`s flying around acting like a video. Each "video" needs to have a `play()` function and other basic media functions. So I used TS here to make an interface called `IPlayable`. So yes, I actually use TypeScript to compile my code to JS for the browser. It's very nice. 
I usually don’t complain about sites on mobile but.... yeesh. Weird sidebars that overlap and hide the content? Who decided this was usable?
Yep. We are using GHCJS in production. 
Obfuscation would be good, it would stop the vast majority of code theft, do it with a tool and add some dead code. You won't be losing anything.
Perhaps a bit of a double devils advocate: Why would you use require now that there is a spec for imports? Maybe for dynamic imports? (IDK, I've never had to use them.) But if you can get around that, seems like using the spec would be better?
Indeed
JavaScript is valid TypeScript, but you're correct that if one guy starts adding types here and there it would probably end up being a bad deal. But if you have a guy that wants to de-structure arrays and use Object.assign... Add babel to your build and forget about it.
My point is that you're trivializing the coordination involved (especially in bigger projects) in swapping over to a compile-to language by comparing it to minification. Minification requires no domain-specific knowledge whereas compile-to languages such as typescript do. Most builds don't even add minification in dev, so it's an apples to oranges comparison. Javascript is valid typescript, but typescript isn't valid javascript. I'm not really sure what point you're trying to make. You're completely ignoring considerations that your lead dev/CTO/architect most likely has to think about: total build size, team training, build times, how well a particular package is maintained, how much documentation is available for a package, etc. I get if you're working by yourself, you can do whatever you want. But for larger teams, there are larger considerations than just "throw it in". 
The point I was making is that you could, in theory say "Write a script to change all the .js extensions to .ts - When you update a function, add types to it - If you see any wins by refactoring, do it". You are totally right, I'm not arguing that it is always a good idea. But incrementally using more TypeScript in your codebase is do-able.
This more or less ho it would look like in react: https://codesandbox.io/s/52vlmow6ln import React from 'react' import { render } from 'react-dom' class App extends React.Component { state = { region: 'Europe', regions: { 'Europe': ['Germany', 'Spain'], 'North America': ['Bahamas', 'Haiti'], 'Latin America': ['Brazil', 'Mexico'], }, } setRegion = event =&gt; this.setState({ region: event.target.value }) render() { const { region, regions } = this.state const countries = regions[region] || [] return ( &lt;div&gt; &lt;select onChange={this.setRegion} value={region}&gt; {Object.keys(this.state.regions).map(region =&gt; &lt;option key={region}&gt;{region}&lt;/option&gt;)} &lt;/select&gt; &lt;ul&gt;{countries.map(country =&gt; &lt;li key={country}&gt;{country}&lt;/li&gt;)}&lt;/ul&gt; &lt;/div&gt; ) } } render(&lt;App /&gt;, document.getElementById('root')) As fforw said, you have several options. Some are harder than others, some make more sense in the long term, some you would most likely discard right after learning it. It's a tough decision to make. 
Dynamic imports and no weird file extensions
Can you write this as a node application running locally on the machine rather than a web application?
Thanks! But how do I make it that the countries are selectable?
Like, checkboxes? If html doesn't give you what you need you make your own control or use one that's ready-made. For instance antd's select can select items: https://ant.design/components/select/ &lt;Select mode="multiple" placeholder="Please select" defaultValue={['a10', 'c12']} onChange={handleChange}&gt; {children} &lt;/Select&gt; None of this will make sense though until you choose your path to making apps in javascript. 
I think i'll just embed the listings in the user collection and try and get that working, I haven't made any progress and it's getting v. frustrating. If you wouldn't mind could you take a look at the latest commit and try and see why basic javascript functionality wont work on the listing page? I have two simple scripts, one angular/ one js in there that were just for testing and it's not running. It works on plunker: https://plnkr.co/edit/H6Qpw3No1zaUDNpPfyhI?p=preview 
Not necessarily. You could create one method to relate the annotation to the proper element in an external JavaScript file and then just call that file as link rel import if that makes sense.
If you're using webpack (and probably others) then you can use dynamic imports already. Webpack will do some magic and create additional bundles that will be requested when needed. Here's the docs if you want to read a bit more on it: https://webpack.js.org/guides/code-splitting/#dynamic-imports
Fulltime TypeScript user since the 2.0 release, so I think I’m going on a year now. I use it I conjunction with React to control and capture sensor data to/from a machine built with ROS. I’d never be able to keep up with our development pace or continuously deploy the way I do without TypeScript. I’ll never start a plain JS project again if I can avoid it.
That is very helpful. Thank you. But I would be a bit concerned with tying my actual code to webpack behaviors. I am comfortable with imports from files because it is spec and from node modules because they are not going anywhere any time soon. But who knows what we will be using 5 years from now. I’m fairly new to development but I think this is reasonable right?
Definitely a reasonable position to take (although it is at least _based_ on the spec https://github.com/tc39/proposal-dynamic-import, with a bit of magic sprinkled on top). My team have decided that it's worth the risk, since we're getting enough utility out of it to outweigh the potential headache if things were to change in the future.
Ok thanks. I’ll definitely look into that. :)
According to [this](https://github.com/GoogleChrome/puppeteer/issues/31#issuecomment-324765627), you can access the raw devtools protocol with `page._connection`, and then you'll have access to eg. [resource timings](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-ResourceTiming) (enable request interception, and listen to `Network.responseReceived` events)
Use express with middlewares for authentification
I *think* I know what you're saying, but my JavaScript have is so weak I don't one he to do it. 
Well, those seem to very different paths. For web games, sure, it _should_ clearly be interesting to learn about graphics. For backend not so much.
If you love it, learn it. Cory House has a great talk on being an “outlier developer.” If you have the motivation to learn something unique and relevant to CS, jump at it. The only way you’ll get truly exceptional is if you have a desire that goes beyond trying to meet potential employer expectations. 
So x86 Assembly isn't a language? And just the word "x86" is a language and not a descriptor of a CPU infrastructure? And when you come a new "language" that looks nothing like the original language, that "offers features" that are not going to be supported by the base language for 5-10 or ever, that's a good idea? Take ORMs for instance, the idea is awesome. I can write something that can used for all different databases and think I've done something great. That's until you wonder why it took 5 seconds to do a more complex queries, and you find out the ORM translated what you wanted into 200 lines of spaghetti code that did it in the most ridiculous way. Now for transpiling from ES6 to ES5, that is fine, because support of it will be coming soon enough and it's just a forward progression of the language itself. 
You probably don't need three JS for what you want to do, but it's still fun to tinker with and I'm learning more than when I tried to go the C++/OpenGL route (probably because the tutorials are written without the assumption that you've mastered C++).
Of all the advice given, nothing is _particular to JavaScript_. That, of course, does not make the advice bad in any way, but then again, does it provide any particular value to focus it on JavaScript? I mean, does adding "with JavaScript" to the title make the content any different from the original? Or maybe I don't understand the intention of this. No explanation about intention was given, though, so...
Thanks for the comment, It's simply because the examples are in JavaScript and developers who use the language would be more inclined to watch it if it's in the title in my opinion. I could be wrong.
JavaScript isn't just about the DOM API, if it were, then it would be OK and I would be "Abstract Away". If we are talking ES(Whatever) going back to down to the more supported version of ES, that fine, because ES(Whatever) will be supported soon enough. But if you have an abstraction which is so insane, which changes the way your write code, say, someone doesn't like the way JS is written, and decides that it should look like COBAL and support stuff from FORTRAN, that's where the problems creep up. 
Abstractions can be good and can be bad. In some previous comments I made: "_But if you have an abstraction which is so insane, which changes the way your write code, say, someone doesn't like the way JS is written and decides that it should look like COBAL and support stuff from FORTRAN, that's where the problems creep up._" "_Take ORMs for instance, the idea is awesome. I can write something that can used for all different databases and think I've done something great. That's until you wonder why it took 5 seconds to do a more complex queries, and you find out the ORM translated what you wanted into 200 lines of spaghetti code that did it in the most ridiculous way._" I have no problem with transpiling ES(whatever) to ES(whatever is fully supported at that time), my problem has been with the abstractions that have gone off the far end that offer "support" for feature that won't be made available anytime in the near future or at all. So the abstraction gives you a false sense of "I'm doing good programming because I have this feature!", but in all sense, you don't. 
Babel only polyfills stuff for you that went through apl the stages and will end up in the language. Its not transforming the language in any way. Typescript is another case. But even typescript only adds stuff to the language it doesn't alter anything.
Babel only polyfills stuff for you that went through apl the stages and will end up in the language. Its not transforming the language in any way. Typescript is another case. But even typescript only adds stuff to the language it doesn't alter anything.
&gt;2. You have backend devs who knows X and it would make sense to use X on the frontend so a product could be developed faster In my experience the opposite makes more sense. Backend logic is now far less, compared to what is needed on the frontend. So if you are going for shared language across the two it would make more sense to accommodate the needs of the larger code base.
never knew you can just add primitives to sets thats pretty cool. what would be the space complexity of your implementation?
We use TS for several of our production projects, both for front and back end code.
I've specialised in web graphics for a few years ago. My answer is a mixed one. Graphics and visualisation work is probably the best sort front-end development has to offer. It's highly focused on performance, you get to solve lots of novel technical problems, you don't write CRUD apps all day and it's a domain where the design drives the technology and the technology drives the design. I'd never choose an ordinary webdev job over a graphics role. However, dedicated roles are very rare. Even when I've been writing webVR apps, about 50% of my time has been spent on non-graphics code, either React-based 2D UIs or Node/Express backends. "Visualisation developer" is a job that might exist in the large cities but is very niche. Given your circumstances, I think you'd be better off investing in backend tech. There are more opportunities for Node and Python developers, and learning something other than JS gives you routes into different development fields. I'm sorry to be such a downer here. At my current gig, the opportunities to do 3D are drying up, and I'm faced with the choice of either retreating into standard-issue React/Redux development (which has never been an interest) or moving into project management. I'll probably be doing the latter.
I think you could chain a map to the return value: Object.keys(duplicates) .map(x =&gt; typeof x === 'string' ? parseInt(x) : x) I prefer your Set implementation though.. very clean.
Correct, while things that will become part of the native language is OK and doesn't try to make the base language into something not recognizable. It's the stuff I've seen in the past, thinking of things I've seen in the past 10 years, and not just in JS, that tried to transform the language to look nothing like the base language and offer features that would never make it in to the base language, so the features never really "worked" they they should have. I don't have any examples I can think off of the top of my head. Maybe I've been jaded from previous experiences. 
I'm not the one you're responding to, but that is a really good point that I don't think of much. Say I have a function that is 200 bytes in ES5. I can write the same function in ES6 with 50 characters - but after babel / babel-polyfill gets through with it I might have 500 bytes going through the pipe. Something to think about for sure. Usually I think that readability for the programmer trumps almost everything, but that isn't always the case.
O(n) space, O(n) time
amazing
like this: https://imgur.com/a/JR8tV
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/kgTWdRd.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dpq42md) 
I'm all for conversation! Yeah, it's one of those things of you have to weigh your options. But if you are using ES6 for features that will end benefiting the project sooner than later, that extra 300 bytes might be OK, since the translation can not be a translation soon enough. Of course, those 300 extra bytes might end up costing 20% more memory usage or CPU usage, but if your app is only using 1K of RAM (Wouldn't that be nice!), 20% or 200 bytes more, might not be a big deal on modern machine. Of course, if that is just one place you are measuring and have say 100 places where you add 300 more bytes each time, that's 30KB extra someone has to download and instead of 20% you now have 2000% more RAM usage, that's 20KB more of RAM usage. Still a small number for modern machines. Of course, I've see where smaller code doesn't equal more efficient code. "I can do this is 5 lines, instead of 20, so it's more efficient!" isn't a way to think, specially if you haven't tested it. That 5 lines might be 10x slower. Of course the first computer I had only had a 3.25 Mhz Z80A CPU and 2KB of RAM, so growing up I would get to see people fight for the title of most efficient code by putting out demos. There's a lot of ways of doing the fire/flame effect in ASM. Slow communication devices and small storage devices also forced people to think about those things.
Visual Studio Code
I love JavaScript and I use vscode. Very useful and has a built in console etc 
I definitely agree. I didn't mean to say that all your learning should be done via books and then you're on par with the best devs out there. Of course making some projects is necessary to the learning process. I just meant that before diving into an involved project and learning as you go, reading a book will make it much easier and result in fewer posts to stackoverflow. That's just my preference and it has worked well for me, but everyone learns differently. 
 func = a =&gt; b =&gt; a + b is a function that, when called, will return another function. func = (a, b) =&gt; a + b is a function that, when called, will return the value `a + b` The first `func` (`a =&gt; b =&gt; a + b`) is the `curried` or `partially applied` version of `(a, b) =&gt; a + b` but they are not the same function. 
You need to add the _id of the instance you want to reference as a property of the instance of the other collection. Then you can load that reference by calling the populate method with the name of the property. For example: User.findOne({}).populate(‘posts’)
If it's done correctly, it is a question of just throwing it in. The build and Dev scripts will still work as they did before, but simply adding an extra - invisible - step. Keep using ES5 code if you want, or write ES6 - now you have the choice. Nothing breaks, and you can now use more advanced features.
I can't for the life of me figure out how to collapse functions. Usually there's a little + or - button next to them to fold them up, hmm
Definitely VS Code (long Sublime3 user here). Atom is a bit heavy, especially for my machine - but yea i used it for around 6 months or so. Actually I really don't like the IDE behavior of VSCode... all these popups and hover things, nah.
I'm already feeling that way about VSCode a little bit. I don't need all of these components and features, almost thinking of doing Notepad++. I do like VSCode a lot overall though.
Thanks you, this really clears things up for me. Not heard of curried functions before.
Probably yes. The whole problem is in Webpack and for me the only feature that leads it currently to the top is the code splitting, and nothing more. Tree shaking originally comes from Rollup and there it is the best.
&gt; Network.responseReceived thanks for your quick answer @lennoff I was able to access a `Network.responseReceived` function as such: `page._client._events['Network.responseReceived']({requestID})` however, this only let's me check if a response with a certain ID has been received (I assume) - but I don't know the specific requestIDs and I would prefer to see all `responseReceived` events. Would this be possible as well?
I'm confused. You're having an audio play and you want the underline to move with it? Like [this](https://i.imgur.com/fmZuK18.png)?
`self` is window. Any element with an id is placed on window. Probably not the best idea to do this. 
i didn't try it, but you should be able to listen to events with `page._client.on('Network.responseReceived', event =&gt; ...)` (where the `event` should have a `response` property)
take notes from vue... Kappa
&gt; page._client.on('Network.responseReceived', event =&gt; ...) works like a charm. Thank you very much
there's no such thing as wasting time , specially when learning something as cool as three.js also, you will find the core concepts in three.js in lots of other libraries, so you are not just learning three.js if you are seduced by the idea of programming a videogame, those concepts will be very handy 
You've extra ) after **on('message'** Removing should fix the issue.
With the allowJs flag renaming all the files to *.ts isn't even required anymore.
Show your love of js and how it is useful to a prospective employer
Yes, I tried so many times to not do the graphics and learn other things but.. truth is i keep coming back to the graphics and im also learning more advanced mathematics too. I good with web dev and js but i dont feel like learning all these new js frame works is exciting.
Remove the first ')' on line 4. Remove line 5. Use an editor (like VS Code) which can format your code.
but what do employers want ? whats the bread and butter of a JS dev ? Im writing some pieces now, a nice website - a killer and super clean tetris implementation in JS -but what do employers want ? 
A simple full-stack website using React and a database, with source on GitHub and linked on your resume.
They mainly care about your ability to bring value to the company. This means working well with others, aligning with their culture and what you can teach others. Your coding ability in JS in whatever latest and greatest stack is just a checkbox to get an interview. Look at js job postings, make sure you can hit their checkboxes so you can get pass HR. Then show you can bring value to the company and it’s a no brainer to hire. In terms of what is hot right now, React front end with node backend is really hot right now. Also use emotion for css
Line 3 - use `window.location.search.substr(1)` instead of replace. It's always going to be the first character you take off. Another option might be `/=/.test(winow.location.search)` because you don't actually do anything with the values. Line 46 - unused local variable `$this` Line 76 - `$this.toggleClass('open').removeClass('open')` If the goal is to always remove `open` you could drop `toggleClass`. General thoughts: - declare some vars initially for `isMobile`, `isTablet`, and `isDesktop` - re-calculate on window resize / orientation change. - it might make sense to define "what is happening" as functions, i.e. "open section", "close section", "move to section", "reset" - and the click handlers would simply call these functions. this might make it easier to follow / maintain later, but YMMV. - as /u/webdevop did in his refactor - if you are using the same elements resulting from a jQuery selector, you can perform the selection once, store it in a var -- effectively caching them.
Ive not looked at any libraries yet.... react is one to look at then... there are many - obviously jquery is another. what they do, Im not sure.
Ok great thanks for the answer 
vscode for the win! Don't get confused by its name vscode is completely separate then the main visual studio lineup(Although its still Microsoft Project). It is developed separately by open-source community and Microsoft team, Its very light and customizable. It is way lightweight then Atom and as fast as Sub-Lime and best thing is its absolutely free and filled with rich extensions! 
TIL: me and Pete Hunt learned JS as the same time. Holy crap that guy is awesome. Very talented guy.
There are online courses on frontend webdev you should consider doing. There's quite a lot to learn.
Hey! Thanks for the response. What I have at the moment doesn't have a reference but what I was trying before included mapping out the schema using mongoose in the same location the models are in now still. At this point I thought that mongoose would handle the objectID reference itself and that would be ok, but that didn't work for me. I also tried various methods of passing the reference in a hidden text box but I'm also having errors with JavaScript not running on my pages. Basically, my questions are: Do you need to use mongoose for the DB connection if you want to use mongoose for the schema? Do I need to make changes to the form submission? Do I need to make changes to the addListing services etc to do the object reference? Any insight would be great
Would you recommend any examples?
Practice writing JavaScript. Nothing else really matters. What passes for competence wildly depends on who is interviewing you. Here are some things to keep in mind from my own personal experience: * A lack of formal education will not prevent you from getting a really good programming job. * Ignorance of popular frameworks will not prevent you from getting a job if you are strong in the language. * Addiction to jQuery sends mixed signals to an interviewer. It is generally viewed as a weakness, but they may not care if you are strong in code architecture or other web technologies. Personally, I don't like jQuery and this never stopped me from getting a job back when jQuery was a universally mandated religious cult. * A preference for writing to the DOM with the standard vanilla methods is generally greeted favorably but also with both confusion. If this is how you code then you are generally considered substantially stronger than other candidates who cannot understand this code, but it opens serious reservations about your ability to adapt to trendy abstractions. * If you have an application that has been downloaded more than 5 million times the nature of the interview quickly changes to more interesting subjects. --- Bottom line: * Practice, practice, practice. This is the one true differentiation between competent and incompetent applicants. * Don't bullshit. Don't spin your wheels. Don't make crap up. Deception is obvious. Be clear and direct with what you know. * To take the previous point to the next level don't think hiding your ignorance behind layers of abstractions will save you. You are still incompetent. Just be honest and up front about it. Again, people can tell when you are bullshitting. To tell it another way the honest, but incompetent, candidate next to you is far more likely to get the job if you are challenged by honesty. --- Basic expectations (if you are not confident with the following don't apply for the job yet): * Understand what the DOM is, at least in theory. This is the backbone of everything in the browser. * Understand synchronous versus asynchronous tasks * Understand scope * Understand events --- Advanced expectations: * Accessibility * Security * Performance * Documentation * Marketing experiments (A/B, Multivariate, analytics) * Architecture
Passport.js and an accompanying strategy is a solid bet. 
I'm a VR web developer, use this every day. If you like 3d graphics tech, go for it!
&gt;react is one to look at then... there are many - obviously jquery is another. what they do, Im not sure. Well, you're *far* from ready to write good Javascript on a daily basis. However, you should just apply, and try to get a "junior" dev job anyway, since you have other programming experience. Depending on what you currently do for a living, the salary might be a step down, but if you're serious about a career in software development it's a worthwhile sacrifice. I learned JS long ago so I can't sing the praises of any one course for learning from scratch. However it's hard to hire JS devs in my area, so at my last company we pretty much gave up on that, and resigned ourselves to training up others on JS (we were using vanilla ES5, so in some sense the bar was even higher), and I ultimately found a course on...Udemy? Udacity?...something like that....which covered important topics in understanding the core language (prototypal inheritance, closure, FP, hoisting, function vs block scope, all that). I've also used Pluralsight for other learning purposes, and in general the quality is high (but it's pricey at $30/mo) The hot library changes every few years. Over the long term, knowing the language well is more important. Over the short, "get a job right now" term, screw around with React or Angular. If you learn Angular now and put that on your resume, people will probably want you for maintenance of Angular apps. If you learn React or Vue you'll attract companies more on the bleeding edge, but there will be far fewer of them (recruiters in my area haven't even heard of Vue - and they sift through hundreds of applicants!)
&gt; ...what they do, Im not sure. You've been programming your entire life but you can't tell what jQuery or React does by simply viewing their respective websites, ie it should take you 5 mins to tell what they do. Kind of a red flag imo.
Situation many here describe is the same in Australia. There are lots of guys who can write selectors for UX, basic form logic and tweak Wordpress front end in jQuery. A sieve yields a whole lot less who have actual industry experience in Angular / React / Vue, many of whom claim to be "full stack" despite knowing nothing much more than how to write gulp tasks and a smattering of limited of NoSQL. There are a load more who can write C# or .Net and it's not hard filling those roles. Finding someone who can actually come up with solutions, and solve problems, AND write Vanilla OR framework JS while knowing what's happening on the backend beyond API calls, is still a challenge. 
need to see your validator function. and why do you have spaces around your = signs?
&gt; Babel only polyfills stuff for you that went through all the stages and will end up in the language Incorrect. When you use Babel, you pick your own preset(s). If you've been using e.g. React you've probably been using Stage 2 or Stage 3 features for a long time. Stage 2 is a pretty common choice. The beloved async/await didn't become official until ES2017 (ES8, if versions were still numbered) yet it's been popular for a few years. Another example is decorators. Some people love them, especially Python and C# people, but they're only Stage 2 and may never become "real" Javascript. Only Stage 4 are practically guaranteed. That's out of 5 stages, 0-4.
You can try [DeepScan](https://deepscan.io/home/). It focuses on finding runtime errors and code quality issues rather than coding style. For example, it finds an issues in the following code about the logical values of conditionals: function foo(x) { if (x &gt; 10) { return x - 10; } else if (x &gt; 20) { // Condition 'x &gt; 20' is always false at this point because it conflicts with previous condition 'x &gt; 10' at line 2. return x - 20; } else { return x; } }
You should post the code and not take photos of it, lol. I'd suggest not using regex to sanitize user input. 
My laptop can't get online right now. All I have is my phone, it is terrible I know. That's how desperate I am right now, lol. Thanks - will look into that
Well if it makes you feel any better, I'm in desperate need of a three.js and have had to figure it out on my own! There is always demand for niche things
Recommend any place to find obj files? Specifically a coffee mug, art canvas, birthday cards -- screen printing stuff for a rendering engine?
Saving for later 
GetElementById returns the dom node, not the value of the input. Value should be a key on the dom node object. Compare the value and not the node and see what happens 😊
A couple things! Firstly, your first if block. You are just checking if the dom node exists. You need to check if the nodes value Is equal to '', otherwise this will not work properly. Secondly, your ! Operator is in the wrong place! The ! Always comes first. So it should be if(!node.value.match(letters)) 
Your regular expression is "/[blahblah]/", but regular expressions in JavaScript are not supposed to be strings. / is instead the special character.
Essentially, yes! I want a reader using the audio to have a visual cue to help them follow along with the text, and I figured an underline would be the simplest way to do so that doesn't interfere with a person's ability to read quickly.
I’ve been migrating a large codebase from CoffeeScript to ES6 for about s year and a half. 
You won't need to be the javascript file in a &lt;script&gt; tag as it's already a JS file. Also In your first check you are checking the DOM element being an empty string, not it's value (fName.value == ""). Your regex expression shouldn't have the quotes around it as it's not a string and the NOT (!) should be at the start. It's generally better to have the form action handle the function invocation &lt;form action="javascript:validator()"&gt; but not actually necessary. 
thank you!
thank you!
I've checked out the usual places and don't see models for those anywhere
If you were to try and convince your boss to convert your existing JavaScript code to TypeScript, how would you do it. Like, how would it benefit business and not just your life as a programmer? Our JavaScript code is pretty messy. Past programmers have tried use it like a traditional OO language (Java for example) but it just feels like a mess of anti-patterns. I would prefer we used something like TypeScript but I would probably have a hard time convincing my boss (or even the other developers for that matter) why I would be worth it.
babel yes, the rest: meh
Is there a tool you'd recommend?
I wrote a Redux alternative. I felt like there was room for someone between no state management and Redux. It’s called Politic. https://www.npmjs.com/package/politic
Have you seen https://www.codetriage.com/ ?
Ok that was some inspirational shit. Thank you. 
I think what you've done here is nice. As someone's already pointed out, there's already a site that offers similar features. One thing that could be interesting to pursue is how to identify those projects that are high-quality, collaboration-open projects. It's quite easy to place a label on something. But if you can identify (for instance) a pattern of replying to issues and incorporating input from lots of people, that could be useful. A lot of this so far has been done anecdotally: "So and so told me that this project actually cares about collaboration." Also, some collaboration-serious projects will have documents in them that describe how to contribute. You could automatically star those, etc.
yea! really cool project. another similar project is up-for-grabs.net i think curated lists are valuable. with github-help-wanted.com i'd like to hook the user directly up to the gh community. whether that creates a positive or negative ux is tbd.
hey, this is great feedback. i agree, it would be interesting to gather some more sophisticated heuristics for identifying relevant projects. the first-pass implementation is limited to the types of queries that github exposes via https://api.github.com/search/issues. atm, i'm hooking up directly to their api. i don't have any service running to aggregate relevant projects. 
This uses QJS, Quantum Javascript.
Try the excellent https://github.com/librariesio/libraries.io
And also https://libraries.io/experiments/bus-factor
[removed]
There's a couple ways I can think to do this. One is to find a data source with timing about when each word starts. Good luck with that, especially for any arbitrary song. The other is to somehow parse the sound as it's played and determine when a new syllable/word starts, and go through the song that way. This would be a difficult project for me, personally, but I would look into either APIs for this kind of data, or tools for analyzing sound files.
I hate graphics and my job is mainly creating frameworks and inner workings of web apps so I don't do it much. That said I started playing with canvas recently in my spare time (simple games), and while I still hate graphics, I've noticed it's thrown a few challenges at me that I wouldn't have encountered with the stuff I usually do and had to think a bit differently, always value in that.
Thank you that’s awesome. I will have a go refactoring to inc functions and vars :) 
Use an inline breakpoint?
The quality of the video does not match the thumbnail.
There is a generic provider implementation in recompose package. Among other numerous goodies 
Could you elaborate on your experience with ClojureScript? I'm intrigued to try it. Thank you
It hurts my eyes as well
Use a debugger instead of console.log? 
Formatting help: Indent code by 4 spaces each line **and leave an empty line before and after the block**: This: Blablabla... This won't be shown as code Blablabla. produces: Blablabla... This won't be shown as code Blablabla. While this: Blablabla... This will be formatted as code Blablabla. produces: Blablabla... This will be formatted as code Blablabla. 
That's a better idea. You don't need to modify the code each time. Actually, what I do is use conditional breakpoints that simply log but don't stop execution. I don't usually _debug-by-logging_, but sometimes, if I do want a log trace of some execution, this is what I do.
| But as i said below, babel 7 can read typescript, so typescript can now finally be used for what it's been made without interfering. This is a game changer for me, I admit that the only reason I have not yet switched to TypeScript, or even attempted it in any capacity, is that I don't want to have to make changes to my build configuration. I'm already happy with Babel and I don't want to have to run my code through the TS compiler and then Babel.
How does this compare with mobx?
Thank you, I fixed it now.
Heads up: your site functionality is disabled by [Privacy Badger](https://www.eff.org/privacybadger). I submitted an error report, but I have no idea how responsive that team or product is.
[I wrote a checklist](http://blog.jakoblind.no/checklist-for-reviewing-your-own-react-code/) that I use when reviewing my own code. It's not as good as getting feeeback from other people, but it can give you something to think on anyway! 
Console.log returns undefined. So you can trick the fat arrow author return with an or statement. const add = (aa,bb) =&gt; console.log(aa,bb) || aa + bb;
As an alternative... // In your debugging utils... const log = (x) =&gt; { console.log(x); return x; }; const spy = (f) =&gt; compose(log, f, log); // with a suitable compose implementation // When you want to spy on a function for tracing purposes... // const mu = (d) =&gt; [foo(d), bar(d)]; const mu = spy((d) =&gt; [foo(d), bar(d)]); 
[Read this](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration).
Great site, would definitely browse through it some day :) Btw the site's design might be too similar to the official Github site, that might cause issues. 
[removed]
We have currently 5 apps in production running together. The total size is over 50k LOC. Almost all of them are reusing parts of legacy JavaScript apps that we have. ClojureScript apps are depending on JavaScript libraries such as React, ReactVirtualized and moment.js, which means interop with JS is quite good. We have 3 front-end devs (including HTML/CSS devs) working full time with ClojureScript and backend (Clojure) ones who also participate in client-side development from time to time.
It seems very slow to load?
 const log = x =&gt; (console.log(x), x); 
Not sure what you mean? 
Yes, but sometimes you need to see how the value changes during execution or you can't block (e.g. mouse events).
There's a typo, you spelled "languages" wrong just above the dropdown 
&gt; wouldnt they still be able to just download my JSON/JS files and look through it to find all the data If you compute things server-side and send results to the browser, users and scrappers will have access to that data. If you send raw input data and compute in the browser, users will have access to the formulas in js and to raw data. Even if you didnt care about your code/data, you should not compute big things in the browser each time for each user, its good practice to precompute commonly used results on server.
Oh, is it me or nobody uses comma operator?
Hi /u/amdsouza92, it looks like you're new to /r/javascript, welcome! Thanks for the submissions, but please make sure you read our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `medium.com` and your own blog/posts all the time. We don't mind a bit of self-promotion, but as for now, you're going to be flagged as spamming. If you want to participate in the sub, go ahead, but don't spam. Thanks for your consideration!
I like your spy function.
This is really clever.
The thumbnail is nice, but your video starts without any introduction, the sound quality is bad and you are doing a lot of mumbling.
I'm not the author, was just curious why you thought video was bad. Thanks for the reply.
You have typo in documentation: `Subjcet`
Could you elaborate more on how subjects are connected with the rest of store? It seems interesting, I see that there are interesting ideas (something between Mobx and Redux I see) but there is some mental overhead which I don't see through immediately (some visual diagram would be nice). Nevertheless seems interesting. It reminds me of my own project Vistate (which I don't actively develop *right now*, maybe I will come back to this: https://github.com/hex13/enter-ghost/tree/master/packages/vistate ). &gt; ideas appreciated. what about hierarchy of models? Most of state management libraries (including yours I see) doesn't seem to have first class support for deep nested states (this was one of problems I wanted to adress with Vistate).
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [hex13/enter-ghost/.../**vistate** (master → 47cff62)](https://github.com/hex13/enter-ghost/tree/47cff62509c5eead2bfa237b0d38344f05a7472d/packages/vistate) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dpr0qio.)^.
So check out (this one)[http://www.npmjs/package/silhouette-core] for another take. Maybe look into middleware integration? 
You can do this: const mu = (d =&gt; [foo(d), bar(d)]) const mu = (d =&gt; (console.log(d, foo(d), bar(d)), [foo(d), bar(d)]))
No worries - thanks for the feedback! Happy to let you know it's on the roadmap :-)
Yes, but there are multiple calls to foo and bar, which you don’t want.
How do you do conditional break points?
$(document).ready(function(){ $(window).on('resize scroll', function(){ var scroll = $(window).scrollTop(); if (scroll &gt; 200 &amp;&amp; $(window).width() &lt; 960 ) { $(".bg-test").css("background" , "#000");} else{ $(".bg-test").css("background" , "transparent");} }); }); Not sure if this is how you wanted to merge them.
Sorry, it wasn't my article, so I couldn't change the font)) But seems like the author fixed it himself
I find myself a little overwhelmed. 133k items? Where do I even start? A lot of the requests look like crap, too. Would be nice to guide people a little better in terms of what to search for, popular requests, etc. 
Yes, something like this. But I should try to explain better... I want the color to show on screen sizes under 960px, but not on screen sizes over 960px, until you scroll down 200px from the top. I don't know if you understood what I meant, but let me know and I'll try to explain again.
What if you do projatt['KPI - Structural Design']++; Maybe the content of `projatt['KPI - Structural Design']` is a string, not an Number. It can be detected quite easily when strings contents are concatenated instead of calculated. Exemple: if `projatt['KPI - Structural Design']` contains the string "3", result will be "3" + 1 : "31" and not 4.
&gt; Does anyone have a better method of replacing "../" with javascript. I have use "php-magic-linking" If you're using PHP (not JS) on the server-side, you should fix the issue there. Sending invalid markup to the front-end and then (presumably) running JS on the client-side to fix it is a hideous, fragile abortion of a solution.
It’s simpler? Also, it does less automatically. For instance, no React component wrapping. If you want a react component to update, then you’ll need to setState or rerender it in a Store subscription. This is intentional because: 1) Simplicity - I believe there is such a thing as too much help. In this case, the core competency is state management. Anything beyond that needs to be another layer on top of it. Also visibility. My development experience has shown me that less typing should not always be the goal. When you add helpers which eliminate some typing, you are also a) making assumptions about what your consumer wants, and b) making it harder for someone unfamiliar with your library to see how things are happening. 2) Independence - It’s not tied to react. Not even by helpers which you could just not use if you’re not using react.
 structural(+1) What is that? Javascript doesn't have these syntax. Where is your projatt definition? And OP should learn lisp or anything that have syntax like this: (+ 1 structural) What a precious natural gift.
Mmm... So... Place a break-point somewhere you want. Then, _right click_ on the break-point marker and you'll get a menu with the option to make it conditional. It pops up a mini-dialog to set the condition. For tracing it is sufficient to just `console.log(...)` any variable that is in scope at that point. As `console.log` returns `undefined` which is _falsy_, it will execute it, but it won't stop. You can also create the break-point directly as conditional, as seen in this [video in MDN](https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_to/Set_a_conditional_breakpoint). In Chrome is [pretty similar](http://blittle.github.io/chrome-dev-tools/sources/conditional-breakpoints.html).
I do not see it as a problem just to debug. Except that foo and bar are one of those functions that changes states of the application. But if is a pure function, there's no problem.
&gt; projatt['KPI - Structural Design']++; Okay so i did: var structural = projatt['KPI - Structural Design']++; structural = structural(+1); It gives me a warning that in line 2 a variable (structural) is leaking? is still get the error: "[No Documents] org.mozilla.javascript.ecmaError: ReferenceError: "projatt" is not defined. (#1)"
I’ll take a look.
Thanks!
Where the variable `projatt` is defined ? What initial value contains `projatt['KPI - Structural Design']` ? As said by @nikaone `structural(+1)` is not a valid syntax. I think what you want is `structural = structural +1;`.
Hi /u/LinusVallinder, For javascript help, please visit /r/LearnJavascript. Thank you!
I considered hierarchies, but felt it was simpler for a lot of reasons to not go there. Instead I went with allowing multiple stores (as opposed to redux) which can limit the observed scope. Subjects are simple stateless observables/events. They are included so that updating a store can be made declarative. E.g. If I pass the store around everywhere and call specific actions on it (imperative), then later decide I want to use two store or change the actions of my store, I have to go refactor everything. But if I pass signals around, now I just have to rewire the signal to the store, without most of my code being affected.
 const repeat = n =&gt; action =&gt; { for (let i = n; i&gt; 0; i--) { action(n) } } const sixDo = repeat(6) sixDo((n) =&gt; { Arm.grab() Arm.moveRight() Arm.drop() Arm.moveLeft() console.log('repeated times: ', n) }) Any times you want , just make a new function with: const nineDo = repeat(9)
I would recommend taking a look at JetBrains's JavaScript IDE. If you've got a school or collage email, it's free.
I did try the correct form i was playing around based on example code from the systems support forum which used that format (probably for something completely different.)
Thanks. So silhouette is a state manager abstraction? I like the idea, but it’s mostly the responsibility of the abstraction to figure out the lowest common denominator and create the implementation glue. I’m open to adding extension points or hooks as long as they don’t break the core concepts.
thanks :)
So the projatt is calling a blank field on the page all i am trying to do is populate it. Again completely new and basing the above on what the software's KB states. [link](https://wiki.esko.com/pages/viewpage.action?pageId=87200362)
The OP doesn't even understand basic loops, and you're advising him to write complex higher-level functions that instantiate the *concept* of "looping N times" as a noun? I honestly can't think of a way to make this more unnecessarily overcomplicated aside from telling him to use a recursive solution.
$(window).on('load resize scroll', function(){ var scroll = $(window).scrollTop(); if (scroll &lt; 200 &amp;&amp; $(window).width() &lt; 960 ) { $("body").css("background" , "#000");} else{ $("body").css("background" , "transparent"); } }); I just removed document ready and instead added load to the on method. Also changed scroll &gt; 200 to scroll &lt; 200. This will give you the black color only on screen sizes under 960px and until scroll is under 200px. When scroll is 200 or over it will turn transparent. 
I don't know your development environment. But based on the documentation page of the link above, projatt is defined with some kind of project attribute. Si it seems there is a mistake with the key `'KPI - Structural Design'`. Are you sure it is correct ?
I'm struggling to see what this buys me over redux and the various connector libraries.
If politic is based on encapsulation and oo, silhouette is built on composition and fp. As far as I can tell, they're not terribly different as far as problem domain is concerned? And I only bring up middleware because my experience with silhouette has mostly been that people don't care much until I mention that it works with redux devtools
Yeah, you are right, but maybe he likes it, and digg into the fun parts of JS. 
I think their domains are a perfect match ☺️. Also, I’m not sure why you say oo? Encapsulation yes, but also fp and composition.
Coffee? Hehe, but seriously, maybe nothing. I wanted something an order of magnitude simpler than Redux, it didn’t seem to exist, so I wrote it. Redux is arguably more powerful, but I didn’t need a light saber, I needed a screw driver.
No, console isn't available. Looking into it my original syntax of: projatt['KPI'] = projatt['KPI'] +1 Is working just not in the area of the software i want it it. The "'KPI - Structural Design'" got reduced to "KPI" in case the spaces were bugging the system out.
Been there done that. The build is still failing according to the github badge. This project needs some maintainers before I set foot near it again.
Almost there. I want the window on the screen size under 960px to always have the background color. Changing it back to &gt; 200 fixes that, but I want the background color to come in on sizes above 960px after you have scrolled down 200px. Basically, just need to get a fix for larger screen sizes. Also thanks for explaining what you have done.
In the documentation you linked above it is written "projatt is read only." It seems you have to modify another variable. I fear i could not help you more because your problem seems more related to `WebCenter 14` environment which i don't know than pure Javascript. Maybe you'll get more help through the support of `webcenter 14` directly (maybe they have a forum or help board something like that).
Try changing the &amp;&amp; in the if statement to ||
You can make a little reusable helper utility for this: const logged = (fn) =&gt; function (...args) { const result = fn.apply(this, args); console.log(`(${args.join(", ")}) =&gt; ${result}`); return result; }; Then you can use it like: const fn = logged(x =&gt; [timesTwo(x), plusThree(x)]); fn(5); // Logs (5) =&gt; 10,8
I do, so I'll check it out!
Nothing is being returned in your `random` function. So the comparison is `x+= undefined`, which results in `NaN` aka Not a number. Add `return` before `Math.floor` 
It does have Segment behind it but could use with more people I recon
Yeah, a few things here: 1. You're missing a closing brace in the end (`}`) 2. You're repeating yourself 3. Your variables have typos (coinrannum vs. coinramnum) 4. Don't ever use document.write, please. It's dangerous and frowned upon. 5. If `coinrannum` is 5000, you won't get any output. 6. I don't understand why you're doing `Math.random() * (10000 - 1 + 1)`, this is the same as `Math.random() * 10000` as far as my knowledge in math is current. Here's a "fixed" version: ```javascript function randomnum(){ var coinrannum = document.getElementById("coinwager").innerHTML = Math.floor(Math.random() * 10000) + 1; var coinoutcome = coinrannum &lt; 5000 ? 1 : 2; document.body.innerHTML += '&lt;br&gt;' + coinoutcome; } ```
Nope, nothing changed. Everything seems to be the same as with &amp;&amp;
Adding to the comment already given, I'd suggest you go to r/LearnJavascript for this type of question.
Thank you! That's really helpful. When I get back, I'll implement your fixes and I'll let you know :)
100 - 1 + 1 ?!?!?
r/LearnJavascript
Put everything inside a for-loop. https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Statements/for
Hi /u/leontas2007, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/Easten_Analogue, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/OnlyDrey, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/tim641, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/loveiscloser, For javascript help, please visit /r/LearnJavascript. Thank you!
No, I'm not aware of anything else that seems to offer as much as Realm in terms of features. 
Sure thing. You're probably a bit new to this so do ask follow-up questions if you can't understand my code.
Okay, my bad. Feel free to close this thread of you want.
That's weird it works for me. On bigger than 960px i only get the black color if i scroll down 200px and on smaller than 960px i always have the black color. I did it on jsfiddle you can take a look. [example](https://jsfiddle.net/fdgj4g3q/)
First feedback I have is: show some text when JS is disabled. Always better than a blank page ;) Other than that it looks sleek, congrats!
Install material theme in intellij idea and remove status bars from views. For sure it'll be cleanest and most feature rich
Why not just have console.log(d, mu); after the line?
Found the issue, there was an API i had to load... i may have misspelt the name.
Great. i'm glad you found by yourself.
Lol
Even as succinct as you made this, it's outrageous how much scaffolding is required to get a "modern JS" based web app operational. 
I feel as though you're missing some fundamentals that are really important to what you want to do. Try plowing through some tutorials on event listeners and it might make more sense.
You can use `console.trace` to print the output of your function const mu = (d =&gt; { console.log(d); return [foo(d), bar(d)]; }); console.trace(mu); mu('a'); // print 'a' and then the [result of foo, result of bar]
good point. i'm probably breaking some rules by using github's likeness. the site is hosted on github-pages, so hopefully they don't shut me down. :fingers-crossed:
it's amazing that i can spend so much time tweaking border-radius's and padding-top's but not see that a primary label is butchered. thank you for pointing it out! I published an update.
this is really good feedback. i got rid of the total-results display because I agree; it's overwhelming. it would also probably help to filter out issues with no description. Current implementation is somewhat limited by the features of github's issue search api. in general, start by adding a filter! pick a language you're comfortable with and add a label. that will very quickly bring you down to a handful of results. thank you for the feedback!
will do - thank you!
https://jsfiddle.net/1922shho/ const _getItems = () =&gt; Rx.Observable.from([1, 2, 3, 4, 5]).delay(300); const _getDetails = item =&gt; Rx.Observable.of(`details for ${item}`).delay(300); _getItems() .flatMap(_getDetails) .map((item, index) =&gt; ({ id: index + 1, details: item })) .subscribe(item =&gt; { console.log(item) });
Fixed.
Added to FAQ.
Added to FAQ.
Added some middleware hook issues on github.
Added to FAQ.
I know it, just hide activity bar(not sure the actual name in English), that is the most annoy things in vs code. 
You like hyphens... don’t ya? :)
Thanks! You have given me a clearer idea of what flatMap is. Can't really use your changes there (the API is going to emit only once with all the items, so it's more like `.of` than `.from`; and the items may be anything, not necessarily sorted numbers). I should have provided more context. But you've pointed me in the right direction.
Very cool! While not **super** advanced, [this](https://redux.js.org/docs/advanced/Middleware.html) helped me when designing Silhouette's middleware API. I don't remember any other stand-out resources off the top of my head...
Can someone tell me if I'm missing something here? JavaScript Promises are implementations of the [https://curiosity-driven.org/monads-in-javascript#continuation](http://www.haskellforall.com/2012/12/the-continuation-monad.html). Monads are meant to be an abstraction which help us reason about the composition of functions on certain datatypes, with the Continuation Monad in particular being designed to [help us model asynchronous operations](http://www.haskellforall.com/2012/12/the-continuation-monad.html). Is there a need to introduce an entirely new set of scaffolding to reason about Promises, then? Furthermore: is this model actually going to make it easier to reason about asynchronous code? The cognitive overhead of constructing the promise graph to *then* reason about the program seems no better than looking at the code itself and inspecting it line by line. Especially when the errors involved in the case studies boil down to failing to resolve the promise correctly, or failing to return the intended promise. I don't have an issue with the formality of the paper: I enjoy seeing when programming concepts have a firm mathematical root. But I don't know what I'm getting out of this study. It is nearly as long as the section on Monads in my Computer Science course, but with considerably narrower scope.
That’s great info. I’m definitely going to reference it. Thanks again ☺️!
[Much shorter hacky one](https://www.youtube.com/watch?v=xGmXxpIj6vs)
There's also a perceptual diffing library built by segment on top of nightmare called niffy. The sad part is that it hasn't been updated in 7 months. I reached out to them and they were uninterested in a new maintainer so I just forked it and added to it. I was thinking about publishing to npm unset a different name if not only for ease of consumption. Anyways, feel free to use it and / or help improve! [Niffy - mousemke](https://github.com/mousemke/niffy)
You can still call `.from()` on the results the API produces, and use `.reduce` to put them back into a single array if you need to. Here's an example: https://jsfiddle.net/vom90w33/ const getItems = () =&gt; Rx.Observable.of(['Oslo', 'London', 'Paris']).delay(300); const getDetails = item =&gt; Rx.Observable.of(`details for ${item}`).delay(200); getItems() .flatMap(Rx.Observable.from) .flatMap(item =&gt; getDetails(item).map(description =&gt; { return { id: item, description: description } })) .map((item, index) =&gt; ({ id: index + 1, description: item })) .reduce((items, item) =&gt; items.concat(item), []) .subscribe((items) =&gt; { console.log(items); }); I can explain `flatMap` in terms of promises, if it might help: calling `.map()` is like returning a simple primitive from a promise `then` method callback: observable.map(string =&gt; string.toUpperCase()); promise.then(string =&gt; string.toUpperCase()); Whereas calling `.flatMap` is like returning a promise from a promise `.then` method callback: observable.flatMap(string =&gt; Observable.of(string.toUpperCase())); promise.then(string =&gt; Promise.resolve(string.toUpperCase()); If a contextual type that wraps a value has a `.map` method for accessing and transforming values, it is known as a "functor". If the same contextual type has a `.bind`, `.chain`, or a `.flatMap` method which can collapse a contextual type returned from the transform function into the parent contextual type, it is known as a "monad". Promises are monads and functors, they just combine both data transformations into one method: `.then()`. You can find out all you need to know about monads here: https://drboolean.gitbooks.io/mostly-adequate-guide Read that tiny ebook and you'll understand `flatMap`entirely.
One thought is that in the setNames function I could add a onclick to each div. Clicking would toggle a strikeout on the text of the name. I could also add to the nameArray and add a boolean value for "present"? Clicking would also toggle this bool. The animation and random choice would only apply to items that have present = True. If my original code above is any indication, this could get messy. So I'm still interested in hearing strategies or elegant solutions.
Hi Matt! Thank you for your comment. You're right, we're becoming very dependent on scaffolding to kickstart new projects in frameworks such as React and Preact. However they are very simple and handy. They allow us to dive right into the feature development. Those one-line commands are maintained and updated regularly. It generally bundles all the recent web standards and good practices. It is open-source and you can check out the code behind and even update it if you like! IMHO, it is a very powerful and clean tool to create a new app! What do you think ? =)
Could you add another option with compose or lodash's flow? 
That's a good one
&gt; The ability to incrementally adopt *framework* is likely the biggest strength. &gt; The biggest strength of *framework* is its relative simplicity and focus. &gt; The biggest strength of *framework* is its popularity. The contenders are: Angular, React and Vue. Which fits all three?
Just got to test it. It seems to work after copying your script. Don't know what happened, but works now. Thanks for the help anyway! Appreciated!
Yeah I agree. There's a lot of loading going on before you see anything. And there's not even that many words on the page. Must be all that " react + redux using semantic-ui-react css framework" shit.
Amazing! Thanks a lot for the detailed explanation.
Yes, I would love to see it. it's in Elm and I've made one "for fun" in Scala and it's been useful. Would absolutely love to see it in JS.
In my opinion, React. Vue fits the bill also, but React is more popular than Vue (so it would be more fitting given the constraints)
 I almost never see this situation. Its like you are finding the most extreme example and then using it to sell a solution. In most cases the pipe would be used in less extreme situations and do nothing but add complexity to the language for no good reason. Couldn't this be a pretty easy babel plugin for a test run?
I have this situation in another language, if that helps.. shows how I'd use it in Elm, and shows how I made it available for myself in Go. https://gist.github.com/natdm/9b4e654bfa0bc7bf594fa778a263b9d8 It could be very useful. It doesn't mean it should be used all the time. 
You lost me with the casing. One does not simply start javascript variable names with capital letters.
but the question, did you understand the code? how things work?
Can anybody compare/contrast this with webdriver.io?
I’m sure you could find a way to use TDD with Jest, but I’m not sure I’d recommend it. I would use TDD to test your *functionality*. Then, get the UI the way you want it. After that, implement your snapshot testing. The snapshot testing is in place to prevent UI regressions where TDD is about defining your specification before you write code. Otherwise, you’re going to have to mock a screenshot you want to build toward first, and I’m not sure that’s practical.
Maybe good to give some ideas for filters directly to the users? Like you just gave me. 
Yes! I'd love to see the pipeline operator in javascript. Currently using R.pipe/R.compose instead.
Cool project! You should post it to ProductHunt. They're running a global (remote) hackathon this month, your project could be popular there. Also, it's good for feedback. 
React/Vue in my opinion fit all three. Both React and Vue are relatively easy to incrementally adopt (I've done it personally with both and personally found Vue easier but React wasn't too far off). Popularity wise React is the clear winner by and far, but Vue isn't without its share of the pie. It's clearly gaining ground and developers seems to love it, but I don't know if anything will overtake React in that department. If you consider Vue/React just the view layer like they are, then clearly they both fit the bill of simplicity, and if you need some abstractions or libraries to use for other areas like routing or state management both have them covered. Disclaimer: I have never used Angular 2 outside of the tutorial, but have used both React and Vue in production applications serving thousands of users. So take that as you will.
Domain comes back positive for malware from AVG. Be careful. Additional scan positive as well. https://sitecheck.sucuri.net/results/github-help-wanted.com 
I did, but I've written a few snake clones in my time :) I used to prefer doing Pacman clones for some reason, I don't even like Pacman as a game :) Yours is good too. I liked the way you took time to diagram out some of the operations at the beginning. Total aside, Brackets looks quite nice too. I really don't need yet another editor, but I had never seen it before. Is the live update built in? 
One thing that's probably useful more generalized is a "tap" function: const tap = (f) =&gt; (x) =&gt; { f(x); return x; }; Then you can build "log" this way: log = tap(x =&gt; console.log(x)); *And* you can do the same with any other side-effectful functions too, like console.trace, console.debug, or even just tossing in a "debugger" breakpoint: breakpoint = tap(x =&gt; { debugger; })
HA! thank you for reporting, but... what a bunch of garbage. "Securi" wants me to purchase "Website Hack Repair" for 41.99 a month. this is a simple redux app, hosted on github-pages, that connects _only_ to github's api servers. if you don't believe that, read the code: https://github.com/mac-s-g/github-help-wanted "website" "hack" "repair" cmon...
Rather than showing how the examples are similar, it would be useful to see how they are different, e.g. stack traces
awesome tip! I'll do that. thank you.
I really liked this article, but I do have one pedantic nitpick, in the medium term outlook for Vue.js it said that it might have an uncertain future because it's "not directly supported by a commercial organization" , while this is true, it is heavily endorsed by the developers of Laravel, being a javascript community obviously PHP is out of our wheelhouse, but support from the most popular PHP framework IS notable and assists with the sustainability of Vue, as well as it being relatively easy to learn AND faster than React or Angular .
Good point, will add it as soon when I get my hands on a computer (also not sure if its possible in twitter).
Does it pair nicely with async/await?
I think this would be something interesting to pursue. I'd be interesting in collaborating on it. And maybe libraries.io can help. 
No backbone/marionette? :( (No, I know... I know... Get with the times, kid)
the code in question is `[+!+[]]+[+[]]`. source: compiled using [jsfuck](http://www.jsfuck.com/).
Angular is like what - version 5 already? I mean - what do those people do - rewrite your app every year? 
It appears to. See https://github.com/tc39/proposal-pipeline-operator#use-of-await
It really shines if you use Typescript.
I'm guessing your site has been blacklisted because it contains the words "github" in the domain. https://www.mcafee.com/threat-intelligence/site/default.aspx?url=github-help-wanted.com &gt; examines how aggressively the site tries to get you to go to other sites that we've flagged with red verdicts. It is a very common practice on the Internet for suspicious sites to have many close associates with other suspicious sites. The primary purpose of these 'feeder' sites is to get you to visit the suspicious site. A site can receive a red warning if, for example, it links too aggressively to other red sites. In effect, a site can become 'red by association' due to the nature of its relationship to red flagged domains. 
*sigh* yet another article praising Aurelia, but i bet yall won't use it tho. 
They do not create a new framework with each version number. They just adopted this numbering scheme for their updates.
&gt; console.trace According to the [documentation](https://developer.mozilla.org/en-US/docs/Web/API/Console/trace), it isn't what he wants.
Hmm. I wasn't expecting const userAge = userId |&gt; fetchUserById |&gt; await |&gt; getAgeFromUser but rather const userAge = userId |&gt; await fetchUserById |&gt; getAgeFromUser
yeah, that's what I love about brackets, the built in "live preview" is amazing. and thanks for your suggestion, I will try to code the Pacman game.
&gt; why does console.log not do it natively? Why would it? It's job is to log things, not operate on data.
I tried it - it is interesting - it does half of what he wants. 
I'm sorry, but I've just had too many bad experiences with flaky functional tests and horrifically long CI jobs. These days I resist technologies like this as long as I can get away with.
dangit. probably true. not super impressive "threat intelligence" though.
I agree. Although it isn't really any faster than React any more (not notably), although it certainly was before React v.16. They're very similar these days but naturally have areas were they excel. When people are discussing the 'big 3' frameworks I always hear: "React is supported by Facebook, Angular is supported by Google". No they're not. They are products of those companies, the people writing the code get their paycheck from those companies. They may be open source but the design decisions behind Angular and React are directly tied to the business interests of those companies. If those interests align with what you need then that's great but they could shift at any time and they aren't going to listen to anyone but themselves (which is perfectly understandable, its their product). I'm not a particularly paranoid person but when using those products it's always at the back of mind and its the main reason why I don't want to invest in them too much when there are more independent, and equally capable, alternatives. Vue on the other hand isn't in that position. It doesn't have any one corporate overlord guiding the design decisions, and there is less likelihood of the community being completely ignored because of internal pressure. However it isn't 'a one man show' like this article suggests. There are a team of core contributors who work on different aspects of the framework. Vue is used by Baidu, Alibaba, Gitlab and many others (it has especially strong support in china). There is no uncertainty regarding Vue whatsoever, and the fact that it is free from the tinkering of any individual corporation (but enjoys financial support from many) is more comforting to me than if it were bankrolled by just one such corporation. Also the recent growth in popularity with Vue has been insane and I can see it continuing to grow in the near future and it already has a very healthy eco-system and the best documentation of any framework, in my opinion. I also really like how Vue is basically using an implementation of web components for its templates, and I believe they will be looking to leverage native browser support for web components in the future. I also think Single File Components are a joy to work with but that just my personal opinion. 
semver. Look it up.
Looks good.
I think you allmost never see this because many APIs are object orientated or have some fluent interface. If you use a more functional style, the need for this feature increases.
One of my favorite frameworks is never mentioned in articles that compare frameworks. Check out Mithril. https://mithril.js.org/
nice. Also, note it takes time. For testing, it'll be really good for you as a developer to think in terms of how to make your code more testing. This will be more evident when you start testing code. You'll go Wtf how do I test this large method. This typically means your method is doing too much at once and you'll need to simplify it to make it "testable" I also recommend this guy's awesome videos: https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q/search?query=testing
[removed]
GWT - Java -&gt; JS, used all over by Google.
ES6 is completely backwards compatible. Barring any radical changes, ES5 code will work for the foreseeable future. It's still the same language, just new features that you can (and probably should) be utilizing. I'm not sure why anyone would choose not to use them.
[removed]
My company is using it but I don't have much experience with alternatives. Pretty happy with it most of the time though!
also this is my first time here so any direction to what the standard for styling code in this r/ is would be cool too.
Why are you using jQuery (as evident by $(window)) but then using vanilla JS to select and manipulate the DOM?
Thats a good point. So couldn't this be used as an argument against adding pipeline to javascript?
Depends whether you like OOP or FP I guess :)
I tried to find documentation about the feature but I don't reminder where I found the trick. I only remembered it when I saw the question and the mentions of "trace"
Not only Laravel developers, but also Alibaba, which is basically the Chinese Amazon. It is also supported by an OpenCollective campaign.
&gt; "React is supported by Facebook, Angular is supported by Google". No they're not. They are products of those companies, the people writing the code get their paycheck from those companies. Facebook is pretty invested in React. However Google is notorious for not giving a shit. Beyond a certain size, the viability of a project doesn't correlate with Google's ownership of it.
&gt; In most cases the pipe would be used in less extreme situations and do nothing but add complexity to the language for no good reason. I can't speak for the JS community at large but most of the projects I've worked with in the last 2yrs have leaned heavily on `ramda` or `lodash` in order to create HoFs that can be passed around. For instance: const firstName = R.compose(R.head,R.split(/\s/))('John Smith') I am not seeing how turning the above into const firstName = R.split(/\s/, 'John Smith') |&gt; R.head adds any complexity and I would say it actually helps make it more clear what we are wanting to do ( once you understand `|&gt;` ). I am also assuming that the stack-traces for the `|&gt;` would be a helluva lot nicer than `ramda`'s "ncurry threw an error" messages.
You're right, React itself is not a framework.
A good article makes you want to roll your sleeves up and give it a try. I'll be giving it a try. :) 
Polymer is not there either. Nor Cycle.js. So perhaps Marionette is too hip for this review ;-)
You shouldn’t judge usefulness by whether it can be done in a different way. Something can be an improvement over previous methods. For example, the new `includes` method on strings and arrays can be replicated using `indexOf` but the newer method is more explicit about the goal. The newer features of the language are substantial quality of life improvements even though much of the functionality can be replicated in older environments.
There is no reason to not use it. It's even getting arguably old now, and pretty much supported everywhere. You can even use it without transpiling if you don't care about IE11 (and you shouldn't care unless you really really need that niche). 99% of things can be done in es6 without any ceremony.
Do not try to write a jest snapshot by hand.
People should really checkout Elm. It is a seriously cool framework that I hope will bury every framework out there.
I know functional programming in JS is the latest hotness, but its not that idiomatic of the language as a whole. I'm not sure I like adding to the syntax (and again breaking my beautifier) just because of what the cool kids are doing now. Didn't they recently add 'classes' to the language to appease all the OO fanboys, and piss off everybody else? Do we have to keep doing that?
Totally understand that adding a tool for a paradigm that you don't use can seem like a bad idea. I was saying that there are others that use these tools/paradigms not only for fun projects but production and adding it to the language would help remove need for some dependencies. As for FP not being idiomatic of the language, I'm not sure I would agree with that. The language was built to imitate Scheme, an FP language. If anything, it is the most idiomatic paradigm. 
&gt; We feel the Angular framework focuses on creating user interfaces in a single page application and does not address the larger concerns of a building a web application. This can lead to difficult to maintain projects if conventions are not established early. At a practical level, there is a lot of magic that occurs to provide run-time behavior that is not part of the core framework-provided technologies. This diminishes the value of TypeScript to the end-developer. This doesn't make much sense. Angular comes with a router, dependency injection framework, animations, SSR support, PWA support, etc Furthermore, I'm curious what run-time magic exists that enables behavior outside the core framework provided technologies. Hell I'd like clarrification on what that even means. I stopped reading the article after this. 
&gt;&gt; not directly supported by a commercial organization &gt; it is heavily endorsed by the developers of Laravel... support from the most popular PHP framework I think you've missed the author's point here - it's not that "nobody knows or cares about Vue.js" - as you note, there's a thriving community of people who use it. The point is thatthere's no **commercial orgnisation** supporting it - it has very little in the way of budget or financial resources, and 100% of its support is from *volunteers* to the Vue.js project (or worse, to other projects that - for now - have decided to use Vue.js... and at any point that support could fairly quickly largely melt away. The point is that it's safer to bet on a project with a company and a few milions of dollars invested in it and some top-flight full-time devs workng on it full-time than on one that's carried *exclusively* on the shoulders of part-time volunteers and hobbyists.
Oh god dojo *shudders*
Why is this framework your favorite? I'd like to hear about it from you
Nope
I'm not exactly sure what you're trying to do but you should be aware that checking the values of strings that hold numerical values is quite dangerous. JS will either combine the two strings which can result in unpredictable results or it will in some cases force a type conversion. You should be holding these values inside arrays for more accurate results, it also makes the data easier to validate and work with. You have a perfect use case for a 2D or even 3D array. 
Preach is great, but it really hurts that enzyme doesn’t quite have a plug-in ready to use for Preact. It makes unit testing a lot harder.
My antivirus says there is malware running on this site and is blocking it! 
Alibaba and chinaese startup use vue heavily. It's fuckimg big in China
Anyone who denies that Aurelia is a great framework, has never used it clearly. My company has been building apps with Aurelia for over two years now and we love it. It gets so much right, it's pretty forward thinking. Sadly, it suffers from marketing problems and lack of resources in comparison to React or Vue. Still, it's a great framework. And I say that as someone who works with React, Vue and Aurelia. Being a good developer means staying open minded and using whatever works. Don't knock Aurelia until you try it.
Well, react is version 16 atm
My biggest draws to Mithril are the performance and how leightweight it is. I find myself not having to require any other libraries (other than Mithril) and my webpack config ends up being dead simple for most apps I end up writing. It comes with XHR and routing out of the box (no need for extra libraries). My typical app size, with static assets included, weigh in around 200k. I build a lot of "proof of concept" apps, visualizations and internal tools at work. One of the biggest downsizes to Mithril is the lack of stackoverflow posts. Mithril's documentation is pretty decent, but sometimes I hit a wall. It'd be nice to bounce a question off somebody else using it. On the plus side, I've learned more about Mithril's internals. This page really sold me on Mithril for my use cases: https://mithril.js.org/framework-comparison.html
thanks man, do you mean per page or per function? I use jQuery else where.
Well why not use it here too?
They missed one major weakness of angular 2+; the error messages verge on useless sometimes. Dont make mistakes when writing in angular2, because you will have to figure them out by guesswork.
&gt; As for FP not being idiomatic of the language, I'm not sure I would agree with that. The language was built to imitate Scheme, an FP language. If anything, it is the most idiomatic paradigm. From what I've heard scheme was considered instead of javascript but the suits decided it would be too weird, but I'm not sure if it has any FP characteristics except first class functions ( am I overlooking something? ). It does however have multiple OO characteristics, like objects (duh), method chains, this, boxing primitive types, etc. If its somewhere in the middle between FP and OO, I'd say its more towards the OO side.
I read about Mithril once and its features seemed similar to Preact. Do you prefer Mithril over Preact or haven't looked into it? They both seem to be really good lightweigh libs. 
It's actually a langwork :P
[removed]
The pipeline operator is horrible. Not sure what example I like more: ``` promise |&gt; await ``` or ``` class Comment extends Model |&gt; Editable |&gt; Sharable { } ``` Yeah, that's needed alright... 
I haven't used it, but I've read similar things. I think it's even smaller than Mithril, which is really impressive. Preact is on my "need to try this out someday" list. 
+1 for aurelia and the only other pro-aurelia comment was super condescending. 
I'm a big fan of Polymer, but now that HTML imports are going away, I'm tempted to try something different like Aurelia.
yea... there's a thread about this above. kinda frustrating because the code is all open source, only connects to github's api, and it's running on github pages. so - you shouldn't be super impressed with your antivirus provider in this case. 
it's the original page load that's slow, right (not the issue queries)? The bundle is pretty large (1.8MB). I haven't had much time to optimize yet. I could definitely use some help optimizing if you're interested in contributing 
Just under 9% of organic traffic to my organisation's website comes from IE11, 9 and 10 on Windows 7. Still an issue here.
One situation is in React where you wrap your component in multiple HOC
Came here to say the same. Plus: How is the value of TypeScript diminished?
I don’t think you grasp how big Alibaba is. 
Thanks for the write up!
Travesty....??.. it should be a programmers choice isn't? Especially for a programmer who write code in 7 different programming language. It's real travesty that someone judge based on variable naming convention used... Write to ES. Include JavaScript naming to generate errors on capital letters.. till then ...please judge the code based on what's it is trying to do. 
In fact, the article's author happens to be dojo's current project lead. I'm gonna make an educated guess and say this article exists primarily to advertise for dojo.
Created a rest-api service for angular 2+ https://github.com/sabbirrahman/ng-restly
I still have 'Nam flashbacks from dojo 1... Have hardly even heard of dojo 2 until this article, whereas the rest of the frameworks are pretty huge. So yeah you might be on to something. 
No es5 code won't be useless. All those people writing in ES6 still transpile to ES5 for browser support/performance.
It now supports mobile https://github.com/atlassian/react-beautiful-dnd/releases/tag/v2.6.0
Original library announcement: https://www.reddit.com/r/javascript/comments/6tymdy/rethinking_drag_and_drop/
True but I'd still reckon Vue is decently well off https://www.patreon.com/evanyou
How well does Typescript handle Angular templates? I recall them being untyped back in 2016, but with how fast things move in JS.... well it may be different now. 
https://www.destroyallsoftware.com/talks/wat ?
Yeah, but these projects are open source. If fb decides to go some strange direction with react that is not in the best interest of the community, people can always fork. I don't see how you can possibly see corporate backing as a bad thing.
Rx.js. That is not officially part of Angular2+, It's pretty much a dependency they use very heavily, and all major examples show it used, but it's not part of the framework-per-se.
In angular 2+, type script will type check templates via AoT In the latest Angular release (5) AoT is speedy enough for medium projects to run in Dev mode for save and refresh so you get type checking in templates while developing They are working on another tool chain called ABC -Angular Bazel Closure that will work for projects of all sizes for AoT in dev mode 
Hmmm, not working on Chrome 62.0.3202.84 on Android 8.1.0 on my Pixel XL. Just brings up the hold menu, can't drag anything. 
Can you please raise an issue on the repo and we'll take a look. There are a lot of devices out there!
Only used Mithril for a small project so far, but I was a big fan. It's got a well designed lightweight little interface, that's easy to pick up and works exactly as expected. It had all the components I wanted and none I didn't.
LOL, this is funny as hell. If I recon, Linus, granted not officially a "framework" was a framework to build a linux os with free tools. That kernel is at the time decided by linus he didn't want to work on it anymore may have died. Well, vuejs, it could stick around for a while, a long while. jQuery was written by a really young guy, and today it's used on millions of websites regardless of it being integrated now naively in most browsers. So this is just jibberish wishwashiness.
Angular language services provide typechecking/intellisense in your templates. It's not really typescript, perhaps tangentially related to your question, but you might find it interesting nonetheless. https://angular.io/guide/language-service
We have tested it on Chrome 62 on Nexus 2.. Not sure what is going on here. Raise an issue and we'll take a look
Yes, Alibabba does sometimes Many Billions of $ (x)*10^9 / day, so I think they have some sway.
Ember is the juggernaut in the room, it's used less right now because Rails has experienced a massive exoduse. The moment some major JS framework adopts Emberjs, it will suddenly charge ahead again.
I'm not sure what your answering. A third party dependency is run time magic? I'm confused. 
Lets not forget.. If jumping off bridges were popular, should be all jump? *sniff lemmings?* Lets just say it's trending and we like how it looks, popularity is often not always "spectacular" angular1 was popular, but got dumped like a bad dream out of developer frustration of it's slowness as the application state grew.
I believe that ECMAScript 2015 was a substantial and much needed evolution in Javascript. Whilst you can get away with not using any ESNext Javascript feature, really the question is: why would you not want to use the latest Javascript features? Using a transpiler like Babel or flavour of Javascript like TypeScript, your code is backwards compatible. The addition of arrow functions in my opinion was one of the best things the ECMAScript team ever did, because it addresses one of the most annoying issues with Javascript and that's retaining scope.
Honestly, I feel like uniform function call notation (like in D or Rust) is a far superior alternative syntax-wise. E.g. `foo.bar(123)` is treated like `bar(foo, 123)` as long as `foo` doesn't have its own `bar` method. However, this thing can only be reasonably implemented in static languages. I'm not sure if JS needs the added complexity of the pipe operator, which doesn't really have too many used (in comparison to destructuring and decorators, for example). One operator that is somewhat related is Dart's `..`, which enables chaining for methods not implemented with chaining in mind. If we consider piping, this one is also worth looking at. But I don't feel like any of these by itself gives enough benefits to add complexity to the language.
https://blog.iota.org/the-iota-javascript-library-65ba22945711
How do you exactly use both es5 and 6 at the same time? Babel transpiles to es5 but what if you use some features not available in es6. Then, how are they implemented?
The pipe is alright. I'd also be cool with adding `compose` to the language or maybe even expression scoped variables via the `in` keyword
Polyfills can be added which basically give you the ability to ship modern features to older browsers
Hi. Great guide. What about SEO?
Hi jimmirbn, thank you very much for your feedback! Angular uses a project called Angular Universal to render you application to pure html. This html file does contain the content of the requested page and is therefore readable by all search engine crawlers. Because this requires additional setup and is not that trivial to understand, I have not included it into this tutorial. However, I have a guide on Angular Universal as well, if you are interested in that: https://malcoded.com/posts/angular-fundamentals-universal-server-side-rendering Have a great day and thanks again!
It has been 3 months and I just found it now. Learned quite a bunch from this blog post! I'll give you my credit, thanks!
I agree, having the explicit await in between piping statements is pretty confusing. My reaction was 'can't the pipe just deal with native promises implicitly?' just this : const userAge = userId |&gt; fetchUserById |&gt; getAgeFromuser But for readability and better understanding your example is a lot clearer.
Rxjs is not magic... That's just observer design pattern encapsulated into a library : learn your design pattern, it will make your life very much easier ;)
This is a paid advertisement, not an article, and should probably be treated as astroturfing by this subreddit. Sitepen is one of the corporate sponsors of Dojo and the author is its lead developer. The 'strengths' section for Dojo is over twice as long as the ones for React or Angular and four times as long as Vue's, while its 'weaknesses' section is correspondingly half the size of any other. The 'criticisms' it levels at Dojo are also *very* weak compared to those aimed at everything else. Aurelia basically gets called a Beta project that's in production, but one of Dojo's potential problems is trying to be so good that it might not have a niche? React makes it easy to make bad decisions because the community is fractured, but Dojo's biggest weakness is how long it's taking to write? Additionally, this is the OP's second post ever. We really should not tolerate this kind of thing here. 
Too bad it will be outdated next week.
&gt; Why would I choose Ember.js? You should not. Don't hurt your company.
It's not a multiplayer game, just something I've made so people in my school can have fun with.
Not sure if you're aware (your repo doesn't mention it) but [yarn upgrade-interactive](https://yarnpkg.com/lang/en/docs/cli/upgrade-interactive/) also provides a nice CUI for upgrading.
It turns out a late defensive addition prevented touch dragging working altogether. Awesome. It is now fixed :) https://github.com/atlassian/react-beautiful-dnd/releases/tag/v2.6.1
&gt; Not used in industry because using it would vastly increase productivity and cause mass unemployment for web-devs. Yeah right. 
Since ES5 uses callbacks and not promises, you have to create promises in order to use old ES5 code with async await.
A colleague used mithril.js for a SPA shortly before leaving the company. I'm still puncturing his voodoo doll almost daily for that. I'm unsure if it is because mithril is so bad or because he used it so wrongly, but basically rewriting html fragments in nested Javascript calls for each tag is something that should be punishable by death.
To continue on that: Facebook USES React, AFAIK big Google products don't use angular, so decisions made on React are made by people heavily using the framework.
Sure! But sometimes you don't want to leave editor. And upgrade-interactive, as I know, doesn't support next tag (alpha, beta, rc)
Hello! If you like playing with javascript and canvas to do little video game I strongly advice you to check the Meth Meth Method channel : - https://www.youtube.com/channel/UC8A0M0eDttdB11MHxX58vXQ Also, what cause you an isssue exactly ? I'm pretty sure you could find how to implement this leader board by yourself.
I think the community is full of idiots. Orange icon is better 1. There are a lot of blue icons atm: telegram, photoshop, skype etc, no need to create another blue icon. 2. The blue icon of VS code is ABSOLUTELY THE SAME as Visual Studio icon, with is also opened very often in the same time. 
Thank you for answering. I will check out the channel at once. Every time I try to implant a leader board into the game, I can never find out exactly how to properly make it work. I've been searching for guides that can help me - but the guides I've found includes the game engine Unity. I am not very good with javascript, that's why I asked for help. But I would love to do it all bymyself if I either knew how or found a guide that showed how you do it. 
Ok, at this point your first step should be to break your problem (making a leader board for you snake game) in sub-problem as small as you can. Let's do this and see which point exactly are an issue for you and how you can find a solution.
It was very obvious that this was a Dojo2 shill piece as soon as I got to that section.
Well said. Unfortunately, /r/webdev and /r/javascript absolutely love listicles and comparisons of web frameworks, and they will get upvoted to the top every single time, no matter how horribly written or inaccurate (as long as it matches popular opinion, of course). Is really no one getting sick of these yet?
[removed]
Elevator pitch for why one would use Aurelia?
Okay, I'll try to do that. I am not very good with JavaScript, but I'll try my best. 
Because that would take time and fragment the community. And then you end up with a product that is in the same situation as something like Vue but at an earlier stage in it's life (organisationally). I'm the absence of compelling alternatives, I would agree but there are good alternatives, so it isn't an issue.
I mean, I don't *care* that it's *written* like this with *italics* every other *word*, or that it's a *listicle* that is not particularly *accurate* and has serious *issues.* Bad content might not be what *should* be upvoted, but what the community likes is what it likes. This, though, is astroturfing. It's one of the people that makes a product pretending to produce an unbiased overview of the existing options while actually just trying to recommend his own. It's not a matter of people 'getting sick' or them or not, it's a matter of people not putting up with paid advertising masquerading as actual content. Would people tolerate a "Comprehensive Review of Javascript Frameworks, by Dan Abramov" published to on research.fb.com? Because that's what this is equivalent to. 
Well yeah, they needed to create a reason why Dojo is the best Typescript framework. 
It could be argued, though, that if what you do is build a huge piped process, your code is as much functional as it is imperative.
You can find part 1-4 at https://medium.com/gitconnected
Functional programming is pretty old, and its concepts predate OOP. JavaScript is also inherently closer to functional programming than OOP. It makes perfect sense to add a pipe operator.
Having been part of several popular projects I can say that in my case "help wanted" labels did next to nothing to motivate newcomers to help out - even when labeling as "beginner friendly". What did work was themselves having issues or really wanted features, fixing / coding them, and send them as PRs. Which seems kind of obvious, if I wanted to contribute to an OSS, I don't think I'd really pick something random that's marked "help wanted", but rather I'd work on adding something I need or fix an issue I experience on a project I use already. Not saying the idea won't work, just my 2c :) 
Can't get used to the way the `|&gt;` operator looks, but sure would be useful.
After some time "refusing" to work with ES6 syntax, now I actually use all the latest standard as soon as available and ES5 syntax starts to read _very old_ to me. Whenever I read `var`, `function` I start to cringe and also I start to feel the same with semicolons, and I remember myself a couple years ago saying I'd never write code like this :) ES5 will forever be valid syntax, since gazillions lines of code use ES5 (and below) but ES6 is a game changer, along with the latest versions (await/async and generators) Here is a short guide about ECMAScript I wrote on my website that introduces the standard and what the latest versions provide: https://www.writesoftware.org/course/ecmascript I hope it might be useful to you.
[Svelte](https://svelte.technology/guide) is also worth considering. Mustache syntax, compiled, uses a fair amount of standard JavaScript, and mostly unopinionated.
It's always a friend and never the poster.
1st one
Maybe xpost this over to /r/ProgrammerHumor 
Pipe would be very useful for libraries like RxJS, IxJS, Ramda and others, even for day to day array operations.
Aurelia is the easiest to use by far! +1 for me.
This looks awesome, but how come he has to get approval from Nike if he did worked on this on his free time? 
I suspect it would just be syntactic sugar, so it probably wouldn't affect anything except the way the code looks on the screen. Spez edit: [Apart from if you need to pass additional parameters to some of the functions](https://github.com/tc39/proposal-pipeline-operator#user-content-functions-with-multiple-arguments), when you end up wrapping the named function you're calling in an anonymous fat-arrow function expression to pull in the additional variable.
This is awesome thanks! I’m specifically learning JS for Ethereum Smart Contracts
Oh incredibly. Here and /r/angular is just full of content farm crap. And most frustratingly every time someone posts another one of these comparisons, as you say, everyone gets overexcited about this non-content - "oh hey, would love to see burp-framework.js get a mention in this list". "I think wheel-reinvention.js needs to be higher in this list". "You said goose.js lays golden egss ... technically they're geoids!"
what would be the advantages of using jScript? Also what should i be using, like in the terms of standards?
It does work for only closed taskbar app, but if I open app it has blue icon 
probably more like "spare work time"
This looks amazing and really something i was looking for. I was waiting on the next Strapi, but this is worth a look!
As a self-described functional programmer who loves to write that way in JS, I have to agree with the lean. Considerable time and complexity have been added to the language to make it act class-oriented, while it wasn't until ES6 that tail call optimization was even added to the spec (and is the one part of the ES6 spec that *still* isn't widely implemented). It's hard to call your language "functional" if you don't have TCO. That being said, the pipeline operator is very nice for functional programming in the same way that chaining methods is for OO programming, and I'd like to see it in.
&gt; how come he has to get approval ... if he worked on this on his free time? If it is something that he also used work time on, which includes *using it at work for their benefit* (if nothing else that can be seen as using work time and collegues as testing resource), then chances are his contract says that they own it or at least have first refusal. Some contracts say they own everything you do while employed, not just in work hours, but those are not legally enforcable (aside from the "we have expensive lawyers and you can't afford the same" type of enforcement). Of course I am not an employment or IP lawyer and even if I was I probably don't know the law in your current jurisdiction intimately as I live and work elsewhere, so don't take my word as truth!
My friend says it makes the post look a bit click-bait-y.
Glad you like it! We finally had the resources to do everything we dreamed about in a micro-service oriented content backend. You get all the code for the editor experience as a bunch of MIT licensed npm-modules. You describe your content structure and get the user interface generated for you, then you can easily plug in your own code to tailor it to your exact needs. You can host this with us (one command: sanity deploy) or anywhere you like. The backend is hosted by us. It is a document store with a powerful query-language, patch based, real time updates and on demand scaling/cropping/processing of images through a globally distributed CDN. Our business model is obviously tied to maintaining an awesome kit to build the editor-facing CMS, then charging (very reasonably) for the backend platform.
On the bottom of the page he defines what looks like an object but writes type before. What does type do? 
You can use one of the multiple babel transpilers.
Thanks! Please keep me posted. Tell me if you need anything ;)
I think for some reason, many people just read these meaningless lists just to see if their favorite framework is mentioned. Looking for some sort of validation I guess.
I'm not sure I see the full picture very clearly, maybe it would help if you posted some screenshots or diagrams. However, I do know that using overflow visible is not a good solution for drag and drop. Either figure out a way to make the entire working area with svg, or use absolute positioned divs containing the svgs. As far as the zoom and pan, you could try using CSS transforms instead.
[removed]
This is only profitable for websites with 10000+ visitors/month. https://www.cryptojackingcalculator.com/ So I don't worry too much...
Seems like developit has been working on it, I think =) - https://github.com/developit/preact-compat/issues/82 - https://github.com/windyGex/preact-compat-enzyme
Does anyone have any experience with talking to the blockchain with React in combination with Meteor? 
How are you serving the pages? You're going to need some server side logic, which can receive high scores, store the scores and present them back in the page sometime. You could do this easily with any server tech (eg PHP, nodejs), but getting initially setup will be the biggest hurdle.
Sounds like you need to move the element being dragged to a temporary transparent SVG container which you then drag around before adding the SVG element back to non-temporary SVG container on release.
ES6 has introduced a bunch of smaller syntax improvements, which I guess you could live without, but also some important features, such as for-of loops, template literals, block-scoped variables, and promises. I’d suggest you go through the list of new features in ES6, and identify the features that seem significant. 
Wow, this is way better than the implementation I ended up making in React. My animations look kinda hacky. Thanks for sharing!!
My friend says this has been spammed to all relative subs in the last week.
&gt; marketing problems and lack of resources You should see if your company can do a blog post or something! It seems like a lot of companies are using Aurelia under the radar. I've worked at 2 already in my short carreer that are using it, but say nothing about it. I'm pretty sure RBC uses it. 
The components aren't proprietary, its the smallest size full featured framework (router, events, data-binding, ect.), its mostly vanilla JS and HTML.
A pleasure. Here's a bonus! By implementing a coroutine that accepts a generator function to handle calling `.flatMap` for us, we can simulate Do-notation to make the code a lot easier to reason about: const Do = generator =&gt; { const iterator = generator(); const next = value =&gt; { const result = iterator.next(value); if (!result.done) { return result.value.flatMap(next); } return result.value; }; return next(); }; const getItems = () =&gt; Rx.Observable.of(['Oslo', 'London', 'Paris']).delay(300); const getDetails = item =&gt; Rx.Observable.of(`details for ${item}`).delay(200); Do(function*() { const items = yield getItems(); const results = []; for (const item of items) { const details = yield getDetails(item); results.push({ id: item, description: details }); } return results; }) .subscribe(item =&gt; console.log(item)); This returns an Observable sequence of each item/description pair. If we instead wanted an Observable sequence of all item/description pairs, we simply return `Rx.Observable.of(results)` instead of `results`. Here's an example: https://jsfiddle.net/7y3zcdt5/
[Flowtype](https://flow.org/en/docs/react/components/)
That's true. IANAL, but you should always look at your employment contract because most of them come with an IP agreement that says the company owns everything you do (enforceability differs from state to state, of course, depending on if it's actually related to their business). I usually have that removed if possible, modified to only specify during working hours and on work equipment, and I list every single project I have (or have thought of) in the "prior inventions" section so they don't own anything.
Cool writeup, I'd love to see your pinball code!
First class function, closure, high order function, you can curry a function with bind method or using arrow function, function constructor, etc...
I honestly never heard of Dojo until I read this article, which leads me to wonder if it's written by one of its team member. 
[removed]
Story of my life.
Oh man. I haven’t come across fantasyland or staticland. Definitely checking those out. I agree with the sort of “heaviness” that comes with relying on a lib like lodash or Ramada. Being able to port Haskell papers into JS is a skill I very much strive for, that is super rad 
Nike owned the software since it came out of one of their projects. They were going to throw it away since it had a bunch of core flaws and he rewrote it in his spare time.
Spammed? I cross posted to webdev, javascript, and node. Once.
A class should contain data and the operations that work over that data. They are the nouns of your program. A function performs an operation. They are the verbs of your program. You can decide to define a set of functions that all operate on the same set of data in a way that is equivalent to using a class but that choice is largely stylistic.
Well my friend would rather post for himself but there are rules. Also its a github link, not a blog. I'm not making money off this.
 const response = loadConfig() .then(buildDic) .then(getApp) .then(getRouter) .then((_) =&gt; getDispatcher(_, request)) .then((_) =&gt; dispatchBusinessLogic(_, request, new Response())) .then(renderResponse) .then(buildResponse) .then(emit)
I am new to programming and have used The Web Developer’s Bootcamp by Colt Steele on udemy.com. I’ve learned HTML, CSS, and javascript from it and i’m over halfway through the course. I’ve learned enough from it to have started to get job interviews based on my portfolio, so based on that i would recommend it! But I have nothing to compare it to, this is the first thing I have tried. 
Object-oriented programming is not *better*. Like with anything else, there are places where it makes more sense and other places where it makes less sense. We're kind of on the back end - or maybe finally now out of - a faddish phase where OO programming has been considered at times the *only* correct way to program, and perhaps that's the spirit in which you've been taught that OO programming is better. This was encouraged by the fact that two of the biggest languages - C# and Java - are OO without any other choice. JavaScript lets you do it either way, and even gives you a choice of how you want to do OO programming (prototype oriented versus pseudo-class oriented), which means that you're free to choose what's best for you and your use case. So objectively, neither is a better practice. It depends on what you're using it for and what you're comfortable with. For my own part, I tend to stay away from OO programming entirely in JS, but that's because it's my preference, and there are still times when OO just makes more sense.
It is. That said, the overall series seems to be pretty fairly written.
[removed]
Thanks for your response! Making the entire working area in svg is probably the simplest solution, though I still struggle with the specific architecture. I've added an example picture of what I'm trying to achieve: https://i.imgur.com/9iwXdWB.png
"[JavaScript: Understanding the Weird Parts](https://www.udemy.com/understand-javascript/)". It has been widely recommended around this sub and I endorse it. It's simply one of the best Javascript courses around, straight to the point and really digging into why things work the way they do on Javascript.
You're probably right, but I'm not sure how I should avoid messing up the coordinates of the link lines (they are transformed and zoomed by the field SVG container). I've added a picture of what I'm trying to achieve, if it helps.
Other than name and interoperability, there's pretty much zero in common between Dojo 1 and Dojo 2, it's a complete rewrite and it's worth a look if you can get over the past. :)
The point of the 11 part series is to ask a bunch of questions, not to pick a winner, because yes, the details will get outdated.
If you are a semi beginner I think the best place for you to start would be with Kyle Simpson’s (https://frontendmasters.com/workshops/deep-foundations-of-javascript/)[deep foundations]
fwiw, it's not hidden in the 11 part series, the author says that they work on Dojo, but as far as trying to be as unbiased as possible, the series does a reasonable job in my biased opinion (see below). The series does not pick a winner, but instead just asks a bunch of questions, gives a way to possibly answer them, and leaves it to the reader to try to decide. It's probably worth reading the first 10 parts before the conclusions post to understand that though. Conclusions and summaries are actually the most difficult thing to try to write here. Yes, there's a goal here to raise awareness about Dojo 2 which is going to be finalized soon, but the genuine goal was to take a very in-depth look at frameworks compared to the shallow analysis we often see. Is the perspective perfect? Of course not, but at least we tried. And we absolutely are not trying to be a link farm or create poor content, but your opinion might vary of course. Also, as far as I know, we didn't submit the post to Reddit, someone else did. Disclosure: I work at SitePen and was the editor for the series. We try exceedingly hard to not be biased and be reasonable and fair. I know it's easy to be skeptical, but we're a small company just trying to help.
... to go into production, how long do you have to code? Depends on the feature and scope of work. For me, my first project was a blog frontend - templates/style sheets/assets with programmatic features like DOM manipulation, analytics and SEO. I had a basic understanding of HTML/CSS/JS at that point and just winged it more or less. took about a month from conception to design to deployment. I don't know that I'm that advanced in knowledge, haha, but I've been told by experienced colleagues I could get a frontend engineering position based on my current level of experience. Truthfully, I think having that UX/UI designer knowledge of graphics, typography, organization, and interfaces will go a long way towards helping you understand the bigger picture so you can focus on the development side of things. I started off with vanilla JS to learn the basics of the language and the DOM. DOM, or document object model, comprises custom user interfaces beyond what you get out of the box via HTML. If you're interested in UI, you'll get to know it well. https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model Concurrently, I learned HTML/CSS since they all go hand in hand for frontend development. Around that time I was messing around with d3, p5.js, ThreeJS, and Phaser (a game engine for web) because I was attracted to all the neat visual things they could accomplish. They're intuitive (except for d3) so you can build stuff with a rudimentary understanding of JS. Then I dove into angularJS - angular 1 as it's sometimes known - which web developers will tell you is out of fashion, but for someone who is just learning and doesn't have production app reqs, is such a wonderful experience to learn web development and it's capabilities. it takes some time to learn the functional and object-oriented aspects of the language to appreciate how all these libraries and frameworks are built and how you can begin to combo them to get really interesting results. I don't believe there are any shortcuts, but there is no right wrong place to start. Just start somewhere, anywhere where you think 'oh that's cool! I wanna learn how to do that!.' If you have an example, ask me and I can direct you. web dev ecosystem minutiae - so much of which would be the equivalent of bickering about whether Axure or Sublime has better plugins to manage your annotation layers - are nerdish conversations about tooling, which to be fair is much appreciated since it makes my life easier, but isn't my chief concern as a designer. Honestly, I don't think it matters whether you decide to go with angular5, react or vue. Just pick one and rock it. They're distinct from each other, but their goal is the same at the end of the day, which is to build a web app. Don't worry about componentizing and optimizing at first - these are engineering concerns that pertain to a larger system. If and when they become relevant concerns to you, you'll know why. Until then just be free and play with whatever you want. Gosh, there are so many resources to learn. My two cents, find someone who teaches coding from a designers perspective. It'll feel more familiar. But to get a broader sense, start here: https://www.gitbook.com/book/frontendmasters/front-end-handbook-2017/details I learned primarily from books, videos, web pages. But the most important place is spending time in your browser. Dev tools is hands down the best. A good teacher on YouTube is funfunfunction - he's hilarious and shows you very practical examples. I discovered him a little later, but I wish I had known about him earlier in my studies. Good luck! 
As the author of the blog series... I don't know who laravel_fan_99 is, nor did I submit or encourage anyone to submit it. I tried my best to be frank about Dojo 2's development. It is hard to know its drawbacks because it isn't really there yet. Take that for what it is worth, like the rest of it. I didn't write the series as a cheerleader of anything but tried my best to highlight thoughts and considerations people should use. Too many "this framework vs. that framework" are single dimensional and I feel that does an injustice to the topic. If all you took away from the series is faults in it, then I don't feel you understood the spirit of it, which is better understand what your needs are and consider it. If you thought there was any clear "winner" or "loser" again, you misunderstood the point. I felt I conveyed it effectively.
No, being the author, it wasn't the purpose at all. If I was trying to sell Dojo 2, I wouldn't choose to do it over an 11 article blog series and if you think any framework came out "on top" (especially Dojo 2) you didn't read the article.
Thank you for the info! My professors have been DRILLING the idea that OO programming is superior into my head for the past few years now. It's refreshing to hear that I can finally divorce myself from that incorrect standard they were trying to shove on me. Thank you for the thorough response! 
Some great stuff on youtube if you hunt around like this: https://www.youtube.com/user/learncodeacademy/playlists If you want to pay check out this site: https://frontendmasters.com/ I found the ones by Kyle Simpson to be good. 
I would recommend looking at online database schema designer tools. Many of the ones I've seen do similar things to what you are trying to do with drawing lines that link tables together, but the tables are not SVG elements. This hybrid approach is probably the best way to go. https://dbdesigner.net/designer?landing_guest=true
the best is freelance contracts that say the same thing... *always* read your contracts people.
Strictly speaking this is untrue. There are a few ES6 features, such as WeakSet that cannot be used it even polyfilled in ES5. Another advantage of using ES5 is that it can be written and executed without a compile step.
yea, makes sense. why even attach the "help wanted" if you don't want to connect with the community though? i think one reason they're ineffective is that there's no visibility (this was the motivation for github-help-wanted.com). also worth noting: unlike up-for-grabs and some other projects, this project is not necessarily built to connect with beginners. More likely for regular contributors. I used it to search for "help wanted" and "docker" labels within "javascript" projects because i think i have some expertise that i'd like to share with the community. that helped me connect with some pretty good projects.
&gt; it would just be syntactic sugar Would it though? For example, it's often said async/await is "just syntactic sugar for promises", but they have a deep impact on stack trace collection. Arrows are also often labeled as syntactic sugar but they have a bunch of somewhat obscure differences. This is also the case with classes. And on the topic of async/await, how would one await in the middle of the chain? `foo |&gt; await bar` implies it's equivalent to `(await bar)(foo)` rather than `await bar(foo)`, and those are completely different things. So then is `await |&gt;` a thing? And if so, should things like `yield |&gt;` and `new |&gt;` be things too? Suddenly refactoring option 2 from sync to async (change `foo()` to `await foo()`) seems far easier than doing it with option 4 (change `|&gt; foo` to `|&gt; async (...args) =&gt; await foo(...args)`) -- not to mention we now have an extra anonymous stack frame in the stack trace Should these be equivalent? `color: ${x}` |&gt; styled styled`color: ${x}` etc etc. I'm all for good additions to the spec, but imho a spec proposal worthy of stage 4 status needs to have answers for all of these questions and more.
Hey there, I was one of the main people that worked on the original, Juno-specific version of Burnside. I'm curious as to what kind of core flaws you were able to fix in your re-write.
Former Nike Engineer here. Burnside was originally developed years ago at Nike. It was one of the first products being discussed for open source when Nike started letting down its guard about such things. However, like every other codebase under discussion, it was deemed unfit for external eyes. Nike culture doesn't mesh well with the tech community (though it seems to get better as time passes). As with all the things being open sourced there, Ben must have marshaled it through the open source process with much personal effort. Nike views this repo more as a recruiting and community involvement effort, not really anticipating its usage outside the organization.
Here is a docker and node package to abstract away the complexity. The user only needs to specify an input and output directory. https://github.com/MFoster/esngin
You must have missed the implied /s, but generally speaking each language _does_ have its own conventions regarding case, indentation and such. More so these days than before with all the code sharing in github and all. It _is_ important to follow those conventions so that each language is immediately comprehensible to other programmers looking at your code. In javascript capitalized variable names have a loaded meaning, so much so that linters would yield warnings out of that dudes code. And yes, based on what I've seen over the years, someone's experience in language correlates heavily with his adherence to the conventions of that language. There exceptions, but they are few and far between. Src: 33 years of programming experience with ridiculous amount of languages.
If you've been hammered over the head with OOP at school, I'd say try a functional approach for the exposure. Use lambda etc. It really does pay to know how to solve problems in different ways. 
&gt;Which is a better practice objectively? While I'm tempted to answer this with platitudes ("the right tool for the right job", "keep it simple (stupid)", etc), what it boils down to is that complexity is bad. The more complex you make something, the harder it is to work with and maintain. Because of this, you want to always use functions when you can, and only use objects when you need to maintain state. Which libraries you use will influence this greatly. If you're using a library like Redux you may never use a single object, because all your state is held in a Redux store object. Conversely if you use a library like Backbone (and many other "MVC"/"MVVM" frameworks) which is class based you'll have objects for your models, views, etc. But whatever your library choices, the essential thing to remember is to not use objects (or any complex structure) when a simple one will do. While it's possible you'll later find you need to add state to a few functions and convert them to classes, this shouldn't happen too often, and if you've been writing good unit tests as you go it should be a pretty quick/safe change.
Can you ask this in the repo where he can respond with links?
[removed]
You also need to use stateful components in React when you want a PureComponent, or to control when it updates.
I'm a little confused about what you said, but usually a 3rd party ticketing system is going to be in an IFrame. So it would be essentially un-editable to you.
udemy has frequent sales. Yesterday this course was $10 and now its $175. Sometimes the links from youtube have a price cut, this brings it down to $19 https://www.youtube.com/watch?v=Bv_5Zv5c-Ts
What's Juno?
Is it a thing? No it's not, it's totally bizarre and if I were using an addon that tried this shit - instant drop If you can't find an alternative, you could apply your own class to the parent div you did create and use subselectors div class="why-did-you-do-this" And your CSS would be .why-did-you-do-this &gt; div { // hey assholes this isn't how the internet works display: none; } Ideally you wouldn't ever remove why-did-you-do-this from the parent class too :P
I mean I hate to be this guy, but the GitHub username of the author of burnside used to match your reddit username, so I have a hard time believing that... https://github.com/scottcheng/cropit/issues/37
JUNO LIKE THE MOVIE!?
My apologies, I was being sloppy with my language. What I meant to say was "stateless functional components", not "pure components" (the two get used together so often I had a brain fart and thought the two statements were equivalent). I have corrected my post.
Huh? My point was that you mention you should only use a class in React when you need state. My point is you can't control when a component renders if it's just a function. Ergo, if you need to control when a component renders, it has to be a class, even if there is no local state.
you mean vega?
The word 'like' is used for too casually in conversation these days. Ironically we are talking about Facebook 
Ah, what I was trying to say was that if I'd just said "stateless functional components" in the first place instead of "pure components" your comment mostly wouldn't have been applicable ... but you do have a good point (regardless of my edit) that wanting to control rendering is also a valid reason to use a class.
I think he's saying it's not an iFrame, but even within an iFrame you can technically reach inside and mess with the styles and classes. I'm betting the tool is doing something stupid like removing any class/style that doesn't belong to them. But what kind of addon would check its own CSS? It's such an inconceivably strange concept
That's great. If you're looking for a more lightweight alternative may I highlight S6 that now includes a rebooted Bespoke.js-compatible microkernel. See https://github.com/slidekit/s6 Cheers.
Most of those are just a result of first class functions. I could write a long list of the effects of OO as well. "function constructor" is just a funky way of creating objects.
You and what army.
I never heard of Spectacle 1.0.
Strictly for games, I've found that the prototype/OO style is really light when it comes to functional objects because you can have most of your common logic outside of the object. This matters when you're considering thousands of functional objects and have to iterate through all of them even for the spatial partition step prior to logic. Keeping your objects light really helps. There's also the added benefit of being able to JSON.stringify() the objects into a database and not having to worry about the prototype functions because all of the object values are within the functional object. When I say functional object, I mean using a function as the game 'class' not {} The differences between function based 'classes' and actual classes is minimal, but I've been using the 'old' way so long it's hard to move to the new way. Something like Object.defineProperty() is really great and you can manipulate it to easily handle observables. Something like wrapping it around the health of a player so that a UI element is automatically updated whenever that variable on the player class changes. Simple stuff but it makes things easier. My way is by no means the best, writing a game in JS isn't the best way, but I'm not about to sit down and write assembly either.
I worked on a proxy API for Instagram's public data over the weekend. You can use it to build Instagram galleries, clones or use it on your own blogs to share your images. https://github.com/whizzzkid/instagram-proxy-api
Currently €15 for me, try it with VPN if you don't get a discount today
egghead.io has a lot of good javascript courses
Definitely would love to have the pipeline operator. Been missing it since I started using elixir. So many times I end up using `_.flow()` but it's nowhere near as terse. Bit disappointed to see a lot of people here against it. My assumption would be that they tend to come from an object oriented language background and don't take advantage of the many functional programming tools that JavaScript provides. It's not a one or the other, it's both, but there is no point nerfing one just because you use it one way. I'm actually surprised, that a prototypal language that has first class functions doesn't have something akin to the pipeline operator.
yeah, you are right. Javascript is all about functions and objects. Not about class or typeclass. I dont know what you mean by effects...
Very nice! 
No. It's a toolkit for writing web-based slides using React components. The presentation itself is actually a React app. Spectacle is an alternative to Powerpoint, Keynote, and Reveal.js. Example from the [Basic Concepts](http://formidable.com/open-source/spectacle/docs/basic-concepts/) section of the docs: import React, { Component } from 'react'; import { Appear, BlockQuote, Cite, CodePane, Code, Deck, Fill, Fit, Heading, Image, Layout, ListItem, List, Quote, Spectacle, Slide, Text } from 'spectacle'; export default class extends Component { render() { return ( &lt;Spectacle&gt; &lt;Deck&gt; &lt;Slide&gt; &lt;Text&gt;Hello&lt;/Text&gt; &lt;/Slide&gt; &lt;/Deck&gt; &lt;/Spectacle&gt; ); } } I've used Spectacle for [all my prior public presentations](http://blog.isquaredsoftware.com/series/presentations), and love it!
It's a bug with avg, I might send them a msg
Aurelia is great, except for the fact that nobody is using it. I tried it over a year ago and project configuration was not so straightforward and there was no CLI. Is this better now?
Why not?
I only read the Vue part since it's the *libwork* I'm most familiar with now and the article is just wrong. For example: &gt; One of the bigger challenges is Vue.js is dependent on a single individual. Which was true a year ago, but not today. Also let's not forget that corporation like AliBaba are betting on Vue which clearly shows the brittle picture the article paints is just wrong.
Click on the "edit in codepin" button :) https://codepen.io/lonekorean/pen/KXLrVX
Derp, thanks!
Haha me too!
Lower your sodium homeboy
I used this about a year ago to make a really long presentation and it was an absolute joy to use. Thanks!!!
had it a look at this and looks really cool
cool. Also never heard of this before but looks nice. From the client side it looks very very similar to [reveal.js](http://lab.hakim.se/reveal-js/#/2) but on the dev side it's totally different. Reveal just uses plain html and you never need to touch JS if you don't want/need to) 
I think that is exactly what I need. I‘ve taken a look into the instagram api docs days ago because I wanted to fetch some public images, but it‘s really not that nice to work with. Thanks for your post! Will definitly take a look into it.
I originally created it so that I could easily embed react components into my presentations that were about React. I use this quite a bit for the sole purpose of touching JS in the context of the preso. That said, we have tags that you can use to essentially write your entire presentation in markdown, minus a light React wrapper.
Yeah I'm not putting in my email address to see "free" content.
No. The best you can do is probably something like lodash’s `pick()`: https://lodash.com/docs/#pick
good work! sorry didn't mean to sound like I was putting it down, just comparing the two. I love react but I have made only 1 presentation before and used reveal. Presentations are hard! Not the dev side but content-wise, plus the whole talking clearly in front of people part. I really want to improve my (non-existent) presentation skills
RE your edit: apparently not, but [even their free option seems reasonable](https://www.sanity.io/pricing) 
That's one way of doing it. Mozilla also provides docs on deconstructor assignments https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment
Their api is so annoying! I just want to fetch MY OWN images and I'm totally fine with putting a limit of my last 21 images. I was using their undocumented `/media` url which returned json but they just recently killed it. now I'm using `?__a=1` (which I see this library is using) but I expect that to be killed soon too. Their whole official api ecosystem is built around making apps to use oAuth to access anyone's feeds and I don't want that. I have a public feed, I want to include some of my images, let me just grab them dammit. can you tell this is a sore subject for me? lol
That’s basically what OP does with the first const declaration. Alas, you can’t destruct and construct at the same time.
I'm actually discussing this with OP right now. We agreed that it would be fine to declare, then destructure as they see fit.
Code?
To claim that this... const userList = []; function addUser(user) { return [ ...userList, user ]; } ...is a pure function is _wrong_.
It gets easier each time you do it. It never gets not scary, but it gets easier.
Use this code: PCWORLDOCT2017 it's 94% discount
I'd second this course. It won't teach you everything, but it will give you what you need to understand JavaScript at a foundational level and make any other course you take make more sense.
Just use a burner mail for that 
Your description is better than the one Spectacle has on the front page of their site.
Lambdas are good for performance if optimized correctly. Ocaml, Haskell, and SML all have very fast compilers and use lambdas as a core idea. Inlining and eliminating extra function calls is the key. JavaScript engine designers have spent lots of time making closures very fast. Likewise, hidden class design means that factory closures that return consistent objects should be able to be represented with the same hidden class making them essentially the same as a class except with true privacy. In the case of both closures and objects, the far and away biggest factor is consistent types and never adding or removing properties. Mutating code that violates these rules will be much slower than immutable functional code that follows the guidelines.
[removed]
Maybe backwards compatible was the wrong choice of words but I meant that code you wrote in ES5 will still work in the same in ES6.
What do you mean what would be the advantage? Either way you're using JavaScript. 
This proxy, just does that. https://igpi.ga/instagram/media/?count=3
We're offering support via email, Slack or StackOverflow. Feel free to ask anything...
&gt; Good, fast, cheap, pick two. I'm not sure I understand how this can be applied to the OOP / FP debate haha I agree with everything you said. Personally I've found that FP encourages writing code that is much easier to reason about... even following only the basic principals makes a huge difference. That being said, I love the structure of classes. There's no reason you can't write classes with methods that use the principals of FP!
This is the first I've heard of it, that I can remember. The only thing I can say, is that the dependencies seem a bit [weird](https://github.com/codaxy/cxjs/blob/14ba48e7e37865b9c9ae04732c9e2bd978b0462c/package.json#L101).
These are not the actual dependencies of the framework. Packages are located in the packages folder.
same. i was using the /media method to parse out recent images from json, which was all i needed for a simple pizza truck brochure static website. and then they just killed it off. now i need to add a whole back-end layer, implement auth, add sdk, etc. in order to display public data that the client gives to IG for free anyway. I could see requiring API for functionality that requires you to be a logged in user, liking, commenting, posting new photos, but for simply displaying profile profile images, it’s annoying. 
thank you! definitely going to check this out after IG recently killed the /media method of fetching json
This is an unpopular opinion?
Whats funny is i picked up jquery in the middle of learning javscript when i didnt really understand javascript yet. I loved it. Now that i understand javascript a lot more i cant stand jquery. It also annoys the hell out of me when i ask a javascript question on stackoverflow and someone comments "why dont you just use jquery?" Ummmm because im using javascript, thats why.
The good news is that every one of these "reasons" is actually the same, and they're all invalidated because you can simply give the function a name without changing anything else about the code, making it easy to debug.
So.. you agree with the post? Giving the function a name makes it easier to debug. 
Exactly! I also don't care about any interaction, I just make the images links to Instagram so people could interact there if they want. Use the ?__a=1 for now, the json is formatted differently and it returns 12 instead of 21 or whatever it was but it works
Yup. But that's the only change that's needed, and so this is a big deal about nothing. "Like the plague"? Pff. Far too strong for how trivial this is.
Maybe. Or maybe it’s a “broken window theory “ type post. Treat minor things with great care and the bigger things will fall into place as well. 🤷‍♂️
Search on yarn instead? It seems a bit better. The numbers are apparently measured a bit differently, but they are there! Also the search seems a bit more robust
Yes on both counts. Love it, never going back.
I've never wasted a large amount of time trying to figure out why the did something stupid.
If you want to `await` code in a loop you have to use a looping mechanism that doesn't define a new function. function asyncFunc(item) { return new Promise(resolve =&gt; { console.log(`${item} started`); setTimeout(() =&gt; { console.log(`${item} done`); resolve(); }, 100); }); } async function myFunc(iterable) { for (let item of iterable) { await asyncFunc(item); } console.log('finished'); } myFunc(['A', 'B', 'C']); // &gt; A started // &gt; A done // &gt; B started // &gt; B done // &gt; C started // &gt; C done // &gt; finished If you want to fire off all of your requests at once, then wait for them all to complete you can use `map` and `Promise.all` (note that in this case `map` must return an array of promises) async function myFunc(iterable) { const promises = iterable.map(item =&gt; asyncFunc(item)); await Promise.all(promises); console.log('finished'); } myFunc(['A', 'B', 'C']); // &gt; A started // &gt; B started // &gt; C started // &gt; A done // &gt; B done // &gt; C done // &gt; finished If you try to use `forEach` you'll notice that it fires off all of your requests immediately, and doesn't wait for them to finish because it's just synchronously running a function on each item of your array. `forEach` returns undefined, so there's nothing to wait for in the top-level async function. async function myFunc(iterable) { iterable.forEach(async item =&gt; { await asyncFunc(item); console.log(`finished ${item}`); }); console.log('finished'); } myFunc(['A', 'B', 'C']); // &gt; A started // &gt; B started // &gt; C started // &gt; finished // &gt; A done // &gt; finished A // &gt; B done // &gt; finished B // &gt; C done // &gt; finished C Also you appear to be using `map` as a `forEach` loop in your code (map is intended to 'map' things (in the mathematical sense) ie [a, b, c] =&gt; [f(a), f(b), f(c)]), and you're passing an if/else block as a function argument.
Readability, debug-ability and code economy are three distinct reasons.
The claim is that by changing one thing, you win in three separate ways. The point is entirely reasonable. And this is javascript, people are constantly demonstrating the anti-patterns in this post. I see it at work, I see it on Stack Overflow. You may not do these things but many people do without much thought. Not so trivial.
Yep you do it like this: const imageObj = {public_id, secure_url,width, height, bytes } = result Also there are other cool things you can do assuming you're using babel. the `rest` operator: const {public_id, bytes, ...restOfTheData } = result now `restOfTheData` will have all of the data except the ones previously listed.
For invalid inputs I'd always throw an error. Invalid inputs means the entire operation is undefined, let alone the output. For cases where the operation being performed is still defined, but not the output (for example something like `getProp(obj, key)`) I'd say it's reasonable to return undefined (or null) or throw depending on your use case. Plus, like you said, a descriptive error message is miles better than silent failure for debugging.
JS noob here, but wouldn't giving the function a name make it not anonymous?
Ah yes in that case it makes perfect sense. Someone on stackexchange just said this: &gt; Every throw you add means the consumer of the API needs to write extra code to handle it. Isnt that a good thing?
Did you forget to "return" the result of your ternary operator? return (aPrice &lt; bPrice ? -1 : 1);
Open Street Maps API or leafletjs?
Well, I just reinstalled my os, I guess it'd be in actually changing the icon for the program and not just the taskbar icon. 
Good thing you had those emojis or I wouldn't have understood the comment. 
I wouldn't say it's necessarily a good thing, but I also don't agree that it's true in general either. If you're passing valid inputs most functions shouldn't throw in the first place, so you probably don't need to wrap every API call in a try/catch.
Sorry I won’t use emojis any more!
Yea that doesn't work either. It just returns all of the properties in the result object since it overwrites the constant = to result at the end.
https://npms.io/about
[removed]
This is what I do. Since npm 5 was released I tend to stuck with npm on the command line, but I find the yarn website much more useful for finding packages.
a faster way is to use gql
A lot of financial firms are using it. A buddy of mine owns a consulting firm and hes doing mostly extjs work for major wall street banks.
why is this labeled NSFW?
Hey, are you part of the team? Is full support open to everyone or just people that pay for commercial use? - I plan on launching the app, I would just appreciate the support for a free build build leading up to launch. Also, do you have a link to the slack channel? Thanks
Curious what the use case is here? And why can't you just do ``` const { public_id, secure_url, width, height, bytes, } = result; const imageObj = result; ```
You just taught me something with that first example. Thank you.
[removed]
It seems OP wants imageObj to be a subset of result. What you’re doing is making imageObj the same as result. 
A full featured version is the instagram private API. It doesn't have the API limits the direct IG has and you don't have to rely on an intermediary. Lib has a decent sized community around it as well. https://github.com/huttarichard/instagram-private-api
How’s lodash/fp compare to ramda? I’ve been using ramda for awhile and really like it. 
&gt; but even within an iFrame you can technically reach inside and mess with the styles and classes For clarification, that only works if the IFRAME contents is from the same host name as the host page's (the one that host the IFRAME element). Otherwise, no code from the host page can even get a reference of the IFRAME contents' `window` object (or vice versa).
Thanks for this, but I think, sending a get request https://igpi.ga/instagram/media/?count=3&amp;callback=foo should be enough for most of the people who just want to have their instagram posts on their blogs. like https://nishantarora.in
Try this for testing. 1. Turn off JavaScript (not via browser addon). 2. Open Web Console. Make sure the context is set to the current browser tab. 3. Select the element and save it into a variable (via console). 4. Modify the element (via console). If it fails at #3, the element is served in an IFRAME. #4 would be impossible to achieve. If #4 succeeded, that third party ticketing system includes a protection code. Don't forget to turn JavaScript back on.
From [here](https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/) (the first google result for "javascript what is a source map", by the way): &gt; Basically it's a way to map a combined/minified file back to an unbuilt state. When you build for production, along with minifying and combining your JavaScript files, you generate a source map which holds information about your original files. When you query a certain line and column number in your generated JavaScript you can do a lookup in the source map which returns the original location. Developer tools (currently WebKit nightly builds, Google Chrome, or Firefox 23+) can parse the source map automatically and make it appear as though you're running unminified and uncombined files.
The point of anonymous functions is that they **aren't** reusable. They only make sense in the context they're used in. Because they only make sense in a single particular context, it makes no sense to give them names. **Counter-argument** Fuck maintaining all those functions. Following your example, turning those would-be anonymous functions into named and dignified functions means you gotta maintain and write unit tests for each and every one of them, when those functions likely don't even make sense outside of the context they're called in. Not everything needs to be reusable. This philosophy was the same that birthed that sad abortion of programming language that is verbose and boiler-plated ridden Java. Guess what the programming visionaries of today said to Oracle back in the day? Fuck your boilerplate, Fuck your templating, Fuck your Interfaces and Strategies, we're making making Javascript, bitch. And they fucking did it. And they made it functional for a reason: to symbolically and metaphorically (and literally) give Java Enterprise programming culture the middle-finger and the f-word. I, for one, vehemently reject this idea of regressing back to the land of endless boiler-plate. MAKE APPLICATIONS NOT CODE. &lt;/rant&gt; TL;DR: So yeah, I'll avoid your **non-anonymous** functions like the plague.
no commitments on that, could be today or could be never.
Yea, so the result object is returning more results than I need in my API. The result is equal to a cloudinary response, I only need the deconstructed things from result. My conclusion is that there isn't a way to shorthand it, which would be a nice feature in the future if possible.
Yeah, then I’d second the top comment of lodash.pick or ramda.pick for now. 
I am developing a simple user interface, in which I want to add lazy-loading concept on the text using 'vanilla' JavaScript. I this right now I am displaying information about 10 users only. When I am going to scroll down I want to load the rest of the information. For that, I find out the current scroll position. If it reaches the bottom, want to append next data to existing one. I tried to append the simple text,It worked. But it is unable to append elements from div. How should I rectify that code?? Thanks..!!
Hey, thank you soooo much on this tips, help, and explanation. Just one thing, is it possible to get your email or messenger? If i ever have any question to ask? DM me if yes. Other than that, i will look in this book or YT channel. I don't know any coding designer who would teach me, only programmers (front-end), but i find it a bit hard to learn from them because they explain on programmer level.
First learn the basics (vanilla JS), then put a framework or library on top. It doesn't really matter which one you use, but from my point of view I would recommend react. The [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript) is a very good and up to date resource for javascript. It is pretty fast I would say. Many big companies are using node widely in production. 
The best solution for your example are types. Add types and don't do any checks whatsoever. It's the least amount of work and you get immediate feedback. 
Learn vanilla js first definitely, ES6 is just syntax sugar
Learn vanilla JS first for sure. JavaScript isn’t scalable (or any of its frameworks really) (id argue) (and it’s not a bad thing if it can’t scale well) but something like TypeScript is scaleable imo. I pm enterprise software and C# and TypeScript work really well together for our needs. Then again, if you get really good at JS and avoid pitfalls you could build a JS/node app that’s faster and more secure than a C# compiled application. As for time, JS should take you like 6 hours tbh. It’s super loosely typed that you can get your hands dirty real quick. I’d suggest Brackets as a IDE cause you can preview in real time extremely easily! Good luck! 
Yes, I'm the lead developer. We offer support for everyone, however paid customers have priority. You can get a Slack invite on [our support page](https://cxjs.io/support). We're also making some changes regarding pricing. CxJS will soon be free for startups.
1. Yeah, learn vanilla JS first, since ES6 is mostly a syntax-sugar. Then learn the difference with ES6. And there is no point to learn TypeScript or any other similar stuff, unless you have to work in project where it's in use. 2. Personally I can't learn technical stuff from books, prefer learning on the fly by doing some tasks. For example, look for one of online coding games. 3. There is no "best" frameworks, all of them is temporary hype, yet currently React is most hyped I guess. I'd suggest try and learn different frameworks and approaches, starting with plain JS, then doing something with library such as jQuery, then maybe Backbone, then React. Optionally check Angular (it's widely used), but personally I hate it. 4. JS with node.js is VERY fast on server, probably the fastest stuff in a context of web. It's more-less easily scalable with workers and so on in terms of performance and easily scalable with proper modular architecture in terms of size of code base. JS is single-threaded event driven by default, but you can use workers manually or with one of lot of modules. In fact, workers are relatively rarely needed in web.
The issue with this approach is IntelliSense in not really working with such constants. Usually you definitely want an IntelliSense for condtants like actionTypes
oh that sounds great. Cheers, I'll join the slack and get stuck in.
inb4 people don't realise that ES6 is Vanilla JavaScript
Ofc you can use it, but you need to ask yourself one question: Do you data will be duplicated? If yes, Firebase is not that great solution. Aside from that, using Firebase is quite simple, problems are starting to rise when you are making advanced things (I had for example problem with making function working on HTTP request - that function was making changes to images in storage).
[removed]
Awesome. Thank you
Thank you, I think this may be the best for me as I don’t need to start at the beginning. I’ll check it out 
The writer of Eloquent Javascript is working on a third edition that will include ES6, but I wouldn't wait for that as I think the current version is still really good. I don't think there's anything necessarily wrong with learning the new ES6 syntax early, as its part of the core language now. When ES7 features are added and considered mainstream, nobody will consider ES5 'vanilla' Javascript which new developers should learn before they touch ES6 and finally ES7 features. Having said that, I imagine most Javascript fundamentals learning material you find may not have been updated with ES6 changes. Just find any course that works for you, but supplement it with your own researching - if you're unsure about a particular topic then search for it on MDN - for example their [functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions) page is excellent, and includes new syntax from ES6. Whatever you do, I think most developers would recommend working on personal projects as you might find that a more enjoyable way to learn.
Cool that takes it down to £10. Now to see how much FrontEndMasters costs
**Bad way** Let say you want the age of a person, written in html like this &lt;div id="123" age="25"&gt;&lt;/div&gt; Then you can write this is JavaScript to get their age var age = document.getElementById('123').getAttribute('age'); However using the data attribute is encouraged. **Good way** Your HTML looks like this now &lt;div id="123" data-age="25"&gt;&lt;/div&gt; And now you can use dataset to get the age var age = document.getElementById('123').dataset.age; If you want to support IE, then you have to use getAttribute(), because it doesn't support dataset. https://caniuse.com/dataset/embed/
It generally depends on what type of contracts (interface contracts) you're willing to sign. And this, in turn, can depend on the particulars of the situation. I mean, your `sum` function establishes a contract and depending on what it is part of, on where it works, you may prefer to opt for one solution or the other. Say `sum` is an _internal_ function to its context. That is, there are other layers involved before `sum` is called. You may then choose to implement validation in those layers and allow `sum` to assume its inputs will always be _valid_. Or say `sum` is an external facing function on a library that will be used in projects beyond your reach (i.e. someone downloads it and uses it and you don't even know). Further more, let's say in that context `sum` is not a core functionality but some sort of helper which people will rarely use and mostly for non-critical purposes. Then it _may_ make sense to just return `undefined` (or maybe even return some _neutral value_). But then again, say `sum` is again an external facing function on a library, but it is a _core_ functionality and will be called often and critically (i.e. current process simply _can't_ progress any further if this fails). Then it seems quite reasonable to throw, because you _want_ to make it fatal and you want the developer to notice and take responsibility. There are, of course, many other circumstances. What are the community's customs? (For various values of "community".) Just _how critical_ is having a correct result from `sum`? What _kind_ of validation is needed? Just type validation? Value validation? Additional imposed restrictions? The argument for performance is... well, it is something we should consider, of course, but it _can't_ be the main argument to determine this decision. Also the extent in which this can affect performance is _wildly_ varied, from no effect whatsoever to maybe some observed effect in a particular situation. As for people not reading the docs... Well, much could be argued about that. I personally don't think that should be a major concern to let it affect design, and it may be addressed through other means. But it may be important, depending on the circumstances. In general, trying to choose a hard rule that applies to every situation is usually a bad idea.
Firebase is an amazing solution to prototype your backend but the difficulties come when you need to customise your business logic and add new features. Also, you don't really own the data, you're completely dependant. It's one of the main reason, we decided to launch [Strapi](http://strapi.io). An easy-to-use backend solution to develop your API in minutes... We are still in alpha but we would love to hear your feedback! PS: Authentication is coming in the next release ;-)
Create function to do it: const imgObj = ({ a, b, c }) =&gt; ({ a, b, c })
Are you refering to JSDoc types? I use them anyway but if I dont do any checks whatsoever my function will (probably) throw errors in some cases when people use it with wrong types. Wouldnt it be better to have caught them before hand thus being able to provide a clear error message, instead of them having to figure out it while debugging?
I am happy to see you reflect my thoughts on that external facing functions should throw but internal maybe less. Thanks for your feedback you truly helped me sort out my idea of this whole thing. I am however strongly considering typescript from here on...
Thanks a lot! Why do you consider the first one as a bad method?
Good luck transpiring [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)? Not everything is sugar.
TypeScript is ok :) In this particular regard, it can help you with _type validation_, which does cover a lot of occurrences. The problem still remains, though, for other kinds of validation. (In other words, the more general question of throwing or not is also debated in statically typed languages)
Because it ensures that you don't fuck with the original attributes the id of the button could be the id of the element, while the data-id could be the id of the variable you assigned
Javascript is by no means slow. When people say javascript is single threaded, they are talking about the event loop. All io operations are performed in a separate thread, thus requiring an asynchronous style of programming. As it turns out, asynchronous io is a very very good way of building scalable applications, even though javascript is ultimately single threaded, which is why nodejs became popular on the server side. 
I am developing a simple user interface, in which I want to add lazy-loading concept on the text using 'vanilla' JavaScript. I this right now I am displaying information about 10 users only. When I am going to scroll down I want to load the rest of the information. For that, I find out the current scroll position. If it reaches the bottom, want to append next data to existing one. I tried to append the simple text,It worked. But it is unable to append elements from div. How should I rectify that code?? Thanks..!!
If you can use ES6 (or babel to compile back to 5) then your final suggestion can be written as: const persons = [ { id: 123, name: 'Joe', age: 25 }, { id: 456, name: 'Moe', age: 57 }, { id: 789, name: 'James', age: 14 } ] const uniqueId = this.dataset.uniqueId; const currentPerson = persons.find(person =&gt; person.id === uniqueId) 
ES6 is also vanilla JavaScript. It’s the language’s evolution, like the upcoming C++17. React ([Ember.js](https://emberjs.com), Vue, etc) are libraries and frameworks built on top of the language. Since ES6 onwards will be the default way to write JavaScript (and btw a nicer way too) I recommend you follow tutorials and guides that use it exclusively.
Ember is a framework while React is a UI library. (This isn’t my opinion; it’s what their websites say.) I recommend Ember for building complex application because it takes care of all the individual parts: UI, HTTP, and has very good addon ecosystem for almost everything you want to do. I use it professionally and I’ve enjoyed it so far. I’m learning Vue on the side and I think it’s fantastic too.
Ramda has better documentation IMO. But many people already have Lodash installed.
 Thank you. But here is another one issue. You need to search third party pre-sets to make your code working. And you could be needed about 5-20 such solutions. One of our company friend, 2 years ago decided to port 70,000 line s project on ES6. Result: Some presets did not work in FireFox, some brings much issues. All works took about 6 months! If to choose between troubles with pre-sets in Babel or TypeScript. I would choose TypeScript. But it does not mean, you will have problems. It could very long and nervous talk. In summary: I do not like to "Compile to JS". 
You are describing the exact reason why i am using a map. Your algorithm is O(n), because it possibly needs to look through the entire array, while my algorithm is O(1), because it calls the reference the directly. This is the algorithm runtime with the size of 3. **Using find** var t0 = performance.now(); persons.find(person =&gt; person.id == '123') var t1 = performance.now(); console.log(t1-t0); Time: 0.030000000027939677 **Using map** var t0 = performance.now(); personsMap['123'] var t1 = performance.now(); console.log(t1-t0) Time: 0.010000000009313226
The fastest javascript I ever saw run was still 3x or 4x slower than anything else we were running. And that was with a helper which I don't recall what it was. Javascript is slow but, in the browser, you have nothing else.
In truth given that nowadays a browser inspector (which you can also use for node debugging) gives you the option to jump into a function definition, the argument is not so strong. Also, 'reusability' is not a valid argument. You don't have a choice on the matter - if you want to reuse a function, it _must_ be either a function declaration (hence named), or a function expression assigned to variable (hence it will have a name, that of the variable). If you are able to use anonymous functions, they are not being reused
In a few years, no one will want to run React. In a few years, everyone will still be using plain javascript. I can't recall what the favorite framework on reddit was but everyone was using plain javascript. It's a sad question when one asks if they need to learn something else before javascript.
sorry jQuery
Being downvoted for recommending ember... Ridiculous
Ridiculous that you probably have 0 real world experience with Ember or real world web applications at all but would be religious about them. Otherwise prove me wrong. See, I’ll recommend Ember every day to everyone who asks of a sane web development experience. Heroku, LinkedIn, Apple, DigitalOcean, HashiCorp, Square, Intercom love it for a very good reason. You think you’re better or wiser than us?
French Vanilla with sprinkles 
I tried installing it via Yarn on windows, but it gave an error. NPM seems to have worked. I very much prefer Yarn now, so it'd be good to see that fixed. And when creating a project on Windows, I got this. Error: EPERM: operation not permitted, symlink 'C:\Users\aladr\AppData\Roaming\npm\node_modules\strapi' -&gt; 'C:\Users\aladr\Projects\strapidemo\node_modules\strapi' at Object.fs.symlinkSync (fs.js:1020:18) at availableDependencies.forEach.dependency (C:\Users\aladr\AppData\Roaming\npm\node_modules\strapi\node_modules\strapi-generate-new\lib\after.js:104:12)
I wonder if in the future you could just use web components + Vanilla Javascript + HTTP/2 + CSS3 instead of webpack + framework + UI-kit stack we have today.
Just learn javascript and you'll know React. Unlike many other frameworks it doesn't have that many foreign concepts. Class, function, few lifecycles, JSX (which are pure javascript functions), and that's it. As for 3, it's the [most used by far](http://www.npmtrends.com/angular-vs-react-vs-vue-vs-@angular/core) and the one that had and has the biggest impact. They're porting Reacts semantics to native languages and systems currently. 4. React Fiber is the webs first scheduler. It will make it possible in the coming months to write web apps that are actually as fast. Other than that, it can render natively on all platforms: Android, IOS, Windows, OSX, Linux.
So let's just ignore angularjs for a moment. For vue, angular, and most other modern js frameworks when you write an html template you aren't actually writing html. I'm not sure exactly how it works with vue, although it's probably similar since you can use jsx with it, but with angular the html you write is compiled into a Javascript function that returns the html nodes that make up the template. So those ngFor and v-for attributes that you write in the template aren't actually being put on to the real dom elements. They are read by the code that converts the template as instructions on how the function should look that creates the html elements. That's why they don't use the data- prefix that /u/Pavlo100 described. Because those "attributes" aren't really going to exist on the elements in the dom. That general idea of compiling html into a Javascript function is something you might want to look in to. Or you could use jsx like react does and just ignore this html to Javascript conversion. But either way basically none of the new frameworks are messing with attributes like you think they are.
I... I think he was agreeing with you and disagreeing with whoever was downvoting you.
My comment has been removed. I didn’t read it right and I apologize for blaming the wrong person. Also I don’t know when people downvote things I say (and I don’t usually care) so long as Reddit doesn’t ban me. 
Yep, you’ll probably still use some kind of framework, but lots of the stuff Webpack etc does now becomes standard behaviour or unnecessary once we’re all on http2 and native es6+
Great
The data- prefix is reserved for user-defined attributes. You're safe to set those because no native attributes will start with data-. This is not unlike custom html tags, though for those all you need is a hyphen in the name since no native html tags use hyphens. What comes before it is up to you (doesn't have to be data like with custom attributes).
Oh I'm sorry you got this error. I think you found an issue... Can you please [open an issue](https://github.com/strapi/strapi/issues) on GitHub? We will fix in the next release ;)
Or: http://10minutemail.com ;)
JSDoc comments sort of work, but tooling for that usually isn't that great. They are also somewhat bloaty. I'd go with TS. Someone who uses your library gets immediate feedback. If they use it incorrectly they get a squiggly. Additionally, there is no runtime overhead. 
Yep. It's for functions that don't make sense out of context. I'd hate to have to follow a chain of functions where they're all defined on the same level (with probably pretty meaningless names because it doesn't make sense to give a name to some random callback). A long Promise chain would be hell to follow the way he wrote it out because each step would require rooting out the function that's defined out of context somewhere.
Well spotted, i actually missed that point. *if* is not possible in HTML, because it needs to be evaluated, however *for* could be possible. **HTML** &lt;select data-for="options"&gt; &lt;option&gt;name&lt;/option&gt; &lt;/select&gt; **JavaScript** document.addEventListener("DOMContentLoaded", function() { var dataFors = document.querySelectorAll('*[data-for]'); for(var i=0; i&lt;dataFors.length; i++){ var currentElement = dataFors[i]; var childElementTemplate = currentElement.innerHTML; //remove childElements from the dom var dataFor = currentElement.dataset.for; //Assuming it is global (Don't make it global) var arrayObject = window.dataFor; for(var j=0;j&lt;arrayObject.length;j++){ var currentObject = arrayObject[j]; //Use childElementTemplate and replace text with currentObject variables } } }); In this case currentObject.name === options[j].name, so you would find the name text in the HTML and replace it with options[j].name
You'd be well served to learn vanilla JS before frameworks, but sometimes learning all of that without actually building anything is not satisfying. I would say start with focusing on learning Vanilla JS, and if that gets boring, go learn a framework to stay interested.
Learn typescript before react . It will be helpful
You certainly could create standard compliant attributes prefixed with data- and then write js to handle functionality of them at run time but then that's, kinda sorta, how angularjs works and one of the things that causes performance issues with it. Newer frameworks generally have an entire render mechanism that is handling these Dom manipulation ideas in completely different manners in order to keep performance high at run time. So while yeah this works it's still not very representative of how new frameworks are handling this stuff.
Going incognito works too.
ES6 is vanilla JavaScript. Definitely learn that first.
heh?
Yeah, I was about to ask what OP thinks ES6 is.
1) People will say that you should learn javascript. And that is true to an extent, but you don't need to know much more than the syntax, prototypical inheritance, and the most common apis like qureySelector, fetch, and bind/call/apply. The real deal is that most places are not hiring for vanilla javascript development, and I would largely avoid it if they were. There is still too many ways the browser differences can screw you, either now or in the future to be tied directly to browser apis. Do read 'elequent javascript' and 'the good parts' and watch lectures about javascript, particularly regarding its functional style properties and how to avoid mutation. But really, most companies want you know at least one major framework or library. Particularly jquery, angular, or react. Pretty much in that order. 2) Don't get hung on ES versions. Basicly there is ES5, which you don't want to have to touch with a ten foot pole, and modern javascript. Any decent build system is going to be using the latest es spec (and probably a few late stage proposals) and transpiling to whatever version your users needs for their browsers with webpack and babel-preset-env. 3) React is a very solid choice. It is just a view library, but the entire ecosystem makes it a complete solution. I've been using it for the last year, and it is really fantastic as you never really wonder why something is in the state it is in current. Especially when combined with Redux. (To be clear, start with React, and then add Redux so that you understand what problem it is solving.) The React/Redux combo is IMO the gold standard of how to do frontend development. No magic keywords or configuration. It is mostly just javascript, and all your data flows in one direction, which makes it very easy to understand when something goes wrong. It is a little more verbose, and it forces you into a pattern you may not like at first, but it is worth it. Angular is the most popular framework you'll see being asked for. There is a lot of angular code out there. But Angular 2+ didn't really take off as well. React really took the wind out of its sails, along with drama with angular 2 as it has been developed. If you like magic keywords and opinionated frameworks, you'll probably like angular 2 more than React. If you REALLY like opinionated frameworks and want a standard end to end solution like, say rails, pick Ember. But I pretty much never (actually not pretty much, just simply 'never') see any work for ember except listed as a 'know one or more advance javascript frameworks (React, Angular Vue, Ember)'. Use VS Code, and whatever plugins you want. Most of the javascript tooling are node based CLIs anyway. The plugins mostly hook into that, but you don't often need them. Node is just a runtime. You likely mean Express, which is the standard backend framework. People use it because it is simple. Not that there isn't a lot to learn, but for the usual stuck it is just plugins functions into each other. Node can be tricky to learn because nearly everything is async. Learn promises and async/await. 4) JS is JITC in all major js engines. But it still an unusually dynamic language, so there are less optimization that are available to languages like java and c#, which have static types and thus have stronger guarantees about object shapes. JS is fast, especially compared with other dynamic 'scripting' languages like python, but those statically typed languages are generally much faster for more representative workloads. Javascript is single threaded, which is why node is async 'non-blocking' by default, to get around this limitation. Node wasn't made to be an async language, it was an architectural decision to overcome this single threaded execution limitation.
JavaScript engines implement an event loop, and setTimeout(0) inserts a callback into the event loop, rather than simply executing the code immediately. You can find a simple explanation of the event loop [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop).
Javascript actually benchmarks higher than Python for numerical operations, which I find a bit amusing.
I think it's worth noting how some things are different in the previous versions of ECMAScript; for if you're working on older projects, but just stick to ES6 and then pick up React or another library once you need to.
Thanks, but the event loop and its checking mechanism, whether some time has passed has to be implemented somehow as well, right? How is the checking mechanism implemented there, so it doesn't hog resources? Naively, it also has to check at least every millisecond, whether some defined time has passed and whether some handlers should respond. Because the resolution of setTimeout() is milliseconds.
Thanks again, I found it myself in your link: &gt;The function setTimeout is called with 2 arguments: a message to add to the queue, and a time value (optional; defaults to 0). The time value represents the (minimum) delay after which the message will actually be executed. If there is no other message in the queue, the message is processed right after the delay; however, if there are messages, the setTimeout message will have to wait for other messages to be processed. For that reason, the second argument indicates a minimum time and not a guaranteed time. So it was a misconception on my part, that the second argument is a guaranteed time, while in fact it is only a minimum time. Makes sense now.
When you call `setTimeout`, `setInterval` or some other function that requires a countdown, the JS engine will hand the timer off to a timing thread in the host environment (while JS is indeed single threaded, a browser is not). When the specified amount of time has passed, the callback is put back in the stack for processing by the event loop.
+1 ember is still so amazing, especially when compared to other frameworks
WTF? I gotta look at the code, seems interesting!
One big difference is that the "wait queue" is implemented in native code. In the case of Chrome's V8 engine, that's C++. If you're interested in the general technique for this, you'd presumably want to look at [how waiting on a message is accomplished in C++](https://stackoverflow.com/questions/10974829/waiting-thread-until-a-condition-has-been-occurred). If you want implementation-specific details, you'd likely need to dig into the specific engine, since they would presumably vary, as the document notes: &gt;The following sections explain a theoretical model. Modern JavaScript engines implement and optimize heavily the described semantics.
Super Cool and Efficent! Will try it Real Soon!
Great Tutorials!
My advice on this topic would be learn ES6 first. Then pick your framework. I personally recommend diving into Mithril.js which is faster, smaller and easier than learning React, Vue or Ember. All these big frameworks will inevitably die in my opinion, it's just a matter of when. IF you are to build using a framework like Mithril.js you're gonna have an easier time maintaining because its mostly just Vanilla.
You won't be able to use X and Y framework and at their full capacity if you don't know the language in which they're written. By all means, go ahead and start familiarizing yourself with JS before ever writing a line of code in any framework if you're in this for the long game. If all you need is a quick fix then don't bother, the frameworks will be enough. Also be wary that JS takes a while to get used to do to its quirks - which are more of a blessing then a curse. Coming from a C# or C/C++ background will (like I did) you'll think you're in the Wild West with all these weakly typed variables running amok around closures and callbacks. But once you're in the saddle for a couple of months or so you'll get better and better at controlling the wild horse which is JS. 
Ah that makes sense, you mean an external thread controls the order of the JS message queue and inserts or reorders messages at defined times, controlled by the external countdown? &gt;the callback is put back in the stack for processing by the event loop. You mean "put back in the message queue for processing" I pressume? Would still beg the question, how the external counter is implemented exactly so it doesn't hog a core, but at least it is in another thread and wouldn't hog resources of the JS thread.
Thanks! That sheds some light. Now I would be interested in how the wait() function is implemented generally (big picture), so it doesn't hog resources or a core, if it has to check the condition so incredibly often, like at least every millisecond
Couple things that have probably already been pointed out but I will do it again. ES6 *is* vanilla javascript (in the same sense that C++14 is vanilla C++). If you're writing your own code, I would suggest to start here. What you're referring to as vanilla would be ES5. While it's falling out of favor, there's fuckton of it still out in the wild and still being written. So worth learning if you find that you need to. (good news is that it's largely a subset of ES6 so picking it up won't be too hard) Definitely learn Javascript before you learn React. It's kind of impossible the other way around, TBH.
React is like JSX, ES6 can be called Vanilla, Learn ES6 first!
Kind of following up on your answer to OPs question, but I've learned enough JS that I can dynamically update the DOM and program classical algorithms (sorting and whatnot) without having to think too much about it. I don't have a lot of projects with it though outside of a visual maze solver, a weather app that parses data from an API, and a vanilla calculator. Would you say that based on that experience, I'm ok to jump into a framework like React or Angular?
True, but doing it like the new frameworks first is probably a bit too hard if you want pure JavaScript. Obviously you could upgrade it later.
Yes, my wording was not optimal, message queue would be more accurate. The details on how the message queue is curated likely differ greatly between environments, but the main point was that the timing stuff is handed off to a native, faster and more efficient process that does the checking, so its performance impact is minimal. 
Anytime code runs slow it's obviously because the language is shit
Thanks, yes that definitely cleared things up to a great extend.
Thank you! I'm glad you like it!
It is always challenging for developers to choose the right framework for the project. Especially when it is 3 top JS frameworks like Angular, React and Ember. If we take an [Ember JS vs Angular](https://mobilunity.com/blog/ember-js-vs-angularjs-developers-2-business-models-to-build-a-team/) comparison, we will see that, Angular is more popular, thus it has a bigger support in IT community; it has simpler syntax and structure making it easier to learn for programmers, while with Ember they meet some learning curve, as it is more verbose. However, Ember is more opinionated for quicker development. As for React, it has even simpler syntax than Angular. Besides, it is weakly opinionated, which is a big plus, as it creates a lot of space for the developer’s decision. 
:D
To understand *that* requires going down a rabbit hole... The processor gets pegged when it's stuck in a single context executing instruction after instruction. The task scheduler isn't *certain* it can safely context switch, so it tries to leave it alone. With an event loop and a timer, this doesn't happen as the low level code is pointing to specialized hardware firing interrupts at predetermined intervals. Since it isn't the CPU, that doesn't affect the usage until the interrupt hits. That means that most of the time, the event loop is sleeping to wait for IO activity, and the task scheduler can confidently switch it out. What this means is that in JavaScript, you can transform a loop into a setTimeout/Immediate moderated one if you need to restore IO. Because each tick of the loop (or N ticks, if you find you can process more than one without suffering) is in its own context, the tasker is happy with you. This transformation might cause some readability pain, so use in moderation...
&gt;pure JavaScript What exactly do you think these frameworks are written in?
It sounds like you're really itching to build stuff, so do it! You'll struggle along the way, but that part never goes away (you just struggle with more abstract problems). Just try to be cognizant of when you run into issues that warrant taking a detour and going back to learning some fundamentals that you might have missed.
I don't know Mithril, but if you want to have a job, it's better to learn at least one of the leading frameworks/libraries
Learning ES6 first has the advantage of not bogging you down with learning the philosophies and quirks of a particular framework. On the other hand, learning while using a framework might give you concrete examples and let you learn more by creating something. Personally I would learn by playing around with the language but a framework us not necessarily a bad idea. I would recommend stuff written by Douglas Crockford and Eric Elliot. Can't say much about the frameworks. What's faster? Depends on what you do and how you code it. Java is better suited for certain tasks, JS for others. Not really a worthwhile discussion imo
No, I'm saying I have built those things already, so should I be able to jump into a framework or should I keep practicing other things first in vanilla?
Yes, always learn the basics first. Frameworks hide what happens but you might need to know what happens when you want to debug your applications.
You are right. The underlying system is written in pure JavaScript. I was thinking in Terms of Angular where you write in Typescript and the HTML has Angular syntax. But it is still JavaScript/transpiled Typescript that does all the work.
Totally agree. 
The operating system doesn’t need to spin in a loop to wait. At a high level it can note the time when the thread wants to wake up, suspend the thread, and then go do other things. Periodically it will check the time and wake up and threads that need to be woken up.
Sorry, I stated that poorly. It sounds like you're ready and interested! Do it!
You’re welcome. One caveat. The membership to frontend masters is $40/month. However there are a crap ton of realllllllllly useful and well thought out tutorials and stuff. Mostly talks by very prominent tech people and walkthroughs of frameworks or development patterns etc. Personally, my company paid for mine and I use it all the time. Kyle Simpson has a lot of classes on there. 
This is Python
1.) Yes learn JavaScript first, ES6 isnt fully implemented everywhere and is fairly new so make sure you have a strong understanding of ES5. If JS burns your nerves due to lack of types and your C/C++ training makes it feel counterintuitive then switch to typescript, but I personally recommend against this. 2.) Good book series. 3.) Frameworks are opinionated, and react isnt a Framework. All these frameworks and libraries are are tools. Use the right tool for the job dont get caught up in the hype. Go to the site of each one and **learn how information flows inside the application in each framework** or how it manipulates the DOM. 4.) If you want speed in processing write C++/Go, JS uses a VM like Java. Again right tool for the right job. Nodejs is excellent for writting rabiddly prototyped scale cloud based application. Basically anything that pipes data around for thousands. To elaborate, Paypal replaced a large portion of its Java code with Nodejs. https://rclayton.silvrback.com/speaking-intelligently-about-java-vs-node-performance Twitter was built using ruby at first if I recall correctly so thats a different conversation. 
Cool it, OP's obviously a beginner.
But it needs to check the time at least every millisecond for a resolution like setTimeout offers with milliseconds. How is this implemented so it doesn't hog resources? Performing some check every millisecond can't be really efficient right?
Thanks, very interesting! Looks like we are getting closer! O_o &gt; specialized hardware firing interrupts at predetermined intervals. Did you possibly mean "specialized hardware interrupts firing at predetermined intervals"? So it boils down to some internal, separate hardware timer, which exists "externally" and doesn't hog the actual computation resources?
When will we be able to use leftpad? This is an essential functionality that has to be embedded as 3rd-party dependency to a shit-ton of projects.
Pair-programming is the single worst trend that could happen to professional programming jobs.
It is and it isn't. Depends on the context. From a purist point of view, absolutely. In practice with transpilation, it is not. I think the distinction is still necessary.
I'm late so everyone's already pointed out ES6 is JS. But... It's absolutely useful to learn what code the browser actually runs. No Babel, no Typescript, no framework. Interact with DOM APIs directly, learn how closures and hoisting work, and all the other little oddities of the web environment. All of the best web developers I've worked with know how to track a bug down to the web platform API and that's a skill that's waning as bootcamp graduates learn React + Redux long before they learn to write ES5.
What is the script? Is something to do this task not already on npm?
Apology accepted.
&gt; How is the checking mechanism implemented there, so it doesn't hog resources? Every modern OS has a sleep function you can call that yields the current thread until a certain amount of time has passed ([`sleep(3)`](http://man7.org/linux/man-pages/man3/usleep.3.html) on Linux, [`Sleep`](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686298(v=vs.85).aspx) on Windows). While the process is sleeping it uses no CPU resources. If the JS engine knows it doesn't have to execute the next callback for 5 seconds, it just asks the OS to put it to sleep for 5 seconds. If you want to see an example of how this is calculated, `libuv` (the I/O and event loop library that powers Node.js) [has this process documented](http://docs.libuv.org/en/v1.x/design.html#the-i-o-loop). 7. Poll timeout is calculated. Before blocking for I/O the loop calculates for how long it should block. These are the rules when calculating the timeout: - If the loop was run with the UV_RUN_NOWAIT flag, the timeout is 0. - If the loop is going to be stopped (uv_stop() was called), the timeout is 0. - If there are no active handles or requests, the timeout is 0. - If there are any idle handles active, the timeout is 0. - If there are any handles pending to be closed, the timeout is 0. - If none of the above cases matches, the timeout of the closest timer is taken, or if there are no active timers, infinity. 
Because it's a pointless effort and effectively even more bloated browsers.
Wow this is awesome. Would be an awesome addition to the react-js, react-native, react-vr family 😁. Hey React contributors📣
Wait until you come to a company which have a dev-team consisting of three developers sitting in a sofa, sharing a keyboard, mouse and a monitor. I think they called it mob programming. They were so slow in getting stuff done.
However, depending on the situation, ES6+ can be used without transpiling, so one could argue that the transpilation step is now primarly for supporting legacy environments, and less for using "non-vanilla" features