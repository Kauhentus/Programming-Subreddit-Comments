This reminds me of the people who say Webpack is way too complicated. And I'm like: Here's my entry file, there's my output file, these are my loaders. And it works. Hooray! I totally understand that you can gather bad experiences if you stumble over tutorials you don't get or get errors by reading the wrong part of the documentation or whatever. But that doesn't make the products bad. I made bad experiences with RxJS, but I know it's my fault since other people can use it. I use Webpack and Babel in almost every project and they just work. No problems here. And yes, they do help me. Namely organizing my project files, shorten my code and make it slightly more readable.
https://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/
In so many ways
Can you source your x2800 claim against `document.querySelector`? I can't tell if you're exaggerating or not. 2800 seems too specific to be an exaggeration, so I don't think you are. I concede that `document.getElementById``document.getElementsByTagName` and `document.getElementsByClassName` are faster than `document.querySelector` and `document.querySelectorAll` respectively -- by an order of magnitude of 10, and maybe even 100. But not 1000. I haven't found any evidence for a speed factor of ~2800. Generally, people are curious about performance, so I've found several JSPerf tests for this. https://jsperf.com/getelementbyid-vs-queryselector/11 https://jsperf.com/queryselectorall-vs-getelementsbytagname https://jsperf.com/getelementsbyclassname-vs-queryselectorall/18 In the 2nd one, the difference is quite stark: ~x300 speed increase for `document.getElementsByTagName`. But it's not ~2800, none of them are. I understand that these are isolated cases, a bit contrived and unrealistic. But can you come up with any test case that would demonstrate x2800? I just don't believe it.
I didn't list them in order of priority. And indeed it is
By mentor, I meant anyone willing to help you, such as a co-worker.
Agreed, but I don't think you get taken into the "depths of javascript" as well as with the React toolchain and using that as a tutorial into the world of javascript I believe is good, because it introduces very little in the way of boilerplate (other than things like the React lifecycle which of course isn't needed if youre not using react)
Oh it was meant to be far more than just condescending.
Exectly) btw, native implementation is [coming](https://hackernoon.com/es8-was-released-and-here-are-its-main-new-features-ee9c394adf66)
It's always the incompetent people who can't make intelligent statements who try and turn the thread into something about me and not the subject at hand.
But there are elitist retards. It does not matter how you see/like it, if your hammer gets shit done, it's a good hammer.
It was meant to do something for your self-esteem, eh? Ah well, there's always next time.
Coming to reddit and seeing all these "answers" and comments always make me realize that, in life, there are always far lesser people than myself.
this guy
*ES2017
Yeahhhhhhhhhhhhhh
Would jquery be defined as a query selector here? 
ES8 was released today, get with the times 😛
I currently feel like Vue is a "best of both worlds" between React and Angular 2+. Definitely agree that it's the core javascript skills combined with the ability to *learn* a framework *when required* that really matters.
Thanks to Reddit Enhancement Suite, I see that my total upvotes for you is now +3. That's what I call "instant credibility". I've been trying to figure out "how much i know" and whether or not I should spend serious money on serious programming ed. Your post helped me answer this question. I started off strong with Scope, but then I remembered there's something odd about JS recursive scope relative to `this` and couldn't remember what it was... so I half checked it. Then i proceeded to uncheck everything else except design. IOW I don't know shit. I mean I know an understand `while` and `let` and hoisting and dynamic typing etc, but those are pretty high level topics. If I were living in an RPG, i'd have the skill "Familiarity: Programming" at rank 1 or 2, but "Javascript" 0 or 1. So thanks for your response... I now know where I stand. 2nd thing is. . . One thing I have to make a slight correction on is your point about Presentation . . . CSS/HTML are simple skills, but it doesn't help you understand basic design, which seems to be your point. If you're a seasoned programmer in any way, then they'll both take a business day to understand (and bookmark the reference for). But that doesn't tell you how to use them. I mean knowing what the 3 pedals are for and how to work the wand of power is great, but it doesn't tell you the nuances of driving in traffic. 
duuuudee, don't be An Imposter!! /s
Not while people still insist on IE support.
It definitely sounds fishy since I imagine it's just a wrapper over the more specific DOM methods with a simple parser on top
What are some security issues that ALL JS devs should be aware of aside from the obvious string sanitization and XSS?
all good, but gonna push back on node. Knowing when NOT to javascript is important too. And knowing more than one language is nothing but good for you.
in 2007 everything worked uniformly cross-browser?
1. Jquery selectors and jquery methods. 2. Arrow functions. but remember that "this" is bound differently 3. PHP. Its good to not be limited to one language. Sometimes PHP is easier to "get the job done." 4. Datatables. A great plugin for the web to make table formatting way easier. 5. Know the differences between Node and the browser. 6. Promises, and async in general. 7. Learn SOME kind of db structure/engine/etc. Lowdb is a cool json based one. 8. JSON. learn to think in it, as it is the Rosetta stone of the interwebs. 9. Array.filter(). One of the most useful methods in existence. Works pretty much the same in php as array_filter(). 10. the MVC design pattern. Most frameworks are moving this way, React, Vue, Codeigniter, etc. 
&gt; even if your app is english-only right now Absolutely. Sites reaching Canadian users often need (and are often required to provide) French versions. America is rapidly becoming bilingual English/Spanish - it's hard to live in Florida or Southern California without some basic Spanish knowledge. 
Sorry, but I disagree that security is best left to experts. Any worthwhile developer should not be writing software with the attitude that security isn't their problem, that *another* developer then has to make secure after the fact. Security isn't something you just bolt on later... Knowing the basics like how to avoid SQL injection, provide CSRF protection, and avoid XSS attacks are fundamentally important, and are NOT so complex that you need to be a specialist.
I think you're a bit too rigid with your interpretation. I'm guessing he's referring to using query selectors without caching the results. document.querySelector("div.user-panel.main input[name='login']").addEventListener('click', something); vs userPanelEl.children[0].addEventListener('click', something) Newer/less experienced devs often rely on jQuery selectors but never cache them.
Well it's called so because it reacts. JSX/hyperscript have made the big changes possible, the rest are more like implementation details, even cycle is very close to react in princinple.
You're not trying to scrape anything. Use something to `GET` the data -- [fetch](https://developers.google.com/web/updates/2015/03/introduction-to-fetch). And then update your `DOM`. It's a 1-2 combo.
&gt; Stay off reddit. Never come here for advice Slashdot's much better for getting thoughtful &amp;&amp; helpful advice. YMMV. 
Others have some good top ten lists. I will just add that every JavaScript developer should know everything in this playlist as the abc's of JavaScript: https://www.youtube.com/playlist?list=PLoYCgNOIyGABI011EYc-avPOsk1YsMUe_
This seems like a solid list! Any recommendations for the best way to learn about architecture?
https://en.wikipedia.org/wiki/Psychological_projection
I agree knowing the basics of any best practices are good, but that tends to lead to being satisfied enough. With security you should never assume you've done enough. Always have a security review step in your reviews, always have it tested by an expert... and never think that "the basics" get you even part of the way there.
Im getting at when people use layers of frameworks on top of each other. A leftpad situation. https://github.com/webpack/webpack/issues/1914 After 8GB it should compile right? well why are you compiling, because typescript, well why are you using typescript, because I need type... no learn ES6 proper. Webpack is a good tool, Im not saying that it isnt.
&gt; PHP guess I'm not a serious _JavaScript_ developer...
I'm glad you mentioned PHP. Being limited to just JS prevents you from knowing that your project or interface could be about 8 lines of PHP. Say what you will about it, but there are some things that are just done better in it. On the other hand, I'd say that frameworks are no longer moving toward MVC, at least not with the fervency they would have done 5 years ago. A whole generation of coders has had to Node+MVC their way through non-Node+MVC-worthy projects, dreaming of different ways of doing things. I'd predict the young frameworks are going to be looking for hybrid models, if not a return to a more functional flow. Could be wrong, but that's my hunch.
TLDR: http://2ality.com/2016/02/ecmascript-2017.html
In a perfect world, we would only use JS. This is not a perfect world. 
/r/iamverysmart
Nice list. I would expand your first to be **scope vs. context** or **scope &amp; context**, though. There's a lot of valuable nuance in understanding how the two can complement each other, not to mention how `this` actually works in javascript.
I like how it simplifies state updates using actions and auto injects previous state. This is huge since it allows the framework to control the lifecycle of state instead of having to maintain this.state and let anybody read it at ANY time
Thanks. 885 pages is not a coffee break read. 
Next level: detect smiles from the camera stream using computer vision and machine learning
If you think TypeScript is some sort of handicap for not knowing ES6 properly then you have some serious misconceptions about ES6 and TS.
The spec has been on the ECMA website for the past few weeks, but I haven't seen any news or announcements about it. I was starting to wonder if I had missed something.
In a perfect world, we would *not* have to use JS. This is the wrong timeline.
Berenstain bears 
The only time I've thought of scope was in my implementation of programming languages class in college. 
I don't know whether to downvote or to upvote as satire.
Then the guys point was stupid. That has nothing to do with query selector speed.
I don't think pub/sub or currying are *required* to be a serious developer. I rarely use currying, if ever. Pub/sub has it's place, but again it's rare in my experience unless working on a realtime app. I do agree the module pattern is useful to know. 
I assumed the OP was referring to the [W3C Selectors API](https://www.w3.org/TR/selectors-api/), but their point applies to jQuery as well.
https://www.youtube.com/watch?v=2KgAilTTZnQ
&gt;[**Good answer. Like the way you think. [0:13]**](http://youtu.be/2KgAilTTZnQ) &gt; [*^K ^B*](https://www.youtube.com/channel/UCcfiLD_MjLWNq35pPKsvLUA) ^in ^People ^&amp; ^Blogs &gt;*^27,712 ^views ^since ^Feb ^2014* [^bot ^info](/r/youtubefactsbot/wiki/index)
I have never done PHP, but have been working as a JS developer for the past 6 years. Would you label me "not serious?" 
You need security-conscious devs, but you also need experts. Your business guarantees about security should rest on the experts' shoulders, not the devs who do security part-time. Security-conscious devs save the experts a lot of time from pointing out obvious SQLi/CSRF/XSS so that the experts can continue staying on top of security news and info, because that can change daily. A dev's guarantee for security is worth much less than someone doing security full time.
They're defined that way to explicitly solve the classic problem of callback methods that want to use `this` to refer to the scope where they were defined. This was traditionally handled via the ugly approach of `var [self/_this/that/someOtherPlaceholderName] = this`.
great answer - would love if you could also opine on when in one's career they should have good handle on these things. e.g. as someone with 1yr of experience, how deep should I go into any one of these topics vs. having shallow knowledge across all of them?
In DC, we have lots of bootcamps but they all in general will accept any candidate with money who looks like they are willing to put in the effort to learn. The bootcamp just gives you a good environment to learn in, and resources that you can make use of *if you wish*. It's not going to actually force knowledge down your throat, or guarantee success. You're not too old to become a developer (seriously... I knew a guy who became a *lawyer* at 68), and honestly with your extensive design background you'll probably be really well suited as a web designer or front-end engineer (tip: if you have even the smallest skills of programming, call yourself a developer even if you do web design and it will boost your salary by $20 to $30k). 
X-Post referenced from [/r/webassembly](http://np.reddit.com/r/webassembly) by /u/thecupid [WebSight, A new computer vision app showing off the power of WebAssembly and asm.js](http://np.reddit.com/r/WebAssembly/comments/6mnooj/websight_a_new_computer_vision_app_showing_off/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Hey /JavaScript, a small team of engineers and I have worked on a tool to showcase the power of WebAssembly. Inspired by the Google-IO featured project WebDSP, we took WebAssembly development one step further by porting the popular C++ library, OpenCV, to WebAssembly and asm.js (Mozilla’s WebAssembly predecessor), helping developers understand the power of these new Javascript formats. Check out how we’re using OpenCV and its machine learning algorithms on our site, or take a look under-the-hood on our GitHub.
wat
1. I think your chances are as high as anyone else, if not higher. Just make a point of your maturity and previous experience in web development. 2. Pretty good, if you show that you are just as flexible as the young ones out there. By that I mean you are able to learn new frameworks and ideas quickly, a very important trait given the javascript ecosystem. Also highlight your maturity and experience as a competitive advantage over the young junior devs during your interactions with potential employers. 
&gt; Proposal: allow trailing commas in parameter definitions and function calls Yay
I've just seen it used or maybe miss used in the field that I've mentally labeled it a code smell. 
Great article. Thanks. I didn't realize CSS for print has gotten so far. It had completely fallen of my radar.
Definitely not too old to learn JavaScript. I just recommend studying in two blocks during the day. Study in the morning, take a nap, wake up refreshed and study again in the afternoon. 
I respectfully disagree with a couple of your points: * jQuery selectors. Essentially they are *CSS* selectors. Web devs should 100% know their way around CSS &amp; CSS selectors. If you know that and you understand JavaScript, you can pick up jQuery in a couple of days if you need to (and one should always try to learn JS before jQuery). * Arrow functions are a basic part of the JS syntax for modern web devs. If you don't know arrow functions you need to learn modern JS. * I agree with the benefit of knowing another language, but it could be anything; Ruby, Python, Java, Elm, PHP, etc * Datatables? Aren't they a jQuery plugin? * Node / Browser - Once again, this is pretty basic - I would expect any developer with more than 6 months under their belt to understand the difference here. Re: Databases - yeah, definitely a plus. Break them into 2 groups - Relational (e.g. MySQL) and NoSQL (e.g. MongoDB) I don't mean to sound like I'm having a go - I just think that some of these points are either quite basic or tangential to what a 'serious' JS developer should know / learn next :) 
Interesting, so at the end of the day, using the getElementByXX methods will be your fastest and best bet?
Oh yeah, that's a good one.
You're not being intellectually honest (or coherent) here. First, if you use an app, you want it on your home screen, not buried deep in your bookmarks in a browser somewhere. Why would you **not** click one button to install an app you plan to use? Second, the browser sandbox is only useful when it... sandboxes. If it it lets websites spam you with notifications at all times, and run processing in the background that wastes your battery life, then what exactly is the value of such a "sandbox"? FYI, native apps also run in a sandbox, and in the case of iOS, it's *stricter* than what some of these new web browser features would allow. In what world should a site be able to do more than an app can?
You mean Safari. Safari is the new IE.
I started working as a front-end developer 10 years ago, and it was firmly established by then. I'd say there was merit in separating the roles since css 2 came out.
Maybe his data comes from older browsers?
It solves a common problem without having to use `bind()` or a placeholder variable, making code more readable. Lexical scoping is what people expect, as opposed to dynamic scoping which is the cause of many WTF moments, so ideally all functions would be changed to have lexical scope, but that's just too radical a change that would break too much stuff. Since arrow functions are new there isn't any existing code to break and it's possible to give them the natural semantics. 
The Rauschmayer books, Speaking and Exploring JS. You can read online or you can buy prints if you prefer. http://exploringjs.com/ EDIT: Also [Eloquent JavaScript](http://eloquentjavascript.net/) /u/chris-c-thomas
I'll check em out, thanks!
I used to get excited for new features in js. now I'm like SLOW DOWN PLEASE.
Before you wonder too far down this path I just want to say that `this` is not directly related to scope. In standard functions the `this` reference always points to that which called its given function, the callee. If the function is an event handler then `this` points to its event. If the function is a method then `this` points to the object on which the function hangs. If you use `apply`, `call`, or `bind` methods on a function you can reassign `this` to be something different. In arrow functions `this` is a lexical reference, which means it points to that which contains the function by scope. I have no idea what `this` does in constructions. I never write code this way, but I do remember the specification providing some clarity on this matter. --- CSS and how to properly write HTML aren't super challenging skills, but they are also no skills that can be immediately grasped. There is some intuitive thinking that goes into these. It just takes loads of practice to really nail this. I remember working in a bar when I was younger. I didn't need a masters degree in economics to be a bar back, but it took a lot of effort to get really efficient at that job.
* http://jsbench.github.io/#8f4021c69ba67f37953e5d0236d596df * http://jsbench.github.io/#24d619b25e826b4d2914a138ce9eb274 * http://jsbench.github.io/#ae7713b7b1db5878d60ecd1f827e091d * http://jsbench.github.io/#19326344341cbc33122e0e8fbbd21b5a Look at the second and third of those experiments.
great joke! upvoted
u fucking wot mate? nap? You sayin I'm so old that I need to take regular naps?! /s Let's be honest... naps are awesome. And I know exactly what you're talking about, being "a new person" after even as little as a 30m siesta... *especially* at 2 in the afternoon. Homeschooling javascript has gotten me very little in 2 years. I'm tired of flopping back &amp; forth on the same middling topics. Most of the 10 topics mentioned in the post I reference, I've not seen solid learning on many of them. Also, I didn't know I didn't know those things... and Googling can only get you so far.
Knowing multiple languages absolutely broadens your horizon and that is incredibly healthy. There are many tasks that Node is not well suited for. For a long time I worked in the travel industry. I have worked for almost every major online travel agency and worked with a major airline. On top of that we all worked with people in our local area who had worked for the world's largest airline. In this industry Java is king. You do everything with Java as much as possible... including as much of the web work as possible. The problem is that if you use one technology to generate artifacts that operate in an unrelated platform then you are on the hook for both the original technology set and that other platform. You have to be an expert in both areas.... and almost nobody was. Nobody wanted to become the expert of everything. The end result was really legacy technology and thousands of experts who weren't that expert. Java didn't have to be the bad guy. Things would have been much better if all the Java work sat behind a fence and supplied data as a service. But doing that would make thousands of developers quickly obsolete and strong JavaScript developers are hard to hire.
ALERT: [left pad made it into the new spec](https://www.ecma-international.org/ecma-262/8.0/index.html#sec-string.prototype.padstart) String.prototype.padStart( maxLength [ , fillString ] )
How to control your alcoholism. /s 
Yes, that might be the case. The name sure has some sort of origin that's related to "reactions". But "reactive programming" is a programming paradigm around data streams (aka. observables) and the "observable pattern". Observables notifies the world that some data has changed. You can subscribe to observables to receive those notifications (= the data stream) - similar to events. But on top of that you can alter this stream, combine it with other streams, filter events by some criteria etc. Cycle.js is based on this observable approach. Other frameworks like React, Angular and Vue follow a more polling approach. They check if some data has been changed. And if it's just by using a setter function. They actively ask if some data has changed or is about to change. Maybe you've heard about "change detection". They actively have to detect changes. Observables on the other hand tell you about changes completely on their own. You don't have to ask them. You have to listen (subscribe), but you don't ask. No change detection is required. Cycle.js just has to react to those notifications. It's difficult to describe this difference. But in short: React is a library with a random name that's related to reactions. Reactive Programming is a paradigm, just like object oriented programming or functional programming are other ones. I think it's the best if you look up for yourself how RxJS works.
Just be interested in learning. As long as you are willing to learn it is ok to be a junior developer. You become an expert with practice. Early in your career it is hard to know where to point your time for deep learning in tiny niche subjects. Your career will likely point these things out for you. Just be willing to seek out strange challenging opportunities. There are some things you can do to speed this up: * Find a mentor. Having the guidance of an expert around helps you focus your learning in more productive directions or helps you with your technique * Write open source software. If you are having an interesting problem at work start up an open source project to create an automation solution. Even if nobody uses that software you still get additional practice writing software. If other people do end up using your software you get important feedback and bug reports. * Stay busy at work. The last job I was in I felt like half the day was just running build jobs. I didn't think I was getting anything done and the technology was so slow. It was hard to get good practice in that environment and the pace of that environment eroded my concentration. If you can work at the speed of thought then you are the biggest bottleneck, which allows you get far more practice in within a shorter time period.
Ummm... yes, "full stack" existed 20 years ago. I was writing ASP in '97, connecting to ODBC sources. We even had client-side rendering with "Dynamic HTML" and ActiveX controls in IE, though arguably "full stack" does not require you to render in the client. Backend and frontend were most definitely separated long before 5 years ago.
I don't know if it's still a good idea to start with jQuery. I think it lost its right to exist. It's purpose was to provide a cross browser DOM API. But now we have that already built in in browsers. And in the best case you don't touch the DOM anyway. I also don't need it for ajax or promises. And that's pretty much about it.
You can start with books on software architecture. Just make sure those books focus more on theory and are mostly language agnostic. How you apply architectural concepts to a specific language is best learned through practice. This is hard to learn because it requires that you have access to software that you can directly shape. I am absolutely not an expert on architecture, but I have learned some things. Most of my learning comes from practice maintaining a large open source application. At first the application was just a patchy collection of libraries, but at the application became more ambitious I eventually removed the code written by other people with libraries written myself that better suited the application's needs. The code style was very consistent across the code and all the code mostly worked the same uniformly, but eventually all the major libraries needed to talk to each other directly and recursively. Since the code was pretty uniform this wasn't a challenge.... except the options weren't being shared properly. I had to reorganize the code around the options so that the API became the central focus of the application instead of the libraries. Now I have been asked to pull a major component out of the application so that it can become a generic feature used by several other applications. This is hard because that major component is really three similar components across different files that their own unique behaviors, which means massive refactoring yet again. I am constantly learning about a more ideal relationship between the code pieces, but it comes from encountering really big problems and the heavy lifting to do massive refactoring jobs.
Added it to the Babel repl if anyone wants to test it out: https://babeljs.io/php/
[My office right now](https://media.giphy.com/media/pwQdvTbFhds3e/giphy.gif)
While i don't know exactly how rxjs works, it hasn't played a role in what react has started, perhaps i should have written react-like, not reactive. As for polling, reacts setstate doesn't poll, neither does redux, unless you mean the subscribers equality check, and mobx uses the observable pattern from the get go. I don't think these details matter much, observables or flux/immutable, its the architecture that allows it that's interesting. 
You guys are getting lost in the weeds. OP's main point is that js developers should have a solid understanding of the DOM. Many newer front end developers only have a fuzzy understanding of the DOM and think of JavaScript as something that dynamically modifies the static HTML text that they write.
&gt; Homeschooling javascript learn by building not reading.
I don't think you're too old. More important than age is having a solid attitude. If you come across as an old man that doesn't give two shits about the style guide and practices we use at my company, you're not getting the job and I'm sure it's the same at many other places. That's all to say that having a solid coworker who's a pleasure to work with in the trenches is more valuable than having one of the same age group 
You should know it exists, but it's not in the "top 10 things every JS dev should understand" list.
lol these opinions
I mean, unless you're just getting started learning the basics of the language, it's pretty high on the list of things you should have some exposure to these days.
Depends how many cups of coffee you've had!
&gt; Yeah, because every serious JS developer should know JSX and React. Sure. You say that in jest (no pun intended), but it's getting more and more common to the point of being pretty practically true. :-/
Prototype chain and type coercion should definitely go in there somewhere
bump
Yes, react-like is fine. Subscribers equality check sounds like change detection, yes. If you mean something like this: `if (oldValue !== newValue) { rerenderComponent() }`. Yes, That's what I mean with "ask for changes". Angular does that too. I know Vue uses setters instead. And yes, MobX uses true reactive programming. It seems it even has its own Observable implementation. Btw: Observables will be part of the JavaScript core language too (currently at stage 1). The thing is: Actually observables aren't that hard to understand. But RxJS has a huge and overwhelming API on top of the basics. And yeah, react has nothing to do with all that. Therefore React is not reactive, despite its name :)
What is stricter with iOS apps than with Chrome/Android?
this is so good
The OWASP Top 10 is a good place to look: https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project 
I totally agree with this: &gt; **Presentation and semantics.** You really need to have a basic understanding how to properly organize the content your users will consume and how to present in a consumable way efficiently. This is something almost completely learned from experience only. You might think CSS and HTML are simple skills that can be picked up when needed, but you would be absolutely wrong. The rise of ever-changing devices, browsers, compilers, and packages of all languages isn't making javascript easier. Knowing your limits or learning what is smart for your stack/project is crucial to better releases and your future success as a valuable asset. Front-end is not just basic html and css with a little jQuery sprinkled on top. Considering these common roles and pitfalls: * bloggers trying to strong-arm $20 themes and templates using jQuery and add-ons. * front-end devs using jQuery and element attribute css that overrides the theme they are using. * marketing gurus that add scripts and "pixels" to the top of their markup. * some backend or full-stack devs who only use jQuery to do simple tasks and make the program work - ignoring the impact to organic SEO, accessibility, and performance. * UX Developers (I'm talking about the graphic designers, dreamweaver users, &lt;table&gt; coders) that do not understand the basics of how user-flow, performance, and SEO are directly affected by the infinitely nested tables, scroll-hijacking, poor context hijack link inline ads, and popups/interstitials. If you think you might be one of those, and are open to learning that there is more to js, css, and html than meets the eye, than you will find your projects and careers transforming into something more awesome.
I'll use the push notifications as an example, as this is the most common ways Service Workers are used today. iOS app notifications: - The apps don't stay resident in order to monitor for notifications. - Custom push servers are forbidden. There's one push server, iCloud, and it's free. - This means at all times there's at most **one** push connection from a server to a phone (saves battery). One for all apps. - The apps don't monitor for notifications themselves, the OS does, and when it gets something, it runs the app to process it. - To unsubscribe for an app, you can do it explicitly via the Settings, but you don't have to: it happens when you uninstall the app, which is very easy for a non-technical person to do. Web notifications: - The best solution (Google Firebase FCM) costs more than the entire Apple developer program. - Your phone keeps open connections to every unique notification server a site may use. - The only way to unsubscribe a site is to dig into the bowels if your browser, as there's no convenient UI, like app uninstall, to do it. It's already very apparent that sites are using push notifications for spamming. They issue unsolicited "subscribe" dialogs, they aggressively spam if you mis-click, and they make it hard to unsubscribe. Thanks, but no thanks. This BS can stay on Android. I prefer not to have one more maintenance task to do on my parents' mobile devices.
I'm triggered cuz you implied that filter is more important than reduce
Wait what. How did you do that? Are you from babel team or does babel repl have this kind of feature to attach any preset?
It's VERY handy to create code for frontend from PHP depending on repositores, entities etc of different orms like Doctrine. It's like work with your entities on frontend etc.
Am I the only one who thinks people over-value knowledge of scope? It just seems to me like the sort of thing where, if a person has to have an intimate understanding of it to figure out what your code is doing and how to maintain it, then your code sucks. Sure, every now and then you run into a bug where somebody didn't scope something properly, but being able to identify and fix that bug isn't nearly the same skillset as the kind of esoteric edge cases people try to test you on in job interviews.
&gt;Am I the only one Probably not
1. Actual JavaScript. Functions, Scope, Objects, Declarations, Hoisting, Types, Arrays, etc. 2. The DOM and related languages, HTML and CSS. You should know how these work. Yes, you can do other stuff in JavaScript, but for beginners and intermediate programmers, the web is your easiest basic in- and output. This means you should also understand how pages load, render. 3. Learn Algorithms. Learn how to implement your some of your own versions of map, filter, find, etc. Never use them in production, but learn the ideas behind them. Once you figure out that it's almost all just fancy ways to iterate over lists and do something with it, to it, or along with it, this all becomes more obvious and easy to grasp. 4. Learn Data Structures in JavaScript, this is a deeper dive into how you arrange, move around and work with data. 5. Learn good habits. I don't mean some fad style guide. I mean learn not to expose globals, learn not to loop over stuff multiple times when once will suffice, learn when not to do something. 6. Learn to tune out the noise. There's lots of BS out there from people who have a lot of time to write about JavaScript, because they don't have to manage and write a lot of real code. 7. Learn AJAX. 8. Learn about the HTTP protocol, know the 1.1 methods, what they mean. Know the secret behind the HTTP protocol (hint, again, it's not magic). 9. Keep your code and build simple. If your spending too much time on a tutorial for a library or build tool, that's time you could be making apps. 10. Learn about functional programming and object oriented programming, learn to use the concepts. But please don't go overboard, going too far in any direction usually leads to a long trail of spaghetti. Some times things are better structured as object sometimes they're better expressed as functions. It's okay. Everything will be okay. Finally, learn about everything with a smidgen of skepticism. There is no one right way. The newest thing is rarely going to be your best option. The business usually wins over the craft of programming.
Yep I maintain Babel and added a new page to use that preset ^. https://github.com/babel/babel.github.io/pull/1271 What you're asking about I'd like too though 🙂 https://github.com/babel/babel.github.io/issues/858
&gt; Accessibility is a really nice addition here. But many companies don't even begin to consider this a priority unless they -have to-, which means it becomes a nice-to-have For those who are doing work where a business considers accessibility a "nice-to-have", consider: * Organic SEO is directly affected by this. * Sales, Ads, conversions are directly affected by this. * It is sometimes a legal requirement, and fines or penalties are potential risks. * It is often harder and more expensive to add it in later. At least consider the basic steps/requirements during the architecting phase. If you know that your project will be requiring SEO, marketing, or compliance with local laws, then *communicate* and at least plan ahead and include some basic parts that will make it easier down the road. I would agree that most stakeholders I have worked with add this to the "later pile" during the initial MVP stage. 99% of the time, scumbag "I told you so" thoughts just love to /rant about this when all of a sudden they want you to scramble to add this.
Why not? :D
In terms of importance scope is to JavaScript what classes are to Java. Knowledge of scope influences your ability to read and write code perhaps more than any other single factor. It influences how large pieces of code come together and how code is shared via reference. The primary benefit of code via scope instead of code via convention is less code, fewer things to maintain, and the ability to perceive flow control more directly from simply reading the code.
It worked much more uniformly. I don't know how old you are, but in the early 2000's, every site had a button on it that said, "This site optimized for [browser name]" because people were sick and fucking tired of basically building 3 different sites for 3 different browsers, so they just built a site that looked good in one browser instead and said, "View otherwise at your own risk." Around 2007, "everyone" decided to make a more standardized model with js and css that allowed for MUCH more uniformity.
If you're able to use something other than JS, you should.
I was expecting to read lists of frameworks in reply to this question, but I am really glad your great reply comes first. Well written! 
Thank you :)
I really like the graphql-tag webpack loader. This even allows you to import fragments in your query files. 
Wow this is ridiculously cool! It will help many people with disabilities to type quick and nice! Not to mention working with apps
Happy to answer any questions folks have about this. I served as the editor for ES2017.
Wow, that title. Are people already starting to ask questions in buzzfeed style headlines?
My opinion will go against the grain a bit here, but my opinion is based on observations while teaching students web development. Older students generally were slower to pick up complex topics that were new to them. It was very difficult for the students over 40 to learn. This was not the case for all of the older students. There was one exception that stood out. He had a lot of experience building very basic websites and he was quicker to pick up the new concepts that built on top of the knowledge he already had. I'm not saying you should not go into professional web development. I am saying it will most likely be much harder for you to learn and harder to secure a job after you secure your basics (We helped students get jobs after and a lot of the older students ended up back in their previous line of work). You know yourself best.
Like Redux built in :-)
had to try it, I focused mostly on performance fwiw ("CodeMaster doesn’t have much time to try to pick the lock before CFBot finds him"). This is ~4.5 times faster than /u/AndrewGreenh 's submission using the simple example data and 100000 iterations :) Though I can appreciate the terseness of his submission. edit: tried against /u/andynocandy submission and this is about 5x faster (at 100k iterations) Minimal object creation and whatnot, after converting to 2d. The array itself is scanned and values shuffled in the right direction, so no new arrays or strings or anything. //shift blocks all the way up var packup = function(lock) { for (var x = 0; x &lt; lock[0].length; x++) { for (var y = 0; y &lt; lock.length; y++) { var p=0; if (lock[p][x] === ".") { for (var t = p ; t &lt; lock.length-1; t++) lock[t][x] = lock[t+1][x]; lock[t][x] = "."; }else{ p++; } } } } //shift blocks all the way down var packdown = function(lock) { for (var x = 0; x &lt; lock[0].length; x++) { for (var y = lock.length-1; y &gt;=0; y--) { var p=lock.length-1; if (lock[p][x] === ".") { for (var t = p ; t &gt;0; t--) lock[t][x] = lock[t-1][x]; lock[t][x] = "."; }else{ p--; } } } } //shift blocks all the way left var packleft = function(lock) { for (var y = 0; y &lt; lock.length; y++) { for (var x = 0; x &lt; lock[y].length; x++) { var p=0; if (lock[y][p] === ".") { for (var t = p ; t &lt; lock[y].length-1; t++) lock[y][t] = lock[y][t+1]; lock[y][t] = "."; }else{ p++; } } } } //shift blocks all the way right var packright = function(lock) { for (var y = 0; y &lt; lock[0].length; y++) { for (var x = lock[y].length-1; x &gt;=0; x--) { var p=lock[y].length-1; if (lock[y][p] === ".") { for (var t = p ; t &gt;0; t--) lock[y][t] = lock[y][t-1]; lock[y][t] = "."; }else{ p--; } } } } var secretArchivesLock = function(lock, actions) { var l = []; for (var y = 0; y &lt; lock.length; y++) l.push(lock[y].split(''));//convert to 2d array var ac=actions.split(''); for(var x=0;x&lt;ac.length;x++){ switch (ac[x]) { case "R": packright(l); break; case "U": packup(l); break; case "L": packleft(l); break; case "D": packdown(l); break; default: console.log("Invalid action " + ac[x] + " in " + actions); } } var r = []; for (var y = 0; y &lt; l.length; y++) r.push(l[y].join(''));//back to 1d string array return r; }; 
Well, SEO, sales, and marketing isn't usually a factor for a lot of business software, especially not intranet / enterprise applications (unless in healthcare and government). But legalities and expense to implement later are absolutely a concern, and should be thought-through. It's certainly a worthwhile addition on the list, and having it on your resume is a big bonus to companies that know what accessibility is... but I've found internationalization to be a much more frequent concern in the industries I've worked in. 
while i get what you’re sayin g, my personal experience is diving into the depths of js because react can be so damn brittle due to massive amounts of dependencies. that isn’t a great thing, and it’s again one of the reasons why i value something with a smaller foot print like vue.
I don't think it will depend on whether you can go to a bootcamp or not. You can definitely learn on your own and, after teaching myself and then working for a couple of years, I have seen that bootcamp grads are often not all that. That said, I have not been to a bootcamps myself so can't comment on your eligibility. I can say that I have a junior coworker (at a larger company) who is around your age. He had a different career and then learned to code. Came in as an intern and was hired as a full time junior dev. So it's definitely possible, but probably contingent on the firm and who is doing the hiring. You are definitely not too old to learn, so if web programming is interesting to you, you should pursue it. You can decide later on if you want to bone up and interview for full time jobs or just do your own thing. 
Thinking you are old makes you even older ;)
Some good, objective stuff here, but also some purely subjective and optional stuff, as well. Node, for example, is a purely optional technology for the vast majority of people who will be using JavaScript. Raw DOM manipulation is good to know, but it's also unnecessary in almost all scenarios. Accessibility is important, but again, not something you *need* to know - it really depends on what you'll be working on. Great summary overall, though.
But the final code is Always a react app or it is a static website? I mean, can we use react lifecycle for example? (Im newbie also on react) thank you
fwiw, I ported to java (changed var to int/string/string [] mostly). at 100000 iterations: my js was on par with my java. at 1000000 the java version was 2x faster than my js version at 10000000 the java version was 3x faster than my js version and over 16 times faster than /u/AndrewGreenh also worth noting it *can* be paralleled in java without messaging overhead (might be useful on larger data). edit: possibly webworkers can coordinate on a shared array as well via self.
"Functional programming concepts in javascript" isnt a nice to have, its a fundamental. "React Performance optimizations", is a "nice to have"
^(but not really /s)
Well, OP asked for 10 things -- all I could think of were ten steps...
So, higher Ops/sec = more efficient code?
In the previous editions of the standard, the "Introduction" section contained a summary of the enhancements introduced in that version. For this version, the "Introduction" section seems unchanged from the 2016 version. In fact, it says, "This specification also includes support for a new exponentiation operator and adds a new method to Array.prototype called `includes`," but those were last year's changes. I wonder if there is a (non-normative) mistake? Also, thanks for all your hard work! I know the committee puts a lot of care and attention into this standard.
Indeed it seems like this document does not include [the updated introduction](https://github.com/tc39/ecma262/commit/08d41001ee619235d11fdfb965608b4f8c77aa6d). Nice catch! I will fix this.
[2nd Experiment on Chrome 59: x88.2 faster](http://i.imgur.com/YxtDfD3.png) [3rd Experiment on Chrome 59: x27.9 faster](http://i.imgur.com/SRSDoUy.png) This supports my argument even more. The speed increase is within the 10s, not even 100s, let alone 1000s.
Clearly no one got the point. Pity. 
WebAssembly it is!
No, I wanted lists, so I asked for lists.
Advertising. 
This. It's like devs implementing their own shitty crypto instead of using solutions developed and peer reviewed by experts who have dedicated their whole life to crypto.
Agreed. Using Node for everything is its biggest stigma IMO. Node is only good for heavy IO low CPU projects, and even in those kind of projects [it might not be the best choice](https://blog.codeship.com/making-the-switch-from-node-js-to-golang/).
2-3 years ago the industry stabilised on AngularJS (1.x). So no, these won't last forever but they're a good choice right now, as are a myriad of other frameworks that have similar feature parity and leverage current browser technologies. 
Then again, it's not as if all the youngsters who enter the job market are necessarily the best and brightest specimen of the human race, and you will _definitively_ find it impossible to compete with them. I have worked with young people who were thick as a plank of wood, so... even assuming he's at a disadvantage, all it means is that he won't be the next Addy Osmani, not that he's going to be a failure.
&gt; ES6/next or &gt; be informed about current trends Pick one.
So as I understand it, the browser is no less strict about web apps than native apps aside from what server is used for notifications? AFAIK a web app cannot pop up notifications if it's not running, unlike a native app. "Uninstalling" a web app simply requires you removing it from the home screen. As far as managing permissions, that should be as easy as the OS makes it to manage app permissions. Just like the "install" process for web apps should be better communicated. Again these are missing features I'd like to see added and improved. I'll admit that notifications are probably my least favourite capability of web apps, though I do find them useful for Slack and Gitter.
No you can't. Even if you don't use React you will use the Vanilla Framework. /s http://vanilla-js.com/
You can easily learn by yourself just building stuff for your portfolio and learn that way. Just clone whatever simple projects you like (tons are posted on various reddit boards) and rebuild them your way, and put them on CodePen or something. You say you are a designer, you can easily start with SVG animation - a bit of a dark art that not many FE devs are well versed in. WebGL, Canvas, CSS animation, all stuff where you can put your background to good use and enter the job market as an "expert" rather than a junior. Then bit by bit you can go deeper with the JS. The problem is not your age in itself, but how potential employers perceive it. Basically it's a how-to-market-myself issue. Relations between designers and developers are often difficult, you have the advantage of being able to say "I understand designers and know what makes them tick" good luck
I'm using Vue at the moment and I agree, but my eyes are set on [Marko](http://markojs.com/) which is what Ebay is built on. It's better in every aspect but the ecosystem around it is still very small. I'm aiming at start using it in 2018. [Here is a great video comparing Marko, Vue, and React.](https://www.youtube.com/watch?v=i6eZA8Y_GgA)
This answer is great, thanks for the write up
As much as the industry can stabilise (pro-tip: it can't) then, for now, yes. But I have a feeling Angular is over-represented in articles, blog posts etc, and not as many people actually use it in real life as we may be led to believe. It's just a feeling, and anyway, it's still the second best bet after React (again - _for now_) Polymer or something like that sooner or later may get big though.
&gt; Once completed, what do you think my chances are to be taken on somewhere as a old-man junior developer? What's most important is that you try to bring something to the table. Some like to be "brought along for the ride". But if you can identify issues that they didn't know they had and solve them, then you're valuable no matter your age. Plus 52 isn't all that old... it's not like you're 80. It might be a little more difficult, but I think if you apply yourself well and don't take anything for granted, then there is still time to enter a development career. Honestly though I would be wary of bootcamps. I think `freeCodeCamp` looks very promising. Make sure you take a look at what they have to offer too. 
no no no .. :'(
I obviously understand the difference between these two features that's why I'm asking this question. Many people say that about JS. That doesn't mean that's my opinion of it. Im nearly seeking to understand the thought behind the implementation.
People swayed toward react when angular announced v2 would not be backward compatible. Now that angular2 is out, many of those react teams are swinging back because they realize how unmaintainable react is compared to angular2+rxjs+ngrx store. heres a [comparison of search terms](https://imgur.com/gallery/4uTXMhk). And for contrast, a comparison of [job postings](https://m.imgur.com/DmHUMjE) on indeed. The react boys will downvote because they don't like to hear the truth. Having worked at multiple enterprises during this time; past coworkers and current teams have re-evaluated and came to the conclusion that for developer interoperability and maintainability, a prescriptive framework with mainstream adoption such as angular is the way to go. Even if that's not the TRUTH, that perception among tech leads and teams will make it the de facto truth.
What does the running time of a program got to do with the language it's written in?
Wow just reading this completely puts me off javascript
[I'll post this next time](https://c1.staticflickr.com/5/4066/4704268314_bb0e9d0ff3_b.jpg)
Polymer is not a replacement for angular. There are people suggesting that you should write presentational (dumb) polymer components within an angular app but I haven't seen much traction there. Google themselves does not seem to consider it a replacement but complimentary. Not sure how react users would view using polymer components inside a react app.
Maybe give https://www.freecodecamp.org/ a try? I haven't tried it myself, but it looks like it covers a decent range of topics, plus you build while you learn instead of just passively reading ... might be a good starting point before shelling out money for a bootcamp ...
1. Be sure to interrupt the headhunter when they confuse Java with JavaScript.
I have never said Polymer is a replacement for angular.
React : 2017 = Jquery : 2009 
I can't believe people have downvoted this comment and have given hundreds of vote to the guy banging on about accesibility... what's wrong with this sub...
The second test shows a difference of **16231.985x** in FF52 and a difference of **9248.422x** in FF54. Those are some serious WTF numbers and FF54 shows a difference of **6987.384x** in test 3. Some food for thought: * The driving distance from Anchorage, AK to Miami, FL is 4976 miles and when divided by 16231.985 is only a quarter of a mile (1618 feet). * 1 second times 16231.985 is more than 4.5 hours. * It is also the difference between 32 minutes and a year. * Or 2.25 days and a century. * Or 2 inches and the total height of the Burj Kalifa. * Or the difference in mass between the largest recorded blue whale and an average domestic cat.
How does this release affect me as a developer? Does this mean I can use the listed changes in my pretranspiled code confidently now? Or are these new rules that aren't transpilable yet? Which environments (browsers, node versions) support this spec? I don't know enough about ecma version adoption to quite know how to feel about things 😅
It's tricky question. There are many ways in JS to write functions. Notice that it's not the same. Each way means something different (there are differences in behavior, semantics. for example arrow functions don't bind `this` variable). &gt; function a(v) {return v + 123;} // func. declaration &gt; const a = function a(v) { return v + 123;} // func. expression &gt; const a = (v) =&gt; { return v + 123; } // arrow function w/ brackets &gt; const a = (v) =&gt; v + 123; // arrow func. w/o brackets and methods: assigning to object: &gt; object.functionName = function (v) { return v + 123; } assigning to prototype: &gt; Foo.prototype.functionName = function (v) { return 123;} as property in object expression &gt; { &gt; functionName: function (v) { return 123;} &gt; } (in above cases you could also use arrow functions, but you won't have `this` variable bound in such case.) and there is a shorthand notation for methods (it's my favorite): &gt; { &gt; functionName(v) { return v + 123} &gt; } no need for function keyword. And there also off course ES6 classes &gt; class Foo { &gt; functionName(v) { return v + 123} &gt; otherFunction() {} &gt; } notice that in ES6 classes there is no comma between methods (I always forget about this and put a comma and then I have syntax error). 
&gt;Polymer or something like that sooner or later may get big though. Yeah but you just implied it. But whatever.
I'm pretty sure the industry never stabilized on Angular. But I agree with your point.
Westworld takes place in 2052 and they're still using React, so it's at least a good choice until then. But after that it's hard to say.
I can't believe all the upvotes this comment got... it's pretty crap. What's wrong with you people??? Scope - ok, although it's too specific limited. Better a "basics", which includes something you forgot, i.e. the prototype chain Architecture - too generic to mean anything. No mention of flux? DOM - agree with the feeling, but lost it all with the idiotic 2800 times slower comment. Really, it should have just said "learn how to do all the dom operations jQuery does without jQuery" Node - opening files and stuff is basic level. How about streams, for example? Timing and asynchronous operations - agree, but add Promises / async in there for crying out loud Accessibility?? - Are you for real? How's that going to help with JS?? It's a FE / Web Dev skill, but won't help whatsoever with node, for example. So you think Accessibility is more important than promises, streams, ES6? Are you crazy?? Security - too specialist Data structures - to generic, wishy washy. What data structures? Presentation and semantics - HTML and CSS are _not_ JS though, which is what OP asked about. Knowing when to avoid the bullshit - what does this even mean? And what about ES6? Webpack? npm? Some popular frameworks? Service workers? Reactive programming (RxJs)? TEmplates? ISomorphic / Universal / Server Side Rendering? 
There's a difference in what happens under the hood when you write: // This is a function declaration. function functionName(input) { console.log("Example"); } Versus writing something like: // This is a function expression. const functionName = function(input) { console.log("Example"); } Understanding this difference is one of the finer points of JavaScript that you should understand (along with how scopes and closures work in the language). If you are using the first option, then the function declaration is hoisted (as people like to refer to it) to the top of the scope it is in. For example, that would turn into something like this: var functionName = undefined; functionName = function(input) { console.log("Example"); } This allows you to call functions before they are declared in your code, however, it can have unintended side-effects if you aren't aware of what is happening. I find it better to go with the second option shown above so that my code is explicit in what is happening and when. Also, when adding functions as properties, you must use the `function expression`, not the `function declaration`.
The automatic indenting though
Most implementations are following the spec very closely. Chakra has been done with ES2017 (functionally speaking) for some time now, and it is available by default in Edge 16. I think it's already on by default in Chrome and will be very soon in Firefox. Of course depending on who visits your site it might be some time before you can use these features without a polyfill or transpiling. It is true though that now that the spec is frozen transpilation is safer. This applies to tooling more broadly as well.
So... generally you could write in the way what's you fit most (for example arrow functions and method shortcuts - many devs think that they are cool), but even if you will write in some way you will still have to know differences between different ways of writing functions in JS. JS is weird language :/ 
What makes react unmaintainable?
actually you could use function declaration when adding function as property: `function functionName() { console.log("Hello world"};` `someObject.functionName = functionName;` 
BTW how did you make code blocks in reddit? I'm always struggling with that. Reddit version of Markdown feels different than e.g. Github one. Lines always wraps...
The world of programming hasn't been "stable" at any point in its existence. It's a constant evolution. But *you* can stabilise your own development by choosing one particular set of tools and sticking with them, regardless of all the new bling that comes out. Not that I would recommend that. This is why so many enterprises are still running off of 30 year old software.
Hit reply, then click on 'formatting help'
It's one of those annoying findnerd articles
I really wish there was a way to hide posts in reddit with certain words in the title... like "aurelia", for example
*snaps fingers* Yes! Slow down! My man!
Whoever downvoted you, I don't need their sympathy. I'm not one of them, but a lot of my peers, all of whom are younger, can't understand jack when it comes to tech. My MiL is &lt; 15 yrs older than me, yet occasionally loses chrome off her task bar and I have to come over and fix it. Fact: some folks my age just don't have it anymore. 
thanks :)
Similar to my solution only more ES6! I was hoping someone would comment on how to ES6 the for loop out of my rotate/transpose func - Thanks!
Haha brilliant
New t the scene, Just realized that ES7 has been out for a while. Why does it seem like most people talk about ES6, but not much about ES7?
Yes, as simyers said you have to build things. I recommend building an application with a database back end and a front end html client. Just pick a platform. Personally, I like google app engine with nodejs virtual machine. I'm 45 btw which is why I recommend a good nap. I can recommend some things to build in order to reach your goal. Feel free to message me. I've been a web developer for over 20 years now.
Good primer and fairly well put together. Unfortunately, for someone like me actually trying to work out how to build an api on Nodejs accepting GraphQL, with say Redis or Neo4j, it's not a lot of help. I've yet to see a decent "how to" covering that. Maybe I expect too much! LOL 
Because ES2015 (ES6) added tons of new features. ES2016 (ES7) and ES2017 (ES8) are relatively light on new features due to the change to yearly releases. 
Jsx for starters, then there's the micro-componentization that happens because of rendering logic complications. It's hard to hand off jsx and the style formatting to the designers. The Wild West use any framework because react is not a framework leads to devs with differing toolings. Angular2 being prescriptive means more devs are familiar with the common path. Plus the older school templating makes it way easier to hand off design. React peeps could argue swapping out jsx for that one templating library, but then you're already off the beaten path. When you have to render for ios/android/browser/desktop, there's just too many edge cases for the developers concerned with business use cases to finagle all the views. 
Don't forget that there's a silent majority here: the group that doesn't browse /r/javascript, just wants to get the job done, almost never concludes that *any* JS framework is going to be a good thing, and just uses jQuery.
A serious javascript developer will know the things they need to know to do their job because that's what you get paid for. 
https://imgur.com/gallery/4uTXMhk
I would disagree and say that a large majority of the industry stabilized on angular, and that that trend is continuing. Here's [one indicator](https://imgur.com/gallery/4uTXMhk) among many. 
Challenge yourself by finding work with Javascript. It will make you learn. 
$150 for the depth camera isn't too bad, but it's a shame you couldn't do this with some cheap sensors and a raspberry pi / arduino 
Probably because it only included two features: http://2ality.com/2016/01/ecmascript-2016.html - Array.prototype.includes and the exponentiation operator. ES6 was a massive release that coincided with/spurred the recent JavaScript revolution.
iirc, `async/await` didn't reach stage-4 in time for the release of ES2016. 
It's not over-valuating but appreciating the fundamentals. Scopes are basics of JavaScript (and every other language which allows for declaring variables). It such basic knowledge as knowing what braces `{...}` mean or how if/else construct works. Sure, many people would grasp it by intuition, but not always, not in each case. Especially if you're coming from other language where the same concepts are working a little bit differently. Or if JS is your first language and you don't even have "scope" concept in your head. Or if you're just debugging your programs and have weird errors and don't know why. And knowing very basics of programming language you write in is important. 
[removed]
That makes sense! Thank you.
&gt;Knowing the basics like how to avoid SQL injection [Here is an excellent video describing this.](https://www.youtube.com/watch?v=s4QxOxGL1tI) Jump specifically to a solve after the cartoon at 5:22.
Actually the USA has more Spanish speaking citizens than any other country after Mexico. EDIT: went to check, and Mexico currently has more. 
Why don't you check by yourself?
Fair enough 
https://github.com/idietmoran/Discord-vasi a discord bot I've been working on. Spawns a watcher that watches an audio folder, and when an audio file is dropped into the folder the bot automatically updates commands to play the audio file without restarting the bot. drag `foo.mp3` into the folder and you can type `!foo` in the discord chat channel and the bot will join the channel and play the audio file. I plan on doing a lot to the bot, but for now I just wanted to automate tasks for one of my current bots so I didn't have to restart and hardcode the bot every time.
People add aria-label all the time because they care about SEO. That it helps with accessibility is just incidental. I'd say all the 'side benefits' of making your site accessible are the real drivers here. Often you'll see a site that hits just enough for organic SEO and sales, but no more.
From the charts, it looks like newer browsers are getting better at executing getElementById and others in tight inner-loop testing conditions.
Just pushed an update with this fix!
I've done most of it. The good parts are really solving the algorithms, the front-end projects, and the back-end projects. The other stuff doesn't really help IMO. As much as I hate `codecademy` it does give a good foundation for the syntax and basic features. FreeCodeCamp gives you a goal/project to set out and accomplish and you do it on your own
#10 is the line I've been trying to learn how to walk. The hardcore functional programming people seem to think it's all or nothing to gain the advantages of FP, but as I've been learning more I've been finding that you can use ideas from both to write good code. Edit: auto-mistake correction.
Elm architecture
I'm constantly amazed at all these devs on Reddit who manage to offload a significant part of their job onto their designers then act like it's a front end framework's fault that they're too lazy to do front end. 
ES8 wasn't released today. It was released at the end of June, and you saw [the same Hackernoon article](https://hackernoon.com/es8-was-released-and-here-are-its-main-new-features-ee9c394adf66) I did. And later someone will come along and tell you it's ES2017, not ES8.
This just tells me more people were confused when using angularjs :D
* **Source Control** * **Automated Testing** * **Deployment into Production**
Sorry, if everyone doesn't follow security best practices, you are going to have endless exploits. It cannot be left to experts.
There's other things that didn't make my list, but help with this, the concepts of contracts, immitability, and enumeration and the collection of common JavaScript Patterns and Anti-Patterns. 
&gt;I would strongly prefer Internationalization over Accessibility, if I had to pick one This is wrong. You can choose to not learn English. You don't choose to be blind.
This industry is so toxic now if you are happy doing what you're doing I would keep your programming to just tinkering and building your own stuff. As soon as you are forced to work at an agile shop (everyone these days) you will soon hate it. 
this seems biased at best and intentionally incendiary at worst.
Show me your listicles. 
THIS POST IS SO INTENSE. Am I an imposter?! I'm seriously questioning myself now. Who am I. Regarding scope - I learned Javascript (and really programming in general, outside of what I did in university) with AngularJS. Trying to understand $scope in angular after not having written any code for nearly 10 years was painful, to put it lightly. 
I'm personally a fan of using the good ol' function keyword, mostly because the hoisting gives me some flexibility in how I can structure my code. For example, if I have a single exported function in my file, I can put it at the top for people to reference. export function doSomething(a, b) { scopedPrintFunction(a); const c = scopedDoesSomething(a, b); scopedPrintFunction(c); return c; // Implementation of functions here function scopedPrintFunction(value) {... } For people looking into the file to get a rough sense of what the exported function does, it's right at the top so that they don't have to dig through to find the function. And if they have further questions about the functions used in the exported function, they can look further down the file if need be. It's always annoyed me when I needed to peek at the implementation detail of an exported function, just to have to dig through all the prerequisite functions before finding the exported one. Plus in the debugger, you get the actual function names used, where the variable assignment ones generally are left as (anonymous function). The only exception to this rule is if I need lexical this binding, usually for a callback. If so, then I use the arrow functions, with variable assignment if need be. I like to leave this for callbacks only. htmlElement.onClick((evt) =&gt; { /* do something */ }); EDIT: Realized my example didn't really take advantage of hoisting.
I had no idea parallelism primitives we're in the works. Cool. I'm sure some very interesting libraries will arise from this.
An engineer who evaluates technologies based on feelings. Why don't you look for evidence? It is not hard to find. 
I no rite The only thing I've missed from other editors, FINALLY. :D
How come I was told arrow functions automatically bind this? You're saying the exact opposite. Was I mislead?
In a perfect world, JavaScript wouldn't exist.
Because `this` accessible in arrow function comes from the outer scope (lexical scoping), not from the arrow function itself. 
YAY auto indent, i hope it works right :-D 
hi - angular core team and author of ngrx here. I'm stoked you like using ngrx and angular - but it's important to note that a lot of the good stuff in those two projects comes from things we've learned from the React/Redux community, and from the greater JS ecosystem as a whole. You won't hear the Angular team crapping on the work of the React team (or any other, for that matter) - we all have different philosophies, but you can build successful applications with any of them. We're not out to "win" - we're out to make developing applications better for everyone. i'd just love it if people wouldn't get so darn tribal about this stuff :/ 
Do people prefer one over the other? For me, ES8 makes more sense since while we're on a yearly release schedule now that wasn't always the case.
1. [read the fucking spec](https://www.ecma-international.org/publications/standards/Ecma-262.htm) 2. learn how to learn. refining your methodology for solving a code problem will help you more than anything else. 3. question everything. "because it's convention" is the most common excuse I see for bad code. 4. be clear. write variable names that strike a balance between explicit and terse. 5. plan. weeks of coding will save you literally hours of planning. 6. communication. call a REST API from client-side, write a rest API. 7. security. learn the basics at the very least. 8. eliminate dependencies where possible. this boils all the way down to point-free programming. 9. never take short cuts. they will get you fired. 10. seriously, [read the fucking spec](https://www.ecma-international.org/publications/standards/Ecma-262.htm)
It isn't "wrong", the number of non-english speakers vastly outnumber the blind, even in any given country. And especially using applications that cannot possibly serve the blind, like instagram or even photoshop. 
Zero-day exploits aren't always stopped by best practices. Have you ever performed a security audit? 
Exactly.
Makes sense, given how insane Angular's API is vs React.
AngularJS is trying to bolt a different language onto Javascript: at its core it has the same syntax (which, nowadays, doesn't mean much anyway, as Javascript is slowly turning into a monster as big as C++) but with different scoping rules. Somebody *obviously* didn't like Javascripts simple scoping rules, where you just have 2 scopes: 1. global scope 2. function scope Nooooooo... there must be news scoping rules, where each component can either see into its (dynamic) "parent" scope, or be *completely* isolated from everything else. When doing AngularJS, I spend more time battling AngularJS than actually doing useful work. 
Great answer - thanks for making that point!
1, 2, 3, 5, 5.1, 6/2015, 2016, 2017... The 2015 one was initially referred to as ES6 and later renamed to ES2015. So, it made sense for a while to refer to the next version as "ES7". However, that's not true for "ES8". That one was only speculatively used. Like, "ES8 might include SIMD" (SIMD was dropped). Using the whole year feels a bit clunky, but it will make it much easier to keep track of these smaller incremental updates. "ES8" currently still makes sense, because it's ES6 + 2 updates, but this intuitive connection will be lost a few years down the road. ES6 was a major event for us, but it's more of a footnote for people who just started. To them, "ES8" is just as arbitrary as "Java 9". And "ES11" would just feel as arbitrary to us.
hmm, i like it
I use function declarations when I want to declare a function. function foo() { ... } I use the method shorthand for object literals. let foo = { bar() { ... } }; I use methods in classes (well, duh). class Foo { bar() { ... } } I use arrow functions wherever they are convenient. setTimeout(() =&gt; this.foo(), 1000); bar.addEventListener('click', e =&gt; { ... }); let bars = foos.map(foo =&gt; ...);
How do you measure if a language is good for long running programs? what language is good for long running applications? What are long running applications used for? 
It's ok, just try to read your post a couple of times before publishing it. 
I havent missed N++ even tho i loved it for sooooo long.
N++ has printing VSCode not.
Late to the conversation but I don't think those are good examples at all which may be why from your point of view-- they were nothing more than more confusing, and a new unneeded thing. A more practical example would be to look at how they are used in a larger framework. Take a look at C# and Linq-- if you're familiar with SQL it feels exactly like a sexy object oriented implementation. If you're not, that's beside the point anyway. Linq is all about C#'s IEnumerable interface which is much like JavaScript's generator concept, and you could write everything in the Linq library into a JavaScript library using generators, which is why I'm using it as a reference. The performance benefit is seen because of the fact that you have a built-in concept of a collection that you don't know the size of-- you only know that you can request a next item, and at some point you may or may not be able to request another item. This is the alternative concept to allocating an entire collection at once only to then iterate it (requires more memory), or generating all generations at once (requires more processing, and may not have an end), again only to then iterate it. Instead, with generators, it is all done in sequence, and only as long as necessary. The real benefit (in my own opinion), which is why I mentioned Linq, comes when generators are working together-- one generator pumping into the next, similar to promises, but geared towards sequence. In the end it allows you to be much more productive while also encouraging an efficient pattern. If you look up Linq I gave as an example and it appears too foreign just yet, I guarantee you will see the benefits in time.
Hi /u/mohammadmahmalji, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
I agree on a lot you write, and I am also of the opinion that a JS developer should know the DOM. But not for the reason you write - 2800% faster than sounds like a lot, but sometimes the numbers are soooo small that even 2800% faster is unnoticeable. Transfer your stance to iterations - native loops are about 2000 times faster than using an abstraction like underscore. But underscore is far more readable and faster to develop using. It's a balance and not an absolute that something is right just coz its faster
&gt; learn not to loop over stuff multiple times when once will suffice While performance is important to consider, the focus should be in understanding *when* to optimise and figuring out what actually causes performance issues. 99.9% of the time, I don't have trouble running `map` and `filter` on the same array. Sure you could link me a JSPerf where a single for-loop is more efficient with a million items, but I would say the milliseconds spent running extra iterations on my 20 item list go to a good cause, which is keeping the code clean, simple and reusable. Premature optimisation is bad, figure out tools like profilers to see where the real performance problems are. Also if you do heavy lifting with JS in browsers, service workers are worth a look.
&gt; When doing AngularJS, I spend more time battling AngularJS than actually doing useful work. You know, I'm almost a year deep in Angular 2 / 4 w/ Typescript at this point and I sometimes still feel like your statement is true. The API footprint of the new angular is absurd. Yet oddly, I'm kind of addicted to it and really excited about what I can do with it. Maybe its like a stockholm syndrome thing. When I finally figure out some random quirk after 8 hours of fudging (with basically zero official documentation to help me), instead of being frustrated at the language's complexity I'm all, "HELL YEAH I DID IT". Although now that I think about it, the fact that I came straight to Angular without previous vanilla JS or jQuery experience was probably an *advantage* for me. When I see many of the stack overflow questions w/ Angular 4 that people are struggling with, its clear that many are approaching it from that paradigm and trying to fit a jQuery sized object in an angular hole.
Points 1-5 may be convenient and savvy much they are extremely bad practice if you want to write reliable and readable code. Instead, check your types, and let the minifier make those shortcuts for you.
Amazing list. Special hooray for Timing and asynchronous operations. A lot of people don't seem to understand the importance of getting those concepts right and many developers I came across simply lack that knowledge.
Preview: Multi-root workspaces - Open multiple projects in the same editor (Insiders build). YAY
I don't know anyone who is specifically a "Javascript Developer". Most people I meet are organized by discipline / stack layer rather than language used. But, for web development which includes Javascript, I'll name a few things I think are important outside of other stuff mentioned here: 1. **Caching**: There are multiple ways to do HTTP caching (etags vs hard expiration). A speedy web app will utilize static assets via CDN as well as live data sets. Being able to boot a web app with appropriate caching, while avoiding cache poisoning, and being able to invalidate cache or update references sanely is pretty important for performance. 2. **Perf Auditing**: Putting aside standard algorithmic complexity stuff, when trying to speed up an existing application being able to use Js Perf tools is pretty important. The Chrome Dev tools have a lot available here, but take some practice and learning. Being able to discern &amp; solve JS parse time, resource lock delays, slow JS execution, inefficient DOM interaction, and long paint triggers is a tricky advanced skill. 3. **Build System**: Tons of JS projects use build systems, and for a medium to large application you're probably going to need one. I don't care if you webpack or gulp or shell script, but being able to put together &amp; scale a sane build system is a pretty important tool! I don't want to think of 10 things but as a final thought: **Have an opinion on a framework or two**: There's lots of popular frameworks out there, there are also great niche frameworks. They can all solve a lot of the same problems, and some can solve more specific ones. Choosing a popular framework is a safe bet, but having an understanding opinion on one or more will help you face shortcomings of the frameworks and evaluate new ones as they come. Also +1 to building sane REST APIs. Even the big companies screw these up every once in a while, so put your best foot forward every time you design one.
top ten ways people are becoming buzzfeed articles, you won't believe number 7! 1) Personal space 2) Personal space 3) Stay out of my personal space 4) Keep away from my personal space 5) Get outta dat personal space 6) Stay away from my personal space 7) Keep away from dat personal space 8) Personal space 9) Personal space click to continue &gt; 
Scrolled just to find this comment, I feel I'm missing something in all this scope discussion. I think it's simple enough, can someone present me some examples where scope is a complicated issue that needs to be addressed so explicitly? 
I have mixed feelings on this. To me it is encouraging people to use npx mocha rather than npm run test The latter is better in my opinion because it is the test *interface* to your application, and mocha is an implementation detail. You can change mocha to another framework down the road and other devs will not have to change how it is invoked. As long as people are using npx strictly for playing around locally, and not as an interface to an application then I think it's useful for testing stuff out.
The Angular project is very large, well-supported and well-documented. It is difficult to see it going away any time soon. 
could you spell it out or list it?
Seems like ES2017 has a lot of words in it. Any chance we could have more pictures? Or is that considered syntactic sugar?
When you have 3 to 4 front ends via different rendering engines, you just need more hands on deck.
Thanks for all your work on the ES2017 standard! Why aren't we calling it colloquially as "ES17", like how we call it "C++11” (for it's 2011 revision)? Seems like it makes more sense than calling it ES8. I realize this isn't a question about the spec per se, but I'm hoping to hear some insight from someone closely related to the effort.
i didn't _evaluate_ anything on feeling. I just _mentioned_ the feeling. It's called "years of experience" and "talking to lots of people in the industry" you patronising sod. Show me some data then.
I've self taught myself over ~20 or so years I've been plugging away at web pages. The single best way to learn something is to have a goal, something you want to build... and try to build it. You'll have problems, google that shit and figure it out... got some cool other things you want to add in? google that shit figure it out. Repeat as necessary... the key: attempt to build something and fix/understand every problem that comes up. I'd start with a todo application. Maybe all client-side to start, store the values in an object or whatever save to local storage, refresh it's all there again.... add a web server, database back-end so now you save stuff when someone starts a new browser window... then implement authentication so not everyone who visits the page gets the same todo list.
also, you need to add searches from react ecosystem. Since equivalent result from angular is achieved not only with React (+redux, mobx, etc)
Based on their obvious misunderstanding of how searching works I wouldn't put much trust in their judgement.
&gt; we all have different philosophies Thats the core of the "conflict". I dont dislike angular for its implementation (lots of good work done there!), but for the philosophy. React-way (jsx, virtual-dom, lego, funcional like) resonates much more with me than any OOP and "proprietary javascript in html templates" 
Documentation on [configuration file](https://github.com/prettier/prettier#configuration-file), [prettierrc JSON schema](http://json.schemastore.org/prettierrc)
That's also it's problem, give me a small targeted framework that doesn't need reams of documentation any day.
Its like the olden days, when you saved state to a tab-delimited file.
&gt; Minor new feature: [String padding](http://2ality.com/2015/11/string-padding.html) 😊
Maybe was a bit harsh. Just trying to distill the attitudes I've witnessed. Philosophy to programming is like religion to morality: the intent is different than the outcome. While there can be many religions, there is a means of verification of what is actually moral via a secular system. And so with software there is an objective better result. We would have to turn to academic studies of productivity along the lines of the MS studies on team org and TDD practices on software delivery and budget...
Nice article.
In the DOM stuff you talk about performance a bit but I feel it deserves a separate item because for the web it matters a lot. Having your site load in milliseconds instead of seconds, will make a big difference in how it is perceived. Knowing what to do and what not to is very important. I was working on a project that ported a lot of C# code to typescript, but they completely forgot 2 things: 1) Their C# applications takes more time to load and has an actual bootup image 2) Javascript doesn't work like C# in some areas and many of the things you can do there, just don't work fast. For example, they had a dictionary to hold information, but that is super slow on Javascript. They often just put things in a dictionary that would be required to loop through when situation X was active. Like functions to run after an event has happened. Total overkill and when you have this in 20+ locations, it starts to hurt your app. Also it was loading everything on startup and while it was still within acceptable ranges, we still needed to implement a lot of additional code they haven't got around to. So while it was doable now, it wouldn't with all those new features. Your stuff about NodeJS goes a bit specific if I'm honest. Dealing with files is not very important for most. I feel more devs work with Gulp/Grunt/Webpack/Browserify and thus how to operate such a thing and what concepts are involved is very important. And keeping those dependencies up2date (to make it easier to upgrade in the long run) is also something that should not be forgotten. And lastly I feel that a point about "make documentation and have useful inline comments" is not something to forget. Many times you will revisit old code and have no idea why you did something as you did it, but it was something you did to make it work in a specific browser, to polyfill or something that will slip your mind. It might be more about coding in general, but its something to keep in mind.
Awesome! This was pretty much the one thing missing, as far as I could tell.
Similar to CakeJS https://github.com/linuxenko/cakejs2
Angular generates help requests like nothing else. The actual usage statistics are here: http://npmcharts.com/compare/react,angular,@angular/core,ember-cli,vue,@cycle/run,@polymer/polymer Pull back the slider down below and you see growth as well.
Not strictly related, but does the release of this spec mean other active proposals might advance in the near future? (due to committee members being freed up or whatever) It sure would be nice for class fields (and to a lesser extent, decorators) to reach stage 3 given how many libraries already recommend them...
Angular is clearly intended as a comprehensive framework with which you can build huge sites. For me, it is like having a luxurious and well-stocked workshop. For smaller projects though, it is kind of using a sledgehammer to crack a nut. 
I really hate the fact you were downvoted for this. I was asking genuinely and you gave a great, mature, thought out response. People downvoting because they disagree are really showing their immaturity and abuse for the downvote system, using it as an "I Disagree" button.
`npm remove -g left-pad`
*Their job* can be a very different thing from place to place though. I've known everything to do all my jobs, (10 years front-end) but the requirements some potential employers have are significantly different, and can require esoteric knowledge that can only be learned either by working somewhere that uses it, or drilling it in it in one's own time. But 3 places I look at will have different needs, and separating new fundamentals from the flavour of the month isn't an exact science.
These are good points. You're right about javascript developer being a less typical job title, though I do see it in job ads more and more. In my case, I have a firm handle on the other parts of the frontend stack, but the javascript can seem a bit Looney Tunes some days.
While `map` and `filter` on the same array is probably more readable, `reduce` works just fine to combine those operations.
The difference is completely negligible in virtually all cases. It doesn't even matter. I just did a test on 1000 `querySelectorAll`s, and it executed it in 2ms. 1 single animation frame on a 60 Hz device is 17ms. Using a more complex DOM and selectors, it increases to 20ms (for 1000 selections). Which means for a regular-ish case of 1-10 different selections, it's less than 0.5ms. Unless you are placing it in a giant loop which you probably shouldn't be doing, go with what's easier. 
http://eloquentjavascript.net/ free html version
Admittedly I prefer a printed one. So the book is valid, I guess
It's not intended to replace the scripts defined in `package.json`, all projects should still provide them to develop, build and test the application (and document them in README). I'd say any sane developer will do it like that. If there's any flags or parameters, using the scripts is more convenient anyway. However, this ensures you *can* use all the project dependencies directly and conveniently when you need to. For example, if you put eslint in the project, you might make it a part of the build process with something like webpack and not even provide any more direct interface. Or maybe you add a lint-script with fixed parameters. With `npx`, a developer can still do uncommon things you don't want to create an interface for, like running with the `-fix` -flag after migrating a bunch of old code to the project. I also think the project generator tool example is a very strong case for this. 99% of the time you want to use the *latest* version of something like `create-react-app` when you run it and it won't have any value beyond that first run.
It's a crap post don't worry too much about it
I like reduce and it's extremely useful, but I think it's best to use an iteration method that implies the return type you want, if one is available. x.map(fn1).filter(fn2) // that's going to be an array x.every(fn3) // that's going to be a boolean x.reduce(fn4, []) // that could be anything, check implementation Just saying avoiding any extra iteration by default is premature optimisation, you should default to straightforward and declarative code, add complexity only when you have to. Most of the time a simple filter or something iterating over your array isn't going to have any meaningful difference versus doing the same filtering inside another loop. Of course there's exceptions and you shouldn't loop for no reason, but I think just avoiding iteration for the sake of avoiding iteration isn't a best practice. Optimisation needs to be sensible and if you do it blindly, you end up moving meaningless cost in runtime efficiency into a meaningful cost in development efficiency.
From a recently published app: /** * String.prototype.padEnd is scheduled for: * Chromium 57, March 14, 2017 * * Currently, Electron 1.6.5 builds against Chromium 56 :-( * */ if (!String.prototype.padEnd) { String.prototype.padEnd = function(length) { return this + (" ").repeat(Math.max(0, length - this.length)); }; }
I meant not only language trends, but patterns and/or best practices, tools and so. Web development is aggresive enviroment
"... Or not when it doesn't" isn't implied by the use of "do this when?"
Who's printing code and why?
&gt; So the book is valid, I guess I've not spent much time with it myself (it is in my reading list along with the You Don't Know JS series, alsop available both online free (https://github.com/getify/You-Dont-Know-JS) and in print for money) but it does seem to be well regarded though not for an absolute beginner (which should not be a problem for you). It is from 2014 so given how fast things are moving ATM there will be some modern changes not covered, but a good book covering the more stable core is better than a bad book that covered all the new fancy bells &amp; whistles! &gt; Admittedly I prefer a printed one. The online one is at least useful for previewing the content though.
Very short bullet point list with little information of use
Here's an excellent guide to currying and more in functional programming [drboolean.gitbooks.io/mostly-adequate-guide](https://drboolean.gitbooks.io/mostly-adequate-guide/)
Thanks for the comment. We will extend this resource over time. I feel like what we have now is a solid baseline, but there is so much more we can do. Would you mind putting together a list of topics you would like to see covered so we can make sure to include this when we work on the more advanced chapters?
Very good, but you left out everybody's favorite, the IIFE: (function() { console.log('I'm an Immediately Invoked Function Expression!'); })();
This is not a problem Node needed to solve. Packages can already install binaries into the `./node_modules/bin` directory. It then becomes a problem for your shell/environment: How do I run a binary in a context-sensitive location? This applies to much more than just Node. I would also prefer this to be a subcommand instead of introducing a new command (e.g. `npm exec` and alias `npm x`) although I realise their intention is for it to be terse.
1. Progressive Web Apps - this is the future for many sites 2. HTTP 2, HTTP push 3. Node.js or similar, being full stack is really helpful 4. Redux with or without React, just a great way to manage application state on the UI 5. Functional Programming concepts 6. How to test your application with Mocha, Chai or similar 7. DevOps for your application, understanding every part of your project will make you stand out and will make you a better developer 8. Webpack 9. Caching headers 10. Browser APIs like background sync, web payments and generally keeping on top of new things coming out
Well you're only 52, so the way things are going these days, you have nearly another 30 years of work in you! I don't know about Bootcamps, but you should be able to get hired somewhere decent. You may have less chance getting hired at some shitty startup *a la* [WELCOME TO OUR STARTUP WHERE EVERYONE IS 23 YEARS OLD BECAUSE WE BELIEVE OLD PEOPLE ARE VISUALLY DISPLEASING AND OUT OF IDEAS](https://www.mcsweeneys.net/articles/welcome-to-our-startup-where-everyone-is-23-years-old-because-we-believe-old-people-are-visually-displeasing-and-out-of-ideas) but there are plenty of places that will appreciate your experience and how that can complement your work. My feelings are: You may be most likely to find a position as a designer/frontend developer, where you spend as much time applying your existing skillset as you do applying your new one. In my experience, a lot of places look for these. Especially so where UI designer/developers are needed, and that can be web or games or whatever. Studios that make games in Unity, for example, may use javascript to script their UIs. I've often drooled over such jobs, but I don't have the design chops. Assuming you're cool with a drop in wages, going from senior to junior and all, have you thought about approaching someone who needs a designer, and uses a lot of javascript, about a hybrid role where they get your expertise in design, at a discount, and train you up in javascript? Might be a terrible idea, but I dunno, it could be the right thing for somebody. Prior to being accepted to a bootcamp, read [The Good Parts](http://bdcampbell.net/javascript/book/javascript_the_good_parts.pdf), if you haven't already, to grasp the fundamentals. Do a few decent Udemy or similar courses, when they're at 10 quid in a regular sale is good. Use a js linter while you work on things, such as eslint, with AirBnB style, and hey presto, you're writing javascript like the pros, albeit slowly at first.
&gt; But not for the reason you write - 2800% faster than sounds like a lot, but sometimes the numbers are soooo small that even 2800% faster is unnoticeable. You are mostly right. We are talking about nanoseconds versus microseconds, but it does add up noticeably if your app makes many DOM queries. The difference in speed multiplies with numerous DOM queries.
I prefer to write functions like this: var recordPush = function parser_recordPush() { Each of my functions are uniquely named using a convention that completely spells out the scope chain separated by underscores. Named functions are handy if you need identifiers in profilers for performance testing or want to know what is happening in a stack trace. Without the function name the function is anonymous. I assign the function a variable so that it has a short local reference.
Thanks for mentioning 3 and 9. Way too many newbies here trying to skip the basics and dive straight into React or whatever, and way to many veterans encouraging them. 
IIFE is just function expression. But okay :) And I didn't mention generator functions.
All i want is for decorators to reach stage 2 !
Who said they always are ? Your suggestion is still wrong and reckless: Security is for everyone, it's one of the basics.
Cool idea. Runs slow though.
Adding an additional option for developers to define their methods and said methods' scope isn't a step backwards. Say you have a class, you want to pass one of the methods to another class. You're using 'this' to refer to the class inside the method, you could bind the method to the class inside the constructor, or you could avoid having to do anything extra and just define the method as a class property and use an arrow method instead. Since there's no new scope opened in the arrow function you can freely refer to the class it belongs to.
Wow. This is awesome. Been looking for a decent introduction on how to implement graphQL, sadly there's not too much resources and tutorial available. This looks really promising and will surely try it.
I always wonder would it be better to learn redux first, and then react, finally react-redux.
In non-strict mode you could achieve something similar by using the more conventional `_` parameter: function addFirstAndLast(x, _, _, y) { return x + y; } However in strict mode (and this in `class`) it will be an understandable `SyntaxError`. Personally I'd prefer using `_`, as for me it improves readability, but in JS adding that would go against the grain as we already have the `, ,` approach.
Could you share some use cases for this?
That's true of many web technologies. They start slow, but improve as time passes.
Nice packaging of the "secret sauce" a lot of mobile shops use to serve content across domains in-app. I think I can hear the collective groan of a few of those shops...
During OWS I went to a few cities where we were hosting an info site at the protest from a mobile web server (it was a full LAMP box tho) ran off a bike. Some mobile shops that build white-label apps (think for like Community Banks and Regional Hospitals) have to keep some type of real time connection without a socket - this is similar to what they do to achieve that. Tons of apps out in the wild do this already, homeboy did a nice job with the interface. 
Yeah, such option would be cool, but if you really need this, you could emulate this with an array and the spread operator: foo(...[10,20,,,40]) And if function has too many parameters, it's useful to replace them with an object: function foo(options) { options.a; options.b; } And you could even restructure them function foo({ a, b, c, d }) { } and ofc when you call function you could just omit arguments you don't want to pass: foo({a :10, c: 30}); &gt; When you define a function used as a callback, sometimes you only need the first parameter and the last. It seems that the problem could lie in problematic API, not in language. If you have library with problematic API you could make simple wrapper (or use some kind of Promisify to convert to Promise based API without need of passing callback as last argument). Not sure if language-change is needed here, because it could be solved in simpler ways...
You're misreading me if you think I am saying security should be ignored. But it isn't an aspect that you should ever feel you have enough proficiency in unless you specialize in it. That overconfidence is considerably more dangerous than what I am suggesting. 
y tho
ditto
Overtaking or taking over? 🤓
So I recorded my site for a while. Then sorted by unused bytes. What was on top? Google's own analytics.js
bump
Thanks for taking the time to fully explain. It seems like in a lot of cases, things like accessing data and querying selectors only becomes an issue when things are either large or done a ton of times. In O(n) isn't bad in cases where the input size is small. 
Personally, I find taking HTML and creating react components from it far far easier than having to attach syntactic sugar to existing HTML and try to implement dynamic constructs.
Taking the UK contracing sector for front-end developers as a whole, I see far more jobs asking for experience in React / Redux now than with Angular (though there is quite an overlap in the requirements and usually people state "Angular" as well as "React" in some of the jobs, most of the projects I've seen are projects based on React) given that React is by far a newer technology, and Angular has been around absolutely years now - you would expect to see Angular a lot more infact than I see it, even in the larger corporates, where you would expect newer technologies to be slower to be brought in.
I assumed he meant "push notifications". Really hard to find a library that offers these for multi-browser/platform support. 
Wow, Thanks! I just looked into this and it seems pretty cool.
One of the better introductions to javascript. I think it's best suited for someone with previous experience. Good choice.
I don't know personally, I often advocate for ES17 or ES'17. Be the change you want to see in the world!
Distributed web, e.g. localized content serving or mobile mesh networks in the event of a government ISP shutdown or natural disaster.
This was maybe meant to be sarcastic, but it's true: ECMA262 has mountains of prose and only a couple figures. A [recent pull request](https://github.com/tc39/ecma262/pull/916) doubles the number of figures. There is still more work to do.
It does a bit I guess, although most everyone else's work is done by the first of the year when the release candidate is snapped rather than when the final version is ratified. Many TC39ers aren't impacted at all by the release.
The standard advice from both the React team and the Redux team is to definitely focus on learning React first. There's fewer concepts and terms to learn, and once you have a good grasp on React, you'll have a better understanding of why a state management tool like Redux can be useful. That said, I have definitely seen a few people mention that they either didn't fully get React until they understood Redux, did want to learn them both at the same time, or actually learned Redux first. (Example of the first case: https://news.ycombinator.com/item?id=14716089 .) Similarly, while the recommended approach for learning React is to use Create-React-App and _not_ worry about Webpack and Babel, some people feel the need to start from scratch so they understand all the abstractions and layers. If that works well for you, great! Different people do have different learning styles, and if you _want_ to start with Redux, or tackle Webpack+Babel before really starting on React, go for it! But, the majority of people do need to ease into things, and so the standard advice is "Start with just React, use CRA, learn Redux later, and only worry about Webpack+Babel once you're fine with building an app." Also worth reminding people that Redux doesn't _have_ to be used with React - you can use it with any UI layer, including Angular, Ember, Vue, or even good ol' jQuery/VanillaJS. Dan specifically wrote a ["counter-vanilla" example](https://github.com/reactjs/redux/blob/f4c908b4e0b47a090fb4036e1f12fc1729fd1bb5/examples/counter-vanilla/index.html) that shows using Redux with a script tag and plain JS DOM manipulation to emphasize that.
Yes the use cases like the two other guys mentioned are useful thoughts. I am starting to write an application which should run offline on an iPad. It stores data and should work like a REST API Backend. But I want to have just one codebase and ship the application on iOS and Android. This was the only right way to do so.
:D as I started to search for a cordova plugin like this I could'nt believe that there aren't plugins (a webserver on iOS and Android) out there. So I write one.
There is a really good YouTube channel called coding train for p5.js https://www.youtube.com/user/shiffman
Yes
Overconfidence is exactly what I'm cautioning against. I've seen far too many centralized sec groups and audits miss key flaws. There is no substitute for best practices and broad understanding of the basics. Overly depending on one group is dangerous.
notifications is an overloaded phrase, but in general can mean anything from notifications within a browser window to something like push notifications on a phone OS.
Javascript has overtaken humanity and achieved transcendence. 
* UTF-16, *still*? * Where's my cake operator `||=`? * Can you tell my first two bullets are mostly troll banter? * What was the most difficult part of the process, start to finish?
It’s leaving the world far behind. 
I wouldn't blame react, I've done lots of front end work in a lot of languages, and browser based is the shittiest, needs lots of work. Minimizing html/css is just a way to stay sane as you write thicker clients and have to keep everything connected and maintained (and no you don't need react to do that, I have no plans to use react). fwiw, not even sure JS is long for this world as transpilers flourish and the browsers enable more native-like performance, and long solved user interaction solutions make their way to the web. Also, some have even gone so far as to basically make the web page a canvas and make their own widgets. This is similiar to what autodesk did way back when they needed a consistent graphical user experience.
Made improvements to the immutability story and compatibility with PureComponents. https://github.com/floating/restore/blob/master/tests/index.test.js#L347-L403
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [floating/restore/.../**index.test.js#L347-L403** (master → a33a41b)](https://github.com/floating/restore/blob/a33a41bf9bfa5b8a5b02e0f51846a7db44e9ec52/tests/index.test.js#L347-L403) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dk4k30x.)^.
What a stupid fucking article. The author admits freely that the three main front-end technologies are * HTML * CSS * JavaScript Well, only one of those is a programming language. Of course it's going to see a lot of use and evolve with the times. &gt; However, it seems nowadays that most front end developers, and people looking to hire them, are only caring about the big “J”, Duh? HTML is a fairly simple spec, and CSS can be taught/learned easily enough. Javascript is, again, the only **programming language** for front end development (excluding wrappers, facades and enhancers such as coffeescript and typescript). Of course people are going to want to focus on that. The ignorance here is propping up Javascript against a non-existent opponent. The author presumes to say that HTML and CSS are ignored when evaluating a front end developer position. This could not be farther from the truth. The author's own reliance on React as an example framework tears apart this conclusion when one stops to realize that JSX is just **HTML inside Javascript**.
Javascript has its use but this echo chamber where browser devs try to convince themselves that js is the definitive language is not helpful and I think it increases the despise with which JS is considered by other devs. I mean JS empowers people to do stuff. That's awesome. And I also get that once you know JS you may want to use Electron and of course you can, however I don't want to kill my RAM so I'm not going to use your application. Only because you can write a desktop or mobile app with JS it doesn't mean it is (or it will be) your best option.
So, I don't have desktop experience (that's relevant to this discussion anyway), and I have some mobile. But one of the huge benefits of JS is the cross-platform solutions. Electron, React-Native, even Ionic to write applications once and cross-compile. (the alternatives I know about - Qt is ugly as anything, and I'd be willing to give Xamarin a try but I don't know much about it). /r/programming loves to shit on people using JS solutions for desktop and mobile as simply "webdevs who don't know how to program in real languages", but honestly, as a lone developer, I'm not writing a Java app and then also an ObjC app when I want to release something. If my app gets popular enough, I'll port it eventually, but to start out, no way. I don't have the time for that. Are there other desktop solutions where you can write once? If I ever write a desktop app, there's no way I'm writing it twice, is my point. That's where Electron is awesome. It's not because I *can't* write a desktop app in another language, it's because I don't have time to do it twice. 
*"One city at a time"*
teamtreehouse.com
Yes, you are definitely way too old to get into programming. You won't be able to wrap your mind around it, unfortunately. Coding is very complicated and it's not something an old person would be able to learn. I hope try comment helps! Best of luck. 
Agree 100% would like to add that I'm glad JS is taking over because as a primarily Java and C guy, I can say I like reading JS a lot more than HTML and CSS. Its also good that front end devs know how to read code. I've worked at places where our "creative media" team *only* use HTML and CSS and are scared of JS in 2017...
Java. Sometimes you can even use C, C++ and C#. The uniqueness of Java is for compilation really. But my comment wasn't about: You can't do that. It was about: Should you do that? Not if you want me to run your code in my machine. It's not about "real languages", it's about facts about the current technology. Javascript it's not close in any way to the "real languages" in terms of performance and raw power.
Thank you for saying this, I was annoyed by and tweet mentioning CSS as favourite language...
&gt; AngularJS development companies are hiring AngularJS Developers who has the right knowledge of the framework and who are skilled in JavaScript to take their organization to the Pinnacle of Glory which the great customer services and satisfaction. I wants to reach the `Pinnacle of Glory`.
It's possible that Java has come a long way, but I *hate* the look of Java applications. Granted, it's possible the only ones I notice are the bad ones, and the good ones are using libraries that I can't tell. But for a long time, I'd cringe at any application written in Java, most likely Swing. The UI libraries may have gotten better. C++ sure - I haven't looked into any of those libraries either. I'd probably look for one of the c++ or c# frameworks if I ever wrote one. I have such a strong distaste for Java in general. I really don't like that language lol. 
I can't tell actually, I hear feedback like this all the time :) Cake operator I like (coming from Ruby where I used it a lot) but its not on the roadmap at the moment. Put together a proposal! The most difficult part is typically people problems - figuring out how to get 40+ people to agree on any one thing is often very difficult. Sometimes my job feels like a congressional whip :-P Outside of pure "process", cross-cutting concerns are always the hardest to deal with. Like, proposal A requires that proposal B make changes but we're not sure if either or both will make it so it's not clear who should change or where those changes should go. This comes up a lot with the new class proposals.
https://www.google.com/amp/blog.techmagic.co/angular-2-vs-react-what-to-chose-in-2017/amp/
 https://www.google.com/amp/blog.techmagic.co/angular-2-vs-react-what-to-chose-in-2017/amp/
&gt;JS won't be going anywhere. Yup, it may still be here, like COBOL :)
LOL. maybe at the tiny startup scale.... but.. when you're doing actually complicated apps--when you have 200 test cases for state and flow (what actually matters) each sprint, there's no time to finagle with all the native ios/ native android/ mobile browser / desktop browser / native desktop rendering views. 
Working on it!!
&gt; There's fewer concepts and terms to learn There's fewer concepts in `React` than `redux`? Is this a typo? Redux is basically a switch statement.
https://imgur.com/DmHUMjE
https://imgur.com/DmHUMjE
Maybe I'm just too blunt after 11 years of dev, 20 years if you count non-professional work.
lol what do you even mean you “hate how javascript looks”. You mean like not some shitty Spring enterprise GUI?
[removed]
ok, fine: https://imgur.com/DmHUMjE
[removed]
AngularJS =/= Angular
I can't seem to find a good answer there. But there have been many languages to claim that title and I doubt it is going to stop with JS, which does not have a "wide" margin afik, or even in the lead, depending who you ask https://www.tiobe.com/tiobe-index/
He didn't mean the look of Java the language aka syntax, but the look of the cross-platform UI. It stinks. Electron apps can look much better than that.
bootstrap css here
Can anyone recommend a good book or guide for someone who knows pre-ES6 javascript but wants to learn all the latest ES6+ features in depth? 
and many will still rely on leftpad
&gt; The author presumes to say that HTML and CSS are ignored when evaluating a front end developer position Well, technically, it more or less is. From my personal experience, HTML/CSS fluency is expected in graphic designers. It's just assumed that a front end dev knows enough to turn a PSD into a pixel perfect HTML/CSS representation. The only html/css questions I've gotten in front-end/full stack interviews boil down to how do you position divs in a row or some other trivial question that takes u 3 minutes of time to focus on the more important stuff 
&gt; JSX is just HTML inside Javascript It merely resembles html but doesn't really have anything to do with it. The renderer takes the function calls that jsx transpiles to and creates nodes for the target platform, be it the browser, mac, windows, etc. With jsx html is an implementation detail.
So, I think something that would help you is to start a project from the ground up. Myself (and probably others here) are more than happy to chat with you, give feedback on your ideas, help review your code, etc.. If you're familiar with github or bitbucket, they are great places to put your code up for feedback. I'm sure you could even just have a new thread on here or another sub (any have any suggestions if there is a better place?) where you can post your ideas and projects and get good feedback. This is all to say, I've done the most learning when I have other people poke and prod at my code. Code reviewing is a great way to get explanations (or opinions) on why your code may be good or bad, slow, inefficient, more of a hack than a solution, etc. Plenty of times I've found out I had been doing something the hard way, or a way that would be hard to debug later, etc.
My point was that it's not proper to compare HTML/CSS proficiency vs. Javascript proficiency in terms of evaluating a job position. They are not equals. The author claims javascript is "taking over" but it hasn't supplanted anything.
HTML is an implementation detail to JSX as Javascript is an implementation detail to Babel. Technically correct, but not overly relevant considering the use case.
Why would we say that HTML and CSS are not actual languages? Are they more like`JSON`/`XML`, so more of a `meta language` than an actual language?
Well, they deleted the post you're replying to - but if it's a single-threaded environment the run time of a request is rather important, because you're not serving any other requests. 
Heh. I wish everyone viewed Redux that way :) Yeah, there's definitely a lot of new terms and concepts when you dive into Redux, especially if you don't have any kind of a functional programming background. "Actions", "action creators", "reducers", "pure functions", "immutable data", "middleware", "dispatching, `mapState`, `mapDispatch`, `connect`, etc. I do think that a good portion of the confusion for new learners is with the FP aspects themselves, but it is a lot for many people to take in at once.
Overtaking. Currently first at [L4](https://en.wikipedia.org/wiki/Lagrangian_point) position.
The web assembly devs even state that it's in no way going to replace JavaScript, but would more appropriately work aside JS.
I kinda miss the days when you could disable javascript and still browse the web.
It only has minor semantics in common with HTML like that an element can be named "div", this is only true for the browser, other platforms have their own elements. [It could also fade given that react-native-web and reactxp already aim for universal apps that don't share htmls named tags.](https://github.com/necolas/react-native-web)
Once I saw p5 I knew he was going to be mentioned. That guy is insane, he's released like 30 tutorial videos in the last few months. 
I also agree entirely about being able to hand off your templates to a design team. Having them coupled with your logic (which is inherently your intellectual property) makes that both hard and a risk.
Most java that is live in the world right now is a far cry from efficient, but its okay either way you explained what you were getting at. I still disagree, but its fine to agree to disagree. 
HTML has no conditional operators, no logical operators, nothing that lets you actually make it do anything. Its just a way to describe a document to a machine. The machine has to understand the document so that it can present it visually to a user. 
It's 2017. My 2013 Macbook has no issue running Electron apps (besides Atom) with two external monitors attached. For me, since I stare at a screen all day, aesthetics are more important than a negligible performance advantage. Visual Studio Code doesn't kill my ram, nor do the 8 other electron apps I have concurrently running (Alternote, Headset, Kiwi for Gmail, Hyper, Spotify, Slack, Webtorrent, etc.) along with FileZilla FirefoxNightly, Chrome, Chrome Canary, and Opera Neon with about 40 windows open between them and god knows how many tabs. Just because Atom is a bloated, slow app doesn't mean all Electron apps hog your resources. 
does this work with sourcemaps?
`markup language`, hence the ML at the end of HTML and XML, but yes. 
I made a face-up [memory-ish game](http://mrspeaker.net/dev/cbff/) in 2006 using stock photos, that I still "enjoy" from time to time. My favorite part is that in 2006 my internet connection was really slow so I just put a mandatory 20 second timer before the game starts to preload everything. Classy!
Well, I also don't like Java in general lol. I like C# a lot though, which is, I admit, a little weird since they're so similar. 
&gt; Css makes things easier but I think that things should be efficient rather than easy Do you not take time into account when considering efficiency, especially your time?
Not really a "duH" to be honest because just five years ago, a "front-end dev" might not have touched any JS at all. In fact, 6-7 years ago, a front-end dev was purely concerned with HTML/CSS. And some companies still keep to that today. I used to know "front-end dev" positions back in the day that were basically HTML/CSS and *some* Wordpress. Or PSD to HTML/CSS jobs. I do front-end dev as part of my job and I do a shit job with CSS. And I know people who can run circles around me with their CSS knowledge. As a side note, yeah, JSX is basically HTML in JS. :)
&gt; Javascript is, again, the only programming language for front end development Don't sass much, do you?
I wasn't really trying to argue much of anything, I really just thought we were having a discussion. Personally I wouldn't use Java by choice because I don't like the UI frameworks I've seen (and I don't like the language much in the first place). My original question was really just a one out of curiosity about what languages/frameworks you'd use to write a desktop application that looks good. &lt;shrug&gt; That said, subjective look and feel *do* fit into a debate about what the best tool for the job is. If Java apps look bad and JS one's look good, I'd lean towards JS, especially for lighter load applications. But that's fair if that's not the discussion you wanted to have. 
He was probably referring to efficiency as in performance. Things like electron are great if you want a quick turn around time, and the app doesn't need to do heavy computation, but if you need raw performance c++. or some other language, is the way to go. But I do wonder how well an electron app would work if you do the heavy computation stuff with a c++ addon, if you can even use those with electron.
Actually, I do. Functions and loops and vars are all good, but you're not building any real "apps" with just sass.
You still can, mostly pretty well. I run noscript at home and after the first week you mostly have whitelisted all your regular sites. When you hit new ones as you're casually browsing linking around you just "temporarily allow all this page" and continue on, though granted, you do have to do that multiple times in some cases (allow scripts that load other scripts, which load other scripts...) It makes for faster browsing as you can bypass a lot of ads. 
Don't fret, you can compile JS to WASM.
&gt; Things like electron are great if you want a quick turn around time, and the app doesn't need to do heavy computation, but if you need raw performance c++. or some other language, is the way to go. True. But in those cases, Electron isn't the tool for the job, unless it is to create some client UI that interfaces with a private server or cloud infrastructure via an API....until now :O &gt; But I do wonder how well an electron app would work if you do the heavy computation stuff with a c++ addon, if you can even use those with electron. WebAssembly is available as of Electron 1.7.0 :D
I'm 44 and a strong believer in the nap. my employers, on the other hand...
According to this they are stage 2? https://github.com/tc39/proposals/blob/master/README.md
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [tc39/proposals/.../**README.md** (master → ee9b320)](https://github.com/tc39/proposals/blob/ee9b3204622e5d488dbf26eda87e51a117a4529a/README.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dk4tbv4.)^.
&gt;in some cases using third party frameworks such as Bootstrap to handle all of the User Interface (UI) development. How is that a bad thing? Frameworks are a great thing, and knowing how important it is to take advantage of them is really good IMO.
sigh... Do you even know that AngularJS and Angular are different frameworks now? You need to do compound chart of AngularJs and Angular vs for example React, Redux. And are you even comparing old angular with react or just new? I know, research methodology is difficult thing... 1) know your hypothesis 2) use proper and replicable methodology 3) validate your hypothesis
Modern Java applications actually look quite good.
Well, html and css arent comparable with JS... If you have STATIC page, you use only markup language (html, css) If you have DYNAMIC page (=with lots of interactions), you need to add language with some logic. And thus, javascript. (But html and css are still used!) Ammount of javascript then depends on ammount of interactivity.
A pretty nice overview you'll find on babels page: http://babeljs.io/learn-es2015/ And the whole thing is explained here: http://exploringjs.com/es6/index.html#toc_ch_first-steps
Right we all know this difference. I'm talking about things like repeaters, if/else, bindings. Its good that there are things you technically could do statically that are being handled in JS.
I suppose you could do it that way, never seen anyone do it, though. Harder to control the context I would think.
Since notifications are unlikely to be serialized, I would recommend passing an element or component to state vs storing text: const Toast = ({ toast, hideToast }: ToastProps) =&gt; ( &lt;div className={ `toast ${toast.className}` }&gt; { toast.component } &lt;div onClick={ hideToast } className="close"&gt;x&lt;/div&gt; &lt;/div&gt; ); dispatch(setToast(&lt;div&gt;all the goodies of &lt;b&gt;component here!&lt;/b&gt;&lt;/div&gt;))
Slack easily uses 75-500MB at any given time, Spotify often goes past 2GB for many users. Meanwhile, their compiled contemporaries (IRC clients, Pidgin, Winamp) would use less then 10% of that and far less CPU usage. Bear in mind the average consumer PC has still has less than 8GB of memory. I'm not saying Electron/V8 isn't okay for general use or that Spotify needs to rewrite everything in C. I'm just saying there's a time and a place for interpreted languages and JS is no exception.
Do you know of any major ones off the top of your head? I'd be interested to see where they're at. Some of the examples I saw on reddit threads after googling weren't that impressive looking, to be honest. 
You seem to not know the terminology. Javascript, HTML, CSS and other are all `languages` in mathematical sense (https://en.wikipedia.org/wiki/Formal_language). Then there are `markup languages` (https://en.wikipedia.org/wiki/Markup_language) and `programming languages` (https://en.wikipedia.org/wiki/Programming_language). The latter one has flow control (if, for, ...), which is typical for activity called `programming` So person who writes HTML/CSS isnt doing activity named `programming`, but this doesnt mean, HTML/CSS arent languages. They are only not `programming languages` Very strictly speaking, CSS3 could be considered programming language, since its turing complete (http://my-codeworks.com/blog/2015/css3-proven-to-be-turing-complete)
I get your point and I don't *technically* disagree. But I think you'd be smart to realize that the typical user that we're all building for doesn't know anything about perf nor do they care so long as your app just works. The subset of users that is either A) running on some ancient machine with RAM problems or B) a dev themselves and cares about performance for performance' sake is quite small compared to the total and really shouldn't be a significant consideration. JS has become so popular not because it's the best specific tool for every specific use case, but because it's a generally acceptable tool for nearly every specific use case and that alone is extremely powerful. Being able to master a single language and then build websites, servers, utility scripts, mobile apps, desktop apps, and even program many devices like Alexa is pretty ridiculously cool. And JS is just as much a "real language" as any other.
Very strictly speaking, CSS3 could be considered programming language, since its turing complete (http://my-codeworks.com/blog/2015/css3-proven-to-be-turing-complete)
This JavaFX theme is okay: http://fxexperience.com/wp-content/uploads/2013/03/Modena-Windows-v1.png not sure what Eclipse uses but it has always looked pretty nice IMO: http://www.tutorialsface.com/wp-content/uploads/2016/09/Screen-Shot-2016-09-14-at-12.26.19-PM.png same with IntelliJ: https://www.exoplatform.com/blog/wp-content/uploads/2014/11/01-IntelliJ-dracula-theme.png Other than that, I'm not really sure other than I know there are good looking modern Java applications. I'm not much of a GUI developer when it comes to Java, my experience with Java is more CLI-based.
It's not remotely fair to compare Winamp to Spotify, or IRC clients to Slack. If you were going to extend Winamp or mIRC to have all the functionality and 2017-appropriate appearance and pretty animations of Slack/Spotify, their memory usage would also skyrocket. Probably won't hit Electron levels of usage, but the difference is likely to be acceptable to the majority of their users. Most web dev teams don't develop for people with the mentality that UIs should be simple and ugly and consume the lowest amount of resources possible. That's just not what the majority of users want.
Wait so Swift, Java, C#, and C++ aren't front end languages any more?
Exactly, I've used Electron apps on various machines that were built from 2013 to 2017 and they've always been fine. The only way I'd even notice how many resources they're consuming would be if I actually opened the process monitor to check.
JS is a garbage language and should be done away with but these morons that love to circlejerk are the entire reason we aren't progressing in the web community.
Dammit, guess i meant stage 3 :/
There are ways to build native applications that look good without sucking in ram and being total shit.
Is there a reason why Spotify is "total shit" other than resource consumption? Sorry that nobody wants to develop apps for your computer from 1995 lol
Javascript has passed through the Iris.
Sorry, not everyone can shell out 2k dollars at the mac store to buy 16gb of ram and 500gb ssd. Do you not realize that the majority of people don't have machines like you do? That many consumers have machines that are 5+ years old, almost obsolete? Or is your head so far up your own elitest ass that you don't see the benefit in doing able to do both. Sorry, good software is hard, shitty devs like yourself will never see that benefit. If a music streaming app is sucking over a gig of ram to stream a song, that is total shit by anyone's standards other than the elitist devs like you who believe 'Sorry that nobody wants to develop apps for your computer from 1995' People like you are the reason the dev community is trash, you accept shitty specs and shitty applications beaus you can afford it. 
Even if you're unlikely to include notifications in serialized Redux state, that's a rather pointless step. Part of the Redux philosophy is to store the minimal amount of data needed in your state, and derive from it as needed. Here, all that's really needed is the text, and maybe a couple values like an ID. It's also possible to handle callbacks and other "return values" from notifications and modals without having to resort to putting functions into the store. Does require a slightly more indirect approach, but very doable. I [wrote a blog post that discusses using pre-built "result" actions as props](http://blog.isquaredsoftware.com/2016/11/posts-on-packtpub-generic-redux-modals-and-building-better-bundles/), and there's also libs like [redux-promising-modals](https://github.com/AKolodeev/redux-promising-modals) as well.
Lol you're hilarious, it's like you have nothing going in your life so you just act over the top aggressive over tiny issues on the internet. Too many people like you in the community. Anyway, I'll trust that they did the market research themselves and have a better idea of what hardware their users have, and that they have a more accurate number than the speculative users you pulled out of your ass.
Then I totally agree :D I'm really exited about this and class properties. 
Uh... scripts in any Microsoft Office document are VBScript, not JavaScript.
YMMV but it's clearly not pointless. that's akin to saying never store functions as variables. It's better to be aware of when it is and when it isn't useful to do so, and passing a component through a common ancestor (redux store or whatever) is a perfectly reasonable and often correct thing to do, imo.
In defence of your parent post (and the post this entire thread hangs under): no one really said that HTML or CSS are not languages (at least not in the current edits). 
really? no performance changes with the upcoming synchronous fiber rollout?
Sure, live in your bubble of shitty code and elitism. 
i'm not sure i agree with your last point, if only because ruby &amp; python would both no longer be "real languages" due to their performance/raw power being provably inferior to post-google js. a language's expressive power and utility extend far beyond how well its performance tracks against C/C++.
With HTML I mostly agree, but CSS has quite a lot of new things going on that frontend developers need to know and stay on top of. That one is a programming language and the other isn't isn't relevant when fronted developers still have to develop using both.
In computer science, a "language" is a set of finite strings over some alphabet. JSON and XML are both absolutely languages. That they aren't executed doesn't mean they're not languages.
That's why you need to work from home. I swear if I ever setup an office for people there will be some quiet nap rooms.
As a Redux maintainer and author of the Redux FAQ: this is one of those things that comes under "yes, it's _technically possible_, but you really shouldn't unless you really know why you're doing it and absolutely have a really good reason to". :) For reference, see [the Redux FAQ entry on putting non-serializable values into Redux state](http://redux.js.org/docs/faq/OrganizingState.html#organizing-state-non-serializable) and my post [The Tao of Redux, Part 2 - Practice and Philosophy](http://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-2/).
I mean, HTML is a language.. never said it wasn't. The fact that the L in HTML means language should be fairly clear. But it is not a programming language as you said. It is of course without having to expand on the abbreviation, a Markup Language lol. 
It was a test to see how good the people were at frontend development; letting an external library do everything seems like a cop out. And why would Bootstrap's design choices be exactly right for your current problem? Can you explain why you prefer Bootstrap's grid system over CSS Grid? It reminds me a bit of the people who could only use jQuery in JS, and didn't know how to do things without it. Sure, it's fine to use a handy library, but there will be a time when better options exist and you'll need to know about them and be able to judge them for your particular case.
Isn't leveraging existing technologies instead of reinventing the wheel part of being a good programmer? I do agree that they should know the basics but libraries/frameworks are there for you to use them rather than just creating from scratch.
Yes, but it's still not part of showing that you are good at making that sort of thing yourself.
Of course, depending on situation, most of that should be done server side, which allows a broader array of languages. Unless you want additional overhead, in which case go ahead and do clientside templating. I did when I couldn't do cgi on my last (free) host.
[more broad](https://github.com/jashkenas/coffeescript/wiki/list-of-languages-that-compile-to-js)
You can use https://github.com/gajus/usus to automate the task using CLI or Node.js interface.
I think handling callbacks specific to the notification could be handled through action creators. It just depends how much information is stored as part of the notification in the Store. 
&gt; Well, only one of those is a programming language. Of course it's going to see a lot of use and evolve with the times. As of now, u/ripvanwinkle said: &gt; Well, only one of those is a programming language. Of course it's going to see a lot of use and evolve with the times. http://imgur.com/iWG7L4m.png which caused me to ask why we would say that HTML and CSS are not languages. 
Poor buddy just was in a bike wreck, though. Broke an elbow and messed up a wrist. I hope he mends soon because I love the CodingTrain channel on YouTube.
[The Singularity](https://en.wikipedia.org/wiki/Technological_singularity) will be written in JavaScript.
&gt; JavaScript really is overtaking the world No it's not. You're just so focused on JS that you don't pay attention to what's happening around you, in other popular technologies. And quite a lot is happening, including in markets where you think JS has become THE standard. "JS is getting quite popular" is true. That title is just a strongly biased view of the current state of IT.
Looks kind of cool - I would add https to your domain though, gives unproven projects an extra boost of credibility which can help in the beginning (not to mention Google prioritizes websites with https in search results, and will start penalizing sites without it soon enough)
One of my professional nightmares is going back to the HTML/CSS/Wordpress kind of agency... :'(
I've got no experience with writing desktop apps in JS professionally, but why would it need to fry your ram?
Text on your site is unreadable against that background. If you're attempting to attract designers, you'll need a designer to fix that up first. Oh shit... There is a navbar hiding there in plain sight!!! Was wondering why the page had no information on the library.
While I agree, I would also consider that you'd likely be adding considerable file bloat for a tiny bit of styling
http://webaim.org/resources/contrastchecker/ Fore: #ed225d Back: #fdcdc1 Contrast Ratio: 2.94:1 Normal Text WCAG AA: Fail WCAG AAA: Fail Large Text WCAG AA: Fail WCAG AAA: Fail 
I mean, you can customize bootstrap to be as lightweight as you need it to be: https://getbootstrap.com/customize/
All of the IntelliJ/WebStorm/etc family is written in Java
No it won't. The singularity will definitely be written in a programming language with good performance. 
I'm pretty sure JS is almost be on par with Java in performance.
Woosh
spotify isn't electron and slack has bugs in os x i think.
Is BMP not supported? It should have been a bit simpler. It's comparable to TGA and PCX. Simple header, uncompressed, and there aren't any checksums either.
He said "programming language", which, as you yourself point out, is different from markup language. 
...oh...yeah...
It's obfuscated. https://en.wikipedia.org/wiki/Obfuscation_(software) Use a minfier instead.
**Obfuscation (software)** In software development, obfuscation is the deliberate act of creating obfuscated code, i.e. source or machine code that is difficult for humans to understand. Like obfuscation in natural language, it may use needlessly roundabout expressions to compose statements. Programmers may deliberately obfuscate code to conceal its purpose (security through obscurity) or its logic or implicit values embedded in it, primarily, in order to prevent tampering, deter reverse engineering, or even as a puzzle or recreational challenge for someone reading the source code. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/javascript/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
It's [obfuscated](https://javascriptobfuscator.com/Javascript-Obfuscator.aspx). The purpose it to hide the original code from being stolen or manipulated otherwise. There is no purpose in this case - since the original code is displayed directly above it.
Is JS even that? Maybe among people who only know one language... 
Assembly kek.
I own a pretty modern pc, i3 4160-8gb ddr 3 1800 mhz, rx580, but opening spotify (or the league of legends client which is in angular I believe) is never a pleasant nor "quick" experience. I just don't want to imagine for a moment stuff like steam being in js.
It's not the greatest, but it's certainly not [unreadable](https://i.imgur.com/d2mrLsP.png). And, to be fair, their [reference pages](https://p5js.org/reference/), which is where most people are going to be anyway, are pretty amazingly done, imo.
Nice. Looks like a good minimalist solution rather than including all of Apache or something.
&gt; certainly not unreadable. What if your monitor temp isn't turned up to *"Burn your eyes out to sell this nice new LCD monitor"* levels? Those colours fail contrast ratios pretty badly. That's objective rather than subjective.
Well, my monitor's IPS and 99.whatever of the Adobe spectrum, so maybe that's helping me out. On my shitty old TN television, though, it [still looks fine.](https://i.imgur.com/MOD0aQH.jpg) It's not even color balanced. I don't actually know how that would affect it, because I'm not a graphical designer. But eh, I can read it on every device I've looked at it on.
/u/wowmansohacked, am I going to have to separate you and /u/sparkbusiness? Don't be a jerk, please.
It's made to look HTML to make it easy, but it's actually different. It doesn't just render as if its a basic templating system. One example is that you use the attribute "className" which gets rendered as "class". Another, you can't just type &lt;br&gt; without making it self closing &lt;br/&gt; or it won't work because JSX can't handle an unclosed tag. If you're tying to render an AMP page you need special configuration for the app-* attributes to end up in the output. The "attributes" are actually props that you're passing, so if you don't handle "className" in a component you create, it won't render. You could just write function calls normally but the point is JSX is easier to read. It doesn't need to resemble HTML necessarily.
why do you search for reactjs? reactjs was never the name of the library. this is intentionally misleading. for reference, here's your first search term redone. http://i.imgur.com/1IgdL1l.png here's your indeed search redone. http://i.imgur.com/9byKhwF.png i have no dog in this fight, but it seems like you're twisting the data to suit your argument instead of the other way around. your "im right you're wrong and that's the end of it" attitude certainly doesnt help your case.
Free code camp is nice.
Nbd just don't like people who don't consider end users.
good call, now is secure www.handsfreeforweb.com thanks :)
I don't understand what this accomplishes that isn't covered by 'git diff .'
huh?
At least we know that the C-like syntax is time-tested and well-liked unlike COBOL which was basically never liked.
Not sure about within Android notification systems/OS but There's no support for BMP on the web except for in Internet Explorer.
Because each one comes with a significant portion of Chromium.
&gt; JS is just as much a "real language" as any other. By what definition? I'm curious as to what your definition actually excludes.
Yeah it's not new tech, just an interface, you can get the same info from continuously typing git diff and parsing the output yourself
It even has a calc function!
Now it just needs configurable, non-stupid indention rules.
Firefox, Chrome, and Safari also support it. https://en.wikipedia.org/wiki/Comparison_of_web_browsers#Image_format_support
**Comparison of web browsers: Image format support** Information about what image formats the browsers support. External links lead to information about support in future versions of the browsers or extensions that provide such functionality. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/javascript/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
Good point! I did look into BMP, but couldn't find definitive documentation on using alpha transparency in a palette. At the time, PNG seemed like a better choice because I could find clearer documentation. Knowing what I know now having done it, I doubt I was right.
God help us all. Crackers and script kiddies will have a field day.
wasm, maybe rust + js glue
This was pointless most of the time
Numpy and pandas are two of the main reasons why I will never use javascript for my backend. All the web development I've done has been for visualizing and interacting with numerical data which I process and serve with python over a websocket. I don't think javascript is ever going to beat python there. 
Good question, and I don't have a good answer for you. I just meant that it's a fully capable, mainstream programming language like any other. I'm not aware of a reasonable definition of a programming language that would exclude JS.
Why would the singularity occur within a web browser lol? It's going to be backend on like servers / workstations for sure.
That measure is clearly horrible for trying to measure the currently most used languages. That's just a fancy sum of search engine results for "&lt;language&gt; programming". If you were ever to get the currently most used language at the top of that list it would be due to pure random coincidence. 
I'm so glad you said this... as an applications recruiter I'm not a developer but I feel I'm picking quite a bit up about technology. At least able to speak to it... but I felt like an idiot while reading this. Why would he compare anything to bootstrap... It's just for responsiveness right? I've always been told CSS is just to make things look better (for lack of a better term) that's not even close to what JS can do especially when combined with the power of client side and modern frameworks like react, angular, or vue among others Oh and why doesn't he try knockout...instead of css?
Interesting... they certainly didn't for a while, as I had to fix an app that used them all over and it broke in all non-IE browsers at the time. It made sense too, why on earth would one use a non compressed image format on the web.
Yea, BMP doesn't really do alpha. There is a forth channel which could be used for that, but software support seems to be virtually nonexistent. Didn't look like alpha was required for your use case, though.
With gzip compression, uncompressed image formats are comparable to PNG. PNG uses the same compression after all. The difference is that PNG can also use filters which sometimes improve the compression ratio a little bit.
I don't even know where to begin. &gt; It's made to look HTML to make it easy but it's actually different. Nope. &gt; It doesn't just render as if its a basic templating system. Yes, that's EXACTLY WHAT IT DOES. JSX is a **syntactic sugar** for telling React how to orchestrate the creation of DOM elements (virtual or otherwise) with props and content. That's its **sole purpose**. Even the most basic React documentation will tell you that JSX is completely optional. JSX tells React the same thing HTML tells a browser: *This `div/span/whatever` node goes here and gets these attributes.* That JSX "resembles HTML" in reality is no coincidence. Its structure is unequivocally designed to mimic standard HTML markup because such markup is easier to reason about at a glance than `React.createClass('div',...)` or `document.createElement('div')`. The subject of `class` vs `className` is merely a language constraint (`class` is a reserved word in Javascript), not some magical JSX implementation detail. The same goes for self-closing tags. Do a little studying on the history of html (and XHTML) specs if you want to understand more about the nuance of requiring a `/&gt;`
True, though most servers apply gzip to text content and skip it on binary files... that might require a server confit change.
Ah, I see now that it's live. That's actually pretty cool.
Ok, if you want to be pedantic. http://imgur.com/a/IFtz2 the same could be said about either, just trying to eliminate noise. 
Why do you need to be an ass like that, "I don't even know where to begin." Get the fuck out with that kind of toxic shit. Is that really needed? It's syntactic sugar for React.createElement. In React Native you still use JSX but it has nothing to do with HTML at all, and instead you end up making native API calls. How React eventually renders to the screen is dependent on whether you're using React-DOM, or React Native on what platform.
for those of you who are [curious](http://imgur.com/gallery/cRvyM). 
yea, the users aren't courteous enough and don't cache in case NPM goes down. Punk' ass kids = startups and noobs.
yes, that chart has too much noise to be useful to draw conclusions from. that's why i chose to omit it - it doesn't provide anything of value. the one i posted has _significantly_ less noise and does allow us to draw a reasonable conclusion - job seekers are more interested in react than they are in angular and angular 2 combined. it's also not pedantic to ask you to use the preferred search term for a library when comparing popularity. google even filters it to discussions specifically about the javascript library so you can be sure noise is minimized. it was, however, disingenuous to come into this discussion using skewed data to try and convince others of your argument.
Love the idea but if history taught us anything(look at pascal, an educational programming language) it is that these types of abstractions are not ultimately helpful for people that want to learn to code. You're vendor locking them into a library that they cannot transfer knowledge out of(aside puesocode maybe- debatable). 
I wonder if CSS is Turing complete.
Could SVG not have been used? Would surprise me if Android didn't accept SVG for notifications, given all the image scaling concerns of mobile devices.
It is. [https://stackoverflow.com/questions/2497146/is-css-turing-complete](https://stackoverflow.com/questions/2497146/is-css-turing-complete)
MDN (https://developer.mozilla.org/en-US/docs/Web/JavaScript) is a great resource for reference and basic tutorials
No, you can't use SVG. From what I understand it's a *lot* more complex to render an SVG - if I recall, people often use a full webview to do it, which would be very resource intensive in a notification.
They never were.
In the end it wasn't. I originally intended to make the background transparent, to better fit the OS (for instance, Samsung has some skins that have an off-white background) but then I realised there were too many variations to deal with, including dark backgrounds on older devices. So I just make it solid white.
lol nice troll.
Yes rendering an svg using javascript would be a lot more complex, but you shouldn't need to do that. Looking at the Notification api it accepts a url, and you can easily put svg data into a data uri, I haven't tried it for notifications though.
Oh, I'm talking about native rendering, not rendering in JS. Passing an SVG URL doesn't work because it would be too complicated to render. It's disappointing but the SVG spec has a crazy about of stuff in it, including animation, so I'm not too surprised they've never added that functionality.
If you'd like to be a software engineer and to understand how programming works then good way is to read SICP. In original it uses Lisp, but there is a version on JavaScript. Try to google "SICP JavaScript".
Thanks definitely going to try it out! 
Everyone should learn how to use SASS, not because it's a million times nicer to use than plain CSS, but because of how it encourages you to think about grouping elements as *decedents*, rather than a list of classes, id's, and elements -because it encourages you to learn *css* scope. As a result, you write better CSS. And by better, I mean less. If you're giving every element on your page a classname you're making things way too hard on yourself and you probably need a refresher on [CSS selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors). This is a fix to a problem you shouldn't have in the first place, imo. edit: this field is dominated by myopic developers, who think shortening a CSS file (that's literally called once and cached) justifies making every class name on your page unreadable. OP is trying to shorten the length of classname's on your page: I'm saying you didn't need half of those classnames in the first place (0 &lt; smaller).
dunno, Boltzmann brain-like phenomenon? everything will eventually happen in a web browser, more quickly than other mediums? lol shrug
Is the the new thing, stealing texts and re-hosting and -posting them on one's own? * From 2014: https://ihatetomatoes.net/8-tips-become-better-front-end-developer/ * from 2016: https://www.quora.com/I-am-working-as-front-end-web-developer-what-should-I-do-to-improve-my-efficiency * This was and is done with this text many more times: https://www.google.com/search?q=%22The+first+mistake+and+surprisingly+very+common+even+with+senior+developers+is+that+most+of+us+don%E2%80%99t+plan.%22 Also, as /u/check_ca pointed out [yesterday](https://www.reddit.com/r/javascript/comments/6mloyg/12_awesome_hacks_for_javascript/dk2m3b5/): the last thing you posted was stolen, too.
Wasm should be strong enough opponent but it is funny to read how article author left CSS for javascript.
In terms of learning the basic tenets of the language in depth, it's very good. In terms of a quick intro/dive into the type of code you will see in the wild, its not likely the best fit because it does not use ES6.
that explains the memory usage of webstorm etc.
I assume so, but the effect is going to be negligible unless you're selecting thousands of nodes in a hot loop or something, so generally just use what's convenient.
That goes for both react and angular. What you see there is actual use in the real world, some people have tried to spin it before and these arguments are silly. React on a peak day is nearing 300k daily installs and it's on a constant climb, Angular will likely never climb over 80k. You get a similar picture by inspecting eco system, simply search npm for "react" and "angular." 
I think it still has longer way in front of it, real world usage [here](http://npmcharts.com/compare/react,angular,@angular/core,ember-cli,vue,@cycle/run,@polymer/polymer). React is close breaching 300k peak and climbing. Vue gets about 20k and actually falling again. 
Oh. This is nice. Might be just the excuse to write some more ClojureScript.
There's this really cool site called [DuckDuckGo](www.duckduckgo.com) which will give you all the answers you want :)
Mannnn, fuck decorators
Today, **K** was released with **2.4**, and the **Kill la Kill** name. For, the **F** missing, **Kazuya Kawaguchi** explained us, it was reserved for the next **1.x** release : https://github.com/egoist/always-bet-on-vue/issues/3 Here, you could see a bunch of bets about **K** : https://github.com/egoist/always-bet-on-vue/issues/1 Now, you can bet on **L** the Vue **2.5** next letter : https://github.com/egoist/always-bet-on-vue/issues/4
&gt; how it encourages you to think about grouping elements as decedents, rather than a list of classes, id's, and elements -because it encourages you to learn css scope. I am using SASS for about 10 years now. I don't see the relevance of your comment. Yes, SASS does encourage to think about grouping in terms of descendants. This makes the developers life easy. It does not in any way solve the problem of the CSS bundle size. If anything, the resulting bundle size will become bigger and CSS slower because of extensive nesting. I have seen SASS generated CSS with 5-10 levels of nesting in extreme cases. Therefore, SASS users will be the ones who benefit the most from this article. I am assuming you are referring to the CSS modules and have no experience with the CSS modules and therefore think it is some sort of replacement to SASS. It is not. I am using SASS and CSS modules. Both solve two completely different problems. It is true that CSS modules encourage use of unique selector for each element and element state. However, that does not mean duplication of CSS (read about CSS composition, https://github.com/css-modules/css-modules#composition). The minification described in this article has its use regardless of whether the CSS is written without a pre-processor or using CSS modules.
&gt; you may want to use Electron and of course you can, however I don't want to kill my RAM My VS Code with some addons takes about 200-300 MB of RAM. Which is a lot, by the standards of Emacs or VIM, but it's not by the standards of the modern technology.
My point being that there are two kinds of popularity: how much something gets around, and how much people actually like it. 
I haven't used it at all but... [not anymore](https://dev.office.com/reference/add-ins/javascript-api-for-office)
This is nice but it's assumes you would use `[name]___[local]___[hash:base64:5]` for both development and production in the first place which is crazy. You could simply have used that for development and just `[hash:base64:5]` for production by a simple change in your webpack config and get 99% of the win. CSS modules is nice by the way but we have moved on to [Styletron](https://github.com/rtsao/styletron) which takes this even further.
They don't look very good, actually. For instance, their font rendering is [kind of shit](https://i.imgur.com/yWac2E1.png). (Monoid font family, designed to look sharp at certain size - but obviously it doesn't.)
&gt; JavaScript really is overtaking the world *of webdev.*. Though it already has done that years ago. 
&gt; You could simply have used that for development and just [hash:base64:5] for production The primary reason I've gone the long way is to enable the CSS scope optimization on CSSO. It produced a bit less benefit than I was hoping for, though. :-)
I'm pretty sure only for the **O** release in fact, where there is only one obvious choice..
Yep, this sounds like that.. Just hoping for the **O** release to be great (because of its *supposed* name ;-) Anyway thanks for the chart..
That remember me [that quote from](http://brendaneich.github.io/ModernWeb.tw-2015/#74) Brendan Eich
Was there any reasoning to roll your own server side renderer rather than leverage Reacts universal rendering approach? I recently had to make a SPA where performance was key and it was trivial by using renderToString and a cache along with some other performance tweaks mainly around webpack.
Weebs
A 1.x version was still planned after the 2.0 release?
I expected articles relating to writing JavaScript that works in Netscape 4. I'm disappointed.
For what UI apps do yes. But the browser DOM baggage Electron carries around with is hogging both CPU and RAM. If something like Qt Quick had a better javascript runtime for general purpose programming it would probably be faster and more resource friendly than Java GUI apps.
https://insights.stackoverflow.com/survey/2017#technology-programming-languages Keeping your head in the sand, much?
Hello, I was the creator of that codepen. I obfuscated it in an attempt to hide the API key, which the provider of the API requested to. I just decided to obfuscate it to prevent most people from using the same API key, unless they were really bothered. Apparently the JavaScript obfuscator prevents accessing the console on both Chrome and Firefox so you couldn't look at the get request. 
I am assuming you are talking about https://github.com/gajus/usus? The short answer is that: it does not work with my stack. I am using several webpack loaders (for CSS, SVG loading, other component inlining) that are browser dependent. There are workarounds (e.g. https://github.com/gajus/isomorphic-webpack). However, the other reason is that I am using https://github.com/okonet/react-container-dimensions extensively. The latter depends on rendering the page to find out all container element sizes. I cannot see how this could have been done using SSR.
I should be One Piece pretty please
That makes sense, thanks for taking the time to explain it. I'm always interested in architectural decisions :).
No love for Linux? 🙁
Yes. But won't it be better if you could do everything that numpy does right in browser? Then you won't need any server side components or worry about communication between them.
Wonder how Styletron compares to [Styled Components](https://www.styled-components.com/). They have similar features.
Isn't that just a search engine?
Hey, looks like npmcharts is built with Vue :)
So... Like .3% after compression? 
This looks good. Lots of similar testing tools being shared recently 
Oh, I didn't know that. In that case, try deleting the selected text, then insert the table.
**O**ne Punch Man ?
https://m.popkey.co/574b46/WxVke.gif
Great article! I wonder if that original line was hand written or minified using [closure compiler](https://developers.google.com/closure/compiler/), or some other minifier
&gt; browser based is the shittiest, needs lots of work And also the easiest to deploy and runs on more devices (by an extremely wide margin) than any other platform. I guess that's the trade off. :-/
Overtaking over.
&gt; JS won't be going anywhere. I'm personally at a point where I'd still pick JS. I _like_ JS as a langauge, especially the latest spec with async/await and a dash of lodash.
well, applets/jnlp were even easier (IMHO), but that was killed by a number of forces (not the least of which was apple constantly pulling the rug out on it)
As a long term developer, old, I have done this type of breakdown on code many times and it is very satisfying seeing what you did here. I agree with /r/fgutz in that this may have been "compiled" or minified from the original but who cares. If you have to maintain code, even your own, then your final version is what I'd rather be looking at.
I didn't personally care for it. I may not have given it enough of a chance, but I felt the examples were too conflated with other cognitive domain topics. (Of course I might just be an idiot, I just didn't want the extra cognitive burden while learning JS). I much preferred YDKJS and Secrets of a JS Ninja, 2nd ed.. 
Please see "Is it worth it" section of the article.
Just as a post-scriptum `[hash:base64:5]` is not an equivalent option. `[hash:base64:5]` chances of collision are a high with just a couple of dozen of CSS classes. I have not seen any websites using this option.
But most of the concepts you mentioned belong to react-redux binding.
Babel 6+ with babel-preset-env is the easiest and best-supported way to get ES6+ capability. My guess, though, is that things would "just work" if you imported `babel-polyfill` before your app loads. You can upgrade babel after things work again.
&gt; VBScript you can program add ins using javascript and html
usually not minified javascript is far more easy to decompile
Using a throwaway for this as I don't want to be identified by my current employer. I applied for this position and was given the brief this article states. The problem with this article is that the code test that was sent out to me at least specifically stated React and Javascript. Heck even the zip file I was sent was titled "Javascriptcodingexercise-React.zip". I've attached the tweet I responded to the author with. https://twitter.com/thehon22/status/885443254606417920 In an 8 hour time frame, I can understand why some of the candidates would put Bootstrap in and call it a day to leave more time to write the Javascript side of this; especially when it almost seems like the brief is all about Javascript and React. I'd argue that i'd much rather have a functioning app that works in 8 hours and follows to the brief then something that looks really pretty but doesn't work at all. My gripe with the article is some of the things he said. "However, we continue to get submissions from candidates who are clearly only interested in JavaScript" - Well I don't know what you expected when your brief really only mentions things related to Javascript and React. Heck you even made it a point to have Redux devtools enabled. To then also go on and say that some of the candidates don't care at all about CSS and HTML and saying "unfortunately this seems to be the trend" is a bit of a kick in the gut. I'd argue that the majority of front ends do care about CSS and HTML hence why we have things like CSS-in-JS and JSX and why there's a lot of talk about it. If you're going to write an article on your experience on trying to hire front end developers and why you only got people that appeared to only be knowledgeable in Javascript, at least don't skew the fact that it's because it definitely seemed like you were really only interested in the Javascript side of things to begin with. Heck he even mentions "The title of the exercise is: Front end coding exercise" which it wasn't; it was "Javascript coding exercise".
Depending on the framework used there, the font rendering will be handled by the OS. For example, a lot of fonts don't look all that great on Windows when compared to Linux / OSX.
&gt; What is really the preferred method, or is it just semantics and developers expressing their preferences as universal truths? Arrow functions.
I've done stuff like this. For this little amount of code, you always get better results doing most of it by hand. There are a lot of hacks the minifier won't know it's allowed to make.
&gt; setTimeout( obj.cool, 100 ); // not awesome You are tearing off the method there. Easiest fix: setTimeout(() =&gt; obj.cool(), 100); obj.cool.bind(obj) would also work, but arrow functions are easier to write and it's slightly more obvious what's happening there.
I did. Did I miss the numbers after compression somehow?
 Performance. I've run some micro-benchmarks - it's not awesome... It's not meaningfully slower in real world applications Could be costly if you're paying by the cycle/CPU with a decent amount of users. I donno, if I found code in the 'old cb way', I'd just leave it &amp; ensure there are tests. I would not refactor existing promise code either to eek out a bit of performance unless I had enough users. OTOH, has there been tests or examples vs `async` / `await` or generators?
Here are Guillermo Rauch's [announcment tweets](https://twitter.com/rauchg/status/885500036192256001)
agreed, this would be simple to write with a little focus. Far more effort went into this reverse engineering. The guy had a one liner idea, futzed with it a bit, and shipped it. I do like these kind of examples though, but not for "production".
It's a bit late but got any favorite resources on those advanced perf auditing points? 
 var self = this; This usually means you're looking at code that predates arrow-functions. I won't say that you should never do this, but 99.9% of the time, you probably shouldn't. Just use arrow-functions, this is one of the precise use-cases they were designed for. &gt; What is up with this functionality anyway? Is it actually just a strange development choice in JS, or does it serve some greater purpose? There's a lot written on this already, but in short, calling `obj.cool()` calls `cool()` as a method (e.g. `this` is `obj` from within), whereas passing it as a param to `setTimeout()` calls it as a function (`this` is global or undefined). [ELI5: Methods vs Functions?](https://www.reddit.com/r/javascript/comments/4m6n24/eli5_methods_vs_functions/)
Meh, seems like the article was only written to promote their friend's endeavor. There are thousands of beginner friendly learning resources on the web.
Hi /u/MindlessArt, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index). If you're having a code problem, then please post code. We can't read minds.
The first excerpt is from a book, where it says the arrow function is essentially the same as the self = this
So in the book it said the arrow function is basically the same as the var self = this, where binding is actually proper usage of 'this' Is that the case or does it really not matter unless you have a thing for super proper coding?
The intro blog post gives a good description of how it works: https://ryantsao.com/blog/virtual-css-with-styletron Basically it's implemented in such a way that CSS size grows in tandem with the number of unique CSS values, rather than in tandem with the number of styled components, which leads to big savings in size since many CSS values are the same across components for the sake of design consistency in real life.
Bind returns a new function. So, we basically just added a function call (and [some overhead](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind#Polyfill)) to arrive at the same-ish result. Bind does have its uses, though. E.g. when you want to create an alias for a method: let qs = document.querySelector.bind(document); qs('#foo').addEventListener(...); As far as "proper coding" goes, when in doubt, go with whatever is easier to understand.
I understand that (and actually agree with your point)... but in my experience, insulting someone is the least likely route to changing someone's mind.
I would avoid. Looks like suck.
If you set the width of the terminal to 128 and use node-draftlog instead of innerHTML, this should work in Node as well.
Haha ok, I'll mull it over if I get there then. Seems like everything is contradictory lol 
This is an interesting library, but I am having trouble seeing any advantage over using an established redux middleware like redux-observable or redux-saga. redux-observable allows the cancellation of Ajax requests, plus all the advantages of RXJS. Also, if you use redux, you get all the tooling and support from the community.
you can technically run react without webpack if you only target es6 browsers
Shit just discovered [Angular Universal](https://universal.angular.io/) today. I gotta say these Angular guys are serious about building a powerful ecosystem.
I use classes. If you use TS, there is also privacy and fields. If you use classes, you get some tooling. If you use TS, you get even better tooling. If you use some hand-rolled ES3/5 "classes", you won't get any of that. You'll even have to use extra annotations to tell JSDoc wtf those things are supposed to be. There is no interoperability, other devs won't know how it works, it requires more boilerplate code, and it might be slower, too.
In words of another commenter: &gt; I read that it had smallish benefits, but the cost to set it up was small, and it had some side benefits Whether 1% bandwidth saving and other benefits make it worth it will depend on your personal use case. For me sharing my development experience with others is as much giving as it is taking. By writing about the tech decisions I've used in GO2CINEMA and other projects I am sharing with others my view and look for feedback from others who have different perspectives. Just the first comment on the Medium.com article is already sharing something I did not think about.
Well, if you want e.g. TypeScript compatibility, you can still do this and then create a definition file. But yeah, it's more work for the same result.
Author here. Those are fair points, and a tough criticism to retort. I apologize ahead of time for a lengthy response, but I love talking about this stuff. As far as middleware are concerned: we're seeking to provide a batteries included, more ergonomic approach. One with less moving pieces. We hope to provide "The Microcosm Way" of doing something, rather than delegate key decisions to disparate library authors. That's not for everyone. Where Microcosm additionally differs: actions are maintained within a tree. State is derived by dispatching the "active branch" of that tree. As actions move through different phases, the tree "rolls back" and re-applies changes based upon the new action states. This behaves sort of like an interactive rebase. This has let us very quickly implement optimistic updates, undo/redo, and stage/commit behavior in a consistent way that we all understand across several projects. It also grants us really nice introspection when testing. Purely on state management, the forking concept in Microcosm, as far as I am aware, is another distinguishing feature. We can asynchronously load a large subsection of an application and share state management in a downward flow similar to React. This has made meaningful performance improvements on a few of our projects. Tooling is a tough one. We are actively working on developer tools, largely inspired by work in the Redux ecosystem and the Vue.js devtools. This is fun work, particularly because Microcosm knows a lot more about everything going on, we have an easier time building out complicated reporting. Ultimately, we are not Redux. We do not have the sheer volume of usage. That will take time and test our ability to grow a community around Microcosm. We love using it, and we hope to share that love with others. 
Good catch I saw that also with the Vue dev tool
If anyone still follows TJ Holowaychuk, he had been working on something called [`up`](https://github.com/apex/up) which was basically `now` for AWS. I wonder if that's what motivated zeit to add this. Edit: [There is an issue open](https://github.com/apex/up/issues/69) in `up` where TJ discusses his thoughts about the whole situation.
Your link doesn't exactly support your comment. In that chart react looks like it is falling from mid 200s to now low 200s. Albeit Vue looks about steady and maybe slightly rising. 
This is great, but can we all agree that this little chunk of software is in no way a raytracer? I was sort of hoping that the OP would come to this conclusion by the end.
Fair.
`self = this` is a lexical closure. There are still many uses for closure in Javascript, but thankfully arrow functions have left this idiom by the wayside. Arrow functions are nice because they do exactly what you want, with _less_ typing than the original `function` definition 
part of this article is about replacing class names with shorter (and unreadable) class names. if you have enough class names in your page to justify that minification you have too many classes to begin with. 
Honestly, the answers you are looking for are pretty succinctly demonstrated by reading the taglines on React and Angular's websites: React: A JavaScript library for building user interfaces Angular: Superheroic JavaScript MVW Framework React is a UI rendering library, while Angular is a full-on front end application framework. React helps you render dynamic interfaces, while Angular helps you make large, overarching decisions about how your application should be structured and developed. Some people want a full framework that makes these decisions for them, while some people want to use smaller tools that are less opinionated about the overall structure of their applications. Both of these points of view are valid. &gt; Angular CLI support. No need to configure your own webpack. Devs can move from organization to organization and use the same familiar tool for bootstrapping and deploying. This is really about separation of concerns - it's outside the scope of what react does. React is a UI library, not a build tool. Many React developers *want* to make their own decisions about how their application build toolchain should work, or at the very least they would rather delegate that responsibility to a library specifically focused on that, while letting React do what it does best. &gt; In React you have to keep handing them down from parent component to child component via props. If React has a way to have dependency injection service layer would really like to know. Tools like Redux and Apollo use React's context to do this. Look at their documentation for examples. However, I think it's critical to understand the difference between dependency injection and an IOC container. Here's how wikipedia defines dependency injection: &gt; dependency injection is a technique whereby one object supplies the dependencies of another object. A dependency is an object that can be used (a service). An injection is the passing of a dependency to a dependent object (a client) that would use it. The service is made part of the client's state.[1] Passing the service to the client, rather than allowing a client to build or find the service, is the fundamental requirement of the pattern. Dependency injection does not need a framework - if you pass in dependencies into class constructors by hand (or into components via props) you are still doing dependency injection, just manually. I feel like the whole point of a proper DI framework is that other than annotations/decorators, you should not have to write your classes in any special way. Your class should just expect dependencies as constructor arguments, and then you should be able to swap in/out any DI framework that does constructor injection. Or just not use a DI container at all and build your aggregate root objects by hand. Again, this is sort of a separation of concerns thing. React is not a DI framework, it is a UI library. React's opinion is that UI components shouldn't really have any idea what happens when events occur. A form component shouldn't directly call any service when the form is submitted; it should instead just tell it's parent *that* the form was submitted and let the parent decide what to do. This helps you write loosely coupled, highly reusable components. Then, if you want to inject services into logic-holding container components, there are ways to do that but it is not the central responsibility of React as a UI library. &gt; Sorry but not having routing as part of the core library is a huge red flag (I am talking about SPA frameworks). Again, separation of concerns. Some applications want to handle routing without pushing/replacing anything to history. Some want to use hash-based history. These things are not really the responsibility of a UI library - two applications could feasibly have nearly identical user interfaces but very different routing strategies. &gt; Typescript out of the box Not everyone wants to use TypeScript, and that's fine. Facebook has their own Flow type checker, and many in the React community use that. I personally use TypeScript exclusively but I don't really want my UI library to tell me what system for static type checking I should use. &gt; I sometimes wonder if a third party framework on top of React could be developed that was more concentrated on doing SPA and could address the above shortcomings. Would definitely consider React more, I still like a lot of things about it. I think what you will find is that many frameworks that build on top of react still favor small, reusable and loosely coupled libraries which have limited responsibility. For example, Next.js is a minimalistic framework for building server-rendered react applications. It has its own build toolchain with babel/webpack (which you can customize if you want, or leave it alone if it suits your needs), its own router (which you have limited customization over), its own system for CSS modules (which is a separate npm module that you can use with nextjs, ignore entirely in favor of something else, or even use in a non-nextjs project) and that's about it. Essentially, the developers of Next.js focused on a single problem (rendering react SPAs universally) and built just enough code to solve that problem, allowing users to choose other libraries to handle other problems. Anyway, I'm not saying React is better than Angular. I'm just trying to point out that one is a library and the other is a framework, so they are not comparable in the way you want to compare them. React intentionally does not do all the things that Angular does. It tries to be the best UI library it can be and nothing else, so you are free to choose other tools that are the best at what they do.
Not everybody uses StackOverflow.
I knew someone would try to answer this way which is why I put "SPA" in the post's title (and sprinkled in the post's description as well)
React lies. It's a framework as well. You implement a render function and react calls it. You call libraries, frameworks call you
I can't make a fair comparison regarding these two frameworks, as I just started learning Angular for my new job. However I want to address your worries from my experience with React. * CLI: React has an official opinionated CLI [create-react-app](https://github.com/facebookincubator/create-react-app) which takes care of configuring webpack and a bunch of other stuff. Also take a look at their "eject" script. * Service Layer: If you use the official redux bindings for react [here](https://github.com/reactjs/react-redux). You can connect your components to your store and no longer have to worry about passing "unwanted" props down the tree ([MobX Version](https://github.com/mobxjs/mobx-react)). * Features: That is true. This is also a small reason why react is mainly considered a library instead of a fully featured framework. I think this is a non issue since you are adding dependencies left and right in a modern web app (this might be scary for big enterprises). * TS: Nothing is stopping you from using typescript with react. Microsoft provides a starter kit for exactly that kind of scenario [here](https://github.com/Microsoft/TypeScript-React-Starter). 
Okay? Like I said, both tools can be used to develop SPAs. One is a small tool that handles just the view layer of your SPA, while the other is a monolithic tool that makes many more decisions for you. Both approaches are valid... comparing the two tools as if they have identical goals is not. I guess you're suggesting that you can't build SPAs with a collection of small, focused tools with limited responsibility? Not really sure, because you just dismissed my entire post without addressing a single word of what I posted. It doesn't seem like you want a discussion, but rather some people to affirm your conclusion that Angular is the best framework for building single page applications. Go ahead and use the tools you want to use. I'm sure Angular will suit the needs of your application just fine.
 ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('root') ); Sure looks like I'm the one calling it... If your point is that anything that accepts objects that implement a specific interface with known methods should be called a framework, then almost everything is a framework. Regardless of semantics, React intentionally tries to limit its responsibility to rendering user interfaces. Angular intentionally tries to handle many more layers in your application. It may be fair to call React a view layer framework, but it's not fair to call it an application framework.
After spending some time messing around with heroku and some other deployment services, using Now seriously felt like I was cheating. Being able to buy and alias domains in the terminal is badass. Production is a breeze. Just spin up a deployment, link the deployment to your domain and you’re golden. Being able to deploy React apps with routing and not having to set up my own server rules. 
Node gets new language features quicker than TS implements them, in some cases. That's the only downside I can think of. Trading in newest features for types. It's also a bummer when definitelytyped typedefs get out of date with the head of the package you are using. This happens a lot as they are often not maintained by the same person.
I thought it was ray tracer and was amazed. But it just mimicked the 3d parallax with math trickery, which is still very cool.
I don't have any great tutorial videos or anything, but the [Chrome official documentation](https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/) is fairly complete.
&gt; it encourages you to think about grouping elements as *decedents* https://www.merriam-webster.com/dictionary/decedent
Would you rather learn a brand new set of non standard dom attributes? Or mostly use standard ones with some extra ones to smooth out the experience? Angular makes you learn their API from the ground up (ng-click), where as react is mostly standard dom (onclick) except they add some missing handlers (onchange to input) I would rather expand my dom knowledge than needing to learn something that is going to be useless in 5 years
You "call" angular as well by running the main angular script. It then finds how you configured it. Of course you have to call it to bootstrap, but after that, frameworks keep calling you. I don't know how you organize react projects, but I only ever call ReactDOM.render once at the start of the app. I let my top level components render its children after that. I've written full apps in react without redux. So it worked fine for me as an application framework. Sure it doesn't have a builtin router, but that's the neat part, you can choose your own. What is react missing that prevents it from being your application framework???
RIP in peace
When you write an application with React, you are encouraged to separate out logic that isn't view-layer specific. It may be the framework for my view layer, but if the majority of my application's actual logic knows nothing about React, and the majority of my React code knows nothing about what my application actually does, it's hard to say that React is my application's framework. The point is that I could theoretically drop React and switch out my view layer while keeping my code for: - State management - Service management - Cookie management - Business logic - Form validation - i18n - Build configurations - Routing (only have to change the rendering functions)
This is really the difference maker for you?
I mean I skimmed it. Sorry I'm obviously way busier than you
So you ask something, then people answer (very well actually) and then you don't have time to read the answers? Fair enough.
In high-collaboration code bases, you should just use ES6 syntax: it is standard. Personally, I never create an object with both static and non-static methods, so it's not an issue: from my point of view, the static keyword there is for namespacing utility functions. Instead of using static properties on a class, you can either avoid global state or inject it from a separate module. However, sometimes I want more privacy than ES6 classes promise, such as when I'm writing a library, and I don't care about inheritance. In those cases, I also tend to write in vanilla JS, since dependencies add bulk and usually aren't necessary. In those cases, I'll use a closure to get the functionality of a class while also more closely protecting state, and then rely on implicit duck-typing for polymorphism. That looks like something like: var Foo = function() { // private variables and methods go here return { methodName: function() { [...] }, anotherMethod: function() { [...] } } } (Note: unlike classes these will be hoisted.) You can also consider whether you really need a class, or whether you would be better served by, for example, a function table operating on enumerated types. The advantage of JavaScript is being able to use a tool that solves just the task at hand, but the disadvantage is that there is no singular "right way": it depends on what tradeoffs you want to make. 
He wasn't really answering imo just defending his preconceived views in an (extremely) verbose way
Trolls gonna troll.
I wasn't defending anything lmao. I said like five times "both approaches are valid, just different". Sorry I didn't include an obvious TL; DR. Here you go: React intentionally does not do all the things that Angular does. It tries to be the best UI library it can be and nothing else, so you are free to choose other tools that are the best at what they do.
React at this point has an entire industry built around teaching it to new developers; if success relies on unseating that, we're probably not going to succeed. Luckily, I don't think that Vue has to compete with React to be "successful". It handles cases React can't, like mobile-first applications or commerce-oriented sites where initialization speed translates into money.
The "problem" is that by comparison, learning HTML and CSS is "easy." It's much harder to learn all the ins and outs of js than it is HTML and CSS. You can create a viable product with HTML and CSS without utilizing some of its newer technologies (srcset, keyframes, etc) without seeing any real performance issues. But if you try and create js without utilizing some of its technologies, you're going to get a massive performance hit. Things like .map and .filter are generally going to perform better than using a .forEach every time. But having an &lt;article&gt; instead of a &lt;div&gt; isn't going to effect anything.
ya ya
https://w3techs.com/technologies/comparison/js-angularjs,js-react
What do you do for persistence? Every time I look into Now, they don't seem to offer much in the way of guidance for persistence.
Agreed. Also, I confess to being heavily influenced by Ruby's way of doing classes.
Yep. This is why I am a fan of hyperapp. Its not production ready so I wouldn't recommend it, but it also teaches you the dom even more than react, but makes it nicer to work with. Learn standard not proprietary things.
Sure, if you organized your app such that you ONLY use react as your view layer you have this power. Then its not a framework. But if you put all that stuff inside react components that is no different than putting all that stuff in angular components, so therefore React CAN be your framework in the same way.
careful, though not to do something like this: var obj = { id: "awesome", cool: () =&gt; { console.log( this.id ); } }; where the this in the arrow function will *not* be bound to `obj`, but rather the lexical scope it is defined.
I can put that code into my components, but that is not the same as React handling those things for me. For example, React does not have an official mechanism for form validation. I may put validation logic in a form component, but it's up to me to write that logic and define when it happens. The fact that it's located in my component code doesn't really mean I'm using react to handle my form validation, it just means I'm tightly coupling my view logic with my business logic, and I'm using React in a way that is not exactly encouraged or considered best practice by its creators. I could put all of that logic into a jQuery plugin, but would you call jQuery an application framework? Let me put it this way. I could write a game using WebGL for rendering. I can write it in such a way that my game's logic is tightly coupled to my WebGL rendering code, such that the same functions which handing the logic of my game entities also handle binding buffers to the WebGL context. But WebGL isn't actually handling the logic of my game - I'm writing all that by hand and the fact that it's colocated with my rendering code is coincidental. WebGL would still just be acting as a rendering library, not a game framework.
I've asked about this before. I get the impression they want you to use compose.io or aws rds or mongolab for now. Ideally you'd have them in the same data center as your webserver. Maybe that's why they did this first?
You create a higher order component/function to do validation, like this: https://github.com/lonelyplanet/react-validate-form Let's just agree to disagree. I believe react can be used as either a library or as a framework, you believe it is never a framework.
Could you provide a code sample? Using context this can get pretty confusing at times.
Sure. Here's the bare minimum that demonstrates what I'm describing: person.js const Person = function ({firstName, lastName}) { this.firstName = firstName; this.lastName = lastName; }; Person.prototype.fullName = function () { return `${this.firstName} ${this.lastName}`; }; module.exports = Person; Azure Function const Person = require('./person'); let person = new Person ({firstName: 'jon', lastName: 'jones'}); person.fullName(); // this.firstName is undefined
Oh no question it's still cool, but it's really just mapping a single (mathematical) function. Maube I'm just easily discouraged, but if I was a newbie and heard that there are wizards out there implementing fucking *raytracers* in 128 bytes I'd think about packing it up. Learning that those magic 128 bytes really just generate a pretty graph animation based on a single hardcoded math statement would turn what was being sold as brilliant magic into an achievable goal for a burgeoning programmer.
Yeah, when I reached out and asked them I got a non-answer along the lines of "you can use whatever you want for persistence"
I would try not using const Person = function .... Thats a mixed implementation/specification. I'd use a named function (thats the ES5 specification) function Person() or use the E6 Classes class Person{
Ok this guy is cleverly crazy
I missed up entirely! Was this on /r/javascript? if not, where do you get your news from? I want to sub to whatever you're subbed to :D
I'm not trying to argue or anything so don't misunderstand I just want anyone else reading this who hasnt used either to be informed. The angular cli has an eject command for the Web pack config as well. And while I highly recommend using the cli especially in the beginning it's possible to create a custom build chain with angular the same as react.
 "aaaabcddd".replace(/([a-z])\1+/gi, m=&gt;m[0])
I would concede that there are trade-offs and you make a very valid point. It is possible to tone down some of the compile time checking to allow types that the compiler doesn't know about. (The newer feature will still be available at runtime) Whilst you get less benefit from features such as refactorings you can still use it to get great assistance with how to use libraries that you are less familiar with. The type system (2.3 +) is now really powerful as well so it's possible to use much more of JavaScripts more flexible features whilst retaining the strong typing in your own code. I do admit it can be frustrating to deal with at times but over the last couple of years (mainly on the front end I'll admit) it's really saved my team at times.
My thoughts exactly.
What do you mean by persistence? Most of my uses have been relatively simple but I imagine you could manage persistent state with something like fire base.
Damn, I feel dumb.
I am glad that people are still working on things like this. While it's common knowledge that "Redux has won", things are hardly perfect. While Redux is light-years ahead of what came before, asynchronous work is still a sore spot. Approaches like begin/end/error action triplets plus various middlewares like `redux-thunk` or `redux-saga` certainly *work*, but they feel more like bolted-on hacks rather than polished tools with long-term staying power. I'm not sure if Redux alternatives like MobX and now Microcosm have all the answers, but I'm glad to see that the search continues. Good luck! We can always use better tools from the future.
How would you use self = this in his example?
Why do these discussions always turn into React (as a view layer) vs Angular, rather than React (and some of the more common supporting libraries in the react ecosystem, that are used when building a complex SPA) vs Angular? I dont find the first comparison helpful whereas the latter is more interesting. All you get otherwise, is "React is just a view layer and Angular is everything out of the box, you cant compare them", which we've all heard before...
Thanks for the lengthy response and great information. That's very interesting. I am interested to look into forking and rollback features. I will investigate the docs more. Another thing I saw that was interesting is the stringified function as the action name. I get that it's convenient, but were you worried about memory (for long strings)? I guess it would be highly unlikely for a clash. 
Just saw this one for the first time: https://github.com/michaelmitchell/babel-plugin-pipe-composition I like that :)
&gt;rather the lexical scope it is defined. What does this mean? I can't seem to understand what people mean by lexical scope or even just the word lexical.
jwt is really nice way for API authentication, but if it's your first time it can be frustrated to work with. Hopefully this example here will save you some time in your development process.
It looks like the problem here might be the ({firstName, lastName}) syntax. Person expects one argument, from which it will pull firstName and lastName properties. Check out https://jsfiddle.net/c7x4g5uv/3/ for an alternative working implementation and a demonstration of what to pass to Person to get the result you want.
What is a lexical closure? I can't seem to understand what people mean by the word lexical.
Some criticism: Why do you make a distinction between react / JS and object oriented programming? JavaScript IS object oriented, just not class-based (til ES6). I think a strong hint towards MVC or MVVM could help the first couple paragraphs. At least the comparison of react/redux to MVC / MVVM helped me a lot (I come from ASP.NET). The last bullet point in "Why is this desirable?" drops a lot of stuff at once. If I didn't know redux already, it would leave me more confused than not reading it. &gt; These are all unusual cases. What about the common cases? That whole paragraph is weird. What's your target audience? Because I have 6 months experience with redux, and you lost me in some paragraphs (and I'm not sure if it's your writing or my lack of knowledge). &gt; Some people are into that sort of thing. You lost me completely there (as in, I just skimmed over the rest of the post). From this point on, you're just rambling. I think you like the idea of redux, without understanding why. At least I don't understand your explanations. I suggest stepping back and think about a design that actually solves your problems, instead of thinking about how redux might be patched to solve them.
Exactly which is why I made the post, that is *way more* interesting. 
tl;dr: Redux is hard to learn, and folks easily fall prey to anti-patterns. The sprawling ecosystem of helpers and middleware isn't helping, and since Redux requires these things to be practical, it would be good for the Redux maintainers to just pick a solution and make it official.
A constant is a type of variable thats' initial pointer can't be changed. &gt;"Sokoban using only constants and no loops" *
As someone very used to using Vuex with Vue.js this is really nice, and feels quite familiar. Great work! Will share with my team tomorrow. 
So on that note: I'm not the author, but I am a Redux maintainer, and I'm very interested in discussion and ideas along that line. A few months back I opened up [a Redux issue for discussing possible improvements and abstractions on top of Redux](https://github.com/reactjs/redux/issues/2295) (which Justin did link at the end of his article). There was some useful discussion, but the thread kind of died down. So, on that note: what sort of things would _you_ (and anyone else) want to see as "official" pieces on top of Redux? For example, when you say "pick a solution"... solution to _what_, exactly? 
Eh?
Ugh. Good catch. (I should be passing in an object literal.) Even so, this is not the issue. I've corrected my example.
after learning redux..I feel it is really simple and easy..but getting to this point is really hard and confusing..specially all that boilerplate code..now I have 2 util class one called storeFactory and one called actionFactory and it handles like 80% of all the reducer/action generation in our app..really save a lot of time :)
This is side-stepping the problem, but you could always just `slice()` whatever number of iterations you want off the array, e.g. `nodes.slice(0, 10).forEach()` for 10 tabs. Would be better than iterating over a lot of stuff that's not being invoked.
Can you show an example of the data in `nodes` as well as what order the output is in when it shows copies of the links?
I'm not the author of the post, but let me try to clarify his points from that section: &gt; An action could be interpreted as a complex state transition, but most of them set a single value. Redux apps tend to end up with a bunch of actions that set a single value; there’s a distinct reminder of manually writing setter functions in Java. &gt; A fragment of state could be used all over your app, but most state maps 1:1 with a single part of the UI. Putting that state in Redux instead of component state just adds indirection without abstraction. An "action" could describe anything that's happening in the application, and reducers _could_ do any updates they want in response. For example, maybe a `"USER_LOGGED_OUT"` action _could_ be handled by, say, having one slice reducer clear out data from the server, another slice reducer clearing out some value for "current selection", and a third slice reducer returning `userLoggedIn : false`. In practice, a lot of the time people only have a single reducer respond to an action, and sometimes only updating a single value within that reducer, so it's kind of like writing a Java `setUserLoggedIn(boolean isUserLoggedIn)` function. &gt; A reducer function could do all sorts of metaprogramming weirdness, but in most cases it’s just single-dispatch on the action’s type field. This is fine in languages like Elm and Erlang, where pattern matching is terse and highly expressive, but rather clunky in JavaScript with switch statements. Because reducers are _just_ functions, you can have _any_ logic in there you want. In practice, what you usually see is: switch(action.type): case "USER_LOGGED_OUT": // etc So, people _could_ have cases where there's very complex logic in their reducers, but most of the time there isn't. For what it's worth, I think the author raises some very valid ideas and concerns. Those concerns don't mean that Redux is _wrong_ or shouldn't be used, but it does suggest that maybe what some people need is another, "friendlier" level of abstraction built on top of Redux.
I love you. It works exactly as needed but would you mind explaining this a little? Regarding the "+" after the "\1"; doesn't that match the preceding item ([a-z]) 1 or more times? So wouldn't that technically match every letter regardless of if they repeat? Obviously not, but I am confused as to why this works. Also, the m=&gt;m[0] thing. The m is obviously referring the match and can be any letter (tried replacing "m" with "i" and it works) so I get that and the index of [0] but why the arrow function? 
We run a "tagging" process that assigns each action a unique string token. This token is based on the function name, or a default value when no name is available (like IE10, anonymous functions, etc). So an action's toString value might look something like: `getWidgets.13`
Thanks! Vue.js is a huge inspiration for us. That's wonderful to hear.
We can always do things better. Ultimately, trying to win on technical achievement can only take us so far. To have long term staying power, Microcosm needs to allow developers to build better products. That guides our decisions anyway: is what we're doing solving a problem or saving time on a client project?
In the updated example, does person.firstName return jon?
Honestly I really don't care that much what it's called. I feel like the Facebook ecosystem of React / Redux / Relay / Jest / Flow / create-react-app could definitely be collectively called an application framework. Whatever it's called, what I love about this ecosystem is that I can pick and choose the individual components I want. If I don't like React, I can use Inferno, Preact, Vue, or whatever else I want. Similarly, I could switch out Redux for mobx, Relay for Apollo, Jest for Mocha, Flow for TypeScript, create-react-app for Next.js. I just don't feel this autonomy of choice when using Angular, which is ultimately why I consider React to be less like a framework and more like a library than Angular. If the day comes when I need to refactor an application to use a different view layer from React, I will be switching out one layer, not a whole stack.
that's one reason why I use flow instead of TS to check my types. Babel with babel-preset-env is my panacea 
Which is unclear? Sorry been at JS a long time. This is all second nature to me
It seems to be kind of like Meteor, but with a Java backend. Run away.
I'm a noob in programming, I just copied and pasted this and tried to run it, therefor I really have no idea how to use what you just typed. Can you perhaps simplify it for a script kiddie such as myself??? 
I'm didn't write the linked article; I just felt like it needed a short summary. It sounds like the original author is worried about the standard anti-patterns (lots of small setX actions + close coupling between the state and component tree). He feels that a higher-level abstraction like Jumpstate might be the missing piece to the puzzle. In my own experience, the big "missing piece" is a good async story. Any practical application will have to choose between `redux-thunk`, `redux-saga`, or a bunch of others to deal with this. After looking at the Jumpstate library myself, I see that it creates a "batteries included" experience around Redux. You get features similar to `redux-thunk`, `redux-observable`, and `flux-standard-action`, all rolled into one little library. It's pretty neat! Unfortunately, it comes with a strong "one store per app" assumption that makes it unsuitable for many applications (including ours).
From my understanding (and I'm shit at regex tbh) the + repeats the same match again. So the ([a-z])\1 will match a single repetition, so let's say it finds 'aa', the + basically says "you found aa, find me all the repeating aa's" rather then it saying "you found aa, find me all that match ([a-z])". as I said, I'm shit at regex so that might not be correct. as for the arrow function, you could write it as function(m) { return m[0] } but the arrow function is just a little neater in this case
Do you mean the data xml file? The stuff in the xml file looks something like this: &lt;opml version="1.1"&gt; &lt;body&gt; &lt;outline text="Real Engineering" title="Real Engineering" type="rss" xmlUrl="https://www.youtube.com/feeds/videos.xml?channel_id=UCR1IuLEqb6UEA_zQ81kwXfg" /&gt; &lt;outline text="Wendover Productions" title="Wendover Productions" type="rss" xmlUrl="https://www.youtube.com/feeds/videos.xml?channel_id=UC9RM-iSvTu1uPJb8X5yp3EQ" /&gt; &lt;/body&gt; &lt;/opml&gt; when using "if (index === 1)" it displays the first link in the xml file on the console when using "for (index = 1; index &lt;=10; index++)" This is what the terminal shows: 1 'https://www.youtube.com/channel/UCLS-p8Q5Vs_PtHpSyCODBzA' 2 'https://www.youtube.com/channel/UCLS-p8Q5Vs_PtHpSyCODBzA' 3 'https://www.youtube.com/channel/UCLS-p8Q5Vs_PtHpSyCODBzA' 4 'https://www.youtube.com/channel/UCLS-p8Q5Vs_PtHpSyCODBzA' 5 'https://www.youtube.com/channel/UCLS-p8Q5Vs_PtHpSyCODBzA' 6 'https://www.youtube.com/channel/UCLS-p8Q5Vs_PtHpSyCODBzA' 7 'https://www.youtube.com/channel/UCLS-p8Q5Vs_PtHpSyCODBzA' 8 'https://www.youtube.com/channel/UCLS-p8Q5Vs_PtHpSyCODBzA' 9 'https://www.youtube.com/channel/UCLS-p8Q5Vs_PtHpSyCODBzA' 10 'https://www.youtube.com/channel/UCLS-p8Q5Vs_PtHpSyCODBzA' Just 10 iterations of each of all the links and when it executes, my computer freezes and I have to reboot. Btw I'm a noob so I have very little understanding of any of this.
Really, your team is building multi-store Redux apps? Very curious, why? What sort of use cases are you dealing with?
I just follow a lot of JS devs on Twitter haha, it's one of the best ways to get news. I don't think `up` was mentioned here, I'm pretty sure I first heard of it when TJ wrote a short tweet introducing it.
Ditto. I guess what I meant to say is that I don't really agree with your recommendation, but thanks for offering it.
In Azure, I receive a reference error. I don't have Azure running before me right now, but the error is something to the effect of "Cannot access property `firstName` of `undefined`," basically meaning that the Azure Function is not preserving the reference to `this`.
No, I mean `console.log(nodes)` before you iterate through it. Or even `console.log(result)` Try running it using the small version of the XML you just posted.
As far as I understand: by hand. [General Tips &amp; Wild Tricks from the author](http://www.p01.org/jsconf_asia_2015/) (who unsurprisingly has demoscene roots).
 console.log(nodes) shows: [ { '$': { text: 'The Mr. Following', title: 'The Mr. Following', type: 'rss', xmlUrl: 'https://www.youtube.com/feeds/videos.xml?channel_id=UCLS-p8Q5Vs_ PtHpSyCODBzA' } }, { '$': { text: 'Real Engineering', title: 'Real Engineering', type: 'rss', xmlUrl: 'https://www.youtube.com/feeds/videos.xml?channel_id=UCR1IuLEqb6U EA_zQ81kwXfg' } }, { '$': { text: 'Name Explain', title: 'Name Explain', type: 'rss', xmlUrl: 'https://www.youtube.com/feeds/videos.xml?channel_id=UCy_QZ1EEY4S 5YT6cmBTwMwg' } }, { '$': { text: 'Soliloquy', title: 'Soliloquy', type: 'rss', xmlUrl: 'https://www.youtube.com/feeds/videos.xml?channel_id=UCOU-cHVIJhJ 9JAeg2ZIIrRg' } }, { '$': { text: 'Veritasium', title: 'Veritasium', type: 'rss', xmlUrl: 'https://www.youtube.com/feeds/videos.xml?channel_id=UCHnyfMqiRRG 1u-2MsSQLbXA' } }, ] console.log(result) shows: { opml: { '$': { version: '1.1' }, body: [ [Object] ] } } Edit: Ran the script with just one URL in file, opens Chrome with 10 different tabs of the same URL. 
Better helpers: const pipe = (...args) =&gt; args.reduce((prev, curr) =&gt; curr(prev)); const compose = (...args) =&gt; pipe(...args.reverse()); // Usage mimicking the pipeline operators: pipe(array , mean , round ); compose(round , mean , array ); Looks similar enough to the version using operators. For extra fanciness you could give the helpers names like ▷ and ◁ or ∘. See also similar post: https://www.reddit.com/r/programming/comments/6mpg69/a_proposal_for_adding_the_simplebutuseful/ Cheers.
The `\1` is a back reference. Back references match only exactly what the original group matched. So let's break it down: First we match a letter via `[a-z]`. Then we group that via the `()`, which "activates" the `\1` back reference. Then we use `\1` to back reference the `([a-z])` group. So if `[a-z]` matched `b`, then `\1` would match `b` (but not `c`, `d`, etc). If `[a-z]`matched `c`, `\1` would match `c`, and so on. The `+` is, as you said, the "one or more" modifier. When the `+` is after a back reference, it basically means "one or more of whatever was matched inside the parentheses". So `([a-z])\1+` matches `aa`, `aaa`, `aaaa` and so on. The `i` modifier is the case-insensitive modifier, and it makes `[a-z]` equivalent to `[a-zA-Z]`. The `g` modifier is the global modifier and it makes the regexp continue matching as many times as it can after each time it finds a suitable match. `String.prototype.replace` has two signatures, one that takes a string as 2nd arg, and one that takes a function. We're using the latter. When the replacement is a function, the signature of the function is `function(match, [group1, [group2, ...])` (actually there are more args after that, but let's ignore them for the sake of simplicity). The function is potentially called multiple times because of the `g` modifier (one time for each match) In the function signature above, `match` is an entire match (in this case, something like `aaaa`). `group1`, `group2` etc refer to each group within the match (the things in parentheses). In our case, we only have one parenthesized group, so we only have `group1` and its value is the first `a` that was matched by `[a-z]` if the match is `aaaa`. `m[0]` is the first character of `aaaa`. `m =&gt; m[0]` is equivalent to `function(match) {return match[0]}` So when this function takes `aaaa`, it returns `a`. When it takes `bbbb`, it returns `b`, and so on. And as I mentioned, the function can be called multiple times. In the context of `.replace`, this means that `aaaa` gets replaced by `a`, `bbb` gets replaced by `b`, etc. So when .replace(...) returns, you get a string with deduped letters.
This is almost correct. If `[a-z]` matches `a`, `\1` matches another `a`. The `+` repeats `\1`, but not `([a-z])`. So each "iteration" of `+` adds a single `a` to the match rather than two. This is why an odd number of repetitions also works. Other than that, everything else you said is correct.
You can think of lexical as 'location.' The lexical scope of a function is the scope of where it's defined. In the example given, the lexical scope would be the window object, so a call to `object.cool()` would log the value from `window.id`
I'm guessing the code you posted is wrapped in a loop, or you are called the code from inside a loop. Based on the value of `nodes` there shouldn't be any channels repeating in that forEach function you posted. I think you'll need to post more code to go any further in debugging this.
There is no more code lol. The first script I put up was the whole thing that's why I don't understand why this is so complicated. Maybe the link to the video of how it was made can help: https://www.youtube.com/watch?v=GVakGPDF3Kc Warning: audio becomes horrible after 9:23 
&gt; The lexical scope of a function is the scope of where it's defined. In the example given, the lexical scope would be the window object I just can't see that. It's defined IN the object. You're literally having to run it by first typing the object name where it's defined obj.cool(). 
How are you including app.js in your web page?
look at this code: var a = [] [1,2,3].forEach((x) =&gt; {a.push(x)}) why can you access the `a` in the loop? What happens if `var a` is defined in another file? It works the same way in a function, or anywhere a new scope is set up var a = [] x = (() =&gt; { this.foo = () =&gt; {a.push(1) } this })() x.foo will push into the array because it's lexically accessible. Sorry if this isn't a clear definition, I'm not even 100% I'm using the word correctly. 
I don't understand. In the web page?. Can you rephrase your question?
When programmers are obsessing over base 10 patterns you realise standards are dropping.
&gt;x.foo will push into the array because it's lexically accessible. I have no clue what's going on here. I had just started learning ES5 a few years ago and looked into Javascript again recently. I feel like they said, "how can we make this language virtually indistinguishable." x = (() =&gt; { this.foo = () =&gt; {a.push(1) } this })() I can't parse this at all. You have "this" on a line all by itself. I'm trying to pick up ES6 and relate it to what little I had learned before and I know here lexical doesn't really matter either way but the ES6 here just makes it even more confusing for me. 
When I think back to -18489600. Summer...
Spring
How are you running that code? Are you just running it by itself in Node?
IMO the arrow function is a little harder to read than clearing stating `var self = this;` ... for a beginner it might be helpful to keep the code as clear as possible. 
Oh! yeah I was just using Node. Should I be using something else also?
I was struggling to find so far good documentation in order to use GraphQL with relational databases. Thank you very much, all links seem to be really useful, specially the last one.
yeah, [and this is being fixed in the next version of firefox](https://bugzilla.mozilla.org/show_bug.cgi?id=1158076) (scheduled for august)
There's nothing in "a" when I run this.
No, that's fine. It just seems like this code is being executed ten times and it may have something to do with your environment.
How is flow diff int this regard? it uses definition files as well. Or are you referring to another aspect?
Well idk what it is, so im lost...looks like I might have to manually subscribe to them all. Have you tried running it?
With es8 you wont have to put comma in the front because they will support trailing commas in function arguments
OK, I was in the same boat as you a while ago. Then I consulted for about a year and landed two offers a month in to job search. This is more about the bare basics of what you need to be productive and land a job. I learned: - JS basics - Scope, Closures, Prototypal Inheritance, this A must know, also interviews always ask about this stuff the most! - ES6/ES8 - Tooling Babel, bundlers like Webpack and Browserify, npm - Basic DOM API, selectors, etc. - jQuery Supposedly it's on its way out, but there are a buttload of companies still using it. Plus it's good to know, esp for smaller projects. - At least one FE framework I learned React/Redux, just because I screwed around with Angular for a bit and hated it, but thought React was really cool. It looks like a lot of companies are using Angular 1.x too. I guess just use whichever one you like the most, and remember you can still get jobs using frameworks you've never used before. If you don't go with React, at least download create-react-app and make a basic todo list or something so you can talk about it during interview. If you do go with React, at the very least learn about MVC and two-way data binding, either with a framework or vanilla JS. - Basic data structures/algorithms Good to know, but you'll probably only be quizzed on the bare basics during interviews. Just know about basic time/space complexity, linear time, constant time, hashing, stacks/queues, traversing tree-like structures, you'll probably be fine. - Utility libraries Know about Underscore, lodash, Ramda, or something like that. ES6 introduced some handy utility methods, but in most large projects you'll end up using one of those three. I started with Underscore, switched to lodash, and later switched to Ramda because it's cool for learning FP. - Basic HTTP, Websockets, AJAX - Different programming paradigms Just learn the basics of OO and FP, how to use them with JS. Learn about different ways of creating "classes" in JS, inheritance, and the bare basics of FP- map/filter/reduce, pure functions, immutability, function composition. - Node.js Just learn about REST, some relational or non-relational DB, templating. Also know what all of these terms mean and how they apply to Node: single-threaded event loop, task queue, thread pool. Also know that node is better for low latency apps...you'll be grilled on all of this stuff. - Asynchronous design patterns Callbacks, promises, advantages of promises, web workers. - HTML5/CSS Probably my weakest point- I got a lot of CSS questions wrong, but they didn't seem to care as long as JS skills were sharp. Also, transpile-to-CSS languages like SASS or LESS are asked about all the time. I was able to get by knowing very little CSS, because I use frameworks like materialize or bootstrap instead and just customize them a bit. At some point you'll want to ditch the frameworks and become a pro at CSS.
Would you mind sharing what storefactory and actionfactory are?
Not the whole thing, but everything looks like it should work: https://jsfiddle.net/0gjon8c2/
sorry i totally see where you're coming from. This is a object builder pattern you might not be familiar with. Here's the building blocks: 1. `() =&gt; {}` this is an arrow function. you can use it instead of `function(){}` 2. `(()=&gt;{})()` is an IIFE, look that up if you're not familiar. Another way to write that could be simply `x = { foo: function() { a.push(1) }` I'm just going to stop explaining lexical scoping because it seems I'm not very good at it. 
Is there supposed to be something in a when I run this? Thanks for the time and help. Also, why is "this" on a line by itself?
There is supposed to be something in a, if you call x.foo() ... Anyway 'this' is returned to set the return value of the IIFE to the object which had the method foo defined on it
Also just realized that my JS isnt formatted correctly for mobile, which makes my habit of avoiding semicolons apparent
It looks like this isn't getting returned. Does that only work with one liners maybe? Also, foo is getting set on the global window object and if you type return this x will be the global object it looks like. Not sure...but thanks with the help. 
It's already supported in the newer versions of node, too.
Still doesn't work for me. I'm just unlucky XD. Thanks for the help anyways. 
I am am typing on my phone, cant double check my code and apologies for the shitty snippets,but regardless, look up closure or lexical scope in JS and you'll get the gist. 
Thank you.
I think this is where I'm supposed to say "username checks out". Did I do that right?
they are just handy functions which will create a standard reducer and register automatically some common actions..so if I call createApiReducer('MySuperReducerName') it will create and register a new reducer with a standard format { isFetching: false, error: false, errorResponse: {}, loaded: false, response: {} } also actions to trigger update of this store are registered..same goes for the actionsFactory..you call createApiActions and actions to update the state are created and are available in your components..so you can just call apiStart() and it will set the isFetching to true. Because what we have is like 30+ modules which pretty much follow a common pattern. The hit the API download some data, display the data, run some common actions. So we tried to standardise this and reduce boilerplate. What we actually came up with reduced like 70% of the code and actually made the application really testable, maintainable and easier to reason about. Now if we are to create a new module, we just have a duck where we use our factories to set up a new reducer, actions etc. and we use a few HOCs for our components/containers to connect all the stuff and thats it, no reducer, actions, constants files and the duck has just a few lines of code. 
I like the idea, but the fetchReady part is a bit ugly especially when used together with such small snippets. Probably in this scenario its best to write a custom document ready function which will be called when all polyfills are checked &amp; document loaded.
Hey there, can you elaborate on cases you've run into where Node has features before TypeScript does? Generators are the only case I'm aware of which we've since fixed, and we typically look into implementating ECMAScript proposals when they hit stage 3 which is earlier than most runtimes. When it comes to type definitions, we've been looking for ways to improve the process of contributing so that it will be easier for the community to quickly patch things up.
Or just use lodash flow, ramda, rambda or this work in progress snippet https://codepen.io/katywings/pen/QgJQpX Wondering how often esnext pipe will be used without other functional patterns.
The claim that JWT allow you to be stateless is really not correct. As soon as you want to have the ability to invalidate tokens, you need state (the blacklist of revoked tokens). The worst case is, an administrator of your site has gone rogue and you want to revoke admin permissions. You don't want those permissions revoked when their token expires, you want then revoked now, so you need the blacklist and we are back to the stateful backend. A bettwr way to handle this, is to have the session ID in the cookie (let's be real, any decent http library can handle cookies) and have the session data in memory. If you want to scale horizontally, put the session data in an inmemory database like redis and scale your app server as you like. 
&gt; What do you do for persistence? I've been using DynamoDB. It seems pretty good and has a nice free tier. https://aws.amazon.com/dynamodb/ https://aws.amazon.com/free/ 
&gt; I was just using Node. How exactly are you calling it? Please be as detailed as possible. Something simply isn't adding up here because the code you posted is fine.
We don't have any actions that are handled by multiple reducers, because having a lot of these drastically reduces (pun not intended) readability. Some coworkers still have issues navigating our redux code, we don't want to make it worse. That's my main gripe with redux, btw. It's hard to navigate the code. If I could redesign redux or had the time to built something on top, I'd try to combine action creators and reducers. You'd need to write your action creator pure and have it always return the full state object, but you then have one point in the source code that deals with the state object in question. But I just woke up, so maybe I should rethink this idea after a cup of coffee or two. My second complain is the necessity of middleware for async work. (Edit: BTW, I don't dislike redux. It's a good library and saved us a ton of time. But it's not as general purpose as some people claim it is. And I'm not sure it should aim for that either.)
It could also be used with async/await functions Another benefit that I didn't mention in the video, is that it doesn't block the rest of your javascript from running, it only blocks the fetch-dependent part if the polyfill requires to be loaded.
Yes, let's look at every random statistic (w3? lol) that confirms your bias and most likely confuses angular pre 2 with modern angular, but let's not look at the one statistic that is guaranteed to reflect real world usage.
Oh that's new to me. I had no idea React cannot produce mobile-first applications and commerce-oriented sites where speed matters. Tell me about about this this.
Developing for node in ts for about half of a year, didn't experience any problems you mentioned. Using huge variety of libraries. Can you tell please, what features does TS lack when node have them already? Also about libraries - you can go in them and update typings. We are developers and should help each other, not only "eat and run".
interesting, you claim to be a young girl... but you have the name transgenderdinosaurs... this makes me suspicious.
I dunno, Flow does not have type guards, so i switched to TS and never been happier. Also, decorators and reflection with types at runtime &lt;3
No, its a decision.
Well topic "help a young girl out" is not right for this subreddit
Have you tried anything yourself so far?
Yeah, you're the 10x super-pro that doesn't, right? Well even if you truly are (who knows), the truth is that it's the biggest, most reputable and most active software engineering community in the world and unlike **some** rankings which use a very dubious sampling of Google trends, SO uses the sound, and widelly accepted, long standing statistical method from social sciences. But ok, let's not put all our eggs in one basket: http://redmonk.com/sogrady/2017/03/17/language-rankings-1-17/ Redmonk, does use automated data acquiry from the Internet but at the very least they combine results from multiple sources to control for sampling bias. There are also these guys that are US centric and sample for job offers. But US centric trends in technology have generally proven to be accurate if not of the current state of "the worldwide" than at least in it's immediate future: https://jobsquery.it/stats/language/group Note how Node.js + Javascript would place Javascript actually above the current #1 which is SQL. Another interesting thing I constatly tell people is how that chart clearly shows that if you were to optimize for both job security and sallary you should learn the (near) future king of backend technologies -- Python.
like white people on muslim suspiscious or more mums hot friends a swinger suspiscious? either way 
the topic is clearly attractive!
no not yet will tonight my first idea was to make a square grid with transparent difrent colours then use focus mousex,mousey to focus a sort of square thing around mouse to give the effect... a little like mixing these two but with dragged instead of scroll. http://codeforartists.com/samples/cfa-scroll-blur.html https://i2.wp.com/codeforartists.com/wordpress/wp-content/uploads/2015/10/color-boxes.jpg
Can I load Promise Polyfill using this tool?
Well, it *tries to* prevent console access with the use of `debugger` statements. It is sufficient to deactivate breakpoints in the developer tools console and you can look at the request to `https://api.darksky.net/forecast/`:) Out of curiosity, what is this obfuscator you used?
not sure if you mean 10 or 10...
What do you mean? They're both Turing-complete afaik.
&gt; Could be costly if you're paying by the cycle/CPU with a decent amount of users. I donno, if I found code in the 'old cb way', I'd just leave it &amp; ensure there are tests. I would not refactor existing promise code either to eek out a bit of performance unless I had enough users. &gt; I was aiming to 'bridge the FPJS gap' for devs who already understand callback code. In order to illustrate how I've come around to the Functional Path ;), I wanted to start with something familiar (Callbacks, Original Recipe). Then guide readers through each step adapting the code. As for the Performance, in real apps I see perhaps a 5-20% penalty in runtime performance (vs. OOP methods) **on a single host.** One of the biggest wins is how easy scaling out becomes (you can trivially explore different shapes of service deployments or microservices, even late in product lifecycle). So it's not fair to compare performance line-for-line on a single host. It's kinda like comparing the 0-60 speed of a 747 Jumbo Jet vs. a Honda Civic. Despite `async` not lending itself toward FP, it can largely be coerced to meet my 'Functional River' rules/requirements, if a bit awkward. That said, I started an `async` example and am stuck on awkward code. I'm not liking the differences between async/sync functions. In any case, I'm trying to improve my overall `async` ergonomics; been writing on my challenges here: https://github.com/justsml/escape-from-callback-mountain/wiki/What-about-Async,-Await-and-Generators%3F Let me know if I'm off the mark or send me a PR/issue. Thanks again for reading!!! 
~~[relevant comic!](https://i.stack.imgur.com/ldNco.png)~~ EDIT: original source: http://cowbirdsinlove.com/43
1
Unfortunately not, as Promyfill relies on the Promise method. So if you want to support all browsers (IE8, etc..), you have to inline a tiny Promise polyfill. Check out the github repo for more info
does this cover part of your goal? [checking if element is visible after scrolling](https://stackoverflow.com/questions/487073/check-if-element-is-visible-after-scrolling)
30
sort of it solves a difrent problem i had aswell.so this https://github.com/morr/jquery.appear looks good. i like the possibilities. i just need to create some sort of effect on border that give pixel and relate it to appear. it will try ..
Ahhh haha guess it didn't work, but good enough I guess? In most other people's pens I could easily see their API keys. I used this one: https://javascriptobfuscator.herokuapp.com/
I've had a look at your code and I totally appreciate you're new to webDev however I felt to really explain how to fix your code example I'd have to touch on a lot of language fundamentals. Instead I've put something together that is approximately what you want but hopefully you can read, understand and add the extra functionality you need. https://codesandbox.io/s/6RE7rW9on Feel free to ask any questions :)
Thanks for your reply. I'm trying to do something different though. I'm trying to render(?) a react component, i.e FaLinkedinSquare using profile.network. FaLinkedinSquare is the font awesome icon. So instead of writing `&lt;FaLinkedinSquare /&gt;` to render the component/icon, I'm trying to do it more dynamically like `&lt;{networkToIcon[profile.network]} /&gt;`. Hopefully this is more clear. Edited: I figured it out. I goofed and used forEach instead of map.
I would imagine getting this as a job interview task: "Reverse engineer this JS, good luck." Just seeing how far people will actually get would show a lot about their understanding of basic javascript. Then again, it might be torture that doesn't tell you shit about their actual programming skills. Still, fun!
In code that just runs from top to bottom this might not seem special. But JavaScript has Closures. I guess this concept could be difficult to grasp for some people.
That's great
Should have used &lt;/joke&gt; tag :/
Why is it weird? Basically you can break it down to two variants: 1) Ordinary functions. function myFun () { ... } They work similar in other languages. You can use them above and below the declaration. 2) Assign functions to variables. ... = function () { ... } I barely use this variant. Only if I need to assign a function to a property of an object that already exists. But this doesn't happen very often. Since the first variant doesn't work for cases like this this second one is needed. It's similar to `obj.prop` vs. `obj['prop']`. First is the nice and short one, second is a more flexible one if you need it.
Are there startup concerns around this, as in when does the tagging happen, and what if I try and register something to the action before that?
should we start jumping up ?
eheh, it's not that it didn't work, it's that is easy to circumvent. Good enough for people with only a basic understanding of Javascript, though. (It's an useful choice if you suspect malicious manipulation of users into pasting code in their console, for example).
&gt; actions are maintained within a tree I find this interesting so let me ask a few questions :). What about cases where your change graph isn't tree-like? Say I submit change A to the server, then B, then A fails, then B succeeds. If I "rollback" to the state prior to A, I lose B's change. Do I have that right? More generally, how does your tree-based system compare to approaches like Operational Transformation?
How do you secure your database? Do you do some kind of ssh tunneling or do you have the Dynamo instance exposed to the world? Is that ok?
Yea I see what you are saying. Generally it doesn't seem like it'd fix the problem. But I'd try it just to see if it works on Azure. Microsoft has always had weird opinions in their js implementations 
So does &lt;{networkToIcon[profile.network]} /&gt; render ok? My advice would be to create a functional networkIcon component and have that render the correct icon based on a property. Edit: Implemented how I'd do it: https://codesandbox.io/s/WX4YlR0E 
Test your code with something you know actually works. A search on Twitter's app for 🌹 yields no users. (I'm curious why an emoji would be your test string.) Also, run/write some basic tests to ensure you are properly authenticated. For example, can you get your own profile or access the firehose?
No startup concerns that I've identified. tagging happens when an action is first created, and only once per function. So like: ``` repo.push(getUsers) // tagging happens here ``` Additionally, the `register` method is only called as needed. When a Microcosm encounters an action it does not have a registration for, it reinvokes the `register` method on domains and effects. This is fast. At any rate, profiling tells us that we have no trouble invoking this on scroll or other high frequency updates on mobile phones in animation loops.
History would roll back to "A", reprocessing it as a failed action. This would undo your optimistic update. From there, it moves to the next action inline: "B". The change for B is never lost, only reapplied. I've made an example of this here: https://runkit.com/nhunzaker/5968b96a8cd6d20012fa881d Operational transform is fascinating! I've been really curious about what it might look like for stores/domains/reducers to produce "change sets" instead of operating on data directly. There are a number of optimizations you can make there (why update a record when you know 10 steps down it's just going to be removed), and reporting on changes gets really good (think Google's versions page for google docs). It is also an active area of experimental research. Research that I haven't followed very closely. When working on history, I looked at operational transformation, but found inspiration in my approach via Datomic (http://www.datomic.com/), a fact based database. Datomic has a few different ways it can reconcile changes. We only have the "rollback and move forward" approach. I'd be curious about what it would look like to make this process configurable, but I haven't had a need for it. 
Nice. Do you have one for ff as well?
I'll do some testing later today and report back. The reason I want to do an emoji is because I want to sort people into lists based on political affiliations. The 🌹is associated with Democratic Socialists. 
Yeah something like that worked, not at my pc right now so not sure exactly what it was. Thanks for the advice. Doing it like that is probably better since its actually a reusable component that way? Thanks sir.
No demo? :/
What's with the trend with using `“”` for strings? It's so annoying.
Hi there, **p01**, author of the 128 bytes plane raytracer. If you liked this tiny raytracer, you should check my other tiny Audio Visual demos in 64-1024 bytes at **http://www.p01.org** &amp;nbsp; Shout if you have any question. &amp;nbsp; The reverse engineering was cool. &amp;nbsp; The meat of the raytracer lies in the `i%2*j-j` and `j=k/i`which gives the X and Y coordinates of the intersection of the camera ray with the plane. Adding `+n/k`to the X coordinate moves the camera horizontally. The binary exclusive OR between the X and Y coordinates gives the checkboard texture. &amp;nbsp; The cruft of the render loop is `P='p.\\n';for(i=64;i-=1/64;P+=characterAtTheScreenXScreenYposition);`. The rendering area is 128x32 because the ScreenX and ScreenY positions are `i%2` and `i/2`where `i` increases by `1/64`each time. This increment is an exact fraction of a power of two, which means that there are no floating errors and we can safely do `i%2` to get a truthy ( non-zero ) value if `i` is not an exact multiple of 2, and a falsy ( zero-ish ) value if `i`is an exact multiple of 2 which is used to insert a `\n` to go to the next line. &amp;nbsp; Hope this helps,
I wrote www.p01.org/128b_raytraced_checkboard/ by hand. For such small pieces, brain always beat the machine. 
Oh it **is** a raytracer: It traces one ray per "pixel" and computes the intersection with a plane, and produce the checkboard texture using a simple XOR of x and y coordinates of the intersection point. &amp;nbsp; It's only 128 bytes and I made it just for fun back in 2012, because I hadn't done a 128 bytes prod in a while. So obviously it is very specialized raytracer that traces a one primitive with a fixed texture and camera path, but it does trace rays. https://www.reddit.com/r/javascript/comments/6n0xlg/reverse_engineering_one_line_of_javascript/dk7kun7/
Really breakdown indeed. As for the "compilation".... nope. I wrote www.p01.org/128b_raytraced_checkboard/ by hand.
when you have closures for instance..lets say we have a function A and in that function there is a variable and another function lets name it B..you can access the variable from inside of function B because it is in his scope. If we have a closure and function A will return function B, function B will still have access to the variable because it is in its lexical scope..so simply said every inner function can access its outer surrounding scope
But is is defined as arrow function. This is important. 
[removed]
You're logging this.id. But what is this? Think about it for a while. It's surely not your object, as objects don't create a scope. If it did, it would be a local scope, you might call it an object scope. But we don't have object scopes in JavaScript, we only have functional scopes and extending that, a lexical scope. Lexical just means the scope nearest where you currently are in your program. But we do have function scopes. So why doesn't your cool function return undefined? Well, because you're using an arrow function, which means it does not create another scope. So, in this case you have a scope, but it's the global scope, as we're not inside any function scope. That means that the this-keyword refers to the global scope. And defining variables by saying var id = 'not awesome'; is in this case the same as saying this.id = 'not awesome'.
You could have JWTs with a short expiry, say 1 or 2 minutes, and then longer lived refresh tokens that can be blacklisted which fetch new JWTs. This way you only have to hit the db every couple of minutes rather than on every request. Still not completely stateless, but not bad. The downside is a rogue admin would still have access for a minute or so.
Mind blown...
Because this is a window object
Is this basically Redux with promises? I have only a basic understanding of Redux so I genuinely don't know what else this adds. Is there an example of a more complex app than a counter?
*rubs eyes* guys can we stop with the ES versions for a week 
So in what sense are actions a "tree" in Microcosm? It seems more like a linear timeline (like Datomic's series of transactions), with rollback-and-replay on action state transitions. I may well be missing something though :). (BTW, we had a brief conversation about Microcosm on the streets of Durham ... a couple years ago? It was just after I had presented on my library S.js at triangle-js. Great to see Microcosm is still going strong and going more public.)
There are 10 types of people in the world: those who understand binary and those that don't. 
Because you're using an arrow function. Regular functions become a method on the object they're created on and will correctly point *this* to the object.
It's not a very good one. The bangs are useless. You will get better results using Google.
Using prefix notation for things like "and" and "equals" makes code less readable, for most people. I have a hunch this might be slightly more readable in a lodash or rx.js style for the average person. alternatively, you could add descriptive names for some of your pipes and split the code up - or at the very least put a comment in front of each map/pipe to explain its purpose. The most beautiful functional code reads fairly naturally and inuitively, imo, which is more important than having it all in one continuous expressions. input.map( (a) =&gt; if( isAtomic(a)) extractDescriptions(a) else extractText(a)) ) 
 + 1 this definitely needs a couple more comments. 
Lets see first what scope is: function foo(){ console.log(a); } function bar(){ var a = "a in bar"; foo(); } var a = "global a"; bar(); // global a We have 3 scopes here, one global, in which we defined every thing, scope formed by `foo` function, scope formed by `bar` fucntion. Scopes are formed by functions (and catch in try-catch construct) but that's not relevant here. Lexical scoping is same as looking at your source code and checking *where* your function is *defined*. Here `foo` and `bar` are defined in global scope. So no mater where you *call* function , lexical scoping determines access to variables by looking where and how it is defined. Lexical parser finds that `foo` is declared in global scope, tried to find *a* variable in `foo`, didn't find it and continued to first outer scope (global) and find it there. Now objects in javascript don't form scopes by them selves. var obj = { a: "a from obj" cool: function(){ console.log(a) } } var a = "global a"; obj.cool(); // global a See `obj.cool` is just a another reference to `cool`. Here also, unnamed function we put in `cool` is in global scope, no mater if you find its definition in object. Because remember objects don't form scopes. So we need to use *this* reference if we want to use `a` from the obj. var obj = { a: "a from obj" cool: function(){ console.log(this.a) } } var a = "global a"; obj.cool(); // a from obj Notice when we use *this.a* what it makes is that lexical scoping doesn't apply. It applies something very similar to dynamic scoping in other langs. It determines access to variables by looking where is function *called* , not where it is defined. That is in contrast to lexical scoping. Here it looked where `cool` is called, and applied one of [four rules](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch2.md#nothing-but-rules) of `this` referencing. It saw that `cool` is called in context of `obj`, so any *this* in cool points to `obj`. Answer: Your `cool()` function is the *arrow* function. Arrow functions **don't apply** the usual rules of *this* referencing, they switch to lexical scoping, that's why you see "not awesome" there.
If possible, I prefer to use native language features than libraries. 
We did, we stopped for a year to be precise. ES is on a yearly schedule, this is ES2017, in a year we'll have ES2018. I get that everyone's complaining about "JavaScript fatigue", but seriously, this isn't it. These are just some minor regular updates to the language.
ES8? Aren't we on ES6...
Now I want some Pad Thai for lunch....
I know, my comment is tongue in cheek :) Really loving the new object methods. Hoping to try the rest out soon too.
Oh alright, no worries. Guess I'm a little fatigued by all the comments complaining about JavaScript fatigue.
The league client was previously adobe air and is now chromium based btw
What if the bug involves waiting a certain period of time between certain actions? Is this supported?
Hi /u/vptes1, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
I think it is a little much too. Maybe you could try factoring out some functions into their own functions with descriptive names. and(propEq('type', 'atomic'), pipe( prop('entityRanges'), head() )) pipe( prop('entityRanges'), head(), prop('key'), prop(__, content.entityMap), props(['description', 'title']), join('\n') ), I feel like these would be good candidates. 
That style is somewhat library agnostic, and people familiar with point free will pick it up regardless of what library you use (though there aren't many right now). Obviously, someone who hasn't been exposed to FP will go "WTF" and push back hard. With that said, the current state of JS tooling makes those hard to debug (stack traces get complicated, putting a breakpoint is hard), and I can't help but feel if you're gonna go there, you might as well go all the way and add category in the mix (Either monads and whatsnot) so you can get the same result without having one soup of parenthesis. Your result may vary. To me, these type of full FP style aren't very interesting when they just replace a procedural equivalent. They're more interesting when trying to make the logic reusable. Like if the "else" part of this if/else was a reusable function, it becomes a lot more interesting.
You could type in a manual step (to wait a certain period of time) for the user
I thought these tests were automated.
What is the supposed name?!?!
Meta. (you did that on purpose, right?)
Hey I made that site :D Yup, I'm a huge fan of Vue, have been working with it professionally since 0.10 Have to agree though that there is indeed a long way ahead. The ecosystem tradeoffs are real and should be factored in (npmcharts is a 1-person hobby project that took a total of maybe 25h of dev time so far). Vue also lacks something like react's [recompose](https://github.com/acdlite/recompose), which is probably the one thing I love more than Vue and React. Anyone wanna look into that? ;)
&gt; We don't have any actions that are handled by multiple reducers, because having a lot of these drastically reduces (pun not intended) readability. &gt; That's my main gripe with redux, btw. It's hard to navigate the code. &gt; My second complain is the necessity of middleware for async work. &gt; If I could redesign redux or had the time to built something on top, I'd try to combine action creators and reducers. It's kind of ironic you should make those comments, when they are literally the intended reasons for Redux to exist :( As described in my post [The Tao of Redux, Part 1 - Implementation and Intent](http://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-1/): - multiple slice reducers responding to a single action was an intended usage from the beginning - Redux was built to make it easier to trace state updates through a codebase - "middleware" concept was created specifically as a way to allow users to choose whatever approach they want for handling async logic - actions+reducers exist as part of the Flux heritage and to make it possible to do things like time travel debugging Per my post, Redux is flexible enough that you can use it in a variety of ways even if it's not what was originally "intended", but it's interesting that you would say you dislike so many of the core intentions behind it yet still find it useful overall. Out of curiosity, what specific problems do you have "navigating the code", and why do you dislike "middleware for async work"? 
Just do the world a favor and use vanilla js here, please. The cognitive load of that piece of code is unbearable.
ES6 was the big update. This is the one that most browsers spent time catching up with. Seven onward will be small incremental updates.
... and those who were expecting a base 3 joke, instead.
6th edition of EcmaScript specification became standard in 2015; since then every year there's a new edition (compared to slower pace before 2015), hence [since June 2017, 8th edition is technically a standard](https://www.ecma-international.org/publications/standards/Ecma-262.htm). Implementation of it in *all* browsers is a bit different story though :)
Anyone else a bit perplexed by the padStart and padEnd functions? I feel like it's either something we would have needed back when JS was first introduced or not at all. It's not like it's solving a problem we're only now needing to address. Left and right padding as a programming problem predates nearly everything. Oh man, just remembered the whole [left pad debacle on NPM](https://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/) last spring! I wonder if this was part of why this went through.
This is a really great point. It's also possible to create d.ts files in your own project to polyfill any missing typings. I had an issue with Mongoose.js recently where the "useMongoClient" option when creating a connection as this was not yet included in the typings. There was actually a PR for this on DefinitelyTyped and was able to add my own typing as it had not been made part of the main typings. Since TypeScript 2+ this has been less of an issue in general and it's pretty easy to get around.
Personally I'm a web dev and wouldn't be able to make that. No math background is likely the reason
It's definitely something that's needed, no question there, that's only been addressed by libraries. None of this is solving any new problems in a big way, just making things simpler. You could always just write your own functions to do this stuff, except for the trailing commas in functions. That could have had something to do with it, but it doesn't really solve the root issue. I think npm addressed that by making it so packages can't be made unavailable like that anymore.
This is just the Babel plugin that allows Babel to understand the syntax when it's building the AST, you would need an additional plugin to actually transform the AST into something existing JS engines would understand. This is the plugin you're looking for: https://github.com/babel/babel/tree/7.0/packages/babel-plugin-transform-optional-chaining
Meanwhile, browsers still haven't caught up with ES6 imports...
Welcome to JavaScript. In order to avoid oddly named standard functions like in PHP, they just left them out completely!
Not even a mention of async? Also, why are people still using the old numbering scheme? It is ECMAScript 2017 or ES 2017.
\#1 .. there is no ES8.
Comments like this are why I'm super pedantic about referring to the specs by their **proper names.** In this case, ES2017. ^(Yes it's ECMAScript 8th Edition but that number has as much relevance now as Chrome's version numbers.)
&gt;What are the pros and cons of this approach the main con for me is ramda forces you to re-do constructs that already exist in the language, but in some weird dsl, all for the purposes of preserving functional purity. The fact that to use ramda 'properly' you have to call a function name `ifElse` and `and` to keep things pure is silly and confusing. JS isn't a functional language. It has functional aspects, but it also has control structures and supports iteration and recursion and imperative programming. It's not haskell or erlang or clojure. it doesn't make sense to treat it like those languages or to use conventions from them because they hardly ever apply cleanly and properly and are usually half broken.
It's library agnostic in the sense that this design pattern and way of doing things is well studied and probably predates JavaScript itself. The terminology used is either obvious (ifElse) or agnostic to JS/the implementation (pipe) JavaScript has if/else statements, but they're not expressions that return values and cannot be used in functional style (that's the one thing CoffeeScript...ugh...still has over it, so you have to do it with functions). 
Well there are articles written about JavaScript fatigue fatigue, so it's nothing new. I'm actually getting a little tired of hearing about it.
Question about trailing commas in a function. Does that comma mean there's something for the last item? For instance: myFunc(1,2,3,); function myFunc(a, b, c, d) { console.log(d) } What will that log out as? I'm assuming `undefined`, but it would be undefined even without the comma, so what's the point in the trailing comma?
That's pretty damn cool. There had to be a library like this already, right? Does it come with a CPU fallback for users without WebGL?
If there's one thing which does not need congratulating it is the remorseless passage of time itself.
Yeah yeah yeah, never mind that 'asynchronous' mumbo jumbo. Nobody even knows what that *means*, why would anybody **use** it? The real holy grail is that we can **pad strings** now! /s
The problem is, even tc39 won't commit to killing the old versioning. &gt; This Ecma Standard defines the ECMAScript 2018 Language. It is the ninth edition of the ECMAScript Language Specification. Straight from the beginning of the intro: https://tc39.github.io/ecma262/
also https://github.com/MaiaVictor/WebMonkeys
Why did you decide to do this as a Video? What's wrong with text?
YouTube ad revenue
Mostly it's for multi line. myFunc( a, b, c, ); 
[deja vu](https://www.reddit.com/r/javascript/comments/6mtvy8/creating_window_notifications_in_reactredux/)
&gt;deja vu I'VE JUST BEEN IN THIS PLACE BEFORE!
😨
It's also interesting that a search for 🌹 returns no users for you. It does for me on both the desktop and mobile/app versions of Twitter.
Async is ES7 ES2016
Yup it does, thats one of our core goals =] Making it easier for users who have zero knowledge on WebGL. Automated fallbacks occur with "auto" mode.
Wooah. Hey! How's Durham? I just moved to NYC. Actions are stored as a tree, but only the "active branch" is processed. Definitely linear time, however if you return to a prior state, the linear timeline forks, preserving the original sequence. Not too unlike how history works in back to the future. Here's a quick example from the devtools we're working on: https://user-images.githubusercontent.com/590904/28220365-28aabcdc-688d-11e7-9f7d-180cf23b88c7.gif
try experimenting with it, and other examples, you might surprise yourself.
Apologies. Will post again accordingly to the guidelines!
Chrome has
undefined 
Well, turns out a lot of devs can't even pad
You could but async/await is just a way to consume promises. I am not in love with the syntax. I kind of like using then.
Because spec isnt finished yet
I could, but some people like videos, and I like making videos. :) Also, for new programs watching someone do something has a way of helping them understand. 
No it isn't. http://2ality.com/2016/01/ecmascript-2016.html
haha... Because YouTube ads pay sooooo much. ;) I could put ads on a blog post to the same effect. I like making videos.
I see. Someone told me ES7 is the new version and now apparently ES8 is out, it's all a bit confusing. Definitely need to read up on this more. Thank you for clarifying!
Sure but we're congratulating Unix time, not time itself.
Watching a video to see what you're doing means: 1. Turning off my music to hear what you're saying. 2. Consuming the information you're providing at a *much* slower pace. 3. For larger amounts of information, making it almost impossible to pause and resume, without any surrounding context. 4. Losing the ability to copy-and-paste any code you've provided. 5. Losing the ability to actually read the code on a mobile device with a smaller screen. Videos are great if the information you're presenting is ideally presented in video format. Code is not that kind of information. All-in-all, blogging would be better.
I know you can use Babel, but until node supports it natively I'm not switching from module.exports. I guess I'm officially becoming one of those old guys stuck in my ways
Written may be better for you, but not for all. Some people learn differently. I find that sometimes in written form key things are left out that would have made it much clearer. I like both ways of communicating. I messed up my text size in that video. It could have been better for smaller screens. Also, including code examples when applicable is always good.
The navigation issues aren't that big a deal. It's the same obstruction you'd have with strong MVC or with indirect communication via events in other languages / frameworks. Or the dreaded "catch an exception 20 calls deep". The use of the data, the function that gathered them and the place that triggered the function can be scattered all accross your codebase with React/Redux. And it's usually in at least 2 if not 3 different files. We learned very, very quickly that you need good naming conventions, a decent directory structure and the redux dev-tools to make sense of the codebase. "Search all files" also helps, occasionally. When I review a new section of our app and want to understand a new action, I have to find the reducer, the action creator, all places the action creators are use, and the mapStateToProps() method in some cases. Edit: listening for the same action types across multiple reducers and having it affect multiple objects in the store can save a lot of time and headache - but it amplifies the issues outlined above. This usually doesn't take long, but it adds up over time. &gt; why do you dislike "middleware for async work"? I just think a good way of handling asynchronous actions should be part of vanilla redux. No issues other than that with it. We use thunk.
If you write the then chain that way it would be hell. I would write it like this... ``` doSomething() .then(res1 =&gt; doSomethingElse(res1)) .then(res2 =&gt; doAnotherThing(res2)) .then(res3 =&gt; doOneMoreThing(res3)) .then(res4 =&gt; console.log(res4)); ``` I'm not saying async/await is bad, It's just another way to use promises. 
Is there a self-hosted compiler called Moon Moon, too?
DUDE. Promises were made to avoid callback hell, and you do it all over again. You need to return those promises. Edit: you didn't mention those functions were promises so my bad. But there's no reason for writing that kind of code. Promises for ES6, async/await when ES8 becomes LTS version. doSomething() .then( res1 =&gt; {return doSomethingElse(res1);}, err1 =&gt; {myErrors.err1=err1;} ) .then( res2 =&gt; {return doAnotherThing(res2);}, err2 =&gt; {myErrors.err2=err2;} ) .then( res3 =&gt; {return doOneMoreThing(res3);} err3 =&gt; {myErrors.err3=err3;} ) .then( res4 =&gt; {console.log(res4);} err4 =&gt; { myErrors.err4=err4; console.log(myErrors); } ); 
If most of your actions and reducers are 1:1, have you considered using the ["ducks" pattern](https://github.com/erikras/ducks-modular-redux), or at least using a "feature-first" folder structure? Both of those approaches put related code close together.
And padThai.
[Moon Moon](https://s-media-cache-ak0.pinimg.com/originals/4f/71/50/4f71501523280d5865e92da00fff5326.jpg) I'm *Rogue Moon*. Sibling of *Moon Moon*.
Our frontend GUI uses React Native + Redux, but it relies heavily on a client-side crypto-currency library that we also develop. The crypto-currency library is a product in our own right, so it presents a vanilla object-oriented API that our partners can use regardless of their frontend framework. Internally, though, the crypto-currency library also uses Redux for its state-management needs. Thus, our app ends up with two stores - one in the app and one in the library. Besides this, there are the normal cases like using isolated stores for each unit test or server-side rendering request. Relying on a globally-stashed `dispatch` and `getState` functions obviously won't work in these cases, but that's how Jumpstate works.
It's a single expression, so yeah it's too much and I doubt the 'plain' version is less readable. It might be more verbose but likely far easier to parse at a glance. More importantly it introduces complexity rather than reducing it.
Thanks for putting my framework in this subreddit 😊
Uhmm. Ternary. 
You asked a fair question and already got an answer. While I also (mostly) like information in written form, you have to concede that some people are not like you. 
I'm using both, I guess I'm doing something wrong ...
We sorted our folders by domain, if applicable, but separated views from "redux" /src/views/user/UserProfile.jsx /src/redux/user/UserActions.js /src/redux/user/UserReducer.js /src/redux/user/UserActionTypes.js (for the constant definitions) We also have test-folders for all unittests. So the tests for UserActions and UserReducer are in /src/redux/user/tests/... I think the "ducks" pattern could work well for us. But as we have a lot of store objects that are used across the app (user profile data and other globally important / required stuff), putting the redux code with the views is not as viable. But I'll keep it in mind. Maybe this becomes more viable as we get more of the application done. Thanks!
I'm sure it is in the spec because of padLeft. It seems a bit silly to me, but I guess there is value in having convenience functions like this in the standard library.
It looks pretty nice, but the benchmarks are REALLY misleading. You compare Vue and claim it to be 89% slower, but you are creating a set of new instances thousands of times a second. Each time an instance is created, Vue compiles the HTML, sets up a reactive data system, and then diffs with the DOM. It is a terrible comparison. EDIT: I made a test case that actually shows how fast Vue is compared to DisplayJS. I'm not trying to hate, just trying to show you that the comparisons you had were wildly out of proportions. Vue is 100% faster. [jsPerf link](https://jsperf.com/displayjs-vs-vue)
Of course not. The world would be a rather boring place if everyone was like me. It's just an irritation over a trend that I see. Lots of information in a "captive" format that requires the amount of time that the author wants it to require. Information that could just as easily been presented as text, and would have been just as clear, if not clearer. But as to "asking a fair question and already got an answer", this isn't a Q&amp;A format. Reddit is a fantastic place for discussion. If OP wasn't interested in discussing the format of their post, I wouldn't have bothered enumerating all of the details I did in my follow-up response. Clearly they were, so I did.
thank you :)
Whole full 8 minutes to see your favourite style of writing promise? Nope, thanks. Would you consider at least posting some example of code before the video to help people decide, if they want to see the whole video? it will help!
Waiting for client-side bitcoin miner.
I'd imagine that all of that got superseded by WebAssembly, but I could be wrong.
I've never been a fan of Ramda's `ifElse`, `and`, etc as they don't seem to actually reduce complexity. Aside from that, I think anyone with even minimal exposure to point-free programming would have zero issues understanding this.
they moved on from gpu's long ago, spent too much energy, and a layer of js would only make it worse, unless that was the joke. edit, oh shit. Any large website can lunch off of everyones browsers for computing resources, without them really knowing, fuck me.
I'm not familiar with Ramda, and although that code uses a heck of a lot of functions I wouldn't call it functional. You want to be compartmentalising your code a lot more when doing FP, that means assigning those massive blocks of nested functions to variables. I also don't think this is an issue with FP, more with the library you're using and your interpretation of FP. FP should be intuitive, any developer should be able to at least understand the code. It should also be a lot more linear, and read naturally. This means as you call functions you should aim to progressively assign whatever it is you're dealing with into a final result: const getD = () =&gt; { const A = generateA() const B = convertAtoB(A) const C = convertBtoC(B) return convertCtoD(C) } Do you see how the only time we don't make an assignment is when we return, and that the intended return is clearly indicated by the function name? This allows us to read our code top to bottom, and progressively build up an idea of the final result in our head. Nesting our functions gets rid of this (massive) benefit of FP, makes our code messier, and crucially far less intuitive than if we had followed the style in your example: const getD = () =&gt; { return convertCtoD( convertBtoC( convertAtoB( generateA() ) ) ) } Not only is this a mess, but it's a pain to read since we have to read it backwards. One crucial thing to remember about FP is that we are taking a performance hit to make our code more readable, more reusable, and more intuitive. We're basically trading performance for a better coding experience, the theory goes that that leads to better apps. Don't be afraid to make what would otherwise seem like a pointless assignment - remember that this is a high-level JS app, not a hardcore, bit-pushing C++ program. &gt; should I continue to do this in the context of a project that heavily employs Ramda? Unless you're starting the project from scratch you should always continue to use the styles and patterns already being used. Even if you think your style is superior (everyone does) you should keep the project consistent. Are other files written in this style? If yes, carry on. Otherwise, look at the patterns being used in similar files and copy that.
For comparison, here's a vanilla JS equivalent. (Needs some test data to verify I didn't make a mistake.) const getContentByChapterIndexes = (content, chapterIndex, nextChapterIndex) =&gt; { return content.blocks.slice(chapterIndex, nextChapterIndex).map(block =&gt; { if (block.type === 'atomic' &amp;&amp; block.entityRanges[0]) { const entity = content.entityMap[block.entityRanges[0].key]; return `${entity.description}\n${entity.title}`; } else { return block.text; } }); }
Why have the comma after the last param? Just code style preference?
[removed]
In theory for the same reason as lists or objects (easier shuffling of args since they all end in commas). I think you'd mostly do that using things like compose where you run lots of functions in a row.
[removed]
A lot of devs can write their code in assembly, does that mean they should? No. Saying devs can't left-pad strings because they used a module is as ridiculous as saying that.
This is /r/javascript so `30 == true` as well. 
I like standards. I have us using node for our middleware. I don't want to have the standards switch between the angular code and the node code, it's all JavaScript. Consistency saves you a lot of headaches down the road
It was actually an Age of Empires [reference](http://ageofempires.wikia.com/wiki/Taunts).
I am the author of this post. &gt; Why do you make a distinction between react / JS and object oriented programming? JavaScript IS object oriented, just not class-based (til ES6). Object-Oriented programming, like functional programming, is a methodology, not a language feature. Some languages _support_ this style better than others, or have a standard library that's designed for the style, but if you're sufficiently dedicated to the task, you can write in an object-oriented style in any language. JavaScript has a data structure it calls an Object, and _most_ values in the language can be treated like objects, in the sense that there are methods you can call on every value except for `null` and `undefined`. But before Proxies came in ES6, every "method" call on an object was a dictionary lookup; `foo.bar` is always going to find a property named "bar" on foo or its prototype chain. Contrast this with a language like Ruby, where `foo.bar` sends the message `:bar` to foo -- this message can be _intercepted_ and _interpreted_, it doesn't have to be a dictionary lookup. Redux is essentially a slower but more sophisticated object system on top of JavaScript's existing one, where reducers and middleware act as interpreters and interceptors around the JavaScript object that actually holds the state. 
You can always further decompose/atomize your code by giving named variables to the function calls that may seem arcane to an outside coder. Though, for someone familiar with functional approaches, I think this is fine.
Most significant accomplishment from the group, they won't die out from starvation. This might or might not be a good thing, and is open for rants of course.
 function getContentByChapterIndexes (content, chapterIndex, nextChapterIndex) { return content.blocks .slice(chapterIndex, nextChapterIndex) .map((block) =&gt; { if (block.type === 'atomic' &amp;&amp; block.entityRanges[0]) { const entity = content.entityMap[block.entityRanges[0].key] return `${entity.description}\n${entity.title}` } return block.text }) } I think it is more readable like this. To OP: Also content seems like a god object.
It would be amazing if they would allow 3rd party applications to hook into the backend, so 1Password, KeePass, LastPass, etc could use this functionality
Whoops, sorry that was what I meant to link! I set that one up in my project and it didn't recognize it. 
I don't see the relationship between wasm and types in javascript.
WASM fills the role of higher-performance types without complicating JavaScript itself.
People still mine with GPUs, and CPUs, depends on the cryptocurrency. Bitcoin's algorithm is dominated by ASICs for sure though. Edit: There's also [Proof of Capacity currencies](https://www.burst-team.us/index.php/how-to-mine/).
This is why the pipeline operator is absolutely essential for real functional languages! The following snippet is (in my opinion) far more readable than both of your examples, since it has less noise (from variable declaration) than the first and reads more fluidly than the second. const getD = () =&gt; ( generateA() |&gt; convertAtoB |&gt; convertBtoC |&gt; convertCtoD );