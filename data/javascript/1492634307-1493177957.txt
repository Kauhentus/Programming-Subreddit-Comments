Besides this, running "console.log(Math.pow(x,3)-(Math.pow(3*x,2)+(x)-3)) ;" returns -54, so I don't see how OP is getting to 27 :P
&gt; class Foo { bar = baz ['some' + 'thing'] = 'wat' } Never used class properties followed by computed properties, but if I had, my linter would have warned me. &gt; const foo = bar() (foo: any) In TypeScript, I'd have said `const foo: any = bar()`. Why the unnecessary second line? &gt; list = makeList() [head] = list You mean `const [head] = list`? I don't tend to use mutable variables these days. &gt; [huge nested mess] Don't nest that deeply, and write simpler code. In any case: ASI is a thing, it can bite you when or when not using semicolons, use a linter. If you don't, put semicolons before [, (, and ` in the rare case a line has to start with one of these.
i'm also getting issues with (Math.pow 3*(x, 2) which should be 3(x)^2 so idk 
ahh you're right, i reran it and i did get -54 as well, still, it's not 0 like it should be. 
ahh, nvm, i don't know what my issue was before because i ran it many times, but i just ran this: "var x =3; console.log(Math.pow(x,3)-3*(Math.pow (x,2)+(x)-3)) ;" and it got me zero
I don't expect this to amaze anyone, but I have for a while felt like I have two options; download megabytes of dependencies for something like express, or write ad-hoc abstractions on top of the native HTTP library. I tend to write a lot of small web applications, where a full fledged web framework doesn't make much sense, but badly implementing affordances on top of the http library has become annoying. Maybe some of you guys are in a similar situation. I gladly accept feedback or constructive criticism. 
Can you explain the objective advantages of omitting semicolons?
Hmm, frankly I haven't looked at classes much and didn't realize it worked like that. Figured either the class block was either all comma separated properties like an object, or like a function block and you would use let/const/var as appropriate. Good to know. 
*gasp* Latest improvements to web browser only available in the latest version of said browser?! What horseshit!
https://github.com/dollarshaveclub/stickybits/issues/21 ^Thanks again for the note!
Less visual clutter
A slideshow of quotes should be the default area.
Static is a dynamic front-end framework that brings together everything that's wrong about other frameworks... Disclaimer: This project is an obvious satire about the state-of-the-art of the front-end development world. Too many frameworks, fragmented environments and the constant struggle to turn front-end development more back-end developer friendly. With that said, it is a nice, quick project that (despite all appearences) actually works and has fairly good performance. In fact, it’s a very good fit for people with legacy projects that just need some MVC/MVVM two-way binding magic to spice up their development process. It’s also a somewhat good fit for people who don’t want all the bloat associated with bigger, more complete frameworks. But if that’s your case, please consider the better options: VueJS and Aurelia
Because it is not a standard and is also not planned to be adopted by other browsers' vendors. See 'Reception' section here: https://en.wikipedia.org/wiki/Google_Native_Client#reception
Hello, We built our blogging platform user admin interface with AngularJS and it's completely open source. It's already in production. It uses JWT for authentication with the backend and has been implemented to do direct upload to s3. We also use the lovely textAngular as for the post editor (We implemented Dark mode as well :P). It has many many more things implemented that I leave that to you to discover if you're interested. Would love to know what you think about it, Github Repo: https://github.com/SavandBros/gonevis-dash Live: https://dash.gonevis.com
We're all friends here! Babel (and Flow, too) are great tools and ones we've learned a lot from. And, you can use TypeScript and Babel together if you like! They can be best friends. So, sorry if you made popcorn, but there's only love here ;)
That's not what this is about.
Can someone who's used ploymer explain how you use it? Whole project? Just a peice? In conjunction with other libraries? I tried it out for myself but couldn't feel exactly how it fits into projects especially considering I use react for many things.
What's an example of a "reliability issue" here?
It would replace react.
not necessarily, but i can't say without knowing the actual code.
It's a rewrite of the reconciliation algorithm AFAIK. It is supposed to be backwards compatible with the current version of React, which means you should be able to use it with the current renderers (e.g. react-dom, react-dom, etc.). 
you know that cursor bug was in chromium, not vscode, right? are we graduating to calling the chromium devs bad programmers too?
Subjective.
LOL who would do that
&gt; plus all of the benefits that types gives you hmm not quite sure what to think when people say this, the benefits types give you and benefits typescripts types give you are different things; i hate for people to think types are that limited
Yep. Javascript. I would check the method the page is using to bold text: some pages may use an HTML tag (e.g. &lt;strong&gt; or &lt;b&gt;) whereas others might use CSS (e.g. &lt;span class="bold"&gt;bold text &lt;/span&gt;). You can use js to gather elements that fit this description into an array and work with them from there. 
Look at DOM querying using vanilla JS by using MDN as a reference. You can then execute the scripts via Chrome Dev Tools snippets or using Greasemonkey.
it's wack. just stick with an industry standard of react
Did you stop reading after the first paragraph.
Typescript is miles ahead of flow.
Then what is it about?
Maybe formally, but informally react is more of the standard for web "component" approach. 
Yeah, why do they have links to prettier-standard in the dang prettier readme. It's... the same dang people working on prettier
Google would. As I understand it, the Play store and YouTube front-ends are fully built with Polymer elements. Edit: Correction, it's YouTube Gaming and Play Store Music.
Web components and React aren't mutually exclusive: https://facebook.github.io/react/docs/web-components.html I assume that includes Polymer, but I might be wrong (plus it's an extra library regardless).
&gt; but I've already had trouble upgrading projects through to v4 but no one forced you to update that if the old version worked fine for you and upgrading is too much of a pain, don't upgrade
Definitely just write your own database. Should be easy to google for. 
Is firebase any good?
lol, I only read the title.
Personally I find it annoying to see a few hundred folders once open my editor with each folder containing only two files. This project started as a tool to eliminate usage of small npm packages in my own projects, such as [eruda](http://eruda.liriliri.io/). Using npm modules just goes against the goal. Writing them myself allows me to have better control of the module rules. You can't have modules with similar functionality. A tiny Module should contain one source file with limited size. It can only depend on modules in the same repo in order to prevent tiny modules from depending on a big module. Whenever I fix a bug or a new feature is needed, there's no need to make pull request to those small github repo and wait for them to reply. In my view, a simple function is not suitable to be published as a package since it's pretty easy to write them myself. Because all the reasons above, I started to write each one of them whenever I need it. As time goes by, the personal utility library becomes what it is right now. Thanks for reporting the "REPL" and url problem, I'll seek to fix it some time later:)
Why wouldn't you? Safari's omnibox is leagues better than Chrome's.
&gt; isn't valid JavaScript. See https://tc39.github.io/proposal-class-public-fields/ which is at stage 2. 
That's not true. ECMAScript explicitly allows syntax extensions, this does not change the semantics of JavaScript.
Check out this thread: https://www.reddit.com/r/javascript/comments/66ea49/closures_in_for_loops_are_driving_me_crazy/
React-motion is physics based, ~30kb and cannot interpolate colors, objects, arrays or number-embedded strings. React-Move is time/easing based, 12kb, and can interpolate anything you want. Each has it's place. React-Move is React-Motion's better half. :)
Support is actually pretty good. With the polyfill you can support evergreen + IE 11 (that's our requirement, anyway). We're using web components in production through Skate.js. 
oo cool
/r/cringe material. This is painfully unfunny.
thank you
If you won't have tons of users, check out https://github.com/typicode/lowdb
Yeah rendering is handled PNaCl - polymer is only for UI controls.
I like polymer way more than react (I have to work with both) - and they both serve as view libraries. I often end up writing code that looks similar in both (or like angular 1.5 components). They can coexist though.
Yeah the PNaCl extension works only on Chrome.
Safari is a great browser. Fast, beautifully minimal, awesome trackpad gestures, doesn't drain batter, syncs well with iOS devices.
It's the new IE6.
Polymer is build by Chrome Team so they are using their own tools. I think the reason is Polymer focuses on web standards and web platform in general - you can Google Play music and lots of other Google properties (soon main youtube) use polymer too - they also use angular 2.x - but to a lesser degree I think. I think this is similar move that Apple did with phasing out Flash for HTML5, they want to use W3C standards.
Ah. Cool. thanks for the answer.
The prototype object reference bug described as a CoffeeScript class gotcha, is not really a CoffeeScript problem, but a JavaScript prototype object problem. I have fallen in this exact trap before. Any multi-dimentional property added to a prototype object, will be shared. Single properties will work fine. var MyClass = function() { } MyClass.prototype.multi = { sub: { property: 'original value' } } MyClass.prototype.someProp = 'hi' var first = new MyClass() var second = new MyClass() first.multi.sub.property = 'shared value' first.someProp = 'will not be shared' var third = new MyClass() console.log('first: ' + first.multi.sub.property + ' - ' + first.someProp) console.log('second: ' + second.multi.sub.property + ' - ' + second.someProp) console.log('third: ' + third.multi.sub.property + ' - ' + third.someProp) This will output: first: shared value - will not be shared second: shared value - hi third: shared value - hi See the [JSFiddle](https://jsfiddle.net/7dd3mt4y/2/) If you set the property directly in the function, it will work as expected: var MyClass = function() { this.multi = { sub: { property: 'original value' } } } 
True
At the very least, you're missing a closing curly brace for that for loop. Could you repost your code with better formatting, as it's not obvious to me what you intend to be commented out at the top there.
Yes. I am used to iPhone and macOS. 
I've used both extensively and I love both. They're actually the same thing except React leverages Javascript more than Polymer. Polymer is more about mixing HTML5, CSS and JS together as a component and leveraging the browser and web components to do it's rendering whereas React is using objects to represent their components and using the standard DOM. Obviously it's a little more nuanced than that but hopefully that's a good enough summary.
I wouldn't say its broken so much as its just different. When jQuery started with their approach to handling asynchronous operations, A+ wasn't a thing. In fact it looks like the A+ 1.0 spec didn't release until around jQuery 1.8 which already had a deferred implementation (used for async). Since then, they've made some improvements to head towards a more A+-like API, such as including a then() method, but the core, non-A+ implementation remained the same. Changing how that works could potentially break a lot of code relying on the original way of doing things so its not something that could be done right away. It was with jQuery 3.0 that the leap was made to be fully compliant with the A+ spec and in turn cause some backwards incompatibility. But this isn't something that's entirely uncommon with major releases.
Why not?
Are you talking about Web components, ie custom elements, or polymer? Because custom elements don't come with a template language or half of your other criticisms. What spec are you talking about? 
~~What~~Why would you come into the JS subreddit to say this? Seems like a real waste of energy. 
Remove the period after `createElement` and before the `(`
Yes, Babel needs compilation to work _in the browser_. But the same file can be used without any compilation, without Babel, in Node.js. The same can't be said about Typescript. 
Web-components. And by extension Polymer. 
The only thing I'll miss from module bundlers is their ability to look for modules in multiple places. In browser it would cause huge overhead with bunch of 404 requests, unless there's some kind of a mechanism to provide a list of available paths for the browser to do lookups locally. Most of the Webpack-bundled projects I work on have absolute path aliases, so you can do `import foo from 'components/foo'`, regardless of how deeply nested directory you are in and where exactly components are located.
Yeah. It is not the only convenience of tools like WebPack. I agree it is a painful but from the other side it is really cool that we can build a simple project and it just works. Personally I'm looking forward how are we going to work with modules in the future. I'm sure it will be cool!
Maybe a poor choice of word, I agree with you it is not a problem. You just have to be aware of it. One could say if you are not aware of it, it is a problem for the developer :)
document.createElement("img"); and not document.createElement.("img"); A debug console would tell you that there's a syntax error.
What would be the alternative to New Relic? I have similar feelings about it, but where to go to? We use manual metrics with DataDog, but that is not quite the same 
What happens if the one who owns the private key intentionally forks his/her log? I mean, creates two messages that both refer to the previous messages in the log, and with the same sequence number. I'm wondering, what happens now.
there is no objective definition for clutter, one person's clutter is another person's information.
🙄 ok, Stage-2 ECMAScript proposals are not syntax supported by any major vendor. The point is, all your examples don't reflect the current state of ~actual~ JavaScript. If TC39 accepts the public field proposal and Flow becomes industry standard, then you might have a convincing argument that semi-colons are non-optional. Until then, stop fucking bike shedding over useless shit. If you use these technologies / extensions in your project, then fine, mandate that everyone use semi-colons, be consistent, but stop. fucking. bike-shedding.
No kidding. People can be brutal while not even taking the time to try to understand.
&gt; fine, mandate that everyone use semi-colons Thankyou.
Keep in mind that my class was run differently than most. Because it was project based, I did not need to spend a lot of time outside of classtime to keep up with the projects. Each student came up with their own, and I guided them along the course of it. At the time, those teaching actual intro or APCS how TEALS typically does were responsible for coming up with their own lesson plans, and grading homework and exams.. I'm not sure if that is still the case. But, I didn't have to do any of that. All of my students had taken APCS already, so they know a bit about programming. At the start of the year, I would give them little mini-lessons or refreshers on certain topics, which would involve a lecture once or twice a week, then some problems exercising that topic for the remainder of the week. This happened maybe once every other week, and when they weren't doing work like this, they were either brainstorming a project of their own or making progress on that. As part of their projects, I had them do research and come up with a schedule of features to guide their development. I met with Kevin (the founder) once or twice a semester and would give him updates on how the kids were developing. He'd take me out to lunch or dinner for these updates, which was nice. (In addition to the stipend we received, which at the time was $5k a year).
[All these are low-level. They adhere to the extensible web](https://github.com/extensibleweb/manifesto). &gt; * The standards process should focus on adding new low-level capabilities to the web platform that are secure and efficient. * The web platform should expose low-level capabilities that explain existing features, such as HTML and CSS, allowing authors to understand and replicate them. * The web platform should develop, describe and test new high-level features in JavaScript, and allow web developers to iterate on them before they become standardized. This creates a virtuous cycle between standards and developers. * The standards process should prioritize efforts that follow these recommendations and deprioritize and refocus those which do not. Web-components do the exact opposite. They prescribe an oldfashioned, browser-bound, non declarative components model with all the problems that it brings solving none of the issues we've had (before v-dom solved many of them elegantly, without duplicating javascript or without binding us to the browser). 
You should use [prop](http://api.jquery.com/prop/)
Any opinions on Dynatrace?
An untyped language is harder to refactor, an asynchronous API with callbacks is harder to reason about and harder to debug, the fact that JavaScript is naturally single threaded is why NodeJS has to use callbacks, but it doesn't buy you anything... we've had multithreaded servers that allow simple, synchronous code authoring while still handling thousands of simultaneous requests for decades.
Because it's the truth. Imagine a JavaScript based server that allowed you to write simple synchronous code in order to read files, load from a database and write the response. Easier to write, easier to comprehend, easier to debug, none of the problems where a callback doesn't get called as mentioned in the article. You're going to say it wouldn't scale, but it certainly can, you just use a multithreaded server like IIS or Java currently is and have a separate VM per thread that you reuse on each request. It may use a bit more memory, but memory is way cheaper than developers.
See my answer to gonzofish's response.
&gt; I wonder if we will see a day when server-side JavaScript takes care of it. Not sure if you're being sarcastic, are new, or very much out of touch... [nodejs](https://nodejs.org/en/) very much can handle this and is used to handle it more and more in major production environments (for good or ill, but that's not a debate for today). If you're using a setup like [express](https://expressjs.com/), then there's even a [package for that](https://www.npmjs.com/package/express-fileupload).
Thank you! My team is currently evaluating GraphQL clients as we look for ways to decouple our existing front-and-back-end services with GraphQL. I'm going to be giving this a careful read.
Sentry is awesome, but it doesn't cover runloop health case. 
According to [section 16.2](Modules in JavaScript) there are 3 ways to reference modules: &gt;* Relative paths ('../model/user'): these paths are interpreted relatively to the location of the importing module. The file extension .js can usually be omitted. &gt;* Absolute paths ('/lib/js/helpers'): point directly to the file of the module to be imported. &gt;* Names ('util'): What modules names refer to has to be configured.
Hi /u/Eleven_Wilson, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `eleven-labs.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [blog.eleven-labs.com](/search?q=%28and+site%3A%27blog.eleven-labs.com%27+author%3A%27Eleven_Wilson%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|20|95% [self.devops](/r/devops/search?q=%28and+author%3A%27Eleven_Wilson%27+is_self%3A1+%29&amp;restrict_sr=on&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|1|5% (I included self.devops because even that is a post for your site)
Hi /u/init0, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Hey, Sorry about that, I indeed tend to share only the work from the blog that my coworkers and I are working on. It's a unique source but the articles are from many different authors. Is that ok ?
I think you missed a point. He probably wanted to avoid downloading megabytes of code that don't get used for a small app.
In addition to the above answers, you probably don't want to be adding an image like that. It might be easier to build your app's layout with HTML (or JSX with React, but that's a whole other story). 
Oki, will put it in showoff Saturday
Thanks!
Exactly, a few megabytes isn't anything for a larger project, but for a throwaway project with maybe a few hundred lines of code it seems overkill. It's also an issue with the amount of dependencies; any dependency might release a minor update which changes a small behavior somewhere. With a few dependencies that isn't an issue, but with 42 dependencies, where 41 of them are dependencies you never manually included and don't even necessarily know of, it quickly becomes more of an issue.
Well either way I'm sure you learned something in the process of making your micro framework.
You don't see why a strongly typed language with an integrated editor makes refactoring easier? Really? Have you used a strongly typed language with an editor that let's you quickly find and change all references? Are you claiming that asynchronous code is just as easy to reason about and debug as synchronous code? Multithreading is only tricky when sharing mutable resources. There is no reason to share anything mutable when writing a transactional server.
Had you looked into Elastic Stack (formerly known as the ELK stack) prior to going with this solution? If so, what were the deciding factors?
If you change your `var` to `let`, you won't have this issue.
My primary concern is the resolution modules by name in a powerful and robust way. Something like webpack can be configured to look in node modules. But what about the browser itself. Afaik. Import by name will only look for a file name in same directory. That it does not have a robust and powerful resolution algorithm as part of the spec.
&gt; What was in Polymer/Chrome is not the final incarnation so we've had to revert some of the support that we already added I'd rather discuss the current situation instead of what things looked like few years ago. I guess I see the strong points where you see weaknesses, I have to work with react on my current project and I really dislike it, maybe its a matter of taste here. I find it hilarious though that you try to make some point using some document, and when I tell you that you have polymer team members on it you suddenly say you don't care. I don't see the point of further discussion here.
Mozilla won't as far as I can tell.
as a user of Thunderbird, i am actually somewhat interested in helping out and have started building out a better/faster email UI and SQLite backing store with fulltext indexing [1] plus fast calendar rendering [2]. on a side note, the death of the Contact Intent API [3] makes me very sad because it promotes the use of native apps on all platforms simply to have access to a local address book. [1] https://github.com/Good-3G/email [2] https://cdn.rawgit.com/leeoniya/domvm/2.x-dev/demos/calendar.html [3] https://www.w3.org/TR/contacts-api/
The extensible web manifesto is everything i look forward to as a web developer and it represents everything that's great about the web now. Why would i care if there was a person on it that then went on to break it. The difference between us seems to be that i am looking at the merits of a feature before i'm dazzled by who drafted it. People keep hand waving for "standards," just doesn't work out for me if these standards mean clear and obvious regression. I believe if something has established itself by means of innovation and wide spread use, it's worth more than a mandated feature put together by a committee out of touch with the real world in a meeting room years ago. 
https://www.npmjs.com/package/eslint-config-airbnb
Not a specific rule, but telling me when my syntax is off is the largest benefit that I get from eslint. Maybe the import plugin telling me when a module cannot be found. 
[`no-undef`](http://eslint.org/docs/rules/no-undef) is my favorite so far, followed by [`indent`](http://eslint.org/docs/rules/indent) and [`eqeqeq`](http://eslint.org/docs/rules/eqeqeq) (because i'm pedantic :) ). honorable mentions to all the formatting rules that eslint can autofix from within vscode :)
[removed]
VS Code, Atom, and Chrome all host perfectly capable debuggers. Many choose to use console logs, though, because their JS is structured in such a way that it is easy to grasp what's going on- so the console logs are for a broad overview, and the debugger is not necessary. I personally do this, although when I do run into more complex issues I fire up a debugger. 
`eslint-disable`
&gt;You don't see why a strongly typed language with an integrated editor makes refactoring easier? &gt;Really? Have you used a strongly typed language with an editor that let's you quickly find and change all references? I'm aware that you can get resharper to rewrite your code for you so it's better. That's not going to rearchitect a badly written application so that it doesn't suck anymore. You can write bad code in any language and types won't save you. &gt;Are you claiming that asynchronous code is just as easy to reason about and debug as synchronous code? Literally yes. If you don't think so then you simply don't know what a Promise or async/await are 
&gt; ploymer explain how you use it? Ploymer is a implementation of web components, the idea is that you could define your own html tags that have behaviors build into them. I can't say how this relates to react. Only that I abandoned trying to use Ploymer and when with a full framework. It just wasn't very fast and limited. There is no shadow dom. 
No debate.
I was surprised to see some of these out-perform others. I had some assumptions about what would be "easier" to optimize, but the results seem to prove me wrong. Anyone have any knowledge about what makes some of these faster than others?
&gt;there’s a good chance that you don’t need to transpile your code anymore. Yet IE11 doesn't even support arrow functions. No browsers support a module system either except Safari TP but the loader spec isn't even finished yet and highly subject to change. I really can't agree with this statement.
&gt; Coming from object-oriented languages, I was used to classes. Since when was JS not an OOP language?
A React component is a function taking x arguments resulting in a function that defines which element, what attributes, and an array of children. Something like: const Component = ({ style, children }) =&gt; createElement("div", { style }, children) Or if you transpile `const Component = ({ style, children }) =&gt; &lt;div style={style}&gt;{children}&lt;/div&gt;`. *This is a real standard* in that it is being used in most frameworks today, resulting in an even playing field where they can actually share code and components. It's also being used on other platforms like mobile, desktop, VR, and breaches new barriers as we speak. A dom encapsulation spec that nobody uses isn't a standard, it will be cast away if it fails to gain traction, and seeing how it doesn't solve a single issue while making app development more complex i doubt it ever will.
lol
OK I got your point now, sorry for misunderstanding. I don't think the implementation (syntax) is going to be any different than from Safari TP. Time will show. The point of this article is to show that the future is a little bit brighter :) Because it is possible now it doesn't mean that it needs to be used now. More like a proof of concept.
True... As you correctly pointed out it is a bit to early to speculate…
You'll need to retrieve it from the server side script.
Not having classes has **NOTHING** to do with OOP. [Haskell has classes](https://www.haskell.org/tutorial/classes.html) and isn't OOP at all. Prototypes however can only exist within the context of OOP.
@skitch920 I added instructions to the readme for using with zsh. That said, I don't use zsh and have not actually tested it to make sure it works. Would you be interested in giving it a shot and letting me know? Thanks in advance!
You know you've mastered JavaScript when you've moved from console.log to console.debug.
haven't laughed at work in a while. thanks for this
Thank you!
Apart from `@apply` rule, the rest of mentioned things in this post are ready to use today. Just have a lookk at great post by Serg Hospodarets on smashing mag... https://www.smashingmagazine.com/2017/04/start-using-css-custom-properties/ ES2015 — https://kangax.github.io/compat-table/es6/ 
RIP Thunderbird. JavaScript is good for a few things. Desktop apps, that are supposed to be open when system starts and run the entire time in the background when the machine is being used, is not one of them.
I write FP leaning JS but it's still absolutely OOP. They can mutually exist in the same language and be used at the same time. You're plainly incorrect. &gt;an object-oriented computer programming language commonly used to create interactive effects within web browsers. [Source](https://www.google.ca/search?sourceid=chrome-psyapi2&amp;ion=1&amp;espv=2&amp;ie=UTF-8&amp;q=define%3A%20javascript&amp;oq=define%3A%20javascript&amp;aqs=chrome..69i57j69i58.1600j0j1)
I upvoted you because what you're saying is technically correct. Still, I'm hoping that comment will turn out to be at the short end of it when the dust settles down. If the semantics aren't finalized yet, I really hope those semantics can be fixed to match with what pretty much everyone (Babel, Webpack, Rollup, ...) has already settled on, and that Node.js will be able to follow them rather than staying on their high horse and fracturing the community by introducing another, incompatible module interpretation for the sake of "correctness".
http://www.aaronbell.com/never-forget-that-javascript-hates-you/ EDIT: wrong article, I meant to reference this: http://awardwinningfjords.com/2014/04/21/functional-programming-in-javascript-equals-garbage.html
I'm plainly incorrect because google/wikipedia says so? Lol. I also made clear that I don't care to argue about whether or not the language is OOP without a clear definition of what you mean by OOP. It lacks classical inheritance as a first class language feature. That's inarguable. If you want to argue something we should argue about whether or not OOP is even good. It's not. It's a horrible antipattern for almost all of the types of applications that we develop with it.
&gt;Have you used a strongly typed language with an editor that let's you quickly find and change references? Not for a long time. But changing references isn't exactly magic. I've never encountered a problem refactoring code in loosely typed languages. &gt;You are claiming that the async/await and promises are as easy to reason about as synchronous code then I'd suggest that you aren't actually reasoning about what async/await/promises do, you're only reasoning about how easy the code looks to you. No... I'm not. I genuinely don't understand why you think async is 'hard to reason about'. If don't understand what the event loop is doing then I recommend watching this video, as it explains it quite well: https://www.youtube.com/watch?v=8aGhZQkoFbQ 
ES2015 is better than I expected, but unless you can exclude IE11, you will still need to use babel. IE is always the elephant in the room and I won't be surprised if Edge ends up the same at some point. 
For fun, use TypeScript or Flow for the next small project you write and see if it makes much difference. Granted it might not, but if you're designing an API and don't get it perfect the first time, it helps alot. The types also serve as very clear documentation of what is expected and what is returned.
`/*eslint semi: ["error", "never"]*/`
https://www.npmjs.com/package/eslint-config-wikimedia (but then I would say that)
Hey, thanks for the comment - at first I wanted to make it look 'posh' then I started working with CSS and decided to grind more JS first ;) Anyway it is something for sure to change.
New Relic has a really good free tier which is good enough for us to monitor our 100+ customers' dedicated servers. Sentry is very cheap and catches most bugs with really useful stack traces and UI event traces.
The site I need to scrape from is our own so it should be fine. Now that I know the term I can look up how to do it. Thanks
why does it have to use the `new` keywoard? why can't it be a factory?
I don't see the problem to be honest. I have Atom, Hyper, Discord and Spotify open all day, they're the most used desktop apps on my machine. And a mail client with rich content seems like natural habitat for Javascript. I know VSCode had blinking cursor gate, but other than obvious and fixable bugs like that i don't think Electron/Chromium suck more energy when idle than native apps. And if they do, i'm curious as to why that is and why it can't be fixed.
Holy crap, there's sanity in JS-land! It's so rare to see tabs in JS-land (normally I see 2-space which is, IMO, far less readable than 4-space, which is far less flexible than tabs) that I sometimes forget that a few linters support it (though most eslint configs, like "standard", don't...)
Most machine learning libraries are written in Python or other "backend" languages. You will probably get better help at /r/MachineLearning.
Atom's a fantastic example of a desktop application utilizing web technologies. I don't see a negative either. &gt; Under the hood &gt; &gt; Atom is a desktop application built with HTML, JavaScript, CSS, and Node.js integration. It runs on Electron, a framework for building cross platform apps using web technologies.
I see the problem, my PC with 1.6 GHz and 1 GiB RAM can't handle multiple instances of chromium running and eating the little RAM it has. I see Electron just as a prototyping tool to create GUIs, i don't see why it's necessary to create desktop apps in Electron when other options like Qt or GTK+ exists.
I follow the AirBnb package for the rules of ESLint. So, it's more often a question of what I turn OFF rather than ON. I can't stand the need for comma dangle, or not having the occasional lonely if's, or padded blocks rule. I get ESLint and love it, but some rules are certainly more of a problem than the problem they're attempting to fix. 
&gt; 1.6 GHz with 1 GiB RAM Because you reference desktop apps in your post I'm assuming these are specs on your desktop?. If so, then I don't think you should be complaining about resource usage on new applications, but instead should upgrade your device.
what shareable thing has the least formatting rules, but catches all the footguns no-undef? I'm starting a new project and don't want prettier and eslint to fight too much. 
i would absolutely go with tabs, so we can all have whatever we like to look at .. but no one else seems to agree with me. all of the code systems i work with flag tabs with big red highlights and other annoying bullshit. So, I use 4-space for everything. And really annoy all my coworkers who use 2-space. But they don't have any trouble reading my code, and they can barely read their own half the time. 
In 30+ years of programming, I've only used a debugger a handful of times, outside of pulling backtraces from binary crashes or to see where in the script it's bailing out, or on a platform where I literally had no external output to log things to. I'm fairly certain that using a debugger would not actually improve my life any more so than proper logging, unless i had like a several minute long rebuild process. 
attributes missing " in json string
 { "extends": "standard" }
Atom, and indeed electron apps in general, are notoriously resource-hungry, though. Obviously RAM is cheap but that shouldn't really be an excuse.
&gt; Our codebase is now roughly 20 years old. It heavily and intrinsically relies on those very Gecko technologies that are now being faded out, more or less aggressively. Being faded away after 20 years? Switch to a javascript framework and see it faded away in less than 2 years.
I guess this is still going to rely on an installed component, though? I use too many devices to try to maintain a bunch of separate device-bound mail clients. Give me something I can log into anywhere, with a consistent interface, and I may be on board. Then give me an electron app which basically just replicates the browser version and I may use it.
4 spaces is hell for us 12-inch screen laptop users. Really inefficient.
&gt; IIS or Java This guy. 
12-inch? they still make screens that small that aren't tablets? You'd really hate my lines out to 100 characters, i'd guess. I really wish everyone would just do tabs. Tabs are just plain better, IMO. But no one wants to. 
I agree. I prefer tabs but it's been pretty much decided that 4 spaces are the way to go. However, YML is still 2 spaced :(
Tricky, but possible. Regex to find the attribute name before the : and adding " before and after. But don't make sense doing it... json to js object shouldn't be tricky
This is what I have come up with. Will this work? http://jsbin.com/guvefevore/edit?html,js,output
If you want to move to webpack, why don't you just move to webpack? Unless you're doing some unusual stuff it shouldn't be too hard to set up. //App.js import module1 from './module1'; export default class App{ constructor(ops){ this.init(ops) this.module1 = module1 } } //Module1.js export default function module1(){} //index.html &lt;script&gt;new App(ops)&lt;/script&gt; Probably better off extending classes but that's how I'd do it if I wanted my files laid out like yours.
jquery style plugin: $.fn.minMaxVal = function(min,max) { $(this).on('keyup keypress blur change', function(){ if ($(this).val() &lt; min || $(this).val() &gt; max) { alert('bad value); } )})` $('#somefield').minMaxVal(1,10) // 1-10` non plugin version function minMaxval (sel,min,max) { $(sel).on ... //copy code from ^^^ minMaxVal('#somefield', 1, 10) 
A few ways, var statement = false !statement &amp;&amp; alert('whatever') if (!statement) { alert('whatever') } 
There are method calls in my modules that use the main app module, so I'm not sure this works. Module.js might use App.filter() in one of its methods. 
This is what I have, but Im having trouble getting it to work. Any advice? http://jsbin.com/wijizoqajo/edit?html,js,output
Sorry could you add some usage examples so that I understand how this is different to (eg) [Styled Components](https://github.com/styled-components/styled-components). What are you trying to do with this? How is it different to raw getComputedStyle or CSSOM etc.? ps I don't think you need to `return this` from the constructor
what is `stickerPrice` ? If it's a DOM element (as inidicated by `.value`) it will always be truthy. What you probably want to do is pull out the number from value, run it through parseInt and check if it is NaN (indicating you got letters or something) edit -- correct link: http://jsbin.com/yefibuquma/1/edit?html,js,output 
I don't know if it is my html but the function isnt working as intended. What I'm looking for is a function that has a max limit of 1million and anything outside of that should produce an alert box. I will post a link with the full source. http://jsbin.com/wijizoqajo/edit?html,js,output
The function I linked above should be pretty close - just change `input.value` to `stickerPrice.value`. It is as I expected, `stickerPrice` is an input element. If you pass any object (including dom nodes) through an if statement, they are considered truthy. I think your intention here is to stop bad inputs - in which case, running `stickerPrice.value` through `parseInt` will either give you the numeric representation of the string the user entered.... or NaN if it can't be converted (e.g, "haha silly form I'm not a number")
\*eye roll\*
It is a lost opportunity. The benefit of writing tests as you add functionality is that you know what features should be tested so that you aren't missing tests later. Now you have to guess.
Considering it's a domain you control then you could allow access from you domain via CORS
It works on mobile but I am looking into some alternate improvements to make it as mobile friendly as possible.
"they shouldn't wall it behind a windows update", ostensibly, which falls flat when you consider that windows has a healthy enterprise userbase that can only get these updates as part of a thorough internal vetting process &amp; are restricted from using third-party browsers. 
Can you add an issue with a screenshot? Would be more than happy to look into it.
It's funny because I'm currently using Nylas as my desktop mail client and it's very good; easily the best mail client I've used (and I've used a number over the years, including Thunderbird). I'm also a happy user of VS Code (and Spotify, and Discord) all of which I have open all day every day. And of course, all 4 use web technologies (Electron or similar). So while I understand your point about the limitations of JS, I think it's also worth considering the limitations of other technologies, and the advantages JS does have. If your theory doesn't explain why there are so many good apps built on that technology currently being widely used and adopted, you may want to think a bit further.
No questions about tests?
The above answer is good for the basics for me. For tests, I generally have someone write me how the map function works and then have them code a drop down autocomplete in any framework they choose. You would be surprised how hard that can be for some people. I highly recommend that new devs go through libraries like underscore, lodash, angular and react and understand what the "magic" is really doing. That is the best way to prepare for a test. 
I've seen that before. The interviewer will ask the interviewee(?) to write a .reduce .map .filter etc function to illustrate what that method is actually doing under the hood. 
No, I am not talking about testing their *skills*, I am talking about questions about *writing tests*. You know, unit tests and shit? Karma, tape, enzyme, sinon, the lot.
I know its a bit of a hassle. Perhaps I'm guessing that u could write a small script which imports webpack config and sets NODE_PATH dynamically before test runs. This way at least u can centralize path settings in one place. Sorry I know this isn't the answer you are looking for.
Personally i tend to solve most of my style tasks with classes and even created an own little helper to write the class string as short as possible. But for highly customized, dynamic styles I prefer something like this: https://github.com/dhunninghake/vudu And this also cool: https://github.com/Khan/aphrodite But I am of course always happy if there are more alternatives coming out of your work :)
This. Been a webdev for over ten years, but guess what, I have a six month old now. Doesn't matter how "passionate" I am about programming: the baby is my side project! Sometimes I get to read an article or two about the latest JS whatevers. That's pretty much it for me outside of work right now. It's WAY easier to have side projects as a junior dev, when you're in school and/or underemployed.
Hi /u/sillycube, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
How about the first 100 lines? all the code is more than the max allowed characters &lt;!DOCTYPE html&gt; &lt;html class="no-js" lang="en"&gt; &lt;head id="head"&gt;&lt;meta charset="utf-8" /&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;&lt;title&gt; NFPA 110: Standard for Emergency and Standby Power Systems &lt;/title&gt;&lt;meta property="fb:app_id" content="189082191212514" /&gt; &lt;!-- *** javascript files *** --&gt; &lt;script type="text/javascript" src="//assets.adobedtm.com/fa5d442811769302936b968457cc4ab1fbf9c942/satelliteLib-a5646c2ec8a9a1cf60541509fc75705cc1668fca.js"&gt;&lt;/script&gt; &lt;!-- jQuery --&gt; &lt;script type="text/javascript" src="//code.jquery.com/jquery-1.11.0.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="//code.jquery.com/jquery-migrate-1.2.1.min.js"&gt;&lt;/script&gt; &lt;!-- jQuery UI --&gt; &lt;script type="text/javascript" src="//code.jquery.com/ui/1.10.4/jquery-ui.min.js"&gt;&lt;/script&gt; &lt;!-- Kendo --&gt; &lt;script type="text/javascript" src="//da7xgjtj801h2.cloudfront.net/2013.3.1316/js/kendo.all.min.js"&gt;&lt;/script&gt; &lt;!-- Modernizr --&gt; &lt;script type="text/javascript" src="/scripts/modernizr-2.8.3.min.js"&gt;&lt;/script&gt; &lt;!-- dynatree --&gt; &lt;script type="text/javascript" src="/scripts/jquery.dynatree.min.js"&gt;&lt;/script&gt; &lt;!-- Custom --&gt; &lt;script type="text/javascript" src="/scripts/java.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/scripts/nfpa_slideshow.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/scripts/jquery.tweet.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/scripts/jquery.zrssfeed.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/scripts/jquery.cookie.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/scripts/utilities.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/scripts/validate.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/scripts/fileUpload.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/scripts/jquery.scrollto.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/scripts/jquery.webinar.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/scripts/NECPromo.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-20350020-1']); _gaq.push(['_setDomainName', '.nfpa.org']); _gaq.push(['_trackPageview']); (function () { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })(); if ('http:' == document.location.protocol) { var page = '/codes-and-standards/all-codes-and-standards/list-of-codes-and-standards'; var OAS_url = 'http://OASCentral.nfpa.org/RealMedia/ads/', OAS_sitepage = 'www.nfpa.org' + page, OAS_listpos = 'TopRight,Top,Left1,Left2,Left3,Right,Right1,Right2,Right3', OAS_query = 'free', OAS_rns = (Math.random() + "").substring(2, 11); document.write('&lt;script type="text/javascript" src="' + OAS_url + 'adstream_mjx.ads/' + OAS_sitepage + '/1' + OAS_rns + '@' + OAS_listpos + '?' + OAS_query + '"&gt;&lt;\/script&gt;'); document.write("&lt;script type='text/javascript' src='http://w.sharethis.com/button/buttons.js'&gt;&lt;\/script&gt;"); } var __st_loadLate = true; &lt;/script&gt; &lt;link rel='canonical' href='http://www.nfpa.org/codes-and-standards/all-codes-and-standards/list-of-codes-and-standards?mode=code&amp;amp;code=110' /&gt;&lt;meta name="description" content="&amp;lt;p&gt;This standard covers performance requirements for emergency and standby power systems providing an alternate source of electrical power in buildings and facilities in the event that the normal electrical power source fails. Systems include power sources, transfer equipment, controls, supervisory equipment, and accessory equipment needed to supply electrical power to the selected circuits.&amp;lt;/p&gt;" /&gt; &lt;!-- *** CSS *** --&gt; &lt;!-- jQuery UI --&gt; &lt;link rel="stylesheet" href="//code.jquery.com/ui/1.10.4/themes/redmond/jquery-ui.css" /&gt; &lt;!-- Kendo --&gt; &lt;link href="//da7xgjtj801h2.cloudfront.net/2013.3.1316/styles/kendo.common.min.css" rel="stylesheet" type="text/css" /&gt;&lt;link href="//da7xgjtj801h2.cloudfront.net/2013.3.1316/styles/kendo.bootstrap.min.css" rel="stylesheet" type="text/css" /&gt; &lt;!-- dynatree --&gt; &lt;link rel="stylesheet" type="text/css" href="/styles/skin/ui.dynatree.css" /&gt; &lt;!-- Custom --&gt; &lt;link rel="stylesheet" type="text/css" href="/styles/browser.css" /&gt;&lt;link rel="stylesheet" type="text/css" href="/styles/message-box.css" /&gt;&lt;link rel="stylesheet" type="text/css" href="/styles/mime.css" /&gt;&lt;link rel="stylesheet" type="text/css" href="/styles/content.css" /&gt;&lt;link rel="stylesheet" type="text/css" href="/styles/contentEditorStyles.css" /&gt;&lt;link rel="stylesheet" type="text/css" href="/styles/responsive-styles.css" /&gt;&lt;link rel="stylesheet" type="text/css" href="/styles/NecPromo.css" /&gt; &lt;script type="text/javascript" src="/scripts/jquery.touchSwipe.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; // Answers Cloud Services Embed Script v1.02 // DO NOT MODIFY BELOW THIS LINE ***************************************** ; (function (g) { var d = document, i, am = d.createElement('script'), h = d.head || d.getElementsByTagName("head")[0], aex = { "src": "//gateway.answerscloud.com/nfpa-org/" + (document.location.hostname.toLowerCase().indexOf('nfpa.org') &gt;= 0 ? "production" : "staging") + "/gateway.min.js", "type": "text/javascript", "async": "true", "data-vendor": "acs", "data-role": "gateway" }; for (var attr in aex) { am.setAttribute(attr, aex[attr]); } h.appendChild(am); g['acsReady'] = function () { var aT = '__acsReady__', args = Array.prototype.slice.call(arguments, 0), k = setInterval(function () { if (typeof g[aT] === 'function') { clearInterval(k); for (i = 0; i &lt; args.length; i++) { g[aT].call(g, function (fn) { return function () { setTimeout(fn, 1) }; }(args[i])); } } }, 50); }; })(window); // DO NOT MODIFY ABOVE THIS LINE ***************************************** &lt;/script&gt; &lt;!-- *** V2 *** --&gt; &lt;!-- Compressed CSS --&gt; &lt;link rel="stylesheet" href="/resources/css/app.css" /&gt;&lt;link rel="stylesheet" href="/styles/v2-override.css" /&gt; &lt;script src="/resources/js/vendor/enquire.js"&gt;&lt;/script&gt; &lt;script src="/resources/js/vendor/slick.min.js"&gt;&lt;/script&gt; &lt;script src="/resources/js/vendor/jquery.hoverIntent.js"&gt;&lt;/script&gt; &lt;script src="/resources/js/vendor/picturefill.min.js"&gt;&lt;/script&gt; &lt;!-- Compressed JavaScript --&gt;
One interesting observation I've made is that I can almost always make a quick assessment between beginner and more advanced js devs purely on their understanding of context (i.e. "this"). It seems to be some kind of threshold that once they can really explain and understand how things like bind, call/apply, async callbacks, etc. and how they affect context they understand programming and javascript fairly well.
Pay attention to the wording. "You *should* be able to talk me through a *recent* side project you are passionate about." Not: "Do you do program in your spare time?" Or: "Are there any github projects that interest you?" This "should" attitude about programming being your job AND a hobby is unnecessary.
I have always liked writing the tests, it's actually easier to test the ui that way, the test runner in watch mode is almost always faster than a browser refresh, especially when data is involved. That way when I get to the ui its 100% done and just ugly, css injection does not need a refresh so dual screen or split pain and you are sorted. It takes some getting used to, but down the line, like now, you would of been happy you had done it and been soo used to it. I spent the last 2 days building a new component, all they way from layout to state management and api calls, without putting it into the ui, and when I did about 15min before the 3nd of yesterday, it worked 100% as required by business with the real data coming from the api I walk in later today and style it. So about 14 hours building something to 100% perfection, without actually seeing it. I never needed to leave the editor as my console runs in my editor as well. 
In general, if you keep an open mind and stay curious about everything you'll do amazing. If you try to learn A and B and C to become a senior developer...not only might A/B/C be out of date by the time you're done learning them, but it'll also be obvious to me as an interviewer that there are serious knowledge gaps. I'd rather you know A very deeply than have a shallow understanding of A/B/C. But the best programmers combine both, and have deep knowledge of A, B, and C. A lot of this comes from your mentality at work. After all, you do spend 40 hours/week working with code. But do you try to get things done 'with hacks' so you can go home as soon as you can, or do you take the time to understand *why* things work the way they do? Stay curious!
Qt and Gtk+ and most of the native toolkits don't easily yield modern applications, more often than not they look and feel like garbage. The web has gone through ages of refinement, the tools available create dynamic interfaces with ease that would have native bite its teeth out. The problem is with Electron and Chrome, though it isn't as bad as some people think it is. 
Not to be flippant but I'd hope they'd think beyond the task at hand, and about the process and environment and thus can generate an rough idea about the difference between being a junior and a senior.
These apps have freedom and expansion that is unknown to a native counterpart, the bit of ram that it currently takes is often an easy price to pay, especially in smaller teams. It will come down eventually as content apart from the browser becomes more prevalent.
Sure there are lots of people that enjoy coding outside of work. Should it be a requirement that your senior dev be this type of person? Or could you also accept someone who is smart, qualified, and leads a balanced life?
Thanks for sharing! These look interesting.
&gt; css injection does not need a refresh so dual screen or split pain and you are sorted. This is how I work too. Without unit tests I can at least see a slice of what I'm working on in the browser (split screen and hot reload) so I know if I'm making breaking changes (at least to the visible slice). Re. never leaving the editor, that's the dream. There are little things that the browser does sometimes that surprise me though (maybe I lack experience) and it's strange that a component does exactly what I want it do to first try.
JSON requires quotes round the properties. correct JSON would be. {"name":"generic/companypicker", "afterRender": "aftaRender"} without the quoted property names it is a raw JS object. and can be eval'ed into a value. (only do this if you trust the source of the eval'ed code) so initialize JSONstring to "tmp=" var JSONstring = "tmp="; ... JSON.stringify(eval(JSONstring)) 
I would love to be working on my own side-projects, but I already work for 12-16 hours a day coding for other people.. Am I supposed to work in my sleep too?
I understand your point, and I believe there are always exceptional outliers. I can personally strongly empathize with that from the college angle. But *only* looking for diamonds in the rough is not an effective strategy for hiring. Candidates that demonstrate interest in code outside of work are more likely to be the type of person I'm interested in hiring - curious, driven, able to make time to achieve goals rather than make excuses. I would gladly accept someone who is smart, qualified, and leads a balanced life. Unfortunately, differentiating those people from the other thousands of applicants who also lead balanced lives but aren't smart or qualified is a Herculean task. How are you going to stand out? And if you are qualified, how are you going to do 45 hours of learning in 40 hours a week - especially in a work environment? Some of the most renowned composers, like Mozart and Bach, are often thought of as prodigies. But in reality, they spent an insane amount of time perfecting their craft. It was a combination of both natural talent and hard work that made them succeed and stand out.
internet explorer
Re: side project, when I ask this question I usually refer to it as "passion project". This could include something the developer built in as part of her job, as a developer-led initiative to benefit the team or the customer. Whether it is a personal (side) project or an initiative at work, this helps build the case that the candidate has the initiative, sense of ownership, and passion to create something and see it through. A candidate can definite prove this through anecdotes of work (9-to-5, business-driven) projects, but side/passion projects definitely help your case, especially developers in senior positions who must demonstrate initiative, ownership, and passion. Source: manager who hires intermediate-senior devs for an engineering department of over a 100
Cheers!
Any specific reason for React? Currently I am reading about React, Angular, Meteor, Ember, TypeScript and Babel, and I'm sure there are many others I might have to look into
You said you don't really have to make any server side api calls or anything like that. You basically only need to deal with user interface. In this case I would say React is probably what you want, seeing as it alone is the 'view' component of an application and nothing more. You could use something else, but I would recommend React for simplicity's sake. React and webpack or browserify to create a single file. Typescript and Babel aren't really frameworks, but tools to create your application. You'll almost certainly use Babel if you want js code compatibility, but Typescript is up to you.
Maybe it's more to do with finding out if they're playing with some of the more bleeding edge stuff as most business production code will be older stable stuff with more support?
Is it was native / screen reader / ARIA compliant?
Have you looked at JSS? It has a lot of features and plugins for generating styles, updating stylesheets, modular css compilation, in-browser autoprefixing,etc. since everything is just json, you can easily reuse, remix, and merge styles. I'm using it in production. https://github.com/cssinjs/jss
I'd estimate an autocomplete to at least 4 hours, how do they have time to do it in an hour interview?
so when will they actually produce a standards compliant product? when will they make a good product? 
Just wanted to highlight &gt; don't even know about this because this is not relevant (:
ES5 support [is basically done](http://kangax.github.io/compat-table/es5/), there's only a few obscure bits and pieces that not all implementations are exact on, but I wouldn't worry about them. ES6 has taken so long because it was such a massive and complicated specification, even during implementation of the features details still had to be worked out. However now support [is pretty much fine](http://kangax.github.io/compat-table/es6/) (as mentioned old browsers like IE11 will *never* be updated). Things are even getting faster with features being implemented before the specifications are even finished, if you use the Chrome nightly builds you can actually use flags to access initial implementations of some of the [proposed features](https://github.com/tc39/proposals).
&gt; Tell me who benefits from pixel perfect design. I think this is a matter of having pride in your craft. I don't think it's necessary and most of the developers I know they don't care about that. In my case I do it because that's the way I grew up. For me it's not different than not doing it and most of the time harder if don't do it that way.
FP without a doubt. JS is leaning that way.
It's definitively not used anymore in the way it used to be before when we had mixins. But still used when you use classes to create components. For example I have seen people bind every function in their component in the constructor just because some functions need it. So they don't stop and think do I need to have a context defined in this function or not? they just bind everything and not worry about that.
They are trying to imply exactly that. And for the life of me I can't figure out why the downvotes are pouring in for anyone in this thread saying otherwise.
* Not being reliant on any framework for building solutions. Using them is great but you should know how to find DOM elements without jQuery, for example. * Understanding asynchronous patterns really well. Callbacks, promises, async/await. Extra points for streams or more functional data structures. Promises are so widely used that a senior JS dev should have a deep understanding of how Promises work internally. Try building your own promise implementation sometime. To that end, you should be able to speak intelligently about the event loop. * System design - this is where senior JS devs (or senior devs of any kind) shine. Tell me how we'd go about building a complex system and what all the main moving parts are. How are we going to test, deploy, package, etc. Good example question: tell me how we'd go about building slack. * Have a good understanding of how to debug. When you hit the "unhandled promise rejection" in node with no useful line number tell me how you'd find the problem. Or there is a memory leak in a web app tell me how you'd track it down with devtools. * Mentoring - I'm not interested in geniuses who can't articulate how they do what they do. Senior devs should spend time mentoring junior devs - teaching is an excellent way to get a deeper understanding of what you do. All that I've mentioned above is not framework dependent. I don't care if you know every feature of ES6 or if you prefer Redux over Rx. You're a senior developer and you can learn those things and adapt to our environment.
Not everything uses react/redux. You still have dependencies that could have issues, for example. It's an absolute requirement that a senior JS dev deeply understand core JavaScript. Everything builds from that. 
I wouldn't say it's required at all. It just makes for a better interview if I can look at a persons github profile and see actual code before talking to them in person. So I would say it helps when interviewing but it wouldn't hurt you if you don't have that.
&gt; Does the idea of a "minimal working example" of a modern front end framework being a 200+kb file make them consider abandoning the career and joining the monastery?... I agree with your post, but this is such a stupid argument.. It's a **frame**work.. You don't download a framework to make a hello world app. The size of something like that is irrelevant. 
If you are familiar with C#, Typescript is going to make writing Javascript a whole lot nicer for you
... bower isn't a thing anymore? :(
It's a bit like how I always use arrow functions. It ensures you don't need to track down the context of this; it will only change when you explicitly want it to. This combined with how often you'll need to bind this in React and the arrow functions in classes syntax coming soon (I forget the formal proposal name) and it makes sense IMO.
Here's another point of view of someone who devotes a significant amount of time to OSS side projects (despite having two small kids): it comes across as a joke when someone sends me an email that starts off with "I saw your work on github" and then links to some job posting offering 50k less than what I make now. As it happens, a lot of recruiters scrape github to find candidates, and people with high star counts are in relatively high demand, so be prepared to make a high offer!
For context: I'm a dev, I leave the non technical stuff to the manager's interview. I'm only interested in seeing the candidate spit out some code. The question we ask intermediate/seniors (but not juniors) is to take an array of endpoints and call them in series, giving me a promise that resolves to an array of all the results. I ask for 3 methods of doing this. It's not particularly hard, but it gives amazing insight into how they think about asynchronous tasks. 
This reminds me of Yahoo releasing a toolbar sometime in 2013. http://www.theverge.com/2013/8/15/4625024/yahoo-introduces-a-brand-new-browser-toolbar 
Not Js or a framework, but just made me think of this. [Hello World - Enterprise Edition](https://gist.github.com/lolzballs/2152bc0f31ee0286b722)
I would if I could, but working freelance and remote, I get paid next to nothing so I don't have a choice.
&gt; The scars and the nightmares. Look out for them I think this is right on. IMHO, a great way to evaluate someone is to have them talk about recent work projects, what things went right and what would they have done differently. This lets you probe into their ability to choose appropriate technology to the task at hand, and their approach to teamwork (and more importantly, conflict resolution)
I also made one a while back when I did not find any that performed good or was in vanilla js. It was something made for a project at work. https://github.com/andersevenrud/select-typeahead
So what you're saying really is that you don't think there's any use case for a noSQL DB? 
Thanks I really appreciate it. What you provided did work. I just added too many "0" in different sections which caused the function to fail. :)
Human nature. Urgh.
Bower is not a thing anymore? What took it's place? Grunt and gulp, webpack? 
I would consider Vue.js as it's super simple to get productive.
Ask about the negative aspects of the language or of the frameworks that he or she has used. 
They should have an opinion on, for example, when, why, how and if to use the new language features in ES6/7 (or really, whatever the newest standard is at that point) -- more importantly, they should be able to support their opinion, based on facts and experience, and without emotional attachment. Even more important (and maybe inspired a bit from past pains): They should know why coding standards are important, and that it is less important which one gets applied than it is that one is consistently applied by everyone throughout the project. Why names do matter. Why discipline is important, and in what area they might lack it (everyone does). In general, I think general intellectual and basic human abilities matter more than specific language featrues.
I can't tell. Are you the one complaining? Or are you complaining about someone else complaining? 
Someone explained this in a compelling way to me as regards hiring partners at a law firm -- it's not like they *want* everyone to put in 80 hours as an associate, it's just that the people who do literally have twice as much experience as the people who only clock 40 hours. The same is true for engineering. Someone who does even a few extra hours of personal development a week can have literally years of experience over someone else by the time they reach a senior level. Also, it's highly likely to be good extra-curricular experience, i.e. a senior EE Java dev vs a senior EE Java dev who has also done 400 hours of Haskell in their spare time.
The problem with the helpers is their dependency on `h`. I would rather have a plain JSON object representing the virtual dom that my function can return, so I can write simple tests without messing with `h` or mocking it. I don't see a good way to use the vdom libraries directly because they are too tightly coupled with the DOM details that I would rather avoid. I am really looking for a thin layer between plain JSON and vdom library. Is there any specific part of code that might be useful? 
I can get lower versions of IE and edge working but after looking at browser version usage they are really low. I most likely at some point will put some time into getting them to work.
I'll look into edge 14. It would be interesting to know if never versions of edge are problematic for simple foreach loops
I don't use foreach much, but can't say i have ever seen an issue. Just did a quick test https://codepen.io/anon/pen/zwqbaw
Most bower packages can be installed with npm now, so there's diminishing need for an additional package manager. 
Oh wait! Bower is not a thing anymore? Well... crap. 
So it's being replaced by npm entirely, then? Or is there something else this week? I still use bower a fair bit, even for new projects, but I treat it mostly as the front-end solution for package management, while I use npm for back-end (nodejs) package management.
beast man thanks I used javascript and it worked like a charm :)) happy friday~
"yoda": [0, "always"]
The last thing is "calling a constructor", not "a constructor". OP was closer IMO.
&gt; Do they cry when asked to manually parse a cookie? I was in an interview a few years ago and was asked how I'd write a sort method for a particular problem. I said that I wouldn't and that I'd choose the right sort method from the JDK (or existing library). They pressed and said that they wanted me to write it from scratch. I went on a little tirade that writing sorting algorithms by hand is pretty dumb and there is always a better implementation already out there to use. Even after the rant I got offered the job.
I haven't used it, do you mean ridiculous in terms of filesize? I would think that's less of an issue in desktop, because you only have to download it once.
Mostly by NPM. The issue with NPM is that you need a lot more setup to get it working for the frontend. I liked Bower when we used it at my old job, but it's definitely a hassle having to maintain multiple package managers.
Thank you, I'll keep that firmly in mind then.
On the server-side JavaScript world... size is basically irrelevant. &amp;nbsp; But in the frontend/client-side JavaScript world... size does matter.... especially with the ever so popular mobile landscape or if your application/website is used primarily in non-first world country. 
Or yarn, if you like your npm a bit more predictable (and have no private repos)
The actual snippet is 'calling a constructor' but he specifically asked for the 'new ...' and that is a function constructor https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function
That's actually one of my favourite interview questions to ask; tell me about the hardest technical problem you had to solve and how you solved it. It giv s me a good handle on how they break down a problem and think through it. I can teach someone programming language syntax, but to this day I haven't been able to yeah anyone how to think through a problem. They either got it or they don't.
don't believe the hype
Yep, I understand the reasoning behind having just one. I'll start using npm entirely, I guess.
You're misunderstanding your own reference. This is the page for using the built-in `Function` constructor, as in **literally it's about a constructor called `Function` that you call to create functions**. If you got past the title and look at the "Syntax" section it'd be obvious what the page is about.
Sure yeah, but don't they use the same repositories?
I think the downvotes are coming from those of us that are actually senior developers and have been for a long time. (I haven't downvoted anyone in this thread) I enjoy the hell out of talking with the junior devs about their awesome side projects and cool new technologies. But in all honesty, I just don't care enough anymore to spend every waking minute writing code. I'd rather spend the time with my kids, with my significant other, with my friends sharing a bottle of wine, or just sitting at home reading a book. I spent the better part of my adult life being obsessive about technology and it has paid off nicely for me. I know what I'm doing and can figure out most technology pretty quickly but I don't feel the need anymore to spend my time off the clock learning more for my on the clock job. When my laptop is closed on Friday afternoon, it doesn't get opened again until Monday. I'll get the emails on my phone, but unless it is really urgent, I'm not going to reply. And I think all of this makes me a better developer. I can have a conversation with the brand new junior developer or just as comfortably the president or board of directors of my client company. I can talk with people about a wide range of topics and understand how their business fits into the world. And that helps me solve their problems way better than learning the latest javascript framework. 
I dunno, look in the description where it mentions the difference in effeciency to using 'new function' vs 'function' (definition). Or maybe I am not understanding what your argument is.
I know and understand "this", which is why I avoid using it. 
Totally. Yarn is built upon npm enhancing it, not replacing it. I just wanted to throw the name out there
Come and join the dark side until you can ask ridiculously large amounts of money for freelancing.
Fedora XFCE
How about for a junior dev ? Would you wanna see their side projects ? Or would you just go straight to interviewing them regarding their JS knowledge / coding assignments of some sort ? 
The side where you can spend your morning getting into the flow, getting interrupted somewhere in the afternoon for a meeting and spend the rest of the day slacking. Makes the evenings doing side projects even more fun.
Believe the hype
&gt; I'm actually not sure where this anti-side-project attitude comes from I think it comes from a false dichotomy that people believe in. People who can't code on the side for fair reasons get defensive when the subject is brought up. It's useful to know that someone loves to code in their spare time, but it shouldn't be held against someone that doesn't have the time to do so. 
If anyone knows how to do this, I'd be all ears. I'm having a lot of fun trying to teach someone who's not very ... problem oriented to think like one. It's hard.
Found the senior JS dev! :)
You'll often hear constructor functions being called classes. Or at least the constructor function along with the definitions within its `prototype` property that define methods that are inherited by instances created by that constructor function. If you want to get technical about it, its not _really_ a class, at least as far as classical inheritance goes, since JavaScript uses prototypal inheritance. But going by the loose definition of what a class is (ripping from [wikipedia:Class](https://en.wikipedia.org/wiki/Class_%28computer_programming%29)): "a class is an extensible program-code-template for creating objects, providing initial values for state (member variables) and implementations of behavior (member functions or methods)", a constructor and its prototype fits. This is why you'll often hear JavaScript having a _pseudo-classical inheritance_ model, where it looks like classical inheritance - especially now with the `class` syntax in ES6 - despite it using prototypal inheritance in the background. Most people won't knock you for calling `CreateMeAnObject` a class.
Their JS is from W3 but it doesn't include inline styles (nor their PHP/C# curly-brace placement). Their [homepage](https://www.w3schools.com/default.asp) clearly shows the separation of HTML and CSS, which is what OP should be doing. Their [very first](https://www.w3schools.com/css/exercise.asp?filename=exercise_howto1) exercise in CSS requires that you create a link to an external stylesheet. I can't even find any usage of inline styles on their site. The notion that W3 is awful/outdated (see [W3Fools](https://github.com/paulirish/w3fools/issues/50)), is itself very outdated. Yes, they don't use ES6 but it still gives a good base in HTML/CSS/JS for absolute beginners. That said, I'd recommend Codecademy/Code School as alternatives. MDN is a wonderful resource but it's not really in the same vein. There are examples, but no exercises or roadmap etc. For OP - `-webkit-xxx-large` is specific to certain browsers and will only work in them. The largest (relative) font size that will work everywhere is `xx-large`, but you can use a high px/em/% size instead if you want super-sized text. See [here](https://developer.mozilla.org/en-US/docs/Web/CSS/font-size).
Updated docs. Edge and IE 11 work now.
Hi /u/thenumber24, please keep it civil.
Will do. 
We don't really have lead roles, but usually interview only candidates with 5 or more years of experience in the field (outside of junior training programmes) I'm convinced the single best way to tell a senior level developer is to have a proper two-way discussion, where you ask their *opinions* on variety of technologies and practices in the industry. "What do you think about X" tends to be a far better question than "describe/demonstrate X". A person who worked in a team will tell you a very different story about scrum, version control, code reviews, CI tools, framework of the month and all the other jazz, than someone who just recited their descriptions and only has theoretical knowledge. Open-ended coversation prompts ideas and opinions that boil from success and challenges they've had with the tools and skills involved. Even disagreeing with the interviewer is absolutely fine and many times can demonstrate a good understanding of the topic and capacity to make informed decisions. The more the interview is like a conversation and the less it's like a test/questioning session, the better idea you get if the candidate knows their shit.
Add symlinks in your node_modules folder that point to the directories you want available from the top level. You can even include the command to create these symlinks in your package.json's `scripts.postinstall` so they will get added automatically.
Being able to program something useful without jQuery or any other library.
It was a loop through of initiating the code highlighting. Always something.
Don't you need to bind click handlers? Or are you using createClass which autobinds to the component?
Depending on what else is going on. I am careful to use 'class' because if I am talking frontend it can get confusing. 1) I often call this an OOP-Class or a Constructor. I try not to use 'function' as making Classes in ES5 is/was a hack (in regards to the formal syntax in ES6 uses 'class' when converted into es5 it'll use the 'constructor function'). 2) I call it 'instance'. myObject is an instance of create me an object. Since the syntax to detect class ancestry in JS is 'instanceof'
I second that. Vue is very easy to learn and compared to Angular gets a lot more done without all the arcane cruft and noise.
its easy. * Somewhat static web presentation -&gt; server rendering (+jquery for interactivity spice) * lots of interactivity -&gt; js rendering and serious frontend architecture (react, angular, vue, ...) There are hybrid scenarios like isomorphic apps and so, but this is basic
In few hours you can just talk about all the stuff so when they would need something, they will know what and where to search.
Makes sense :). I've seen that approach and it's really good for taking snapshots of an applications full state.
I'd be down to help you in go. 
&gt;We reached for underscore to give us helper functions that the JavaScript alone didn't have. No we didn't. We wrote those helper functions cause, ya' know, we're programmers. And we didn't have to wait for someone else to write our code for us. 
That's really the point of the question... look at all the opinion and debate that it sparks! I personally think the only person who benefits from pixel-perfect design is the designer.
I don't think it's an issue having to look stuff up. How can people possibly be expected to remember everything about each method?True experience is knowing what to look up.
Your post reminds me of all those people who state, "C is dead. Nobody uses that anymore.", and, still, C is one of the top two or three most used languages in the world. If vanilla javascript is so difficult, how do the programmers who created React, and other libraries and frameworks, manage to ever put something out?
I actually don't agree with this. Not because you're wrong, because this absolutely is "as designed". But the design is horrible. Your `MyConstructor` is, in every way, a function. There is absolutely no difference between it and any other function (including whether or not I can call it with `new`). The only thing that even indicates that it's a constructor function is the *convention* that the name starts with a capital letter, something that is clearly not enforced by any JS engine. It can also create an object. So can any other function. Changing a constructor function (implicit return) to a factory function (explicit return) is pretty much the definition of 'trivial'. There really is no difference whatsoever between `MyConstructor` and any other function you choose to write. The `new` keyword effectively does only two things. 1) It makes it so we don't have to type `return`. 2) It makes it so we have to care about the implementation of the object creator. This is the reason for your `this` check and why it became so popular: to make it so that we don't have to care *how* the object is created, which is something we shouldn't have had to worry about in the first place. The *proper* response to the need for the `this` check would be to make it so that all object creations look the same, no matter the source. Instead, they decided to enforce that they look different, that you are mandated to care whether your object came from a literal or from a class. As designed, but a design that is pretty much universally accepted (in general) to be bad. We're supposed to program to interfaces, not implementations. Let's just be clear - if *every* object creation required `new`, as is the case in many languages, that would be fine. If *every* object creation disallowed `new`, that would also be fine. The issue isn't even that you *can* do it differently in different instances, it's that you *must*. And that is the crux of my problem: in trying to abstract away these differences so that I can care about what actually matters in coding, I'm now prevented from doing that by a more explicit enforcement of implementation over interface. I never had a lot of objection to `new` because, if I didn't like it, I could just choose not to use it and instead use JavaScript as a language with prototypal inheritance, given that's what it actually is. The problem is that I no longer have that option, because while class constructor functions are still, in every way, *functions*, I can't invoke them.
You sound like a pretty reasonable, understanding, and self aware interviewer, very nice to hear. You should post the assignment, i'd like to see what's expected of senior devs.
please share a simple example.
Sounds like JavaScript may need to adopt C++'s "placement new" syntax. In C++, `new T()` does what you expect -- allocate memory then invoke T to initialize it. But C++ also lets us write `new(ptr) T()`, which skips the allocation step and instead uses the memory "ptr" points to. That being said, it seems extremely rare that we would need to do this in JavaScript, so I don't imagine this would get any traction either. And even if we could, to be honest, OP, I think there are probably better solutions. Rather than replacing a class's prototype with some arbitrary chain of your own, it sounds like you could instead extend the class and override anything you want to behave differently. Feel free to post details of your original problem if you want help figuring out an alternate solution. /u/Barandis
I've heard this book recommended. https://en.wikipedia.org/wiki/How_to_Solve_It 
Source is in Typescript. There for it's not Vanilla Javascript.
Wes Bos has a good vanilla js series that goes over not only map but also many other important javascript array methods under the "array cardio days" https://javascript30.com/
Not sure i follow. Low level languages have a place. As for Javascript, it's become a good language. Frameworks have abstracted HTML and the dom away, because it made making apps hard which is plainly evident. index.html is a stub that loads a bundle, the dom is a dumb-pipe content host, or better yet, a switchable render target. This is what allows the web to roam free, finally. 
How do React programmers, and others, manage to get things done then since they use vanilla JS and the DOM?
A constructor may be a function, but not all functions are created equal. Object methods can't be instantiated with `new`. Neither can arrow functions, and their rules for `this` are different than other functions. As such context cannot be changed for arrow functions with `bind()`, but that's also the case for other functions created through `bind()`. Then you have generators which are also another form of function, which is not unlike how constructors created through the `class` syntax are also different than other functions created elsewhere. They are explicitly different - not just by a naming convention - because they represent a kind of function that can only be called through instantiation with `new`. Welcome to JavaScript.
Well, I have used it pretty regularly at my current job about 50% of the time. Had to migrate from version 4 -&gt; 6 recently. If you have Sencha Architect its not so bad to migrate. But Overall using Ext.js just feels like its WAY too much code to get something done. One thing I really didn't like about it was trying to use the regular dom api alongside it is almost impossible since the names ext generates on the html elements are different everytime. It was probably a good choice several years ago, but today it just feels clunky and huge. 
Well yeah, and I accept that library authors get to choose their API. To me this goes beyond that a little though in that it's not really API, it's fundamental. These two constructs produce something that is, for most purposes, identical. function value() { return {x: 1729}; } class Value{ constructor() { this.x = 1729; } } Yet, to produce essentially the same object, we're forced into different calls. const literalBased = value(); const classBased = new Value(); I don't feel like we should have to care whether our value is made with a factory function or with a class. I feel like library implementers should be free to change the implementation without having to change their API or do something arbitrary like wrap all class constructions in a factory function to make the API look the same.
&gt; as vanilla JS doesn't have a way to do this other than the DOM state is just a value changing over time. VanillaJS certainly has a thing called a "variable", I am sure you must have heard about it. If you're referring to tools for managing state and it's changes, then you're right, vanilla JS doesn't have an abstraction built in to easily observe and react to state changes, but it's trivial to build an event emitter or even something more powerful with Proxies. And keep in mind Proxies are vanilla JS.
[You can use JSX without a build tool](https://www.reddit.com/r/javascript/comments/62pbxk/trying_to_find_ways_of_learning_react_without/dfot9o3/). Maybe it's just me, i think transpilation is one of the greatest strengths that Javascript has. If for some reason you don't like it, use [hyperscript](https://github.com/hyperhype/hyperscript) or any implementation that suits you. Or something like Vue which gives you templates for old times sake, then translates them into react-like functions.
They are really, REALLY easy to implement. And absolutely awful to reason about the deeper they go.
The official docs + the middleware list should be all you need. It's a really slim middleware layer.
Wait until you are maintain someone else's code. Even well formatted code after not touching it for a long time takes much longer to reason about than promises/generators/async await.
Hehe I do that. But I understand that I don't need to bind every method in the constructor. I use it for a quick glance at what methods are in that component. But yeah, I should probably stop doing that. Good thing I'm the only one at work who understands React. Which means I review my own code.
I expect a mid to be able to competently develop on their own without mentoring or help. If you give them a task, they can get it done. I expect a senior to do the same as a mid + drive technical decisions and architecture as well as be able to mentor junior devs.
I would use assembly language for everything, its the fastest.
I'd spend those precious few hours updating your resume and looking for a place to work that *isn't* ridiculously mismanaged. 
Sorry I really didn't explain myself well. I wrote that as I was leaving work. That's exactly what I meant about frameworks and libraries being an abstraction to make writing complex apps easier. But as you said, vanillajs should never be overlooked in favour of frameworks as in the case of proxies. It's picking the right tool for the job. 
Part of this is the leetcode/hacker rank preparatory culture where using only native methods is allowed and encouraged. Used libraries is seen as "cheating", despite the fact that in the real world you would never roll your own omit function.
exactly. I work a full 40 hours a week solving difficult problems on the css side, javascript side, design side, business logic, etc. Maybe I'm jumping to conclusions, but the type of person that has side projects may not BE the most senior developer. The people I know that do a lot of side projects are those that aren't satisfied in their current job position (not too too indicative of seniors who have options), need to learn the ins and outs of different things, etc.
Ah yes, thank you, that looks very much along what I am looking for, I guess you mean something like ... (vnode.children || []).map(applyHyperscript) : h('div', toString(vnode)) Nice idea to call it `vdomOf` or `vDom.of`, looks exactly like pointed functor... ;) If using with React, it would be via [react-hyperscript](https://github.com/mlmorg/react-hyperscript), so no issue with `className`, not sure about the event handlers that might need some dictionary to translate. As far as performance goes, I would hate to sacrifice the code complexity for the sake of performance, hopefully the reduced DOM complexity will compensate for the extra abstraction overhead. I am currently playing with `snabbdom` which delegates reconciliation to its `patch` function, the latter treating its `vnode` argument as abstract tree if I see it correctly. Then it feels the same thing, whether passing the tree at once and applying `h` recursively, or applying it when assembling the tree, again, recursively. What the `patch` function sees, seems exactly the same. Is there still any notable performance difference there? 
Oh, you only want h2's? Then the regex needs to be `/^##[^#]/gm` .split(/^##[^#]/gm).map(p =&gt; "##" + p) And add this to the end if you don't want the stuff before the first h2 .slice(1)
How does the way the BE is structuring their data models relate to some crazy thing I gotta do on the UI because their domain model doesn't well match how the UI is supposed to be presenting it. That's often the case for data input into the application. Or how can I easily combine data on the UI to take advantage of existing api routes. 
Good to know. What's the lowest version you need to support?
Haha. I can see where your coming from but i think you can make the argument that technically everything is vanilla JavaScript when you use it. I believe it's more of an ideology that you are dependent on something else to work like jQuery or a framework. 
No, I don't think my employer would appreciate that. I can describe it, though: Applicants have to create a webpage that displays data from a particular public API with some interaction (e.g. click to show details). They're free to choose libraries, frameworks, etc, but cannot use generators (like yeoman). There are also a couple of non-functional requirements. I don't decide to hire or not based on the assignment itself. It serves purely as a starting point for the technical interview. 
I also forgot to mention, change cell types with `1 - 4`.
For those who check the comments first, the linked article is useless, go to the source directly: https://www.kochan.io/nodejs/why-should-we-use-pnpm.html
~~Useless is a strong word :)~~ ~~I've seen the original article posted a few times, including myself, but it did not get the attention that I believe that it deserve. My guess is mainly because people are SOOO tired of all the new/shiny JS stuff.~~ ~~The point of this article was to provide an easy to digest opinion of why I think this library is cool and worth your attention.~~ ~~But you are right, it is mainly useless, that is why I linked to the original article all over the place.~~
The obvious problem with this proposal is that the following code is already valid js syntax: switch (someArray) { case [a, b]: doStuff() } so this proposal cannot be actually implemented because it introduces ambiguous grammar. 
~~For those who check the comments first:~~ ~~TLDR; Instead of having to re-download libraries over and over and over again every time you run npm install in a new folder, **pnpm will download that version of the library once in some global context and will create a symlink to this library when you run the pnpm install command**.~~ ~~If sounds interesting,~~ read the original article: [Why should we use pnpm?](https://www.kochan.io/nodejs/why-should-we-use-pnpm.html) 
Wasn't this posted here like 2 days ago? With that said, yes, PNPM does look very nice.
Like maven.
The disadvantage of arrow functions, at least in React, is that they're re-created every time the render() method is called. This causes an additional DOM comparison, which can be a performance hit even without a re-render on complicated pages.
You should probably get them at least passably up to speed on Javascript before jumping into React itself. Generally, the more you know Javascript, the better you understand React, and vice versa. I'll also toss out my standard advice and resources: The article "A Study Plan to Cure Javascript Fatigue" ( https://medium.freecodecamp.com/a-study-plan-to-cure-javascript-fatigue-8ad3a54f2eb1 ) is a great place to start. It gives an excellent series of steps for tackling modern Javascript concepts one piece at a time: Javascript, React, ES6, and state management. On that note, definitely don't over-complicate the learning process by trying to learn many different things at once. Some people will say you should use a "boilerplate" to learn React, and they're wrong - boilerplate projects almost always come with too many pieces configured, and are confusing for beginners. Instead, the best advice is to focus on learning React itself first. Once you have a good understanding of how React works, you will better appreciate why a state management library like Redux can be useful, and you can learn about other tools later. You should start out by reading through the official React docs and tutorial at https://facebook.github.io/react/, and I'd encourage you to use the official Create-React-App tool ( https://github.com/facebookincubator/create-react-app ) for setting up projects. It creates a project with a solid build setup, with no configuration needed on your part. There's an excellent post called "Simple React Development in 2017" ( https://hackernoon.com/simple-react-development-in-2017-113bd563691f ) that gives some more specific instructions on the actual steps to follow. Past that, I keep a big list of links to high-quality tutorials and articles on React, Redux, and related topics, at https://github.com/markerikson/react-redux-links . Specifically intended to be a great starting point for anyone trying to learn the ecosystem, as well as a solid source of good info on more advanced topics. It includes links for learning core Javascript (ES5), modern Javascript (ES6+), React, and much more. I also published an "Intro to React (and Redux)" presentation at http://blog.isquaredsoftware.com/2017/02/presentation-react-redux-intro/ , which is a good overview of the basic concepts for both React and Redux. Finally, the Reactiflux chat channels on Discord are a great place to hang out, ask questions, and learn. The invite link is at https://www.reactiflux.com .
What does case [a, b] mean?? I tried this const input = '[1,2]'; const a = 1; const b = 2; swtich (input) { case [a,b]: console.log('wat'); } That didn't work...what is the point of case [a,b] Even if it conflicts with existing grammar, we can just redefine what is does if its currently useless
how do you create reusable components? I've got a button that's used across a lot of different react apps and it has some fancy animations for hover, etc... I'd love to not use `setState` and make it a pure function but then it just seems like it would be less portable and create a leaky abstraction where the redux store would need to support the button in really specific ways. 
`case [a,b]` will never match cause you are creating a new array on the fly as a value for the case. `var a = [4,5];` `a !== [4,5] // true` This would actually work var a = [4,5]; switch (a) { case a: console.log('yes!'); case [4,5]: console.log('never'); } Edit: Even though my example looks weird, let's consider a case when you have an array of arrays, you randomly pick one, and then run it through the `switch`.
My company Cottonwood Coding does in person/remote JavaScript / React / Redux training. We can easily fit into this price range. Would love to talk to you if you are interested. 
\&amp;nbsp; 
I use it on a production site. I wanted to give my users an offline use of the website. It took me quite a while to wrap my head of how it worked and how to use it. I am still not using it perfectly but it satisfied my purpose. I used Googles Service Worker Toolbox to handle how the resources should be fetched. I set it to network first since I had some issues with it crashing my handling of websockets.
But is any of that really as easy as writing standard HTML? Using React for everything without question is not something I will ever subscribe to, either.
That's why we have so much trouble finding people who understand the core language. Everyone gets used to relying on Angular or React for everything.
Both React and Angular 2 are not very good with reusable components.
So ie 10 wouldnt be crazy to get working but ie 9 might be a challenge and based upon general usage percentage of all version of 9 and below combined being less than 0.1% it might not be worth it for me to put work into it. https://www.w3schools.com/browsers/browsers_explorer.asp
Classes seem inapplicable here and you likely do not want them to work with your library. Eg. if someone passes you a constructor for a class with methods, those methods will not be available unless you do the proto wiring. Using `this` just to get implicit return seems not only overkill (and likely bad for perf) but also potentially confusing. 
Feels good having something you poured hours into being called horrible. I guess this is a sign I'm doing something right? (Edit: I should say that the gist linked above was private for a reason - just some early thinking. Things have changed significantly since that gist.)
Check your values to see if they're valid numbers, if they aren't then you need to focus on the correct input: var PRICE = parseFloat(formData.stickerPrice.value); if (isNaN(PRICE)) { formData.stickerPrice.focus() } Also for the love of god don't use capitals for your variable names unless they're constants (which they aren't in this case).
This doesn't work for me in Windows 7. Either the symlinks don't work or it isn't properly reading my npm config for the custom registry I proxy through. Either way, the supposed benefits don't really outweigh the effort at this point. The output is also hard to read -- in git bash it's spitting out random characters, the developers don't really seem to care about Windows, which is a very real requirement for many many people working on node projects. Also, I always have to question the decision making of developers who choose to pull yaml into a JavaScript project.
It was, but I don't think it got the attention it deserved, hence me trying to TLDR; it's main benefit and repost all over the internets.
Great points, would you mind filing an issue: https://github.com/pnpm/pnpm I don't see one that describing what you are seeing. Re "carrying about windows" I think there is only so much that 2 guys can do. My dream is to see something like this make it's way into the real NPM.
Not true. Ad agencies have huge boners for pixel perfect design. What they sell to clients is is that design, and they lose money if they deviate from said design. 
How to use stack overflow 
I'm still not sure I understand what you're asking, but look at this: http://jsbin.com/bakedihura/1/edit?html,js,output. This is obviously a homework assignment, so I won't give too much away, but if you want to be comparing the two input fields, your approach simply won't work unless you use global variables. How's this look?
Don't let one person's opinion slow you down. We are all heading in the right direction, this is just more of the details on how to get there.
Sorry, didn't read the article, do you now what's the difference to yarn?
ಠ_ಠ
Thank you!! If you're able to, can you also point me in the right direction for checking each element for an instance of ##Siren for example and returning that element? SO Banned me because 6 different people jumped to downvote this question. 
&gt;...Yarn is just a small improvement over npm. Although it makes installations faster and it has some nice new features, it uses the same flat node_modules structure that npm does (since version 3).
Yeah I agree with this. I didn't agree with the comment I replied to. I love React and JSX. I've even gotten help from you on the Reactiflux chat room :)
In my opinion the only difference is this. If you have no one to call when the project breaks and you are expected to fix it then you are a Senior Developer. Congratulations. The only caveat is that if you freeze when the shit hits the fan, blame BS like it's JavaScipt's fault, or IE's fault, or someone other than you. You aren't a Senior developer. A senior developer knows to hold off on the blame game until the bug is fixed. A Senior will put his/her head down, work a troubleshooting model, figure it out, break it down, and get it working again. 
Sorry, it's still possible to produce ambiguous grammars: switch (foo) { case bar: match //match clause or identifier? baz: while (true) break baz // is baz a label? } Also, introducing keywords affects the specification for identifiers. Currently `case` is a forbidden identifier. Forbidding `match` will surely break a ton of code in the wild.
What do you think "a11y" is? 
FrontEndMasters.com you r welcome.
This is great! My npm library is looking like Tanner Linsley's greatest hits lately.
Yes, but people aren't asking the right questions. Why do you need flattening in the first place? Is it because you have too many damn packages saved down to a single universal or semi-universal location? That is hording in a very neglectful way. Once things do break you are screwed, because you are already drowning in tech debt. Imagining floating in the middle of the ocean with only a personal life preserver knowing you going to die either from exhaustion, starvation, or drowning. You could try to paddle to land... but you are probably doomed. It would be cheaper to start over. How did we get here? It's because it is convenient... amazingly convenient. Unfortunately, this is actually part of the problem. Why bother spending the time and energy with dependency management when you have such astonishing convenience at your finger tips that takes almost no time with almost no effort? Because no management effort is taken you don't see the mounting problem until the thread breaks the camel's back. Dependency flattening is just one of the problems that bubbles up when you have a huge number of assets and no management. On large projects with a huge ton of dependencies (imagine hundreds) and a very large user base you start noticing problems of breaking builds because dependencies never make it across the wire or arrive in a state that is corrupt or incomplete. This is observed frequently at Atom-Beautify. Just search the issue list. https://github.com/Glavin001/atom-beautify/issues/ I am working on a project now to invert dependency management so that the weight of this problem is on the developer instead of the consumer. This will allow developers to catch problems in their test builds and correct for them before pushing software off on their users. Dependency management is hard and painful, so I am trying to make it as easy and automated as possible. The project is https://github.com/prettydiff/biddle and I hope to have it production ready at the end of this weekend once I merge the 0.2.0 branch.
Very true. Though, a significant portion of spyware is online through web services in the browser. Linux won't protect you from that.
Possibly, right now I don't really have time to investigate more and I don't have enough specifics for a decent bug report. I'm currently in a corporate environment and pulling dependencies is much more complicated than normal. I need things like custom certs and internal proxy repositories, there are lots of places for something like this to fail. Although I did dig a little further and the first issue is probably the fact that it doesn't use the custom cert specified in my npm config.
Typically, uncaught regressions happen like this: - Build feature 1. Test. Ship. - Build feature 2. Test. Ship. - Build feature 3. Test. Ship. - bug report: feature 1 crashes on invalid input. What happened? Some code that feature 1 happened to depend on was changed, but because you were focused on building/testing only feature 3, and you had already made similar changes for feature 2 with no incidents, you only smoke tested that feature 1 was working with valid input, but not with invalid input. A sufficiently complete test suite would've caught that before you released feature 3.
it was w3 haha..
Thanks but after hours of waiting on my professor he was finally able to assist me thanks for the help 😁
on windows is easier to start with than on linux..but than again if you don't like linux than you can still install windows etc.. if you only do frontend will you probably not see the difference that much..and when you earned your money you can still upgrade :) just make sure that you have an ssd disk with your windows..for linux it is not necesary
Good use of spacing and clean lines, managers and CEOs love that shit. Makes things look "modern".
As a TypeScript user, JSX is just one of the things I have built-in, so I don't even think about it. I don't make my apps 100% React, either. Individual components use React when it's the best way to factor them. Things like TypeScript, Flow, Babel have become the norm for any bigger JS application these days, so we can almost call JSX a "built-in" feature of any JS dev stack. 
I have recently bought what I hope is my last Mac (I think Apple is not interested in devs anymore) and have been asking myself the same question. By chance I have been working onsite at a client's for the last couple of months, and there I can only use Windows. So I had a good test drive. Windows has got better, their OS is almost as slick as Apple's. I could live with it and its quirks. But as a dev what I cannot live with is the CLI. Cygwin, gitbash, are all poor substitutes for the real thing (try installing something on gitbash). You can run bash on an Ubuntu emulator on Windows, but I haven't tried it and it's still beta anyway. Copying and pasting in a terminal is still A PAIN IN THE ARSE. The wrong slashes are A PAIN IN ARSE. The fact that it all goes tits up when there are too many nested folders and the path exceeds 255 characters is A PAIN IN THE ARSE. So I am going to try a Linux machine next. And if it turns out that doing "normal" things like checking emails or writing text or running Dropbox is a pain on Linux, I will probably keep a Linux box for pure development, and a cheap Windows machine or a tablet for the rest - it's still going to be cheaper than a Mac. The only issue really would be opening Adobe documents (.psd and .ai) in linux.
not really..if you are already familiar with Linux, than there is nothing windows could offer..
I've stopped testing people, I talk to them. Experience shows up through conversation. Everyone can talk about their preferences but experienced developers have perspective gained by using different tech. They can take you through their reasoning as to why React was better for a project over Angular, Postgres over Mongo, etc. They've actually used or evaluated different approaches and have their own experience to draw from. Everyone should talk about lessons learned from failure or how they're learning new tools, but the quality developers are those who are curious on their own. They can talk about experimenting with cutting-edge tech just to understand why it's catching on and what problems it's solving. They weren't *told* to, they *wanted* to. Everyone can list something that's important them but experienced developers will have reasons and examples to back it up. Experienced developers have exposure to different communities. They'll have some experience with how open source projects are managed, which best practices are used and when, where, why. The worst developers I've worked with lacked all of these qualities. Coding was just a 9-to-5 for them and nothing else mattered once it worked. They had no perspective and felt like their solutions were equally acceptable as any others but "it works" was the only metric they ever had experience with. They felt like there was nothing else to learn and therefore shouldn't be *taught* to. I would much rather hire an infinitely curious, self-motivated web 101 student than someone twenty-years their senior and devoid of these qualities. 
I do want classes to work with my library. My library creates objects. Classes create objects. It would be pleasant if I could consolidate all of the different ways of making objects into something standard. In fact, I can do that. I can chain to a class's prototype just as easily as I can chain to another object, or to a function's prototype. The thing that's hanging me up is that constructor functions (class or otherwise) perform some initialization that's hidden away from the prototype, and I'd like to be able to use that initialization. I can use it with non-class constructors. I can't used it with class constructors. I can incorporate classes into my library, but it'll become less functional. I'll have to think on which way is best. As an aside, regarding confusion, that's all subjective. My opinion is that having a function where an object is created, bound to `this`, and returned - all without any code indicating that should happen - is more confusing than using `Object.create` and returning the result with `return`. I believe it's even more confusing when that only happens when you call that function one way and not when you call it another way. I think that it's confusing to use `instanceof` when you don't have instances and `class` when you don't have classes. I think that it's confusing that JavaScript programmers generally not only embrace implementation leakage but vigorously defend it.
I wouldn't ever try a lodash one-liner in an interview unless it was actually cleaner, but thanks to special circumstances, I just wrote this for a colleague *today*: `_(modules).concat(_.flatMap(modules, 'subModules')).map('application').compact().uniqBy('name').value()` Normally I'd never string that much, it's much less efficient and harder to read than it should be.
Getting that setup is not that easy. OP said it's easier to get started with React than plain HTML and it received up votes. I disagree with that. But yes those tools are nearly a necessity in any significant modern app nowadays. 
This is just one of many reasons I **despise** tests. People design them for the wrong reasons. I would love to discover that someone could tell me how existing methods work, but I would never treat that as a metric of anything. An interviewer asked me how I would write a PHP class to represent and eventually build/write an XML document. *"Something like (native functions) inside DOMDocument and XMLWriter?"* I asked. He said no. I was confused because those are tools I used to do just that but he wasn't satisfied with the answer. I even explained how they worked conceptually. I was pissed, because I don't think he understood what he was after and it was unfair to me. I didn't get the job, but I probably didn't want it. 
Yeah, I think that's the problem though. Those things you just mentioned are not Material. Material does make good use of spacing and such, but that's not what defines it. It kind of sounds like it's just a buzzword people through around that actually just means "modern web design".
Oh, I see. By arrow functions I meant the doSomething method declaration itself becoming an arrow function. But I wasn't aware of that, so still thanks :-)
you don't need to make match forbidden outside the scope of a switch block
&gt; The moment you start talking about experience, you're absolutely correct: experience is everything. However just because you spend your free time on something, doesn't mean you have more experience than the battle hardened senior who has spend their time actually "solving" issues rather than just spending time on a pet project without any weird or abstract issues posed by a client or employer. I think people should do whatever they want with their free time. And yes, being a 10 year senior dev hopefully means that you're competent and qualified. I don't think people should be slaves to their job. Absolutely not. And yes, projects done in free time aren't always useful. But seriously, how is it surprising that when two devs with equal professional experience go up against each other, the one with more raw coding experience tends to win? I get why people don't want to feel pressure to code outside of work. But what are you seriously asking? For employers to disregard outside projects / work? Like, I have at least a few personal projects that are years old and are, well not mind blowing, but very substantive examples of my abilities to code across many different tech stacks. Why wouldn't I bring that up in an interview? 
Oh yeah, that's a different thing that I think is specific to the way context is handled in ES6 class declarations, if I'm understanding you correctly.
Yep, it's a stage 2 or 3 proposal at the moment. I used it in the past with Babel and it removes the binding headache altogether.
If you have to set up a developer workstation from scratch, you'll spent most of your time installing the OS. This doesn't mean we have to be sitting here and arguing whether maybe we don't need an OS that much.
&gt; So, I use 4-space for everything. And really annoy all my coworkers who use 2-space You sound like a dick
For the nth time - no, they are not better, because they get printed out in all sort of places like browser consoles where you just don't know how many spaces a tab will take
[removed]
But eslint removes the need for yoda.
Why would you use `class` sugar unless you wanted to call new. That's the entire point of the sugar. I literally don't understand what you're asking.
No problem! Personally very fond of the service worker and want to use more parts of it but it took time to wrap my head around. That toolbox helped simplifying the implementation.
This week I attached a callback function to the global object so I could execute a function inside of React from inside an iframe which was outside of React. Super cool but I hope no one ever has to figure out what I did :)
My hiring process is roughly as follows: - take something one of us did last week and turn it into a small coding problem - ask the person to solve it If they can't do it then they couldn't have worked here last week. 
&gt; windows couldn't handle the long paths. Here is an example, for anybody else reading: https://github.com/Glavin001/atom-beautify/issues/1045 This was evidence of dependency tree madness where the dependency mapping was so deep that long directory paths resulted. Often times it was circular where a descendant dependency requires an ancestor module somewhere in its own dependency tree. This indicates all manners of problems and missing management. Tree flattening is better, but you still quickly arrive at hundreds of dependencies. The primary application(s) doesn't need or request most of these, but the application will still break if they are absent. Either way it passes the buck and imposes all liability onto the user.
Thanks, I appreciate that. It's not just for the candidate's sake, though. A good candidate can find another job quite easily and is interviewing me (representing my employer) as much as I am interviewing them. I have nothing to gain by making the experience difficult. The assignment is actually not very hard at all and also used for junior candidates. The difference is in the level of quality that is expected and how well they can communicate about it.
The idea here is to be able to bring in properties added to instances during initialization within a constructor to other arbitrary object instances by calling the constructor against them as a function. This only works if the constructor can be called as a function allowing you to override `this` in the constructor call with an object of your choice. OP's example with the Test constructor shows this, where Test() is called as a function against the obj object adding its x property to obj as though it created obj (but didn't). The class syntax breaks this because it wants to enforce the automatic initialization and prototype assignment handled through `new`, preventing usage of the constructor without it. Unlike non-class constructors, you then can't easily break it up and manage those two pieces (constructor init and prototype assignment) independently. 
Another thing I like to do (depending on the quality of the assignment) is to find a bug, show it to them and ask them to talk me through their process of finding (and hopefully) fixing it.
Saved you a click: Author found out that there is a package manager (pnpm) that downloads file into a cache folder, and then creates hardlinks pointing into the cache folder. There is nothing about why npm doesn't make sense, which is what the title implies.
Yes the files work fine online but not offline with cache cleared
NPM also uses a cache folder, it doesn't download libraries over and over again.
 var arr = ["one", "two", "three", "fourty-two"]; let i = 0; let len = arr.length; var obj = {}; do { obj[arr[i]] = arr[i]; ++i; }while(i &lt; len); i = 0; for (var key in obj) { console.log(`${key} : ${arr[i]}`); // gives one : one etc.. ++i; } https://jsfiddle.net/424z0o21/1/ If you really need different key name, just make an other array for the key and replace arr[i] by keyArr[i], though this way has the advantage to fit for unknown key number and name type.
I expect them to be able to use functional programming and write non-mutating ES6 code without if statements.
I... I'm so sorry. Thank for your sacrifice. By doing that, you saved someone else from the pain and suffering of having to do it. Which means you are a goddamn hero.
 Why not just have a bigger surface, then you can zoom and dezoom/scroll to get to specific color zones ? 3d is cool but you can't see a part of the colors in the dark side of the globe... Seems fairly impratical.
Maybe I'm still not getting it? What's wrong with: &gt; const binder = (Clazz, obj) =&gt; (...args) =&gt; Object.assign(obj, new Clazz(...args)) I understand that this requires different code for being passed a class vs a pre-ES6 constructor function, but the fact that `class` behaves differently from `Function` doesn't seem to prevent the OP from achieving what he wants? Like, why is this an issue for building the library? Why does the mechanism through which these properties are mapped require not calling `new`? Edit: thinking about v8 codegen, I realize that this suffers worse space complexity, but I mean, it's JS, who cares if an extra object is initialized.
116 &lt;canvas id=c&gt;&lt;body onload=for(x=s=c.width=c.height=1024;x--;)for(y=s;y--;)x&amp;y||c.getContext('2d').fillRect(x,y,1,1)&gt;
Hi there! I develop and maintain `@angular/service-worker`, a SW implementation designed for SPAs, especially Angular apps. The service worker API is pretty challenging to use. It's low-level, which makes it a very capable and powerful API, but it can be very difficult to use correctly. The good news is that it's generally hard to make lasting mistakes - the spec limits the maximum time a SW script itself can be cached to 24 hours. Some of my own personal experiences and gotchas I tripped over while working with the APIs: * The MDN documentation isn't always up to date, particularly around the variety of special `Request` modes and options. * DevTools in Chrome has gotten a lot better, but still has some idiosyncrasies. For example, sometimes the Cache Storage view on the Application tab is stale, and you need to right click it to refresh. * `FetchEvent.waitUntil` exists, but you must call `FetchEvent.respondWith` synchronously - you cannot asynchronously decide whether to handle a request. `@angular/service-worker` just responds to everything, and manually delegates to the network if needed. * Scripts loaded via `importScripts()` are not bytewise-compared in the same way the main service worker script is, so if the main script isn't updated, the dependences may not be re-fetched, even if they've changed. * Automated testing of SWs is rather difficult. `@angular/service-worker` has a facade layer to allow much of its logic to be unit tested, plus [some Chrome profile trickery](https://github.com/angular/mobile-toolkit/blob/ffea4acfe442da3af7050c37b0d7baf005efe834/service-worker/worker/src/test/e2e/spec/protractor.config.js#L8) in its Protractor configuration to allow end-to-end testing of things like Push Notifications. * This is not a problem I've encountered personally, but I worry about the safety of caching assets fetched from the server for long periods of time and the potential for race conditions with updates of those same files. Many serving systems don't have atomic updates of deployed files. Thus, you could imagine a SW downloading several .js files for an app could unluckily collide with a deployment and end up fetching some of them from v1 of the app and others from v2. This will break many apps. The old Application Cache spec had a feature where it would re-download the manifest after it had cached all the content, and if the manifest had changed it would know it collided with a deployment and throw out the cached content. I plan on building similar protections into `@angular/service-worker`, perhaps even checksum verification of static file contents. Anyways, I highly recommend starting out with sw-toolbox to implement some of the higher level caching logic. I'm also happy to answer any specific questions about how things work.
You might be getting a issue because you are loading jQuery twice. Since you want to be running offline, remove the first jQuery (https://code.jquery.com/jquery-2.2.0.min.js) and replace it with the (css/jquery-2.2.0.min.js).
I am pretty sure that was added after my comment.
Oh come on now. OP says React is easier to get started than HTML and should be used for everything. I disagree (maybe a little to just voice my unnecessary opinion) and we diverge into this. React is awesome but honestly it's even more awesome with a build pipeline with Babel and JSX. Getting those setup is not as easy as opening a text editor and writing HTML. And with that comment being at the top, I felt it necessary to explain why I find that attitude dangerous. Especially with so many beginners reading this sub. 
So removing the https://code.jquery.com/jquery-2.2.0.min.js kills the jquery altogether. It seems my local jquery isnt working in the first place. I need local jquery file that works!
Looks like you might be right, and yarn went the other way precisely to support Windows seamlessly: https://github.com/yarnpkg/yarn/issues/1761
Just leave a link to this comment in a code comment and they'll be fine ;)
Download which files The jquery? I have the jquery files downloaded but is there an alternate version of the jquery file that will work?
I solved it &lt;script src="css/jquery-2.2.0.min.js" type="text/javascript"&gt;&lt;/script&gt; had to come first in the head tag.
I'm not sure if you went into CS or not in college, but I was sort of "forced" into it, and now I love it. If you love the industry and you can keep up to date you can 100% work in the industry. Going off what what /u/uviveleroi said, curiosity and the willingness to learn is the most important part about being a web developer. I've seen too many "senior" developers who don't know what the best tool to use is, just what they learned 5-10 years ago. I'm 100% self taught in the web development space, and I've had no issues finding jobs.
That can be said for any package manager. The main differences here are that JavaScript is now the most popular language in the world, NPM is larger than all other package managers combined, and there is no governing body (ala RPM) to extensively test versions of all node modules so teams can rely on stable vs experimental. That last point I personally think there is a real opportunity for someone to come along and innovate.
Well, we wrote our own style guide, based heavily on Google's Material Design spec.
What's wrong with div's? Serious question, I use them unless I need some special behavior like an input or table. 
you can just include &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.24/browser.min.js"&gt;&lt;/script&gt; and you're set to write in jsx in your react code. it doesn't require you use webpack and all that other fancy stuff
I actually went to school for Audio Production, picked up a minor in CS my last year. The only reason I even dove into programming was a fluke. I opted to be a lead developer for an interactive audio installation that parsed data streams in to MIDI for use by digital instruments. Never looked back haha. Found web development because we turned it into a sort of online interactive after the live install was taken down. [Link](http://www.isleroyalewolf.org/sonification) if you want to check it out. I truly enjoy the field, a friend of mine and I started up a small web agency and we are both from different fields, but very passionate about what we do. It's definitely a lot of fun and very engaging.
I think maybe I was a little unclear; in my defense, it was the end of the day on a Friday. You're absolutely correct; any anonymous function (or any method bound in the render method itself) will be re-created on every render. The point I was trying to make is really the one below: that binding those methods in the constructor, like so: constructor () { super(); this.someMethod = this.someMethod.bind(this); } or like so: constructor () { super(); this.someMethod = (val) =&gt; someMethod(val); } avoids re-creating those functions when they're passed to child components, since the bound method itself, rather than an anonymous function, can then be passed. Since their props are unchanged (strictly equal), their `render` methods and the resulting DOM comparison won't be run.
If you use tabs for block-level indentation and spaces for alignment, it doesn't matter how many spaces a tab will take (within reason), the code still looks fine. 
I've updated the original article to reflect this fact
That seems parseable, but I'm sure someone is going to whine/bikeshed about the parenthesis-less if :) Anyways, I'm done. Back to writing my parser...
I think you mean I implied, which I didn't intend to. You inferred.
did you read this? https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/switch
Yes, this is part of the design for promises. They aren't meant for recurring events, they are meant for potentially long running processes. Callbacks are an excellent way of handling recurring events.
You're absolutely right. Why use jQuery for events &amp; selectors, like so: // Ready event. $(document).ready(function(){ .... }); // Has class selector. $(el).hasClass(className); ... when you can just use plain JavaScript: // Ready event. var handler = function () { ... }; if (document.readyState != 'loading'){ handler(); } else { document.addEventListener('DOMContentLoaded', handler); } // Has class selector. if (el.classList) { el.classList.contains(className); } else { new RegExp('(^| )' + className + '( |$)', 'gi').test(el.className); }
no idea what your use case is here. . . but whats wrong with just doing: result = goal + " to " + city; ??
I think he may have different actions and different locations. 
Indeed, no reason to ever have thousands rows in your dom. The user won't see them anyway.
Yes! I'm currently struggling my way through creating D3 visualizations, so would love to see more videos like this! Edit: I see you already have 5 D3 tutorials uploaded. I'm excited to check these out! Thanks for posting!
Hit me up if you have any questions. 
You really need at least basic knowledge of JS. If you're the type that likes to learn as you go, you could finish the Codecademy Javascript course super quick just to get up to speed (you already know how to program, you can probably finish it in a few hours). 
Damn sorry to piss you off so much. I wish things came as easy to everyone as they did for you. I'd be interested to see what the reacttraining team thinks if people realized it could be learned in 30 minutes. Also you're anecdote is for a large project that was using jquery. Someone learning programming is not gonna start with a large project. Just remember you learned React in 30 minutes because you understood the problems it solved. It was easy because you knew what the DOM was and how elements fire events. You probably understood how shared mutable state can easily cause headaches or how a top-down approach would be easier to understand. You knew Typescript was helpful because you ran across typing issues before in JS. Your past helped you and new developers don't have that. Telling them to "oh just use this and this because trust me" is not that helpful. 
I wish this was every coding interview because that's ridiculously simple!
If you look at the source code behind Ext.js, they've basically tried to make java from javascript. Widgets and basic spa type components are built for you but if you try to dig into their code and build something more custom that deals with how data is managed, I cry for you. You cannot use ES6 syntax and half the time what 'this' is is a mystery. 
Hey, what about being able to write something where the dropdown is and get it saved in the list? I'm pretty sure it can be done somehow (im pretty new at this), but having that implemented would be cool :)
Like most amateurs, you don't know how professionals go about their business. Interestingly enough, I did use to raise cows for our own use at one time and, at this moment, just put away some dough for baking bread tomorrow. Like most redditors, they think everything is too hard and they want someone else to do the work for them. Then they find out, too late, that they're left in the dust as people who stick to the basics out run them in everything. You kids will never know how great real food tastes and what real programming is.
If you really have to support ancient browsers I'm all for jQuery, but the following in plain JS supports a bit over 97% of browsers (including IE11+): document.addEventListener('DOMContentLoaded', () =&gt; { .... }); if (el.classList.contains(className)) { .... } Edit: sorry for bad formatting, I'm on mobile. 
If there is not the option im looking for, using this in a form for example, being able to type it and it being saved in the dropdown list. *Sorry if im not expresing myself verywell, english is not my main lenguaje.*
Seriously, amen; you can just also use .getAttribute('class').indexOf() to simply check if a class name exists. These ancient ES syntax ways of supporting old browsers are out the window in real production environments. I work for a massive financial institution that services millions of customers; if your browser is old, we tell you to update to IE11 at minimum. This isn't the days of AOL; if your browser or native app can't handle es5 syntax, then sorry, you're in the sub 1% of our customer base (we actually track these metrics too, this isn't just a "guess").
I have to add - why the hate for vue &amp; the downvotes? I am a huge React supporter (especially with the optimization re-writes coming in 16), but the only fault to Vue is it is late to the game - it aims to do what React does without a huge base &amp; a massive organization to back it. Also, frameworks like Vue/Inferno/etc that had massive performance gains over React are what is driving React to improve its performance. We should be grateful there are competitors to the virtual DOM world :D.
Thanks a lot for sharing, looks like there's a lot I have to learn. I might be misunderstanding this but, parent won't work here if I want anything besides document? I'd imagine only document has the createElement function? Or am I missing anything?
&gt; typeof vnode === "object" BTW, this seems to be unsafe. E.g. `null` will pass but throw errors on property access, insane JavaScript ;)
Thank you, it looks like you've put a lot of work into this =) Can't wait to see more.
&gt; It supports comments. JSON doesn't. json5 does (used by babel). Also: { "comment": "this is a comment" }
This is hilarious!
This guy is right on the money! The more one can avoid this the better. FP makes code a lot easier to read.
&gt; windows couldn't handle the long paths. [It can now, or at least there's an option to enable it (which is unfortunately disabled by default still)](https://www.howtogeek.com/266621/how-to-make-windows-10-accept-file-paths-over-260-characters/). 
Thanks 
r/iamverysmart
&gt; Seriously, amen; you can just also use .getAttribute('class').indexOf() to simply check if a class name exists. Are you sure about this. Let's test if a toggle button is "on" or "off": let classes = "button off"; let hasClassOn = classes.indexOf("on") &gt; -1; alert(hasClassOn); // true As I said, [regarding the other "improvements"](https://www.reddit.com/r/javascript/comments/66ph7m/when_does_a_project_need_react/dglhd9o/) suggested to my code here, it's one thing to correct me on technical merit, but your solution is going to just outright give **wrong answers** from time to time.
If it's really that which bothers you about my response, then yes, adding a single HTML page without content is easy. You can take my opinion in a holistic manner, i think project-oriented. How much effort does it mean to finish *that* project, with *these* tools. And there hasn't been a single case over the last couple of years where the traditional way would or has been easier. I pretty much agree 100% with everything /u/LtAramaki said below. 
Sigh: - I actually **did** use `DOMContentLoaded` above, but it won't fire if you subscribe *after* it has already happened, so your code is unreliable as it won't fire at all in some cases. - And although you claim I have `classList` in IE11+, it doesn't work on certain types of nodes, like SVG. You need to drop IE entirely and go for Edge if you want to rely on it. It's one thing to correct me on technical merit, but your solutions here are **unreliable or incomplete**.
No worries :)
&gt; What’s the extended forecast for the JavaScript community this week, you ask? Confusing with a 90% chance of inexorable tooling showers. New Node.js-based tooling emerges in a drizzle-like fashion. If you aren’t keeping up with the small, incremental changes, it feels more like weathering a treacherous downpour of foreign concepts and tooling. Along with this tooling sprouts the need for new JavaScript “dot files” to satisfy tooling configuration. QFT
Neat!
Interesting read, even though it has nothing to do with javascript (except the used language).
I think you could consider using a Vue instance with a CDN link as a jQuery replacement if you don't need to support pre-ES5 browsers. It is built for such minimal use cases and requires no transpiling. You will need to use vanilla JS for Ajax requests though or link another library. 
If you really need such behaviour write your own method using a proper name. Do not replace Object.create! Anyone working in your code will be more than baffled if Object.create works in unexpected ways.
Quit pretending you are so funny by posting the same thing everyone else posts all over reddit when they aren't smart enough to know what's going on. Dumb people do that all the time.
Ok, here's something simpler: function h(tag, attrs, children) { var el = document.createElement(tag) for (var attr in attrs) { el[attr] = attrs[attr] } for (var i = 0; i &lt; children.length; i++) { var c = children[i] el.appendChild(c instanceof Element ? c : document.createTextNode(c)) } return el } Then, you use it pretty much the same way as hyperscript: var html = h("div", {class: "hi"}, [ h("h1", {}, ["hello"]) ]) document.body.appendChild(html) You don't want to do `window[name] = ...` in your function. Doing this is called global scope pollution, and it's considered bad practice (and in fact, it breaks if `name` is a value like `"location"`)
`const createElement = (tagName, properties) =&gt; Object.assign(document.createElement(tagName), properties)`
hey @KajMagnus. all peers would consider the forked log to be broken and stop asking for more recent messages. this is an intentional design decision that will probably not change, as it allows the protocol to be much simpler. since this means logs are per-user per-device (otherwise you might fork), it becomes a _user interface_ problem how to interpret multiple logs as being a single identity. more on this [here](https://viewer.scuttlebot.io/%25PwYjgBO4qwpz4ya%2BFLiXphHyuwdFHntrMGd%2FbXJc17o%3D.sha256), hope that helps. :)
yes pleaseee
What purpose of a language goes beyond the usage of it?
I just shit myself laughing! 
You got it. 
It is worth pointing though that "logical" checking isn't really much different from this. `Pi`, in essence, is just a type-level lambda that gets mock-applied to its function. Under the hoods you could claim Forall works very similarly, due to the way it inspects functions. I'm obviously not claiming this dirty hack is nowhere close to what Idris is (that would be utterly offensive, even), but the underlying mechanism isn't that far away.
Promises aren't a replacement for callbacks. 
Heh. I own the place. 10 developers for 13 years. It's too fun coming here and make fun of pretenders like you.
If you program or run your business like you troll I'm surprised you're still in business. Also, I'm not a noob.
The article is from 2012 and a total mess.
it is more like they want to teach you the principles of programming, oop and basics of algorithms..that is the purpose of college. Not to teach you all possible programming languages but to teach you to program, to think in certain way. You can than go pick a language and learn the syntax because everything else will be the same. Java is therefore a very good choice..because it showcases many approaches, paradigms and patterns. If you learn for instance design patterns..you will apply them the same way in c#, Java, php or javascript..only the syntax will change..so at college they will teach you design patterns not how to do design patterns in JS :)
That assumes the interviewers were looking for palindrome detection so robust it could take care of composite Unicode characters...
Fair enough
&gt; You can get as explicit as you want; indexOf, match, etc. Match? You mean like the code I initially posted? &gt; Why in your own applications you wouldn't know your own gotchas is beyond me. I really hope, for your own sake, that it's not "beyond you" and you're just becoming intellectually dishonest for the purpose of supporting your argument here. This attitude brings me back some 15 years, when I was working on small, simple applications, by myself, and I thought it's the ultimate expression of intelligence to micro-optimize basic operations by taking "smart" and fragile shortcuts in every instance of the operation, instead of relying on a robust implementation wrapped in a suitable abstraction. Embedding gotchas into your code, with the idea you'll be doing `indexOf` in your head every time you combine two classes to check for collisions is very naive. What happens if you refactor your code, changing all instances of class "toggled" to "on"? Or what happens if the class you check for is injected at runtime through a variable? Are you going to be always thinking about the hundreds of gotchas scattered around your code? What happens if you maybe don't work by yourself and knowing each other's "gotchas" quickly turns into an unmaintainable nightmare? There's only one right solution for an operation so basic: use an abstraction that implements the operation correctly. This can mean: - Use the built-in one if it does the operation *correctly*, if it's there. In this case, sometimes it isn't there. - Use a third party library that implements the operation *correctly*. Like jQuery. - Implement your own abstraction that does the operation *correctly*. Implementing bare essentials from scratch on your own is a rookie mistake, when jQuery is less than 25kb minified and gzipped, and your users *already have it in their browser cache* when you refer to CDN's like Google's. I don't need the job security of semi-obfuscated fragile code, and I don't need the ego boost of writing shitty code that looks like "smart" optimization. I just want to write stable, maintainable, robust code. You should, as well.
Hey, I know it can be a mind-shift going from jQuery to React, but yeah... don't use both at the same time. I built a very simple accordion widget with React that hopefully illustrates one way to go about it. Check it out: https://codesandbox.io/s/pYW6EVgx1 With React, you feed data (called props) into a component and let it render itself based on that data and it's internal state. When the props or state change, React will render that component again automatically. Edit: If you haven't already, definitely checkout [Thinking in React](https://facebook.github.io/react/docs/thinking-in-react.html), which is a great intro into how to think about components in the "React Way".
What problem are you trying to solve?
Yes, I understand now. But as you point out, some of this messiness was already there before. I think it's probably incorrect to call `class` sugar anyway -- as the OP points out the implementation is different, but I'm not sure that anyone every promised that it was supposed to be totally transparent. I guess it just doesn't seem like it's that big idea for this library to limit what can be passed -- as I sort of was suggesting in my original comment, I think using `class` if your intention is to do lots of prototype wizardry or run-time modification is probably un-idiomatic and a code smell.
What I meant, is that everything he wrote was pretty much unrelated to Javascript (or any other programming language). He just happened to implement the AI in Javascript.
This is getting too pretentious for my blood. You'd rather inject a library to handle simple operations, I'd rather not. Have a good one.
unfortunately college education is not flexible at all..so if new trends arise they need to update the curriculum and that needs to be approved..it can take years literally :) ..so react or angular are like 2-3 years old and the JS boom is like 2 so they can't really react upon every trend..and html, css and jquery can be learned at home within weeks :) 
K.
Yeah I definitely agree about HTML, CSS and JQuery. Good point. I've ears horror stories about getting curriculum approved, I hadn't even thought about that. That process taking longer than the actual technology growth must be frustrating.
Same here, most of my professors are years removed. That's why I think adjuncts with a knack for teaching isn't a horrible idea.
Alright, I just updated `dir-tree`. It should support Node v6 now.
IIRC Visual Studio 2017 even has some react specific features. 
You can even write this as a one-liner! const compose = (...funcs) =&gt; (...args) =&gt; funcs.reduce((prev, func) =&gt; (prev ? func(prev) : func(...args)), null);
Flawless. 
Scary accurate. I've taken a lead role for a startup recently and was tasked with starting from ZLOC after 4 years with Angular. I ran through each of these issues and learned react is not the best solution by far. My biggest issue right now is testing. Coming from Angular, you sort of assumed the view later worked. In react, you actually test the view layer, and this inevitably is annoying as hell because you need to first search through the DOM to find the DOMnode and test the contents. Also, I hate react router, but it's also fine. It does just take a while to learn 99% of problems are solved with withRouter.
You're not wrong.
https://code.jquery.com/jquery-2.2.0.min.js that is not a local file 
Yes this is exactly what I was trying to tell you with the local files. But your file structure doesnt make sense. you should have a js folder js/jquery.... not css/jquery
What does that even mean? Promises and callbacks are not the same at all. One of them wouldn't even make sense without the other.
Yes indeed, fixed. 
&gt; As a junior front end dev Going on a hunch: this is the problem. JavaScript is *not* a good teaching language. It's not even a good *programming* language. There are so many weird odds and ends, questionable design decisions, and outright errors in the language design that it makes much more sense to teach people a logical, consistent, and more readily adaptable language. In terms of pedagogy, the choice is basically using a bare-metal, learn-the-machine language (C/C++), the most common (or similar) language (Java/C#), or the easiest to use with all batteries included (Python, Ruby). There are options for other languages with their purposes (I hear Ada is still popular). But JS has so many warts and Prototypical inheritance is so different that I can't imagine it being a reasonable choice for the purpose of *teaching* programming.
The first function accesses global state. You can't guarantee that multiple calls with the same input will yield the same output. The second function returns a function. The inner function doesn't modify its closure, so you know that calling the outer function with an input will result in the same output. *The inner function is not executed when the outer function is.*
Not an expert. But I'm going to say why I think that is the case. In the first case the variable is simply pointing to a function. ~~Meaning it is pointing to an anonymous function. But in the second example you are explicitly returning and assigning the function definition to the variable. Which makes it the same as a named function. Doing this on mobile btw. Will try to clean it up when I get home if needed~~. EDIT: That's what you get for guessing. refer to the comment to my answer.
Don't really agree with you..first of all recursion is present in every programming language because it has nothing to do with it..second it doesn't matter that JS uses prototypal inheritance because if you are moving to a different language you are expected to learn its principles..no one said that you will know everything but you will have everything needed to get running as quickly as possible..now every competent developer will tell that if someone says OOP is wrong because we have FP now than it means that the guy just doesn't understand OOP..OOP prefers composition over inheritance which is the same as in JS and every modern language..it just means that you can nicely organise your code in classes, encapsulate your logic, create scope and instantiate objects..which is pretty much the same as in JS..in ES6 we have classes which we use to organise our code, they create a scope. We can instantiate objects..it doesn't matter if they are just function and were created by prototypes..because that is the quirk of the language..but than again you use DRY, SRP, Factory pattern, iterators..you use the same logical thinking and approach to problem solving..the thing is that the approach to programming is constantly evolving, new best practices, patterns...OOP, FP, MVC, MVP, CQRS..so if you know them, you can apply them everywhere. I applied CQRS in PHP and in React..the approach works like a charm..of course it was modified for the language and framework but the principle is the same..the important part is the knowledge of the design..not the implementation..that is the thing of the language
That second function is technically pure, because it will always return the same thing: an impure function which does IO. That example is kinda silly, really.
This sounds like some sort of misunderstanding. Consider this: var impure = function() {console.log(2)} var stillImpure = function() { console.log(1) return function() { console.log(2) } } There's nothing inherently pure about putting a function inside another. The outer function can still be impure if it incurs side effects. More fundamentally, there's no way the outer function is pure, because a guarantee of purity is that *the same input returns the same output*. But, look: console.log(stillImpure() === stillImpure()) // false Why does this matter? Because the guarantee above means a pure function call can be memoized (i.e you can call it once, save the result to a variable, and then the next time you need to call it, you can just grab that variable instead, and your program should behave identically regardless of what it does.) But consider what happens if the outer function looks like this: function impure() {console.log(1)} function isThisPure() {return impure} Now, it seems we're safe, right? isThisPure() === isThisPure() // true var f1 = isThisPure() var f2 = isThisPure() f1() // logs 1 f2() // logs 1 But, what if we do this: function impure() {return Date.now()} function isThisPure() {return impure} var f1 = isThisPure() setTimeout(function() { var f2 = isThisPure() f1() === f2() // false }, 1000) So, as you can see, when the functions are created at different times, they return different values, and therefore we cannot optimize by replacing f2 with f1.
React by itself is not a solution for a real SPA and as a lead you probably realized that very quickly. It can with micro libraries like react router and fetch etc get you there. Angular is a full bodied solution with downfalls on how it managed state syncing and how unintuitive directives really were. Angular 1 and now 4 are considered over engineered by many engineers but I'm not one of them. That being said all the "next gen" frameworks are components models and there is a reason for that. It is by design that components are reusuable, composable, and self contained. Angular 1.x was re done into a new model because it lacked that simplicity. Think rootScope and 2 way binding though these ideas still exist in some respect. Anyway, the people that say react is hard or complain don't seem to understand it because it's more of a declarative/functional approach to UI development whereas first gen frameworks were very much imperative. I think this articles perspective is misguided and the author may be seasoned but obviously not given the ecosystem of react a fair shake. I've done work in backbone, angular 1 and 2, and react with redux. There are positives to both and I prefer the react solution over angular 2. The component model is far simpler and thus easier to code. Lifecycles mimic a state machine and it just makes sense, for me it does anyway. I also prefer state management with redux/flux implementation models in both react with redux and angular 2 with ngrx. I also prefer using my own wrappers around my http client instead of using stuff that angular bakes in like if I want to use bluebird for promises or moneypatch with some other implementation. As far as your statement about the view layer just working I'm not sure why that wouldn't also be the case with react if you wanted it to be. Not to mention that the DOM is a projection of state so it's easily testable in an atomic fashion. Scope in angular is supposed to do that but you get retarded creep and inconsistency due to 2 way binding hence the reason angular 2/4 doesn't have this model and that digest loop shananigans is gone. One more thing about the router. You can literally structure react router as a config and make it work almost identical to angulars approach. Resolvers wouldn't be there per se but that's handled within the component as it should be since that's where the data and code live.
I can see how you may come to that conclusion, but the issue is whether the language is ugly or not, 97 percent of the web uses it now. It's rough to learn, and probably even worse to teach, but every developer will touch it in his or her lifetime.
You do realize that's convention outlined for larger teams to find code and have structure. If you really want to reduce boilerplate you could literally put everything right close to each other and your action creators are just direct handler calls to mutate state thru a reducer in the same file if u really want. It would be no different than like an angualr where u define a root scope of state to change. The way the code is namespaced has nothing to do with redux principles at all that is a choice of the project. The catch is that they they give this as a guide bc they found it to be the simplest for teams to work with. About the state being passed around everywhere in a god object. That is what redux basically is but limits the interaction to only reducers making changes hence easier testability. Its also nicer to work with state since you can make components have minimal read cursors into the state so that you don't need to pass down everything top down e.g reduce prop management across cutting components. In simple crud apps I could see this being cruft I guess but in things like dashboards and interfaces like a photo editor it's a clear winner for predictable state and history capture.
&gt; ES6 syntatically avoids lots of the biggest problems I agree that ES6 fixes some of the syntactical problems. However, there are still other issues (such as how it handles numbers). To be on the record, I *like* ES6 (especially compared to classical JS, but I remember when the cool kids were calling it DHTML, so I'm an old fogey), but I don't see a good pedagogical reason for it. If you can articulate why we should encourage JS over other languages, I'm all ears.
Yea declarative vs imperative. Pure vs unpure function construction. Immutable vs mutable. In practice I think its probably similar to why i see a lot of people have trouble with things like D3 as well. I think all js developers should look into a language with functional constructs or declarative models to see stuff like persistent data structures, async data flow like CSPs, etc. 
How can i forward this to /r/chess?
You can say we're done here but I'm more than welcome to discuss the use of JavaScript as curriculum in a college class. You can't seem to get past the junior dev bit. That's fine, I'm generally used to getting talked down to. See the issue here is you've quoted me out of context. I didn't state it was worse to teach. I mused that it might be. In fact, your original reply to this thread suggests that very fact. I'm enamored by JavaScript and believe that it is teachable. That doesn't mean it's the most popular or most common. It is an empirical fact that it's used on 97% of websites. Regardless, If you had trouble understanding the point I was discussing in the original blog post, please let me know so I can further revise my writing. If you think JavaScript is only ever written for personal websites or self promotion I'm not entirely sure how I feel about your other thoughts in the first place. I'm sure you have more experience in the industry, but I'm also unconvinced that I couldn't find a developer who has only written JavaScript by choice in the last 5 years. 
Redux itself does not care what your file structure looks like. You can separate every kind of thing into separate files (constants, action creators, reducers, selectors, etc), or put everything into the same file. You may also want to read through Dan's article [You Might Not Need Redux](https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367), where he discusses some of the actual tradeoffs that Redux asks you to make. FWIW, I'm writing a blog post that clarifies what actual technical limitations Redux imposes (and where/why they exist), vs how you are encouraged to use Redux, vs how it's _possible_ to use Redux. Intermittent progress, but hoping to work on it some in the next few days.
Keep in mind that Thunderbird already had to run a web browser for displaying HTML emails. Having those whole application in that environment doesn't change much.
I clearly opened a can of worms by using a particular language in my post. I should have been more clear that I'm using JavaScript as the prototypical client side language. I think that college curriculums could benefit from a bigger focus on client side technologies. So much time is spent on server side languages, but not everyone is suited for that kind of work in the stack. I love back end flings every now and again but I'm also very visual and enjoy manipulating the DOM, playing with controls, and messing with styles. Regardless, it's highly subjective because as you pointed out, every department is different. I appreciate your thoughts.
&gt; I'm generally used to getting talked down to. Well... there appears to be a reason for this. &gt; you've quoted me out of context The relevant part of your quote (and here I'm redacting for concision) is: "It's ... probably even worse to teach." My quote cut that down to just two words shorter. I even *directly addressed* the second part of that statement. You can't just wave me off by saying that I took you out of context when I addressed your salient points directly. &gt; I didn't state it was worse to teach. You only said "probably." Then you failed to say anything about why we *should* teach it. Lacking additional argument, it's entirely reasonable to assume that you'd think it's hard to teach. If it's hard to teach, then there's a reasonable assumption that it's *worse* to teach. There's little benefit in choosing a language with few benefits and many problems for teaching. My argument is precisely that there are other languages that are better suited for teaching. I've also indicated some ways in which JS is *bad* for teaching. You haven't provided any argument in favor of JS apart from a meaningless statistic. &gt; I'm enamored by JavaScript and believe that it is teachable. Don't care. Doesn't address the issue. It may be teachable, but other languages **are better for the purpose of teaching.** This is my entire point. I'm not saying that JS is unteachable or unlearnable. I'm just saying that it isn't particularly suited for the purpose of teaching in learning CS principles. &gt; That doesn't mean it's the most popular or most common. My argument was that being popular or common are logical reasons to use a given language as a teaching tool for programming. If JS isn't the most popular or common, then it lacks that potential reason. &gt; It is an empirical fact that it's used on 97% of websites. I owned a goldfish once. Wait. What does this have to do with our discussion? &gt; If you had trouble understanding the point I was discussing in the original blog post, please let me know so I can further revise my writing Oh. You're the original author. Well. Yeah, I can break that down for you. I think there are some logical errors. And yes, I think these logical errors are the result of a general ignorance of the profession. That's also *expected* of junior devs. That's why they're *junior*. That's entirely fine. &gt; you think JavaScript is only ever written for personal websites or self promotion This is a straw man argument. I never said that. In fact, I very **explicitly** made the distinction in my belief that most programmers do not write JS professionally and whether many programmers have actually written JS. I readily concede that many and maybe even most programmers will write some JS in some capacity. I merely speculated as to *why* it would be more common than other languages. &gt; I'm sure you have more experience in the industry I do. &gt; I'm also unconvinced that I could find a developer who has only written JavaScript by choice in the last 5 years I don't think I understand this. Perhaps I'm reading it wrong. I know many programmers that have *only* written JS for the last 5 years. By choice even. They even made career changes so they can focus on it. They love it. *** TLDR: You've completely misunderstood any of the points I was making or how I'm addressing the use of JS as a pedagogical tool.
Yea you definitely could do that. I always used redux with my react router usage so typically my routes were always just container components leveraging "componentDidMount" instead and in react you always tend to handle the null rendering case or loading indicator use case inside the container component itself not on the router side.
As you said there are many forms of abstraction to reduce boilerplate. That is really the secret and key to success of react. It does one thing very well. Virtual dom management and rendering HTML from said virtual dom. The other aspects around state management can be made to be whatever your org or project decides. If you want mobx style decorators for selectors good for you, if you prefer redux same thing, if you want to create custom framework with a revolutionary idea that has a lot less boilerplate than redux, thats great, and React doesn't get in the way. That's why I choose it over an angular eventhough any front end developer can make both of these frameworks/solutions work to reach the end goal.
I did mean couldn't, thank you.
Ahh, I see your point. That is something that we spent a lot of time discussing at work, when and where to make API calls. Similar approach, we ended up abstracting out the fetch/dispatch functionality into a configuration based dispatch middleware/component to keep the containers more pure and easier to reason about. It's basically just a custom implementation of Redux `connect` somewhat similar to how Relay works (but without GraphQL).
I don't even understand this statement? Are you high? 
I would argue that the book is wrong. The return value of either function can not be guaranteed because they're both accessing a mutable store (localStorage). Code elsewhere in the application can change the value for any given key. Only if the function cached the value returned by localStorage could this be considered a pure function because subsequent calls with the same key would return the same value.
&gt; I'm stating that it doesn't make sense to completely ignore a skill In the presence of a limited amount of time to teach as many principles of computer science or software engineering, it completely makes sense to choose a subset of the potential programming languages. &gt; clearly desired by employers in the industry today Clearly desired by *some* employers. Not most. Not nearly. Also, college is a learning institution. It isn't a 4-year job placement center. Colleges should make decisions based on the best tool for teaching students, not on what a whim of a small portion of the industry is doing. &gt; You've broken it down in to an idealistic crusade against the idea that we teach JS in colleges Bullshit. I'm claiming that there are very good reasons for schools to teach other languages. Schools create their curriculum based on practicality and effectiveness. I've also said that (1) there are better pedagogical tools and (2) that JS knowledge isn't nearly as useful for job placement as you seem to think it is. You have yet to address either of these points. &gt; someone who reads "junior dev" which is merely used to delineate an amount of time spent in the full time professional environment It isn't necessarily a delineation of time spent in a professional environment. It's an indication of the expectations and needs of that individuals. It's a mean of articulating to peers how much responsibility should be shouldered by the individual and how much instruction and training is expected from the experienced staff. &gt; instantly believes their opinion, which yours is, is the end all This is an ad hominem attack that isn't relevant to this conversation. You haven't addressed the issues that I've raised and have instead decided to project onto me. &gt; I believed experience mattered in the first place, but at least I listen to those less experienced than me. I listen to those less experienced. I also recognize ignorance when it's placed before me. I have made the claim that your article is written from a standpoint of ignorance. Also, please don't project on me that I am unable to unwilling to listen to people less experienced. I've taken the time to listen and address you. &gt; TLDRs are insults to the intelligence of those you're addressing... At least have the decency to assume I'm reading what you're saying I think the TLDR still stands. You may have read what I've said but you've yet to actually address any of the concerns that I've articulated. 
 document.getElementById("bos").textContent
Solid intro!
??? Promises don't make sense without callbacks? 
&gt; any competent JS developer will tell you that OOP is an unnecessary source of confusion TIL I'm an incompetent JS developer. ;-) I've [seen your descriptions of your workplace](https://www.reddit.com/r/programming/comments/66hpqs/less_than_5_of_indian_engineering_students_are/dgioklc/), so I get why you end up at the opinions that you do. But not every workplace is that way. Or even most workplaces. And that bubble you're stuck in is exaggerating your opinions to unhelpful extremes and ultimately causing you to belittle and to speak incorrectly on behalf of developers who are, in fact, competent.
So I'm not fan of React (in fact, I'm a contributor to svelte) but the statement &gt; In the end I’ve found out that my app will require 3 times more Javascript code for the same trivial tasks I normally handle in Vue.js or Riot.js but it seems that React devs don’t care so I also don’t care. is silly when React clearly states it's just a view library. The React devs don't care about the boilerplate you added by choosing the Redux library.
&gt; And that bubble you're stuck in is exaggerating your opinions to unhelpful extremes Agreed, but I am speaking from multiple different employers based in different parts of the country, which fuels my bias on this matter.
Because the line: playerWin = icons.every(icon =&gt; icon.classList.contains(player)); if being run for every `winPossibilities`. It IS actually setting `playerWin` to `true`, but then it goes through the next possibility (which is false) and overwrites it. Try putting a `console.log(icons, playerWin)` immediately after you set `playerWin` and looking at what happens in the console.
Purity does not require that two results from calling the function results in strictly equal values. Consider this code sample: var function mapSquare(numbers) { return numbers.map(function (num) { return num * num; }); } var numbers = [ 5, 4, 6, 1, 3, 8, 7, 4, 1 ]; console.log(mapSquare(numbers)); The function `mapSquare` can be considered pure. Every call to `mapSquare()` will produce a new array, but for identical values in the input array, identical values in the output array are returned. This is what is meant when 'a pure function always returns the same value' - it doesn't have to return the exact same value from the exact same place in memory, but its value, its meaning must be the same. --- When talking about pure functions in JS though, we have to take it with a grain of salt. JS was never built to be a pure functional language, and it lacks some of the most important features required to truly follow the definition of pure functions to the letter. One big example is type signatures, and is a big reason for the development of TypeScript, for example. Going back to my above example, I'm making some assumptions that are not documented in the code: I'm assuming that my input argument is an array of numbers, and that it has a property `map` which behaves like `Array.prototype.map`. Ofcourse, in the usage example all of these assumptions hold true, but they are not verified at all. You can add multiple runtime type checks, but that uglifies the code heavily and still doesn't fully cover the assumptions either. The solution is type signatures, which basically function similarly to how `interface`s can help require a class to implement a specific API. It's the same here: you could require the input argument to be an array of integers. When the array type itself is then also properly type signed, it in turn will vouch for providing well-defined iteration patterns such as `map`. If you're interested, [here's](https://staltz.com/is-your-javascript-function-actually-pure.html) a decent article detailing the issues with function purity in an originally impure language like JS, and covers everything I've mentioned and more, with a little more depth.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [gin-gonic/gin/.../**README.md#api-examples**](https://github.com/gin-gonic/gin/blob/e2212d40c62a98b388a5eb48ecbdcf88534688ba/README.md#api-examples) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dgmnylu.)^.
Of course you can do without it. What do you think people did before react :p the syntactic sugar you are talking about existed in coffeescript a lib that's very old like jQuery. It is incorrect to view react as necessary or unnecessary in the same way as ppl say ask is jQuery necessary? The answer comes down to what level of abstraction do you find things easier to work in. React gives you a component level abstraction to give you predictable rendering based on any state snapshot in time and reduces the grossness of working with the DOM API and how verbose the code gets e.g, dynamic DOM element creation. Working in pure jQuery code bases and backbone I felt this pain. Angular was able to solve that problem which is why it's considered a second gen framework. So going back, Is it possible to do do what react does with just sass and native DOM manipulation or handlebars? Of course it is but now you will probably need to create a common abstraction to use across your app components to manage state, right? Otherwise you end with yet again js spaghetti. It's best to consider React as a baked solution to what I just posed. I think on your own you will find that you will be implementing a bastardized version of state management to accomplish this kind of state projection that react gives u. Of course you could do a very light version but there is a reason why React has a dedicated team in the first place. It's non trivial in the general case. I mean riot.js is basically that version but without the flexibility of what React does in some use cases.
I'm not sure you fully understand react router and the reason it is the way it is. It's a declarative component model approach to be consistent with react principles. Using those routing libraries as proof they are doing it the right way is dumb because those underlying frameworks don't have a functional component model. Look at the latest modern frameworks I.e angular 2/4, Vue etc they use declarative routing schemes or at a minimum configuration based component schemes. Not to mention you can also make react router work as a config based approach with URI matching....Do your homework sir. EDIT: One more point is that you are looking at routing from a server to client point of view whereas react router in most cases is client only hence some of the difference. React router can be used on the server in the same way but you are comparing apples and oranges.
I have looked at web components and polymer since 4 years ago I understand what you are saying. Unless you are catering to only the latest and greatest browsers you won't have much of a distribution of your app. I never said those techs wouldn't replace it. In fact other libraries can easily replace react as well. The point I was making is that you are looking at it from the wrong perspective. I never said react is the only way to go. You said it was unncessary and I said it's "necessary" if the problems you have fit reacts purpose of abstraction. As of right now it's the simplest view layer abstraction I have worked with. Similar to how jQuery was to the DOM 10 years ago. React is 100% sure to die. The component model will live on. That's what polymer and web components are btw... The jQuery thing is just a comparison. I also don't use jQuery anymore​ and haven't for about 3 years now. Query selector does solve 95% of what I used jQuery for. That and react and angular make it obsolete bc they take away the Dom API for all but 1 or 2 use cases like the portal pattern for example.
react-router also uses a URI/pattern matching not sure what you mean. Also this just showed me that what I said about the simple cases vs harder cases to be evident and that you are not very versed in actually USING the routing systems. The part I was alluding too...in vue is http://router.vuejs.org/en/essentials/nested-routes.html and in angular 2 https://coryrylan.com/blog/introduction-to-angular-routing http://lishman.io/angular-2-router https://auth0.com/blog/angular-2-series-part-4-component-router-in-depth/
lol I understand what middleware is, though not in the context of vue middleware (I assumed the middleware here is like a "guard" which in React code + react-router would be done via props + Redirect component with render condition based on the prop e.g, `isAuthenticated`). The data configuration I was talking about was the get/post data handlers which now live in a route configuration instead of the component itself which is what uses the data. This is more geared towards stuff like angular 1.x routing and the other routing frameworks u first mentioned not Vue where handlers are actually components. Its only "HTML markup" with JSX its obviously javascript as well. You were arguing that `react-router`doesn't make sense. I was showing you why the idiomatic way is the declarative `Route` component approach (ala Ember.js btw) and React doesn't use an additional "template" view seperation to do rendering ("Templates separate technologies, not concerns"). Not really sure what you are arguing about. Its pretty clear you can do routing either way (declarative or config based approaches) with react-router depending on what your team would decide to do and that these are equivalent models. Your first routing suggestions really do not map to how routing is handled in the modern frameworks. The other routing suggestions do indeed add stuff like data resolution which is now handled in components in the newer frameworks. Hence, why I even commented in the first place bc the new frameworks no longer do that and let the component declared do its thing. Our other disagreement which we agree on but u dont seem to think so is that react-router, angular 2, vuejs have equivalent routing schemes. They don't look identical but they do in fact have the same component model unlike your original suggestions.
I see what you're saying. Because the second example always returns a function regardless of the key you pass it, you're saying it's pure. I still find it an interesting case because it's creating a new instance of the inner function for every call. Passing the same key does not technically yield the same result, but you do end up with a function that accesses the localStorage layer utilizing the key you passed. It's like the conundrum of the transporter in Star Trek. If it breaks you down molecule by molecule, then rebuilds you in a new location, is that technically you or another version of you thats, for all intents and purposes, an exact copy. Hrmmmmm.....
That site has many problems. Not the least of which is trying to load non secure JS files from external domains which Chrome is blocking.
I touched upon this in other comments, [like this one](https://www.reddit.com/r/javascript/comments/66ye3v/why_does_wrapping_an_impure_function_with_a/dgmmo38/). Also, think about how impossible pure functions would be if you would care about strict equality for reference types (objects). Oh you want to use a function callback somewhere in your pure function in order to map over an array? Well then, first define the callback outside of the pure function, and then pass it as a parameter when calling the pure function. Doesn't sound very logical does it? You could also take that thought a step further and look at JS' underlying mechanisms. JS is really very, very object based, such that even the primitive data types which normally pass by value, are technically supported by objects. Try some of these lines: // Regular primitive values console.log(2 === 2); // The underlying data type constructor var x = new Number(2); // The resulting object instance, and how its primitive value is internally managed console.log(x, x.valueOf()); // Not even loosely equal, cuz these are two separate object instances console.log(x == new Number(2)); // Primitive 'magic' - JS doesn't want you meddling with their data types so you just get primitives back // (The operators cause type coercion, which uses the .valueOf() method) console.log(x === 2); console.log(x, x += 2, x); // Oh and there's also these funny types of constructs.. console.log(NaN, Number.NaN, NaN == Number.NaN);
&gt; you must use className instead of class to define the DOM css classes because class is a reserved word in javascript...
You can make [json endpoints for instance](http://stackoverflow.com/questions/41332643/sending-data-to-database-in-react-js-web-application). Before you'd return a HTML blob, now you return JSON, not much of a difference. There are also lots of services that can connect to a database with a client side API and even react to its changes or allow you to create queries and schemas on the client. Firebase, mongoose, graphql, and so on. 
Well, `var x = Object.create(myObj)` is the equivalent to: var x = {}; x.__proto__ = myObj; You can still define some properties to the new object (x) using the second parameter on Object.create, but that's it, the prototype is still going to be myObj. So yeah, you are not going to prevent the assignment without overwriting Object.create (which as you may know, isn't recommended). There's no way to check if your object itself is being accessed this way. By the way, seems like you are trying to solve something....that should not be solved, or should be solved in a complete different way, I'm curious about why you need it
learn 2 engrish plz
Perfectly said. Experienced dev here: Picked up basics on React in a day, React + Redux + Automated Testing and good conventions in about a week.
But Istanbul's html coverage reports are so nice. If it were up to me, I'd always pick Istanbul over NYC. 
Cypress.io is a fantastic new player in e2e testing. Eases the pain of using asking Selenium based. Runs in the same execution thread as your app so debugging tests is an absolute pleasure. 
That part was really strange. When things get complex in Vue or Riot most developers go VueX or more recently Vuedeux, and riot-redux for Riot. All produce similar boilerplate. While Redux in general demands some effort, the codebase is actually made smaller and less complex as components do not meddle with state any longer but merely react to it. 
Yeah, couple of the things in it are a bit off, but it's a good overview. I've definitely never seen E2E tests being referred to as smoke tests myself. Here's something I wrote on the topic of different test types: https://codeutopia.net/blog/2015/04/11/what-are-unit-testing-integration-testing-and-functional-testing/ (if there's any inaccurate bits in that, do let me know and I'll fix it)
There are plenty of courses on Udemy for sale every other week for like $15, one time fee. Some of them have 10-15 hours of content and go from beginner to pretty advanced(like ES6 functions and such..) I'd look there. 
Thank you I will certainly look in to that
For some the act of having a project they can implement, regardless of whether it is language-specific in its implementation, aids with learning. Is this for people who are working professionals learning to upskill their JS? No, but it is a launching point for newbies looking to see if they can understand the language being put in to practice.
That's a missed opportunity on their end, it's a good way to probe the interviewee's Unicode proficiency (but then, maybe they had other ways to test it, or didn't care).
Even though it might be the future, it's not an established solution within the community yet. Though I agree it's atleast mention-worthy.
Does that support testing JSX components too? I'm running a mocha+karma+chai setup at work and it's a PITA to work with, because we must webpack-compile all the test files and run the whole bundle.
Yes. It should support that since the TypeScript compiler support compiling JSX.
&gt; so I get why you end up at the opinions that you do. But not every workplace is that way. Or even most workplaces I have been thinking on this. There are many wonderful software developers in the world, without which most innovations and creativity would not exist. These models of excellence, however, are dwarfed by the vast numbers of developers who simply write code. The ability to write code does not make for excellence as this is merely the baseline of competency. It is unfortunate that the optics have become hopelessly blurred in that these two distinct qualities are so often indistinguishable in the workplace. Nobody should be hired to a professional position merely because they can read even though reading is certainly required. Programming should be no different.
I've created a subreddit to share and teach between players, talk about development, bugs and stuff https://www.reddit.com/r/devlifeWBG/ Thank you all :)
Ok, I decided to rename all occurances of "sanity tests" and isntead call them functional tests. and to remove smoke testing at all. this is much more useful in the scope of an "overview"
Cool :) There's just one other minor thing that caught my eye besides the test type stuff: Unit tests aren't necessarily preferable to run in node. If you need to test client-side JS, it may be valuable to run the tests in browsers (eg. against real DOM since jsdom doesn't implement everything) Otherwise I don't think it had anything particularly inaccurate about it. However if I might suggest one improvement, Mocha at least supports promises directly in tests, so instead of using `done()`, you can directly return a promise, which might be useful to include in the bit where you mentioned promises ([here's also something I wrote on that topic](https://www.sitepoint.com/promises-in-javascript-unit-tests-the-definitive-guide/))
Watch functionality in jest is the best I've ever seen, and snapshot tests make simple component tests so easy and fast to write. Literally all my dumb component tests now are a call to my helper snapshot test function and a few tests to make sure clicking and whatever other events are actually being fired. I have also found jest a lot easier to set up. I've set up quite a few mocha pipelines, and when I recently switch to jest, it took me maybe 10 minutes to get my tests running from 0 knowledge of jest. I definitely think there is room for improvement on a performance front, but frankly I don't write code bases with 1000's of tests; our code is much more modular where I work, so a lot of our components are separate npm modules. 
Logged in just to comment, I'm graduating from community college in 2 weeks with a CIS degree, there is an entire course offered that is just javascript/jquery/css. Final project is to create a commercial website with responsive design. It never occurred to me what a pain it would be to get the green light on running that course. Maybe that's the reason the chair of the department teaches it.
I think it's supposed to be accessed from this page: https://collab.itc.virginia.edu/access/content/group/f85bed6c-45d2-4b18-b868-6a2353586804/2/Ch24_Mullen_A_Cyclooxygenase-_-/index.html You click the links on the left and the slides appear on the right. Heads up though, as the other commenter mentioned, this site is horribly built and downloads an *insane* 45MB before it starts to work, so make sure you're on a fast internet connection, but astonishingly, if you sit and allow it to load for a few minutes, eventually you will see slide 1 on the right and you will be able to click to change them. Hope that helps!
Worth giving a shout out to [jsdom](https://github.com/tmpvar/jsdom), too. For those looking to replace PhantomJS or equivalently clunky headless environments, I've enjoyed using mocha + chai + sinon in jsdom for component-level tests. We've found it to be much faster and more reliable than the headless alternatives, although that might change with headless Chromium on the horizon.
I've been using Semantic-UI-React heavily in my latest projects and it's very very difficult to get it set up without a modern build system. I'd honestly just reccommend learning the NPM module system. Learn off Create-React-App. https://github.com/facebookincubator/create-react-app
That's not a honest rebuttal - you didn't say you are using typescript. Big difference. For JS jest is the best IMHO.
Apples primary business is selling hardware. It obviously has other business but it's nothing compared to their hardware business. So if there are fast user friendly platforms where they can excel the hardware, the App Store, they are all for it. Meanwhile Google's primary business is selling ads and data. So obviously ad free apps don't help with their business. 
[Trevor McCauley](https://github.com/senocular) has corrected the composition example.
Well the downside of that would be like with any framework (I would call tape a library and jest a framework here, hope you don't mind), that you'll have quite a bit of start-up time. You'll have to spend some time getting used to the tools, compared to tape, where you basically require('tape') and learn two method calls. Then you can just write your code as you want it. I'm a bit intrigued though. Will make sure to put jest on the "stuff to try"-list
You can check out wesbos.com for some free courses on a range of things. His paid ones are worth it too. Wes is great. 
That is how I would approach it as well. You will _never_ be able to teach someone JS/React in 2hrs but you can show them `MDN` or a few other nuggets of truth so they can quickly become unblocked.
I wrote it at first but looks like a simple require can make jasmine for example support it too so it's kinda unfair to consider it as a real advantage: https://github.com/matthewjh/jasmine-promises
I've always wondered how Meteor rates as a tool for more complex applications like SASS platforms. Can you connect it to a relational data source (like a SQL dbms)? Can you enforce complex ACLs against your API? Can you build a RESTFUL API that outside entities could integrate with?
Do you ever find writing unit tests or TS integration / extra build steps to be dreadful? With react / redux and it's unidirectional flow, I already find data very easy to reason with and know exactly what props should be passed into each component. I'm trying to convince myself to bite the bullet and incorporate TS and unit tests into my project, but the former just feels like overhead and the latter not very DRY.
Meteor can connect to PostgreSQL. I am not familiar with the ACLs question. Meteor can create a RESTful API using the `restivus` package, but Meteor really wants to use DDP to communcate between the Meteor server and a Meteor client.
Yeah I know, but if there's that 1% chance that is going to cause trouble in the future, it's worth changing
We use Koa. Works great. Total control.
Just leaving an update, where we've reached 1.0.0! * Library actually compiles correctly now * Indices and values are coherent now * There's a faster way to access the global context from inside a foreach loop
Thanks a lot, I'm glad you two like it! (I'm one of the co-founders). There are a bunch of benefits with Scrimba over traditional video (easier to create, editable, light weight, indexable, responsive). We hope to grow it into a central hub for teaching and learning web dev online.
Meteor is huge and clunky therefore destined to die early, as some parts of it will probably grow outdated. But it's cool.
I searched for a little library that gives me the content of a directory and that can format it nicely but I couldn't find something that I liked, so I created [dir-tree](https://github.com/nemoxps/dir-tree). Maybe some souls find it helpful.
Koa is not exactly thriving, either. Looking at the github commit activity, it doesn't seem to be that lively. And express looks completely dead, almost no commits for two years. Server-side JS seems to be in a limbo.
&gt; these last 2 years (including me) now stopped using javascript frameworks. I came to the conclusion that once you know a little better the jungle that is the JS ecosystem, it's better to roll your own set of librairies for you projects (including big ones). Interesting view, but I'm not sure, whether this is more or less due to the success of libraries like React and some special purpose libraries like RxJS. I'm not sure, whether e.g. Angular2/4 is already *dead*, because if you used this or a similar framework for a working product you won't switch to a different environment too easily.
Koa is meant to be an extremely slim layer over `http`, so there isn't really anything much to add to it. The rest of the stuff just comes from middleware authors. Same thing for Express – GitHub activity isn't really an indicator of how well a framework is doing. Express still has crazy amounts of usage.
Second that! Koa is an amazing little piece of technology. So simple and completely pluggable. It's even more awesome with the recent native support for async/await.
Do you want your overlayed images saved as such on your disk or should it just be in the browser? If it's just in the browser, then you can create 100 divs, each with your image as the background. In each div you can then insert the other image, with position: absolute and then position them with top and left. Make sure your div has position: relative.
just to display in the browser, if you can imaging there will be this picture of the parking lot (http://imgur.com/QTvFvry). in real time our application will be analyzing this lot and placing a red spot (http://imgur.com/smDp91m) or a green spot (http://imgur.com/btiXlhe) to tell the user (web application) if the spot is unavailable or available respectively. I plan on using a for loop to change color of the spots, but right now I am just having trouble placing the colored spots on top of the parking lot image with the desired coordinates.
At our place, we migrated our tests from jest to mocha and got our 900 or so tests to rerun in 4s instead of 30s. The parallelism performance gain is a lie. There's a lot of overhead to run tests in parallel and doing so makes performance worse (provided your modules are small and properly mocked). 
https://codesandbox.io/s/460zq4Ok To set this up locally would be a matter of seconds, but that relies on modern build tools (node, npm and webpack), without which i would not recommend using Javascript, as you'll be cut off from everything that is going on. Where ever you will go, it is assumed that you have a basic understanding of what npm is: a module repository. Every module assumes you know what bundling is. If they still offer script tags (which many packages do not) it is for legacy only and that is quickly waning. Your foot into the door is [node](https://nodejs.org/en/), which you may want to install. Open your terminal and type `npm`, you use it to set up projects and fetch dependencies. It makes sense to [learn webpack](https://webpack.js.org/) next. 
Making react work without a modern build system is a bit of a sisyphean task, but it can be done. If this is really what you want I could help you with this. However, if you're interested in react (or interested in making web apps in general) I would highly recommend getting some sort of build system. Some of them, like Facebook's own [create-react-app](https://github.com/facebookincubator/create-react-app), are made to be easy to get started with. I could assist with that as well if you're interested. If, however, all that you really want is a nice looking button in good old HTML + CSS + JavaScript, there is a much easier way. Semantic UI is not originally for react, it's just some CSS and a few small scripts on the side of you want it. Go to Semantic's [getting started](https://semantic-ui.com/introduction/getting-started.html) page, follow the steps under "simpler setup", include the CSS on your page and you're good to go. A primary button like in your example would just be the HTML &lt;button class="ui primary button"&gt;Primary&lt;/button&gt; All the components on their main site should be well documented for this use case.
Server-side JS is more stable, leading to less commits. Notice that node itself hasn't been seeing as many or as in-depth changes as well?
No need to. Already got my coverage.
It has a timeline UI? Because I've used Greensock in another part of my app. Can you please link to it? I've done a lot of searching and I haven't come across a UI from them. Thanks
You're welcome! :) And thanks for the gold!
Flowtype for express+mongoose application.
Yes, it's dying.
yes, it's dead.. new game in town is webpack with all its modules, however if you able to produce projects that work with modern tech then why change your env? I still use Sublime2 when it's been dead for a while
You still need something like Koa or Express to handle requests...
wish i could give more! have a great day!!!
a lot of death in this javascript post
Express + SocketIO, it's always worked great for me.
I use Meteor daily for a very large web app. It's great, I still love using it.
I seriously hate articles like this and this war between every library/framework, every library has it quirks, we should be happy that developers build those libraries and we can use the one which suits our coding style/preferences. Regarding React, It seems for most people that redux/mobx and react-router are embedded into react library. React is just a view library, need state ? use setState, need routing ? use native history API, or choose from other router libraries that are created, who share similarities to vue/angular/you name it routers. 
Non-Mobile link: https://en.wikipedia.org/wiki/Not_invented_here *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^59956
Just wanted to say that I'm still using meteor regularly for both current and new projects. It is a really nice framework. No plans of switching to something else any time soon.
What? I'm just saying that it seems like the people who complain about difficulties with React the most, are those who have experience with older / different technologies. Compared to many junior devs who pick it up quickly since it's the only experience they have and because React is simple. I'm not a vue lover, but I also think it's relatively simple and I'm glad its becoming popular. 
I always saw Meteor as a cool tech demo. Since it controlled the complete end-to-end stack, it could give you some slick features straight out of the box and you could stand up a pretty elaborate prototype really quickly. Frankly that's where I always saw the value in it. I don't know if it was ever seriously being considered as a production-grade framework, or if that was even one of its goals...
i got the finished code thanks again!
That's also what Jest uses by default (which you probably want to change if you're using Jest for backend tests).
Any plans on licensing your tech? That feels like a bigger play than being another edtech platform.
i have the array as a JSON file right now, and am currently looking up how to import said file as variable x
Awesome! I think this is what I needed. I figured that the includes function just wasn't supported or something. I will give that a shot 
I tested MeteorJS with Angular and was really more powerful that my ExpressJS style action... But with all these frameworks keeping pumping probably I'll not be addicted to one.
If your have a file .json your need to load the file with a http request. With jQuery: http://api.jquery.com/jquery.getjson/
PM2 is probably what you want http://pm2.keymetrics.io/ Can run multiple clustered apps
1. Why are you loading all 11M rows into memory? 2. Is there anything common about the 30K requests that could be used to cache the responses to the requests?
I just read about the canvas and I can't use it because my code is going to be used within tumult hype, and I need a JavaScript code that will work within the program. Also I am not drawing anything this is for a top down shooter.
 &lt;script&gt; var x = /* print here the json string */; document.addEventListener("DOMContentLoaded", function(event){ x.forEach(function(val,i){ if(val) document.querySelector('.spot-'+(i+1)).classList.add('green'); }); }); &lt;/script&gt; Make a dynamic html file with https://www.npmjs.com/package/pug
JSON is the format.
No! I don't want what I'm learning to be on the hype train.
Let's back all the way up. What does this server do, and why does it get 30K calls per second? What is your SLA (e.g. max response time for a request)? It sounds like you're trying to map IP addresses to city names. There are probably much simpler methods of doing that than what you have described so far.
wow thanks for the clean up! not sure how to make a dynamic but ill work on that tomorrow, I am very new to javascript. back to importing that json string though, it will be on a local file so I am still confused on how to print the json string to var x. Lets say array.json is in the same file location as the javascript code
It's a server in the real time ad server bidding space. The max response time should be under 50 ms. We get the ip address of each call, and we have to query redis to map the ip to a city. But since there's 11 million rows of ip ranges, we would like to load all the data into memory. It will be a simple key-value lookup if we do that. Otherwise, for every single call we would need to make an additional round trip by calling redis each time.
I'm not familiar with the software you're using, but I'm assuming you're using Javascript. If you want to make a game you need to use canvas. I think your idea of canvas is wrong, read [this MDN page](https://developer.mozilla.org/en-US/docs/Glossary/Canvas). You may also want to use a library like Phaser to help out. 
Use the HTML5 canvas, draw the image of the parking lot onto it, then use the arc() function to make a circle where you want. Assume that you want to place a 2px radius dot at (100, 100). var ctx = yourCanvasElement.getContext("2d"); ctx.drawImage(yourImageElement, 0, 0); /* make sure canvas and image are the same size before you do this */ function placeSpot(x, y, z) { var color = (z ? "#FF0000" : "#0000FF"); /* red if z=true, green if z=false */ ctx.fillStyle = color; ctx.arc(x, y, 2, Math.PI*2); /* Math.PI*2=360degrees in radians */ ctx.fill(); } You would then call it with: placeSpot(100, 100, true); Tell me if there are any issues, this code is untested and you might need to call ctx.beginPath and ctx.closePath. I forget. 
keep just the X most recently used, or fetch in db. I think that is not suitable...
For me it's mostly just that I can easily replicate all of the Meteor stack that I care about with NextJS (by Zeit), and keep all my flexibility. 
If my math is right, you need at least 536MB of memory to store just the IP addresses. That doesn't include the city names. Have you profiled the performance of MySQL, PostgreSQL, DynamoDB, or a more powerful Redis cluster? Also, consider moving past Node.js. It's clearly a bottleneck. I mostly use Python; however, compiled languages (e.g. C++, Go, or Java) should yield better performance.
Could you pls paste the complete code here? That would be greatly helpful.
Express died the day TJ [sold the github project](https://hueniverse.com/open-source-dickishness-629d1497e3aa).
Thank you and all others' advice. I will starting learning some "modern JavaScript concepts", such as the build system. The create-react-app page seems good reading, I will try it.
&gt; all that you really want is a nice looking button No. I took Button as the example. What I want to do is a single page application, React + Semantic will fit my needs very well.
well deserved! thanks for you help :)
The problem is I cannot insert html canvas into the program, there is only a slot for JavaScript and menus for me to apply the java script to the proper objects. I know it can be done without canvas.
I have at least 4,050 mb of memory in each container instance. So that should be enough.
Try calling jquery as a function jquery()
That worked! Thanks man. &gt; (only do this if you trust the source of the eval'ed code) You mean from injection? It will obviously fail if the format is incorrect. 
Yes. Even though JavaScript has a new version coming out every year the fundamentals stay pretty much the same.
There's no particular requirement to use SSR in React, by default it is CSR. The React way of coding shouldn't touch the (virtual or actual) DOM directly very much if at all. Prefer conditional rendering based on your app's state. 
I don't know much about Meteor, but if you are new to web development, you ought to be more concerned with having something that just works. Long long before you worry about "does it scale." I see so many people ask this and amble from one stack to another and they haven't even built anything in the first place to even think about scaling. 
&gt; basically creating your own query language for an app that could compile to a graph ql backend or even a solr style backend without ever changing the component data needs Pretty much; our approach has been largely inspired by how configuration driven our app is (think multi-tenant app where every bit of text/label/placeholder is configurable on multiple levels). We needed a portable approach to interpreting the data the client needs. Wanting to stick to existing standards/convention, we ended up deciding to model our API after [JSON schema spec](http://json-schema.org/) which allows us to do do some pretty cool validation using [ajv](https://github.com/epoberezkin/ajv). While I like Flow/Typescript, the don't lend themselves well to highly dynamic data. Since the layout/render also depends a lot on the schema and/or configuration, we have two schemas one `schema` that describes the data, the other `layout` which defines the containers/components and their bindings to the state. We basically have one default fetch/change reducer (as middleware) that handles most interaction/events (dispatched from our dynamic field component) such that the actions/reducers we write can focus on business logic. Sorry for rambling, this stuff just gets me excited :) &gt; Anyway sounds like you work at a good front end shop you are one of the lucky few. Thanks! We're hiring ;)
Ha, meteor itself is a case of not invented here syndrome. * Blaze was created instead of any actually supported ui alternative * Has to use fibers on the server instead of promises or async.js or anything else * Atmosphere package manager! Let's make a better npm * let's make our es6 support only work via a custom babel plugin we've built! And of course once they tried to retcon most of these decisions they made all of their library developers go through quite a bit of double effort. Telling anyone who doesn't want to deal with all this crap that they're reinventing the wheel is ridiculous. No one is even suggesting that by the way. They're suggesting building an alternative via mostly interchangeable blocks rather than what has been shown to be an insane monolith.
Yes and no. It was great because it establish best practices around writing readable code. Crockford has always preferred code that is understandable over code that is terse. When there are two ways to do something, Crockford picks the one with the fewest foot guns. Once you understand that principle, then reading 200+ pages isn't needed. Honestly, if you want the same feel, watch his lectures on the Good Parts, then watch the update that came out a few weeks ago with ES6 specific things.
Clever. Yeah, we do some generation based on our schemas, but it's not a very sophisticated approach. Sure.
Here are a few of my favorites: array.filter(Boolean); // remove falsey values from arrays, like null and undefined array.reduce((sum, num) =&gt; sum + num, 0); // sum of array of numbers Object.values = (obj) =&gt; Object.keys(obj).map(key =&gt; obj[key]); // Object.values polyfill await new Promise(r =&gt; setTimeout(r, 1000)); // Sleep an async function for a second await Promise.race([doWork(), new Promise(r =&gt; setTimeout(r, 1000))]); // Wait for up to a second for work to be done Bonus: (not a one liner, but great for testing async in the console) (async () =&gt; { await doWork(); await moreWork(); })().then(console.log, console.error);
The original post is from 3 years ago... it still shows `comprehensions` which were dropped. This won't work: [ for (value of ["Harriet", "178"]) value ].join(" was "); But the rest are nice and I use similar things a lot.
I'm only coming to this realization now but I can't use sockets to detect changes in an external API, can I? 
Yes, it's still a great book. I'd also recommend the You Don't Know JS series by Kyle Simpson - they have more up to date content.
Yes. But if you use typescript, tslint and something like lodash it enforces correct style on you for many things.
Does anyone else prefer Array.from rather than destructuring when converting a NodeList to Array? Edit: Also, I think is actually a "spread" operator wrapped in an array literal in this situation, so it's not even destructuring. I guess that's why I don't use it, confusing.
Your first point is what scared me away from it. The lack of interchangeability makes Meteor a dangerous bet when building Enterprise grade apps.
yeah exactly. as long as your aren't exposed to a code injection given it's an 'eval' (not one of the 'good parts'!)
&gt; It's rough to learn... I don't understand why people say `js` is so hard to learn. I've found haskell, erlang etc hard to learn (I haven't been successful as of yet) but js is far more straightforward and pretty "easy" to learn.
It does no such thing as "incorporating many of the book's teachings". It simply adds features. Yes, there's arrow functions, but there's also generators and classes. Those are clearly not incorporating anything from The Good Parts. The strength of The Good Parts is that it shows you how to make the most of the best JS features. And as it turns out ES6 didn't add many in that department.
I'm seeing a lot of paid lectures of him on pluralsight / similar. Mind linking the ones you're referring to? 
Comprehensions were nice, but you can achieve the same thing using generator functions and the spread operator. Although the given example is contrived and pointless, since you get the same result with ["Harriet", "178"].join(" was "); A better example would be: function* counter(n) { for (let i = 0; i &lt; n; i++) { yield i; } } [...counter(10)].join(" "); // "0 1 2 3 4 5 6 7 8 9"
Maybe you've gone over a bad tutorial? If you're coming from Angular and you think React is hard, something is very off. I'd try it with the official pages or a quality course like [Eggheads](https://egghead.io/courses/react-fundamentals). React is a simple viewlayer with a tiny API surface, there isn't that much to learn. Although a thing people tend to do is learning everything at once. If i was you i wouldn't touch server rendering, redux, routers and all that stuff until i'm fluid with plain React. That takes about an hour. 
This comment sounds like you haven't used Meteor. Meteor is way easier than express, especially for real-time apps. For context, I've used Meteor quite a lot – but now I use express. I have plenty of reasons but ease-of-use is certainly not one. I do miss the easiness of Meteor (but not much else).
Did not use Meteor, but currently I am building my real-time webapp with Feathers.js
A million times no. I don't think it is a good book for beginners. The primary reason this is not a good book is that it is too terse and doesn't have enough examples, although javascript has also moved on somewhat. Are you a beginner programmer or a beginner to javascript ? That is an important distinction and will help people recommend a better book. If you already know programming try something like Eloquent javascript and some online tutorials. Don't waste too much time reading books, just get started on projects, you will learn much quicker. On the other hand if you are new to programming that is more tricky and I can't think of any books off the top of my head.
Sure, would love to see some examples!
na
Polymer + Firebase is popular nowdays.
No. It's not a good book for beginners. Read 'You Don't Know JS' series if you want to learn javascript but don't expect to read it in only 1 day. You won't learn js with that 100 quick pages boook (can be easy read in only one day) which is more like an Author's opinion of which are the good js parts (from his side). 
Which Application server/database do I use?
Short answer: variables are not properties. When you write 'parrot.weight = 17' you are creating a new property on the parrot instance of your Bird.
No. "JavaScript: The Good Parts" is not a book for beginners. It requires to understand a bit more than basics to understand this book. As lots of guys mentioned here — "You don't know JS" by Kyle Simpson is much better choice for JS starters. At some point it is worth to give it a read as the mechanism of language didn't change at all since this book has been written. We got few syntax sugars like class that simplifies syntax but doesn't change the concept at all. Another thing that you need to be aware of — it is written by Douglas Crockford — the grumpy papa of JS world. He is very opinionated about things and the language that he uses in this book is very subjective. Just a quick warning before reading this book. 1. "You don't know JS" 2. 1000 projects... 3. Good parts — maybe...
Reading books about software is not a waste of time. Sure, real projects and practice is important. But you will learn how more experienced programmers think, if you read some books. (Edit: Sorry in advance if I misinterpreted your comment.)
Thanks. After following the instruction of create-react-app, I have my test app running now with React Semantic UI enabled. That's really cool. And I like how import/export/module/class works in ES6.
You're exactly right. In fact I'd say Meteor came about one year too early. If it were built from the ground up now, it'd probably be a pluggable collection of established libraries, react/blaze, npm, mongo, babel etc. All centred around DDP, which is a proper bit of innovation and hopefully will survive on its own outside the Meteor framework. 
Credit to Eric Eliott const pipe = (...fns) =&gt; x =&gt; fns.reduce((v, f) =&gt; f(v), x); And an example I've made using it https://jsfiddle.net/96ymh5ea/1/
Firebase isn't for every case. Unless things have changed it needs to connect at startup. Where I like PouchDB as it can start offline and replicate later.
Could be - I never used it - I still prefer python+postgresql for my backend needs.
I see it as a frontend use-case, "local storage", SPAs, mobile app wrappers and that kinda thing. That's where Firebase and Meteor messy the waters a little by locking to a propriety backend. Enabling frontend by selling backend. Rather than simply being a frontend engine and being great at that job regardless of monitisation. 
The middle one seems like the best to me. What's the advantage of await?
Await allows you to write async code like it is synchronous. It's basically sugar for promises. It's only a matter of preference as far as I know. EDIT: Not really, see replies to this comment.
You can also await non-promise values, which makes it transparent when a function returns a promise or a non-promise.
The fact that the timeframe of the "architectural decisions" greatly affects the way you have to do things ( in a now non standard way for many things ) is precisely what I'm complaining about. No one ever says 'if only they had written node's fs module at a different time or updated it for modern time, it would be great!' Read this https://staltz.com/libraries-shouldnt-support-everything.html it cuts deep when you try to justify using a framework like meteor. Use meteor for efficiency all you want--it's no different to me than hearing someone uses a boilerplate they found on GitHub efficiently, except you're on mdg's wild ride and they aren't :)
Yep, it's still very much a thing. Since you are a front-end dev, do you already have experience with Angular? If not, you may want to substitute React as it's the dominate front-end framework these days (MERN). Also, there is a lot of hate for Mongo so don't feel like you are bound to that either. If you are just getting into back-end development, learning Node, Express, and Mongo at the same time can be overwhelming, IMHO. If you happen to have experience with a more traditional relational database such as Postgres or MySQL I'd recommend you stick with that for now. For what it's worth, my stack is primarily MySQL, Express, React, Node. 
React is not dominant by any stretch. Angularjs is still orders of magnitudes larger. React supporters are just very vocal.
Just to add to this - may help someone in the future referencing this post. Function expressions are not hoisted, heres a good example; https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function#Function_declaration_hoisting
I'd watch his video series on Yahoo once you have a little experience. It's long, like maybe 8 hours - but it's crazy interesting / informative
No kidding, that's fucking cool. Hope this site takes off but at the very least I can totally see something like Code School buying them out.
Are you a beginning programmer, or just new to JavaScript? If you are an experienced programmer who wants to know the quirks that make JS JS, it is a great book. If you want to teach yourself programming, hold off for now. It assumes that you understand basic control flow, functions, "traditional" OOP, etc.
Unless the value you're expecting is the promise at the start of a chain. If you're inside a promise chain, it doesn't matter if the return value of a step in the chain is a promise or non-promise. I.e. this extremely contrived example will _always_ work. function getFive() { if (Math.random() &gt; 0.5) { return new Promise(r =&gt; setTimeout(() =&gt; r(5), Math.random() * 5e3)); } return 5; } async function consumeFive() { const five = await getFive(); return five; } consumeFive().then(five =&gt; console.log('five = %s', five)); Something a little less contrived might be a cache from which you can read synchronously for a cache hit, but in case of a cache miss you'll revert to the network and return a promise instead.
That race one is clever 
Full stack is a pipe dream, there is no way you can get depth with both frontend and backend. Remember the *mongodb apocalypse* from a few months ago? That is what you get for letting people do full stack.
Can you recommend an Express + SocketIO + React + Webpack boilerplate?
Here's how I would do it. Rather than have most of the function's code in an if statement, you can just return early if token is not defined. I think it's easier to read that way. Your code feels very crammed together too (obviously very subjective). So I put in some vertical whitespace. I also put ".then" and ".catch" on their own indented lines, so it's easy to find both handlers. The option passed to findById - can this be encapsulated inside the User model? Why is this object being defined in this module? There's nothing specific to this module as far as I can see (although I don't know the wider context of the code). Defining it somewhere else would make it (a) reusable and (b) cut down on the amount of lines of code in this module. const User = app.model('user'); const Helpers = app.model('helpers'); const Encryption = app.model('encryption'); exports.verifyAuthToken = (req, res, next) =&gt; { const token = req.signedCookies['session']; if (!token) { return next(); } const decrypted = JSON.parse(Encryption.decrypt(token)); // findByIdXXX calls User.findById(session, options) // obviously you would give this a better name User.findByIdXXX(decrypted.session) .then((user) =&gt; { req.authedUser = user; Helpers.updateSessionCookie(res, user.id); next(); }) .catch(() =&gt; { res.failure('invalid_auth_token'); }); }; 
I agree. Both books are good.
I agree with this too. Crockford is not the be all end all.
Which is why you should always filter on an explicit predicate even thought it's annoying. I'm certainly guilty of this, but just because 0 isn't meaningful in the use-case now,... What a pernicious bug that would be to track down.
Try using the result of the first step into the fifth one. You'll see that you'll prefer async/await ;) (async() =&gt; { try { const a = await getData(); const b = await getMoreData(a); const c = await getMoreData(b); const d = await getMoreData(c); const f = await getFinalData(a, d); return f; } catch (error) { // stuff } })(); Async/await is much cleaner when dealing with shared context between the different steps. Creds to : https://twitter.com/scastiel/status/855890956528349184 and https://twitter.com/GromNaN/status/855879347076464641
&gt; (async () =&gt; { await doWork(); await moreWork(); })().then(console.log, console.error); People might disagree but I find the optional 2nd position error callback in `.then` to be smelly. 
Unbelievable how many people don't understand this. At some point there's nothing left to add and very few bugs to fix. That's by all metrics an example of a stable, successful project. When Node introduces breaking changes and your favorite framework shows no attempts to keep up, then by all means, call it a dead project.
Been applying for jobs the last few days haha, this was one of many last straws. 
You can spread any iterable - arrays, strings, maps, sets. If you can use `for..of` on it, you can spread it. 
`Array#map` is actually ES5, along with reduce, filter, and even [every](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every) &amp; [some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some). Makes it even safer to use! Unlike object spread, careful with that one since it's actually not in the spec yet, probably ES2018.
Yes I know. Notice though I'm not doing that. The window id is actually different. The window id is the name of the div wrapping the canvas element. When there is no chart, that returns as a HTMLDivElement. Once the chat is created and its instance is attached to the name of the div wrapper, the name of the div wrapper's constructor changes to that of a chart.js instance. Anyway, maybe I'm misunderstanding something but I don't really see how I'm not doing what you suggested already. There is a high chance I am just not understanding you and an even higher chance I've probably given you a shitty explanation of how this all works because I'm thousands of lines of code and 100 files and tons of libraries and technologies deep into this project and I've probably forgotten how/why I did some stuff, lol
"letting people". I think that is an extremely narrow minded thing to say. Who's to stop letting people explore and learn? Certainly not you. I'm not gonna say that *mongodb apocalypse* is not a serious issue, but you'll find security incidents with almost any popular and widespread tech.
From what I've seen the industry has really backed off mongo after being momentarily excited about it. There are a lot of articles on why you shouldn't use it for 95-99% of use cases, here's a few. TLDR most people have relational data, so should use a relational database. http://cryto.net/~joepie91/blog/2015/07/19/why-you-should-never-ever-ever-use-mongodb/ http://www.sarahmei.com/blog/2013/11/11/why-you-should-never-use-mongodb/ Mysql, postgresql, sqlite are all great options for most sites/apps. I think you'll get a lot more mileage out of relational SQL skills.
I'm not claiming it to be anything other than difference in syntax. There are cases where I prefer the chain syntax (when I need to catch) and others where I prefer async/await (most other cases, but not all). It does allow you to express things in ways the `.then` syntax doesn't, e.g. async function beep() { return { boop: await bzzt() }; } I also like tacit (or point-free) style, which means I use `compose` a lot. For that purpose I have a `chain` helper which in all its glory is const chain = curry(async (f, x) =&gt; f(await x)); It's not much longer without async/await, but I like this form much better. Long story short, while you may not gain new functionality per se, it is wonderful syntax sugar which enables more ways to express asynchronous patterns.
Well said, I concur :)
You've helped already. Your response will come in handy in the future :-)
thanks, i was trying for 3(x)^2 or (3x)^2
It failed to cover everything on most websites such as cnbc.com. Can you make it covers more background types? It works on some sites and not on others. It needs more fine tuning. Thanks
Is the API in your hands, can you alter it? If so it shouldn't be a problem otherwise I'd say your assessment is sadly correct.
Use a unique name for WHAT? What the actual fuck are you even talking about? "Clobbering the div"? Wtf does that even mean. Anyway it doesn't matter. Not gonna get in an internet argument over javascript lol...I'll figure it out. edit: FWIW the issue is that my version of safari was out of date and .includes() support was not available. I updated safari and now it works fine. 
In firefox use Inspect element(I use FireBug) and paste that code in the command line and the stuff mentioned by @mdragon will be returned 
Not really. For example, how do you exit [a chain of promises in the middle](https://medium.com/@benlesh/promise-cancellation-is-dead-long-live-promise-cancellation-c6601f1f5082)? There is no API to do that. [There was a proposal](https://github.com/tc39/proposal-cancelable-promises) but it was canceled (pun intended). With async/await you could simply `return` and be done with it. With promises you have to find an ugly way like throwing an error which is confusing since your `catch()` code should only handle errors. Or you could write a bunch of [confusing nested code with conditionals](http://stackoverflow.com/a/28832276/816478). Also [see this aberration](http://stackoverflow.com/a/41085581/816478). Bluebird solved this problem with [a cancellation API](http://bluebirdjs.com/docs/api/cancellation.html) but it's not standard.
Oh wow that's really cool. Thanks for telling me. 
Can this ever refer to non property things?
One of the rare instances in my experience where `setTimeout` is actually being used to set a timeout. ;-)
&gt; array.reduce((sum, num) =&gt; sum + num, 0); // sum of array of numbers You even can even sometimes omit the initial value if the array is guaranteed to be non-empty. 
+1 Insightful
That's a good point some people miss until they start doing a lot of work with promises.
I think it already depended on the platform. For example, in IE at least, if you call alert("something"); Other functions can run in the background.
&gt; I think it already depended on the platform. No. &gt; if you call alert("something"); That has nothing at all to do with functions and anything I said.
Rather than work and parse strings, just insert the html into your dom and work with that. I provided a codepen https://codepen.io/anon/pen/mmrXbd It takes your textarea value and saves it as HAM. It then creates a hidden div and inserts the textarea value into the div. Now, we can loop through each child element of our hidden div, determine if it has a SRC or HREF, and append your tracking URL. View your console in order to see the finished string.
Or you can use Rx and have a clean functional approach.
codeschool.com is great. They're good at skipping fluff and teaching best practices. I use it to onboard new grads. If I were you, I'd go through a little more overhead and make sure I start with ES6 and try using React if you want a GUI. ES stands for ecmascript (I don't remember what that is though haha). es5, es6, es7, etc. are all 'versions' of javascript - es7 means its the spec for 2017. Every subsequent version of javascript can "trans-pile" into a previous version of javascript - enabling new code techniques/sugar and making long term support much easier. babel is the go-to transpiler. Books-wise, I can't not recommend Javascript: The Good Parts. Big part of JS history though probably dated by now.
&gt; I'm still finding a lot of resources for Angular and many devs I know are getting into it. Sure. Angular has just become a framework for enterprise problems and solutions.
I have a question. Seeing a large mix of "yes" and "no" responses, but the "no" responses seem to suggest it is not a good book for beginners. I am currently in an immersive, in-person 12-week JS course to get started, so I have face-to-face instruction, homework assignments and exercises already in place to practice. Would this book be a good PDF to have lying around for reference, or to maybe get another point-of-view on concepts I find challenging? Thanks! 
I use spread if I need to create a new array with multiple items, like `[...arr, someItem]` over `arr.concat([someItem])`, but otherwise I prefer `Array.from`. Also nitpick, but "..." isn't an operator, so "spread operator" isn't right. It's just "spread syntax" inside an array literal, or spread syntax inside a function call. Operators specifically take arguments and produce a value, like `+` and `in` and such.
&gt; Thus, you end up moving away from the one-size-fits-all approach, even though it makes things go much faster in the short-term. We know (at least by hearsay) that from Spring or Rails (but the situation is probably different in the C/C++ world). I'd just like to see the complexity of this problem. Privately you have all options for example, but most companies have to work with a developer team, which provides only certain knowledges and abilities. So you won't introduce a new technique every little while (to exaggerate a bit).
You are not talking about functions. Look at your example. the INSIDE of `alert()`is atomic. Can you change its internal state while the window is open? Is that system function accessible so that you can have your own code inside of it? No and no. It's not even a Javascript function, it's a native system function that you get to call from Javascript.
Yeah if theres two things the promise spec lacks its better error handling and a stack/history of chained promises and their results.
Each situation presents a unique problem. While there may be congruence between instances where this occurs, the specific result or cause will vary wildly. Even if, start to finish, an application is developed for a company to specification, there's nothing saying they won't have to pivot and expand it outside of that scope in the future. What I've been seeing lately are technologies based in constrained ecosystems that are unable to keep up with time. After the third or fourth year, the underlying platform has evolved greatly, but the application itself was never meant to follow that path. 
Ah...good comparison. I didn't even think about it like that. And this is just the object itself that it's in the scope of. Makes a lot more sense! I still have a lot to learn haha, but at least im asking questions I suppose.
o ok
&gt; Note that the code snippets in this article have been tested in the latest Google Chrome version 30 Thank you for sharing a current article.
I have a feeling they always pushed Mongo because it was less of a hurdle than learning Postgres. Unfortunately, it stuck.
ooooooooooooh!!!!!! 
I think developers should at least have an understanding of the stack in order to communicate. Outside of that, I'm generally negative on generalists. While there are a few amazing rockstars out there that can do full-stack development the vast majority of people who claim to be full-stack usually are good at one part of the stack and lacklustre to horrible with the rest of the stack. I feel like web development is one of the few places where we think specialisation is a bad idea (because someone threw out a Heinlein quote once and it caught on.) I think the other challenge is that teams very often don't hold their team members accountable when those individuals take on work that's outside their expertise or when they fail miserably at the work. They just keep moving on because of that "full-stack" job description and the hate on specialisation. 
The definition of `map()` is unnecessary since `Array.map()` is already in ES6. So `mapPrice` can be rewritten as: const mapPrice = collection =&gt; collection.map(getPrice);
because the functions are actually asynchronous https://jsfiddle.net/m4nq3t8s/
Wait, what?
Gotcha covered. I keep a big list of links to high-quality tutorials and articles on React, Redux, and related topics, at https://github.com/markerikson/react-redux-links . Specifically intended to be a great starting point for anyone trying to learn the ecosystem, as well as a solid source of good info on more advanced topics. In particular, you'd be interested in the sections on [Project Structure](https://github.com/markerikson/react-redux-links/blob/master/project-structure.md), [React Architecture](https://github.com/markerikson/react-redux-links/blob/master/react-architecture.md), [React Component Patterns](https://github.com/markerikson/react-redux-links/blob/master/react-component-patterns.md), [Redux Architecture](https://github.com/markerikson/react-redux-links/blob/master/redux-architecture.md), and [Redux Techniques](https://github.com/markerikson/react-redux-links/blob/master/redux-techniques.md).
The first scenario is a common example of callback hell/pyramid of doom. To solve this common problem, there is the second and third scenario. The second scenario solves it by using promises. The third scenario transforms the code using async/await.
Please note that this is not valid in ES Modules, only in Script parsing : https://tc39.github.io/ecma262/#sec-html-like-comments
What the fuck are they smoking at ECMA TC39? Still no proper numeric type, but weird-ass comment syntax. Gee, thanks, that's a big help…
Yeah because documenting with a formal specification that which is required to run code on the internet is a horrible idea that benefits no one! /s
I think this is something they kept from way back in the olden days when a browser might not interpret a &lt;script&gt; element properly.
It's not the documentation that's the problem, it's that they decided to add this syntax to the spec, so all parsers now need to support it, adding complexity for (apparently) no good reason.
Yep. Fundamentally, like the rest of Annex B, this is merely formally documenting semantics required for a script engine to implement in order to run code that exists in the wild in droves. If we didn't spend time on this it wouldn't be possible to implement ECMA262 and also run JS code on the web. That would be... very bad.
Ugh, yeah, I guess that makes a some sort of sense. Making code written in 1997 still work, yay I guess.
Cancelling a promise is useless without cancelling the underlying asynchronous operation - and how that is done depends on the actual operation. Which is a different one each time. It may be an HTTP request, it may be file read access - it may be file write access.. and what happens if you were to let the Javascript runtime cancel such a thing? Data corruption seems a likely outcome, eventually! Nearly untraceable of course, because the issue is highly time- and context-dependent, try to debug this. No, only the application itself knows how to cancel its operations, so if you want to cancel a promise what you actually mean is cancel whatever the application does in that asynchronous operation. Just removing the promise from memory and maybe even tell the operating system to abort any asynchronous operations that the promises's code started would be really bad. When you get this far you find that since promise cancellation is actually a misnomer, it's "asynchronous operation cancel", you find that the ball actually is fully in the application's court! It has to have all the code to deal with cancellations of its async. operations. But if it does, what's the problem with promises? As soon as the app cancels its own asynchronous operations the async. code is ready to return a result through the promise anyway! For example, your asynchronous function to write a sequence of files (that belong to the same transaction) is canceled. It cleans up after itself, deleting the already written files, or closing files open for writing, whatever. Now it can return a resolve() or a reject() result. And it has to do *everything* of that in any case, you can't just pull the promise from under its feet and just stop the code blindly.
Sure, it'll be a non-zero amount of web sites, most of them written in the nineties, but large parts of the web? Hardly. Haven't seen that syntax anywhere in ages.
Not for every use for sure. Just something that accomplishes what these systems do, but with some particularities which make it a bit better for some if not many problems in that space.
Oh my! I didn't even realise it was a video. I thought it was just a picture of the "pyramid of doom" and was wondering where the async/awaits were. Thank you for clearing that up. 😊
Take an hour to go through the basics again: https://egghead.io/courses/react-fundamentals Then you just do it. I mean you must have some idea how to pull it off with regular HTML and CSS, React forms components around these and allows you to handle and react to state. Or use ready-made components, if you can.
&gt;Cancelling a promise is useless without cancelling the underlying asynchronous operation - and how that is done depends on the actual operation. Agreed. &gt;Just removing the promise from memory and maybe even tell the operating system to abort any asynchronous operations that the promises's code started would be really bad. Also agreed. &gt;It has to have all the code to deal with cancellations of its async. operations. But if it does, what's the problem with promises? The problem is the lack of a standard interfaces to 1) request cancellation or 2) "on cancel" resource cleanup. Every implementation will roll their own version of Promise cancellation &amp; they will inevitably be incompatible with each other. Things like "is a canceled Promise considered Resolved or Rejected?" should be standardized sooner than later.
But you don't *need* to cancel the promise: As soon as you cancel the underlying asynchronous operation your promise fulfills or rejects anyway. Because if you cancel the asynchronous stuff, the synchronous part runs to completion (be it success or failure).
It's stock market data. I can't actually predict how often it changes. But I do want to give the most up to data info. Some other user commented a way, is that my only option?
The author ~~copy-and-pasted~~ ripped-off a 3-year old blog post here... nice. --- Here's a contribution on the topic though: Using object destructuring in a function argument: [{id: 1}, {id: 2}].map(({id}) =&gt; id) 
&gt; All centred around **DDP, which is a proper bit of innovation** and hopefully will survive on its own outside the Meteor framework. This guy is on the money. Emphasis mine. I am replicating this on my own project with redux / react and may release it as a plug-inable package if there is interest.
That's like building your own house because you don't like your front door :)
It is blocking. Had to double check myself! An alert in the middle of a function stops that function but does not release the event loop.
Neat, took me a moment to pick up that it wasn't css. For anyone interested in the topic you might like [Animate.css](https://daneden.github.io/animate.css/) 
No. Like taking the gold railings from the titanic as its sinking.
function getMovieTitles(substr) { console.log($()); } this gives me "cannot read property 'document' of undefined" There is no window or document in scope of the hackerrank problem. And I don't know how to work around that. 
Wouldn't​ `a&lt;!--b` be valid syntax anyway though? Same thing as `a &lt; !(--b)`
Well shit, how the hell is my parsing library supposed to handle this...
Indeed :-D Note that the comment parsing kicks in only with the literal sequence `&lt;!--` (or `--&gt;` when it starts a line) so you can get around the comment parsing by adding spaces or parens as you did. 
&gt; I am replicating this on my own project with redux / react This is how I am 'recreating' DDP with a websocket connecting front and back. Seems to offer me what I needed Meteor for.
Yeah this is the real advantage here. Try stepping through a long `.then`chain without dying inside just a little bit.
I'm still having trouble with this. We want to import a text file with contents that look like this: 1,0,1,0,1,0,0,1 and assign this array to a variable (var x) in the javascript file we, need var x to look like so: var x = [1,0,1,0,1,0,0,1] i would greatly appreciate it if you can help again. the text file is named array the javascript file is named CapstoneJAVASCRIPT they are both in the same file location
`declare` is a *type* declaration, and as such doesn't actually have a value associated with it. It is used to let the TypeScript compiler know about globals it may not be aware of. It is *not* equivalent to `var`, `const`, or `let` and is removed during compile. declare var externalLibrary: any; // Without the above, this would result in a compile time error externalLibrary.doSomething(); What you want is to export the variable. // VarFile.ts export var myVar = 'myValue'; // OtherFile.ts import { myVar } from 'VarFile'; console.log(myVar) // -&gt; 'myValue';
Throw an error for being a little shit and including `&lt;!--` in your code ;)
Seems like we've likely come to the same conclusion. I've more control, there's no magic, and the API for redux and react are very nice and sensible--and just as 'complicated' (or not complicated) as meteor's. And Dan Abramov's free videos on the redux api are the best I've encountered. 
Exactly, if you're parsing a module your tokenizer should do as you suggest (`&lt;`, `!`, and `--` as separate tokens).
I think you missed my point. I was saying that it breaks the atomicity of the caller, i.e. function() { alert("something"); console.log("More user code might have executed before you get to this line"); } While the browser is showing its native alert, it continues to process other events such as mousemove and will call more of your functions that *do* change state before your first function resumes
Yep! Still not entirely convinced of the need for standardization but this is certainly the beginnings of such an argument ;)
This is a classic example of a binary search algorithm, with the slight exception that the sorted array is a figurative one, i.e. all numbers in order 0 - 100.
You can have your cake and eat it too, but it just requires a lot of work to ensure the platform evolves in an intentional, non-breaking way. The web has been a phenomenal success in this regard - pages from decades ago for the most part are readable and usable today despite the web's capabilities having grown a couple orders of magnitude since. Course you have to have a cost somewhere, and that's on implementations and spec authors (specifically Annex B but this principle's impacts touch everywhere from the choice of names to syntax available to use for new proposals).
Not sure if this is what /u/deathmood meant, but someone said once something to the effect that design patterns are indications that the language is missing a feature (see this discussion on [C2](http://wiki.c2.com/?AreDesignPatternsMissingLanguageFeatures), e.g.).
Because they have no idea what they're talking about. 
 console.log(x); // check if its the correct text var txt = "var x = ["+x+"];"; fs.writeFileSync('array.js', txt, 'utf8');
Thanks. This is settles it then. :)
JavaScript *generally* has no understanding of HTML. JavaScript in the browser has, with the `document`-object. Are you running in a browser? Or are you running with Node.js (= in a console-window)?
&gt; I've more control, there's no magic, This part is the real reason why I stopped developing in Meteor once I started using redux/websockets. Those two are what I needed Meteor with DDP and 'Client-side Mongo' for and I am in total control of those two pieces of my stack with redux and a websocket. If you make a package, I'd be interested in checking it out.
You're on the right track. I would check out Wikipedia's article on Binary Search and have a look at the pseudocode. That might give you an idea. You could also pepper your code with alert()'s to let you know where in the search you are as well as the values of your variables as the search runs. A debugger makes this a whole lot faster and more interactive. edit: Don't be discouraged. Usually, algorithms are saved for the 2nd semester/quarter (at least back when I was in college). If you still have more questions, reply and I'll give more specific hints or my solution, whichever helps you learn better.
If you want to perform multiple async calls in parallel and then collect the results, then you'd want to await the list results of a list of async functions inside a Promise.all().
Not sure why you would think Meteor is dying. I think Meteor is evolving had has changed considerably in the past few years. Now, it kinda feels like Express with the larger degree of freedom you have after fully integrating npm. I've used Meteor for dozens of projects, including several SaaS products and it has been great. It's the perfect solution for real time Web applications.
Awesome list of `now.sh` deployments. https://git.io/awesome-now
[are-you-async-yet?](https://h3manth.com/new/blog/2015/are-you-async-yet/)
 Header always set Access-Control-Allow-Origin "*" Header always set Access-Control-Allow-Headers "*" Origin headers need to be set on the remote server api.artsy.net, not your own server. Setting this on your own server will do nothing. http.onreadystatechange = function () { ... }; http.withCredentials = false; http.send(); Try inserting the withCredentials line. It tells the browser that you don't need to use the cookies stored in the browser. If you don't tell the browser to do this, it tries to use the cookies, and it's not permitted to by the server. https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials You seem to have some other token handling authentication, so it shouldn't be necessary. That said, if you ever put this in a public facing site, anyone can see your token by just looking at the source.
Caveat: do bear in mind I don't replicate the whole stack, just the parts I care about. Also, on mobile so sorry for lack of links/formatting. If you have more specific questions after this broad overview I'd be happy to answer in more detail. - push: most apps honestly don't need it, but if I do I just use socket.io. - push from DB: I am almost always using Postgres so I just use node-postgres' LISTEN functions in conjunction with triggers. - next handles all my transpiling, bundling, SSR, patching client, and async data loading. - everything else is just basic React. 
What you're supposed to do is level up beyond Meteor by learning how to do it all on your own with this precise stack: Webpack, React, Redux, Apollo, Express and NPM. The path is pretty obvious. Classic Meteor's full stack reactivity will always be an amazing thing...at first glance. Basically, to this day no solution ever came close to what Meteor could do in terms of full stack reactivity: it's API was so sweet and simple, there was no configuration, and it could scale far enough for most MVPs. The problem however is that exactly how far it could scale was never something people wanted to bet on. I used Meteor from the start and know of no famous extremely popular services built on Meteor. If you could scale it super far, nobody took the risk and instead built their systems that needed high performance with other task-specific tools. That's the "Apollo Realization" essentially. By building Apollo, Meteor and MDG has managed to keep themselves relevant through the realization that professional developers need to be able to craft completely custom &amp; scalable systems at the intersection of their databases and their clients, i.e. their web servers. So presumably all that's left of Meteor that you can't easily get outside of Meteor is isomorphic bundling, i.e. what Webpack can also do a lot less automagically. That's basically the main and only reason to choose Meteor anymore. Cuz remember, you can choose Apollo without Meteor. Same with React. Meteor's bundling system perhaps doesn't get the credit it deserves, especially since they seem to be making headways farther into code-splitting than Webpack itself, particular when it comes to server-side rendering in combination with code-splitting, which is something Webpack still struggles with. Anyway, yea, Meteor is dead for intermediate to advanced developers. If you're beginning to intermediate, definitely use it since wasting time on configuration and building IS A THING. It's a thing that won't grow your skills as much as building actual apps. So if Meteor can help you build your actual app quicker, definitely do it. But once you get to a certain skill level and where you're building an app with a lot of stakeholders expecting it to go far, choose NPM + Webpack without Meteor. And then invest the time putting it all together on your own. It's more than doable, and it will consume your time. But it's not beyond your capabilities, and when it comes to switching parts in and out of your system (perhaps for future scalability concerns) it will pay off. Learning how to "build" your app (i.e. through Webpack) is an important step in your path as a "journeyman developer." So if you've spent some time with Meteor and you're wondering about going off on your own to do it without Meteor, it's probably the right time, especially if you're starting a new greenfield project. 
Right, I understand that there are new keywords and such, but what problem is the syntax solving? OP says that the code is hard to read (or that it's ugly), but the proposal, as far as I can tell, looks identical to a switch statement. And, as you mentioned, it even has the same functionality. My point is that if a proposal doesn't solve a problem or improve anything, then it's not a very good proposal.
the same problem is actually solved in a cleaner point-free way by simply currying.
And `&lt;?=''` is valid PHP.
All of these technologies belong to the web, there is nothing that binds it to Polymer in particular. Polymer is an abstraction on top of the web components spec that fills some of the many gaps that the spec leaves open. It inherits the encapsulation, HTML imports, directives and templates from the spec. While you can use web components in React, either by [readymade wrappers](https://github.com/Wildhoney/Standalone) or by rolling your own, there's arguably not much sense in it. Web components are a regression to functional components. As for the other things, that's pretty much common by now and [many of these are automated](https://medium.com/@vladimirmetnew/webpack-loaders-and-plugins-for-your-new-progressive-web-app-378e09f469). Addy Osmani, you probably know him, has written many articles over the last months that are combining React with progressive enhancements, plus webpack specific things like async code splitting routes or components. If it interests you, you might wanna check out his Medium. Some perspectives about web components in relation to React: https://github.com/facebook/react/issues/5052#issuecomment-145594782 https://dmitriid.com/blog/2017/03/the-broken-promise-of-web-components/ 
not that I'm aware of, these are only available on the Element prototype - you'd do better by rolling your own with requestAnimationFrame and the ilk
You could animate `document.body` instead of the camera, and get the same result.
"improved" Only last week I was watching a video by Crockford in which he was showing exactly that kind of code and then saying "can you guess what language that is?" .... "yes, right - of course, Java - who else would come up with that crap??" Here's the video for those interested https://www.youtube.com/watch?v=6Fg3Aj9GzNw
Hi. I published a similar article the other day that goes a little bit more in depth and compares WAAPI with widely used CSS Animations... https://pawelgrzybek.com/intro-to-the-web-animations-api/
I am working in 3D with [three.js](https://threejs.org/), so I am afraid that is not possible. I'll probably have to roll my own as /u/thom_gather suggested, because [TweenLite/TweenMax](https://greensock.com/tweenmax) are overkill for my needs.
I'm using it for the page transitions on [my personal site](https://qwtel.com/) with great success. Together with the [polyfill](https://github.com/web-animations/web-animations-js) it can be used today. EDIT: In case anybody is wondering, those are [FLIP](https://aerotwist.com/blog/flip-your-animations/)-like animations. The Web Animations API is great for those. 
Lol forgot to switch accounts
Stateful or composed animations are difficult, often impossible for CSS and class patterns alone, or it looks broken and unpolished. Imagine something like this in CSS: http://chenglou.github.io/react-motion/demos/demo8-draggable-list/ If you're using Angular, React, Polymer or Vue you're probably already tweening in JS anyway. Take a look at [Facebooks animated](https://www.webpackbin.com/bins/-KfKys3S2mgEH9UsE8GL) for instance, which uses spring based physics. This is way too convenient and powerful to replace it with CSS. It's also cross platform, so you're running the same code on native platforms, which CSS can't unless you're wrapping a webview.
&gt;[**The Post JavaScript Apocalypse at Silicon Valley Code Camp 2016 [73:58]**](http://youtu.be/6Fg3Aj9GzNw) &gt;&gt;Silicon Valley Code Camp October 1-2, 2016 &gt; [*^Silicon ^Valley ^Code ^Camp*](https://www.youtube.com/channel/UCl_fhwlTAARASHq2hoEd_pw) ^in ^People ^&amp; ^Blogs &gt;*^5,583 ^views ^since ^Oct ^2016* [^bot ^info](/r/youtubefactsbot/wiki/index)
Yeah i too am confused... Been raised in java i always thought it was what motivated programmer would do... Now Crockford said its crap.. i loved that idea since i can now say its crap... its not that i wasn't motivated enough to split my catches... But truly i don't understand either arguments. I'll just keep on doing what i do i guess... But i want to understand Crockford arguments if i can.. So i can justify writing less verbose crap. 
Article doesn't say a whole lot more to be fair. It's pretty sparse on actual details (what was being taught on the course, what the module objectives are etc...) 
What sort of fundamentals?
In [this thread](https://www.reddit.com/r/programming/comments/66ww2m/stanford_is_moving_from_using_java_to_javascript/) posted 2 days ago into /r/programming [I wrote](https://www.reddit.com/r/programming/comments/66ww2m/stanford_is_moving_from_using_java_to_javascript/dgmf6ck/): The truth is language is relatively unimportant for introductory computer science. Various concepts can be taught in just about anything from assembler to C to Java/C# to scripting languages like Perl/Python. Where language becomes important is when various other metrics become important such as: * time to prototype (show a working skeleton) * time to delivery * extensibility/reuse * ease of modification and re-release * execution speed * debugging support * monitoring/profiling support * security risks, mitigation of crashes Then there are things that make developers feel comfortable/uncomfortable: * terseness * initial hours required for understanding basic principles * whitespace/layout considerations * community support/attitude None of these things are really that important to a first-time learner of software development. The things *they* need to understand are *principles*. You can implement abstract data types, or object orientation, in C if you have to. It doesn't have to be pretty, it doesn't have to be fun, it doesn't have to be the way you want to code when you leave university. But you *do* have to learn the *principles*.
Currently using vim as my text editor. I'm using plugins for syntax highlighting enabled, autocomplete and linting using eslint. Everything is done on the command line as far as development goes. I'm on ubuntu so gnome terminal is pretty good. If I have to split panels I might use tmux. This workflow works rather well without a mouse. It is mainly because of this fact that I use vim. On the front end I'm a big fan of the whole react redux ecosystem. It makes reasoning about application state much simpler. Even though, there's a lot of boiler plate, i find it worth it in the Long run. Backend I use node, express and posgresql. Most of the apps I make on the back are restful apis. Json web token for authorisation. Json schemes with is-Json-valid for form validation. Bookshelf as my orm for posgresql along with knexjs. Makes migrations bearable. I love fullstack Javascript.
No doubt JavaScript is gaining strength and Java has inherent inefficiencies, however I doubt if JavaScript is going to replace Java in the real world industrial strength software development
I've used: https://github.com/tweenjs/tween.js/ with threejs and it covers every base as any value can be animated. You might have to adapt your render/logic/physics loops to have a running delta T if you don't already. Without it the time scales for tween.js are arbitrary. 
Oh god. More confused recruiters incoming. 
Not this guy again. All his posts are basically "javascript sucks"
Visual Studio Code + node + livereload + rollup + babel + self made framework + template literals
Is there something about the language that limits Javascript's industrial strength? Or is it Java's current ecosystem and popularity?
IE11 *is* the most recent IE, since it's been discontinued (unless you're referring to Edge, which is quite different and not relevant) &gt; You were pointing out an obscure and old bug. Unfortunately, many of us still have to target IE because lots of people still use it and so it remains relevant. &gt; I'm talking about features of the Javascript language. ??? Terrific, I didn't contradict you &gt; A bold claim, but hey, who needs evidence. "I don't think this is specific to alert" surprisingly means that *I don't think* this is specific to alert, it was very clearly marked as conjecture, as in, I think I have observed it before, but I'm not sure enough to say for definite. As to evidence, I did provide evidence in my last comment, which you even referred to in your reply, so nice job there. &gt; You report a bug and claim it's a feature! At no point did I say it was a feature, in fact, if you actually read my previous comments, I said I thought it was a bug, your incredible powers of reading comprehension don't cease to amaze. &gt; And now you even top it, "I'm sure this is common but I can't show you". I don't know why you put that in quotes since I didn't say that at any point, but you know, who needs to make valid points when you can just make stuff up? &amp;nbsp; Has it crossed your mind that perhaps the contention you claim to find on this subreddit is your own doing? &amp;nbsp; This whole argument was completely uncalled for, I wasn't even calling what you had said into dispute, I merely pointed out something that I found interesting and thought others might also. I don't think that's how the language is supposed to work. &gt; Quite ridiculous. Very much so, a better person than me would have simply conceded and ignored you a while ago, since you don't even bother to read the responses properly before getting up your own arse. You've repeatedly failed to read/understand my replies, so I may as well return the favour. I really don't give a shit if you reply to this or not, I'm done. 
**This title is more than misleading... it is a lie.** Standard is experimentally offering an introduction to programming class taught using JavaScript instead of Java. The primary introduction to programming class is still there and still uses Java.
That is not totally a bad idea! JavaScript is a good place to understand the basics first then it's even a better place to learn Closures, the power of object composition and asynchronous operations, measuring code performance and most importantly the real problem solving thanks to all the continues libraries API changes and browser different support to modern features.
&gt; Hey you know Javascript, right? I have a Java job lined up for you!
This title completely mislead
It looks really interesting. I actually just bought it lol.and now to play, the waiting game....
I think this likely boils down to a general preference for instruction of OOP principles. Most people have a knee jerk reaction in favor of imperative programming and OOP, or at least that's how it appears to me, and Java historically leans in those directions. Java most definitely has an excellent ecosystem, but the same is largely true for NPM in many regards; plus it is my own observation that JS projects appear to have frequent and short release cycles. If the argument is that Java persists because of all the code already written for it, that argument is progressively losing steam. Edit for autocorrect
I don't see the problem teaching JavaScript as an introductory language. I learned on BASIC and I turned out fine.
I don't see the problem teaching JavaScript as an introductory language. I learned on BASIC and I turned out fine.
Probably no real difference but I suppose YMMV from browser to browser. If you use pixi.js instead of the canvas 2D API you won't have to worry about performance. I would avoid trying to update just the changing parts.
I don't see the problem teaching JavaScript as an introductory language. I learned on BASIC and I turned out fine.
I don't see the problem teaching JavaScript as an introductory language. I learned on BASIC and I turned out fine.
It's always interesting to get another view on CS1 modules from another educator. I've taught Java as a CS1 module as well as Python and I have to say I agree with you for a lot of your points. What I tend to forget as a (somewhat) experienced programmer though is that JavaScript comes with it's own set of intricacies (type checking, comparison, piecemeal standard implementations, etc...). I'm not saying Java is the best language for CS1, because it's not. If I was to push any language as being industrial grade, fundamentals ready and beginner friendly it'd be Python. Although, I'm not a fan of Python either but that's a different discussion!
Wtf? Did you do this on purpose?
Sorry had a stray `GOTO`
&gt; If you're going to teach the fundamentals of programming, start with what the computer actually sees. I *did* write some simple programs by entering machine language hex codes for a Z80 machine in school, but do you really think that this should be the first step you should take when learning programming?
garbage article. get that sh*t off here.
The first thing PHP developers learn about is script delimiters. It doesn't look so weird when having some experience with the language.
It doesn't look weird to me plus I fully understand why it is like that. either my PHP example or the stuff OP learned about today. I just think it's funny.
Yep. It's one introductory course and that's all. 
Been doing a lot of Python lately at work. All that beginner friendly syntactic sugar really does breakdown once your needs start to get even a little bit complex. And it really is not well suited to the functional paradigm at all. But honestly, what really makes me hate Python more than anything is the documentation. It is just the worst. JavaScript has its own warts, but at least they are fantastically documented. 
Plus you need like literally zero tooling. Notepad? Web browser? Okay, here we go!
I'm struggling to get this to work...When i try to install pwa-manifest-webpack-plugin I get the following : MacBook-Pro:cropchat erichardson$ npm i pwa-manifest-webpack-plugin --save npm WARN deprecated lodash-node@2.4.1: This package is discontinued. Use lodash@^4.0.0. &gt; lwip@0.0.9 install /Users/erichardson/Projects/cropchat/node_modules/lwip &gt; node-gyp rebuild CXX(target) Release/obj.target/lwip_decoder/src/decoder/init.o CXX(target) Release/obj.target/lwip_decoder/src/decoder/util.o CXX(target) Release/obj.target/lwip_decoder/src/decoder/buffer_worker.o ../src/decoder/buffer_worker.cpp:8:56: warning: ISO C++11 does not allow conversion from string literal to 'char *' [-Wwritable-strings] _height(0), _channels(0), _trans(false), _metadata("") { ^ 1 warning generated. CXX(target) Release/obj.target/lwip_decoder/src/decoder/jpeg_decoder.o CXX(target) Release/obj.target/lwip_decoder/src/decoder/png_decoder.o CXX(target) Release/obj.target/lwip_decoder/src/decoder/gif_decoder.o CC(target) Release/obj.target/lwip_decoder/src/lib/jpeg/jmemnobs.o CC(target) Release/obj.target/lwip_decoder/src/lib/jpeg/jcomapi.o CC(target) Release/obj.target/lwip_decoder/src/lib/jpeg/jdapimin.o CC(target) Release/obj.target/lwip_decoder/src/lib/jpeg/jdapistd.o CC(target) Release/obj.target/lwip_decoder/src/lib/jpeg/jdatadst.o CC(target) Release/obj.target/lwip_decoder/src/lib/jpeg/jdatasrc.o CC(target) Release/obj.target/lwip_decoder/src/lib/jpeg/jdcoefct.o CC(target) Release/obj.target/lwip_decoder/src/lib/jpeg/jdcolor.o CC(target) Release/obj.target/lwip_decoder/src/lib/jpeg/jddctmgr.o CC(target) Release/obj.target/lwip_decoder/src/lib/jpeg/jdhuff.o CC(target) Release/obj.target/lwip_decoder/src/lib/jpeg/jdinput.o CC(target) Release/obj.target/lwip_decoder/src/lib/jpeg/jdmainct.o CC(target) Release/obj.target/lwip_decoder/src/lib/jpeg/jdmarker.o CC(target) Release/obj.target/lwip_decoder/src/lib/jpeg/jdmaster.o CC(target) Release/obj.target/lwip_decoder/src/lib/jpeg/jdpostct.o CC(target) Release/obj.target/lwip_decoder/src/lib/jpeg/jdsample.o CC(target) Release/obj.target/lwip_decoder/src/lib/jpeg/jerror.o CC(target) Release/obj.target/lwip_decoder/src/lib/jpeg/jfdctflt.o CC(target) Release/obj.target/lwip_decoder/src/lib/jpeg/jfdctfst.o CC(target) Release/obj.target/lwip_decoder/src/lib/jpeg/jfdctint.o CC(target) Release/obj.target/lwip_decoder/src/lib/jpeg/jidctflt.o CC(target) Release/obj.target/lwip_decoder/src/lib/jpeg/jidctfst.o CC(target) Release/obj.target/lwip_decoder/src/lib/jpeg/jidctint.o CC(target) Release/obj.target/lwip_decoder/src/lib/jpeg/jutils.o CC(target) Release/obj.target/lwip_decoder/src/lib/jpeg/jmemmgr.o CC(target) Release/obj.target/lwip_decoder/src/lib/jpeg/jdarith.o CC(target) Release/obj.target/lwip_decoder/src/lib/jpeg/jdmerge.o CC(target) Release/obj.target/lwip_decoder/src/lib/jpeg/jaricom.o CC(target) Release/obj.target/lwip_decoder/src/lib/jpeg/jquant1.o CC(target) Release/obj.target/lwip_decoder/src/lib/jpeg/jquant2.o CC(target) Release/obj.target/lwip_decoder/src/lib/png/png.o In file included from ../src/lib/png/png.c:14: ../src/lib/png/pngpriv.h:805:4: error: ZLIB_VERNUM != PNG_ZLIB_VERNUM "-I (include path) error: see the notes in pngpriv.h" # error ZLIB_VERNUM != PNG_ZLIB_VERNUM \ ^ 1 error generated. make: *** [Release/obj.target/lwip_decoder/src/lib/png/png.o] Error 1 gyp ERR! build error gyp ERR! stack Error: `make` failed with exit code: 2 gyp ERR! stack at ChildProcess.onExit (/Users/erichardson/.npm-packages/lib/node_modules/npm/node_modules/node-gyp/lib/build.js:276:23) gyp ERR! stack at emitTwo (events.js:106:13) gyp ERR! stack at ChildProcess.emit (events.js:194:7) gyp ERR! stack at Process.ChildProcess._handle.onexit (internal/child_process.js:215:12) gyp ERR! System Darwin 15.6.0 gyp ERR! command "/usr/local/Cellar/node/7.7.3/bin/node" "/Users/erichardson/.npm-packages/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js" "rebuild" gyp ERR! cwd /Users/erichardson/Projects/cropchat/node_modules/lwip gyp ERR! node -v v7.7.3 gyp ERR! node-gyp -v v3.5.0 gyp ERR! not ok npm ERR! Darwin 15.6.0 npm ERR! argv "/usr/local/Cellar/node/7.7.3/bin/node" "/Users/erichardson/.npm-packages/bin/npm" "i" "pwa-manifest-webpack-plugin" "--save" npm ERR! node v7.7.3 npm ERR! npm v4.1.2 npm ERR! code ELIFECYCLE npm ERR! lwip@0.0.9 install: `node-gyp rebuild` npm ERR! Exit status 1 npm ERR! npm ERR! Failed at the lwip@0.0.9 install script 'node-gyp rebuild'. npm ERR! Make sure you have the latest version of node.js and npm installed. npm ERR! If you do, this is most likely a problem with the lwip package, npm ERR! not with npm itself. npm ERR! Tell the author that this fails on your system: npm ERR! node-gyp rebuild npm ERR! You can get information on how to open an issue for this project with: npm ERR! npm bugs lwip npm ERR! Or if that isn't available, you can get their info via: npm ERR! npm owner ls lwip npm ERR! There is likely additional logging output above. npm ERR! Please include the following file with any support request: npm ERR! /Users/erichardson/Projects/cropchat/npm-debug.log
You can reuse all of the values all the way through. For a simple examples (with just the getMoreData fn), promises are definitely way more readable. But if you need to use a previous var at the end, with async it looks like that's much more doable/readable. 
Really? I've only ever come across 1 undocumented behaviour in python in the 11 years I've been using it. 
This is the exact reason why I never believe titles 100%. Also, screw you OP. It's not cool to purposefully mislead millions of people just for some karma. Edit: regarding the 'millions of people part', reddit threads actually come up on Google, so u/timlmul, u/mgoerlich, and u/CStaplesLewis just stop. We're trying to steer **away** from misleading people here, not cause more of it. Arguing for the sheer sake of being annoying isn't particularly tolerated on this sub, so just stop now. It was cute, you win, now get back to circle jerking to your favorite pictures of each other. **Edit: tl;dr: trolls will be trolls.** 
Java/JavaScript
Can you elaborate? I know what currying is but I'm not well versed with async and I feel like if you did it wrong you'd turn certain things sync incorrectly? 
I get that, but when looking at most of the recent ES2015/16 updates async/classes/arrow functions those are all really syntax sugar. I personally love the syntax direction JS is taking. I am not 100% sold on this idea though. I like the syntax changes, but I am unsure if it really abides the languages more functional direction.
I personally like Python more as a beginner model but after programming in Java for a few years now I've come to like it quite a bit. In Java, lots of things are verbose, but it's *predicatble*. Once you are familiar with the syntax, there isn't too much "magic" around your typical code base. JS has a lot of weird quirks and things you can do. In our work due to various runtime contexts we write the same piece of code in both JS and Java and I find myself going to the Java code base more often than the JS one to figure out what the code is doing because it's easier to see what is happening and not get unexpected results from briefly browsing the code
The only real downside to starting with js I can see is the language being loosely typed. 
I originally pulled this from Facebooks flow syntax. I posted this with the intention to get feedback :)! https://flow.org/en/docs/types/
I think the documentation itself isn't too bad, the main gripe I hear from people is the layout of the Python pages. Large blob of text with sparse examples makes it a bit hard to navigate when most people want a series of small paragraphs followed by simple examples. Compare to MDN for JavaScript and there is a definite difference. I think Python could fix a lot of the issue with not too much effort with some simple reformatting, trimming, and better examples. This guy has a pretty good explanation of the beef: http://cryto.net/~joepie91/blog/2013/02/19/the-python-documentation-is-bad-and-you-should-feel-bad/
It is a bug. In one version of the browser (your latest example does not work in current IE or other browsers). &gt; I was only pointing out a quirk You were pointing out an obscure and old bug. I'm talking about features of the Javascript language. *You* take out some extremely obscure bug of one browser (and not even in current versions of that browser, I tried your code) that can only be demonstrated using an obscure feature long deprecated (for production in any case). &gt; I don't think this is specific to alert either, but that is the easiest one to test it against. A bold claim, but hey, who needs evidence. *You report a bug and claim it's a feature*! And now you even top it, "I'm sure this is common but I can't show you". Quite ridiculous.
I kinda feel like everything Crockford said in that segment is just... crap. Supposedly JavaScript's "better" way of doing things is this: try { // plan a } catch (ignore) { // plan b } // clean up Crockford says this is better than Java's way because 1) you don't need to care exactly what the error is; you just need to know something went wrong, and 2) you don't need a finally block. Except, 1) Java can do that too. You just catch the generic "Exception" type. *Plus* you almost always **SHOULD** care about what error type you're handling. Real life example... A co-worker did a blanket catch like Crockford is proposing, and in that blanket catch-all error handler, my co-worker's plan B was to return a default value. Fast forward not too long after, and I have to track down a bug. I'm placing all kinds of debugger statements and logs and commenting code to find out where the issue is originating from. Turns out someone had misspelled "assign". Just a stupid little typo. Normally such a simple mistake would be easy to find. A misspelled property name would get you undefined, and trying to invoke undefined would throw a TypeError, which would show in the console with a file name, line number, and explanation. *Except*, of course, the co-worker's blanket catch-all error handler was suppressing the typo TypeError. Don't do that. Always know what you're catching. And 2) Crockford's clean up isn't good enough. A finally block runs not only if there's an error, but also if there's a simple return. Not to mention that if the catch block throws, then you won't reach Crockford's clean-up. In short, a finally block will run *always*, no matter what. Crockford's clean-up won't.
An engineer, writing as a psychologist, talking about how designers are not engineers. In my home land, we might say this is the pot calling the kettle black.
I LOVE JavaScript, but I think starting with a weakly typed language can lead to bad programming habits down the road. I think CS should start with C or C++, weed out the people that really have the mind for it or not.
First I never said I *wanted* angularjs. I said it still dwarfs react. That's just a fact and sorry you don't like it. And second *I* didn't say vue was bigger. I *linked* to a site that says it is. If you have issued with that then tell the site. Don't try to blame me for that.
&gt;I didn't realise I was in this suburb. Language IS religion. You get downvoted just because you point out the truth that a weak type language is not good enough to be the first one to learn to understand fundamentals of programming Judging by how you just formulated that sentence, I find it hard to believe you can hold a college degree in any science field, not just computer science. I would love to hear you correct me, though. Source: BS in Computer Science currently constructing neural networks in javascript, largest network consisting of over 20,000 neurons and over 90 million connections.
More than millions. You've mislead us. http://lmgtfy.com/?q=how+many+people+have+access+to+google
[removed]
You got it man! There you go!
A switch statement isn't a solution here. The way a switch statement works is, the switch expression is compared with strict equality against each of the case clauses. Which means you're asking if `e === e instanceof InvalidArgument`.
this was my loaded response before he deleted his post and account lol: ______________ yo wtf!!! im actually sauper confused now! &gt; I'm misleading by saying there's only 100k+ subscribers on this sub. You never said anythning about the number of subs here, that was a completely different user. &gt; I then tell you that millions of people have access hence Google. You originally said million, then i correct you, you change it to billions and call me out. So I then show you that you changed it and you get defensive? &gt; you forget what you're actually arguing for. No i havent. I was totally joking around but you devlolved the conversation into an actual argument calling people names. Bye. EDIT: I've undeleted his comments here http://imgur.com/FIzfHkZ EDIT 2: Now reddit is sorting the conversation out of order and showing his account isnt deleted. super weird.
[removed]
I even went further when I held a programming course for beginners, I threw together a quick web page where you could enter JavaScript code (using the ace editor component) and push a button to have it executed immediately, including inline error display and a debugger with variable introspection.
[removed]
Just look at his comment history, that guy is either a troll or someone whit a really shitty live who has to compensate for that on the internet. If he wouldn't call names on everyone I'd almost feel bad for that poor devil.
yeah, i blocked him after realizing this. I was making a joke that probably didnt work well. He just wanted to troll.
/u/SOLAR_FIELDS roughly explained my gripe. It's not with the completeness of the docs, it's the formatting. Long pages covering multiple methods, written out in plain english paragraphs, with inconsistent examples. Compare that to MDN's JS documentation. One page per method. Information is laid out as reference info, not paragraphs. Multiple examples on every page. If you want to write a textbook, write a textbook. Documentation should be optimized for quick reference. 
I think it comes down to the controlled mutation of state. It makes concurrency easier when you have one authority mutating state in an safe organized way. 
Simplest? If/else. It's gonna be janky though. Take a look at this little snippet from a handler I created for switching panes, tabs (I call them views): for (registeredItem in availableRegister) { const currentItem = availableRegister[registeredItem]; if (currentItem.isShowing()) { if (currentItem.getName() !== requestedView) { currentItem.setDisplay(false); } else {return; } } else if (registeredItem === requestedView) { currentItem.setDisplay(true); } } This is essentially an array of tabs, or panes. For each one, it checks if it is showing and then if the requested one's name is the same, it does nothing. Else, it'll continue to loop, and once it finds the one with the name that matches the requested one, and display it. It's rather nifty. I could probably create a dumbed down version of it for your use, if you like.
Hi /u/nevercomindown, please keep it civil.
Sorry, will do.
The biggest problem I see is that you would have to request the data very often which some APIs actually don't allow hence why I suggested sockets since you could make it so you only get the data if it changes. I would look into how many requests per minute the API allows because that'll probably be your bottleneck.
Also u/mgoerlich and u/CStaplesLewis were both harassing me up above at the top of this thread, yet no mods do anything. I say poop and all of a sudden a mod comes, what's up? 
I... was not expecting that. Well played!
Report any comments that violate our guidelines.
Sure, **we** were harassing **you**…
Yeah, you guys were. Just like how you are now. Fucking stop and just shut up.
Hi /u/mgoerlich, please just ignore further interactions for now. This is going nowhere. Thanks.
Hi /u/timlmul, please just ignore further interactions for now. This is going nowhere. Thanks.
You linked "you might not need react" instead of redux. Correct link: https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367
Would you mind giving me your thoughts on Feathers? We use Meteor at work, and it's great for how we're using it, but I'd like to go with something a bit lighter weight for a hobby project I've been working on. The project involves monitoring another process on the server and displaying that in real time to the user (and allowing for some interaction). Does Feathers seem like a good fit for something like that?
For your 2nd point, the connect function basically does what you described (listens to store, updates component with data from store). It's just made for you so you don't have to do it. 
Whoops, that's what I get for trying to copy URLs out of my history :) Fixed - thanks!
Because browser vendors wait until Stage-3 for the spec to be stable before implementing and shipping the feature, otherwise potential new changes to the spec may not be backwards compatible. Babel is happy to ship features and break their users when the spec is updated. Unfortunately this is not something browsers can get away with.
For the purposes of running the file in Unix / Linux, the first two bytes in the file must be `#!`, so no BOM.
Thank ye kindly. If shebang shows up in the spec, you know who is to blame (and it's not me :-P).
That's the same without redux 
If you really set your heart on it you could even make a little program for your game w/ Electron and Node.
Imagine redux as your database. Your database is divided into tables(reducers). Now what do you usually do with a db table? You run queries on it, these are your actions UPDATE, SELECT, INSERT, DELETE so basic crud. Of course if you want to query your db you have to connect to it(Container components) and if you want to run actions over your db you have to call them(dispatch)
I don't really understand the issue here. The "boilerplate" for redux is like 10 LoC for a whole app. &gt; Why not just create a base "Store" class, with a connect/disconnect that can be hooked into the Mounting and Unmounting of components, that calls an "UpdateState" function in the component. Then the actual stores extend that class, and just add in their own actions (addTodo or whatever), which at the end just call that the base store's update function which iterates through the connected components and calls their update state function. TBH, that's not super far off from what redux is in the first place. 
Nice work!
It's basically a js version of Elm which is what inspired Redux in the first place. I'm not here to hijack this thread and point people to HyperApp.. or Choo or whatever. I'm just convinced the simple approach is better, less boilerplate and confusion.. I don't think people should have to explain Redux, it should be self evident.
pwned
You probably want to use a show/hide feature on the divs rather than trying to swap out individual pieces. For each image set div, add a class 'tab' and an id, like 'set1'. &lt;div class='tab' id='set1'&gt; Content here &lt;/div&gt; Create a CSS class which can be applied to hide the divs. .hide { display: none; } Then you can use javascript to hide all of the tabs and unhide the one that should show. function hideTabs() { [...document.querySelectorAll('.tab')].map(function(tab){ tab.classList.add('hide'); }); } function showTab(id) { hideTabs(); document.querySelector('#'+id).classList.remove('hide'); } Now, you can set a button's onClick event to execute the showTab function for the correct section to show. &lt;button onClick='showTab("set1")'&gt;Image Set 1&lt;/button&gt; 
But then I wouldn't be learning... meaning that I would not achieve the goal of this project. Not asking anyone to do the work for me, just to be more of a code mentor. I'll call anyone, that seriously wants to help, Godfather if you like.
Just ask some specific questions on the subreddit, or preferably search stack overflow. Learn the way countless before you have.
That rocks! 
&gt; reserve the syntactic space following a colon after an identifier for tools like TypeScript and Flow. In that case, any chance TypeScript will pick up the syntax? It seems like an obvious fit.
I'd be happy to mentor you through your project. Feel free to PM me any questions, and I'll answer when I'm able.
I agree. I'd rather spend more time implementing actual enhancements to my app. 
You should look into [MobX](https://github.com/mobxjs/mobx). I'd love to hear what you think after using it for a couple of components. It was an absolute gamechanger for me.
Thanks! I'm outlining things. I'll be in touch.
instead of a "dispatch" you simply call a method on a class instance an then verify it's state changed accordingly. It's not rocket science-it's fairly basic OOP.
Check at pluralsight.com It got a free month trial. Its vast complete and easy to find stufff
This has never been a problem with apis that separate operation description with execution. Where Promises get into trouble is mixing the two together: stateful values that can derive from each other mixed with eager execution. Look at FileReader: you create an instance, tell it what it will do, and THEN you execute it. The cancelation interface is right on the instance you created, available before the request actually runs. Even setTimeout gets this basically right: the synchronous result of setTimeout IS a cancelation interface, while the asynchronous effect is basically "forked" (not really, but conceptually) into separate future thread. But with Promises, it's way, WAY too easy to actually start off an effect before you're even ready to set up the logic for canceling it. And, worse, pure transforms are muddled together with eventual side-effects. The problem with things like FileReader and setTimeout is that they're not super composable. But there are ways to solve that problem without resorting to stateful values.
validate against what ? last time i saw someone ask this they were trying to make a phishing page :/
Every model needs a controller, then you need routes and views ... why? Every service needs an interface, then you need dependency injection and implementations ... why? Redux is a (very small) framework that implements a functional one-way data flow pattern. If you don't get it, or don't like it, you don't need to to use it. Dispatchers and reducers are just functions.. events in your system are sent into redux via a dispatch function, the reducer then decides how to apply that event to the state tree. AFAIK there is no industry standard around keeping said tree flattened, you're free to shape it however you like. There are plenty of advantages to having a single state store with a specified api footprint(i.e. reducers) for interacting with that state. 
I recommend watching this [video tutorial] (https://egghead.io/lessons/javascript-redux-the-single-immutable-state-tree). It walks you through building a lot of what you described by hand, and then introduces redux one step at a time so you can see what it does. I agree you could do all of this yourself, but then you'd end up with your own custom solution. This will make it harder when you have to train someone else on it or you move on and someone else has to maintain your code.
More code generally means more bugs.
Go with MobX instead. Generally I'd say that it is a minority of web applications that needs something like Redux.
I'm going to premise this by saying watch this video (even if you've already watched it a while back). If you haven't you should watch this video (Important bit starts @ 10m): https://youtu.be/xsSnOQynTHs?t=602 What Redux gives me is a way to decouple my application business logic/rules from the actually interface the user uses. If we take a step back to earlier web development we have a classic client-server model which was a simple request-response. This works incredibly well, and it's super simple. A user would make a request, the server would take information it stored locally about the current users session, generate a new document and send it down to the client and then just wait around for the next request to come from the user. The issue is that it makes it hard to create rich client applications because all the processing is occurring outside of the users computer, this adds a lot of latency to any interaction the user takes with the html document, and doesn't provide the best experience for the user. Now lets look at React, and lets skip all the state crap and focus on pure components. Every React component takes in a set of props and returns a description of the html fragment. If we were to write this out as a basic functional transformation we have`(component, props) -&gt; html`. The real power of React is it's ability to manage complex DOM interactions for you, but lets just look at React as a way to generate html given a set of initial values (props), basically just a templating library. So now with React we can take an input and produce html that the browser can render. This is very similar to what our classic web development. Someplace in this tool chain existed a way to take an input and generate html (see any server side templating library). Now how do we solve the user interaction problem? We'll anything a user does is also a transformation function (though a bit unpredictable). The html our templating library produced generated a fixed set of ways the user can interact with it. These are all the links, buttons, forms whatever have you that was generated. In classical development all of these actions where _intents_ to the server. When the user interacted with the DOM a request would be generated and sent to the server, which then processed the request given a set of business rules and send back a new document with another set of interactions the user could take. What is important to note here is that the user always expressed an intent to do something, but it was ultimately up to the server to carry out and respond. So what does this all have to do with Redux? Well what is Redux but a pattern of intent -&gt; response interaction? With React we are taking an input and generating a DOM with bindings (onClick, etc) which when a user interacts with it simply generate an _intent_ of the users action (hence action creators in Redux). This intent is fed through a set of business rules (redux middleware) which determine exactly how the users action should be interpreted (because no one trusts users). These business rules then ultimately result in some state transformation (reducer), in classic web development this would be updating a database. At the end of this, our classic server then takes this new state and generates a new document and sends it back to the browser. With Redux, we take this state and feed it back into our React transformation. We could just replace the entire DOM but that isn't ideal. React solves this problem for us though! It's _really_ good (maybe slow) at updating the _current_ DOM with the changes that differ from the new representation (vdom at work here). Best yet, this all takes place on the users computer, where the cycle time is fast. This process takes milliseconds, instead of possibly 100ms. My absolute favorite example of this is with the `redux-saga` middleware. I wrote a bit about this earlier today: https://www.reddit.com/r/javascript/comments/67f6pz/whats_your_development_environment_setup_and_what/dgqjzwk/ Also I think you are making Redux to complicated. It's so simple. This example of course doesn't have all the dynamic type checking, but all that just goes in the way. Redux only ever has a single reducer. `combineReducers` is just a way to, well combine them. Redux itself also really doesn't have a concept of middleware. Middleware is just all the crud that your action goes through before it actually calls the redux native `dispatch`. function createStore(reducer, baseState) { const listeners = []; let state = baseState; function subscribe (fn) { listeners.push(fn); return function unsubscribe () { const index = listeners.indexOf(fn); listeners.splice(index, 1); } } function dispatch (action) { state = reducer(state, action); listeners.forEach(l =&gt; l()); } function getState () { return state; } return { subscribe, dispatch, getState } }
IE did not suck at first. It was one of the best browsers, and pushed forwards some truly interesting tech but then they won, the team was diassembled and all activity stopped for 6 years. IE didn't suck because they shipped too much, too fast. It sucked because they stopped shipping at all.
holy block of text, did you throw it in a &lt;script&gt; ?
Fixed.
Went back to make sure this wasn't /r/shittyprogramming. Your post is completely unreadable, unfortunately. In general you can easily get some javascript into an html page by embedding in a &lt;script&gt; tag, like so: &lt;html&gt; ... blah blah blah ... &lt;script type="text/javascript"&gt; Your code goes here &lt;/script&gt; ... blah blah blah ... &lt;/html&gt;
It'll be tough to help without seeing what you actually did. Did you check the console for errors? (https://developer.chrome.com/devtools#access)
With the rise of single page applications and micro services: no less than any other application. Think of something like online ordering or banking (TurboTax is probably the nicest looking SPA I've seen lately). There's a lot going on in the browser and a lot of asynchronous calls / state updates being made. 
Beginners of all people should be using typescript instead of javascript.
You can make it real: https://github.com/taisel/GameBoy-Online
Redux might be lower-level than you need if the boilerplate gets in your way. In fact, it may be dangerous to use since *boilerplate* is essentially technical debt, (as soon as a convention changes, all that boilerplate needs to be updated). Personally, I used [apollo-client](https://github.com/apollographql/apollo-client), an awesome GraphQL client written on Redux.
I agree. It's a good thing that React has Facebook on it's back, so that it can be widely used.
If you have deeply nested components that share state, it can be problematic dispatching an event all the way back up the tree. Or pulling down a prop for that one thing you need. This also creates a dependency nightmare. For instance: &lt;main /&gt; &lt;foo /&gt; &lt;bar /&gt; &lt;baz fizz={buzz} /&gt; &lt;bob fizz={buzz} /&gt; If you need modify buzz, you need to handle an event all the way up from baz to a function in main. Because only main can hold common state for component that depend on the state of buzz. You will have to pass a function all the way down to baz in order to setstate in main from baz. You also need to pass down buzz in some form all the way down, even if foo and bar don't use buzz. This turns into a mess quickly. With redux, you simply define a reducer to change buzz in the store and dispatch an action inside baz when you want to change buzz. It also makes the one way flow more explicit. State &gt; view &gt; action &gt; new state...rinse, repeat. It's all one direction. Using connect, you can simply define what information want available from the store right inside the component. If you have really limited state and/or only local state to each component or if you components are not deeply nested, you don't need redux. Passing a function down through props and handling it on an event is perfectly fine. It just gets more unwieldy at a certain point.
My dragon curve from last week, now on Codepen: https://codepen.io/ccajas/pen/gWLGvr
I got a taste of Redux + React when I did some work on upgrading our CMS which now includes it in the core-- like the other commenters have mentioned, the boilerplate really turned me off to it. But after reading through your comment here, I have a much better idea at what I was hacking at. I've also been stubborn to embrace functional programming with the hype over the years but now I can appreciate the concept with Redux as a concrete example of a framework revolving around functional programming. Congrats, you've made me a convert to functional programming and Redux!
Thanks. I just downloaded it and tried it out. It's not bad at all, but maybe I am just worried about JavaScript itself.
Heh. Not exactly my original intent, but glad the comment was useful and informative :) You may also be interested in reading an issue I recently opened to discuss general concerns about Redux "boilerplate", and possible useful things that could be built on top of the Redux core to make things easier for learners to get started: https://github.com/reactjs/redux/issues/2295 .
Redux is great. It is totally orthogonal to React. I've used it with Mithril.js and VanillaJS and it definitely solved some pain points I had in my applications.
Thanks! I kinda am with JS. Though I am familiar with PHP, Python, and HTML.
I did some research a while back. But this covered most of the highlights. (Biased, ofcourse.) https://www.youtube.com/watch?v=6I_GwgoGm1w If I needed a full js framework, I would probably go with Aurelia over Angular 2. It seems to have less baggage than ng2. But we didn't need anything more than a view library in current project and React fit the bill nicely. React/redux has worked much more nicely than I had ever imagined. I personally think jsx's combined view logic syntax make more sense. It's familiar right from the get go. And I don't think maintaining two dependent files is really a separation of concerns, since the component (view) is the concern, not the technology (html/css/js). Spliting up html and js just means a single change must often touch more than one file because your template is so tightly coupled with logic. /rantoff If you really wanted to be complete, you need to look into Elm IMO. I haven't had much time to dig into Elm, but it looks fantastic. I feel like it is the first solution to come along lately that tries to address the entirety of the web development process with fresh eyes and tries to build a comprehensive solution. Even if Elm itself doesn't go anywhere, I think the process, tooling and domain specificity refinements that it is innovating on are the future. To be clear, react is just your view. You give it some state, and it gives you some html on the page. Components are like functions that take state and return html. It is not a framework. It doesn't do data binding to the server or authentication or validation, or any of the other stuff you expect from a full framework like ng2 or aurelia.
After googling an error or warning from React/Redux I often find myself at a GitHub issues page with Dan very patiently explaining what is going on.
Here is a link: /r/HyperApp
Someone built a really shitty DOOM clone in only CSS. I was pretty amazed. 
Are there any decent doc sources for Hyperapp? The Getting Started guide leaves much to be desired, and I don't see much else. 
While not untrue, it's not a really constructive comment. More code also generally means more features, more functionality. 
I've been using Aurelia for over a year now. I use the separate .js file to my advantage in a number of ways. One instance is extending base classes into screens that share the same base operations. Can you do the same thing in React/Redux?
Heck I see him in random, obscure repos helping with issues
My Tomato had different variables. You can use "nvram show" to get a list of all variables and grep for your current SSID to find out what the variable is. For example of your SSID is called ABC then do the following command to find out the variable for your setup (case sensitive) nvram show | grep "ABC" In my case the variable for regular wifi was wl0_ssid and for 5g was wl1_ssid. Hope that helps :)
And also once something hits browsers, it's pretty damn difficult to remove that functionality.
I meant it didn't break authentication. Worked great for me. I found the nvram variable without issue. 
A React component is really just a class. You could design your component such that that makes sense. The preferred method is composition instead of inheritance. Or higher order components. I'll be honest, I've never had to inherit from anything other than react.component. It all comes down to how you organize you bit and bobs. All of our components are very small, functional bits. Like for my current project we are rewriting a rails app. And we just go through it bit by bit chopping up the view until we get single logically cohesive, functional units and compose them together.