I don't know the answer to your questions, but I'm curious what you're building.
Or a 3rd person competitive shooter like GRAW2 and socom 
If you know nothing about coding then do codeacademy in a couple hours then jump straight into Free Code Camp and work through the JavaScript section. They have lots and lots of algorithm challenges.
This would be the easiest question to google. You would of had your answer in about 30 seconds and saved yourself 2-3 minutes typing out this question as well.
Ah yes, that does make perfect sense, thanks for the explanation! 
hmm...was really hoping for the feature since they're implemented in typescript
Interesting. Thanks!
Thanks 
unrolled loops are faster so you should probably start doing that
I think it and YDKJS complement each other well. Some things aren't covered as thoroughly in the Secrets book and vice versa. I do especially appreciate how the Secrets book explained how you could write your own generator driver the way TJ's co works (or bluebird-co).
Yeah, but "radar" is a very loose term. Anywhere I have ever worked this just means that the idea is recognized as good, not necessarily that it will be done anytime soon. I definitely believe that it was "on the radar," because I know there are some great engineers at npm who saw the value and would likely have advocated for it. I just don't believe that the people making choices about how time is allocated shared that vision. With past large changes to npm like when it went to flat dependency structure, the public knew it was coming for a long time. As far as i know there was no such public knowledge about these changes until after yarn came out. This certainly makes it look like a reaction.
yeah, i think anyone who says 'they read plenty of books and it helped them so much' is full of crap, atleast that's how I take it. I know plenty of people read JS books but i see pretty much 0 value in it. Wouldn't it be 100x better to read source code for website interaction you'd like to develop and break it down to its full extent?
In addition to what others have said I thought I'd offer a little bit of help with beginner friendly debugging (someone mentioned dev tools but like a lot of beginners you might not know much about them, so I thought I might add a few basics. This might help you figure out the flow of your program a little better, and let you poke around it as it runs to find out where your assumptions about it break down. --- To do this we will add in a simple statement to our code called a debugger statement. It look like `debugger;`. In order to access and practice with the development tools I'll just type out a short snippet of code that you can copy-paste into the console of your browser to practice this with if you feel like it. var numberOfKitties = 2; console.log('So far we have ', numberOfKitties, ' kitties'); debugger; for (var i = 0; i &lt; numberOfKitties; i++) { console.log(' Kitty number ', i, ' says "Meow :)"'); } numberOfKitties = getMoarKitties(numberOfKitties, 3); for (var i = 0; i &lt; numberOfKitties; i++) { console.log(' Kitty number ', i, ' says "Meow :)"'); } function getMoarKitties(current, numToGet) { var newNumberOfKitties = current + numToGet; console.log('We just got ', numToGet, ' more kitties!!!'); return newNumberOfKitties; } To run this in chrome, you would open the console tab of the developer tools. The way I do it on my computer is `Ctrl+Shift+I` though there are a lot of ways to open it. Then you just paste the code in and as the code runs it pauses at the `debugger;` statement with [this interface](http://imgur.com/X1Y1sj9). I tried to outline the most important parts of the interface for you as a beginner: - In the bottom I still have the console. It shows the code I pasted in and then it has one line which came out of the program. - To the right side of the console is a little thing that says VM101:2. This indicates that the line that the output came from was on line 2 of the code. - In the middle is the code itself, paused at the debugger statement. In general the highlighted line indicates the line that is about to run next, but hasn't been run yet. - In the top-right I drew a box around three buttons. These are "step-over", "step-in", and "step-out" - "step-over" will run the current line that is highlighted and go to the next line. - If the current line is a function (like calling getMoarKitties) "step-into" will take you inside of that function code to continue poking around there. When you get to the end of that piece it will take you wherever comes next in a program. - If you "step-into" something you don't care about (let's say you understand what getMoarKitties does, or you accidentally step into some 10,000 line library file your program is using that was written by someone else) then using "step-out" will run the rest of that for you and put you back outside just as if you had stepped over the function call. --- I included a small bug in my sample program (it counts kitties incorrectly and is off by one). A good exercise if you want to practice the debugger is to find what part/parts of the code cause that. Either way, I hope this might be helpful. I'm not sure if your question was answered or figured out yet but in case it wasn't I thought I'd add the basics of this wonderful tool. 
You could hire a person in college or something to have better luck answering questions.
Thank you for the feedback. I made this as the calculator project for FreeCodeCamp, but if I do work on it more in the future, it would be to add the scientific functions. Before they fixed the log(0) issue that you mention, did dividing by 0 give Infinity? I set an upper and lower (magnitude) bound for the output and output "Error" for anything outside of that, but it's not exactly the same as the iPhone calculator, particularly for very small numbers.
Actually, I'm trolling, as he is. All trolling aside, though, there is a valid point here and it is that one can build anything with plain JS. It's just not always that attractive for newcomers, though, so maybe not the best fit for what I want to achieve.
Well, I don't quite get the metaphor, but yes, writing a Virtual DOM manipulation library myself is not something I'm willing to do right now. Plus, even if I wanted to, I'm better off contributing to an already established library than starting from scratch. It's to the benefit of more people!
Google: &gt;"Cutting off the nose to spite the face" is an expression used to describe a needlessly self-destructive over-reaction to a problem: "Don't cut off your nose to spite your face" is a warning against acting out of pique, or against pursuing revenge in a way that would damage oneself more than the object of one's anger. Basically, I'm saying a lot of developers take it upon themselves to do everything from scratch to prevent dependency on libraries/frameworks, only to end up in a situation where many man hours are spent reinventing the wheel and onboarding new developers than getting stuff done. Carry on!
I would also recommend IRC ##javascript on freenode.net.
Because I literally have no idea how to do this. Kindly suggest resources, if you know of any.
I'm building for React as it turns out and I will kindly suggest to people to use Preact instead, as it better fits the profile of what I'm going for here.
Wasn't this a part of TS before the proposal even existed?
What do you mean you have no idea how to do this? Do you use webpack, or watchify?
Why is JSON "generally a pain to write?" It's succinct and extremely well understood by people working with node. If you need comments and imports then you can just change .json to .js and module.export the literal, using "require" to pull in other files. It doesn't get much simpler than that.
Your question is perfectly fine. It especially include a minimal working example showing your problem. The only thing to do is waiting for answer. The reason why it can take some time is that the problem is in using google app api and so it might take some time that someone who has the correct environment to reproduce the answer and solve it to come. Just be patient.
I reset my pc but knowing my luck cached files is exactly what it was ... Thanks for your help mate 
Cant someone show a side by side "hcnf" vs yml and show how hcnf is any easier?
service workers maybe
Can't speak for /u/desnoth but I find Vue's component model to be far superior to Angular's directives. It's far less complex, the syntax is clean, and everything is locally scoped instead of global. EDIT: I'm talking about Angular 1. Angular 2 might as well be different framework.
If statements !== AI
CRA now includes a service worker: &gt;By default, it also includes a service worker so that your app loads from local cache on future visits. Looks like you were running the "production" mode so that may be the issue. 
Just to highlight something about the email, please don't embed a form within the email, it simply won't work for the majority of recipients. Same with embedded JavaScript (incase you are considering it) the functionality will be stripped out. Thanks to the spammers nothing risky is allowed. Think of the email as the magazine cover, the good stuff is inside. So link to a landing page containing the form or anything that can't be rendered before deployment of the email. Feel free to PM. 
Yarn is the future. I'm sticking with it. npm has shown time and again that they are incapable of making good technical decisions unless the decisions are made for them. It's truly dumbfounding how the makers of a tool that's the foundation of an entire ecosystem can't understand the importance of basic lockfile features or remotely fast install times, to the point where someone has to go out and write a competing product to make a point. Let's not forget how long it took to get rid of the infinite dependency trees in npm2 as well. Oh, and how npmjs.org somehow allowed users to withhold packages, which led to the left-pad incident. How on earth does that even happen? Allowing a package to get pulled from the repo when thousands of other packages depend on it, including giants like Babel? And it's not like yarn is that hard to switch to. JS fatigue doesn't even apply; they're both package managers and accomplish the same thing with very similar commands and processes, same as all other package managers. Yarn is simply objectively better in every way, aside from npm coming built-in.
Déjà vu
I'm sure a bagillion **switch** statements would work for your needs... 
Try posting a code snippet to /r/learnjavascript- that's a more appropriate audience for this type of question.
If you've done any kind of programming before it's easy to get started. Mastering JavaScript is an entirely different thing. I've been writing it for 7+ years and I still feel inadequate.
Should be there now!
Every problem is this - until it becomes clear that it's something else
You're for sure going to get a larger body of potential users going with React, if you have to choose only one. If it goes well you will probably even see someone port your work to Vue.
The one thing Yarn still has that is killer is `yarn upgrade-interactive`.
Oh man I've had this a few times and when I realized it, every time I've felt like the dumbest person ever. I ctrl f5 100% of the time now out of fear.
intelligence is subjective
Yep, this is very likely the issue. I have no idea why this was made a default. SWs are cool and definitely should be considered for many apps, but you have to know the implications and APIs. Just adding them as a blanket feature seems error-prone.
IF that's true. Then what next?
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [gunthercox/chatterbot-corpus/.../**english** (master → dd6e536)](https://github.com/gunthercox/chatterbot-corpus/tree/dd6e5360e4e14c3ee8e48f4bc74ff0cd957cea5c/chatterbot_corpus/data/english) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply di64f94.)^.
Agree. I think this may be related with Google and the PWA evangelization (which I think is a good thing). 
Hahaha yeah I know what you mean, I've been there before infuriated that something isn't working simply because of caching and I'm not realising 
[Bot Builder framework w/ Node JS](https://docs.microsoft.com/en-us/bot-framework/nodejs/bot-builder-nodejs-quickstart)
P5 is awesome. Check this article out. Helped me write my first engine using P5: https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection
Like, all of them, actually. Literally every C# dev that has to touch JS sees Typescript and immediately feels (slightly more) comfortable.
Well, it's not like they'll know any ES version syntax, so I'm not sure I understand your point.
I think it'll take at *least* four months to make a Facebook clone.
I was disappointed by those changes as well
IF you have enough of them, you can make an AI. Just more work.
Thanks, I'll try that next time 
Thank you! I spend a good deal of time getting it right, so I'll post the final solution here. It works! Thank you for getting me on the right path. var form = FormApp.openById(formID); var formResponse = form.createResponse() ; var items = form.getItems(); for (index = 0; index &lt; 2; ++index) { var item = items[index] // Cast the generic item to the text-item class. You will likely have to adjust this part. You can find the item classes in the documentation. https://developers.google.com/apps-script/reference/forms/item-type. if (item.getType() == 'TEXT') { var textItem = item.asTextItem(); var itemresponse = textItem.createResponse('Core Teachers'); formResponse.withItemResponse(itemresponse); } if (item.getType() == 'PARAGRAPH_TEXT') { var textItem = item.asParagraphTextItem(); var itemresponse = textItem.createResponse(logSummary); formResponse.withItemResponse(itemresponse); } } formResponse.submit(); 
I actually use API.ai, you like wit better?
This was the missing piece: if (item.getType() == 'TEXT') { var textItem = item.asTextItem(); var itemresponse = textItem.createResponse('Core Teachers'); No way you could guess that! Thank you for helping.
&gt; This was the missing piece: &gt; if (item.getType() == 'TEXT') { var textItem = item.asTextItem(); var itemresponse = textItem.createResponse('Core Teachers'); &gt; No way you could guess that! Thank you for helping. 
That sounds like a variation on [Eliza](https://en.wikipedia.org/wiki/ELIZA). If you want to iterate on that a bit, you'd probably want to start with something that processes natural language in some way. extract verbs, subjects, etc.. That'd allow you to have some more generic patterns to match against, and somewhat more accurately reuse bits of sentences in your answers. I haven't really used it myself, but this looks like it could be interesting to take your bot in that direction: https://github.com/nlp-compromise/compromise 
Actually, `bind` creates a new function - so maybe it really doesn't matter in this case?
The mark of an AI is to be able to learn through experience. If statements are hard coding intelligence, not allowing any learning and thus not a mark of an AI. 
Exactly, there's no actual benefit in defining it on the prototype if you bind it in the constructor, since it won't be inherited. It just looks slightly cleaner in current ES syntax while we wait for the class property proposal to reach stage 3/4.
Am I the only one who is really frustrated with codewars? I hate spending 5 - 10 minutes just figuring out what the author is asking of me. Then spend 30 min - hour completing (or more often than not, not completing) a Kata that is not practical at all. Am I doing it wrong? am I an idiot?
I think this is an unintelligent comment, given that any algorithm based on discrete choices will at some point​ have to be interpreted as conditionals and/or look-up tables. Control theory and machine learning have usually been referred to as separate from AI. Have you implemented an AI? Didn't it have several if statements?
No, AI doesn't have to learn. That's other type of AI which learns stuff.
To be honest, it depends on how the logic works. There's many ways from recursive calls at object to regex
I think AI: A Modern Approach will help you get started.
There is no universal definition for "AI", it most commonly refers to any program behavior that is intended to resemble intelligent decision making. The computer controlled opponent in a game is often called the AI even though most of the time it does not involve anything very complex.
Something Else, Finally!
thanks!
Same here
I recommend you take a look at AIML, it's a markup language for AI. While it uses XML as basis it wouldn't be hard to change that into JSON (I kinda did that myself at one point or another because who the fuck likes working with XML?) 
What kinda website? Hows your backend setup?
In my tests, Ionic has been exceptionally slow as a Progressive Web App, even for trivial applications. However, I haven't tested the newest updates and whatnot. I think you should test how a fresh init of Ionic performs as a PWA. Even during Google IO, Addi Osmani barely mentioned Angular (which Ionic builds on) due to it being fairly slow compared to Vue, Preact and React. 
Kinda lite on the frameworks..
A littel bit late, but hopefully I'm getting it right 1) You're doing some assignments in your ViewModel - this.newcart = koCart(); this.total = koTotal(); this.quantity = koQuantity(); the values used for creating your ko properties won't be revaluated on change. Means if koCart (reassignment) changes, newCart won't react to it. 2) You could try onclick: window.addToCart.bind(null, id) - but I havn't tried this yet just an idea 
I am certainly biased here, but I do hope they choose React. It already is the most ubiquitous go-to solution in the post-jQuery era, and having WordPress on board would certainly help to solidify that. If there's something the JavaScript community as a whole *doesn't* need, it's more uncertainty about what's the right solution to learn and use. Nothing against Vue, but IMO it's just too little, too late.
Which makes the biggest problem of javascript stay forever: developers don't think they need to learn javascript to use it, since they already know C# or Java. Making typescript more similar (at a glance) to those languages is something bad IMHO, since the language is so much different from them. 
So these folks threw out their entire PHP codebase, which used the notoriously bloated Symfony2, went for a script engine that's at least 2000% faster (Node V8) compared to barebones PHP, and arrived at an API that's 70% faster. Typically when you rewrite an old project from scratch, you can get it several times faster even on the same platform you started with. Something went really wrong in that rewrite, IMO. And their overall new solution seems pretty messy, with some things that stand out: - They opted out of TypeScript and similar developer tooling, in favor of fragmenting their application to small bits to keep it maintainable, and using high-overhead interproces protocols for communication. - They use horrible hacks like [memoizee](https://github.com/medikoo/memoizee) for "cache"... which shouldn't be seen on any production application. Aside from this type of memoization being very error-prone, it also slow, and may in some cases be slower than not using memoization. - They didn't take full advantage of Node's persistence, but seem to have kept their persistence logic pretty much identical to what their PHP APIs did (PHP needs to rely much more on external persistence, as it's a "run and exit" execution for every request). 
Clickbaity article with some guy's own preferences and generic advice passed on as "THE modern way" to write JS. Plus - what has the number of spaces used for indentation got to do with modernity?? 
I like React. It's a decent choice. But variety is good, variety brings innovation. I'd love to see some big company actually adopt Vue.js, but that might also bring all its flaws to the surface, while React has been tested a lot more and is definitely rock-solid. I'm kinda rooting for Vue, but I still think that React will be the winner both here and in most similar cases. It takes a lot of faith to go with Vue these days. 
That actually looks cool. Does it have a virtual DOM built-in? (I'm not going to be using it for the current project, but I want to check it out in the future)
I saw this post on Instagram &amp; it seems to be a knowledge section for developers, so I just casually shared it on Reddit. What's the harm in sharing knowledge if it comes from any source.
[removed]
&gt; Something went really wrong in that rewrite, IMO I guess it's the overhead introduced by all the network calls between micro-services. &gt; They use horrible hacks like memoizee for "cache" Yeah, that's really weird. In-process caching is only useful for per-request stuff (like current user profile etc) and it could be easily done in PHP. They didn't seem to have any specific problems with their current tech, so the rewrite was successful because developers had better understanding of problem domain, not because of shiny new tech.
Thats is a complete bullshit. Assuming we are talking about PHP 7 or HHVM, performance is on par with Node.js. Which is incredible, considering that we are comparing apples and oranges. https://www.sitepoint.com/php-vs-node-js-smackdown-right-of-reply/ Provides a good overview the two technologies at the high level for people who might be an expert in one but not another.
That source is 2 years old.
As I said elsewhere in the thread, the difference between 5.x and 7.x is 2x. Unfortunately the Language Benchmarks Game no longer make nice graphs which are easy to analyze at a glance, but here's a modern bench of PHP 7.x vs. Node.JS: http://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=node&amp;lang2=php As you see in over half the tests Node beats PHP by huge margins.
Sorry for bad experience. Staying annoyed for hours and then rage posting on Reddit is not the best way to fix the issue :-) The best way would be to report a bug to us, as we are always happy to help: https://github.com/facebookincubator/create-react-app/issues/new In this case the issue is likely due to service worker registration that caches the files: https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#making-a-progressive-web-app. This lets the app load instantly for repeated visitors but it is still a new model for many people. We are looking for ways to document this better. You can also participate in this discussion: https://github.com/facebookincubator/create-react-app/issues/2398. Cheers!
If you are looking for more relevant benchmarks, check out TechEmpower. Express beats Symfony by a huge margin, in "multiple queries" it's 1.5 times faster, in "single query" it's more that ten times faster. 
You are welcome to participate in this discussion if you have opinions about this :-). Most of the time, if you aren't sure why something was done, you can just ask, and we will be happy to answer! https://github.com/facebookincubator/create-react-app/issues/2398
I am a bit lost with your repo organization (I would work a little more on the architecture and folder structure) but cool project. Keep it up and release a v2.0.0 soon :)
The language benchmarks are already covered in comments, PHP is way slower than Node. Though after reading the whole article, they have got a respectable speed-up considering CPU usage has dropped dramatically.
I was trying to use the following structure: https://medium.com/@alexmngn/how-to-better-organize-your-react-applications-2fd3ea1920f1 That might be because of some major rewrites I should've done better. Perhaps I can help you with explaining the structure? Thank you for support :)
&gt; async requests It seems that executing simple database queries in parallel doesn't have significant advantages (and from my experience most of queries in eCommerce platforms are simple). I've checked TechEmpower benchmarks - for multiple requests the difference between Express (that uses parallel requests) and Symfony (that doesn't) is only 1.5 times. In "single-query" benchmark Express is 15 times faster.
&gt; It seems that executing fast requests in parallel doesn't have significant advantages. I've check TechEmpower benchmarks - for multiple requests the difference between Express (that uses parallel requests) and Symfony (that doesn't) is only 1.5 times. In "single-query" benchmark Express is 15 times faster. Saying async requests don't have significant advantage is pretty silly. If all requests end up going against a serially executing service, then yes, it doesn't matter (well we still win on network latency, but I'll ignore this here). But if the service you're calling is multi-threaded, multi-process, is itself async, or you're calling heterogeneous services (independent APIs), then your total processing time goes down from the sum of all request/response cycles, to only the longest request/response cycle by itself. There's a reason why Facebook added async/await support to Hack, although PHP doesn't support it.
Could you maybe explain why using memoizee (or I guess any other similar chaching solution) is bad?
Ohhh I see. I will take a look at it this evening after work. Maybe you could add the link to the article in the readme so that people know what inspired you.
See edit. I never said that non-blocking I/O is useless, I just said that it's not that useful in specific situation (that I think applies to eCommerce applications) - very simple queries (that use highly selective index) to a nearby database server.
The ESM loader wasn't cooked up over a weekend. Its core, reify, has been in development for more than a year and is even in production use at Meteor (a TC39 member). Unlike global engines/runtimes the ESM loader is opt-in. So you're opting-in to features that you can cherry-pick/lint to taste. Many features, like the `export` syntax expansion to obtain parity with `import`, are non controversial and more likely to land in future spec revisions. Others are more controversial but designed for a better developer experience. For example, the ESM loader honors established CJS practices by carrying over some existing CJS conveniences/helpers like `__dirname` and `__filename`. Standard and technical entities, like the TC39 and Node CTC, **are not** infallible. While I'm represented by both the JS Foundation &amp; Microsoft in the TC39, the strength of Node.js has always been in the community and user-land packages. With packages like Lodash, which impacts ~30% of all npm packages, taking a dependency and community champions like Sindre Sorhus as allies, this loader will likely become an integral and essentially standard 😉 part of the ecosystem. As such, the ESM loader can help guide standards and technical entities to improve things for everyone.
I haven't tried this one yet, but I've spent a considerable amount of time testing various Virtual DOM implementations/DOM differs, and I've noticed the following: - there is an incredibly high number of edge cases a library like this one needs to take care of, and the number of libraries that get most of these right is surprisingly small; - performance is all over the place, and it's not always the smallest libraries that are also the fastest. (Note that this will only really start to matter if you need to update your UI 60 times per second, which you probably don't if you're just building a normal application type thing.) The library that had both the best performance _and_ the best handling of edge cases that I encountered during my testing was [Inferno.js](https://infernojs.org/). It's really, really, really good. 
Well, in that case I'll keep an eye on it. Seems like I could actually benefit from using it in some other project. (I like choosing the right tool for the job and I love finding new tools, so thank you very much for this!)
Is there a joke I'm missing here?
At this point i feel like browser could offer their own diff/patch algo. So we can use it on a second thread by default and have decent perfs. 
any website really....i know im being generic but since ionic is simply html, javascript and css why not build a mobile optimized website with ionic?
/r/iamversmart
Thanks for your feedback. Inferno.js is really good! For benchmarks, [see js-framework-benchmark](https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts/table.html) and look at _hyperapp_. Inferno.js is about 10%-20% faster than picodom. Picodom is smaller though, ~990 bytes (&lt;200 LOC), whereas inferno is several thousand lines of code. Picodom is just the dom builder and patch function. 
This seems very similar to the [Snabbdom](https://github.com/snabbdom/snabbdom) core. Would it be fair to compare the two?
Do you ever wonder if something you deploy is actually faster or if it's just broken?
Is this true? &gt; we’re very bullish on gRPC as the next-gen standard for communicating among microservices Is this a general consensus among developers? I know cryptocurrency is using RPC. I'm not a fan.
The only problem about using that framework is that you need to use that other module `ReinventingTheWheel`.
&gt; But the "why would someone use this?" Maybe to bootstrap a mobile app if you don't have the skills or time to maintain two apps There are a lot of people who fall in this category!
&gt; developers don't think they need to learn javascript to use it TS is a superset of JS though, so once you learn Typescript there is nothing left to learn about Javascript.
If you like writing HTML + directives go with Vue, if you like JSX go with React. That's probably the biggest difference. Both are good and architecturally very similar. Vue is slightly faster in some benchmarks and more lightweight. React has more adoption. I've used both and prefer Vue for its pragmatic approach to problems.
Fair point! 
Since when is a single source that measures "reactjs" (an identifier few people use for React) an objective fact?
&gt; Would it be fair to compare the two? Yes, absolutely. &gt; This seems very similar to the Snabbdom core. Neither the API or the implementation are similar. I'd be curious to know which parts you found similar and would be happy walk you through them. 
Since StackOverflow uses tags that everyone is forced to use. There are no other React tags like `react`, `react js`, etc. `reactjs` is the only one [Google trends is smart enough to identify a particular subject and is consistent with SO trends in this aspect](https://trends.google.com/trends/explore?q=%2Fm%2F012l1vxv,%2Fm%2F0j45p7w), but there is no way to identify Angular 1 and Angular 2+.
Maybe consider looking up the 'contenteditable' attribute and use styles to give the feel of an input on active state. Otherwise I would suggest breaking down your components more so you don't have all that logic in one render function.
I too would like to see a unified front, but the "right" solution should actually be the *right* solution. Unfortunately that's probably an arbitrary decision within every organization. I feel that way about something like Ember moreso than Vue though because Vue seems pretty awesome.
No, I get that. But after a certain point I can only imagine you'd be better off actually writing a native ios and native Android apps. 
This sub is not "I have problem, code a solution" type of thing, you need to dive down into learning how things work. Anyway, here is one example how this could work(note that I did not know what exactly you want to achieve) - as simple as possible. https://codepen.io/anon/pen/mmZdbY?editors=0010 
i would take this with a grain of salt - this represents instances of tags - a more accurate stat would be pageviews on questions with those tags - by looking at tags, you risk a bias towards languages/frameworks with poorer documentation or generally more difficult for beginners - which could be applied to the angular-react debate
Dude, you link to synthetic benchmarks which do not line up in the real world at all. See, this is the difference between the real world and places like /r/javascript. There's people throwing benchmarks around showing Node can do X job 1000% faster, but in real life performance tests for real world apps it's never even close to that. 
Did you find any of the two examples on the README useful? Maybe you can help me figure out what I should put there instead.
Hello again, im pretty new to reddit, so i didn't know. Im sorry. :) Btw, it doesnt need to delete the previous text, just get on the lines below the previous lines after the certain time. So here is how it is supposed to be: display two lines of text, wait certain time display two new lines under the previous , wait certain time, etc. Hope you will help me finish the last part. :)
Yes, but if you also look at [Google Trends](https://trends.google.com/trends/explore?q=%2Fm%2F012l1vxv,%2Fm%2F0j45p7w) it becomes obvious Angular has always had more interest than React ever had. Just to be clear, I'm not saying Angular is better than React, just that the reality is quite different outside of the Reddit and HN bubble. Angular is still very strong in the enterprise world. I'd also like to point out that I'm no Angular evangelist. I use Vue myself.
Virtual DOM libraries generally expose a [hyperscript](https://github.com/hyperhype/hyperscript)-like `h` function. This is the vnode builder function. This is also what hyperx/JSX is compiled into when you use a babel, hyperxify, etc. The `patch` function has a similar story. This is the function that patches the DOM comparing and old node with a new node. All virtual DOM engines need one too. So, the API here is how you would use hooks, lifecycle events, keyed nodes, modules, styles, animations, vnodes, attributes, properties, etc. Snabbdom [is not](https://github.com/snabbdom/snabbdom/blob/master/dist/snabbdom.js) 200 LOC either. BTW, Snabbdom is great and I am not trying to compete with it, but one problem I had with it was that it was really difficult (not impossible, but why make it hard?) to support both JSX and hyperx (due to its unconventional props/attrs module API).
Dude, you are taking a lot of different data from different sources and coming to some wild conclusions. Anyone who works in the real world can tell you that synthetic benchmarks on web languages rarely line up to real world performance. Node is nowhere near 2000% faster in practice compared to PHP.
Thank you! I'm still new to JavaScript. Hadn't thought of using event listeners. I appreciate it!
The intended audience is anyone that wants to create a view library/framework based on a Virtual DOM, like React. What it's trying to achieve is: enable anyone to focus on writing the state management and application architecture of their framework, instead of the lower level DOM patching, etc. As for what you need to learn, you can start with a framework like React. If you want to try something a bit simpler, check out [hyperapp](https://github.com/hyperapp/hyperapp/tree/master/docs).
There's been a paradigm shift that makes the dom irrelevant for most of what you do. You declare layout in functions. These functions create a virtual tree which is mapped visually into the render target, the dom for instance. If a node in the virtual tree changes (which libs detect by diffing) it gets updated in the visual tree again. It allows you to make complex applications with ease, they can render in the browser, or as a native desktop app, mobile, or literally everywhere. Most frameworks use it, many prominent websites use these frameworks, native frameworks/languages start to build on the same principles. If you know Javascript there's not much to learn, you can get it under an hour. Begin with React, which started all of this, then move to whereever suits you best.
Axios. I like their error handling API more than fetch
One of the advantages of Fetch over XHR (which Fetch is intended to replace) is that Fetch uses a Promise-based API, which makes it a lot easier to use than event-based XHR. But this advantage doesn't really matter in practice, because Axios and other XHR-based libraries provide Promise-based APIs anyway. A big limitation of Fetch is that it's not capable of aborting requests, which makes it **less** capable than XHR. So you can't implement things like timeouts that abort a request that is taking too long. It's just not possible. The Fetch API is definitely easier than XHR but it looks a bit weird, like the following idiom that parses a JSON response body: fetch(...).then(response =&gt; { return response.json(); }).then(...) The json() method acts on a response with a json body and returns a Promise for the parsed body, but it's a strange idiom because json() isn't a great name for the method (a clearer name would contain a verb) and it's an asynchronous function for no necessary reason, since parsing JSON is usually done synchronously.
&gt; Dude, you are taking a lot of different data from different sources and coming to some wild conclusions. I've taken two direct comparisons of PHP with Node.JS from a reputable source. One for the 5.x branch and one for the 7.x branch. There's nothing wrong with the data. &gt; Anyone who works in the real world can tell you that synthetic benchmarks on web languages rarely line up to real world performance. The 20x (PHP5 vs. V8) and 10x (PHP7 vs. V8) numbers I claimed, are for synthetic benchmarks. I never claimed otherwise, I said "the script engine is 2000% faster". Go up there and find the quote. That implies raw performance, not taking into account SQL databases, file I/O and so on. 
I can tell that you're an incredibly intelligent guy that knows a lot about development, but I just think you're missing the point. In your original post you wrote: &gt; Something went really wrong in that rewrite, IMO. And your very first point you make is that Node is 2000% faster than PHP and yet they only achieved a 70% increase in speed. But you make that sound bad. You keep talking about how Node is 2000% faster in support of that point. But everybody else is saying that just isn't true in **real world production**. For example, at my current company we started building a huge new product about 7 months ago. We spent a lot of time and resources comparing PHP + Laravel, .NET Core, and Node + any framework. We looked at many aspects of each option and even wrote prototypes in each. As the applications grew, Node's performance advantages shrunk. There were too many other bottlenecks in web development. We have databases, frameworks, ORMs, latency between servers &amp; microservices, latency between front-end SPA and API backend, etc. By the time you add all that shit there's no real world difference between Node and PHP for any decent sized application. If I want to do something very compute heavy, I won't be using Node or PHP anyways. I'll write a C#, Java, etc app to handle it and use the PHP layer to transmit the results. The fact that these guys got a 70% increase from their work is still great. That being said, a lot of other people are correct in saying that they probably could have had similar speed increases just from rebuilding their current PHP setup. 
Guess they have to pretend so the investors think they are doing something with the money
The part where it actually learns.
I support innovation and people who like to code and build great things. And am happy to see JS is getting these features. I even see a downvoted comment to "just use amdefine". Well that solution worked fine for me, then 5 years of amazing hop scotch between build tools and libraries happened. And while some report benefits and advancement, I have to tell you, the amount of tools you have to pull in these days just get some single page interaction going... Just stop. And we need to draw a line between "progress" for the language and its libraries vs introducing features without discipline. The more features a language has, the harder it will be for open source and industry to develop consensus on what's idiomatic. Want to know another language feature? Being stable. I swear, it's like the language reinvents itself every year. Give me some sort of promise when you'll leave the standard alone, then I'll wait for the community to form best practices / libraries to catch up. After the dust settles, I'll invest time reading up on the standard. Ain't trying to jab javascript. Love the language, community is top tier, but everything these days from build tools to libraries seems like a moving target.
I still don't understand why WP needs to have any JS framework at all in Core. I thought they were focusing on their REST api instead
&gt; asynchronous function for no necessary reason, since parsing JSON is usually done synchronously. I think the reason why it's async is because it is a stream/buffer that you are parsing into JSON, not a string that you are parsing.
Afaik Safari was the last browser that implemented fetch. Now it's natively supported by everyone.
Thanks, I will try to search using that keyword! *Edit:* Sadly there are no search results for this on YouTube. :(
Currently using the really small https://github.com/developit/unfetch as a polyfill.
Got Em!
Thanks for your answer, it was a genuine question. I remember it needing MongoDB when I looked at it years ago.
What is an RPC? I was also hoping there'd be a bit more elaboration on this choice..
[removed]
If they were at 82ms average, are you saying they should be getting to response times of 0.041ms? Lol ok
I wasn't saying that, but even if I was... your math is off by 100x. That's what happens to engineers without engineering degrees, when doing calculations. But I'm glad you can entertain yourself. 
Build something significant with a major library/framework. Then build with something else. Just keep going. Eventually you begin to find pain points in different approaches. Build like a todo app, and add some friend functionality to share todos, and then add scheduling functionality. Or figure out something that people want and either make it or join in a project working on that thing. Like I joined a project that makes a web app for world of warcraft, since I'm really involved in that community. The intersecting interests help me stay motivated and the the complicated problems that need to be solved push me to learn more than I would have normally. Before that I built mods for kerbal space program to fix issues I had with other mods and to build things that I wanted in the game. Keep a list of ideas for things you may want to build and revisit them when you get time. I have a huge list of stuff I want to build, and I'll never get around to building all of it, but it means I never wonder about what I can do next. Find your thing, dig your heels in, and get to work.
Why? React Native is a good example of using Javascript and React as universal concepts.
There are some pitfalls in that in general and lots of [ready-made components](https://github.com/kaivi/ReactInlineEdit) that abstract them, though you might want to check out their source for help if you want to roll your own. import ContentEditable from 'react-edit-inline' class App extends Component { state = { value: '' } render = () =&gt; &lt;ContentEditable paramName='value' text={this.state.value} change={this.setState.bind(this)} /&gt; }
No worries, happy coding!
&gt; A group rewrites a whole, mature app, a feat in itself. I am actually more impressed that they managed a rewrite on-time and on-budget, while delivering a real improvement to the system. That they did so whilst also switching to an utterly different programming language, is incredible!
True, but 4.1ms is still damn near impossible. Everyone loses :( 
Suppose you are writing a chat application, and you have a list of unread messages somewhere in your app's core. This list can appear in different ways depending on where the user is. For the app's icon, it could appear as a number in a little red circle. On the "Friends" screen, it could appear as a bold username, and on the "Chat" screen, it could appear as a highlight on certain messages. Now, suppose we detect a new incoming message from the server. How do we update the GUI? In the old model, the core would need to know all the places the information appears so it can manually toggle highlights on or off or replace one number with another. If the programmer forgets to update a spot, the GUI will get out of sync with the core, creating weird bugs. This the old "JQuery" way of doing things, and it doesn't scale well. The "two-way data binding" people are also doing something similar, except that the data flow is a lot more automated. The React / virtual-DOM model is completely different. Instead of manually updating one location or another, you just re-render the entire GUI from scratch whenever the core data changes. That way, no matter which screen the user is on, everything will always be up to date. On the flip side, updating *everything* is obviously going to be slow, so the model requires some level of caching and difference-checking to be practical. That way, only the things that have actually changed need to be rendered. That is what this library handles, at least on the most basic level. I haven't mentioned "components" yet, which are reusable bits of GUI code you can put all over your app. When you embed a YouTube video on a web page, for example, you don't manually create the playback buttons - the YouTube video component handles all of this for you. Most modern web frameworks have a single purpose - to help you define your own components and combine them together. Even JQuery lets you do this. In their purest form, React "components" are just plain functions that take some app state as input and return some GUI as output. As long as the input is the same, the returned GUI will be the same. Thus, a full React-style framework can potentially do caching and diffing on each component's input, as well as its output. React also allows components to have local state, separate from the app's core state. This is useful for stuff like the current scroll position, for example, which the core shouldn't care about. Thus, while picodom can certainly be used on its own, you might want a few more features for a full solution.
Thank you so much! That is an awesome answer and helps a ton! One thing I'm curious about: &gt; React also allows components to have local state, separate from the app's core state. Are there terms/vocabulary for these different kinds of state (either in React or generally)? Also, is the "core state" the only one that every modern component based framework will provide and the "local" version of state you mention is specific to React or others who provide it as an extra feature?
Hi /u/ELECPON, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
Interesting bits of the nes features. Last time I used NodeJS was last year, and version 6 was about to be shipped by then. Time flies by fast, but man, the Javascript ecosystem seems to be drifting faster. Gotta refresh some concepts and learn some new to get along the wagon!
Refactoring, Working Effectively With Legacy Code, GoF Design Patterns, Structure and Interpretation of Computer Programs, How to Design Programs, Clean Code, Pragmatic Programmer, Power of Habit All of these have helped me be a stronger developer that ships software. I've been doing this long enough that I won't label myself as an X programmer. I'm a software developer and most of the truly valuable knowledge I have gained throughout my career was related to learning about systems and patterns that apply broadly across language boundaries. JS isn't super tricky, as far as syntax goes. 
We're talking about gRPC here, it's a bit different -- old school RPC systems are quite another thing :) http://www.grpc.io/
Cool, thanks. That one's on my radar already - I'll stick it on my shortlist.
They're all books I'm aware of, but haven't wanted to shell out for or invest time into reading in case they're all java or C based, in which case I'd find them hard to get through (as I mentioned in the OP, I've read the pragmatic programmer, which was great, just a bit hard going). Having read those books yourself, do you think that's a valid concern or am I worrying about nothing? (For all I know, there's no actual code in these other books anyway and my issue with them is entirely imaginary!) Edit: I should probably add that I've read a bunch of softer books that have helped me out just as much as technical books, so I've no doubt there's a lot of wisdom within those pages.
No, it is not. First, the document API is only available in a web browser. Are you hoping to run this code in a web browser? Second, the document API does not open files. It allows the API user to open the current document (the page in the browser that the script is running in) for writing. If you are hoping to run this code from the command line, you have two options, and if you want to actually use something that other people use, then you really only have one option: Node.js. I found a decent article (using Google) on writing files using Node.js here: http://adminuser.org/reading-from-and-writing-to-files-in-node-js/
Please note that pico-dom in the benchmark table is not picodom, but a different framework.
I wrote it so I could write the same style everywhere. Allows for code like this: List&lt;String&gt; allNames = doWith(data, JsonData::getFunctions, map(pipe( JsonFunction::getSignature, JsonSignature::getName )), concat(__, ramdaNames), uniq(), without(data.getHide()), sortBy(toUpper()) );
Clarification: IE will never support it. 
Yeah it's a hard page refresh. Clears cache and reloads.
First of all if you want to do IO with javaScript, you need to use nodejs, documentation of file system related API can be found [here](https://nodejs.org/api/fs.html). What you wanted to do is roughly this: var fs = require("fs"); var FILE = '/etc/file.conf'; fs.writeFileSync(FILE, 'nameserver 127.0.0.1\n'); In your js code, `document.open` is a _browser_ api, which only runs in a browser and has [nothing](https://developer.mozilla.org/en-US/docs/Web/API/Document/open) to do with file system access. In fact, document is a global variable/namespace that only exits in browser, and not available in nodejs. In terms of writing files, here are some key differences between Python and nodejs 1. `open` in python is a buildin function, whereas similar functionality in nodejs is provided by fs module 2. In most cases, javascript does not require you to explicitly open/close File Descriptors (it's possible to have similar control with fs.open and fs.close if desired though) 3. Common practice in dealing with IO in nodejs is asynchronous, some exceptions like fs.writeFileSync exists - but it's considered non-idiomatic You should read up on async io, callbacks, Promises etc with respect to javaScript: it's a big topic and very different from Python (everything is synchronous by default). However, if you are just learning the basics, stick to fs.readFileSync and fs.writeFileSync, most of your Python knowledge can be transferable. 
Free to read online (my books): * [Exploring ES6](http://exploringjs.com/es6/) * [Exploring ES2016 and ES2017](http://exploringjs.com/es2016-es2017/) * [And others](http://exploringjs.com/)
Oh, cool, I've already read your "Setting Up ES6" book. :) And I recognise that Rhino front cover, so I must have considered reading the others at some point recently. I'll add them to my list, thanks! Also, good on you for making them available for free!
&gt; Some of the “smaller” implementations are incredibly fast like surplus, domvm, ivi and dio and almost beat vanillajs a rather generous assertion, given how tricky it is to shave that last 10%
http://beginningprogrammer.com/programming/javascript-for-the-object-oriented-programmer/
Why everybody is hating angular
yeah i was agreeing
&gt; The mentality of "I implemented it first, now you have no alternative but to use my implementation and not the spec'd one becaue I infiltrated everything I could" is exactly what I meant. You've got it wrong. The ESM loader is opt-in. Every package author has a choice. If you don't want to use it, you don't have to install it as a dep, and can always wait 11 months for the built-in, less dev friendly, Node 10+ only solution. &gt; While I see the point and advantages of your library and admire its initial purpose, I completely disagree with the mentality of where it wants to go. Make a draft, discuss with others, even with me in TC39. Are you part of the TC39, Christoph? I've gone down the draft route and have worked with the Node CTC and TC39 on various things. However, they aren't the only routes available and I'm happy to explore others.
I agree that the momentum has already pulled far away from Backbone, but you'd be surprised how many popular web apps are still using It. I'm pretty sure that Pandora was using Backbone until a few months ago, when they switched to React.
Vue single file components are super sexy :)
But most of these sites are in end-of-life, maintenance-only, will-rewrite-in-react-as-soon-as-we-have-budget mode.
I settled for React right now, but I'm seriously considering porting to Vue after I'm done writing the library. After all it's not that difficult!
Agreed, mostly. I am actually in the middle of migrating a project from Backbone myself, and was surprised to see that there are still people maintaining Backbone's monolithic source. There are still warm issues, still recent questions on Stack about Backbone, so I think while it's definitely not a hot topic, it's not completely dead either.
I love the way they are handling it - they keep fine tuning the project and keeping it up to date (I remember following a discussion on github about converting ES6/7 classes), but no new development. The problem is that most plugin authors are (or already have) giving up.
Cool. Having worked on several heavily component based projects, both in React and Vue, I found that Vue allowed me to write less code, and more elegant cooling code. Components that behave just like you'd expect native inputs to behave are very easily to build with Vue. However, if number of current users is the priority, React is the clear winner :)
Nope, but it's still in use unfortunately, especially with company intranet apps and such. I'd love to not have to support it.
Because the 1.x codebase was so poorly designed its own developers had make a new version from the ground up. Floundering 1000s of enterprise apps. Forcing those teams to hire people with "angular skills" just to maintain bad, poorly performant 1.x apps. Yeah, no thanks.
I can't speak for the why it's in C#, but I would guess it's largely historical given MS API naming conventions. Some of it probably does carry in from existing C# users which isn't really a problem or anything as long as naming is consistent. Otherwise, here's an actual attempt at an explanation: creating an interface is useful for abstraction and ensuring your code isn't tightly coupled. Instead of depending on the implementation, you can depend on the API contract instead. The name of the implementation often coincides with the name of the abstraction, so it'll be named called an `IFoo` instead of `Foo` and `FooImpl`. This is often handy for things like mocks, or creating alternative/specialized implementations, though (like mentioned) it's already pretty easy to mock something in TS anyway. I don't really have a great reason otherwise, but I feel like I could mostly convince myself with this. :)
Thanks for the info! I remember being told to look up nodejs but I thought it was mainly for socket programming, regardless thanks. I'm not sure if it makes a difference but everything is being done on a web browser, but it's more client to server in a website. Regardless thanks for the info looking forward to learning more about nodejs since I'm only in the beginning stage lol 
~~[Sure it does.](http://imgur.com/a/g2f1d)~~ [Edit: Previous image didn't include request body.](http://imgur.com/a/ensfV)
No, show the request body.
[This](https://medium.com/@shahata/why-i-wont-be-using-fetch-api-in-my-apps-6900e6c6fe78) is a decent read that I think was posted here recently. Essentially the author says that `fetch` is too low-level for ergonomic use in application code. If you need to do low-level stuff it's great, but if you're just POSTing to a JSON API, then go with a higher-level library like Axios. Of course, if you want to save on dependencies, `fetch` seems like a great platform to build an internal convenience library on top of.
the download builder on that is hilarious, the loading animations to feign calculation processing is the cherry on top. actually cherry on top might be the empty `.js` file 
[#927](https://xkcd.com/927/)
[Image](https://imgs.xkcd.com/comics/standards.png) [Mobile](https://m.xkcd.com/927/) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini\-USB\. Or is it micro\-USB? Shit\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 4556 times, representing 2.8639% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_di7hvxk)
After a certain point of *what*? Sounds hand-wavy to me. Frankly, I don't see why most mobile apps would need a custom implementation on each platform.
you mean non php?
Have a look through NPM. A cursory search got me this: https://www.npmjs.com/package/hal
This is the only answer this thread should need.
Why does React with MobX have slightly poorer performance than React with Redux?
"Vue.js is the fastest of the big three modern frameworks although not by a large margin. It starts faster than both angular and react and shows little weakness." I've seen this same thing on other benchmarks. What is Vue doing that Angukar/React are not doing? And more importantly, when will React include some of that secret sauce? ;-)
You are definitely biased. Most ubiquitous one after jQuery is angular 1. React is more hyped and talked about, but angular 1 is most used.
BS. On vacation recently I read through the React and Vue documentation. It took way more than an hour to read through the docs. Afterwards I totally understood Vue and had a simple app up using single file components in an hour or so. But after reading the docs I'm still confused about React. It is much much more complicated than Vue. Maybe Vue just works with my brain better, or maybe the React docs suck, but I ended up going with Vue and so far it has been nice. 
That's okay, I don't support IE. 
&gt; Does it needs to be in the client side? Yes (otherwise I'd just use moviepy). &gt;If the size or performance isn't a problem then just follow the ffmpeg tutorials I linked. You linked to tutorials for the original ffmpeg, not anything for video editing on the client side.
One thing is that vue afaik will identify parts of your templates that are basically static and never change, so it will ignore these during diffing. I believe they also do quite a bit of cashing etc. (I watched a talk by the creator of vue a while ago, may misremember)
&gt; One thing is that vue afaik will identify parts of your templates that are basically static and never change, so it will ignore these during diffing - https://github.com/facebook/react/issues/3226 - https://babeljs.io/docs/plugins/transform-react-constant-elements/
Why would someone not want to rewrite the same app in 5 different languages when 90% of the code is shared?
Ah okay thank you a ton.
Yeah, that is a bit of a shock though considering that react is somewhat poisoned by the terms that Facebook has added to it. https://news.ycombinator.com/item?id=11270213
Hah what the hell is this :D That Google simulator demo?
My work migrated from 1.x to 2.0 and it is much more complient to work in team with angular2
Noticed that as well..
That is fine, as i said, nothing against employing technologies that shave off bytesize or pre-cache. But Google thinks this is overall the direction the web is headed to, the dom driving apps everywhere and they're pushing for this for years now with one failure after another. Making web apps more effective should be considered "normal" anyway.
There's been [a talk by the Inferno creator](https://www.youtube.com/watch?v=djOc1EK07Tk), Domenic Gannaway, which now works on React. Inferno used to be the fastest in these micro benchmarks, they're fluctuating each time. He claims that by catering to micro benchmarks they even lost performance in real world applications because the criteria is completely off and sometimes even irrelevant. You can optimize against writing/deleting/updating thousands of rows every frame, but it's questionable if this is going to make any difference at all in a real world world application. The fact is that any web app today looks poor compared to a native counterpart despite the optimizations so you'll not see React invest into it too much. React Fiber on the other hand will make an actual difference. You can already play with the alpha and [run some demos](https://twitter.com/hollyglot/status/841364072972992512). It employs technologies like visual occlusion, render priority, deferring, async rendering, async components, chunk rendering, etc. These are some of the things that make native apps perform as fast as they do. Fiber probably won't be the fastest in these benchmarks either, but it will yield the fastest web apps, probably close to native performance one day.
Detailed explanation of how the most fundamental data structure of JS works.
I think the article is a bit over dramatic. AMP isn't meant to be the end-all and be-all of web development, it exists to solve a very specific problem: How to have a fast mobile website when no custom JS is needed. This isn't the first time that google pushed better engineered sites to the top of the results. I don't think this is an attack on the democratic open web, at least no more than usual.
It's not Java subreddit. You're aware of it, yes?
&gt; "NPM" on my resume Why even put it there?
just when I thought javaslangs rename to vavr couldn't get any worse.... it has with people imitating it. 
As a developer, how should a good documentation look like? What info are you expecting to find, in what order? What should a documentation never miss?
&gt; React Fiber on the other hand will make an actual difference. It is still just an idea, there are still no evidence that tradeoffs that were made by making scene graph synchronization pipeline nondeterministic are worth it, especially in web environment with many edge cases.
&gt; Could you maybe explain why using memoizee (or I guess any other similar chaching solution) is bad? It's not, don't always listen to the guy who shouts the loudest :) There are good use-cases (re-use objects that are fetched from an external system across requests, cache slow computations) and bad use-cases (you probably shouldn't replace HTTP caching with memoization) but at the end of the day it can be used, even in production. And the police won't arrest you :)
Thanks
Thanks
There is no difference, because classes are just an abstraction, syntactic sugar for what was already built-in within the language since inception. Many JS devs think classes should be avoided because they behave in a different way from classical inheritance. In classical inheritance when you create an instance, that instance inherits from the class blueprint, but from that moment on, it's a completely new copy, whereas in JS the copy is still linked through the prototype to the "Class", leading to confusing results. You can learn more about classes in this github repo (https://github.com/joshburgess/not-awesome-es6-classes ) and on this excellent article by Eric Elliot (https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9). 
And badly written code is the reason the multitude of frameworks and libraries exist. Cause most devs don't learn how to code and only want to plug in other people's stuff to do it for them. Then, when they have to write their own, they can't or do it poorly.
Yes. You can already experiment with some of it, chunks, some basic culling practices, without going into async internals. I recommend following Sunil Pai on twitter, he's got lots of examples that you can incorporate or learn from. From what i've read the focus is compatibility first and new patterns in phase 1, phase 2 will switch Fiber to async to greater effect.
dropping the slowest 2 and fastest 2 out of the 20 and averaging the rest makes more sense i think.
i use an autoinjected javascript bookmarklet to theme all of my webpages and AMP destroys that functionality, blinding me with nasty white user interface. i *hate* AMP
PHP and application architecture are vastly different concepts.
I like Vue a lot. It's much easier to understand and reduces the React boilerplate a lot. At the same time, it doesn't really come at the cost of performance or flexibility.
Read and understand the "you don't know JavaScript" series 
`class` is a newer syntax (ES6+) while the constructor version has been around since the beginning. Given that, you won't see `class` used as much, especially in older code. But newer code will likely be using it a lot more because its more concise and (imo) easier to read. Neither are necessarily more efficient than the other, at least not in any sense that will matter. They mostly do the same thing behind the scenes aside from their differences: * `class` syntax allows usage of additional keywords such as `extends` and `super` for extending other classes, and `static` for specifying static methods. * `class` uses the shorthand method syntax in method definitions (methods differ from other functions, for example, in that they are not, themselves, constructible). * `class` bodies are inherently evaluated in strict mode. * `class` definitions can not be redefined where as function constructors can. * `class` declarations are not hoisted where as function declarations are. * `class`-defined constructors are not callable as functions. This creates an incompatibility between classes and constructors. While you can have a class inherit from a constructor, having a constructor inherit from a class causes a problem because constructors do not support `super` and due to the fact that class-constructors aren't callable, you can't call the class-constructor in the context of your subclass instance for initialization. * `class`/`extends` syntax automatically takes care of the additional boilerplate that not everyone does with constructor inheritance, such as fixing `constructor` as well as implementing static inheritance between the constructors themselves.
So what would you recommend me on getting used to? What should I use and prefer? 
You can try this software ( www.classicpdf.com ) this is paid software but you can avail trial version for your current needs.
As I looked at your class, I didn't have any immediate recommendations for how you can adjust it. The reason: you're managing state, and at the end of the day your side effects will have to live somewhere. In an ideal world, your functional code would be free of side effects, and in a less than ideal world you try to contain them as much as possible. In its current state you have: * `constructor` initializes mutable variables * `loadIdentity` mutates state from an IO source (localStorage) * `saveIdentity` persists to an IO sink (localStorage) Without fundamentally changing _what_ your class does, I don't see much room for improvement. I applaud what you're trying to do but this may not have been a low bar to target. Both mutation and IO are mud in the water, but to be clear that's not a condemnation &amp;mdash; you're obviously trying to solve a particular problem, and employing the appropriate tools.
Thank you for your feedback, and explanations. Essentially, this Store is a base class from which Stores are extended - ie a User store, and such - that implement things such as "setDefaultState", as well as any number of additional functions (setUserId, or whatever) - that then call back the update function in their base class. Components then import these singletones, and connect on mount / disconnect on unmount. And the update function hooks into those components and lets the component then manage how it will handle the "state" change of that particular store. 
***Let's make everything a blog post!*** 
They are focusing on their own self pleasuring.
It would be very inconvenient (for the lack of a better word) to "marry" OO classes/inheritance/patterns and functional techniques in one system. A functional approach would be to use just one store, which is passed to all of your components, that holds dumb data (i.e. arrays and POJOs), and introduce a constrained "language" for getting and settings parts of your specific store (i.e. Flux pattern; see Redux for actual implementation). If you feel that OO makes more sense to you, take a closer look at Angular — folks over there have been experimenting with applying some of functional techniques to OO, without going full functional route: there are common fundamentals that both paradigms share when it comes to writing maintainable code, so you can learn them in either realm.
[This is a nice overview](https://learnxinyminutes.com/docs/javascript/)
Thanks for the mention! All my books are free to read online and specifically targeted at programmers. They explain the full language (up to ES5, then what’s new in ES6, etc.): http://exploringjs.com/
build something. Also give rxjava a shot since you are probably stuck in an OO mentality. Also typescript. Try avoid getting sucked into the whole npm/node/tool/framework deJour thing and keep java around for the server side.
IIFE classes are still best imo. const Person = (function Person () { let name = "Bob" function Person () { console.log(name) } return Person.prototype })() const person = new Person(); Only method to actually have private methods. And uses FP which is miles ahead OOP
It doesn't mean anything. &gt; What React Native means for Swift/Objective-C community Nothing. &gt; What WebGL means for Unreal Engine Nothing.
This is where you start. Javascript is Weird...and AWESOME: http://www.youtube.com/playlist?list=PLoYCgNOIyGABI011EYc-avPOsk1YsMUe_
You still need to know intimately JS in order to write great code in JS. True, some programming skills are impervious to any language but at the end of the day you're still using a specific language and you better know it well in order to do a good job.
I hate learning through videos. Hard to copy-paste the examples from the screen 😜
This book is a good source for advanced JS patterns. http://chimera.labs.oreilly.com/books/1234000000262
also "Javascript patterns"
You can lead a horse to water...
For YouTube, you'll need to listen for the `spfdone` event. So, change your script something like below. function processPage() { //put your code here... } addEventListener("spfdone", processPage); processPage(); And set the `run-at` metadata to `document-end` (`document-body` is not a valid value, BTW). If you need to use `document-start` you'll need to replace the last line of the above code with: addEventListener("load", processPage); 
I recommend [this](https://www.packtpub.com/web-development/nodejs-design-patterns-second-edition) book. It is really very good, doesn't talk down to you and assumes you're a competent programmer with a respectable experience. 
It clearly demonstrates how much of an impact it can make to defer tasks that are deemed visually less important. In the example it prioritizes the overall graph over the expensive item-counts and thereby maintains a stable framerate. This is next to impossible in todays frameworks. Try that anywhere else, they would all choke on it despite grades in benchmarks. That items should get a lesser priority because they're not in view, expensive to build, or doing stuff that keeps an overall scroll or animation from executing fluidly, that happens *all the time* and that is precisely why web apps are unable to maintain 60 frames per second. To finally nail that is one of the purposes Fiber's been built for and even the earliest demos show that it can pull that off. 
Your second example probably shows a greater difference than you think.
Some other milestones: * Read at least a few books on the subject including Crockford * Publish at least 1 useful npm module * Cheat at a JavaScript based game that has obfuscated code * Come up with a 1 sentence description of JavaScript that explains all the features of the language * Be able to bootstrap a simple SPA with DB, Back and Front end in under an hour * **Most importantly! Teach someone else JavaScript** Also, when you feel like you could provide an intelligent answer to your own question here you are likely either a master or starting to become a master.
Yeah... peerjs sort of ... stopped years ago. To bad it was awesome. Moved to simple peer with own signalling and its been wonderful Wonder how reliable this truly is. I mean having that many links in the chain would cause some inevitable problems left and right. Guess it would be awesome for non prime content (or fraudulent streaming sites). Side note: Mediasoup provides a great "old" way of scaling stream by having the server redistribute it. Its just like another peer. 
Have you given it a try yet? VS Code has excellent ES6 &amp; Typescript integration out of the box, and has a pretty good assortment of file icons also. They are very quick to update to the latest TS versions also. The TS integration is great, even in JS-only projects, because VS Code automatically downloads the typings (when available), and uses them to give you autocomplete hints. You can even enable type checking of your JS files, enabled by the latest TS releases. Because of how fully featured it is, the only plugins I have installed are for other languages (like Elm, Elixir, ...), ESLint, and Vetur (for Vue.js single file components).
I'm not sure what you mean. It is supposed to check, if you understand when the callback function of .then is run. So in the first one, doSomethingElse is run after doSomething was fulfilled, in the second one immediately. BTW: it's an almost classic example by Nolan Lawson, described in this article: https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html
Of course, they are easy to test using the console. Maybe it would have been clearer, to ask "What level of JS knowledge is needed to answer this question in an interview environment?". In other words: do you understand why it happened?
Oh, so that was intentional: I had thought the difference was intended to be between passing in a particular function and passing in a function that wraps a call to that function; one example looked similar to a mistake that many beginners make, of passing the output of a function call into `setTimeout` when they meant to pass the function itself.
... but what would be best? Having a few skyscrapers in a few sub-districts, or as much sub-districts as small blue buildings, all of more-or-less the same height?
What would be the reason to drop the fastest 2?
I would google Kyle Simpson he's great. He has several intro courses designed for people like you introducing the language not programming on a site called www.frontendmasters.com 
For new and unfamiliar functions, people usually rely on type signatures to get an idea of what functions expects and what it will return: it can be either [Haskell-like syntax](https://sanctuary.js.org/#types) with `::` (can be read as "has type") and `-&gt;` (which is "function from {left type} to {right type}") or TypeScript/Flow. For common functions, you normally know that they expect/return a function (like `map`, `reduce`, `filter` or `always`, `flip`, `pipe`) because you already seen their signatures and used them. It's important to note that people in FP world value generality *a lot*, trying to distill the essence of pattern into a function, so when you learn that function, you normally can apply it in many different cases. In practice it means that after initial introduction to FP world, you only occasionally have to look up function documentation, which it isn't that big of a deal.
&lt;offtopic&gt; [Custom JS-logo](http://i2.wp.com/codingraptor.com/wp-content/uploads/2016/02/pic-web-javascript-logo.png) derived from the Java-logo. Uh oh. I don't like where this is going... &lt;/offtopic&gt; 
`// replace with alert or document.writeln if desired` I _really_ don't like where this is going.
Can people who down vote this explain why? 
The configuration in the webdriver allows to drop the slowest n results. I used to do that in earlier reports of the framework, but decided against keeping this practice. I had the feeling it reduces the reported variance leading to a wrong impression of the precision of the reported values. Instead I went and doubled the number of runs. Dropping the fastest makes no sense to me, unless we assume the browser can cheat. Instead it might make sense to report only the fastest run. But of course e.g. when a full garbage collection or compaction occurs just in some runs you'd neglect that cost, though the user would sometimes run into such a long garbage collection. All in all I like the current way best ;-)
It was cool seeing a demo at the end made using Choo. Choo is my favorite in the current sea of react clones. I like it because its tiny (4k vs react's ~200k). Choo supports server-side rendering. And its made out of smaller modules which are all independently useful (DOM generator, diff engine and router). Instead of using JSX files, choo uses ES6 tagged template literals. As a result the code doesn't need a compilation step at all. But you can still actually compile the templates if you want for better performance + a smaller JS bundle in production. Its great stuff. I'm a huge fan.
Thanks a lot! 
"Want to be good at JS? Learn Haskell" 
http://www.libtorrent.org/dht_store.html could be of interest for this project. It's a proposal for an extension the bittorrent to store arbitrary data. Through this it could be possible made possible/easier to create a livestream. Sadly it's (afaik) only a proposal, but I think it's a very interesting one.
You most certainly can, working on an app that does just that. 
There is https://github.com/xuset/planktos which is using the same technology
I think that's worthy of its own post on here, very cool.
1. You can't call `new` on the prototype. If you run this code, it dies with a TypeError. 2. The private var is scoped to the class, not an instance, which means there would be only one "name" shared across all instances. 3. FP and OOP are complimentary. Neither is miles ahead. 4. I don't know anyone who would agree that this is FP.
I just got done going through a month worth of interviews... Unless you are looking for a new job, I would avoid doing it. Every interview (except for one) was at least 3 hours long, with one being an entire day. Except for the all day one, all of them were poorly conducted and we're just asking questions you see by searching Google for "javascript interview questions". I did learn a lot about my skills with the all day interview, but outside of that, it was a waste of time. I would recommend the following: * Build up a public report showing off code. It doesn't have to be a full product. Tackle Computer Science topics, and include tests. Any potential employer can see your code this way and know you do proper testing. * do something like the todomvc site. Use a nodejs base, implement the same sample site with multiple frameworks. Include testing, and bench marks if possible. * Have a readme for everything that explains your goal, why you did what you did, and any relevant data to back it up. * Use ES6 for everything * Write a babel plugin. Get familiar with working with the AST. Doesn't have to be useful, just a demonstration that you understand it. * Write a plugin for webpack. Same as above. * Read the JavaScript Definitive Guide book. Start to finish. Have a repo where you include all your code from working the book. * Create an account here that you consider public. As in you wouldn't mind having your name associated with it. Use it strictly for coding, and review work posted in learnjavascript, along with posting your own for review. * Learn Typescript (this is quickly becoming very important) Also, create a job search on LinkedIn for senior JavaScript developers. See what companies are looking for. Review often, make sure you are working those skill sets. Edit 20 minutes later: I forgot to add, start mentoring someone. Fielding questions from people who are learning is a great way to learn more about the language yourself. You would be surprised about the number of things it exposes in your knowledge.
Irregardless of weather or not setting candidates this sort of thing is a a good idea or not, you can be pretty sure Reddit is not going to solve it for you. Perhaps if you come back with your attempt so far and ask for help on specific things you don't understand. If it helps this seems like a fairly straightforward task if you are familiar with programming/javascript.
I'm fairly new to programming. I have a degree in IT so I know the basics of a lot of stuff. I just don't feel I know where to begin with this
http://www.nightmarejs.org/
That only serializes an object to hal-format, which is about 10% of the features I want. But thanks anyway, I appreciate you trying to help me. :-)
I'll also throw out a recommendation for eloquent JavaScript (free on github, but I'm on my phone with kids running around so I'll let you google the link). I was kind of in your boat - CS major worked in a different field for a decade. I took a Bootcamp, and it's been great but shouldn't be necessary. Might be worthwhile to look up one of the free boot camps and work through the curriculum/exercises. 
BTW there is an error in survey because this is not runtime error (as survey suggests) but syntax error. It doesn't even parse.
So you'd rather everyone rewrite the same code over and over again? Do you not see how ridiculous that is?
Thanks.
I gave it a try around 3 times last year, but it's been 4-5 months since I've last given it a shot. I downloaded the latest Insider build last week, but haven't gotten around to installing it again. I'll give it a go later today or this evening and get an idea about what might be missing. thanks!
Isn't that the point of this problem? To determine whether or not you have the skills necessary to do the job? In which case the answer would be no, you don't yet. I'm also fairly new to programming, and I can remember a time where I'd be stuck in the same place as you with this problem, but now I've had more practice and can conceptualize the solution and start developing a roadmap to complete it.
Something called "web scraping" can get information from any HTML page - it's much too complicated to explain via reddit, though. Look it up. Most likely, though, websites will have an API you can use that will actually return JSON. You'll have to look for the site's API. Facebook's developer documentation can be found here https://developers.facebook.com/
And now one of those devs speaks up.
and still no native import/export :(
Was looking at the change notes for exactly this. Sad times.
sorry edited it... I didn't screw this up in the project... Otherwise it probably wouldn't work at all...
Any reason for creating Altair as opposed to contributing to the Graphiql? https://github.com/graphql/graphiql
didn't mean to write on a .txt on my computer. It would be a .txt that is on my repository, at the same folder as the .js file 
This is one of the main reasons why such an exercise is important, because nobody wants to debug 2000 lines of code. When asking for help, you should really make every effort to make it as easy and painless for others to help you (otherwise, they probably won't be bothered to help if it's too much trouble). Ideally, you will reduce the code down to a test case that contains the minimum amount of code required to reproduce the problem. Doing so makes it much easier to diagnose the problem and provide assistance. This can be anywhere from 5 to 50 lines, but any more than that and you probably didn't reduce it well enough. However, as is often the case, in the exercise of whittling the code down to a small reproduction case, you discover what the actual problem is. This happens _a lot_ -- I'd say 90% of my problems that I consider posting, I've fixed myself after trying to create a solid reproduction.
Yup, I was in the same boat so decided to write one up myself. Hope you find it useful!
It's a hard problem to solve. See https://medium.com/the-node-js-collection/an-update-on-es6-modules-in-node-js-42c958b890c
Yeah, I know, but still there was a hope.
The class syntax is a lot more readable than the classic function/constructor syntax, as soon as you add methods. If you don't have to support legacy browsers, go for class.
Look at what I wrote down please
&gt; strive to master software engineering at a high level Do you have any resources — besides experience — that you would suggest for improving in this more general area?
&gt; Most importantly! Teach someone else JavaScript I think this is a wonderful and often neglected means to strengthen one's knowledge for a subject.
One approach I have experimented with is emulating the terminal in the browser by connecting to a node backend with sockets. When a command is sent from the browser to the server it is executed with process.exec(), and any output from stdout is sent back to the browser to display. This backend doesn't need to run on your terminal server, just on a server that is able to connect to it. I started implementing this with a React frontend to use for running dev scripts from within the browser, if you are interested there is a repo at https://github.com/alsiola/npm-web-console which (I think) is just about functional
It's in canary and safari if you wanna play with it ahead of time 
If you'd read that article before, you'd have seen the last paragraph that said: &gt; At the current point in time, there are still a number of specification and implementation issues that need to happen on the ES6 and Virtual Machine side of things **before Node.js can even begin working up a supportable implementation of ES6 modules**. Work is in progress but it is going to take some time — We’re currently looking at **around a year at least**. (Emphasis added)
Async/await was added in 7.6. https://medium.com/@eli.goldberg/async-await-is-here-node-7-6-0-9f5a9904eb41
"How do I manage my versions of Node? Oh, nvm, I figured it out."
Also Winamp. And PHP!
My bad, the example was not clear enough for real world case which actually fluctuates below 10fps due to complex design requirements. It is usually `~90ms blocking EVERY FRAME` vs `3ms`+(fully responsive inbetween)+`3ms`+`3ms`... totalling `110ms`. Even before react fiber, any sane developer had done this kind of thing. Just the same reason why we have Splash screens. **Without it, sometimes UX gets REKT so hard that you cannot ship it.** Real world apps, such as, Virtual-List with 1k~30k contact thumbnails, pseudo scroll-boxes that requires non-linear trajectory by spec, real time drag-drop SVG elements, loads of `Animated.interpolate()`s etc. even `componentShouldUpdate`s cannot help them. The world is not a simple todo app. In fact, if you have ever shipped a real product you don't want ANY jank under any circumstances. 60fps FTW! :p Oh and this is not limited to web, it's the same with `react-native`. 
&gt; It is usually ~90ms blocking EVERY FRAME It is not that simple as you think. First of all we need to understand where ~90ms are coming from, if it is a js execution time and it is not framework overhead time, then you got serious problems with your application code base. From my limited "simple todo app" experience :) 90ms are usually comes from "recalc style", "layout" and "framework overhead", and Fiber just won't make any significant difference, it still has quite big "fw overhead". &gt; The world is not a simple todo app. In fact, if you have ever shipped a real product you don't want ANY jank under any circumstances. 60fps FTW! :p Yeah, I guess you have way more experience in this field than me :) Nice argument, can't argue with it.
I came here to ask this same question for my wife. I was so pleasantly surprised to see our exact question already asked here so recently. Thank you all for the great links. Wife is now sitting here watching a free video @front end masters. Probably going to end up signing up for the monthly access there. Our local library didn't have much for JS.
they aint even angular bro
we'll have ReactOS ([not that one](https://www.reactos.org)) first
so he typo'd one letter and added a "d" to an and you are calling him out for that. Now you are just being a twat. Why be a dick when you could just either not comment or actually try to help?
100% serious. They had a router at version 2 which ended up getting scrapped for version 3 that everyone used with angular 2. With the next major angular release they decided to push everything to 4.0 for consistency
I didn't see the typo till you pointed it out, if he is experienced with java he should be able to build something in js in short order. It wont be pretty but it will be experience. Not really sure what is up your ass though.
Worked well for IBM.
My article :P
seemed like you were calling him out in your quote above for the typo and being snarky about it. Whatever though. I can let it go. 
Well it certainly wouldn't pass linting. 
MPJ on YouTube has some solid videos on object creation, explaining how and why it differs from ‘classical OOP’ paradigms. http://www.youtube.com/playlist?list=PL0zVEGEvSaeHBZFy6Q8731rcwk0Gtuxub
Look for ‘synonyms’ like “js“, “node” and perhaps things like angular, react and such and see the graph rise. 
As someone who hasnt touched node yet is this a big deal?
It's not javascript itself. It's rather libraries and frameworks that are getting more popular.
What's up with this title?
CJS is non-standard JavaScript. The `import/export` syntax is the standard being adopted in browsers and should be adopted in Node as well. If we're not getting Node to at least adhere to JavaScript standards then what's the point?
I take it you didn't read this? https://github.com/facebookincubator/create-react-app/issues/2398#issuecomment-304638935
Just to check because this is super easily over looked, do you have a base tag in your index html? 
Thanks for your contribution, I'd like to know what do you think of this article then? https://www.barbarianmeetscoding.com/blog/2015/12/28/black-tower-summoning-object-composition-with-mixins/ Is this a plausible way of using Object Composition?
What do you mean by "event is completed"? Events in JS just occur, they don't last. When event occurs, corresponding event handlers are executed. `addEventListener` is a way to register your function as event handler — that function will not be ran until the event actually occurs. It's similar to how `setTimeout` works — you give it a function and `setTimeout` sets up a delay to run that function later, but your program doesn't get paused for a duration of that delay and other code can still be executed. If you want to understand how this mechanism works better, Philip Roberts' [*What the heck is the event loop anyway?*](https://www.youtube.com/watch?v=8aGhZQkoFbQ) talk is a good place to start.
This clears my doubt. What I meant by "event is completed" was that it waits for the event to occur then it compiles the event handler function.
An idea could be to use the github api to push on an other branch on the same repo
https://trends.google.com/trends/explore?date=all&amp;geo=US&amp;q=javascript,programming
My favorite quote from Bill Gates goes something like "Measuring programming progress by lines of code is like measuring aircraft building progress by weight."
Yarn is still quite a bit faster. We don't see any reason to transition back to npm. In fact, @maybekatz who works on NPM5 just recently did a PR for yarn that made it even faster. :) Async is a big deal, but it was in 7.x, too.
I recommend using nvm. It's much much easier to switch among versions. Super easy to setup, too. Just cut and paste their shell script from nvm's github page ... then nvm install node.
I just played around with async/await yesterday for the first time and it's glorious. I thought it would be some black magic voodoo thing but it's actually super easy. [Here is a nice presentation that explains how to use it.](http://rossboucher.com/await/#/)
It's a server thing. With Apache you'd need to use mod rewrite to redirect unknown paths to index.html. I'd recommend you to just use Firebase hosting for your SPAs. The free tier is amazing and gives you CDN and SSL for free. You can also configure all sorts of redirects with a simple JSON file. There are other static file hosting services oriented towards SPAs such as [Netlify](https://www.netlify.com/). You could even use S3.
Does it come with NPM 5? Edit: It does.
Some joke about reduced package size after bundling 
You're welcome to start the rewrite: https://make.wordpress.org/core/
ur kind of right it, tabs are single threaded usually, and the page stops rendering while the `&lt;script&gt;...&lt;/script&gt;` text is parsed. so people usually put it at the bottom of the page before `&lt;/html&gt;` the eventlistener is a trigger, that then stops the page from rendering and executes the callback function code on that event (but hopefully is asyncroneous? Not sure!) both have a small pause
&gt; how does garbage collector decide when to collect garbage That's actually pretty basic. It just [counts references](https://en.wikipedia.org/wiki/Reference_counting) to the object.
ui router is a third party module for AnggularJS (1.x). I'm referring to @angular/router which entered final at 3.x when the rest of Angular entered at 2.x.
FFMPEG is an encoder/decoder. You need to figure out how to "add" the videos in sequence, and then send that to FFMPEG to encode it. I don't now much about video, but an idea could be to export your videos to a sequence of images, pick the frames from each video you want, and then [encode that](http://hamelot.io/visualization/using-ffmpeg-to-convert-a-set-of-images-into-a-video/). This seems quite rudimentary but it should work. Honestly, doing this on the client is a terrible idea. Performance will be crap.
&gt; Unfortunately the Language Benchmarks Game no longer make nice graphs which are easy to analyze at a glance… Unfortunately nice graphs make foolish conclusions easy. The nice graph you've ripped out-of-context does not even allow analysis, because we cannot see what tasks were done or how the programs were written.
Nice work. Probably a good start for anyone interested in GLSL or after looking at this https://github.com/stackgl/shader-school
I'm writing a Reddit comment, not a PhD dissertation. FYI, all the tasks and sources are available on http://benchmarksgame.alioth.debian.org/
What's wrong with it? Seems pretty clear to me
I would like to know how it compares with stuff like bower, or even npm when used for browsers. Also, some example using babel/ES6 imports would be nice.
(original question)`How does the Garbage Collector decide, if it should free up a given memory location?` Maybe you're right, but when I looked at this question I imagined internals of GC and exact moment in which GC kicks in V8 or other engine. I didn't even think about such obvious answer :) 
Looks like author is having some dns issues... [github repo](https://github.com/gl-transitions/gl-transitions) is here, or [alternate link](https://gl-transitions.netlify.com/) to website.
Yep, it worked with nvm.
 var zonk = {length, width, depth}; ?
If that all you use that object for, then you can do something like const widget = (length, width, depth) =&gt; ({ length, width, depth }) // or function widget(length, width, depth) { return { length, width, depth } }
Can't I just use jQuery to get the informain like so: console.log($("#pageTitle").text());? And how do I apply it on a specific URL from another page?
no was providing a simple class example focusing on the relevant parts.
Interest is based on search volume
Technically, no, but from a marketing and user standpoint yes.
In that case — no, there's no syntactic shortcut for assigning properties to `this` in constructors. You could (ab)use [`Object.assign`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) however: function widget(length, width, depth) { Object.assign(this, { length, width, depth }); } var zonk = new widget( 4,5,6 ); //=&gt; widget { length: 4, width: 5, depth: 6 } I would advice against it though — this is far from idiomatic code.
The closest you can get that I can think of is function widget(length, width, depth) { Object.assign(this, { length, width, depth }); } This assumes that whatever environment(s) this code runs in will support ES2015 shorthand property names. 
That too is ***not*** object composition. It's multiple inheritance. For example, here it is in Python, which natively supports multiple inheritance. class canBeIdentifiedByName: def toString(self): return self.name class canCastSpells: def castsSpell(self, spell, target): print(self + ' casts ' + spell + ' on ' + target) self.mana -= spell.mana spell(target) class canSteal: def steals(self, target, item): print(self + ' steals ' + item + ' from ' + target) class canPlayMusic: def playsMusic(self): print(self + ' grabs his ' + self.instrument + ' and starts playing music') ## class Wizard(canBeIdentifiedByName, canCastSpells): # &lt;-- multiple inheritance def __init__(self, element, mana, name, hp): self.element = element self.mana = mana self.name = name self.hp = hp class Thief(canBeIdentifiedByName, canSteal): # &lt;-- multiple inheritance def __init__(self, name, hp): self.name = name self.hp = hp class Bard(canBeIdentifiedByName, canCastSpells, canSteal, canPlayMusic): # &lt;-- multiple inheritance def __init__(self, instrument, mana, name, hp): self.instrument = instrument self.mana = mana self.name = name self.hp = hp Just ordinary classes inheriting from other classes. Later in that article series, they cite Eric Elliott as their source, so it makes sense that both MPJ and that JavaScript-Mancy series got object composition wrong in the same way that Elliott got object composition wrong, because they both learned from and regurgitated Elliott's wrong information.
There are two projects working on this https://github.com/benjamn/reify &amp; https://github.com/standard-things/esm
okay thanks. is it smarter then to pass the constructor an object? and do a generic loop to assign the properties of the object?
okay thank you
Php6
And you wrote *"nice graphs which are easy to analyze at a glance"* -- which is not true. 
If the site you need doesn't already have an API, what I'd do is create an API (using node.js, or python, or whatever you want) that will web scrape on demand, and return the information you need in JSON format. You'd have to host that service, but it's much easier to deal with (and much less client resource intensive) than web scraping with jQuery (also, most of the time you don't need jQuery... Javascript has advanced exponentially in the years since jQuery was made) in your client's browser. If you're trying to do something with Facebook or any other site that has a public API, though, use that API. It's much easier. You don't need to scrape.
Log out `arr` and you'll get (something like): Array [ &lt;3 empty slots&gt;, "covfefe" ] This has nothing to do with "covfefe", but works with any value - even `undefined`. I'm frankly not sure what you are surprised about.
Why would an offsite link be relevant to the rudeness of gaearon here to sunsetfantastic? 
This project is fairly old, and was one of the main competitors when bower, jam and jspm was hot stuff. I wouldn't use Ender on new stuff in 2017.
https://media.giphy.com/media/ADr35Z4TvATIc/giphy.gif
TypeScript offers syntax sugar for this with classes: class Foo { constructor(public x, public y) { } } // compiles to: var Foo = (function () { function Foo(x, y) { this.x = x; this.y = y; } return Foo; }()); ```
Knowledge of vanilla JS is a great plus(if you know your way around JS then you know how to most stuff frameworks do). If you are thinking moving to Vue.js then go for it. It is easy and powerful definitely a good choice. Angular, is more complex, and react is very similar to Vue but with a larger number of developers and resources (being older than Vue). I suggest trying Vue, there are good resources out there (book, tutorials, articles), I believe you ll be surprised.
Does this need to be a web site? If you used Electron you could probably use FFMPEG natively from Node using the C library. https://github.com/fluent-ffmpeg/node-fluent-ffmpeg Edit: also [this](https://medium.com/@brianshaler/on-the-fly-video-rendering-with-node-js-and-ffmpeg-165590314f2)
That's too many pages 
Far, *far* too many pages. And, judging by the sample, most of them are crap.
lol, I appreciate the effort, but it's too much, and really looks like crap
Yes this needs to be something a user to a website can use.
(: the best kind of correct
I kinda disagree. I prefer to have more detail than less, and screenshots help me. I'm fine with lots of pages if most of them are screenshots compared to reading a 500 page tome. When technology changes, you can compare your screenshots and get an idea that the books instructions are outdated and where to play around to get to the next step.
concise and clear. thank you, very useful reading
If only it had Machine Learning and 3D rendering with WebGL, I'd buy it
Most of those screenshots (e.g. the `composer install` output) only needed a few line snippet to get the gist of what's happening.
I suppose the first question is, how do you want to ship this component to your users (which could be yourself)? If you want to do it in an oldschool vanilla Javascript way, your component would ship as two files, a `.js` file and a `.css` file. The user includes both files into their page using `&lt;script&gt;` or `&lt;link rel="stylesheet"&gt;` tags. Now, to actually put a copy of your component somewhere on the page, your users might call some kind of `makeMyComponent` function, which does a bunch of `document.createElement` calls to build up your component's HTML. Between the styles provided by your CSS file, the HTML structure built by your `makeMyComponent`function, and any event handlers you hook up in your Javascript code, you now have a component! At this point, developing the component looks no different from developing any other web page. Of course, there are more modern ways to do this. For instance, the Polymer Project (https://www.polymer-project.org/2.0/start/quick-tour) lets you define custom HTML elements, so you can put a tag like `&lt;my-compoent&gt;` right into your page's HTML! This is arguably a lot easier to use than manually calling a function like `makeMyComponent`. They also have templates, so you can write your component in HTML-like syntax instead of a bunch of `document.createElement` calls. The React project takes a completely different approach. In their model, "creating a component" is just defining a function or a class that takes some input and returns a bit of HTML. Your component can include other components seamlessly, and other components can include yours as well. React uses something called JSX, which allows you to put HTML-like syntax right into your Javascript code: function MyPrettyButton (props) { return &lt;button&gt;{props.text}&lt;/button&gt; } Later, somebody else can just do `&lt;MyPrettyButton text="hello" /&gt;` in their Javascript whenever they want an instance of your button.
A good way of keeping things understandable is to separate the data and logic that powers that component from how that component is rendered. The logic can be tested a lot easier than rendering and if things are decomposed well the rendering can be pretty simple. Take a look at MVVM.
You might checkout the flame charts in the chrome debugger. It will show you a stack of which functions call which, and how long each takes to execute.
... lol. 
DUDE WEED LMAO
https://Fusetools.com is still best and native
I've been trying to use Facebook's API but it's tough. I want to get the Full Name and link to the profile picture from a profile's URL. (Like I wrote above). I can't find how to do that...
front-end frameworks *for the most part* (vue, react, angular etc) are pretty straightforward and have big enough communities that it's really easy to get help when you get stuck. In my opinion the better you get at "just going for it"--trying stuff out, hitting the wall, debugging, getting help, writing tests etc--the faster you'll climb the learning ladder. As a pretty extreme analogy, say you wanted to learn calculus but didn't have a lot of math experience. You'll figure out pretty fast that it's hard and you might need to brush on some basics, but you'll have learned that quickly and on your own instead of always wondering. So yes! Absolutely go and learn whatever you want, just keep in mind that you'll need to occasionally train on the smaller pieces of the whole (JS stuff, algorithms, design patterns, web tech, graphics etc)
Has anyone ever managed to actually read a book about programming ? because I haven't. I can read chapters. I can refer to books for something specific. But I never managed to sit down with the book in the hands, and read it like you read a novel.
thanks for the effort but seriously no serious developer is gonna find value in that given the constantly changing javascript environment and community for me it would be way easier to just google what I need off any of those libraries 
Get your hands dirty. Define what you want to build and go for it. Just start and you'll learn a lot from the mistakes and errors. 
Haha, you are right!
I can read stuff that is fairly technology agnostic like Clean Code or The Gang of Four book, but not something specifically meant to teach a technology.
This is one of the more difficult areas of browser development. It will require a good understanding of the DOM API, CSS, JS as well as what features of those are available in the browser versions you're targeting, and various nuances and workarounds for each. Additionally you'll want to handle touch/mouse input, keyboard and other accessibility concerns like `aria-` attributes. You should look at the APIs provided by other 3rd party components - sliders, menus, calendars, etc. Typically they'll have some sort of initialization function that accepts a bunch of options and callbacks, as well as a cleanup/destroy method.
If someone offers me a free box of shit, I'm not going to take it just because it's free.
But it's not a box of shit. It's a 2000+ page ebook... listen, I'm not saying you have to like it or that it is even good but if someone devotes that kind of time, just give the guy props for offering it...
Didn't really realize it would be this easy. Looking forward to trying it tomorrow. Thanks for the post. 
I'm not specifically saying that *this eBook* is a box of shit, I was contesting your assertion that just because it's free we should cheerfully accept it without criticism. Although, that said, this does at least *resemble* a box of shit. 2100 pages of mostly useless screenshots trying to cover too many topics...Even assuming all of the content is good (which the sample didn't really lead me to believe), it should have been broken up into a half-dozen separate books. And it should have been heavily edited.
thank you, good observation.
ill pissv on you, free
Practical Object-Oriented Design in Ruby by Sandi Metz. Really pleasant read, gives you a lot to think about. I've gone through it a few times.
It definitely needs better indexing, but I read through some of the JS section and its not bad as a beginner text. It would be a good starting point for someone wanting to get into web dev imho. Yes things change fast, but he covers all the basics of the toolkits that really don't change all that often.
Thank you this advice helped me tons :)
I read Effective Java like that... 
ooooooooo - yeah! Wow - they got rid of the horrible stepping/rounding issue that effect always has!
Yarn is completely MIT licensed, has an RFC process for feature requests that even the core team follow, and we get majority community contributions/PRs. I went out of my way at launch to ensure it wasn't branded an FB project so I'm interested in hearing your feedback on why you think it's the case and why it's a bad thing.
https://docs.npmjs.com/how-npm-works/npm3-dupe covers it pretty well.
 for (var i = arguments.length; i-- &gt; 2; ) { This guy
Here's what I would do: * Read about basics of the JavaScript language * Start programming JS in the browser - show/hide stuff, form validation, etc. (just please if any tutorial mentions window.open() or alert(), run away...) * Learn basics of jQuery to see how much easier it is to manipulate pages with something more than just vanilla JS If you get here, you can continue with learning: * front-end JS frameworks such as React, Vue, Angular * server-side JavaScript: * Node (try some simple scripts first that you just run from the command line, you don't have to write web-servers as they always want to teach you in tutorials) * Express - that's a framework for building websites on Node
And... because it is an e-book, you can't easily wipe your your arse with it.
Hey there! It really depends what you want to do? While all of these big names give you different tools to accomplish the same things, these tools match different coding styles and different approaches. You can pick anything you think is reasonable. Some give you just the tools to create interactive UI, some other try to be the complete stack to separate the data and business logic. If you just want to have interactive UI, you could get started with RiotJS. In my opinion, this is the easiest to learn tool, to create interactive UI . Popups, Dropdowns, Filters, Sliders, Carousels, anything UI-related. There are even tools like mavo.io that allow you to create interactive UI just with html properties. But i prefer to have a little more control over the behavior. I agree that you should start with the basics though. A framework or library is only a set of tools composed of plain javascript. And you can learn basic javascript here: https://developer.mozilla.org/en-US/docs/Web/JavaScript However with any programming language: what do you want to do with it? All of these tools have one thing in common: you need to know what a Date object is and how to create one, if you want to display dates. You need to know how to structure data with arrays and objects if you want to create and manage listings of something. You need to know how to retrieve data from a server if you want to dynamically fetch and display data. You need to get a feeling for what you want to do, only then you can learn about the different topics. :)
somebody needs to make covfefescript
Hello tangerto. How complicated? From what you say, it doesn't sound that complex :) so cheer up. You don't need d3 or complex svg animations to create that component. Regarding all these frameworks: it really depends how you prefer your code to be layed out. So I bring in my own recommendation. For my components, I prefer to use riotjs - a lightweight and easy to learn tool (have a look at their examples: http://riotjs.com/play/todo/). Based on just css animations and some data, I can create any component I want to. What do you need for interactive UI anyway? Some event handlers, some understanding of css animations and how to combine these. Riot does offer an easy way to that.
I cannot thank you enough for taking the time to write this. Your post was more informative than any tutorial I came across. Sorry for posting on wrong sub. 
&gt; I'm not sure if there's a benefit to pulling the components out of the iframes or just leaving them there and encapsulating all my components inside iframes, but this may open up some new possibilities for web components. I feel the goal of components, in general, is to achieve the latter where they are encapsulated. Components should be ideally reusable but also standalone and independent (if I wanted to render it on a page, it shouldn't need to depend on other things that it doesn't just come with). Your first example sounds really similar to what ReactDOM essentially gives users the ability to do from the component level -- access specific dom elements or other components from components despite the fact their execution has happened somewhere else. In general, it's frowned upon as bad practice but there are practical cases I believe where you may need this to happen. I think it's an interesting topic though.
Looks like he just copied the W3C specs and such and rammed it into a book. 
I heard third will teach you how to talk to women. Not like we redditors would need it anyway
`I have the best words` defines a string called "best". `myResult begged myPeople for a job` calls myPeople.job() and assigns the value to myResult. `bigly` is the ++ (increment) operator. Decrement operator is `totally overrated`. `fired` terminates the entire application, but only via a segfault, and always immediately triggers a core dump that spills the entire contents of memory into the standard output. **Edit:** Oh, and obviously the greater than and less than operators should be switched.
I want to do this mainly with React, and perhaps some vanillajs. That being said is it possible to mix both?
All those *.js things are solutions to problems and answers to questions. You need a problem before considering a solution and you need a question before looking for an answer.
`@noframes` should work https://wiki.greasespot.net/Prevent_Execution_in_Frames
npm i maymays drumpfbtfo
Like she would ever Promise that.
No React-Native? I mean, that makes me discount the rest of the article because it's not been listed, despite it having a lot of traction.
It's possible from what I can test in the console. Then you might want to find a regexp so you have to call glob.sync() once. It would return you an array of filenames, and then you just have to do smthing like : files.map(function(el, index){ el = "http://localhost/site/" + el } And finally you can use your files inside your array. Caution, I did not try the .map thing, might be not correct at all.
You need a covfefe.
Since `files` is already an array, you don't need to surround with square brackets to use it as one. Simply: const options = { pageUrls: files, }; There's a couple of other improvements you can make as well. `glob.sync` returns an array, so there no reason to ever treat it its values like strings (concat with a ',' and then splitting). This is how I would personally implement this. It has a few more lines of code, but I find it much more readable (assuming you're okay with ES6) and is a bit easier to configure for other file patterns. const glob = require('glob'); const filePatterns = [ 'production/*.php', 'production/profile/*/*.php', 'production/*.html', 'production/profile/*/*.html', ]; const files = filePatterns .reduce((accumulator, filePattern) =&gt; { return accumulator.concat(glob.sync(filePattern)); }, []) .map(file =&gt; `http://localhost/site/${file}`); const options = { pageUrls: files, }; 
I give this to young developers to read even if they aren't interested in Ruby. She explains good software design so well.
You are God's gift. Thank you so much! 
It wasn't a funny enough gaffe to warrant all the hype 
Inspect the user agent Edit: Why the downvote? This is how it's done.
This has got to be a joke, right?
&gt; don't bully me Wtf?
I wonder if they'd get better results compiling to WASM instead of to JS...
Thanks
Just this: http://imgur.com/a/54jkf
^(Hi, I'm a bot for linking direct images of albums with only 1 image) https://i.imgur.com/FWeAKRD.jpg ^[Source](https://github.com/AUTplayed/imguralbumbot) ^| ^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^| ^[Creator](https://np.reddit.com/user/AUTplayed/) ^| ^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^| ^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dibhsxc) 
I could not care less about readability myself. My major concern is **automatic resolution of merge conflicts**. This becomes apparent only after you have been bitten by it. But by using json, merge conflicts with lock files would have to be resolved *manually*. 
Are you utilizing sites like Facebook or google for login or just making user accounts yourself? If your doing it yourself, check out satellizer library for user authorization. There are a few tutorials for connecting with firebase if I remember correctly. 
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures
Those are all very different things: - Node.js is a runtime for executing Javascript code outside the browser, in the same way that the Python runtime is needed to run Python code, the JRE for Java, the .NET Framework for C#, etc - Angular and React are libraries/frameworks for developing user interfaces and Single Page Applications in the browser - Express is an HTTP/web server framework that runs on top of Node - Intro and Multiscroll I'm not familiar with, but I'm assuming that they're Javascript libraries for dealing with specific page interactions (site walkthroughs and scrolling) There's a variety of resources that can be helpful when trying to understand these libraries. First, you probably would want to look at the overall descriptions for each one. Large tools and libraries generally have a separate home page, like https://nodejs.org/ or https://facebook.github.io/react/ . Most libraries are available via the NPM package manager, and you can search for them at http://npmjs.com/ , and most of them also have their source hosted on Github and can be viewed there. Beyond that, my [React/Redux links list](https://github.com/markerikson/react-redux-links) has a category called [Basic Concepts and Overviews](https://github.com/markerikson/react-redux-links/blob/master/basic-concepts.md), which has links to articles that help explain what some of the tools, technologies, and buzzwords in modern JS development are. In particular, you might want to read through [The State of the JavaScript Landscape: A Map for Newcomers](https://www.infoq.com/articles/state-of-javascript-2016), [The Hitchhiker's guide to the modern front end development workflow](http://marcobotto.com/the-hitchhikers-guide-to-the-modern-front-end-development-workflow/), the [Simplified JS Jargon list](http://jargon.js.org/), and my own slideshow on [The (R)Evolution of Web Development](http://blog.isquaredsoftware.com/presentations/2016-10-revolution-of-web-dev/). Hope that helps!
Yep. If someone has a big list of what problems those individual JS things solve that would be awesome :)
Oh my god Node just made *total sense*. Thank you! I've been unable to process its description until now. Thank you for your explanations, this is awesome and exactly what I need.
Interesting read. And it's good to hear that he's able to sustain development through Patreon. Too few open source devs seem to be able to get a solid income from their work. 
Use the create-react-app cli to scaffold your project out. Makes setup so much easier. Use Redux if you are going to handle anything more more than local or very limited state. The one way data flow, explicit behavior, and sane state mutation makes it much easier to reason about your state. It is worth the very minor extra boilerplate. Use react-redux to connect your state to your store. The standard router is react-router. redux-thunk to handle async actions. In-line style library like Radium can be useful if you don't plan on having to swap out themes. Be prepared for a holy war if you read/talk about in-line styles.
&gt; Primarily added complexity, and astronomically higher memory usage. At the very least, you have a separate instance of the JS VM running and optimizing for every component, to say nothing of the memory cost of generating N dom trees. Besides complexity (I think a framework could smooth this part out), the rest of these are real problems I'll need to consider, thanks. &gt; It would certainly be nice to have a way to powerfully, but controllably isolate things in web pages, such as CSS, JS, DOM Shadow DOM, custom elements...*still waiting!!!* But I heard they are at least Coming Soon^TM
http://www.berkshirehathaway.com/
Hey daBarron, while you are evaluating alternatives take a look at [Inversoft Passport](https://www.inversoft.com/products/identity-user-management) (not to be confused with passport.js). This article walks you through the migration process and identifies key differences between Stormpath and Passport: [Mirgrating from Stormpath to Passport](https://www.ibm.com/blogs/bluemix/2017/05/tick-tock-migrating-from-stormpath-to-passport-on-bluemix/). Full disclosure, I work at Inversoft and am happy to help answer any questions you may have!
github gist in combination with hashnode.com?
I think you've mistaken what I mean when I say 'closure pattern'. I mean something along [these lines](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures). Using a closure is more than simply setting methods on the object itself instead of the prototype, you eschew the prototype altogether and store private state in a lexical scope. Closures do not have inheritance. In the closure pattern, you don't use 'new' when invoking a constructor, and so you can't use the 'this' keyword. There is no such thing as the 'prototype chain' in the closure pattern. If you want that, you need to use classes. Classes do not transpile down to closures. The class syntax transpiles down to interacting with the object prototype directly, but that is not the same thing.
I'm saying if you do something like: `domNode instanceof Node` and `domNode` was created with an iframe sandboxed `Node` constructor, wouldn't you expect to hit issues?
Yes, that is scoped. But you could still have more &lt;div&gt; tags, for instance, and different classes applied, with different modifiers. Often it happens that you have little variations of a component which are determined by a specified prop, so you could apply a modifier "element--modifier" just based on the prop value.
Oops. Typo, should have been `this.greet = () =&gt; {` or `this.greet = function() {`
I agree with what you said, but I still think that BEM could help. As I wrote also in the reply to another comment, you could still have more &lt;div&gt; tags in the component's hierarchy, for instance, and different classes applied, with different modifiers (based on some props of the component itself). Anyway I find really "weird" to write CSS in JSON format, and it takes a lot of time to split the strings with quotes, especially if you have to use sometimes the normal quotes (') and other times the quotes for the interpolation (`). And also the camelCase thing for me is not really positive: the idea of having differences between what you write in development and what you find in debug kills my brain :) (I just don't accept the idea of it, of course I can easily work with that...) I didn't try preJSS yet, but I think it could be amazing, especially if they provide editor plugins to highlight the syntax as in a normal CSS.
Why? I am talking about state of the art technologies used by companies which are working with millions of dollars...
Sharing should be easy: you can have a style/color.js file and a style/typography file for instance, where you just export the basic variables, then you can have a style/mixins.js to have a way to share code (even though for me it's not a good idea, considering that components should be completely independent from each other).
I see, maybe you would hit issues there. I'm just not sure if the components will need to compare types like that, or even worry about other DOM nodes. Currently instanceof and typeof aren't being used. I want the components worrying only about themselves, they can talk to each other at the JavaScript level to update/affect their JavaScript properties, possibly even subscribe to each other's events, and each component will render its current state based on its properties. Maybe I'm missing something or haven't progressed far enough to encounter the problem yet.
One potential downside is that the benchmark assumes many objects that are used exactly once and have limited interactions with `this`. IIRC that's the sweet spot (in terms of CPU performance) for classes vs. closures.
Ah, what you're going for is the factory pattern, which, yes, uses raw objects and eshews prototype chains and inheritance altogether. I mistakenly assumed you meant `Friend` to be a constructor in both cases. (Admittedly, I didn't look closely enough at the code examples) But basically every JS style-guide I've ever seen says you should only capitalize constructor functions, so I think a more idiomatic version would be: function buildFriend(greeting) { function greet () { console.log(greeting) } return { greet: greet }; } And "factory pattern" really is a more precise name for this than the "closure pattern". Closure is a very broad general concept that means a lot more than just one style of object construction. My version (with `this.greet = function () {}`), for example, also uses closures to construct objects, hence my confusion over the term "closure pattern".
what do you mean?
IIRC the more you access properties or call methods on `this`, the slower it becomes. E.g. if you'd want to keep the `this.airInLungs` in sync while running the method (instead of copying it into a local), that should be more in favor of closure style. P.S.: The last time I looked into the various benchmarks my conclusion was "it really depends and neither is faster 100% of the time". But then again - I'm lazy. ;)
Yea yea, it's obviously not for everyone :)
Rxjs - its not fun though.
You can feature-detect Wasm support by checking if the global `WebAssembly` object exists. Wasm starts up quicker, runs faster, and is also a bit more compact. Wasm is already supported by Firefox and Chrome and the next version of Edge should support it, too.
If you are making your components correctly, they will be so small and single-purpose that bem will seem redundant. I rarely need anything more complex than a single word class name. Consider that if you want to work with css in js AT ALL, you will be using the camel-case form, because that is how css properties are exposed in js.
Awesome, thanks for clearing that up; sorry I didn't read a bit more carefully the first time. My brain just autopilots to "constructor" when I see capitalized functions, and I didn't look carefully enough to see that it wasn't the case.
in that case I'll wait for the 2nd edition. thanks buddy
Can I reuse my JavaScript functions to create the Custom Elements like in the un-project https://github.com/dmitriz/un ? Is it simple? Is anyone using it? Are there interesting examples out there?
Check this https://github.com/btomashvili/react-redux-firebase-boilerplate 
Who cares if it has components? Those angular modules will give you plenty hair-pulling, headbanging moments so that you'll rue the day you started a big project angular 1. Just make it simple for the next guy and use react. Setting up webpack really isn't that hard.
Creating a new project with angular 1, right now, would be silly. Your time is better served on a platform that is getting support.
Maybe I'm in the minority but I love the way classes look and feel while coding them. Yes they are still really .prototype underneath, but they seem cleaner, and easier to consume while scanning code. Extending the prototype manually I always thought was a pain in the ass, and created so much more code.
The thing that convinced me to lean towards classes rather than the other options – after an adult lifetime of preferring closures and plain objects over prototypes – is the way that they scale. If you have 1000 objects that have the same 4 methods, with the closure option you're paying for 4k methods. If you add another method, you're paying for an additional 1k. Not just in memory use, but also in initialization and in VM overhead (tracking how the function is used, whether it's a hot function and worth doing more optimization, etc). It adds up.
Browsing the web is more of hassle than it's worth nowadays. Especially when adblockers remove 99% of the javascript you don't want to run anyway
Some criticisms. * You get more precise results if you dont use `+=` operator. This is not optimized by V8. * The function `getAirInLungs` isn't needed, which imposes a large bias. Just call the `airInLungs` reference directly. It is still a closure. * I suspect the large gap in the results is a very V8 centric thing that is substantially less prominent in other JS compilers. **EDIT** I created a jsperf to verify some of these assertions. https://jsperf.com/classes-closures * By removing the `getAirInLungs` function the results are similar in V8. * In FF the classes code sample was about 8% faster. The reason why your code samples are soooo completely biased is due to how resolution works against the scope chain. In an object there is no local scope. Properties declared on an object are local. There is no penalty for accessing `this.whatever` for instance. There is a tiny performance penalty for accessing a closure, because of how resolution works. First the local scope is checked for the reference, then the parent scope, and so forth up to the global scope, and then the prototype chain is crawled. **EDITEDIT** I reran the test in both browsers: * Closures were 6% slower in FF * Closures were 35% faster in Chrome It seems if performance is your objective and Node is your primary development target you should probably **avoid classes in favor of closure where possible**.
Extending classes is pretty sweet though, I always find it useful to have a base user class, and extend it for the various roles 
I'm still amazed that React even took off other than the Facebook circle jerk. No disrespect to the developers but, no separation of concerns, and dealing with yet another specialty language to deal with learn in JSX is annoying.
I've never put much weight in the detraction that "Classes are syntactic just sugar". You could say the same thing for `.map` and `.filter`, which can both be achieved by `.reduce`. Hell, almost every method for working with collections could be functionally replaced with a `.reduce` if you felt like it. The reason to use `.map` et al, and I believe this applies to the Class syntax as well, is for greater expressiveness. It makes the intent of the code more obvious, and as such improves readability.
It's worth mentioning though that it doesn't have to be that way -- the closures in an object made out of closures could all share the same space, if JS compiler writers made it a priority. It's not an exotic optimization -- the ORBIT compiler for Scheme had shared closures in the early 1980s. Admittedly I'm not holding my breath, but this means I'll go ahead and code in the clearest style except where profiling shows it to matter.
Yes! In fact quite a few features of ES6 are just sugar. Arrow functions are just sugar. Default parameters, rest parameters, and the spread operator are sugar. Template literals are sugar. Destructering is sugar. forEach, map, filter, and reduce are sugar. In short, if Babel can transform it to ES5, then it's almost certainly just sugar. But only with classes do folks emphasize that they're "just" sugar, as if that somehow makes it a bad thing. In reality, I suspect a few people decided ahead of time they were going to be against classes, so now they try to come up with reasons after the fact.
The real problem I have with inheritance is that it's brittle. It only takes one small, seemingly-insignificant change far up the inheritance tree to break an entire application. Composition allows you much more freedom and is far more robust, with no real drawbacks compared to classical inheritance. It seems easy to find a good pattern to manage inheritance chains, especially since everyone seems to learn OO in uni, but it gets out of hand really fast. Before you know it you're splitting up classes and trying to pry apart functionality and causing a world of pain for yourself and your coworkers. FP is a real game changer, and in web, mobile and server environments there is very little reason why it isn't always a viable option. Maximum code reuse, immutability and composition over inheritance make for a much more enjoyable coding experience.
My main projects right now are 1) a CRM (so, glorified CRUD ;)) and 2) a mapping tool that lets users draw designs over the top of a (leaflet) satellite map. There's definitely _logic_ - for example, sorting CRM entries according to due date. And forms. So many forms. I've been keen to set up end-to-end testing in the past, but getting the infrastructure in place to do it properly is a pain.
Well said. Sugar in our lives is a good thing!
And even that can be sugar. 
You can create your own test. Here is another one I found: https://jsperf.co/class-vs-function
I guess I can see some merits in the idea, but the thing that makes no sense to me is this: import styles from './styles' ... const { classes } = jss.createStyleSheet(styles).attach() ... &lt;button class="${classes.button}"&gt;Button&lt;/button&gt; ... So you write your styles in the weird JS way, and then you just end importing them and assigning them to an object or whatever. You can do pretty much the exact some thing in Browserify using the browserify-css transform (minus assigning), without adding much to your build process :S https://www.npmjs.com/package/browserify-css
wow, I just looked at their GitHub repo, pretty impressive number of stars there. I think I used version 2.0... something like that. Maybe things are better now. I do remember it being pretty darn easy to pick up and go. I did pre-transpile instead of in-browser.
Nah, it sucks.
Its what I got in Chrome when I ran the test a second time. **edit** Just to ensure I am not blowing smoke I tried this again. First run classes scored about 1.38% faster. On the second run classes scored 38% slower. It seems there is optimization for closure in warm cache after the code is compiled.
I was referring to the jsperf.com test I created where I originally got a 35% slower result for classes on second and later runs. On the jsperf.co test that I did not write the results are always about even except for every 10th run classes perform twice as fast as the function code and FF performs nearly 10x faster than Chrome.
With a JSS solution like styled-components or glamorous you have a function that returns a set of styles. The styles can change based on props, so you just care about the styles you want to return while the framework takes care of the class names.
true dat, we used to abuse macros to no end as well. (and then we started abusing the c preprocessor)
How complex does the library need to be? [co](https://github.com/tj/co) is some really interesting insight into how `async/await` works under the hood, in my opinion. [lodash](https://github.com/lodash/lodash) source is pretty easy to read, too.
test post please ignore
console.log("Hi, How Are You?")
Good point about adding properties to the function objects. Comparing for equality doesn't have to be a problem -- ORBIT did it -- but properties sure would be. I guess you could deoptimize if you hit that case, but it'd be a lot to back out of, gah. Dammit, JavaScript.
Thanks, I had a really good play/look at it, seems really good but for our app we really need to have groups. I was told me that this feature was still in the development.
Another language? JSX isn't a language. It's just a syntactic sugar to make nested function calls look like html.
Probably you're right about the sigle-purpose components, but I still think that BEM gives a little bit more "meaning" to class names. Anyway it's probably irrelevant. About the camel-case form, I think that in JSS you could also use 'margin-bottom' as a key, but what really interests me is to give a try to this preJSS to write common CSS.
The whole point is that the stylesheet will be scoped in JSS! And in big projects it makes a HUGE difference.
I would recommend watching this [talk](https://www.youtube.com/watch?v=x7cQ3mrcKaY) by Pete Hunt where he addresses the "separation of concerns" issues. And JSX isn't a language, it just converts code that looks like this: var a = &lt;a href="/" id="link"&gt;Home&lt;/a&gt;; into code like this: var a = React.createElement('a', { href: '/', id: 'link' }, 'Home'); And that's basically it.
`while (air --&gt; 0) { // The 'goes to' operator.df` lol
You're not in the minority at all. You're simply in the quiet majority.
&gt; JSX isn't a language. It's a superset like TS.
Fuck these guys and their lame ass community hostile generic branding bullshit.
&gt; Arrow functions are just sugar. Arrow functions are the opposite of "just sugar", arrow functions are a semantic simplification from old functions. You may believe they bind `this` on creation but that absolutely isn't the case. What they do instead is *not* override the resolution of `this` references, leaving the natural lexical resolution method. Here is the specific part of the spec: &gt; ### 9.2.1.2 OrdinaryCallBindThis ( *F*, *calleeContext*, *thisArgument* ) &gt; When the abstract operation OrdinaryCallBindThis is called with function object *F*, execution context *calleeContext*, and ECMAScript value *thisArgument*, the following steps are taken: &gt; 1. Let *thisMode* be *F*.[[ThisMode]]. &gt; 2. If *thisMode* is `lexical`, return NormalCompletion(**undefined**). &gt; 3. Let *calleeRealm* be *F*.[[Realm]]. &gt; 4. Let *localEnv* be the LexicalEnvironment of *calleeContext*. &gt; 5. If *thisMode* is `strict`, let *thisValue* be *thisArgument*. &gt; 6. Else, &gt; 1. If *thisArgument* is **undefined** or **null**, then &gt; 1. Let *globalEnv* be *calleeRealm*.[[GlobalEnv]]. &gt; 2. Let *globalEnvRec* be *globalEnv*'s EnvironmentRecord. &gt; 3. Assert: *globalEnvRec* is a global Environment Record. &gt; 4. Let *thisValue* be *globalEnvRec*.[[GlobalThisValue]]. &gt; 2. Else, &gt; 1. Let *thisValue* be ! ToObject(*thisArgument*). &gt; 2. NOTE: ToObject produces wrapper objects using *calleeRealm*. &gt; 7. Let *envRec* be *localEnv*'s EnvironmentRecord. &gt; 8. Assert: *envRec* is a function Environment Record. &gt; 9. Assert: The next step never returns an abrupt completion because *envRec*.[[ThisBindingStatus]] is not "initialized". &gt; 10. Return *envRec*.BindThisValue(*thisValue*). "arrow" functions have `thisMode=lexical`, regular functions in strict mode have `thisMode=strict` and regular functions in non-strict mode have `thisMode=global`. So arrow functions just bail out at step 2 of this process.
Hiya, I have worked for 3 years on the problem of A/B testing at my company, and the most scalable solution I've worked with is deterministic experiment grouping on the frontend w/ PlanOut.js Since we use planout to bucket users into experiment groups on the frontend (using a unique identifier like an email address), there is no need to render block on an additional xhr while you fetch experiment data (even if you pool the xhr using graphql). As soon as your react app renders &amp; has the unique identifier available, your app knows which experiment group (params) are active. https://github.com/hubspot/planout.js
You are using let, const, and arrow functions inconsistently across the implementations. Using let or const in a loop is slow in V8 because it allocates new memory on each iteration for the variable. Arrow functions perform with less overhead because you're not binding "this". And as long as you are not capturing or accessing anything from the outside scope inside the arrow function, they are much faster because they are a "pure" function. 
The good parts: * Minimal and elegant API. * Good documentation, easy to learn. * Official router included. * Mixins (despite what Dan Abramov says) The bad parts: * Only one core maintainer is left, no company behind the library. * Community didn't grow, hence not that much quality 3rd party stuff. * Lack of IDE support (like in IntelliJ IDEA or WebStorm) * Too many bugs (despite 100% coverage). Personally encountered some. * Not among the fastest, although version 3 was an improvement. * Lack of container component (HOC) support (&lt;yield&gt; is very limited). * Painful transition from version 2 to version 3. Some behavior (e.g. ref availability) was not standardized / covered by tests. * The remaining maintainer has radical plans for Riot 4. The last two are especially funny considering that the core maintainer [wrote an article about React](https://medium.com/@gianluca.guarini/things-nobody-will-tell-you-about-react-js-3a373c1b03b4), in which he accused the upcoming React 16 in (supposedly) breaking things. 
I didn't change anything from the op's original code except to remove a node reference in both samples and to remove an unnecessary reference from the closure sample.
We're comparing property read to local variable read here. So, no. Even for a fast path property read on a monomorphic object, there's potentially more work. With a decent compiler nothing beats a local variable read.
Are you sure an optimized function (machine code) would still read all locals from the object by looking up the name? Given that JS semantics (sans eval) don't allow a runtime modification of the scope bindings, that seems like a fairly weird implementation choice..?
It can, but writing quotes all the time is even more different.
&gt; I came across Riot the other day and noticed it does in-browser compiling for custom components/tags. Seems like a great way to separate views/business logic into separate tags (without relying on Node) and use observables to reduce coupling between tags. React, Angular, Vue, Marko, Monkberry, pretty much any modern framework/library has that feature.
Agreed (especially re unit testing), except for one use case - starting a new and small project with a team of people already experienced with Angular 1, like your client above. Which is exactly our use case. Pushing React or anything else on a team like that, in addition to having to continue to maintain Angular projects is NOT a good business decision in my humble opinion.
Vue CLI will scaffold all the project configuration for you. No need to worry with webpack unless you want to get fancy and even in that case everything is already laid out for you.
Done. Excellent survey, BTW. I hope you get all the info you need.
pizzicato.js is pretty sweet https://alemangui.github.io/pizzicato/
You make a `styleVars` file and import it, same as you had to do with SASS. For something like button styles, that's what componentization is for.
You have got to be kidding me.
Very nice. Please post the paper and results when finished!
It just uses npm by default but you can manually download all the dependencies if you really wanted to. It doesn't use node at all. Well the cli uses a node server for dev but that's totally optional. What's the problem with using a package manager though?
U might wanna ask in r/programming r/learnprogramming for more responses 
Check this tool - http://getlibs.com/ (I am a developer). You can use most of the frameworks without node. [React](https://github.com/activewidgets/getlibs-react-hello-es), [Angular](https://github.com/activewidgets/getlibs-angular-hello-ts), [Vue](https://github.com/activewidgets/getlibs/tree/master/examples/vue/es5/sfc) - with a simple [in-browser compiler](https://github.com/activewidgets/getlibs/blob/master/plugins/vue.js) for single file components (es5/require only atm). Here is a non-trivial example with Angular - [realworld.io frontend](https://activewidgets.github.io/getlibs-angular-realworld-ts/), [source](https://github.com/activewidgets/getlibs-angular-realworld-ts).
Can you define precisely what you mean by "object composition"?
Here's a site that aggregates existing custom elements: https://customelements.io I'd like to add mine there too when ready (https://github.com/trusktr/infamous).
Entertaining != accurate. https://www.reddit.com/r/javascript/comments/6cmf06/class_keyword_object_creation_in_javascript_fun/dhw8pg0/
They still support Dart and all of Googles internal Angular projects still use Dart... https://github.com/dart-lang/angular2
I don't think it is the same. With my function, I configure my string such as `Hello` once and for all, with the simple function call: `factory('Hello')`. Then I simply call `helloFactory` to create my objects. In contrast, the `class Factory` requires me to provide the string every time I want to create an object: `new Factory('Hello')`. Both `new` and the argument make it less simple to use than just calling a pre-configured function with no arguments. Next you are suggesting to create the new 2nd function: const helloFactory = () =&gt; new Factory('Hello') Yes, it does return the same factory, but now the string is hardcoded. To make it reusable, as in my example, you need to create this more complex function: const factory = sound =&gt; () =&gt; new Factory(sound) But now you have to separately manage the class itself together with that separate function. And to make things worse, the function is coupled with the class. You cannot simply change one without the other. That can make your code fragile and harder to maintain. And there is yet one more problem with the class solution -- the lack of privacy for the `sound` prop. Which needs to be addressed if providing really equivalent functionality to the closures, where this privacy is guaranteed. I presume that is possible but would add another layer of complexity and coupling to the code. With no real benefits as far as I can see. &gt; You're also not using prototypes right. You're still creating brand new functions for every object with a different sound. The whole point of prototypes is to share just one copy of the methods across all objects, but you're not doing that. True, the prototype is created here at the configuration time. The use case would be when you only need to configure few times in your app or even once. For instance, at your app initialisation, your import some config settings that will stay the same. Then there is no need for a prototype, but the functional factory remains reusable and easy to maintain with no hardcoded values. 
I disagree with pretty much all of that. Your "factory" takes a parameter "sound", and the class "Factory" also takes a parameter "sound". Your "helloFactory" hardcodes a particular string to that parameter, and the class version "helloFactory" also hardcodes a particular string to that parameter. You don't need to do any of those changes you talked about to the class version. It already achieves the same thing as is. Except when we make new sounds... f1 = factory('foo') f2 = factory('bar') f3 = factory('baz') f1 = () =&gt; new Factory('foo') f2 = () =&gt; new Factory('bar') f3 = () =&gt; new Factory('baz') Your version creates brand new functions for every sound. The class version shares the same functions across all instances of all sounds. &gt; And there is yet one more problem with the class solution -- the lack of privacy for the sound prop. Indeed. But there's also a (possibly worse) problem with the factory solution. [It's privates are actually **too** private](https://www.reddit.com/r/javascript/comments/6b0yc3/factory_functions_privates_are_too_private/). It would prevent you from implementing certain kinds of methods, such as "isEqual". Ultimately both classes and factories should use weak maps.
I find creating a new function like `f1 = () =&gt; new Factory('foo')` a higher layer of complexity than simply calling a function. You have to create and maintain separately functions for each `f1, f2, f3`, and there is some repetition in the code. &gt; Indeed. But there's also a (possibly worse) problem with the factory solution. It's privates are actually too private. It would prevent you from implementing certain kinds of methods, such as "isEqual". Ultimately both classes and factories should use weak maps. This is the first time I hear the term "too private". I prefer to have private mean private. Any lack of privacy creates confusion. If you want to access your property from outside for whatever reason, then it is not private. You have a different problem to solve, for which different tools are available. 
All the modern javascript engines do this as well (the original article and a lot of the posters here seem confused about that). A closure is just an object with two pointers: a pointer to its Context object (heap allocated store for closed-over variables) and a pointer to the function body shared between all closures of the same function. And all closures sharing the same lexical context share a Context object. It's the same as Orbit.
Hi /u/sigumagwa, for link submissions, please use the "Submit a new link" option. Thank you.
Thought it was an oddly slow day.
Just ran across this today, looks good: [The Modern JavaScript Tutorial](http://javascript.info/)
thanks I just bought " The Web Developer Bootcamp" by Colt Steele for $10. I also have access to Udemy the complete developer
A couple of schools of thought on this: * Go to school and get a computer science degree. You probably will have 0 experience, and are not competent with web technologies, but you are very employable and probably have a solid understanding of OOP concepts. Web technologies probably aren't going to make much sense to you, and you might even think they are hopelessly broken. Fortunately for you there are frameworks. * Go learn a language with more jobs, like Java. You are more employable and will eventually be tasked to write JavaScript anyways. JavaScript has a syntax that looks like Java, but you will be amazed when your code doesn't scale and performs very slowly. ES6 has classes so JavaScript won't be completely foreign to you, but HTML and DOM aren't things humans can write. You will be lost without some massive framework to abstract the DOM for you and manage all this stuff that doesn't matter to you anyways. * Go take an educational bootcamp. It will scratch the surface just enough to raise your confidence and help you to feel employable. * Write software on your own and punish yourself with learning the technologies the hardway. This sucks and its full of frustration. Worst of all nobody is giving you awards, certifications, or payment for this wasted time. You will figure out how the technologies work though, and likely end up far more competent than the prior described options. Other people on the job who never went through this punishment will have a hard time relating to your understanding of the technologies. They might even cry if you attempt to peel back some of the layers of stupidity they have carefully put in place to protect themselves from writing code.
No, what I mean goes something like this: there's just one heap-allocated object for all N of the functions. The object has N function pointers, followed by however many free-variable slots. A reference to the first closure is a pointer to the start of the object. A reference to the second closure is a pointer offset from that, to the next slot, where the second function pointer lives; and so on. The code of each function uses different offsets to access the free variables, since they each get passed a different pointer to a part of the shared closure object. You could avoid this complexity if every reference was a "fat pointer", i.e. a pair of a function pointer and a datum (which would usually be a pointer to what you called a Context object). But I don't think that's what you meant because I haven't heard that JS engines represent things that way. What I take you to mean is each closure reference is a pointer to a separate heap-allocated object which has a pair of pointers.
There are too many aspects of this which are personal/pure luck to give you any kind of answer: - The speed at which you learn: You could have a very analytical mind and programming comes naturally to you as though you'd always known it or you could run yourself hoarse shouting curse words at your computer fulltime. - Who you know: It really is the most important thing, really. If you know someone who can give you a leg up or even a heads up when someone is hiring and you can get in before it's actually posted you're golden. OTOH you could go 12 months without a bite even though you could show a CompSci degree and several tech certs. - Where you live: Certain areas are far more conducive to tech work in general and even though remote work isn't a crazy unicorn like it used to be getting international work or getting people to trust you (especially if you don't have previous work references) can be hard - What you want to do?: Front end is quite a big platform and say you learn Angular but there is no Angular jobs going or the same for React or people not caring about your vanilla JS skills and want someone with specific experience (especially for a beginner they're not going to assume any level of skill with learning these things on the job) Short answer, pick a decently hard project (recreate fb or Reddit, e.g.) and build it. When you think you're ready then apply for jobs. It will depend on you how long that takes. Blah blah, 10,000 hours to mastery blah, blah.
Thanks. Personally based on what I've read I want to learn node, react especially
I just want to iterate as it wasn't clear in my post that while I refer to some frameworks/libs I have no preference either way and your employability depends on what the market in your area is requesting. If you only care about getting a job just keep track of what companies are requesting in your area.
This comes off a little condescending, and maybe a little out of place for the post and sub, but this is all solid advice regardless of what the [survivorship biased](https://en.wikipedia.org/wiki/Survivorship_bias) echo chamber says. Even if you can manage to find a job, you'll get capped. I had a 40yr old asking me the other day at lunch about which degree he should get because he was tired of DevOps and capped out (at a very high salary), but couldn't move up the ladder due to lack of education. 
I'm also working on a bachelors in information management and security assurance
Mesh networks like Bittorrent are the wrong architecture for live video streaming, latency will get ridiculous at scale (as the creator of Bittorent himself has said). However, now that the groundwork is here, it shouldn't be hard to swap out another architecture.
Getting SCSS support feels like Christmas. Nice work Prettier team!
As far as securing goes I recommend [Passport](https://www.passportjs.org/docs/login). It has a few different authentication strategies and once a user has logged in all requests have a user that can be used to validate subsequent requests (like say only some users have access to some such resource).
Thanks for all the insight on the different schools of thought
The difference is that `var` creates the variable in the local scope for wherever it's declared (say, inside a function), and simultaneously assigns it a value of `10`. No `var` means you're not actually creating a variable, you're assigning a value to it. So it will try to find `a` in the scope chain up until it hits the global scope and then assign it in the global scope if it wasn't found before then. Generally speaking you should not be doing this 99% of the time.
Ayyy I used to work for SurveyGizmo
It's cool. You do free work for us, so we really can't complain. Thanks! :)
Is there support for any other http methods other than get? Also, I'm curious where the verbage `at` came from as opposed to what you may find in express for example. I don't dislike it, in fact I think it is growing on me.
Many of us don't
This would have to integrate with vim to be useful.
This article was a bit difficult to make it through all the way. There seemed to be some (a lot) of things I disagree on. &gt; People have been talking about JavaScript fatigue lately While pedantic of me here, it's been some time since js fatigue has been mentioned in the community. Most of us are over that fad. &gt; I think this discussion evidences how good programmers cannot be lazy people I believe this is false. A good programmer can be lazy, here meaning not keeping up to date on every new shiny library or framework. Some of the best instead focus on a specific area, as they should. &gt; It is simply far too easy to create a new library or package Yes, and this is part of the beauty that is web development &gt; since anyone can do it in a few seconds now, this generates a lot of noise. I can at least agree here. There is a lot of noise, but it can become rather trivial to discern what is important from what isn't. &gt; It is just too easy now to share poor code. It's always been easy to write and share poor code. &gt; You search GitHub, or the npm registry, see what is popular for that, take a look at comparisons between the top candidates, maybe check which ones have unit tests, good code size, reasonable architecture, some minimal documentation, responsive project leaders… it can take a hours, even days, to decide. Yes, you should take time to find the right tool for your project. Depending on the performance, ease of development, stability, support, and a dozen other factors this is very important. It is somewhat short-sighted to suggest we shouldn't spend time to find the correct tool for the job. As well, I would say it is a good thing that we have so many options. They will compete and you will benefit from having the choice. &gt; Recently I needed a library to build query strings, just a small one so that I wouldn’t have to include jQuery just for that. This is hilarious. Write a function yourself in five minutes. Or if you must use someone else's code, then just grab the first package you like off npm. Iirc there is a package named "querystring". &gt; Writing complete and bug-free programs is challenging. Sharing poor code is not. Slap a cool animation on your Readme file and everyone will assume your project is awesome. I feel like this is written by someone who has yet to support a large open source project. Yes, writing bug free software is difficult and arguably impossible. That doesn't mean we won't get it as good as we can. This assumes that developers don't care about what they are writing and creating. I'd wager that it is the opposite. We love what we do and want to make it the best as possible for our users. I could continue, but I believe you get the point.
There you go! https://github.com/prettier/prettier/blob/6697122e287411d50858b21ed70ce8162f013ba8/README.md#vim EDIT: permanent link
I'm very excited to see this feature. We have a quite large Typescript project and this will be a great addition.
`let` is used for such things. "use strict"; let a = 1; function aPlusB() { let b = 2; var c = a + b; } window.console.log(a); window.console.log(b); window.console.log(c);
I'm asking the opposite: the format designed to transfer data is slower than just outputting the data. My data also does not contain any user inputted data, and the whole software is for internal use. No protection against malicious data is needed.
Oh, I hadn't thought of the double parsing. That might be why. Also thanks for the warning but that string cannot occur in the array (no tag at all can occur).
Thanks for the heads up! There are no newlines in my data.
My point was that executing javascript code also involves parsing from a string: the javascript code itself, which is also more complex than JSON data. As ddl_smurf point's out, there might be an additional step because the JSON string is parsed as both javascript code and json data.
https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js There's a lot of stuff behind the scenes in JSON parse, if you look at the code. Not only it is slower to use in from flask to the client, you will also find memory usage to be critical for the client as well. I've run out of memory due to JSON parse in node.js 
Just to be clear, even if your json is ` [1, 2, "&lt; / script&gt;"] ` you'll run into this. It's a commonly used injection technique, and whilst I understand you have reasons to know this won't happen, I would still recommend coding defensively. For ex. someone might copy that bit of template and use it with other data, or you may forget and let user input leak into your array.
could you briefly tell me what is the solution that you are pointing to?
`at` listens for all types of requests, though I should probably add a way to distinguish between them. [Here's an issue I made](https://github.com/emctague/serville/issues/6) and I'll actually implement it later today when I have the time.
It's local, but the value will persist when it can be accessed outside of the function. This can happen if a value is returned, as with your example, or, as another example, if captured through a closure. The garbage collector automatically handles this for you, knowing what is accessible and what isn't. Once a value is no longer accessible (no other references accessible to your code exists making it impossible for you to get to it) the garbage collector will free it from memory or queue it up to do so later (or put it back in a pool or whatever). For normal local values not made available outside a function call, this will happen right away.
How would you prevent this injection technique? Would you sanitize every array element?
Express is large and contains many features (and lots of configuration) that isn't necessary for API servers that just want to serve JSON. A better question would be "When/why would you use this and not restify?", as restify is far more similar and preferred for this sort of server. My answer is that Serville is far smaller and simpler. It makes you do things a certain way, minimizing configuration and keeping file size down. This small file size is ideal for any situation where space is extremely limited, and is also quite quick to download and set up. Serville is also likely much faster, considering the alternatives have far more features and complexities that would take far more time for them to process before actually completing a request.
This is smarter than my suggestion, much slower, but respects the data integrity 
&gt; you could go 12 months without a bite even though you could show a CompSci degree and several tech certs Sorry but if you have these and can't find a job in 12 months you're not looking hard enough period
Just noticed you were wrapping your object in quotes to run it through the JSON parser. If it's already in object notation, why would you even need to parse it in the first place? Either way, the answer is still the same. In the first example you are parsing a string (which you turned your object into by wrapping it in quotes), while in the second example you are just reading the object. Both examples require you to read the object, but one has an extra step of converting it to string and then parsing it back to an object. Of course that extra step is slower. 
I made a simple tool to figure out the best combination of colors for a logo: https://cxjs.io/fiddle/?f=oFG53qGJ
You can't bind the event to the element if the element doesn't exist yet. If you're putting the JS in the &lt;head&gt;, without having a $.ready() wrapper, this won't work. I you put the JS after the &lt;body&gt;, it will work but you'd be doing it wrong. (Arguably)
Write a function to remove event listener and then call said function when you when want the event listener removed?
[Indeed.](https://github.com/v8/v8/blob/master/src/json-parser.cc)
[removed]
It’s deprecated: https://nodejs.org/api/fs.html#fs_fs_exists_path_callback I’d use `fs.existsSync()`, anyway.
In React everything models around properties, that includes events, classes, styles and layout. If you want to receive events in one case but not in another, then treat it like anything else. If you need that piece of state, which determines if you can receive events or not, inside of your component then use setState, otherwise: const A = ({ hover, children }) = { const handle = event =&gt; console.log(event) return ( &lt;div onMouseOver={hover &amp;&amp; handle}&gt; {children} &lt;/div&gt; ) } &lt;A hover&gt;i can hover&lt;/A&gt; &lt;A&gt;and i can't&lt;/A&gt;
Ah, so it is.
I wrote my JavaScript books for people who already know how to program. Free to read online: http://exploringjs.com
That distinction is extremely platform dependent. Strictly talking, compile and run time distinctions make no sense in interpreted languages. Since OP is probably including this in html, there are very few optimisations that are usable because any cache for JIT would be very hard to handle. 
Thank you
Thanks! That's nice to hear :) Yeah I guess it's a bit unusual for a frontend dev to be doing this as well :P
Thanks!
This ^ Not only that but Java pretty much *owns* the fintech industry. If its related to banking, securities, stock trading, etc - it probably runs on Java.
Yes good point, thank you! I already interviewed developers from some of these major libraries, and will use that in my thesis :) 
It seems like a bit of a code smell to me that you're injecting JSON inline into your JS. Traditionally, this kind of data is retrieved on the client from a server asynchronously using XHR and then parsed using JSON.parse() when it reaches the browser. JSON.parse() is used at runtime for data retrieved while the application is running, not for constructing the source code itself. From a performance perspective, parsing source code using a JIT interpreter vs. parsing a string into data at runtime are two very different concepts with different optimizations, even if they seem superficially related. What exactly is it that you're trying to accomplish by injecting this data directly into your script?
good advice - thank you, I'll also have in the client code domain checking (which could be changed, but is nonetheless a starting point). 
What, exactly, are you trying to secure? Are you trying to ensure that only your client is talking with your backend? Are you trying to protect secret information like API keys? Are you trying to protect user data?
I'm trying to enforce user licenses. the "users" are website owners. they currently put myserver.example/YOUR_API_KEY as a script in the html, which serves them the JS if the domain matches. I mostly want to prevent them copy/pasting that response, and then using that in place of the myserver.example/YOUR_API_KEY 
You might want to look at jscrambler. They advertise advanced features, but I have no idea if it actually does something or if it's just snake oil as some seem to suspect.
I use d3 + react very extensively. My strategy is to use react for rendering, d3 for math. Works well for me. Alternate strategy: 1) pass a dom node to d3 2) shouldComponentUpdate --&gt; return false in react 3) let d3 do it's magic The second strategy might be a tad easier. But I found the first made more readable code. YMMV. There are a ton of resources online on this topic. As far as I can tell, there is currently no standardized way to do this.
Why write two requests if you don't need to?
I just don't think I understand OP's scenario where you'd need to generate dynamic JavaScript with runtime data injected into the actual source code, almost like a C++ preprocessor directive. Typically the JS gets delivered to the client as a static file that deals with data only known at some point in the future, instead of being a JS payload generated on the fly. It's possible they're writing script blocks directly into their server-rendered HTML templates containing data, but this is not maintainable or well-encapsulated.
**tl;dr:** If performance is critical, you're better off using XMLHttpRequest without setting the responseType *for now*. After [today's post about the performance of JSON.parse()](https://www.reddit.com/r/javascript/comments/6f0q3t/why_is_jsonparse_way_slower_than_parsing_a/), I started thinking whether the performance of XHR requests could be sped up somehow. After all, they're typically doing a JSON.parse() call for every request, and if the response is large this could add up and cause dropped frames. Now I know the fetch() API can give you the JSON object without needing an intermediate string representation of the body, so I figured it might be faster. So, in order to know for sure I decided to create a little benchmark for it... unfortunately, the reality was a bit different than what I had hoped.
Well, javascript is the only thing I've ever used to insert into a wordpress template front-end "code" text box. That's the main reason I went to that. 
Point taken. However if we take a look on how JS started, I think it was meant for browser only at first. Now it evolved in a multi platform general use programming language. Although I think it was designed as a DSL at first
Nicely put
Before I go further, I should have said Java and C# dominate the financial industry, and for the same reasons. I think this guy's answer on quora sums up my personal opinion on the matter more concisely than I could: https://www.quora.com/Why-is-Java-considered-better-for-banking-sites-Is-it-possible-to-use-PHP-or-NodeJS-instead/answer/Adam-Englander-2 TL;DR - Banks want someone they can sue or hold accountable when shit blows up, and then show at every turn that they did some type of due dilligence: buying oracle and purchasing platinum support, and only hiring oracle certified java engineers. Also the JVM / CLR makes them feel safer in terms of security. 
Hi /u/logols, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
use eval on strings containing eval containing eval 
I've added this feature in the latest version!
`_.pluck(_.sortBy(obj, [o =&gt; Number(o.ABC)]), 'FCT')` That's off the top of my head, but I believe that should work.
My apologies that it came off like that, while I'm willing to pay for it, I'd also like to be able to do it myself too. I've updated my post. I guess the specific question would be: Am I remotely close to the right answer, and if so, what do I need to change in my example?
You could make the API endpoint HTTP only and enable CORS with just the domains of licensed users whitelisted.
\&lt;![CDATA[ ]]&gt;
Security by obscurity does not work. Period. Scrambling your and minifying your javascript will not fix any security issues your API might have. And replay attacks are a serious issue you should fix. As far as I understand your problem, I suggest the following: * Go HTTPS only with CORS just whitelisting your clients domains. * Use OAUTH instead of static APi keys. You could also enforce HTTPS with client side certificates. Meaning that anyone using your API has to use a certificate you trust (or is provided by you). However, that means the browser is out of luck and anyone using your API has to make their own web-endpoint.
 _.sortBy(obj, o =&gt; Number(o.ABC)) without the []'s works also 
I think I can give you some code !
Object properties are unordered, thus a second property can't be fetched by index nor trusted to be the property you want. The only way to do this would be to loop through each object with a for loop and grab the second property that way, but again, the "second" property isn't guaranteed to be what you want. 
yea, though the fact that fetch isn't supported on IE or Safari mobile **should** inform your decision. I'm not going to drop support for 90% of iphone users and 10% of desktop users for *any* performance gain. 
For those browsers I would suggest using a polyfill. The latest browsers will gain (at least when Chrome catches up) and no one loses.
Your example is too abstract for me to really see what's​ going wrong, but I would try using an onChange listener for the text box and see what comes back. https://api.jquery.com/change/
Well yeah, I'd say that latter part is exactly what he's doing. For example if you want to quickly bootstrap a SPA from the initial page request, that would be a quick and simple way to do it. I don't think I'd recommend it in general for the reasons you mention, but it seems fine when you just want to get something working and you're not concerned about the engineering aspects of it.
Can you give me an example​ of when you would care about this optimization? When would you send THAT many HTTP requests that frequently? You never would...
Ok, I appreciate the well thought out response and I appreciate now having a benchmark to reference. However, I still think the 40% difference is not as significant as it seems. If your app spends 1% of its total execution time making fetch requests, optimizing that 1% into 0.6% of total execution time is usually a futile effort. I have not actually profiled to see how much overhead even a heavy fetching app will incur, but I think 1% is probably a close estimate of the fetch/xhr overhead. It might even be a generous estimate. All that said though, thank you for taking the time to share the results.
Then why are you measuring ops per second? How much bigger is the response so in memory between the two? Also UI painting is done in a different thread than JSruns in so how would frames freeze based on parsing done in JS? Are you talking about canvas?
If performance is critical one should use WebSockets anyway which is what Firebase uses on their JS SDK.
&gt; Premature optimization is the root of all evil 1000 items is nothing. You should be able to accomplish millions of urls per second. https://jsperf.com/test-vs-match-regex
When it was first conceived, the intent certainly was a DSL for browsers, but the actual language design was far broader and resulted in general-purpose, Turing complete language whose first compiler only ran inside Netscape. At this point, it is absolutely not a DSL. 
Measuring ops per second is just what benchmark.js provides, so it was easy to get those results :) What I really would have wanted to measure is the time it takes from when the first byte of the response is received to when the JSON is parsed. Unfortunately XMLHttpRequest makes it very hard to measure only that part and because the APIs are so different it makes it difficult to verify whether or not I would be giving one of them an unfair advantage. So I just opted to measure the entire request/response cycle instead, even if that means I'm also measuring some fixed overhead. You're right actual UI painting is done by a different thread. What I mean is if there's any JS animation running, it would not be able to update during those frames. And for that same amount of time all event handlers would get delayed until the parsing is done.
I agree that fetch vs xhr is a micro-optimization that shouldn't be considered except in the most extreme circumstances where it is actually proven to be bottleneck. However, if you want to see how JS will impact page performance, all you have to do is go to dev tools and enter this command in the console: `while(true) {console.log('something')}` Your scrolling of this page will stutter consistently and you will end up having to kill the tab (I was unable to refresh due to the endless loop).
to the top you go!
I made a class-based Worker threading system and just added the first helper today that sets up a virtual DOM in the worker thread: https://github.com/protosam/Threading.js End goal is to be able to slap stuff like AngularJS into a thread and have it just update the main window DOM from the background in the hopes of performance gains.
When I was building an app I had cases where I'd do something like &lt;button data-json='{"value": "something", "someOther":"value"}'&gt;My Button &lt;/button&gt; And then in my JS file I'd do something like $myButton.on('click', function(){ var data = $(this).data('json'); // Do something with tdata }); When I showed this code to a security company for review, they told me this was a volubility and I should instead do this: &lt;button data-json="%7B%22value%22%3A+%22something%22%2C+%22someOther%22%3A%22value%22%7D"&gt;My Button &lt;/button&gt; $myButton.on('click', function(){ var data = JSON.parse(decodeURIComponent($myButton.data('json'))); // Do something with tdata }); Thoughts?
It depends what data you have in the JSON and how you generate it, but the company is right that this looks fragile, because if a string within your JSON has a single quote, then you break out of the attribute of `&lt;button&gt;` and then what you have yourself is *at least* broken HTML/JS, and potentially a security vulnerability. The thing I don't agree with the company is on the solution. First, the correct way to encode content in HTML attributes is *not* by URL encoding, but HTML encoding which will look like this: &lt;button data-json="{&amp;quot;value&amp;quot;: &amp;quot;something&amp;quot;, &amp;quot;someOther&amp;quot;:&amp;quot;value&amp;quot;}"&gt;...&lt;/button&gt; I don't know which language you use on the server, so I can't tell you which function you should use, but if it's PHP, we're talking about this: &lt;button data-json="&lt;?= htmlentities(json_encode($data)) ?&gt;"&gt;...&lt;/button&gt; Notice that I'm not using single quotes to wrap the attribute, but the more standard double quotes (which the function above accounts for). The important thing about this encoding is that it's *native to HTML, so you don't have to decode it later in any way*, i.e. your script becomes this again: $myButton.on('click', function(){ var data = JSON.parse($myButton.data('json')); // Do something with tdata }); **However...** although this is a better solution, I'm still not a fan of this. It's verbose, and also if you have large JSON sometimes, you may hit a limit on attribute size in some browsers (which is 64kb). Also it's ugly as hell. What I would *highly* recommend is that you move *all* your JSON data to a single `&lt;script&gt;` block and assign it to a variable there. You can make it an object where the keys are something unique you can refer to later. Then the only thing you need to pass to the attribute is that id, nothing else. Here's the solution with PHP: &lt;script&gt; var data = &lt;?= json_encode($mapOfData) ?&gt;; &lt;/script&gt; ... &lt;button data-id="&lt;?= htmlentities($id) ?&gt;"&gt;My Button&lt;/button&gt; ... &lt;script&gt; $myButton.on('click', function(){ var data = data[$myButton.data('id')]; // Do something with tdata }); &lt;/script&gt; And here's how the final output looks/works like: &lt;script&gt; var data = { "123": {"value": "something", "someOther":"value"}, ... ... }; &lt;/script&gt; ... &lt;button data-id="123"&gt;My Button&lt;/button&gt; ... &lt;script&gt; $myButton.on('click', function(){ var data = data[$myButton.data('id')]; // Do something with tdata }); &lt;/script&gt;
Vuejs is the future of front-end.
That's a common assumption :) According to this [article from Netscape 22 years ago](https://web.archive.org/web/20070916144913/http://wp.netscape.com/newsref/pr/newsrelease67.html) JS was meant for browsers as well as servers. "JavaScript is an easy-to-use object scripting language designed for creating live online applications that link together objects and resources on both clients and servers. [...] A server-side JavaScript script might pull data out of a relational database and format it in HTML on the fly. A page might contain JavaScript scripts that run on both the client and the server. On the server, the scripts might dynamically compose and format HTML content based on user preferences stored in a relational database, and on the client, the scripts would glue together an assortment of Java applets and HTML form elements into a live interactive user interface for specifying a net-wide search for information. "
You could periodically change what JS you serve them based on some kind of rotating key, and update your server API at the same time. That way if someone copies out your JS, whatever server calls it's making will only work for a small amount of time until you rotate the script/server API. With enough obfuscation, I guess you could theoretically do some nasty stuff. But even if it is possible, it's probably a waste of time and effort. Just give people your Javascript. Who cares? Your customers are paying to access your servers. Make it easy for them to do so. It's not the JS itself you're trying to protect, right? Unless you're trying to license purely front-end code - to get someone to pay a recurring fee for the privilege of embedding 150 lines of Javascript? In which case... good luck? If you're licensing access to your backend, my recommendation would be to stop trying to obfuscate your JS. License a key for your server, provide a sensible API that people can call regardless of whether or not they're using your scripts, and then throttle or put usage caps on it. Let your customer pay for X calls a month or something, and then just leave the relationship at that - it'll be way easier for both you and your users. If you're trying to license a 150 line library, then my recommendation is to find a new business model. But if you *really* think people will pay for that, then it still doesn't make sense to me to obfuscate your code. You know the domains your customers are using, so just tell them upfront not to copy your code, and then periodically scan their websites with a bot or something. Remember that your clients can't hide their JS any more than you can. You can always just look to see what they're doing, and then punish them if they break contract.
Maybe I'm missing something, but what does HTML have to do with a JIT cache? 
https://www.reddit.com/r/programming/comments/66hpqs/less_than_5_of_indian_engineering_students_are/dgioklc/ That has never stopped being true. By all measurements there are a tremendously greater quantity of Java jobs on the market than JavaScript jobs. I am not advocating for OOP. If this is what you think I urge to read the comment again.
It is institutionally taught in schools and Java is (until very recently) single paradigm. This is by far the absolute most important advantage.... a unified programming culture that is produced by factories we call universities.
The 40% you're talking about is almost entirely waiting for an HTTP response over a network. The reason why these things are done async is to prevent the thread to sit there and wait instead of allowing the CPU to process addition instructions. Measuring ops per second as your benchmark does doesn't take this into account as all.
That doesn't change the fact that UI rendering is done on a separate thread. If you cap out one of your CPU threads by an infinite loop your stuff going to lag and get screwed up for reasons that just don't occur under working conditions. Also when would the difference be a bottleneck? How many HTTP requests would you have to be making a second in order to have any impact in any environment?
&gt; By all measurements there are a tremendously greater quantity of Java jobs on the market than JavaScript jobs. This doesn't really matter if you're a job seeker. What should matter is how many there are for **you**. As an individual job seeker, there are plenty of open positions in both. 
Like I said, its a micro-optimization that isnt worth it. Im only talking about your JS/render thread comment. If you dont understand how slow JS can cause jank in the UI, then you must not do much with it.
I write JS all day every day. No need to be condecending. I totally understand how JS can cause jank in the UI but I also understand that what paints the UI. This mean negligable amounts of CPU operations which is the case here won't lag the UI. [This page](https://developers.google.com/web/fundamentals/design-and-ui/animations/animations-and-performance#top_of_page) explains things in great detail in the "CSS vs JS Performance" section. Also you said that this mico-optimization is something worth caring about in extreme circumstances. I'm saying it's not as you would have to be making far more HTTP requests per second than the browser can even make. If you disagree that there are extreme cases, ease provide one even if a little abstract.
There's a discrepancy between the two arrays. The first has 'name' and the second instead has 'issue'. Should these be the same? Also, does it need to be a sort? [I'd personally map the values to a new array or use a reducer.] (https://codepen.io/Olliebaba/pen/wevYLX?editors=0010). It is worth noting that they are effectively doing the same thing. Edit: Also, can you not have the source API do this for you before sending you the data? IMO, this should be handled server side.
What you're talking about is a legitimate optimization for server-rendered SPAs. I'm just imagining OP echoing out blocks of data in PHP into HTML templates.
Lots of guesses with your data structures here, but something like const prefOrder = [ "caseDate", "ID", "email", "phone", "issue", "status" ]; table.records.sort((a, b) =&gt; prefOrder.indexOf(a.type) - prefOrder.indexOf(b.type)); // == [...] 
Huh. I didn't know they used [Maybe](https://github.com/v8/v8/blob/5c2f1be58d7c3582270270bda39fa14d160205d8/src/json-parser.cc#L44) in V8.
To cache any JIT work for reuse you need to recognise the same code being compiled, I'm assuming this is harder for inline js than for js files with an URL
Configuring in my case is usually : changing security scheme of a route (jwt, cookie, none), changing server ports (websocket and api), restarting, shutting off etc. But yes could mean anything.
I don't have a lot of experience with WASM, but this article seems to explain it well https://hacks.mozilla.org/2017/03/why-webassembly-is-faster-than-asm-js/
https://www.youtube.com/watch?v=WIqbzHdEPVM I recommend watching this is a great talk about wasm.
`&lt; / script&gt;` doesn't actually break anything. The exact sequence that will close the script tag is anything that matches `/&lt;\/script[\t\n\f /&gt;]/i`. You also need to be aware of `&lt;!--`, which appears to cause no problems, but actually causes the next `&lt;/script&gt;` to fail to close the script tag. That's actually a big security hole - it causes subsequent code to be interpreted as JS rather than HTML, turning what would be harmless as HTML into an exploit. I codified and published all this in [htmlev.js](https://github.com/twhb/htmlev.js). With it, you can test safety with simply `htmlev.isValidScript(string)`.
&gt; Do you write native C code for the JavaScript VM or how do you get the performance boost? Essentially yes, but the textual format is only relevant when debugging or viewing source i.e. it's precompressed to bytecode before being sent "over-the-wire". &gt; Comes the performance boost only from the JIT Compiler which can generate better code due to type information? ... But it's not JIT compilation that's the point? It's already in a binary format. But you are correct that static typing gives more control over memory and reducing execution time. &gt; How huge is the performance boost in general, is it worth it to use it in small websites? Depends on what you're using it for. &gt; What are other limitations like limited setTimeout/prototypal inheritance etc.? WASM is not javascript... I suggest you go through the site more thoroughly.
This stuff is standardized. The given code is directly derived from the HTML specification, and works in all browsers. No different whitespace is tolerated, or in different places. Test it. The exploit I'm talking about is causing `&lt;!--` to appear in a script tag, then, later, eg `alert(1);` to appear in HTML. It would have been useless for the attacker to submit `&lt;script&gt;alert(1);&lt;/script&gt;` for display in the HTML, because we HTML-escape it. But our HTML-escaping function (correctly) leaves `alert(1);` unmodified. And suddenly, the attacker can run JavaScript.
I absolutely do not respect your baseless assertions. Back it up with testing or documentation, or they don't even warrant a response.
I don't owe you anything, I showed you a standard you are failing, you just think it doesn't apply. If you want testing I can bill that work for you, but my assertion that you need to reproduce exactly the matching behaviour of every browser parser is not baseless. My point was choosing to take on such a task is a bad idea from the very start, it's much easier, and performant, to just avoid injecting js code in html.
Also Reactiflux for those interested: https://www.reactiflux.com/
If you just want to reorder elements, with ES2015's [destructuring assignment](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Unpacking_fields_from_objects_passed_as_function_parameter) and [arrow functions](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions) it can be done in a pretty self-explanatory one-liner: const reorder = ([name, email, caseDate, phone, status, ID]) =&gt; [caseDate, ID, email, phone, name, status] reorder(['John Smith', 'john@example.com', '2017-06-04', '(541) 754-3010', 'pending', 1]) //=&gt; ['2017-06-04', 1, 'john@example.com', '(541) 754-3010', 'John Smith', 'pending'] 
It currently doesn't work properly but it's been fixed already and should be a part of the next release. See https://github.com/nodejs/node/pull/13316
What are you going on about and what does this have to do with my reply? Feel free to drop the word "should" from my last reply, as it seems to have confused you and sent you off on some bizarre tangent. 
Planout looks really cool! Thanks for sharing! The biggest impediment I see to using something that orchestrates bucketing on the client side is that each individual services determines it's own bucketing whereas our API serves consistent bucketing information to multiple services. Have you run into that challenge in your implementation? Regarding xhr concern, another good point! There's something I left out of the original post: we're doing server side rendering from within a kubernetes pod. Our API also lives in a kubernetes pod. They talk to one another via kubernetes DNS. All that to say that the HTTP API call is extremely fast. The HTML we pipe back to the user is already "toggled" into whatever state we expect it to be in, so there's no flashing or flickering. Thanks for taking the time to read and comment!
From the component? You don't have to remove it, React does that for you.
Perhaps that makes it somewhat analogous to Node's native modules vs regular JS modules?
There are two formats. SASS which looks like python because it uses no brackets and SCSS which looks like CSS because it uses brackets. Both belong to SASS (language) though.
It's not intended to be written by hand; it's intended to be a compiler target. In fact, it's misnamed: it's actually a bytecode and VM standard (although it does have an assembly language it can be disassembled to).
Probably the best talk on WebAssembly and [this one](https://www.youtube.com/watch?v=HktWin_LPf4) too is great 
I doubt that it's a problem. There are much more sophisticated ways of associating caches with source than just the filename. Modern browsers already have infrastructure for this, and need it for things like implementing CSP, which can allow or disallow execution of script even in inline script tags or href attributes, on a per-tag basis.
Yup.
Is there a specific reason you can't use the split function? Homework project or something? Anyway you can always do a for loop across all the text and mark a group of 1 or more whitespaces as the end of a word. 
Yes, it's for a bootcamp project. I've been studying my notes for a few days now and am lost. 
Since it doesn't have JIT, it's only fast for the one case where you have a language with type information but don't need a JIT (no managed memory). Big misnomer to think it's always fast as a compile target for free.
They tried it long ago back when there were competing promise specs and it was too much of a bike shed. Since callbacks are the most performant implementations of asynchronous code (for ex from a memory standpoint), they decided to let users do their own mechanical transformation of callback code with the `promisify` utility than bloat the stdlib. It's a pretty good solution in 2017 all things considered, like that fact that everyone was already promisifying in some way.
It won't, initially. DOM manipulation isn't their objective. Oh but it will happen. 
In my experience if you make it too hard to steal your product you will get more purchases with stolen credit card numbers and lose money on chargebacks. And those users would not pay in any case so its better to put your energy into improving your product for someone who is happy to pay. 
[GC/DOM](http://webassembly.org/docs/gc/) support is still being planned.
Tossed it into a JSBin file here for testing; but it goes to another webpage/site. Not sure all the implications for trying to go to another webpage, probably will have to include the entire url with the new webpage name http://jsbin.com/quzesohazi/edit?html,js,output Maybe window.location will be more up your alley for this functionality https://developer.mozilla.org/en-US/docs/Web/API/Window/location
You seem to be unsure about performance in general, so here's a crash course in how performance works. The barriers to better performance tend to be (in order): 1. Bad algorithms (quadratic or worse) 2. Runtime Overhead 3. Memory access patterns 4. Branch Prediction 5. Instruction Mix Everybody has to deal with algorithmic performance. The compiler/runtime can't save you if you're using a slow algorithm. The last item, instruction mix, tends to come into play when people are optimizing C / C++ / Rust. It involves inspecting the compiled assembly, reading processor manuals, etc. It's not impossibly hard, just something more to learn, but you have to be in one of the languages mentioned (or similar) in order to have enough control to change things. The others are relevant to this question. **Runtime Overhead** Every language provides a particular set of semantics and it community prefers using the language in particular patterns. Ultimately the items in this category are slowing things down because of memory access patterns or branch prediction but there's a lot that the compilers/JITs can do to cut down this overhead so I'll mention it separately. In 2007-8 the browser vendors all decided to battle over javascript engine performance. Performance has continued to improve but just after that first year the same JS code ran something like 30x faster. A bunch of optimizations happened but I'll point out three. The first is the hidden classes optimization. With the optimization, looking up an object member (e.g. `foo.x.y`) involves taking the memory location of foo, adding two numbers, and loading the resulting location. Without the optimization, you have to calculate the hash of `x`, add the offset, load the result, make sure you got something, calculate the hash of `y`, add the offset, load the result, and make sure you got something. Needless to say, the optimized path is significantly faster. It's not exactly the same but as an example, you used to be able to get a 15%ish perf improvement on a loop simply by assigning the result of the `.length` to a variable instead of having the lookup happen every turn around the loop. The second is addition. In javascript `a + b` is super complex. The underlying CPU instructions for adding two ints or two floats are very simple and very fast. The problem is getting there. Since JS is weakly typed, the two variables can be pretty much anything: strings, Date objects, functions, undefined. If the variables aren't numbers or strings, they'll get coerced, leading to everybody's favorite parade of wat. The runtime has to perform a bunch of checks to determine whether to concatenate or add and if add, whether to use integer addition or float addition and if they're mixed do the float conversion, etc, etc, etc. Further, if this expression is part of a loop, there's no guaranteed that what's in the variables will take the same path each time so you have to do all the checks every loop. Happily, most code has implicit types. If you're adding up the numbers in an array, they'll usually all be ints or floats together. A JIT compiler can notice this and boil all the checks down to a pair of assertions that `a` and `b` are still ints and if they are, do the add or take the slow path if they're not. With asm.js and wasm, the compiler can *know* that they're both ints and skip the check. The final one I'll mention is code transformation and inlining. Say you write something like `[1,2].map(x =&gt; x + 1)`. An interpreter would have to allocate the source array, copy the values into it, lookup the `map` method (you might have replaced it), allocate the destination array, and walk through the array, calling our increment function for each element, and putting the result. Making a function call involves copying over the local variables, copying the return value back into the calling context, and some register book-keeping, which is a lot compared to incrementing a number. Most of the computational effort in our loop is a result of how we've written the code. A JIT could notice that the function isn't getting reused anywhere and we're not really doing anything special with it and inline it (basically copy/paste the body anywhere it's used), which eliminates the function call overhead but makes the code size bigger. It'd probably inline `map` as well and boil our code down to allocating the source and destination arrays and then doing the equivalent of a `for` loop. A smarter compiler (e.g. one producing wasm) could notice we're working off a static array after all the inlining and just write `[3, 4]` in the code. There are lots of small details like this that combine to make many dynamic languages slow. You can design your way around some of them. The `J` and `Q` family of languages is infamously fast despite being completely interpreted because it works on vectors of data with the slow interpreted part being used to line up fast built-in operations with good memory access patterns. Complied languages with magaged runtimes can take advantage of most of these tricks, yet Java, C#, and Go have a reputation for being slower than C / C++. Why? Memory access patterns. **Memory Access** Think of the CPU pipeline as a factory machine that consumes raw material (data) that's in a big pile called RAM. Back in the day, the pile was right next to the machine so the worker filling the machine would just grab whatever was needed and toss it in. These days, the RAM pile is now down the hall. Just grabbing something means walking all the way down the hall, finding it, and coming back. As a result, the machine mostly sits there doing nothing while the worker is running back and forth... The performance of CPUs has increased by something like five orders of magnitude since the 70s while the performance of the CPU's connection to memory (Front-Side Bus) and the memory itself have only increased by 2-3 orders of magnitude. As a consequence, pulling a chunk of data from RAM takes 100s of times as long as a normal CPU instruction. If you want your program to go fast, not having your CPU's pipeline stalled for hundreds of operations is a good idea. Fortunately, the intrepid hardware developers have come up with a solution. Instead of our nameless factory worker fetching data one at a time, they install a conveyor belt. The worker stands next to the machine and guesses which data the machine will need next and the data comes in on the conveyor belt. As long as the guesses are good, the machine chugs along at full speed but if the guess is wrong, the pipeline stalls while the fetch from RAM happens. In a processor, a chunk of hardware pre-fetches data from RAM into the local L1 and L2 caches based on access patterns. It does this in cache-line sized chunks (64 bytes on most architectures IIRC) because it costs the same to grab the full cache-line as it does to grab a single byte and data access tends to cluster. The pre-fetcher looks at your code's data access patterns and guesses which data it'll need in the future. The easiest pattern for pre-fetch to guess is walking through an array. If you're walking through an array and all the data you need to work on is in the array (e.g. it's an array of floats) then the CPU will have all the data it needs, the hardware will be busy, and your processing will go very fast. Alas, this isn't always the case. If you have an array of objects, the actual object values aren't in the array but pointers to those objects (pointer is an int representing a memory location) and in order to get the data, you'll have to follow the pointer and load that memory location. The pre-fetcher will probably not be clever enough to predict where the objects are allocated, so you'll get pipeline stalls and your code will be slower. In C++ / Rust, the structs (think fixed shape object) are placed directly into the array. If you run across discussions about "value types" in .Net or Java, that's basically people wanting to be able to do the same thing in those runtimes. It's not the default because there are tradeoffs involved. This topic is pretty important for how little it gets covered. If you really want to know more, "What every programmer should know about memory" is 100 pages and covers considerably more than you probably want to know about memory. I also recommend [Mechanical Sympathy](https://mechanical-sympathy.blogspot.com/).
The incrementer will happen after the loop is executed. So x will follow 0-&gt;1-&gt;3-&gt;6 and i will follow 1-&gt;2-&gt;3-&gt;4. Output will be 6, 4.
I don't understand how it would be biased if they selected them from a blind review?
Time to rethink my private GitHub repo. I cannot conscionably support an organization that not only engages in sexism, but forces a political element into the equation that doesn't need to be there.
&gt;Why does a gender have anything connected with the talks? I can't speak for the organizers, but generally when you implement a bias toward diversity (which this pretty clearly demonstrates), it suggests that you see some inherent value in a diversity of perspectives rather than strict subject matter meritocracy. If you don't see that value, don't go to the conference, or better yet run your own. 
&gt;diversity of perspectives You mean diversity of skin and sex organs. They don't care about your diversity of thought, in fact, they want a very homogeneous way of thinking.
This sounds as too ridiculous to be true. Suppose there was only one speaker. Suppose it was a male. Discrimination! Sexism! Uh, yeah. 
It was a blind review process. The fact that they were all men had nothing to do with it. The talks were chosen on the content.
There's some choice comments on twitter here like &gt;itd be helpful to blog about how &amp; why it happened. Theres process fail here, so a retrospective would be useful for others to learn from. Clearly must be process fail here if an unbiased blind review process was used. I can only see it now, the fail will be deemed either there weren't women in this blind review process or there weren't enough women. Considering that this is GitHub they certainly had women in the process. If they didn't have enough women, they'll find that even with an even amount or more women that they are simply not getting enough or any women through the process still. Finally, they'll claim that the amount of submissions by women are dwarfed to the point that the sheer odds are stacked against them and that they'll have to make at least two blocks, white males, and minority to ensure even amount of speakers are drawn, while still claiming that the process is an unbiased blind review.
Sad!
It appears that [this discussion was censored](https://www.reddit.com/r/programming/comments/6f7l7x/electronconf_postponed_until_a_more_diverse_slate/) (as it's no longer listed in the sub) by /r/Programming after it quickly became the top posting, receiving 100+ upvotes.
This isn't an issue to deal with if that means lowering the quality of your conference, as the entire process was supposedly to garner the best talks. When you are trying to attract people based on content, you're clearly not doing so when you're more concerned about diversity of the speakers.
Hey, thank you for replaying. It is right what you said, just a silly browser game I have been playing with, too much free time lately...but it is not a button to do things in game, you are supposed to click this button to vote for their game in another website and then after submitting the vote they would give you some privileges, and to reuse it you have to wait 3hrs, thats what I would be looking to bypass.
I've been taught my whole life to treat everyone as equals, but you're saying that developers should be smart enough to actively discriminate against people based on their race and sex? No thanks. 
IMHO, the UI is shit, and it doesn't have nearly the employee cachet of a github profile.
Yeah, I'm familiar with games doing that sort of thing. That's definitely something they validate on their servers, bypassing the button would do nothing. You'd manage to send the request to the server and it would simply fail there. 
This is a great move. GitHub has a long history of treating women like heck and they owe it to the developer community to have a diverse set of speakers.
I was wondering if it was blind review. Any archives of the CFP or any other evidence that says it was a blind review? **Edit** Nevermind, I see the selection archive page above
They just redid their UI. I'm not sure I'm a fan yet, but it is different.
Hmmm what a shame, I don't know why I thought it was somehow possible, anyways, thank you for taking the time!
Where are the people with backbone in our society?? Why have all the people in charge of anything turned into gutless caricatures? How does being female automatically bring insight and added value to this conference...insight and value that could not come from men? Isn't that an incredibly sexist perspective? I feel like I'm taking crazy pills. Looking at that Twitter conversations, where are all the men? I see one woman complain, another woman confirm that it was a bad idea and then several other women start talking about process reviews. 
&gt;Are you implying that women aren't proposing talks of the same quality than the men? There is no implication here, every talk that was accepted in a blind review process was proposed by a man. Full stop. This isn't saying that women are inferior to men, it's saying that in this instance, the best talks were proposed by men. The end. &gt;It's like saying the United States win more medals at the Olympic Games because they're naturally better. And yet they still give the United States the medals when they earn them, they don't skip over the United States and award the medal to the next runner up. Human knowledge does not move forward based on the sex organs of who presents ideas. Human knowledge moves forward when the best ideas are shared. Women can learn from talks presented by men, men can learn from talks presented by women. The speaker doesn't matter, the quality of the presentation does. You don't need "representation" for a talk to be good. Anyone who refuses to listen to a talk because the speaker doesn't tick off a diversity box is a sexist or a racist and has no place in the conversation at all. 
What if their handbags are of the wrong brand? Doesn't count if they can't girl.
Yeah, we're just used to GitHub's, but I don't think it's that bad.
&gt; But there is most certainly a natural bias created by the big gap in numbers of male/female devs. there is no evidence that this gap is due to hiring bias. that is a SJW woo-woo talking point. &gt; Having a male only conference continues to spread the idea that women don't code or aren't good enough to be speakers. So if I go to a fashion conference, and only see female and gay men speaking, I should think straight men can't do or aren't good enough to do fashion? It's intellectually lazy and insulting to the rest of society to argue that we're all simple minded creatures that will automatically jump to that conclusion. 
Typical that this comes from the company who banned their own own slogan because apparently, "meritocracy" is sexist, racist and homophobic.
TL;Dr 1. Slice.call(nodelist) 2. Array.from(nodelist) 3. [...nodelist] I prefer Array.from To me coding style is all about declaring intent in the most readable way. I think the spread operator (...) is still too uncommon to be super readable, and Slice is a bad method name to use if you are not slicing away a chunk of an array. Sideote: wht didn't we get nodelist.toArray()?
Yep, exactly.
It mostly a coat of paint, though. The issue tracker is still shit and navigating a repo on their site still makes no sense.
&gt; one conference that is trying to address that By rejecting speakers because they have the wrong gender. That's gender discrimination aka sexism. Going with whatever the blind review came up with would have been the correct unbiased choice.
It's dangerous to disagree with these people with an account that ties to your real identity, because they will literally harass your employer until you are fired and blacklisted from the industry.
Maybe. I don't think I've ever used their issue tracker. I primarily use it for private repos for me. We use stash (bitbucket server now) for a few projects at work (as clients demand.) I have the PR page bookmarked and that's the only thing I use. Everything else I do through the client on my computer.
[removed]
jokes on them. I'm currently unemployed. But thanks for the heads up. I thought I had already removed any identifying info from my post history. 
Does having a woman on stage automatically boost every other woman's coding ability? No. Going to school, studying, and practicing is how you get better at programming. There is no "positive discrimination" required for someone to put in the effort to learn something on the internet until they master it to the point where they can go on a stage and teach others what they have learned.
When you're referring to VCS as SJWs I think you may be forcing it. 
It doesn't have to be even but you would think they would try to get at least a couple women, people of color, etc... It really doesn't matter but since our society inherently views men as more capable, sometimes you have to have "artificial" diversity. I don't think it's a bad thing to make sure it's not just dudes. 
Dude... that's awesome!
&gt; since our society inherently views men as more capable no it doesn't. stop projecting. if you really think that, you are the sexist one who needs help.
Well the situation right now is that, say, they have selected 10 people to give talks, but they're all men. Assuming they don't add more days to the conference to allow more talks to be presented, they're going to have to remove someone from presenting from this conference. That means that at least one person is going to be removed for no other reason than their sex organs, and that is evil.
Disgusting. Absolutely disgusting. In an attempt to show "diversity", you instead show deliberate "bias". Bad taste in my mouth.
Considering that we are calling oppression in this instance not having a 200K a year job a country were the majority of the homeless are men, I don't think that is something people are ever going to understand. Positive discrimination based solely on gender as if that is even the biggest barrier to entrance into tech is bullshit and insulting to the millions of actually oppressed people in America, regardless of gender.
/r/ProgrammerHumor
It doesn't matter if it's a blind review if Github didn't make the effort to encourage more submissions from women. The problem isn't with the selection process, it's with the submission funnel. People in this thread seem to feel like the gender imbalance is just the way of things. It doesn't have to be, and surely being able to identify with a speaker on stage is something that will help. FWIW, I'm an engineering manager at Udemy with a 50/50 gender split on my team.
You're a literal Nazi edit: I am literally shaking
Hey @nemohearttaco: It seems like mapping the values is what I want to do. I took your snippet and edited it: const arr1 = ['issue', 'email', 'caseDate', 'phone', 'status', 'ID'] const map =[2,5,3,1,4,0] const arr3 = Array.apply(null, Array(map.length)) arr3.map((d, i) =&gt; arr3[map[i]] = arr1[i]); However that gets me: mapping ["ID","phone","issue","caseDate","status","email"] I wanted it to get me: mapping["caseDate","ID","phone","email","status","issue"] What am I missing here? it does not seem to order it based on the number I placed in the map.
Considering the entirety of the human race seems to have trouble deciding what gender is these days, I choose to refer to people by their sex.
[removed]
Identity politics. Also known as cancer.
&gt; sex organs Gender.
Change my view: It should also be removed here because it really has nothing to do with javascript (at least in the /r/javascript sense).
[GitHub's selection process](http://www.apeer.org/wp-content/uploads/2012/06/IMGP1051.jpg)
This is the best tl;dr I could make, [original](http://electronconf.com/) reduced by 85%. (I'm a bot) ***** &gt; You hereby release, waive, discharge and covenant not to sue GitHub and its respective parent companies, subsidiaries, affiliates, officers, directors, partners, shareholders, members, agents, employees, vendors, sponsors, and volunteers from any and all claims, demands, causes of action, damages, losses or expenses which may arise out of, result from, or relate in any way to your attendance at the Event or any related event, except, of course, for any gross negligence or willful misconduct on our part. &gt; While we hope not to, GitHub may prohibit your attendance at any GitHub event at any time if you fail to abide by these Event Terms and the Code of Conduct, the GitHub.com Terms of Service, or for any or no reason, without notice or liability of any kind. &gt; We reserve the right to cancel the Event or any related event at any time, for any reason, and without liability or prejudice. ***** [**Extended Summary**](http://np.reddit.com/r/autotldr/comments/6f9u3f/githubs_electronconf_postponed_because_all_the/) | [FAQ](http://np.reddit.com/r/autotldr/comments/31b9fm/faq_autotldr_bot/ "Version 1.65, ~136444 tl;drs so far.") | [Theory](http://np.reddit.com/r/autotldr/comments/31bfht/theory_autotldr_concept/) | [Feedback](http://np.reddit.com/message/compose?to=%23autotldr "PM's and comments are monitored, constructive feedback is welcome.") | *Top* *keywords*: **any**^#1 **event**^#2 **GitHub**^#3 **Terms**^#4 **relate**^#5
I thought the phrasing "the way of things" made it clear I was speaking about the industry, not this conference's speakers. In the reference to coal miners, have you heard of [whataboutism](https://en.wikipedia.org/wiki/Whataboutism)?
It's a down vote train for this viewpoint, but I knew that when I posted :)
What's their history? [Getting rid of meritocracy because they thought it wasn't inclusive enough? ](http://www.businessinsider.com/githubs-ceo-ditches-meritocracy-rug-2014-1)
I'm going to have to assume that if conference ticket purchasers turn out to be overwhelmingly white and male, GitHub will turn away these paying customers and give a proportional number of seats to women and minorities for free or at a substantial discount.
I don't understand why it's a bad idea to make sure the conference spotlights different types of people and ideas coming from different types of people. I get that it might result in a "biased" conference in the sense that some speakers are elevated over others due to the desire to be more inclusive, but isn't that a price worth paying? Don't we want to actively try to make the future of our field more diverse? Instead of downvoting, tell me why you disagree. Help me to understand.
&gt; I'll wait to hear how being black or a woman makes you a better coder It's not that it makes you a better coder. Diversity is important because people with different backgrounds have different ideas, perspectives and ways of approaching problems. Women and men are an extreme example of this. The actual structure of our brains is different. We don't want more women in the industry because they're better than men but because they will see problems from a different perspective and go about solving them in a different way. Having more diverse ways of approaching and looking at problems is beneficial to our industry. 
Thanks man! Had fun doing it :)
Prettier is an amazing tool. It seriously changes the way you think about formatting - by eliminating it completely. It's fucking marvelous. 
is there a black way or female way to write code? Does the syntax look different?
&gt; sex organs Gender.
[removed]
Code is an artifact of what we do, it is not the work itself.
Had to scroll way too far down to see a reasonable response. There is, currently, an imbalance between men and women in engineering. This imbalance is particularly stark when it comes to talks and conferences. Every time a company tries to take action to improve things, there's a backlash, which only further discourages women from pursuing careers in engineering. I am glad to hear Udemy is doing better than most companies in the valley. Keep up the good work!
10/10
Openly trans you mean. Every speaker on the list could be FTM trans for all you know.
Github is a private company who claims to want to promote diversity in tech. Apart from anything else, their responsibility is to their own values.
Being black or a woman will influence your approach to solving problems, yes.
This is a joke question right
I'm playing devil's advocate because these posts always get reported for being off-topic (likely why it was removed from /r/programming as well). I kind of agree, on account that the news topic is non-technical, but will agree to disagree (and thus leave it up).
&gt; (at least in the /r/javascript sense). The title of this post implies some racial/sexist conflict which isn't exactly the type of thing you see everyday around here. But I disagree with kenman: removing it doesn't make sense, it would just be seen as another type of censoring.
&gt; You're being intentionally obtuse. 
I downvoted because your idea of diversity appears to be gender instead of diversity of ideas. You can take a room full of 100 cis straight white men and have a diverse set of ideas, just like you could take a room full of a mix of all races and genders and have almost no diversity of ideas. When your diversity boils down to skin color or gender, you're not an advocate for diversity, you're just a bigot.
It's kinda about as relevant as it could be right ;-) 
Pretty disappointed by the response in the comments. I hate any kind of SJW bullshit, such as the Nodevember fiasco, but women and non-white ethnic groups are underrepresented in software engineering; so as long as the quality of the talks is not impacted, this is a good thing. On the other hand, I read the Twitter conversation in which a presenter stated he found out about the postponement via a Tweet; GitHub should have handled this better and it would suck if some of the talks were cut as a result. If anything, there should now be more of them.
Wow, another case of a diversity quota ruining quality. I don't give a fuck if all the speakers are Chinese homosexuals or transgender Norwegians, as long as they are best for the conference. Getting real sick of this overly pc shit.
So if you were one of the men who had their talk selected through a blind selection process because it was one of the X best topics presented, you would be okay with someone telling you that you can no longer give your presentation for no other reason than because you are the incorrect gender? You call this a good thing?
Weird, I thought being a developer was about writing code, not about looking a certain way.
I would be disappointed, but would ultimately understand why the decision was made, as is corroborated by [these](https://twitter.com/framerate/status/871394328114896896) [tweets](https://twitter.com/mrfunkycold/status/871388405287895041). This is ultimately to assist diversity, not to penalise men for belonging to the "incorrect gender." Your choice of words there was poor.
Maybe you're okay with watching people be victims of sexism, but I'm not. &gt;Your choice of words there was poor. My choice of words there was accurate. This is literally what is happening with this conference. Literally. In no uncertain terms, men will be told they can no longer talk because, despite being selected as having the best topic, they are the wrong gender. 
Explain how this shows a hatred of women. If you can't defend your buzzwords, don't use them.
It's about encouraging diversity in submissions, not diversity in selection.
Six of one, half-dozen of another. 
The problem isn't that they want to be more inclusive, but that they didn't factor in this decision when they were picking all the speakers and as a result people who were going to speak effectively got canceled because they're dudes. If Electronconf wanted to take some time to find women to give speeches as well, that's fine, but for them to completely disregard the speakers that were going to speak because of the speakers gender is also sexist. Perhaps instead of completely disregarding the male attendees because electron's female audience might be smaller or more marginalized, perhaps they could start with female developer outreach and leave the speakers alone if they haven't done anything wrong. They shouldn't need to break down the rest of the electron community in order to build up female attendance. Why couldn't Github start with it's own female electron developers and then use that dogfooding to attract other ladies who might be interested in the project. I doubt Github is so sexist that they don't hire any ladies to code Electron or Atom. Perhaps have a small showcase of some sort that shows what those developers (develophers?) liked in the project and didn't like, and use that to market to other female coders.
The reason I love programming is because literally anyone who has a computer and an internet connection can teach themselves, the only limit is how much energy you're willing to pour into the endeavor. I don't care what the gender split of people who choose to be programmers is, I respect the right for everyone to choose how they want to spend their time. If more men or more women choose to become programmers and put in the work, it doesn't matter to me. I don't give a damn about equality of outcome, I care about equality of opportunity.
You would have a point if all men were prohibited from participating in, or at the very least being unrepresented by the conference, but this is not the case; there will still be men at this conference, and I imagine they'll still be the majority. This merely a small sacrifice for diversity.
&gt; The title of this post implies some racial/sexist conflict which isn't exactly the type of thing you see everyday around here. I refuted the claim that it has "nothing to do with javascript", and even the title relates it to a JavaScript conference. So not sure what this comment was responding to.
I have a point because someone was chosen, and will subsequently be told they are no longer invited to speak because of sexism. Why are you ignoring the point where people who were selected to talk will no longer be allowed to talk?
Lack of positive discrimination is what has caused the situation in the first place. As per the above comment, &gt; surely being able to identify with a speaker on stage is something that will help. 
How? Our experiences influence our base assumptions, the questions we ask, the problems we choose to solve... and being black or a woman will certainly provide you with experiences that I would not have as a white male.
Currently, the gender split of people who choose to be programmers is not representative of the overall population. Doesn't this fact prove that there is not currently equality of opportunity?
You do know women had just as big a hand in creating this industry as men right
It only means that one is more bad than the other, but both are shits or too big and complex :D Seriously. But yea, definitely, React is total leader for me (disclaimer: i'm not using them) and Angular is total overkill and mess. No one should use Angular for something new, it will be dead sooner or later. And it's totally recommended to switch such code bases to something other - Polymer2 for example, again Google's thing, but in right path.
I'm not talking about actual participation. I'm specifically talking about the failings of this push for higher participation. If women were interested in these fields to the point where participation matches gender distribution, then it would have happened already with all the money spent on encouraging it.
You might be right about their intentions, but that doesn't mean it's not a good idea to encourage diversity of population type based on geographical background, gender, race, etc. I feel that it's fundamentally a good idea to diversify.
Who cares if it represents the overall population? Other careers will have unbalanced gender ratios as well, whether it's male dominated or female dominated. Different people are interested in different things. When I logged into the internet I was never asked who or what I was, I looked up things that interested me and learned to write code on my own. Anyone can do this. ANYONE! Boy or girl, black or white, go fucking read a tutorial! But maybe if we're trying to justify 'diversity' by saying that these people have different 'perspectives', maybe people need to consider that more men than women find coding to be an interesting hobby because our brains are different, and we shouldn't expect the entire pool of developers to be 50% male and 50% female. Anyone with an internet connection can try to be a programmer, that's as equal as it gets.
He obviously means the people within the organisation. I don't know about gitlab, but it's very obvious Github is run by SJWs. Evidence in the topic we're commenting on.
It may be true that anyone with an internet connection can try to be a programmer if you work from home, but not necessarily in the work force.
&gt; women and non-white ethnic groups are underrepresented Asians are white now?
No, I don't think you're following what he's saying. He's saying that if you just open it up, you get the same people who have been in the industry for years who were pre-filtered by a variety of systems. He had to go back and *look for* the women and minorities who had been filtered out before they even got around to submitted a resume to him.
Oh, do you have stats on the submissions? Can you link them?
https://insight.kellogg.northwestern.edu/article/better_decisions_through_diversity 
The attitude that "women aren't interested" in STEM is provably false and also creates a positive feedback loop. Many of the women who become discouraged from participation do not do so because of the nature of the work, but by the attitudes of those surrounding them. And that can happen at any stage in life, in increasingly subtle ways.
Nothing feels more like inclusion than being chosen based on your genitals after the fact it was shown none of the female/ minority talks were up to standard. Imagine being one of the women/ minorities selected for the round 2 of the conference. You'd feel like an absolute token. Simply there to meet a quota. And imagine the man (or men) who get kicked out because of their genitals. Your talk was good enough but you're the wrong sex. What an embarrassment.
This is a really good point. Universities are just starting to take proactive measures with respect to this, spending money, time, training, and effort trying to encourage more diversity in their cs programs.
Interesting claim : I would wager social stigma and norms are a hundred times the cause here than difference in brain structure. Fuck I feel grossed out by half my CS classmates. Lack of hygiene, lack of social skills, really turned me off from the field for a while.
`bool gender; // true = man, false = woman` ...a year later... "Hey Johnson, our customers have been asking for an 'other' option on the gender field. How much work would that be?" "About two days to change all the places where it's assumed to be a boolean." "Nevermind then."
Good to see Angular going away, where it belongs.
This doesn't mention race or gender? It's more of the​ diversity in the sense of personality and background history. 
Huh? I can reply to any _person_ I please. You are the only one hijacking with this flamebait... which I probably made a mistake by replying to. 
[Morning scrum at GitHub be like...](http://68.media.tumblr.com/9110c6ccfb21bfdaaafbf85dc22c42d2/tumblr_nm8xq04vBw1us2puio1_500.jpg)
oh ffs. seriously? now we have to do this shit here too? Can we just dress presenters in cloaks and use voice scrambling so that nobody knows whether or not they have a penis or vagina...or a tennis racket? 
"The system" in this case may well discourage submissions from highly qualified people that they can more actively recruit. Then others members of under represented groups will see someone like themselves succeeding​ in this industry. Knock another brick off the wall.
Can you provide an example of how they would implicitly or explicitly be discouraged from applying if they were already qualified?
The problem here is that a blind review process still draws candidates from a systemically biased pool. So while the reviewers themselves are not guilty of bias, the selection still represents the challenge of representation the tech industry is facing. That is the reason conferences should make an outright attempt to diversify their speakers. I commend the organizers for making the very uncomfortable decision to postpone, because it couldn't have been easy (see the highly upvoted reactions as evidence). Consider that privilege can often be invisible to those with it: it may make men (as most of you are undoubtedly male) uncomfortable to contend with the issue of gender in this otherwise apolitical thing, but for those outside the male gender, it is not an option to ignore it. Women in the tech industry have to grapple with gender every single day. Men have the privilege to ignore it and chalk it up to an unfortunate reality.
I've let it run for 50+ generations now and every now and then a standout will show up, persist for a few generations, then drop off with apparently no net gains to the population. Definitely nicely done, but it might be worth taking another look at how you're judging fitness, or mutation rates, or something that would seem to be preventing any persistent improvement. 
Github made two mistakes here. The first one was to use a blind review process in the first place, if the goal is to attract both quality talks and diversity. Of course the vast majority of the quality talks will be from the largest demographic, duh! With limited time, you can only have so many talks, and that means that minority applicants apply with a big disadvantage of being selected. Suppose you have 70 male applicants and 30 women, and 10% of each group has the best talks. The men group then has over twice the chance of being selected. The second mistake Github did was to go back on the agreed talks after they got a selection they didn't like. When you make a moronic mistake like choosing a blind review process with no reserved spots, at least own up to it and stick with it, and promise a more fair review process in the future. By changing their mind after the fact here, they get into a lose-lose situation and come off as very prejudiced even though it's not the intention. Apparently they didn't even notify the selected speakers that their talks got canceled. Maybe next time they will reserve some talk time specifically to minorities in addition to having a blind review process. Basically, the whole process strikes me as very clumsy.
* Do all exercises in [Structure and interpretation of computer programs](https://mitpress.mit.edu/sicp/full-text/book/book.html) * Read [Design patterns](https://en.wikipedia.org/wiki/Design_Patterns). * Read about the internals of a JS VM (pick one).
Perhaps they've read threads like this one...
Did they just assumed the speakers genders?!
i hope they make sure to also include all race and sex variations. caucasian male and female, african decent male and female, asian m/f, indian/eastern m/f... and then another couple for each religion. let's not forget transgender. and redheads. :) I demand all race, gender, and religions to be equally represented. no matter how much it has to do with the conference.
Now imagine that photo with men holding the signs. Really makes your neurons fire.
&gt;When fascism comes to America it will be called anti-fascism Hmmm... no one could be this stupid. *Checks user* Oooooh, ancaps! That explains it! 
they aren't complaining about lack of representation in coal mining though.
"The system doesn't funnel you women... it's a self-perpetuating system" Unbiased blind review of a biased system doesn't produce an unbiased result
Why care for Electron anyway. The whole design behind Electron is a joke.
Your comment has no argument or substance. Just more identity politics. 
Well if their goals were to sabotage the whole point of the conference, then yeah i agree. Rescheduling a professional conference is basically a death knell, people have jobs, plane tickets and reservations. Not to mention doing it at the last minute, without warning the speakers, with no postponed date, for obviously sexist reasons and in a blatant display of hypocrisy.
that's fucking dumb
Weird how that works right...
Unfounded accusations of misogyny are toxic. Stop
More like Electrons fire amiright
Personally, I don't care what the person giving a talk identifies as. In fact, why should that even matter? At a talk, I'd like to see the best presenters with the best talks. The talks were chosen in a blind review process. The best, most diverse set of talks were chosen. Now the presenters are being they cannot present because of their race and gender. Isn't that the definition of discrimination?
I have a hard time reading scholarly articles about subjects that aren't my specialty, but the NY times has an article that I think really hits home about this. Though it focuses on civic engagement and social capital, I think it's a really good starting point for anyone that's trying to reconcile their personal experiences with a diverse environment, and what they're told about diversity. http://www.nytimes.com/2007/08/05/world/americas/05iht-diversity.1.6986248.html The small bit on the workplace in this article explains: &gt; "Because they see the world and think about the world differently than you, that's challenging," says Page, author of "The Difference: How the Power of Diversity Creates Better Groups, Firms, Schools, and Societies." "But by hanging out with people different than you, you're likely to get more insights. Diverse teams tend to be more productive." &gt; In other words, those in more diverse communities may do more bowling alone, but the creative tensions unleashed by those differences in the workplace may vault those same places to the cutting edge of the economy and of creative culture. &gt; Page calls it the "diversity paradox." He thinks the contrasting positive and negative effects of diversity can coexist in communities, but "there's got to be a limit." If civic engagement falls off too far, he says, it's easy to imagine the positive effects of diversity beginning to wane as well. "That's what's unsettling about his findings," Page says of Putnam's new work. This article also seems to be a good source on how diversity specifically impacts the economics of a business (ie they actually cite sources but also write in a way i can understand): https://cluteinstitute.com/ojs/index.php/JDM/article/viewFile/8974/8934 I think the tech sector, as a whole, seems to struggle with supporting social causes, and preaching it strongly, yet does an absolutely shit job of actually explaining why things matter (which is a bit ironic for an industry built on questioning the status quo and being innovative), and there's a big stigma about daring to ask why diversity matters. As to get back to your specific question though, I think some big issues could be circumvented by asking questions that might not occur to a largely homogeneous group. For example, snapchat has a bunch of 'beauty filters', that are largely fun like adding a flower crown or puppy ears, but it also whitens the user's skin. The same company also had a bob marley filter last year that also effectively applied blackface to a user. If you had a more diverse team, especially at the management level, you can see how someone would probably have asked some big picture questions like 'given the historical context of black face and minstrel shows in this country, is this ok?'
&gt; A cornerstone of those ideologies is the assumption that the human species is divided by actual races [...] and that the race has an important influence on those people, with no exception. Sure, and of course there is no major physiological difference between the races -- they are largely social constructs. But that does not mean they have no effect on a person or the lens with which they view the world. &gt; Every problem a black person can have among white people can happen to a white person among chinese people living in china. No, they can't. Nothing happens without context (as you alluded to later in your post), and history is just as important of a contextual factor as any. Sure, of course a white person can feel isolated and lonely and out-of-water in a country foreign to them. But that is not the same as those feelings felt by black people in the Western world (specifically, in this case, in America). Furthermore, a woman will invariably have different experiences than her male counterpart in any reality-based circumstance. In any case, that line of argument is at best tertiary to the case at hand -- this is a conference in America hosted by a private corporation that values diversity. A list of speakers entirely composed of white men does not reflect those values and only amplifies our industry's already homogenous nature.
It's easy and common not to care about things that don't affect you -- or benefit you at others' expense.
Indeed, but not in the way you think it is.
Well the conference was supposed to adress that question i guess. Which is why it's a bit idiotic for them to do this sort of thing if they want to promote their tooling.
Mel Gibson?
Nah, Jesus looked like a Jew, everybody knows that.
&gt; I don't think it's a bad thing to make sure it's not just dudes. Do you think it's a good idea to select, say, three to five female speakers, simply so that there would be some female speakers? How would you feel about being selected for that?
&gt;Men too face these issues. From school teachers predominantly being female and treating them poorly compared to their female students (male teachers afraid of the industry due to potential for paedophile accusations from the paranoid). To the massive amounts of violence men face in comparison to women. To the huge suicide rates. This is completely beside the point, unless you are just trying to appeal to emotion and create a false equivalency. This isn't the oppression Olympics, it is seeing a problem in our industry and trying to fix it. &gt;Any FTM trans can tell us about how they started thinking more logically after their transition. The gender roles aren't the only differences between the sexes, there are real actual physical and neurological differences too. Are you really making this argument? This is insulting. 
So you're talking specifically about creation? Then it's even more one sided. Ada's foundational paper might be remarkable (if you like huge footnotes to Italian papers that are longer than the actual paper), but it's nothing compared to the sea of publications that both inspired it and built upon it, Boole, Pascal, Babbage and all the others just did more than the single women in the field that didn't exist yet. And if you think CS was born not in the purely theoretical ramblings of Babbage but in the electromechanical days, there is even less of a contest. Women did less both to create and to perpetuate CS than men did. It's a fact, and though it really doesn't matter all things considered, you can't use the opposite of facts as an argument.
&gt; But that is not the same as those feelings felt by black people in the Western world (specifically, in this case, in America). I fear i have to agree to some degree on that part. As a European that has quite a few friends throughout the different countries of Europe and to some degree in Asia, i am getting baffled about how out of hand these things seem to be in the USA. I have never heard of anything comparable to those things that seem to happen on a weekly basis in the USA. What is happening over there that openly used racism and sexism towards a specific group is not rejected by society? I would go as far as saying that this behavior would be, to some degree, illegal over here and whoever made the decision to cancel that event based on gender and/or ethnicity should prepare for legal actions. We have quite an open-minded society throughout the different countries. With most of them having an equivalent to same-sex marriage, equal rights and women on high ranks in politics and all that without safe spaces, forced quotas based on gender or ethnicity. Yes you make different experiences in the USA but that has nothing to do with skin color. I am already shuddering just by reading and thinking about that. I cannot imagine how i would feel if i was chosen to speak at a conference and being later refused just because i have the wrong skin color or gender. This must be a horrible feeling and this reminds me to our horrible history.
&gt; unless you truly believe men are smarter than women and therefore deserve all the good jobs Are you really making this argument? This is insulting.
Well you see the minorities don't want to simply accept they are inferior so whenever things meter out they get mad and cry and try to implement laws. Affirmative action, Diversity is our strength etc etc
…with thunderous applause.
So now they're going to cancel male speakers ONLY BECAUSE THEY'RE MALE. wew
Is this a strawman? How is it that I cannot relate?
Gender is just a social construct, it shouldn't matter that it was all "male" speakers. It's not even a real identification.
Neither of those examples are a good thing. They are both very hacky. It's like converting shit into puke. 
They aren't complaining about a lack of representation in the waste management field.
Interesting when you add nodejs to the chart...
Try code academy. Very helpful. That's where I learned along with the book Eloquent Javascript. I'm employed full-time as a developer. Code Academy is kind of fun. Try it out. 
So? I'm not writing his homework for him, the only ES6 feature in there is the template literals, the question was about the function. If that's a no go I'm sure he'll manage to figure out how to alert some strings. 
seeing RoR's nosedive in 2017 also gives me pleasure. :D
&gt; The teachers's not the greatest, and I've honestly learnt nothing Not to be snide, but you only have yourself to blame. At this stage you could learn a ton just by using google for an evening. 
That's a fair point, though I do strongly believe that concepts I need to know and use should be found in and through the classroom.
Down voted because you asked for data...wow. 
I've heard Kyle Simpson talk specifically about reading an article discussing how Prototypes were arguably a superior methodology by showing how Class-style inheritance could be "replicated" with prototypes (like classes in JS), but that prototype-style delegation could not be replicated inside a class-based programming language. Any help would be appreciated!
that's not weird at all?
I have noticed that too, but haven't stopped to debug it yet. Just made a working version and posted it. There are some winning cars that are a brighter white, those are more than one car that looks exactly the same running side-by-side. Maybe those are washing off the standout that is alone. Even if the standout finishes up in first, the 5 (guessing a number) look-a-likes that did well will end up having a higher chance of breeding. Will investigate further when I have the time.
Your interests as a dev and Github's interests are not the same, of course. This conference is as much a promotional vehicle for Github as it is a pure conference in an academic sense. They want to display themselves in the best light, and that means diversity ranked as a value equal to - if not greater than - the maximum interestingness of the talks. And it goes without saying they totally screwed up the organization aspect.
Why are comments like this that seem perfectly sensible getting downvoted this heavily? What's going on in here?
Let me try to explain the differences in perspective: The thinking behind affirmative action is to try and "make up for" lower-level systemic/cultural/social bias and inequality, in this case in order to try and help encourage more or higher-quality submissions from under-represented groups, because they believe this is something they can and should help address at their operating level (i.e. they consider themselves "social justice warriors"). On the other extreme is the thinking that the only "justice" that should be sought in a tech industry context is that which gives the highest priority to technical merit, and that the advantages/disadvantages any given person had in arriving at their level of technical proficiency should be of no concern. This stems from placing productivity as the primary interest, and the belief that any inequality is so deeply rooted in systemic/cultural/social/biological factors that it's probably a waste of time to try and make a difference at such a high level, i.e. affirmative action more-or-less just treats the symptom, not the cause. Personally I find the reason for delaying this conference absolutely asinine - but I'm not advocating for one side over the other, at the end of the day it's just a difference of opinion in whether or not "social justice" is something tech enterprises can (effectively) and/or should help address. Unless people are willing to discuss a middle ground, you might just have to learn to agree to disagree.
**Here's a sneak peek of [/r/GitInaction](https://np.reddit.com/r/GitInaction) using the [top posts](https://np.reddit.com/r/GitInaction/top/?sort=top&amp;t=all) of all time!** \#1: [GitHub is undergoing a full-blown overhaul as execs and employees depart — and we have the full inside story](http://www.businessinsider.com/github-the-full-inside-story-2016-2) | [2 comments](https://np.reddit.com/r/GitInaction/comments/44ioqr/github_is_undergoing_a_fullblown_overhaul_as/) \#2: [SJWs threaten owner to add a "CoC", admit they don't even use the software](https://github.com/syl20bnr/spacemacs/pull/3484) | [6 comments](https://np.reddit.com/r/GitInaction/comments/47j40b/sjws_threaten_owner_to_add_a_coc_admit_they_dont/) \#3: [Remove the term "whitelist"](https://github.com/dotnet/roslyn/pull/3507) | [5 comments](https://np.reddit.com/r/GitInaction/comments/4o9u83/remove_the_term_whitelist/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/5lveo6/blacklist/)
But how is blind review sexist?
I actually really like it because you just use pure JavaScript instead of needing to remember weird framework-specific syntax like `ng-repeat` in angular or `v-for` in vue. Example: function TodoList({ todos }) { return ( &lt;ul&gt; {todos.map(todo =&gt; &lt;li&gt;{todo}&lt;/li&gt;)} &lt;/ul&gt; ) } whenever `todos` changes, the TodoList gets rerendered. tldr: i personally think its a lot more elegant to add the HTML into the JS so that you get the full power of the language rather than trying to add logic to your HTML templates like angular.
I think positive discrimination to set an example and give inspiration to a minority has is place, but similarly I don't think anyone is claiming women can't be developers. In fact, there are numerous well-known initiatives to promote development as a profession to women and girls; of all professions out there that girls are being told they *can* pursue, I should think software development is damn near the top. It seems pretty astonishing to me that organisers didn't happen across a female applicant that made the cut, but I also doubt they're sexist, consciously or not. Ultimately, it seems like a bit of a dick move to change the dates of an event after it's been decided and people have started planning. Additionally, I presume some people who have recieved invitations to speak will now have them retracted.
Insulting? It is something you literally believe. &gt;Any FTM trans can tell us about how they started thinking more logically after their transition. The gender roles aren't the only differences between the sexes, there are real actual physical and neurological differences too.
The problem is not that women need help learning to program. They're perfectly capable on their own. It's about showing that it's an acceptable, normal, respectable career for women to pursue too. 
Is there any evidence that women help solve problems in this way? Everything I've read says that diversity causes tension and uncomfortableness. Somehow we managed to get to the moon largely without women but now we need them to program?
Science! Reality doesn't require belief. Are you disputing the neurological differences or the power of hormones? That would be an extraordinary claim and require extraordinary evidence. Disheartening that you couldn't read my response without injecting some kind of adversary into it.
That's because coal mining is a low-skilled, high-risk job that is under threat due to climate change and the push to move to renewable energy. There's a lot of places where minorities are under-represented, but it doesn't make sense to focus on opportunities which do not provide strong economic value. Even coal miners are complaining about how job opportunities are disappearing and pay is not as competitive compared to other industries like tech and health care.
An idea which is being discussed in some tech circles in reference to unconscious bias is the idea that the tests are set to fit a preconceived notion of what makes a good coder, speaker, student, whatever - and that those preconceived notions and/or the tests used to distinguish them have always worked so far, when you're basically only choosing between white men, but may not have the same power when applied to a different demographic. For example, there are some educational techniques which can basically erase racial/ SES-based differences in results, and there are some interview techniques which have been found to overlook talented women while selecting less talented men. Basically, if the people doing the selecting have the same mindset and background, they're likely to respond better to applications written from that same mindset/ background without any explicit cues.
Have you ever been in a place where you were unlike everyone else in some way? It can be uncomfortable or even intimidating. Then there's all the examples of casual sexism in this industry that only make compound the problem.
Embarrassing that this occurs. 
"Like this one" doesn't mean this one.
The argument wasn't about the merits of coal mining, as bad as it may be. The argument was that coal mining with all its warts and moles, for as long as it has existed, has not seen equal representation. Arguing that it's not a lucrative industry is facile, because so wasn't sitting on a rocking chair and knitting stuff (which was a comfy norm to follow a few decades back).
I bathe twice a day and smell of Davidoff's finest at all times, so there.
can't be sexist against men /s
On a slightly different track (but not too far off), Milton Friedman had always opposed shit like this (e.g. equal pay). He has a couple of videos which are gold: https://www.youtube.com/watch?v=hsIpQ7YguGE
Thank you based diversity quotas. Maybe now we can finally fix these sexist blind reviews.
deleted ^^^^^^^^^^^^^^^^0.7591 [^^^What ^^^is ^^^this?](https://pastebin.com/FcrFs94k/50035)
Not willing to relocate at the moment. Thanks for your comment.
It's still a minuscule number overall. Just google "apollo team". It's all white men.
I'm disputing that men think more logically than women, which was the implication of your claim. &gt;Science! Reality doesn't require belief. You're right, it doesn't. Whatever you are on, though, does. Also, no need for snark if you want to have a real discussion on this, but something tells me you don't. https://www.researchgate.net/publication/222534750_Negligible_Sex_Differences_in_General_Intelligence
Well, it's been a year since the last time [a tech event was cancelled](http://dailytrojan.com/2016/04/25/point-postponement-sca-panel-reveals-snowflake-culture/) due to lack of women. I guess we were due. "You can't do anything unless it fits a pre-ordained set of regulations and quotas that we deem appropriate." How is this not textbook fascism?
A field dominated by one sex doesn't make it sexist, it usually means there's a biological preference correlating with sex. Assuming that women feel unwelcomed and threatened by a male dominated field just because there isn't a large representation of women makes it sound like you think women are weak, now that is sexism. Identity politics is cancer, merit is all that matters if we actually want to progress in fields. It's not a problem whether there is 1 female programmer or 1000, nor is it a problem if there are 1 male nurse or a 1000, as long as these people are chosen because they are the absolute best for the job. Diversity quotas actually lower quality and discriminates people based on sex or race, because it pushes away those with better merit for the sake of imagined 'social justice'.
Off topic, but if an Uruk Hai ever presented at a conference, I would attend no matter the topic.
So a rich woman/black kid who got an easy life studying in the best colleges should take precedence over a poor male who had to prove his worth through harder work? Why do American think that classes do no exist? It's all about gender and races now. The American Left is dead.
You are not a simpleton, it's just that the word "fair" has gotten a different meaning in media.
Honestly, checkout the response below from /u/i_am_smurfing. That's what's up. Much better than my response imo. But in response to your question, your edit was not mapping to the order you wanted. It would be this: const arr1 = ['issue', 'email', 'caseDate', 'phone', 'status', 'ID'] const map =[5,3,0,2,4,1] const arr3 = Array.apply(null, Array(map.length)) arr3.map((d, i) =&gt; arr3[map[i]] = arr1[i]); 
deleted ^^^^^^^^^^^^^^^^0.4624 [^^^What ^^^is ^^^this?](https://pastebin.com/FcrFs94k/59320)
/r/kotakuinaction
Why are almost no women going to college to study STEM? How can you expect equal market share they go study other things?
?
There is an imbalance, but it goes farther than this. How can you expect that many speakers be female if there are almost no females working in the field? And how could there be when almost none study CS in college? That's the root of the "problem", yet people only look at the symptoms.
The more equal a society gets, the bigger the differences in participation becomes between sexes in all fields, and this is despite spending more resources on women to encourage them into fields where they are underrepresented. Less equal societies where you can't choose freely has more women in STEM fields for example, because they don't have the freedom to chose what they actually want, something we have in the west. Your claim is anything but true for a majority of women, infact nearly everything, including the voices of women, say otherwise. Biological differences, highly correlating with levels of sex hormones, determines our interest in different fields to a greater degree, even amongst infants.
A girl not majoring in CS because she doesn't want to be around a bunch of awkward guys is essentially equivalent to a guy majoring in biology because he wants to be around a bunch of hot girls. In either case the student is making a significant decision about their future without really considering their interests/passions. There's nothing wrong with selecting a field based on of one's peers in that field, but in that case I'd wager one does not have a true passion for that field; I can't imagine strong interests would be thwarted by a higher than average rate if bad hygiene. If someone does not have a real interest in a field then is there actually anything wrong with them avoiding it because of social reasons? And on the note of social stigma of CS, around the time of college major selection it is certainly not considered "cool" to be a computer geek, guy or girl. Why is it then that so many guys are willing to follow their interests and learn how to program in high school, yet significantly fewer girls do the same? The AP computer science enrollment rate is [81% male and 19% female](https://ngcproject.org/statistics), but I don't think any guy chooses to take such a course because he feels it will benefit him socially.
&gt;I think the point is that equally good black/female coders might not even get an interview​, or in this case, be considered to speak Why though?
Not sure why people don't just think of the situation as being the product of many partially collinear influences. Gender, race, class- all important. I don't see a need to oversimplify and I hope others don't either.
Why? Because their's some omnipresent racist force out there stopping those people? If you think that racism is everywhere then you're going to find it everywhere. 
Nothing is physically pushing them away though, so what he said still stands: &gt;it is ultimately up to them to make it happen Social 'barriers' are constructs of people's minds that they have formed based on their perception of society and nothing more, they have the power to overcome them if they'd like.
I thought it was clear here, that we have an industry where though there is an imbalance, based purely on intelligence etc, there need not be. That as a result of a history of imbalance, that it needs to be given assistance to avoid following the worn path of unnecessary imbalance.
Without evidence, sorry, I know as a slightly gentler male, that being on a team with several male, macho dickheads - constantly asserting their dominance and ability with large egos, versus having a few women or two on the team, make a big difference to me. There tends to be less dominating, egotistical machoness.
You're such a manly stud it's turning me on
I think the point of postponement was that this is something clearly in their power to, if not control, at least alleviate. To reach out to people in order to be more diverse/representative.
You don't get to spout misinformation then, when asked for proof, say "I don't owe you anything". You did not show me a standard I'm failing. You showed me a list of idioms. It's as relevant as linking to the dictionary definition of "moose". I don't "think" it doesn't apply, I showed you exactly where in the specification it says it doesn't apply, and I tested it across browsers to be sure. It really takes some arrogance to say you won't test the code without being payed, to the guy who just tested the code without being paid, and told you the results. Who also researched and wrote the code, and gave it to you in its entirety, also without being paid. If you refuse to accept the results of testing, and refuse to say how the tests can be improved, it sure looks like you just don't like the results. And that really makes me wonder - why the fuck are you not OK with the fact that this code works? Of all the things in the world to get pissed off about.
Getting turned away from an event doesn't happen out of no where, for instance it might be seen by the the KKK or Black Panthers/BLM or whatever group has membership based on race (all of which is totally legal, groups like that aren't forced to include all people), but not at a JS convention unwarranted. The USA isn't the ultra-racist hellhole that I often see Europeans thinking it is, societal racism (overall) died well in the 1980's if not before then, racism these days isn't an issue, not even close (though I'm not denying that it exists in the US), and if you think it is then you must be crazy. The bigger issue in race is right now is how that pertains to merit, which funnily enough is the exact issue that started this thread.
What is this shit? Sick version of positive discrimination?
+1 no semi colons
&gt;Equal Nope
http://www.businessinsider.com/githubs-ceo-ditches-meritocracy-rug-2014-1
Here is a second- https://readwrite.com/2014/01/24/github-meritocracy-rug/
Sounds like the men are being bullied right now by Github? They earned a spot and someone else got it instead. Right?
Hmm, also this: https://www.wired.com/2014/04/tom_pw/ Makes 'ya think. 🤔
Stop being so presumptuous.
This is not about selection for coding skills, though. This is selecting conference presentations. Sure, if you're concerned with execution of a skill, a blind test might make sense, but if you're trying to get a diversity of ideas across, not all presenters need to be ideal coders. I'm extremely curious about what the selection criteria were, though.
So basically their masculinity forces you to notice your lack thereof. Maybe you're the problem. A furry who is the problem in a situation? Well color me surprised.
It's worth pointing out that this is not a single incident. This is the exact same reason why a [gaming panel with top industry professionals was cancelled](https://heatst.com/culture-wars/usc-cancels-legends-of-the-games-industry-event-for-not-including-women/).
Wasn't he the asshole that got Samantha Bee out into the world? Proves his point is not valid.
Sorry you got your little white male panties in a bunch. I'll be sure to get help. 
&gt; I reckon that if I can get the display value to save to a variable each time I press an operator/function, it'd be rather easy to write out the functions for the rest of the buttons. That's exactly what you should do! The display should be just that - you should only ever be writing to it, not reading. Instead of using `eval()`, set state variables. Here's the idea: http://jsbin.com/juqupamedi/edit?html,output
&gt;please explain to the mentally ill what is wrong with them Wew.
Stats don't matter. Why are they relevant? They had a chance to submit, they either didn't, or they did and weren't good enough. Congrats on forcing incompetent people into power. You work for the Clintons?
Their plan to spotlight the alleged strength of diversity through their little experiment only served as a highlight to the reality of their ideological zealotry. 
ok so now instead of getting the absolute best talks, you get talks selected by github which are still okayish. if you still go to this conference you'd have to be a total retard, they are directly telling you that this isnt going to be the best that it could be
at this point this is just so obviously broken and yet none of them see a problem
"but shouldnt we at least try?" - SJW
You must be a real hit with the ladies.
Surely your reading comprehension is a touch better than that. The sentiment is that these people took something that is, as far as we know, a perfectly fair and balanced, meritocratic selection system designed to get the best and brightest at the fore so they can give their talks, and instead replaced it for the sake of inclusion. To shorten that to a sweeter point: They're focusing so hard on being nice that they don't realize they've become pricks. Funny, considering how you responded to them.
it's still slower than github but how can you beat 'free'?
It's a conference about javascript. Genitals and gender literally have nothing to do with it. You go to the conference to talk about *fucking javascript*. I'm done with this thread. This is dumb.
The is nothing about programming that women can't do just as well. They are under represented because they don't want to tolerate the sexist bullshit.
I think it's interesting that around the time The Daily Show started focusing on diversity of hires over quality of applications, both their ratings and their per-30s ad prices started dropping (a trend that continues to this day).
Does it seem odd to you that only 1/100 of the cs students at your school were women, considering they make up more than 50% of the college population?
That argument is invalid because it can be made in any time period no matter how institutionally racist or sexist it is. If you go back in time and solicit the best academic papers, you'd find they were all written by white men. Is it because white men write the best academic papers, or because the connections, support, and positions of status in academia were all held by white men?
Github was just going to do the conference with the talks chosen based on merit. When they posted the schedule, the SJW crowd piped up: - https://twitter.com/fox/status/870761439094489088 It's much easier to complain about things on Twitter than to create engaging presentations.
Whooah... So hiring people not based on their own merit is supposed to make sense? They have a good product that got traction, and are milking it now. Another company based on meritocracy will take the lead soon...
Lol who cares? Let the girls do the thing or whatever. Throw a few blacks here and a Tunisian there. Bleep bloop no sense in stirring up there jumbo over a wombo. Yknow?
Paid products and services should pay for advertising.
It seemed odd, but then again there are a lot of other fields were there are basically no men and I never heard men complaining about it. Also, many women not only have no interest in CS, but actively denigrate CS students as to them it's such a shit field. So no surprise they don't want to go somewhere they don't like. It seems to me that a minority of feminists tries to insult women in general, again and again, because they don't like their choice. You can't force people to study and work in fields they don't want to go.
Referring to someone's personally expressed political values is quite literally the opposite of "identity politics". That's not a catch-all term for things you don't like.
Different strokes for different folks I guess.
It's worth watching the Jon Stewart clip above. It doesn't require unethical actors for biased systems to self-perpetuate. When we view nursing as a "woman's job" and target commercials for electronics toys at little boys telling the next generation how the world works. That computer science has a far different gender ratio than similarly difficult and technical majors raises questions that are worth investigating: http://www.npr.org/sections/money/2014/10/28/359419934/who-studies-what-men-women-and-college-majors
&gt; from the largest demographic In this industry, i assure you every outsourced, off-shored and near-shored employee of western companies, as well as every employee from Asian companies knows about github. Google any random IT stuff and you'll find a dozen Indians&amp;Chinese both asking and answering about the same topic on stackoverflow and publishing HowTo videos about it on youtube before you run into a single white guy. only 16% of the world population are white. I really don't know where you're getting this perspective from. 
Occam's Razor says that out of two options, one being a huge but unobservable, unprovable subconscious conspiracy to preference white men that even exists among coloured women; and the other being that white men are simply better at most things, the latter is true. Sorry to all the coloureds and the women. Maybe after the next extinction cycle you might have a chance.
You can find plenty of diversity of thought within any arbitrary group. Clumping people by sex and skin color is just a really bad idea, fraught with errors. Besides, I don't think diversity of thought is even important. I'd prefer a group of uniform, highly skilled individuals over some nebulous 'diverse' thing for diversity sake. Too much diversity of thought can lead to dysfunctional teams from choice paralysis. Or inability to mesh well. It's all overrated neo Marxist garbage.
I'm unsure what exact point in my two posts you are responding to. I already wrote (twice!) that I agree that backpedaling on the outcome of the talk selection was really stupid.
here is more detailed example `componentDidMount() { window.addEventListener('mousedown', e =&gt; this.initDrag(e), false); } initDrag(e) { document.documentElement.addEventListener('mousemove', e =&gt; this.doDrag(e), false); document.documentElement.addEventListener('mouseup', e =&gt; this.stopDrag(e), false); } doDrag(e) { //...blablabla } stopDrag(e) { //remove listeners here } ` Is this the correct way to do that ? 
It's totally ridiculous. I'm writing linear algebra routines for GPUs. No part of this needs 'diversity of thought'. 
So when men suffer to prop up your first world lifestyle that's a necessary imbalance, but when women choose of their own free will not to participate in this industry, that's literally the next Holocaust? If you want 50% women in tech, I want 50% women in coal mines, sewage plants, border patrol, and road construction. And I want those to be mandatory quotas. I want women to be turned away from high-paying jobs because we have too many women in high-paying jobs and need more women in the mines. Anything less is hypocrisy. Face it: you're not out for fairness. You just want cushy jobs for the girls the same way University alumni and the collegiate patriarchs handed out cushy jobs for the boys a hundred years ago. You're no different to the parade of shitty human beings that have come before you.
There is no biological determination that men should do JavaScript development and women shouldn't. If you bias your selection towards men and pretend that they were selected by merit you hurt the field. I never said conference participation shouldn't be merit based. I never said or implied women are weak.
Case in point. I grew up in a rural countryside in a glorified shed with broken windows and a tarp roof. But my dad brought home a computer when I was eight cause he knew it would be important. I self taught to avoid undue financial burden on myself or my family. Now I'm a privileged white male in a fortune 500. And fuck all the sacrifices my Dad made working in the oilfield to get me here.
And to show them that the industry has moved on from a maschilist mentality. That is if it really has. After reading [this twitter conversation](https://twitter.com/fox/status/871478847941689344), I'm not sure.
&gt; componentDidMount() { window.addEventListener('mousedown', e =&gt; this.initDrag(e), false); } initDrag(e) { document.documentElement.addEventListener('mousemove', e =&gt; this.doDrag(e), false); document.documentElement.addEventListener('mouseup', e =&gt; this.stopDrag(e), false); } doDrag(e) { //...blablabla } stopDrag(e) { //remove listeners here } Is this the correct w Several problems: One, unless you want to drag anything and everything on the page, you need to not attach the event listener for mouse down this way. Use react's event syntax to attach "this.initDrag" to mousedown on the element, not "e =&gt; this.initDrag(e)". Two, stop using the (e) =&gt; someFunction(e) function. It is doing nothing except ensuring that you can never remove the event listener. Just add and remove someFunction. Three, when you remove the listeners, only remove mousemove and mouseup. Leave mousedown alone. Since you let react create it, react will remove it.
A case of the women's studies majors crying for more women in STEM. 
[removed]
Where are you that there are only phone jobs?
huh?
Links to a reactConf 2016 presentation on flux/redux/relay
How can you spit that way on the people who deserve to attend a conference. Why do you want to replace them with random people who are less intelligent and don't deserve a spot? The only welcoming that needs to be done is the welcoming of the people who have a good enough work, not your absolute insanity. I don't want to hear what some random woman or black thinks. I want good, interesting works, not your absurd proposal.
Wow assuming my sexuality. Nice.
From where in the fuck did you pull that?
Not quite: read this: https://www.reddit.com/r/javascript/comments/6f8u2s/githubs_electronconf_postponed_because_all_the/digz7hb/
But this thread is about something beeing canceled because too many white males are not wanted.
Your link is pointing out CSS vs JS. Not quite as relevant to the discussion as you think. You wanted an extreme example? Lets say you are fetching a 20mb json payload just once. Parsing that is a synchronous operation. Calling JSON.parse on that takes around 500ms. So if fetch is adding 40% of overhead, that is a significant amount of time for the JS thread to be working on one thing. So lets think about this in the context of UI. If you are mounting components to the DOM and one of them has to fetch 20mb of json, then you are going to see page render pause while it does its sync operation. If you can save some of that time, you should but not until it is an apparrent issue.
Much thanks for your response, it is greatly appreciated! I'm afraid I don't really understand how the code you have input makes the screen go blank...blame that on my own incompetency . I understand that you have put all the operators into an array. But I'm not sure how to figure out the compute function, and how it connects to the variables above. Especially that variable that equals null...
Exactly. I didn't become a developer to deal with these non-issues. And irrationally they're having the **opposite intended effect** on me as a male developer. I'm beginning to find myself having an unfair bias against women (opinion wise) in the industry because with men I don't have to care about this bullshit. I can just do work, for works sake. It's bullshit and so incredibly anti progress. If 90% of the industry is men, then your industry is **un-diverse**. Instead of shitting your pants and crying about having more women at cons do something useful to attract more women organically. I mean, aren't some of these shit heads data scientists...? Jesus.
They will say you are a privilege white man because your father had some logical foresight... Their food is jealousy. I'm glad you made it!
I (as a European) feel like this is WAY more of an issue in America. It looks like biased inclusion is the default because unbiased inclusion just doesn't happen. Funny thing is that KPI's &amp; inclusion percentages don't measure biased or unbiased. If, in the above selection process, talks submitted by women are not selected based on their content or subject, I fear the problem lies not with the gender of the speaker but with the quality of the content. I feel we shouldn't even be discussing the diversity thing because the content should be leading.
American progressives talk a lot about intersectionality, but they always conveniently ignore social status.