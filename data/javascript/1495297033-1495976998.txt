This is happening only when tests are too tightly coupled with production code... 
Good article, but I disagree about not using semicolons. In addition to providing great visual cues when tracing code, there are many potential bugs that only exist when you skip semicolons. Accidentally type random numbers on your keyboard without realizing it? Well some calculation 20 lines above the documentation just changed. It may not take long to debug, but it's a non-issue with semicolons. 
Well, with eslint and auto correct, I would say it doesn't matter anymore. Configure your eslint as you want, but stay consistent in your code. I prefer semicolon, but I don't mind anymore if I missed one. Eslint will add it.
Some comments: It's not obvious you need to click save before hitting next, I went through it and didn't have anything saved so had to start over. When you add something that can be added more than once, like work experience, the form validations go red for the next entry before you start filling it out.
This is not black and white. Between big Facebook grade application and "little site" done in weekend (with HTML/CSS and dozen lines of jQuery), there are plenty of medium sized web applications. They need months of work. They for example have good amount of JS code on frontend (often with using of React, Angular etc.) and plenty of logic on the backend. Not testing such medium sized applications is quite irresponsible... 
/u/amitmerchant I just went through myself and absolutely agree with Deseao's points. It should auto-save on "Next" or throw a warning dialog when next is clicked without a recent "Save". A few other points: * When adding multiple items (e.g. experience, skills, etc.) it would be nice to be able to reorder items without having to delete/add new; * With the "Fancy" style, when increasing the line spacing, it also increases the spacing in the sub-headers (i.e. Education), making it so that the text no longer aligns with the line/horizontal rule section separator; * The option to reorder the sections would be nice so that you can highlight or "bury" what you want. Some people may want their Education first, especially if they're new to the workforce with little or no experience, or want their skills listed last (or first); * I think this is more personal preference (and standard practice for CVs, I guess) but for the experience, the summary input should be required. Never would I add a previous experience without a summary to a CV.
I'm involved in hiring frontend and backend developers. At most I skim over the section that lists known technologies because I really don't care. I care quite a bit about what projects you've worked on and expect that if you are unfamiliar with a technology I use that you'll learn it in the job. If you're looking to be a better developer you need to write a lot of programs. Pick a few representative projects where you learned a lot or which demonstrate a skill to add to your CV rather than a list of technologies.
I had a feeling this may be the case. Thanks for your input, I'll try and make the CV a little more project oriented. I would like to note that I have worked on a tonne of projects, but the amount I could actually link to in my examples is actually quite low thanks to a combination of working on projects under NDA and projects going old/deprecated. What are my options here? Also this list isn't so much for my CV as it is for you guys to suggest what else I could add to it, for myself - I'd appreciate any suggestions! :) Cheers 
If the NDA doesn't allow you to say anything about the project then of course leave it out. If you can talk about enough to also describe your responsibilities and what you learned it might be viable. While more recent projects are preferable, if you have an older project which demonstrates a skill that is fine to include. I once asked for a code sample and was directed to code written in 1996 which was part of a very important library. It was a good sample.
No semicolons?????
I think one advantage to separating UI would be easier inter-op with with React Native? Although I haven't had much chance to play around with it myself yet. Render callbacks are definitely more verbose but I typically encapsulate them in their own component: function InputUsername({ path }) { return ( &lt;Field path={path} validate={isUniqueUsername}&gt; {({ value, onValue, error }) =&gt; &lt;div class="form-group"&gt; &lt;input type="text" class="form-control" value={value} onChange={e =&gt; onValue(e.target.value)} /&gt; { error &amp;&amp; &lt;div class="input-error"&gt;{ error.message }&lt;/div&gt;} &lt;/div&gt; } &lt;/Field&gt; ) } And then usage looks something like: function SignupForm() { return ( &lt;Form&gt; &lt;InputUsername path="username"&gt; &lt;/Form&gt; ) } Happy to help if I can if you end up going down this path! 
&gt; It's kind of a wives tale at this point that they're required. There are many cases where they can be omitted, but they are not optional.
I know I'm going to get nothing but downvotes for saying this, but in the part about functional programming, the initial imperative approach feels significantly easier to understand and follow than the functional implementations following it.
very nice!
After I started using standard, I've had no issues. It checks all the edge cases where not having one might cause an issue. I'm not going back, code looks great too.
I'm glad someone pointed this out; I don't have any experience with ES6 classes, but from what I've read so far, a lot of folks believe classes were a mistake and pretty much go against the nature of the language itself. Thoughts?
It's already supported in Webpack 2 natively, but we added a Babel plugin to make it work in test environment.
Thanks! Added Resume examples on the front page. :)
Thank you! :)
Hi! Thanks for the feedback. I'll look into the above issues and try to resolve them. Please check back later for updates.
I prefer ESLint with the standard preset. You could use the semistandard preset.
I'm using JS since 10+ years and I like what they did with class. Multiple inheritance is hard to do though, that's my main critique. Other than that it's useful in specific situations. I'd not recommend to always use it if you can though. That's also one of the main things I love about JS. You can write in so many different styles, e.g. Functional, Object oriented, and imperative. Nearly every style is possible and you can use what works best so solve your current problem.
Stopped reading when it told me to use spaces for indentation. What is wrong with tabs, man? They're made for indenting and most editors let you change their size, so I can't see any reason to use spaces instead.
Javascript has always been object oriented. People just don't understand how it could work without classes. 
Can you give an example? My answer would be that it should be in the documentation. If it's not in there, you could look in the source code but that should be the exception rather than the rule. Some libraries may even spit out errors that tell you what it expects..
False. It's prototype based.
Honestly I don't think this has been refactored well at all, and ironically the _enumerateFirstSetRules method still has 4 levels of nesting..
Yeah, but is it easier in general, or easier for you because you're more familiar with that style? I find the functional approach a lot easier to understand, but I've been switching to writing things in a more functional style over the last year or so. I do agree that the last "simplified" snippet is not easy to read, I don't really understand why he did that.
Prototypes are a type of OO. It's using objects as prototypes of other objects to get inheritance.
Oh my... Its crazy to see how widespread missinformation regarding semicolons in js still is. Omitting them is totally fine and by no means bad practice. Just putting semicolons into your code wont save you anyway. Learn where an explicit semicolon is really needed instead of spreading myths about how necessary every single one is. If you use semicolons fine, if you don't, great. Just be consistent and mindfull.
This.
I tried to emulate your 'Basic' example here: https://github.com/j0nas/light-form/pull/8/files -- and updated http://light-form.surge.sh with the example. I think this demonstrates the core principle of the library pretty well: the form itself is still simple in that it doesn't need to deal with onChange and value binding, and the rest is done as I normally would do with 'vanilla' React/Redux. Thoughts?
To call js oo is to incorrectly induce ideas of how it works. It's got objects sure but it's inheritance system is prototypical. It's like calling a bird a dinosaur.
Nice! Away from my computer now but will give it a shot when I'm back. 
looks nice! Is there an ability to save to pdf or doc?
Learn functional reactive programming with RxJS. Don't just skim over it. Really get to the bottom of it, grasp the concept. You'll never think about data flow and code in general the same way again afterwards.
A lot of those are common-sense things which most JS developers do. But according to the author, "modern JavaScript code" includes these, as well: - use 2 spaces for indentation - no semi-colon - stop using for loops - replace comments via local function names like "enrichElementWithCalculatedValue". Nope.
https://en.m.wikipedia.org/wiki/Object-oriented_programming Searching h for 'resemble OO languages'. Resemble !== Is
&gt; Prototype-based programming is a style of object-oriented programming in which behaviour reuse (known as inheritance) is performed via a process of reusing existing objects via delegation that serve as prototypes https://en.wikipedia.org/wiki/Prototype-based_programming ¯\\_(ツ)_/¯ 
Good question! I have no idea why I haven't checked this out myself, so I did just that: https://github.com/j0nas/light-form/pull/9/files And I'm pretty happy with the result: 1.8kB minified and gzipped! :)
Whats your opinion on points 3 and 4?
Perhaps, but I completely agree with that statement. The greatest qualities of JavaScript are lexical scope by default and inheritance is optional. If it weren't for those JavaScript really would be Java's little brother and just as crappy.
**Stop.** Put all the buzzwords away. Instead start writing applications. Write a game or a distribution utility or a static analysis application. There is a world of difference from some code monkey that can copy paste snippets of code versus somebody who actually solves automation problems. You will never know what the real problems are until you encounter them, and its only solving real problems that makes you a competent developer.
Oh wow, one paragraph in wikipedia, I guess that settles it. Read [this](https://stackoverflow.com/questions/107464/is-javascript-object-oriented) stack overflow answer. [This article](http://www.academa.si/?content=http://www.academa.si/html/articles/js/professionalJavaScript/isJavaScriptObjectOriented.htm) [This tutorial](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object-oriented_JS), from MDN no less. What is Mozilla doing, spreading these lies about the OO nature of javascript! How about Crockford of whether it's OO or not, [here](http://javascript.crockford.com/javascript.html), I mean he only helps design the language. What does he know. If we want to take it back to wikipedia, how about [this page](https://en.wikipedia.org/wiki/Self_(programming_language\)) about self, the language that Javascript took it's prototypal inheritance from. &gt; Self is an object-oriented programming language based on the concept of prototypes. Want a practical example? What about all of the gang of four design patterns, written in Javascript. [here](http://www.dofactory.com/javascript/design-patterns). It's so weird that it's not OO, but you can do all the OO stuff with it. 
checkout some of the work from yoshuawuyts as he's been pretty prolific about his work in [building frameworks](https://github.com/yoshuawuyts/jsday-verona-talk/blob/master/slides.md) also peek the source code for: frontend framework: [choo](https://github.com/yoshuawuyts/choo) backend framework: [merry](https://github.com/shipharbor/merry) asset bundling: [bankai](https://github.com/yoshuawuyts/bankai) css toolkit: [sheetify](https://github.com/stackcss/sheetify)
Wow! That's great
Javascript classes are extremely basic and simply mask prototypes. There aren't any interesting features to them like traits, or mixins, or multiple inheritances. Reflection on classes is also pretty shallow. I'm not against ES6 classes though. I think they're a huge step forwards for Javascript, but still, a small step in the grand scheme of things so JS is nowhere near the level of other object-oriented languages that I use (e.g. Smalltalk, Python, Ruby). Even Typescript is better (in my opinion) than Javascript because it is statically typed at compile time (where I care about type checking), and dynamically typed (allowing for flexibility) at runtime. Erlang and Elixir are similar. 
He refutes the reasons people say it isn't. Do you have any other reasons he missed? Apart from finding tiny snippets of text that can be interpreted loosely
What's that good reason?
https://en.m.wikipedia.org/wiki/Multiple_inheritance see the diamond problem. I'm pretty sure languages like Java don't let you do it. PHP has a feature called traits that lets you achieve similar functionality using mixins. 
The fuck are you talking about? Javascript has been a functional language since the dawn of it's inception. To give credit, he could have done all of that map filter stuff within the reduce function. It's obvious the OP is newer to FP.
Easy, was the first to market component-based web framework that did it well, so larger companies started using it. Once the freight train of a large company starts moving, they put their full weight behind something and don't choose something new very easily because of the cost of retraining. Sure, senior engineers can pick up the hot new frameworks easily, but what about retraining everyone that's working on existing codebases. Try convincing them every two weeks this hot new framework is the thing to use.
Interesting read, thanks for sharing
Touché 
Have you looked at Preact (https://preactjs.com/)? It is a tiny 3KB library that handles the DOM diffing / component lifetime stuff. It's basically the same idea as React, but a lot more lightweight. There is a pretty good series on how Preact works internally here: https://medium.com/@asolove/preact-internals-1-the-easy-parts-3a081fa36205
I just finished up (a first pass at) a Vue boilerplate project. You can view the source at https://github.com/joncass/vue-boilerplate. I'm just getting started with Vue (and for that matter open-source, boilerplates, etc!) so comments and constructive criticism are welcome!
By saying it's not OO, you are being wrong. If people think c++ style classical OO is the only type of OO, they need to be taught that there are more styles. Not (incorrectly) told that classes are OO and any other way isn't. &gt; Objects inherit from objects. What could be more object oriented than that? ~*[Douglas Crockford](http://javascript.crockford.com/prototypal.html)* At its core language JavaScript is many things and very different from c++ and Java, but it's still OO.
Dont forget lazy evaluation
You think *thats* [confusing](/r/confusing)? *Of all the things Ive missed, I lost my mind the most.* 
Although you're getting the same value at the end, it's worth pointing out an important difference in the promises version of the function. In the await/async version, the variables a, b, c and d are assigned the *result* of the asynchronous requests. In the promises version you wrote, those variables are instead assigned the *promise* returned by the request. Of course, another promises version could be written where those variables are actually assigned the results of the requests, but that isn't the point. Of course you can write anything in await/async with promises instead, just like you can write any code using promises with callbacks instead. The point is that one version is clearly more legible and easier to write than the other. And the easier your code is to follow, the least likely it is to be buggy, and the more likely it is for a reviewer to spot a bug.
First of, can we please not disrespect open-source projects?! It's okay to not be a fan of it, but there's no need to use "bullshit" to describe something that people have put a ton of effort into, and provided to our community for free. I don't work on Standard, but our community really needs to be better at this. Second, it's worth noting that the lack of customization in StandardJS is **by design**. One advantage that brings is that adding Standard to a project is super easy, there's hardly any configuration to set up and maintain. But IMO the biggest difference is that it pretty much shuts down any discussion on code style. One of the team members prefers tabs over spaces? "Sorry, but that's not Standard". And the team can focus that much more on product development. With ESLint, someone on the team can validly bring up a "can we add/remover this linter rule" discussion. That's not to say those discussions are necessarily bad, but you should be aware of their possibility.
[removed]
He is right but that statement is not well put. Javacript has prototypal inheritance. Classes are syntaxic sugar on top of it. But fundamentally it is a dynamic language and it leans toward more and more FP. And when you start thinking in FP and/or reactive terms, OO just sounds... wrong. And that's usually coming from experienced developers.
It's funny, because I learned to code by writing JavaScript, but have since moved to writing mainly Java, and I've definitely found that classical OO has "infected" my mind when writing JavaScript. 
It's more about the platform you're building for (as well as the complexity/speed requirements of the app). Performance is a bigger deal on mobile browsers and embedded applications/webviews as opposed to your typical website that people load on their desktop. If that's your target than use whatever you're comfortable with, most users won't notice much of a difference if the app is relatively simple. Also, have you considered using Preact? It's basically React-lite, so you'd be using most of the same development practices but with a smaller footprint and in some cases some better performance.
In my opinion this is an unnecessary convolution. Sometimes verbose is good. Redux is verbose for a good reason. When you're neck deep wading through a complicated reducer the last thing you want to have to do is pick apart this type of composition in my opinion.
I think you are confusing "functional" with "lazy/non-strict, strongly typed, purely functional". Would I be correct in guessing that Haskell is the only functional programming language you have used? Try a lisp sometime, it's definitely functional, but like JavaScript it's missing a lot of things from your list. Personally, I think the only thing JavaScript is missing from a standard functional programming language is proper tail recursion.
&gt;don't worry about writing bug-free and consistent code, your tools will do that for you!
Could you explain the difference between classes and prototypes? They always seemed to work the same to me, minus class inheritance. 
&gt; I think you are confusing "functional" with "lazy/non-strict, strongly typed, purely functional". I'd argue that almost by definition any language that can't support a purely functional style is at most a hybrid with functional elements rather than a "true" functional programming language by any useful definition. I don't see where your other two points come from. &gt; Would I be correct in guessing that Haskell is the only functional programming language you have used? Not even close, sorry. &gt; Try a lisp sometime, it's definitely functional, but like JavaScript it's missing a lot of things from your list. Lisp is rather an odd case. I wouldn't necessarily agree that it's "definitely functional"; instead I'd argue that it's a hybrid with some functional elements, per the above. For example, unless I missed something, Common Lisp doesn't guarantee to eliminate tail calls, which immediately means you can't use recursion to replace iteration arbitrarily. [Edit: Fixed an incorrect word in the final example.]
Traditional subclasses inherit properties from their parent but those properties are bound to the new class, not shared. JavaScript classes inherit properties from the prototype, but all subclasses of that protoype literally point to the same object/properties, so they're shared.
What languages would you consider "functional" and not "hybrid, with some functional elements"? Also, it's definitely possible to write a JavaScript program (or lisp, or C++, C maybe even most langauges) program where all the functions are pure. Scheme guarantees tail call elimination. You are correct that not all lisps do.
[warp.js](https://github.com/benjamminf/warpjs) - Warp, distort, bend, twist and smudge your scalable vector graphics in the browser. warp.js allows you to feed in any SVG file and apply any kind of complex transformation. I actually finished this about a month ago. I even started this project nearly two years ago, but it stayed in a prototype phase for a long time before I got around to building it properly. I'm sure applications for this are few and far between, but it was interesting to see if [something like this](http://codepen.io/benjamminf/pen/NpQdZZ) could be built.
I don't have any problems when using Webpack. I'm only running into this now that I'm trying to *also* do server rendering (where I don't *need* webpack)
Cool! Very useful! 
I'm just here to complain about the no semicolo... wait no everyone else already did that. I'm here to disagree that Prettier and ESLint --fix are "basically the same". With Prettier you can rapid-fire out garbage code and it makes it amazing. Heck I barely even type line breaks anymore let alone semicolons. Formatting be damned, it's a whole new world!!
Regarding "no semi-colon", what if : This: var name = "John"; var surname = "Smith"; can be writed so: var name = "John"; var surname = "Smith"; but this: var name = "John" var surname = "Smith" can't be written so: var name = "John" var surname = "Smith" give error: Exception: SyntaxError: missing ; before statement 
Scala deserves an honourable mention as well. Much as I love it, a million ways to skin a cat and at least 9/10's of them will be unmaintainable.
p.s. I try to use two spaces but reddit accept only four space to transform it in code.
&gt; var name = "John"; var surname = "Smith"; Personally I think that is just bad form in the first place and should be avoided.
Yes, if my tools can do it for me, why should I bother?
I'm talking about human written and read code, I think it is less clear.
React is double the size because it normalizes events and does some other things that Vue doesn't bother with. If you cut that away, which is as easy as adding an alias, it is smaller than Vue, [React-lite](https://github.com/Lucifier129/react-lite) is at 10kb, but you can get [React down to 2-3kb](http://i.imgur.com/UkSdULz.png). The micro benchmark stuff is also pretty much irrelevant, and an alias can get you "faster" again if that matters to you. Web frameworks despite their optimizations aren't close to perform like a native app does and much of the current benchmarking is like counting peas. What will make a real difference is the upcoming [React Fiber](https://twitter.com/hollyglot/status/841364072972992512), this is when visual occlusion, render priority and other things that are common for native apps will be introduced to the web. I don't think any other framework has begun to address these issues yet. As for Vue being more suitable for large apps and testing, especially with Reacts [track record](https://github.com/facebook/react/wiki/sites-using-react), i don't think the people that say so have used React at all, Jest or anything of the sort. 
I created a library for documenting your code through a run-time type language called Signet. I've been doing a lot of work on it this week and my team has been incorporating it into the work flow to help identify and highlight places where API endpoints are being used incorrectly. It has helped to speed up development and cut down on common kinds of errors which revolve around incorrectly interacting with modules and type mishandling. Is easy to get started with since it has lots of pre-integrated types (including the basic Javascript ones) It's also really powerful, allowing users to define their own types, handle dependent types (like a &lt; b), and lots more. https://www.npmjs.com/package/signet
Ooooo, damn that's got a high number. Is it faster than the internal trig functions?
Wow..... that's huge.
Whoa - some huge differences there. Thanks for taking a look.
Duuuude get your head outta the sand. I don't care about tabs versus spaces, but this guy does, and sounds like you might, and I was wondering what that guy thought of that the fact that most open source projects used spaces. My IDE does it automatically based on whatever the project is doing. So does yours, so does everyones. Thanks for the downvote though, did you use the tab key for that too?
I usually prefer prototyping to classes, but it depends on the problem at hand. What I really like about javascript is precisely its flexibility.
I'm not sure what you're getting at. The whole reason things like type systems and linters exist is because people aren't perfect and you're bound to miss something at some point. So yes, you should use tools that completely negate that possibility. And no, your choice of semicolon-style isn't as important. 
All of the modern frameworks are "fast enough" (unless you are doing something very custom.) Don't worry about performance, just pick the framework you enjoy using or the one that handles your particular use case best.
Output for the *Normal trig functions* experiment: * Firefox - `r: 0.021537362969610025, x: 12.497100999539951, y: 0.2691962245232696` * Chrome - `r: 0.021537362969610025, x: 12.497100999539951, y: 0.2691962245232696`
Good question! Lets ask the Magic 8 Ball! *shakes like a madman* **My Sources say no.**
`var name = 'John', surname = 'Smith'`
It is a visual cue and shows when a line ends. If you don't use semicolons you have to scan more code to know where it ends.
Really stupid nit-pick but the example you made says: &gt;Hint: enabled when Field2 &gt; 10 It should be **&gt;=** as if you put 10 in Field2 it becomes active.
It's not that much of a difference. OP talks like it was impossible.
So if most people do something it's proven to be good?
Just like no-semicolon rule.
I've been seeing them frequently in commit messages too...
A minifier will automatically convert var name = "John" var surname = "Smith" to var name="John",surname="Smith"; So it doesn't matter if you use semicolons or not in the development version of the file.
Do you return router at the end? If you are getting 404, it seams like the route doesn't exist.
Never had a bug related to semicolons, I've been omitting them for over 3 years now. 
Nice insight on the prototype-closure duality. Importantly, the closure chain bindings occur statically, whereas the prototype chain is walked at runtime and therefore may change over time. 
That is why you should know where you can't omitt semicolons...
This exactly. This guy who wrote this article knows nothing of performance, likely because his experience began and ends with JavaScript. I use JavaScript in production, and every time I write anything my main concern is performance. I'm guessing he loves regexes, and eval is the best thing ever. 
Seriously stop that habit. For loops are more performant than maps+functions. 
Check out RE:DOM https://redom.js.org 😉
Which is?
The official Koa documentation has an example of handling errors in streams, maybe it can help you. https://github.com/koajs/koa/blob/master/docs/api/response.md
yeah true.
As a cool concept as this is why not just use something like const foo = `a string with a ${variable} inside`;
&gt; However, I do recommend to use functional stuff when it's convenient. Absolutely, and don't get me wrong, I like FP and apply it quite often (but not exclusively -- it largely depends on the language and platform I'm working with.) But sometimes it feels like people do FP for the sake of doing FP, and the article linked above (well, the part of it that was about FP) was, to me, an instance of this.
Thanks a lot for this comment, the aXe extension seems like a must-have tool, I'll definitely use it when developing other things as well. I fixed up the demo (https://github.com/j0nas/light-form/pull/10/files) according to the feedback from aXe: http://light-form.surge.sh/
Haha, good catch! I fixed this in the last revision along with the accessibility issues.
How is it different than Vue.compile()? 
This so much. Comparisons at this point are stale and often rife with inaccuracies on both ends in an attempt to make the comparer feel good about their choice in framework. Both are great, neither are perfect and people should just try them to see which one they like more. 
Fuet is actually a thin wrapper around the reference vue template compiler. What it adds is automated template name generation from paths and combining the output into a valid js file. See https://github.com/wearespindle/fuet/blob/master/fuet.js for more details 
Perhaps it's better to simply write tests and not tell them. ;-) One thing I do to help reduce the number of tests and time to write them is I use test doubles only at the external ends of a code path and then just use approvals (approvals js) to verify the output. Then I can write a single test for a while set of files at once. Here's an example from one of my personal projects for reference: https://github.com/cmstead/js-refactor/blob/master/test/addExportFactory.test.js
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [cmstead/js-refactor/.../**addExportFactory.test.js** (master → 54d39e7)](https://github.com/cmstead/js-refactor/blob/54d39e77ddfc29e1b6b80ad158a9d123b41b8b54/test/addExportFactory.test.js) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dhuf6wa.)^.
"You don't need to build them in React today either. React can render to any part of the DOM." You cherry picked and didn't read this followup part: " If you think this can be done by targeting specific elements into React, without rendering the entire page you will likely lose some of the performance advantages of React." As far as I'm aware, It is not a good idea to target specific components with ReactDOM. Let's say you target the footer and header and an article tag. You lose the performance of the three components diffing simultaneously and you are writing to the DOM 3 times. It's better to render to a single div. "See highlight. User code NEVER touches the tree." Sorry no, you don't understand that's the point of React your "code" updates the "tree" every time. There is no difference here, the tree is not exposed. "I'm not threatened at all, I just utterly don't see the point." Because you clearly don't understand the concept. "Post a snippet and I'll respond properly" No! Listen to yourself, you should have responded properly from the start. I'm not here to prove anything to you I'm not on that wavelength. The article explains a concept well and I am not responsible for anyone who jump to conclusions. Sorry I can't continue this convo it's a time killer.
sounds like tech religion to me
Wait... There's already a vue 2?? 
Yeah that isn't the most beginner friendly API. It shouldn't be difficult to just pull spending. but I'm a noob so.
&gt; I am trying to find out what I should be learning next to make &gt; myself more employable as well as a better programmer in general. Just return to the beginning and learn more(on deeper level) JavaScript, HTML and CSS. Don't think you know these sufficiently. After all these 3 technologies are most important in frontend. Get know your tooling better. If you e.g. know how to configure Webpack, don't settle and try to write your own loader or plugin. Read about internals of Git etc. React. Have you heard about new React implementation (Fiber)? Do you know how is it different than previous? Do you know tools popular in React community (e.g. Redux, React Router, Flow, Storybook)? And try to limit(!) yourself, to specialize. React, Angular, Vue - it's good to know different libraries that make same thing - but after all you can't be expert in three different frameworks. It's wiser to choose one you want to specialize in. Software - don't only use software, but try to make your own. You can start with making useful extensions (for example extension for editor you use, or extension for web browser, extension for Sketch etc.). And of course, make practical projects, like said other people here. 
I just recently went from typeorm (immature, buggy), through sequelize.js to objection.js and like it by far the most.
I work for a small enterprise software company and we are still solely using angular 1. We will be doing so for the foreseeable future. We haven't yet come up with a great plan to transition all of our code to v2
We definitely still use angular 1 with absolutely no plans to move to angular 2
I think you should keep your options open. Evaluate more than just Angular 2 because there's some other pretty great options out there as well.
We still use angular 1.* at work. It handles almost all of our front end needs.
Really I didn't know ES6 was around a decade ago, and that person who tried it had all the same conventions as mine. Wow! Sounds like you read the article properly once again and you're not jumping to conclusions. Such rational thinking you have, bravo! 
Redux is great. [RxJS can also do a decent work](http://codepen.io/tweinf/pen/NdEVRL) when it comes to handling your state and triggering React render cycles. 
I think so -- very useful for making fast as possible sorted indexes to jumbled up numbers :)
To be honest, we thought about it at our small company but I think it will rather go into the React direction. Angular 2 still feels too unfinished, at least in my eyes.
All I see is a bunch of random tree animations, which are all different (based on human movement) and no way to compare them. It's a very frustrating visual comparison :/
We do at work. Felt very trapped by the migration (or lack of) to ng2. Angular material really did that in for us. Now because the effort to upgrade is so large, we're just considering other options instead. Right now React is at the top of our list.
&gt; I'll never understand the mentality that says, essentially: "I can write sloppy code because a tool will come along after and clean it up for me". You'll never understand it because no one actually has that mindset. If I cut and paste some code (something I do quite frequently during a refactor), the formatting is going to be messed up, and I want my tools to fix it for me. It really is that simple. I'm not writing "sloppy code," I'm just using a tool to automate code cleanup. Reviewers never see my code in the intermediate sloppy state. If you are not taking advantage of this, you are missing out on a huge productivity boost. &gt; Do developers today really not think that having good, consistent habits, whatever style they might be, is worth something? This sounds like a "good old days" type of argument. Sure, having consistent code is good. But if I understand the inconsistencies and know exactly which inconsistencies the tool is going to fix, why would I not take advantage of the tools? &gt; Sometimes they use good variable names, sometimes not. Sometimes they comment functions, sometimes not. All because they know a tool will deal with it. Tools do not deal with these issues. You might just be dealing with low quality developers. Don't blame the tools. TL;DR: we have amazing tools these days, and we should use them.
I think a lot of companies might be stuck with angular 1 for a while, most of their apps are now developed &amp; in production, so those need maintenance &amp; probably new features. That said, I also think vue.js is a great choice for teams coming from angular 1, it removes all the boilerplate code/stuff you had in ng1 &amp; feels as lightweight.
Angular 1 is still used exclusively by my small company as well. Way better support community and online docs and tutorials. Angular 2 does some cool stuff, but it's not enterprise ready in my opinion. 
Not a framework
Veteran JS-head; literally never heard of it.
You already know my answer man. Ng1 days are numbered thats why I knew I had to experiment with these technologies. VueJS seems the best of the bunch for me. You should give them a try for yourself and check which is best. All of them use V-Dom so thats where most of the performance boost comes from.
In terms of speed, is vue really faster when using the inferno react compatibility module and optimising with shouldCompUpdate, etc?
I felt the same until angular 4 but then i haven't explored reactjs in depth
man.you doing well!
Continue to invest because I believe they're really going to push Fuchsia
awesome, because im excited as I just started learning a lot aobut Fuchsia and Dart
&gt; But how can you be sure if you don't have any tests? One can test his code without writing code to do those tests, which is what I do: "testing all code paths manually as I write". Conversely, having unit tests is no guarantee of correct code. &gt; There are articles showing you how to start writing unit tests, what's so difficult about it? I have followed some! I ended up writing about five times the code to test my code, as there was code that actually did something, and most of it tested either functions so simple they were obviously correct, or tested the UI rendering functionality of the framework I was using, something I can't directly control or fix anyway. And that was just for a small side project. Multiplying my workload by 6 to gain code correctness that I already have seems like a bad tradeoff.
Angular 2 did not solve any issues for us that Angular 1.x already solved. Also 3rd party support like bootstrap has been lacking for 2.x for the last year+ as we continue to evaluate 2.x. at this point we will stick with 1.x. 
Yeah, I can definitely see where you're coming from. UI in particular is a bit of a pain, requiring hugely complex tests which immediately break when you change a line of CSS. Also depending on the type of project, they don't always have hugely complicated code which would require more work to verify :) I often work on fairly complex "thick client" type apps myself where it would take me forever to verify things by hand - I mean yeah, I do it manually as I write the initial implementation, but we need some way of verifying it remains functional over the years and after many developers touch the code, fixing bugs and adding new features. Checking every possible place where things could break as a result of a change just isn't feasible. Or at least I'm too damn lazy to do it by hand :)
Hi /u/alexmenar, English content only please.
Yeah errors are shit in Angular ...
Thank you, this is what I was looking for
It's basically React in concept with some Angular sugar on top. I like it.
I've never seen that. Do you understand what zone is? You have to be pretty explicit to get something to run outside of it. I'm honestly not sure what would be required to run outside angular's zone. Maybe some Web worker stuff? Anyway the way you fix that is to inject zone and then execute whatever was giving you trouble with, from memory might not have the name exactly right: zone.runOutsideAngular(function)
I'm rewriting a bunch of Angular stuff in Angular 4 right now and I have been really enjoying it. I did Angular 1 for a number of years and then didn't do any frontend for awhile (about a year) except for a handful of React components in an existing project. When I first started looking at Angular 4, I found it a bit daunting how much had changed. It felt like learning a new framework and language. However, back when I had been doing Angular 1, we had started experimenting with more modular design using CommonJS imports and ES6 syntax and using webpack to build everything for us. I remember it took me something like two days to get the karma testing setup with webpack to build it all and even then code coverage kind of almost worked. It felt like the classic joke of NPM insane dependencies. I actually looked at some of the libraries people were recommending one should install to get code coverage working with webpack and a few of them were packages set-up to export just a few lines of Javascript. It seemed pretty nutty. Anyway, I'm now using the Angular CLI at work, I just started using it this week, and everything just works and I don't have to set up webpack myself. I found myself really productive within a day and the CLI enforces a kind of clean, modular design that I really like. Thus, it's been great for starting new projects from scratch. I'm also enjoying Typescript much more than I thought I would (I mostly write Python at work and Haskell at home, so I may be a weirdo and YMMV). I'm really happy with Angular 4. I think the code looks better organized by default than most of the Angular 1.* code I've seen in the wild: it reminds me of the kinds of organization we were starting to enforce a year and a half ago with ES6 and our Angular 1.* project. Also performance is nice and the defaults are great. I have three complaints: - You end up with a seemingly enterprise-Java-level number of files and directories. - It often feels more like "writing Angular 4" than writing JS or Typescript. The things you learn don't often provide broader lessons for writing code, imho, so it's a different kind of personal development, which, ultimately, may feel like wasted effort if you have to move on to another framework. - Googling for help brings up many Angular 1.* results and even the Angular 2 results are sometimes out of date (what's with all that crazy history on the router?), so you kind of have to figure things out on your own. *Edit*: one really surprising thing is that Ramda + Typescript + rxjs feels closest to Haskell of anything I've ever written at work.
Jesus no need to be such a twat
Hey guys, be serious, is just an example, this mean that normally i write: code(...); code(...); And after if i want make a minimized file i just replace \r and tabs with nothing. and come out a code more light to transmit to the browser... Like google, try to view-source:https://www.google.com
Still supporting old Angular 1.x code at work, with no plans to upgrade or rewrite.
Hi person on the Dart team. I have had one suggestion since I first heard the name. You folks need some form of outdoor system for "Lawn Dart". I'm so sorry, I'll leave now. 
Google kills off everything, so the clock is ticking. Is it Ad revenue? No, so the first sign of weakness and its neck will be wrung.
Dart is used exhaustively in the largest ad revenue systems (AdWords and AdSense and the internal CRM for Ads customers).
Hah. I love it!
I work at a client in financing industry and there Angular 1.x is still considered brand new, with transition from Wicket underway for years. To give some perspective, they are still running some systems on Cobol and for large part of the codebase SVN is used for version control. Angular 1 what they've trained their own developers for and there's now an extensive set of reused Angular modules across all projects, including all the common UI stuff. Even their mobile application is AngularJS wrapped with Cordova. Switching to more modern libraries and frameworks is out of the question and even updating AngularJS 1.x versions is met with heavy skepticism from the architects. So regardless of the current trends, AngularJS isn't dead and won't be for a really long time. This is the case in many large organisations that aren't technology-oriented. They choose a framework and stick to it for a decade or more. I've managed to push through some modern build tooling for new projects, like Webpack and Babel and I'm trying to refactor code into a component and container pattern, away from MVC, but it's a really long uphill battle. Ditching Angular 1.x is a pipe dream at best. Although I will say this audience may not be critical in the context of Atom, as teams like this tend to use an IDE like Eclipse across the board.
Are there any plans to compile Dart to WebAssembly?
Agreed. I have a lot of Angular 1 apps at work that I still maintain, but anything new gets written in Vue.
No specific plans I can talk about but some of the potential changes to the language I've mentioned (dynamic -&gt; static type system) would make this possible.
Do you use AoT compilation? I thought that was supposed to significantly reduce the amount of data needed to send to the client.
We do, but please don't continue to support it. The best way to get people onto the new versions is to make clean, easy, well-maintained libraries that only work with those new versions. It's impossible to get people to stop coding to an old standard completely but if we make it very attractive and easy to move to new versions then people will start using them.
&gt; But ng2 falls short against ng1 on productivity. You think it might be because you were already more experienced with NG1 than you were with NG2?
Ahhh! Thank you very much for your reply! I had it in my head that it would be great if users could edit the information inside of a text editor, since it will be text heavy. However, I guess a basic page interface wouldn't be that bad of an option either. Thanks man.
Nah, readability is key. I do agree that for a library code or when you really have perfomance issues you should use a traditional for loop. 99% of the time it doesn't matter so I go for the Array.prototype methods. For me perfomance should be taken into consideration...when perfomance is an issue. If we go by perfomance first mentality, you'll probably end up with a shitton of unreadable pure SQL queries on your backend and things like that
Press pp
Yes I do! It's great! But I do want to move to Angular 2 in the future.
uhhh what?
Legacy apps? Yes, although we have stopped writing Ng1 components and have it as a hybrid app with all new components ng2. New apps? It depends. Something quick and lightweight I would go with react. Enterprise software where things like code reuse and type checking are important, I would go with ng2. 
I worked on a huge enterprise angular 1 project, that had really high qualitity frontend code... From this year I am dabbling in React and I will never look back into Angular world in the foreseeable future. Look into React, you won't regreat it. It's amazing how simple and powerful it is.
Yes, I work on a major application for a fortune 10 that still uses ng1.5. We've taken our own strides to modernize the workflow like using typescript/esNext, and building in a way in which the components are truly modular. It's not bad. I had wanted to use ng2 but it was, frankly, crap. And with an in progress app I don't see any way we'll port over to ng4 or react or anything else really. We've got it running with tdd, hot reloads, etc. Not sure what "upgrading" would do for us.
It seems to be the preferred language of the Doubleclick/Adwords part of the company. Since that's the part of Google that makes money, that should make long term maintenance pretty much guaranteed. I expect development to continue as well. That'd be more subject to corporate politics but being attached to the profit center tends to shield you from that sort of thing.
I think the guy who wrote Preact is now on the React team.
Now you just need Taylor Otwell to endorse it on twitter and you'll be set. ;-)
&gt; Recent versions of Angular, with AOT compilation and tree-shaking, have been able to get its size down considerably. However, a full-featured Vue 2 project with Vuex + vue-router included (~30kb gzipped) is still significantly lighter than an out-of-the-box, AOT-compiled application generated by angular-cli (~130kb gzipped). https://vuejs.org/v2/guide/comparison.html
It's pretty obvious if you've built with both frameworks. It takes longer to get to that same level of skill with ng2.
is JavaScript your first programming language? then use Google. if you're somewhat familiar with general programming concepts, then for JS: - understand how closures &amp; function scope works - understand how asynchronous code flows, callbacks and maybe Promises - understand type coercion, `===` vs `==` - understand prototype inheritance - understand what `this` is, `new`, `function.call()`, `function.apply()` after this, learn the rest by reading other people's code, there's plenty of it.
Not a knock on ng2 at all its just more complicated and in respect has a longer onboarding time.
lol. it's v4 now. all the things that were awesome about angular seem so long gone. v1 for life!
At my company, we use ng1 only. We are experimenting with Ng 2 and typescript, but that's not going to happen in this decade.
Setup is the most annoying part about react. Everything else is great. 
Companies are still using it yes. I recently interviewed for a full-stack position. I excelled at everything, but Angular 1.x as I've never used it. I've experience with React and especially Vue, but compared to other candidates who had Angular 1 experience, I was cut.
Absolutely, first time I set up a project using vue-cli I spent hours digging through the webpack configs learning every part of it, its not something you want to take for granted :)
I haven't had issues with bootstrap (but I just started, admittedly, this week). I have to build a bunch of highcharts things too and I was pleasantly surprised to find that the library that exists for Angular2 works well.
Yep. Use it at work and if I were going to start a new personal project I would be choosing between Angular 1.5 and Vue.
the gist link you provided is gone. Basically, I agree with you, I will figure it out. a small simple component like this one I'm building, involving React may not be a good idea, replacing 'fetch' with XMLHttpRequest may reduce the size a little bit also. 
Hard agree on that decision fatigue
Hmm I've always read that the learning curve for angular was steep. I do no think react/redux is a steep learning curve at all, but I do agree with you that for really small projects redux might not be worth it.
Glad you like it :)
:D
I trust Google about as far as I can throw them. Developers would be crazy to invest in their technology. 
Yes, but I intend to use something newer and more marketable for my next project.
Leeoniya, thanks a lot. Can I contact with you later. If you provide me your email address.
From your phrasing, the VM doesn't seem to be a priority, is that correct? If so, this seems to make full stack Dart &amp; in general, Dart, much less attractive. You'll still need some server-side component for all these apps. If you write JS you can get a language that continues to get a ton of work put into enhancing its performance, runs on mobile, desktop and web. I suppose it comes down to how much more performant or other advantages Dart brings that you can't achieve with TypeScript or Flow.
Yeah this is pretty spot on. I grew to like angular 2, and especially typescript. I've had the same thoughts about the CLI and the router. My complaints are the same as yours. With all that said though, I think I still prefer react. I am thinking of using typescript (or look into flow) in the future with React as my primary framework.
After rendering the pdf, what would be the best for the drag and drop part? A jQuery module?
The VM is already in pretty good shape, though. It's one of the fast scripting language implementations. It's in the same tier as V8 (etc) and LuaJIT. For deploying server-sided code, you'd probably use an application snapshot, though. It does use some AOT magic for instant startup and puts everything into a single file. https://github.com/dart-lang/sdk/wiki/Snapshots#application-snapshots
I don't want to misreport, so to be clear, the Dart VM is considered "mostly complete", and we are shoring up areas that are are some times orthogonal to the VM. &gt; You'll still need some server-side component for all these apps. Yes, server-side Dart is still relying on the Dart VM, and that isn't going anywhere. The VM is still a really important story (it's the magic sauce behind [Flutter's hot reload](https://flutter.io/getting-started/#quickly-viewing-source-code-changes-with-hot-reload), for example).
If we were only running in JavaScript, and had no other goals or compilation targets, then I suspect Dart would either look more like TypeScript or be cancelled. You can read more about what I mean on my blog - https://medium.com/@matanlurey/possibilities-for-function-overloading-in-compile-to-js-languages-bee87e97c161, specifically around "Tree-shaking partially to the rescue". This is the optimizations I'm talking about: void main() { var animal = new Animal(); animal.consume(new Water(5)); } class Animal { void consume(something) { if (something is Food) { print('Ate ${something.weight} pounds'); } else if (something is Water) { print('Drank ${something.amount} liters'); } else { throw 'Unexpected: ${something.runtimeType}'; } } } class Food { final int weight; const Food(this.weight); } class Water { final int amount; const Water(this.amount); } Compiles to: main: function() { P.print("Drank 5 liters"); }
Give vue a try if you come from angular
I'm unsubscribing from this subreddit. 
Oh yes, migrating a huge system to Angular 1.x - started in 2015. Likely won't stop either to maintain consistency. It's still good, has its quirks but it's still better than knockout + xml webservices by far. 
We're still on version 1.5.* I think. There are plans to move to Vue or ReactJS. But we haven't fully decided on where to go. 
I think that multiple inheritance was actually tackled somewhat better with interfaces, but I have yet to see a system with interfaces implemented in a way that doesn't tend to be a pain in the developer's ass. (not that i've seen all languages/systems) I think Javascript prototypal inheritance system can quite well solve all the problems that multiple inheritance solves, though it's just not very intuitive to do so, especially for the beginner. Some would say multiple inheritance is not for the beginner either, but the first OO language I ever used was one that supported multiple inheritance.. and i have yet to see a language since then that does. 
OO is perfect when you literally need multiple instances of the same thing. 
Angular2+ does not use a virtual DOM. You can use a "redux-like architecture" in pretty much any framework.
They had ng-bootstrap when ng2 was in rc. So, your use of "now" can be misleading. 
Angularjs docs make use of $scope which is explicitly advised against in pretty much all style guides. Angular2+ docs are miles ahead in quality. Not only that but they cover tangential topics such as deployment and webpack. Many angularjs tutorials are outdated -- and that's my gentle opinion.
Yeah we've known this for a long time. This discussion is about a standard API for converting from epoch time (# of seconds) to human-readable and localized date-time formats
I'll make the menu button a bit bigger, and try to make a `next` button.
There are ways, but they are rather intensive, such as hooking up a live browser session to a capture program and comparing pixel renderings, generating all possible pseudo element selectors a stylesheet can define, simulating keypresses and checking the location of the focus state. For now, I just try to do a very good job and then do sanity checks as I change things.
And I would agree that there is a significant learning curve to angular as well. My point was that once you learn it you are able to build complete (front end) applications efficiently without needing to learn any other tools and wondering if you have the most effective combination.
This looks a lot like [Quiver](https://itunes.apple.com/us/app/quiver-the-programmers-notebook/id866773894?mt=12); I'd be interested to see how it holds up (either by people have used both, or just from people's experience with this app), although just based on Boostnote being an electron app, I highly doubt I'd give up Quiver on my Mac. Edited for clarity. 
Boostnote is available for macOS, windows and linux, and supporting snippet note(not only markdown), so easy to save code.
There are numerous online sources for Javascript. A very good start, is a site that I feel very proud for, since I helped in its creation, and I strongly believe is THE place to start when learning web development. It provides free courses in HTML, JS, CSS, PHP, MySQL with exercises for each lesson to help you understand what you have learned. [Academy of Code](http://www.academy-of-code.com/) Try it out. You won't regret it. 
To be honest I know big companies that consider Ubuntu 14.04 to be not stable enough to be used on employee laptops (so they have to use either Ubuntu 12.04 or Windows 7 or any OS X).
Is Quiver an electron app?
To the best of my knowledge, no. If it is, I'll have to revise my opinion of electron. :) Edit: I think my original post may have been too ambiguous, so I've edited to hopefully clear up any misunderstandings my original wording may have caused. 
&gt; It it possible to store 3gb in a variable? I think so (i have a variable with 1.8GB on the browser right now) and it works. &gt; Can I stream it? I don't know what type of file you are talking about but i would assume you can stream it. &gt; Can I use an api to download it to google drive? Probably [you can](https://developers.google.com/drive/v3/web/manage-uploads) 
Write like a ninja? What does that even mean?
There is no way to tell if application is written using Electron other than inspecting the meta-information (or looking at the memory consumption, lol). The fact that "you can tell" an Electron application apart from a native application is simply a coincidence of "web minded" UI conventions (like Bootstrap) leaking to the native app domain. In general (over-generalizing), most Electron apps will be lower budget projects than native apps (at least those that we get to see in #javascript community); and therefore you get lower quality products with a tag "Electron", and thus the association. I mean... it is literally enough to look at the Boostnote screenshots to tell that it is done using Electron/ by web developer. The same applies to React native vs Phonegap, by the way. Performance/ UI argument is bullshit.
We're also using Angular 1 in our applications. We will use Angular 2 respectively Angular 4 for future projects, but we have no plans to upgarde the existing applications, because it would cost to much if its not badly needed. These apps are also good maintainable and performing very well and Angular 1 also got nice new things in the versions 1.5 and 1.6. 
My personal opinion is that pretty good, just means mediocre in another 3-5 years, if the development stagnates on the VM. The snapshotting system seems pretty cool. i didn't know Dart had this kind of functionality before.
I think it's worth pointing out that while you can't avoid touching the world, you can delay it by returning an action that *will* affect the world instead of doing it then and there: function clearCanvas(canvas) { return function() { canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height); } } var canvas = document.getElementById('canvas'); var action = clearCanvas(canvas); // nothing was actually performed yet // at the very end of the program: action(); // now we actually changed state of the world This definition of `clearCanvas` is pure, but we have to explicitly run its returned action by ourselves.
They should have incrementally modernized angular 1.x instead of a big bang release of ng 2. 
RxJS is standard now ? 
Wow, I didn't know that (admittedly, it is clearly described in the docs so entirely my fault). Thanks a bunch!
Typescript makes them slightly less of a pain in the ass since interfaces do not have to be implemented explicitly
So this looks much nicer than your typical json schema as the DSL is essentially creating a real type you'd find in something like TypeScript rather than a json document verbosely describing a type. Now what is the performance of like this like for validating vs https://github.com/garycourt/JSV ? It almost seems like JSON Blueprint would be even better by converting the Blueprint schema to a JSON Schema either internally or as a build step, which would then allow the full suite of other tools available.
Eh, if you're new/inexperienced, sure, jQuery modules might make a lot of sense, but you've got a good deal of complexity if you do it that way. I'd recommend looking at e.g. Angular or React in regards to creating the entirety of your frontend app.
You are not alone in this, on npm: &gt; 656 packages found for "json validator" &gt; 1085 packages found for "json schema" &gt; 544 packages found for "object validator" 
&gt;An anti-pattern is a common response to a recurring problem that is usually ineffective and risks being highly counterproductive.[ Oh. Oooooh. Thanks, your explanation makes it a bit clearer. The solution wasn't really applicable to my needs anyway, multiple requests to the server are not the best way to solve my issue apparently. But at least is can find my way a bit more easily, I was getting lost with the callbacks, etc. I'm gonna look at the doc for the ES6 Promise now. Thanks for your time
I appreciate you taking a look, sorry its not very presentable just yet. But there is meaning encoded in all the names eg. "_destosub" is destination_bar_of_sub_range, "fllbar" is fill_level_of_bar, "nxtcap" is ...i forget what 'cap' stood for, maybe current_anchor_position. I think the main reason its hard to follow is its a bit complicated (the 'barsort' possibly overcomplicates its general sort function), and its untidy. It *is* well tested and does sort numbers several times faster than .sort() or Timsort. 
You have to dress all in black to use it.
So? This is what Apple do with iOS and have done for years? I don't see the issue, not at least without bringing Apple to task first for it.
Didn't think of using reduce before as a series but essentially what it is doing is chaining the result of the previous iteration to the argument of the next one
It seems interesting
Isn't this exactly like OneNote?
I agree, I much prefer the original method.
Is this different from evernote? What problem were you trying to solve OP?
Only market I think it would be useful for would be elementary and high schools? Low-cost laptops preloaded with configurations to make installing unapproved apps impossible. In that setting it seems kind of nice for smaller schools. But yeah, that's the only scenario where it seems like a good idea.
The same people who open email attachments and unknowingly install viruses. The same people who benefit from a trustworthy repository of apps like iOS users. I think Windows 10 S is great for children and older folks. I'm a Mac/iOS power user, but I think this would be great for people like my grandpa who've accidentally installed viruses on Windows.
Doesn't really seem any different than a Chromebook to me. Definitely not devices for everyone, but I know several people who are very happy with their Chromebook.
Blocking the world's most used browser. Another innovative idea by Microsoft.
No its because now there are so many programming languages that are multiple platform and it's the only way they can compete. I hope they know though everything is going to the cloud. https://upspin.io/doc/overview.md https://youtu.be/giUatBmmb_Y?t=97m
iOS is an entirely different OS, this is just windows 10 with restrictions, the equivalent to this would be releasing a MacOS "s" in which their MacBook Air or something would only run apps from the App Store. With no technical reasoning behind it. The fact that you can optionally upgrade to the full version of windows 10 invalidates any good excuse Microsoft has for this OS.
I've been working on a new work project using React that has potential to grow in the future though probably not that big that we'd need more than 2 people managing all the code. What do you do about CSS? I'm trying to figure out how to get my CSS to be modular like my components without having to stray too far from writing styles using normal CSS syntax. 
It's free, cheaper hardware costs when you don't factor in OEM licenses. It's a push for MS new universal Windows platform, that is more secure and sandboxed environment the more vendors that update to the UWP framework means a more secure OS and better for all ms customers. 
Microsoft trying to be like Apple/Mac, L U L... I swear, Microsoft is run by monkeys... It's almost 2020 and this is there big idea for the future... 
A chrome that is actually just a wrapper for the iOS safari yes. Chrome for W10S could be the same, just using the Edge browser rendering engine.
a guy opened an issue on their github repo but no one answered yet. I think they will do it anyway. https://github.com/wallabyjs/quokka/issues/20
What would be the benefit of this?
Why is a mobile OS being compared to a desktop OS? Mac OS does not force the user to use the App Store. That's the only point that needs to be made. Bringing up iOS is simply off topic. https://www.microsoft.com/en-us/windows/windows-10-s There is not one picture of a mobile device. Why the fuck are we talking about iOS?
Their reasoning for being so locked down is beyond me, but I still think it's a bad comparison. Apple doesn't provide a "macOS" upgrade for iOS devices simply because they couldn't handle it. We're talking about handheld devices here vs computers with the capability of running the full version of windows 10.
Says a lot about your exposure to people outside your social strata. Nobody in real world cares about this as long as they can email and facebook.
Me, speaking to an elderly relative of my boss who he asked me to consult for a tablet purchase: Me: Well, depending on your needs, any tablet will do, but if you type a lot, I recommend a chrome book or something similar with an actual keyboard. Them: Oh, that sounds nice. Me: Sure, so what exactly do you use your old computer for? Them: Oh, just email, pictures, my checkbook. That kind of stuff. Me: What kind of pictures? Like.. Facebook? Or do you take a lot of your own? Do you do any editing of any sort? Them: Oh, I have about 10 years of photos I keep on my computer. Will I be able to manage those on the Chromebook? Me: Sure, but you'll have to use an app that you may not be familiar with. It shouldn't be hard to make the switch though. Them: Oh dear. What about my checkbook? Me: How do you manage it currently? Them: I use an older version of Quicken. Me: (googling Chrome+quicken) Well, it doesn't look like there's a version of quicken that will run on an iPad or Chromebook, but I'm sure we can find you something. Them: Oh, I don't want to learn a new checkbook program. I guess I'll just stick with my old computer then. I've had this conversation dozens if not hundreds of times. Your silly dismissal is silly.
&gt; I hope they know though everything is going to the cloud. [The internet? We're not interested in the internet.](http://www.itjive.com/wp-content/uploads/2015/03/Bill-Gates-Internet-300x300.jpg)
It's different in that it runs on linux at least.
It is included automatically when I use the most recent angular cli.
It would also be an amazing setup for a kiosk because of how locked down it is. I'm guessing that Microsoft will allow enterprise environments to set up their own Windows Store software libraries, then they can push their kiosk app out to their clients pretty easily while keeping the clients themselves quite locked down. It would be an interesting way to deliver OS updates and software to, say, POS terminals. That sort of thing is a really big market for Microsoft. It also makes sense for them to try and unify their architecture so if their store ever got to a point where it was a real selling point of the platform, then they would have fewer systems to maintain. Not allowing Chrome though is an interesting choice. I have to wonder about that one. The two scenarios I can see are that they are either working to completely rebuild their OS again and the way Chrome works now would make it not work well, or they want to push people into using IE (Edge, whatever) so they get used to it and get to prefer it on a normal Windows desktop.
Nothing new 
I can install native chrome and Firefox on Mac. You mean ios where you have to use webkit 
&gt; We're talking about handheld devices here vs computers Given the potential of the handheld devices, I'm not sure this is a useful distinction. Microsoft has literally shown off [Win32 Photoshop running on a Snapdragon 835](https://www.youtube.com/watch?v=PaSmZzo3Y_c) SoC. So it's not that iOS devices "couldn't handle it"; it just hasn't been done yet. 
Because its still the same argument. The actual device is irrelevant. Why isn't it an issue for iOS just because its a Mobile OS as opposed to Desktop OS? And considering Windows 10 kind of blurs the line there anyway, how long until there is no distinction between Mobile and Desktop OSes? 
Thank you all for answering. I think i am starting to grasp the theory around it. I guess I'll just have to use it in practice, and get used to it. Here is a link to a book I found about it if anyone is interested: https://www.gitbook.com/book/drboolean/mostly-adequate-guide/details
I think the first sentence sums up what i was wondering about. Thank you for writing :)
I'd recommend anyone getting one of these machines to turn them into Chromebooks instead using https://www.neverware.com/
It isn't the same. Chrome is written from the ground up to run web apps and pages and the engine they're using is Chromium/V8. The OS is a "browser" so to say. Though you can still install any browser you want with Crouton. Windows 10 S is a generic Windows with an enforced store. It is pretty crazy to block the most used application in the Windows eco system. This would also kill Electron btw.
what does green field mean?
Never had access to the original device. Was only asked to advise on new purchase.
I don't see how it is like ChromeOS, it is not and it isn't driven by Chrakra/EdgeHTML, it is plain Windows with new restrictions. A legacy desktop OS that has web-browsing apps banned or use Edge is completely insane. As for the link you've given, doesn't that directly contradict their TOS? These applications ship Chromium after all. Or do they really refer to the arbitrary "browsing" aspect of it: tabs, url-bars, HTML content. Like, Atom is OK (though it does "browse" in the plugin overviews), but Brave isn't? Wouldn't that pretty much underline that really the only reason they're doing this is to throw a wrench into Chrome and push Edge (which in my opinion is the worst possible browser of them all).
Yeah for their app store that is highly restrictive but no language restrictions at all lol and watch out for azure with any connections to other servers cause Itll cost you every time some visits your page. But yeah no restrictions just you know, those...
There are problems with what Apple is doing with iOS. iOS devices are restricted to using Safari's engine, which lacks many features such as progressive web apps, web rtc, and many other things. Apple is single handily blocking web browser invocation. If Apple doesn't want to add a new feature to it's web browser engine because it might compete with native apps (which they make a fortune off of) then a huge chuck of the the mobile web is blocked from such feature, thus that feature wont see wide spread adoption. Apple can block new innovation on the web by simply blocking it on their platform. It's a huge problem. 
Yeah, I get that there's a potential target audience, but the minute they need to accomplish something that isn't supported by the limited number of store apps, it becomes a "why did I even purchase this stupid thing?" conversation. Trying to explain away the net positives when the user simply cannot do certain things won't get you far when it becomes an argument over wasted money that doesn't come easy.
Autostart audio. Don't care, never going back.
&gt; The lineup already includes Evernote and Slack... Woah! Who needs anything else!?
When applied to this example (general I/O in JavaScript), there's no real benefit. If you extend this line of thought to other areas though, like Promises, you get more tangible benefits, like being able to actually cancel or retry a Promise^(1). Ultimately, for me, this pattern is a tool for communicating intent of the code more clearly (specifying computation vs. actually executing it). &amp;nbsp; --- ^1 Check out [Fluture's comparison of Futures to Promises](https://github.com/fluture-js/Fluture/wiki/Comparison-to-Promises) for more examples.
This is by no means related to JavaScript and I struggle to find comments here that are more than whining.
Another shitty, laggy and battery hungry JS app for desktops? No, thank you.
I think this is a fine move by Microsoft. Windows is the most targeted OS for malware so having a centralized repository for official applications is a pretty good move. Whether they use this technology to try to box out the competition is a different story, but I think it's way too soon to judge.
I like React but I don't like Redux. I would bet that it's an in-between solution to what is eventually commonplace in the React community.
Yeah it's definitely a divisive proposition. To continue my Grandma example: she will never, ever wake up one day and decide or need to use her PC for something new. As far as the computer illiterate are concerned, the more a PC can be made into a cheap iPad, the better.
Parameters are an optional part of functions. They allow a function to receive input. A function is a bag of instructions. There are three approaches to this concept: * use parameters for input * do not use any input * use closures for input an example of a function without any input function timeInSeconds() { return Date.now() / 1000; } // this performs a calculation without any input an example of a function with a parameter function timeDuration(past) { return ((Date.now() / 1000) - past); } // in this case we use a parameter because we know what the // instructions are, but want to allow any number as input an example of providing input to a function via closure function timeDuration(pastSeconds) { return ((Date.now() / 1000) - pastSeconds); } function durationYears(past) { return ((((timeDuration(past) / 1000) / 3600) / 24) / 365); } // in this case function durationYears receives input by executing // function timeDuration for input. This function is not declared // locally to durationYears, which is dark magic called a closure
One mistake can cost you everything on your computer or your bank account. I don't think that learn-the-hard-way approach is worth it. If you upgrade to Windows 10 Pro, you should know what you're getting yourself into.
&gt; […] Chrome on iOS is just a wrapper for Apple's Webkit-based browser components. Google has made the UI look comfortingly Chrome-like, with the ability to sync bookmarks, history, passwords, and other data, but it's not the same browser as on other platforms. Huh, TIL
So this is a pretty common scenario when loading any graphics/etc. In short, here is what you are doing to load the images: document.getElementById("completed-project-img").setAttribute("src", projects[index]["path"]); Now, setting the src attribute of a DOM element triggers the process of the engine to go to the source where that file is located and begin to download it (you can hit f12 in chrome, go to the network tab and see all the requests your browser is making on demand). However, in your code, you set the source and then immediately call updateSplider(); setInterval(function() { updateSlider(); }, 3000); So basically, you are not waiting for the image to actually download and be ready to render. The reason it "eventually" works, is because your browser by default will cache images it downloads, so once it actually has been downloaded, then when it comes back up in your cycle it is already cached/ready to be used. To fix this concept, you need to come up with a process that listens to the onload event for the elements you are setting the src to and then from there halt your slider until those images are actually ready to be shown (or show a wait spinner/etc). You can do this with different types of async approaches or you can make it entirely a blocking process that tracks how many images are currently pending loading and then render once they are done loading/etc. When you test something like this locally on your own server, you may not see an issue of this latency, but over the web/to any random users, download speed will absolutely cause these types of hiccups no matter how fast someone's internet is.
I don't have a real problem with Edge, but my issue is having all of my bookmarks/passwords/extensions already synced with Chrome. Such a shame. 
If you want to render a canvas with pure functions take a look at [react-canvas](https://github.com/Flipboard/react-canvas). With something like React you don't ever "clear" the canvas; you just tell it how you want the canvas to look at the current time and it does whatever side effects it needs to do to update it, so your code can be free of side effects.
This could be a problem for Microsoft in Europe.
No demo page? 
Maybe I'm missing something, but i thought `.mjs` wasn't settled on, and in fact was one of the less popular options for distinction of es modules within node.
This is how Microsoft will enforce DRM on their platform, and eliminate "Malware" installers. Probably going to require a registration service which is part of the "store" installer mechanism which has to be digitally signed by their service. But what about sending self-executing archives to people so they don't have to have winrar/7zip/zip etc.. or developers who have to test software. I suspect anyone who uses their older software will have to explicitly enable some kind of developer mode to run these other programs.
An advanced user is probably the best way to describe it. Installs a lot of software, often uses the terminal to manipulate certain things in macOS, etc. Essentially it's a user who does more than just browse websites, Skype, etc.
My bad! Every time I post it seems to be very well received, so I assumed it was OK. I'll work on getting others to post my stuff or post other people's stuff as well, which I assume will fix the issue?
I'll check it out! Thanks 😊
SME's? 
Because children usually have huge bank accounts. Better make those mistakes early than later when they do have money.
The kind of person the average users will ask when they fuck up.
Fortunately that's not the case on Mac OS
[removed]
Why is that a problem? You won't be using this OS anyway. No person that has bookmarks/passwords/extensions synced with Chrome is part of the target audience for W10S.
I use Evernote and I wish it had better support for code. If Quiver was available for Linux, I have no doubt that I would switch to it. 
Thanks! Very cool summary/list. Bookmarked/saved for later. I'll update my subscriptions. 
My entire family, who are barely computer literate, all sync their stuff with Chrome. In fact, I don't know anyone who doesn't. 
Yes x)~~, Nice! 
Yeap. Safari is becoming the new internet explorer. Especially the mobile version of it.
when chrome blocked java applets and flash, it was universally lauded as a great move, despite the popularity of those technologies... a bold move in protecting dumb users from causing the apocalypse... When microsoft does something similar, people get bent out of shape. In case you havent noticed lately, microsoft has a mission set out to become one of the most open platforms there is. They have already open sourced powershell, brought it to linux and mac, and now there is also the linux subsystem for windows, the consolehost is starting to get some serious attention from the dev team after a decades long hiatus .... visualstudio code and typescript and having a lot of open source contributions to other products as well as begining to allow open source contributions to microsoft products... They arent trying to block anyone, they are desperately trying to include everyone. Its a wonderful time to be alive for people who manage computers for a living.
I think it's trying to compete with Chromebooks but instead of making a custom OS that's basic by design, they're just taking Windows and restricting shit for no apparent reason. Horrible business decision.
&gt; There is no true equivalent of this for desktop yet. I feel Chromeboxes are pretty close. I've installed several for elderly family members using their current keyboard, mouse and screen, and they get on with them really well. The ~4 second boot time is even more noticeable when replacing an aging Windows desktop PC. 
My only complaint is the audio when you are coding is too quiet. You speak too softly, and it sounds like the noise filtering (more specifically the gate) isnt always passing words. Maybe try backing it off a little, and add some (audio) compression (not data compression!). Perhaps roll off or shelve off a little of the low end. 11:50 to 12:05 is a good example of the audio dropping in &amp; out. When you are talking to the camera, its great (... although it might be worth switching off the AGC of the camera (or auto brightness, or whatever). Get a nice brightness, then stop the camera from automatically adjusting it. It will make edits easier, as the overall picture will stay similar). 1:15 is an example of this. Good content tho. Well explained and nicely delivered!
Looks useful! If anyone's interested, I have a variety of other similar-ish libs listed in the [Store#Synchronization](https://github.com/markerikson/redux-ecosystem-links/blob/master/store.md#synchronization) section of my [Redux addons catalog](https://github.com/markerikson/redux-ecosystem-links). (Actually already added `cross-tab-middleware` to the list over the weekend, too :) )
We've got an ES5/Backbone app and just started adding a couple new features using React and Redux. No Babel or compilation step yet, so we're using [react-hyperscript-helpers](https://github.com/Jador/react-hyperscript-helpers) as an alternative to JSX. Working pretty well for us.
Here's how this conversation would go at every company I've ever worked at: Me: "Can I intentionally break our product so that 5% of our users won't even be able to load the site?" My Boss: "No." This post is fantasy-land as far as I'm concerned.
My main question of the article is: If already in a workflow where transpiling is used, why change it if its gonna cost you users?
Look at the context here. Nobody we know may like the idea of never using anything but Chrome, yet, there's a very viable market for ChromeOS. Windows Store may be a failure, but that's due to lack of buy-in and some compatibility issues. Both are being addressed right here - big names announced to be coming to the windows store, and MS forcing a distribution format without compatibility issues. Maybe the salves work. The Mac App Store, imperfect as it is, proves that app stores can succeed on the desktop. iOS has banned competition on the browser front since inception, so I'm sure MS isn't putting themselves at risk of being sued. I'm not at all saying that makes it a good thing. Just understandable. What thief wouldn't snatch what they know they won't be punished for? Trusted app repos are very valuable. They're not just for the technologically illiterate, in fact they come to us from the opposite end of the spectrum - linux. They're the solution to every time you've installed something that turned out to be a virus, every time a legitimate download was hacked and infested with malware, every time seemingly-good software shared your contacts behind the scenes. We should all hope that, one way or another, we get a great app repo. The problem is, MS sees the value they're providing here, so they're using it as a trojan horse for a cut of profits and stifling competition.
Microsoft Edge not allowed on Chromebook!
Not shilling, simply pointing out facts. I could care less what os you use, i just find it funny when people change their stance on a practice based on what company did it, rather than anything meaningful.
They are making it a guideline. I think they had programmatic rules in place to target spammers. Because mods are always awesome (I mean, you have to say it to not get banned...), the admins are relaxing some of the programmatic rules that would accidentally target legitimate users, and are leaving it up to the discretion of (awesome) mods. It was also rare that the rules would kick in against a non-legit user that hadn't already been dealt with by mods. That was my take-away from the announcement/discussion
What to do?
&gt; which lacks many features such as progressive web apps That's TV-level technobabel. There is literally no possible way any browser can "lack [...] progressive web apps". In fact, your entire post is nuts. You're making up the narrative you want then filling in the facts. You know what the truth is? Safari adheres to the standards (unlike IE). Safari was, by a mile, the first browser to fully support ES6 (unlike IE). Safari is evergreen (unlike IE). Safari's performance is among the best, certainly not restrictive (unlike IE). Safari is open-source, and is the basis for Chrome (absolutely unlike IE). So no, by no stretch of the imagination is Safari "the new IE". And every time I hear that, it's from what I'm guessing you are: a web dev who just can't stand that Safari doesn't make users download a new version every few minutes. You know what, deal with it. We've seen a hell of a lot worse than a company that doesn't do "agile".
I find windows 10 bearable and functional, though not easy or enjoyable like windows 7. Windows 8 is literally a forced blowjob of satans dick
I will definitely PM you. Thanks for the offer. I'm actually like 80% deaf in my right ear, so makes doing things like this a little more difficult ha. 
Windows 10 S is their version of a Chromebook. Can't install IE on a Chromebook either. Once this takes off (if it does) then Google will most likely package chrome for the windows store and you can install it.
Yeah, they are perfect for users who just want to surf the web, watch videos and use basic office apps. 
It sounds like they are looking to bring some competition into the niche chromebooks and chromebases now occupy. Computers that are cheap, easy to use and hard to screw up. 
Try Eloquent JavaScript, 2nd edition. The online version is free and is sprinkled with inline interactive exercises.
&gt; That's TV-level technobabel. There is literally no possible way any browser can "lack [...] progressive web apps". By progressive web apps, I'm referring to service workers and the other various APIs used for PWAs. Sorry I didn't list out every single API. &gt; So no, by no stretch of the imagination is Safari "the new IE". Not once in my post did I mention IE so I don't know what your rambling on about
Their original presentation talked about the education market a bit. So that might be a big chunk.
Here's how it will actually work for those of us who have an interest in, and the ability to, continuously implement the bleeding edge: - We will produce a non-transpiled code setup for use in modern browsers that support modules - We will continue to also produce transpiled code that will run in Lowest Common Denominator, for use with rendering engines that do not support modules Sometime in the course of the next 6 years or so, we may consider transitioning. However, we will probably still end up needing to transpile things, in the module version, because for the next foreseeable *forever* we will receive new updates to Javascript every year, which may or may not involve very large changes that may take quite some time for the browsers to implement natively. ... in which case, at some point, we will transition from shipping a module version and a non-module version.. to shipping only module versions.. one of which is transpiled to the Least Common Denominator that the users can get away with . . and it might end up being the only one unless a &lt;no*somefeature*&gt; tag is introduced that we can again use to fork from. 
What about make a limited account and only use that one. Only use admin account to install things. Thats the setup i have for my dad
They're trying to compete with Chromebooks for the education market.
So, I've not really used ng1 at all, learned ng2 and have been using it for about 8 months now, and really like it. Can you elaborate more? What kinds of things take too much time in ng2 that are much easier in ng1? EDIT: I should also add that I've only been using the Angular CLI, so I haven't had to mess with any build stuff during my entire time of using ng2.
This assumes you cannot possibly run a large web application without: transpiling from some other language **and** a billiion NPM modules. I suspect you can come up with a trilliion excuses why you absolutely cannot live without all the baggage. I absolutely detest transpilers for two reasons: * It requires a build process just to run the code. Make some code changes and then rebuild. Building takes time, which sucks my life away. There is nothing more wonderful than requiring a minimum of 30 minutes to do a 2 minute code change. * It is an excuse for people who have absolutely no idea what they are doing to participate. In a classroom or daycare where everybody is learning and holding hands this is great. When it comes to a production application that is a bloated piece of shit the wonderfulness starts to wear off. The most common excuse I hear when I mention that somebody might not need all the bullshit is something like..... but but but I work in a team and what about the newbs. Go fucking mentor them. Usually though mentoring is absent because everybody on the team sucks and most people are playing with imposter syndrome.
The stupid computer is a fix for the stupid person
Just want to let you know that some folks like me find this rule to be dumb and ensure you that you should not feel ashamed. People want to have someone to create free content for them but then forbids the author to advertise the content. This leads to situations like asking a friend to upload your content for you which doesn't solve anything but makes admins happy. I barely have time to write - forcing me to crawl the internet to earn some virtual karma in order to share my knowledge is discouraging.
First, I'd recommend reddit's wiki on self-promotion: https://www.reddit.com/wiki/selfpromotion You'll notice the first line of text there is: &gt; _"It's perfectly fine to be a redditor with a website, it's not okay to be a website with a reddit account." - Confucius_ If you're a normal redditor, i.e. you post whatever you think is interesting, regardless of the source, then occasionally posting your own content isn't a problem. However, if a majority of your posts are just your content, then it's clear that you're not actually a redditor -- you're just using reddit to generate traffic/clicks/sales/etc. And there are a _lot_ of people who use reddit solely to promote something they have a vested interest in -- a product, a company, a website, a youtube channel, even themselves. That's not what reddit is about; what makes reddit work, is the idea that users submit content that they think other redditors will enjoy. The abuses range from outright spam (_"buy my stuff!"_) to sneaky [astroturfing](https://en.wikipedia.org/wiki/Astroturfing). If your content is good enough, then you shouldn't have to continually post it yourself. There are content sources here that users practically race each other to post first, because the source is of high quality and practically guaranteed to be popular. We also give a grace period for content creators to share their work(s), typically 8-10 posts, so that they can get the word out and get some exposure. Additionally, our [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts are essentially a free-for-all, so even if you've been posting your own content too much, you can always post it there without worry of it counting against you. It's not a perfect system, and I've spent a lot of brain cycles trying to come up with something that is: * fair for all * doesn't pollute the sub with bad actors abusing the system * requires little, if any, moderator intervention (not because I mind doing it, but because I'm not always timely) Open to ideas :) **edit:** I forgot to address this question directly: &gt; If it gets upvoted, what difference does it make if the original creator posted it or not? The problem there is that votes can be manipulated very easily, there's a lot of posts that are filtered before they go public, and sometimes they'll have 3-5+ votes before anyone ever sees them. There are also spam rings that I've identified previously, and still exist, that just upvote each other's content and make empty comments to generate activity. So to trust only upvotes, or to make that a measure of fitness, is dangerous; we certainly don't want to encourage any further vote manipulation by making it a yardstick which distinguishes spam from non-spam.
The worst thing you can do is install browser extensions. If anything goes wrong there is always the "Powerwash" option which wipes it back to the day you bought it: reboot and log back in using your Google account and you're good to go again. Having said that, I've not had any actual screw-up problems from elderly relatives with them over the past few years.
You pretty much described the last 4.5 years of my life. Great to not be working that way, with those self-important arseclowns, anymore. :D 
Media source extensions! They were in an iOS beta and then removed, the bastards. 
&gt; But what happens when you don’t have the app window selected and you press a keyboard key, do you still hear any sounds? &gt; The answer is unfortunately a no. &gt; This behavior is because of the architecture upon which Electron was built. It doesn’t allow you to get global keys, like you can do with the C# language. I don’t know the real reason behind this caveat but I guess it has something to do with keyloggers and user’s privacy. I thought Electron has global hotkeys? https://github.com/electron/electron/blob/master/docs/api/global-shortcut.md
I cannot go back to Redux after using [MobX](https://mobx.js.org/).
When im asked this in life (randomly) I usually struggle for an answer that someone who is what we would call a regular 'user' would truly understand. I try things like "we use the Command Line Interface" or "we can read web code" and they usually give me a dismissive 'oh, ok, so you know a bit more about computers...". When I adopted the barely half-accurate 'Its basically a computer hacker" answer, they tend to get the point much faster, even if it's not an entirely true statement. They don't REALLY need to know what a power user is, so much as they need to understand that they, and likely very few people they know in life, are one.
Well done Tyler, thanks for sharing!
I guess we'll see whether the ES spec continues to outpace implementations of the spec. I'm pretty sure developers are always going to want to use new features without having to wait for even the 38% of evergreen browser users who don't get the update instantly. The title of the article suggests you _might_ not need transpilation - which is totally fair. We should be circumspect about important technical decisions. But to then claim &gt; Considering the statistics above, this means 2018 will be the year the majority of the web apps can get rid of the module bundlers or transpilers. seems too exaggerated for me. The author also seems to overstate the cost of using a transpilation/build process, though I could be convinced that the ecosystem is suffering from some 'architecture astronaut' space sickness around build tools and processes. Moving targets of browser implementation aside, there are going to be a significant number of projects that still use things that will never be native in browsers - JSX, like the author mentions, but also single-file components (e.g. Vue), custom file type loaders (e.g. Three.js has a loader for .glsl files, though admittedly a simple one), whole non-JS languages like TypeScript, and the upcoming WASM target. The author distinguishes between transpilation and compilation, but they might as well be the same thing.
Thanks! You're very welcome.
Just like they did on iOS. I don't like this one bit, but the people have the power to allow or deny it by buying S products. We'll have the option to release on the store, but nobody is forcing us.
I thought of putting a loading gif, but i don't want to as it doesn't speed up the slider. I have noticed that when i place the images directly in the HTML that there is negligible waiting time for the images to load (no JavaScript slider, just images below each other). Is there a way i could make all the images load when the website first starts loading? I was thinking: window.onload = function() { for(var count = 0; count &lt; projects.length; count++) { var img = new Image(); img.onload = function() { continue; }; } }; Edit: updated possible code to use
I'll just say though, that if I had had a computer running Windows 10 S when I was a kid, I probably never would've been a programmer. All these tightly controlled platforms (mobile too) may be nice but they offer very little in the way of tinkering. I think it's a bit of a shame this is slowly getting lost. 
Prepack doesn't do this level of optimization from what I understand. Its much more static analysis. Dart can do this as its type system is much stronger. Not so in JS.
&gt; Any software being developed such that each individual programmer has to wait for every other programmers changes is being developed wrong. You break down the software into multiple pieces and each programmer has their own local version of what they are working on that they can compile against continuously. No one else should be waiting on them and their slice of the software shouldn't take 15 minutes unless it's such an extreme case that the 15 minutes is justifiable. git branch &gt; The argument isn't that it's OK because everyone does it. Sure, but that is exactly what your comment said. At any rate a transpiler isn't the same as a compiler.
Microsoft's target demographic for Windows S and Surface Laptop is college kids -- they clearly didn't do their research. &gt; "We built Surface Laptop to do two things: refresh the classic laptop form factor that our customers, especially college students, have been asking for; and make a Surface that works seamlessly to showcase the best of Windows 10 S." https://blogs.windows.com/devices/2017/05/02/introducing-surface-laptop-powered-by-windows-10-s/
As a programmer too, I agree to an extent. Android is probably the most "tinkerable" and popular OS at the moment. I can't imagine many kids installing Linux.
Yeah, I grew up using DOS from a young age, and although one can't expect that level of complexity anymore, it is nice if popular systems today have at least a little bit of freedom to do stuff outside of the gated community. The problem is that freedom comes with a risk of blowing stuff up if you misuse it, like I did with DOS a few times. Still, that's how you learn...
&gt; Apple is single handily blocking web browser **invocation**. "Come to me, oh Chrome"
&gt; Not exactly the same but pretty damn close. Like Java and JavaScript? Transpilers convert one language into another whether higher or lower, like passing C through emscripten into JS. They certainly don't produce things the machine uses. The c compilation process passes code through an assembler so that it can produce object code which the machines use. You can even inject asm instructions into c lang code to direct its behavior at the assembler. The JIT compilers produce code that the machines use and not some other language that people write code in. Nobody refers to the JIT as a transpiler. 
...yet
This is exactly it. They want to try and compete with chromebooks, which are getting more and more popular in cases where a full computer isn't *really* necessary. 
And Vista? What do you think about Vista?
so either schools or government offices
I don't even know what you think this has to do with anything but if you want to sit there and try to pick apart every statement I quickly wrote on my phone as if it were a white paper assertion have fun with that. &gt;Nobody refers to the JIT as a transpiler. OK well good thing I didn't either.
"Your boss" is part of the things that breaks the advance of web development. If every "boss" said yes, I garantee that the 5% would be reduced to something between 0 and 1%. You also ignore the fact that you can have many browser on the same PC. I have Firefox and Opera for example. Nothing says that the 5% don't have one of the main ones in case of. And the numbers of websites that can boast being accessed by all the types of browsers frequently must be low. If you work for google or other monster companies I'd say why not. But chances are that you are not. Your problem is also that you said it in a way that leads your boss to think that he will miss 5% of the traffic. Which is false.
Consider multiple input single output compartmentalized blocks which abstract the code away and have the ai build the blocks instead of the underlying code. Run it with multiple webworkers / threads / etc on node.
Except Chrome was already a trusted and established browser before Chrome OS showed up. IE is still lackluster next to Chrome / Firefox / Opera besides maybe performance and efficiency. 
I'm a fan of javascript.info
Great suggestion! That's one way I was thinking of speeding this up: Parallelizing much of the "generate next population" function. There's no need to do those manipulations in sequence. As for compartmentalized blocks, I'm not sure yet how to approach that. Potentially simplest could be at the symbol level. So instead of manipulating characters, the code manipulates symbols from JS grammar. Manipulating ASTs could be even better, but that smells difficult to pull off well.
I think I'm at step 1 :D My overall fitness function does return a percentage. Like a "percent of max possible score" kind of thing. The problem I have is that code either is or isn't syntactically valid so I don't know how to express closeness to syntactical validity. For example, evolving a string is easy. You use levenhstein distance as your fitness function and that makes it easy to rank candidates based on how close they are to the target string. With syntax it's more like "works" vs. "doesn't work" ... how do you get "almost works". Actually ... maybe if I used a JavaScript parser that could tell me "I could parse X% of your code" ... hmmmm Thanks!
Look at Apple with iOS, they are doing the same thing. Chrome on iOS is just a wrapper interface for the Safari engine. 
Try developing for it. Then try developing for the remaining 99% of the market. After losing your mind with some stupid Safari-only bug that only occurs on iOS and that you can't reproduce or diagnose because you have to have the whole apple ecosystem in order to have remote inspect, you'll change your opinion of this crap browser. 
How about only enforcing these rules when the content/Redditor feels spammy, there's no way to describe exactly what spammy is but you'll know it when you see it type of deal. 
I find it awfully funny that everyone is complaining that store apps are limited to the in-os Web rendering engine, but Apple has been doing the same shitty practice for almost a decade on iOS, causing it to be the bane of existence for Web developers, but somehow that is all right because... Apple? 
Only if you're 200% positive the difference between your native and transpiled code will never cause an unknown bug.
Others have touched on the issue, but IMO the problem with Safari on IOS is that it's the only browser framework on IOS that Apple allows (outside of server side rendering content) So basically you run into an issue where you're dependent on updates from Apple, and you're operating on an Update cycle more consistent with Apple Product announcements then the fast tracked browser updates everyone is used to on desktop. On Mac you can largely ignore Safari by installing Chrome or Firefox. On IOS this isn't so easy. If someone wants to use a modern web feature, they have to shim it into an IOS app themselves. On top of that, you can't build a "modern" browser in IOS, you either have to render the content on a server (which is horrible from a user perspective because no one should expose their login info to a browser running on a server), or accept that Apple will update webkit if and when they feel like it. Firefox on IOS may be called modern, but only when apple pushes the update to make it modern. Apple may announce a lot of cool stuff in June, but chances are you won't actually see it until it ships and Android as a platform sounds much better for developers using web APIs then Apple. Microsoft to it's credit is at least trying to remain credible with Microsoft Edge. Apple however is super secretive outside webkit and it's hard to gauge when they'll adopt an existing API into Safari on IOS. 
So _that's_ why we had the same CSS bugs on iOS across Chrome and Safari! *facepalm*
A god among men.
It's terrible. Right now we're waiting on apple to fix at least 3 bugs with their webkit that's caused some horrible, horrible issues for us and some terrible hacks for us to fix. Not to mention one that means the browser essentially makes 200x more requests than it needs to when loading a page with SVGs. They need a much better release cycle than almost yearly.
I dont really care about conspiracy theories... i exclusively used linux for a decade,then moved to windows. I've managed nix and windows systems at scale. I could care less what OS you use, as long as I dont have to be sysadmin of thousands of machines running your text file based OS, even though im perfectly comfortable with grep |sed |awk at the micro level and cheff, puppet, etc at the macro level, management is just easier and more robust on the windows side of things, in my experience. I for one am very happy with the direction microsoft is finally moving in. 
Is this producing a static image from a 3D file ( e.g. Blender / .OBJ / 3DMax ) or is it doing a WebGL render of the model ( like ThreeJS or BabylonJS )? 
A check mark means there is a bypass for a given lib/mitigation pair
It is a really awesome presentation about how to write fast &amp; compiler-friendly JavaScript!
True, I was just pretty sure there was a law for laptops and desktops etc. Hence windows normally gives you the browser popup choice thing.
Demo is here: https://wearespindle.github.io/vue-tabcordion/ I still need to capture navigation events, so the tab switches back when a user presses the back button.
Make it perform poorly on ie11, and when there are complaints, tell them it is a bug with the browser and they need to upgrade? /sorrynotsorry
&gt; They need a much better release cycle than almost yearly. Thankfully they seem to be moving in that direction - the last point updates to iOS and MacOS came with a big update to Safari.
If Windows 10S takes off in a big way, Google will likely package up a version of Chrome which uses the Windows 10S HTML and JS engine - just like they do on iOS.
The same is true for any other browser on the iOS platform, as apple simply does not allow it browsers to implement their own
I don't understand why not. Why do you need a strange extra language for simple object properties to begin with? A language that has proven unstable and problematic. Javascript is suitable for handling layout and styles with ease. I also don't get the PHP reference. JSX absolutely encapsulates logic and layout. The looping and the conditionals map out state into views (you use the same in templates, just in an arbitrary way), but the logic lives in its own domain. In PHP and traditional Jquery apps all three (logic, code, markup) were literally one or had implicit "hooks" into one another. Nothing implicity about a *component* that declares the properties it receives, forms a layout according to them, and ships its style.
It's obvious you are unaware of history and are doomed to repeat it. 
&gt; Why do you need a strange extra language for simple object properties to begin with? Because it's not just "simple object properties"? If it *were* just "simple object properties", there would be no talk about CSS modules, nor CSS-in-JS. &gt; JSX absolutely encapsulates logic and layout. The looping and the conditionals map out state into views (you use the same in templates, just in an arbitrary way), but the logic lives in its own domain. In PHP and traditional Jquery apps all three (logic, code, markup) were literally one or had implicit "hooks" into one another. Nothing implicity about a component that declares the properties it receives, forms a layout according to them, and ships its style. I don't get what you're trying to say here. 
Note to self: Redditors need a library to copy text to clipboard cause they can't code it themselves.
You can also see this as a code snippet. No need to create a new dependency.
Because they are. Have you ever looked at typescript? It still has a lexical and syntax analyzer and code generation. It's also why typescript brands itself as a compiler and not a transpiler. Transpiler is just a convenience word not a technical one. You love to make dumb arguments in this sub. Just stop. You just look foolish because you don't even know what youre babbling on about half the time.
The average web app uses a gazillion modules. I'm not an expert, but I have no idea how can browsers resolve/load all of the used modules without significant network overhead.
What is the benefit of paying for scaledrone versus another service in the same space?
&gt; Because they are. Have you ever looked at typescript? Yes, I have written a TypeScript parser in JavaScript.
Really interested where this will lead to. I'm currently in the process of writing my thesis on supervised machine learning, and cannot recommend Python enough. Have you considered using a LSTM approach? The AI will have to remember what it wrote to make sense of it.
Yeah really, what's the big deal with not being able to install things on my computer or connect my server to anything...
Note to self: Redditors are sometimes dick to other people for no apparent reason
https://www.youtube.com/watch?v=K0IGlJJ3x8E
For this simple use case the benefit is price. 
The named capture groups enhancement for the replace method looks really useful. There are many times I have to do something like x.replace(/blahblah/, functionName);` where function name has to analyze the result to ensure it is only operating on certain matches.
&gt; Can't install IE on a Chromebook either. Except for Intel (as opposed to ARM) Chromebooks; Just enable developer mode, install [Crouton](https://github.com/dnschneid/crouton), then Wine, and finally IE.
This sounds like a homework question. 
And I'm sure a work around like that will eventually be found for the Windows 10 S devices. I feel like this thread is getting ahead of itself and complaining that something isn't available until it is. It is a new ecosystem. Give it time and it will either die a bastard child like windows phones, or grow and prosper with a vibrant app ecosystem like Android.
Angular and React
Sure, differences between development and production are already there, but I wouldn't go out of my way to add to them, just for a slightly faster compiler time. Yes, using minimizers and optimizers in development would also provide a benefit of closing the gap between dev and prod... but the cost of making it impossible to debug is a lot steeper cost than "builds take an extra second or two longer". Plus, if transpilation is a significant time-sink for dev, are you using incremental transpilation? Sure, my initial compile takes a few seconds, but every change after that is less than a second. (You criticize the "downvote voting", but note that you didn't actually provide any reasoning other than a somewhat condescending "don't you test?", until the downvotes came)
&gt; The problem I have is that code either is or isn't syntactically valid so I don't know how to express closeness to syntactical validity. Start with 'Here is an AST/some other config object. Make valid JS code!" Instead of doing any fitness or population control or anything. Start with model based learning and make it work. I find that having model based learning as the base line works well because I have a "This is correct but hard coded" experiences to compare what my computer is "learning" against. &gt; With syntax it's more like "works" vs. "doesn't work" ... how do you get "almost works". It is `valid` vs `invalid` so you are on to something there. But `almost works` shouldn't be apart of what you are doing now. `almost works` is a 'I almost chose the best option' instead. &gt; Actually ... maybe if I used a JavaScript parser that could tell me "I could parse X% of your code" ... hmmmm ....now you're on to something!
But for example when user close browser how the server will know that he end editing?
Not 100% sure what you're asking for and some of the formatting is a little weird but I think this should mostly do what you're looking for. const arr = storeobj.items.map(item =&gt; { const product = products.find(prod =&gt; prod.id == item.productID); return Object.assign(item, { images: product.images }); }); arr; // [{ productId: number, images: object[], ... }, ...]
Thank you for responding. Yeah, I could have worded that a bit better. I am trying to take the first JSON response, and check the IDs against the ID's in the second one and match the proper URL. `const cart = storeobj.items.map(item =&gt; { const product = products.find(prod =&gt; prod.id == item.productID); return Object.assign(item, { images: product.images.small_url, name: product.name, price: product.display_price,}); });` ? Will this help me with that?
&gt;Let's use Scaledrone as our signaling server because *it let us use WebRTC without doing any server programming*. But you don't need Scaledrone or any service &gt;However, if you wish to write your own signaling server, this tutorial will still work fine.
You can pretty much do this with template literals, just store the patterns as strings instead of RegExp instances. const foo = '[abc]'; const bar = new RegExp(`${foo}[123]`); I don't see much of a point in creating separate RegExp objects for each part of the pattern. You don't gain anything out of it, especially since you lose the flag information anyway when you add them into a larger pattern.
This one? https://github.com/vuejs-templates/pwa 
&gt;el.style.position = 'absolute'; &gt;el.style.left = '-9999px'; Doesn't this cause a reflow on the browser?
What's with the elitism? Anyone working for living should understand that whatever gets the job done is king and all other considerations should be afterthoughts. That said, of course you should place a priority on learning how to do everything yourself. Just make sure that you first get what needs to be done, done, then use your free time to expand your knowledge.
I use CircleCI (free version). It picks up code changes via webhooks from BitBucket (also supports GitHub). My repos contain build scripts that then zip the final JavaScript (output from TypeScript compiler) and upload it to AWS Lambda via the AWS JavaScript SDK.
Thanks, I just noticed a typo that went through the spellcheck. 
Thank you for such an awesome lecture.
Take a look at the code again, more specifically the "addToTodo" function, and see if you can find the issue
I forgot a semicolon, but that doesn't change anything. Otherwise I can't see it...
i'll give you another hint. you do this in `doSomething`, but not in `addToTodo` here's a hint that'll solve it for you [Spoiler](/s "you're omitting a specific keyword") finally, here's the way to do it that eliminates the whole problem altogether [Spoiler](/s "instead of passing in a function that invokes doSomething, just pass in doSomething")
Note to self: 28 lines of javascript is elitism for redditors.
No, talking to someone like they're retarded because they don't have your skill set is elitism. It's just bad taste bud.
https://jsfiddle.net/4y097wa7/4/ Debug your code, console.log is not the ultimate way to do it, but it can quickly help you see where you are blind. The other two are pointing you in the right direction, but I think you are getting lost with scope. See if the fiddle above helps you see.
I think you meant: var order = { items: [] }; order.items.push({"product": id, "quantity": q}); console.log('order: ' + order);
Yeah, that should work.
you were missing the return. you returned true to the anonymous function, but the anonymous function returned nothing.
Your number variable is treated internally as a string (text). You need to use: var number = parseInt(prompt("Choose a number between 1 and 10")); to force js to interpret the value as a number. Otherwise, "j" also becomes a string when you do "j = number"...
&gt; let done = (todo[i]()); Understand what (todo[i]()) returns and you will know why done = undefined
You got a job related to GIS without any ESRI/ArcGIS experience and haven't coded (JS?) in 3-4 years?
I reduced Redux by using Mobx. :) hehe!
I got contracted to do JS work (I know someone in the company that helped me get the gig). The client asked my company to contract people to do ESRI/ArcGIS. My friend wants me to bust ass to get ready for the contract. 
So even less clever than https://github.com/mattdiamond/fuckitjs
We're using 4.2. Migrating our platform from 3 to 4 was such an ordeal and took so long that no one can stomach upgrading to a newer version. The whole thing is seriously awful.
I have looked through their website to get a general idea, but it seemed to be older. I was hoping that someone might know of a tutorial series that I could check out to get a better idea. An example of what the client is asking us to do before we kick the contract off: Develop a custom interface that uses 0Auth2 authentication against the ArcGIS platform to access user items and add tags. The interface should check authentication authenticity, have an input section to add tags and give feedback as to if everything was successful or not.
We use heroku mainly because of how easy it is. Will probably migrate to AWS later in the lifecycle of the app. We use codeship for CI but we mainly use it as a tool to see if code from PRs are ready to be merged or not. That's basically it aside from git.
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push?v=example &gt;**Return value** &gt;The new length property of the object upon which the method was called. You're assigning the length of the Array (1) to "order". var order = {items: []}; order.items.push({"product": id, "quantity": q}); console.log('order: ' + order);
I don't disagree with anything you've brought up! I guess I can sum up my position with two propositions: 1. developers will always want more than browsers provide (whether new ES features faster, or different syntaxes/languages) 2. the build ecosystem will eventually settle down from the current Cambrian explosion Accepting those propositions would indicate that there is a robust role for transpilation/compilation in serious web apps going into the future, even if there is _also_ space for pure/non-transpiled JS code being used in the wild.
comp science
solid advice, my entire summer is gonna be dedicated to this man, all this community college has done is confuse me on EASY topics and just make me copy and paste code, awful school.. JUST AWFUL!! i really dont wanna be there another semester, I HATE wasting time but I hate when the time I'm wasting is actually hurting me.. because they confuse me and just have me copy code that looks like non-sense to me
You know what I want (and I was just struggling with this)? I want the ability to do global string replace on any text based files that webpack touches, whether it's just copying files from one place to another, or including said files into a bundle. I tried a bunch of plugin combinations and I can get *something* working though it's inconsistent.
You're an intensely unpleasant person and I'm surprised you've gotten anywhere in life with your apparent lack of social skills.
Probably shared worker.
lol, yeah I'm in new york so if my portfolio speaks for itself i dont think the job hunt will be scarce but yeah i am defenitely going to eat shit from people, that's just gonna be how it is but i'm kinda a "yes boss" kinda guy so I'm not gonna get emotional over that shit. The school stuff has been plain garbage so far, my professor knowingly feeding me shit turns me off from it so badly. i'm going to just take advantage of my motivation and just work so damn diligently i wont have to go back there.
I'm just putting this here: https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q
That was the best high-level overview of the struggles of the Node core team dealing with modules I've read yet. Unfortunately we're all stuck with transpiling and bundles for at least 5+ years because of browser support, but at least that gives them time to sort this out. Cheers to hoping that .mjs doesn't win the battle...
I think the points 4 and 5 are the best. 4. Easier to share and compose (same as CSS components). 5. Portability to other platforms besides the browser
Yeah there's actually an app for that. It's called iOS.
As if your opinion matters. You're just an angry person bitching about reddit, via reddit. Sad.
This is strangely cool. I actually have a good use for this, thanks!
As purely syntactic matter, the old CommonJS syntax feels more native for JavaScript. For instance, what would be the simplest ES6 module version for createStream: require("mithril/stream"), in https://github.com/dmitriz/un/blob/master/examples/active-counter/index.js#L36 ? 
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [dmitriz/un/.../**index.js#L36** (master → f6548dd)](https://github.com/dmitriz/un/blob/f6548dde85b50e22109040d75a9ec7e7348f1d60/examples/active-counter/index.js#L36) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dhyj03e.)^.
I agree completely! (html, css, js) is not separation by concerns, it's separation by filetype... I'm in favor for all-in-js o/
All the reddit headlines say you MUST use React cause you can't survive without it. And you MUST use it everywhere! That's the only reason redditors use React. Cause reddit headlines tell them what to do. So you should, too?
At least the proposal for dynamic ESM imports is stage 3. Hopefully it'll be in ES2018 and then it'll make things a lot more palpable.
Hi /u/SonGoku2017, if you have a specific question and have already attempted to answer it, then we're more than glad to help, but we're not going to do your work/homework for you.
React is all client-side js, and it's really good at rendering a view based on data, and updating the view when the data changes ("reacting" to it). It's only really useful if you need a dynamic client-side ui like a SPA, or some interactive widget. 
Okay. So it makes sense for Facebook because it makes it easy to manage a constant stream of posts?
You can render React components on the server and serve the rendered HTML to the client; look up "isomorphic" web applications. This is really handy for SEO and stuff like that, but can limit the reactivity of your application. But React handles stricly the View layer of an application, so any backend API calls and stuff will be implemented in NodeJS and something like ExpressJS or Koa (optionally, if you want to use a framework to help write your endpoints). So React is only about rendering the frontend of an app. 
Thank you for the response. Checking these out now.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [assertible/move-file-loader/.../**index.js#L26** (master → 47b57c5)](https://github.com/assertible/move-file-loader/blob/47b57c52fe4c41e798dea94c478dde2f264105f5/index.js#L26) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dhyljiv.)^.
 import * as createStream from 'mithril/stream';
If you are circling back to Javascript I'd go with Java. That gives you the front end and a strong back end language for full stack web work. Personally I think it's best to focus on a goal of what you want to deliver and avoid tinkering with tools and languages that aren't relevant to that. At the 101 academic level it seems like broadening horizons is a good approach but once you step foot into the professional world pretty much everything you learn leaves you with 1 answer and 10 new questions and the horizon is constantly receding faster than your ability to see it. 
If you *want* to return a new array after adding a new item to it, use `.concat`. `let array = [];` `let newArray = array.concat([itemToAdd]);` Note that `concat` will expect to receive an array, which is why I wrapped `itemToAdd` as one.
Basically. The news streams, post updates, messenger, and more can be dynamically updated without being too taxing. This is useful if you need to update a stream of information without forcing a user to reload. React-native does similar things, but on mobile. Think Instagram and Facebook messenger. 
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [dmitriz/un/.../**index.js#L36** (master → f6548dd)](https://github.com/dmitriz/un/blob/f6548dde85b50e22109040d75a9ec7e7348f1d60/examples/active-counter/index.js#L36) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dhynd3w.)^.
You are close but have many incorrect statements. Java and C++ are languages that are written in human readable syntax that get compiled into byte code. JavaScript is a scripting language that runs via interpreter or engine. Both C++ and Java run on any environment, Java doing so through the jvm. Neither are better than the other, with one difference being that C++ has pointers and requires the developer to manage memory, where Java has garbage collection and does not require memory management. Java will have more applicable uses cases in web dev. JavaScript was named so because the creators thought the syntax was similar to Java, which is funny because Java 8 looks similar to JS. I'm a strange twist, the V8 engine and other interpreters are written in C/C++ and companies like Mozilla hire C++ devs. The bottom line is that C++ and Java have different use cases and you should choose a use case, not a language.
Might not be the design itself the cause of the problem? The ES6 module design is not written in the native JS style, where a new variable is created via an equality assignment like `var a = b`. It breaks the standard JS model and so hacks are needed to get around.
There are a few tools to format Reddit code. A [website](http://redditlint.com/) and a [Chrome Extension](https://chrome.google.com/webstore/detail/ctg-plugins/hjljaklopfcidbbglpbehlgmelokabcp), second of which I created. Onto your question. If the div with the class of "key" only has children one layer deep, then you can use this code: if (e.target.parentElement.className == "key" || e.target.className == "key")
lol `"date"` and `"unknown"` are not typeof values... https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof
Thanks! The problem is that a class is being applied to the parent div with the class of .key. So if one of its children become e.target, then the class would be applied to those elements, no?
I thought tinders API was all but public
Hey, thank you for this excellent reply. In the time since I've posted my comment, I've started using React at my day job in exactly the way you elaborated on. We have legacy requirements and also highly complex requirements in general. Even our new, clean-slate projects require a mix of React and DOM elements, i.e. for other API integrations. Super glad to see you can fairly easily mix React and DOM subtrees. These are real world requirements! 
You say static, but the commonjs style you are asking about is far from static. There's no way to resolve those requires without running the code.
You're welcome. Though as an update, some of my examples are out of date. Walmart, for instance, is now using React sitewide, and NatGeo's entire front page is done with React. Walmart has some server side rendering to speed up things, but NatGeo does it all client side, so it looks like they might be evolving into a SPA. I wouldn't use NatGeo as an example of anything anymore. The company has gone downhill. Management closed down all the open source projects, and has been making some seriously questionable decisions with which contractors it hires leading to perverse code. /rant 
React, and any other front end framework, is most useful when you are trying to build an application that looks and operates like a traditional desktop or mobile app in the browser. For example, you have multiple views that you would like to display on a single page without causing a browser refresh, and you want these views to be displayed dynamically based on user interactions, url route changes, etc. If you are just displaying mostly static html, or just trying to dress up user interactions on a mostly static html page, you probably don't need a frontend framework. If you've got more than three or four views that are dependent on a bunch of state, you'll probably want a framework.
React Native and Ionic for example
What about storing your data as JSON and loading it dynamically? 
This is from a talk? 
It is standard to have equality assignment in JS. This is broken here. Looking at, I have no immediate clue what is initialized. That I would have with =. Great article but I could not see there the reason to break the JS assignment syntax.
Java for sure
&gt; Cheers to hoping that .mjs doesn't win the battle... You should really only say something like this if you have proper arguments against it, other than that it just _feels_ bad. Because although I can understand that feeling, it isn't enough to dismiss it. [Here](http://2ality.com/2017/05/es-module-specifiers.html#why-new-extension)'s a nice overview of the advantages.
Creating an object with properties containing different modules seems kind of odd... What would be your use case for this?
Not at all. Imports are strictly more static that assignments. (E.g. they accept only static strings). They're designed to be *easier* for tools to handle. The whole mjs thing exists because es6 modules are strict mode and cjs ones aren't (unless you opt in via `'use strict'`) So suppose you have `import 'foo.js'` and a foo.js containing function foo() { return this } console.log(foo()) When you execute the `import 'foo.js'` statement, node won't know if the module is a cjs or es6 module, therefore if it's strict or not, and therefore if it should log the `global` object or `undefined` I don't like mjs at all. I think they should have handled it so `import` can't handle commonjs modules, and you still have to call `require` for those.
FYI there is a official browser version of tinder coming
Interesting concept. Feedback: 1. Freeform widgets is just asking to get disorganized. It may feel more boring, but some kind of list view with possible splitting of content view area among different content would be more organized than virtual windows. If you must use windows, though, at least do snapping. 2. What if I want dozens of "pages"? Looks like you have a tab interface. Think about what happens when you have more than a couple. 3. Complements on having a clean UI and smooth animations. The exception being the background. Again, it's quirky and cool, but also confusing. Are those just slanted, default widgets I can click? 4. How do I group things within each page? Is there a meta widget that holds other widgets. Can widgets be nested? 5. Does universal undo work? If I type something in a note, then add a todo item, will undoing first remove the todo and then the text entered in the note? 6. What other keyboard controls do you have? Can I make a new thing without the mouse? 7. What if I want to have two different "pages" of widgets open in two different tabs of the browser? Will updates propogate to the other tab? Will it do this without talking to the internet, detecting the other tab via postMessage? 8. Real time collaborative features?
My cs degree taught me loads. :/
There are literally sections called "benefit 1," "benefit 2," "benefit 3," "benefit 4," and "benefit 5."
Does anybody know dop? Is like ddp but agnostic to all frameworks. https://distributedobjectprotocol.org/
&gt; "feels bad"? Nobody's talking about feelings I wasn't saying someone was talking about feeilngs, but just that if you're naming arguments, feelings wouldn't be a good one. Do you have any concrete example what "eroding the standardization" means in practice, i.e. what we will not be able to do soon that we are able to do now?
[This one?](https://github.com/dmitriz/un/blob/master/examples/active-counter/index.js#L36) In that case, what would feel natural to me would be to have `mount` be a separate module, so that I don't need to care about how that function is constructed. It's somewhat restricting to have to do it that way, but it's pretty OK to do it this way and easily worth it if it gives us tree-shaking.
&gt; You think I care what you, a redditor, thinks of me? We don't _think_ you care. We _know_ you care. Otherwise you wouldn't be here spouting whatever nonsense crosses your angry little mind. &gt; I speak of redditors as they deserve to be treated and no better. You speak like the sort of person who deliberately goes out to offend people then wonders why they have no good friends. &gt; Just look at this place. If you don't like it, why are you here when there are many other places you could be? Maybe you could show us how great you are by making something better, instead of spending your time making yourself look like nothing more than an angry dick?
It's not that clear, but another con is not being able to keep modules and scripts in the same directory, and to bind a module to the directory it's in. That said, I agree that it's the most viable alternative.
Similarly I'm amazed by the ass-hattery of some people, pretenders who think they know "social interaction" and stuff.
&gt; As far as I know, React was the first framework/library that introduced components-based approach to the web According to this: https://en.wikipedia.org/wiki/Web_Components#History, Polymer was the first library featuring Web Components.
No, because its closer to a fetch.then than a = b. When you are referring to anything external, you need to be able to potentially defer the outcome, or perform it all before you start - so static analysis or run-time promises are the only two options.
Web Components, yes. That's a specific set of standards that have been driven by Google and Polymer is the implementation part of that effort. Components as a UI concept in JS predates those standards by a couple years.I believe the initial web components drafts were 2011 or so. The first JS framework using components in the way your parent post means is Sproutcore back in 2007 (Ember was originally Sproutcore 2.0 before the re-brand). Components in the current sense were popularized by Angular around 2010 and further with React's release in 2013.
Neither - it's like asking which one between Amsterdam or Bruxelles is closer to Cyprus. Although many devs will tell you that C++ will give you a better "education" than Java, as it is a better language, there are benefits in choosing Java instead. Namely, interacting with BE devs and the chance to get into Android development. Basically Java was born with the web, C++ was (an OOP version of a language) born with Unix. 
The point of the todo example applications are used as a starting point in many cases; they try to cover the concepts of programming (in multiple languages) - so I guess that it's just a continuation of that trend to show you how to do it but in the 'Redux' way. https://learnredux.com is a pretty good place to start, I found that Dan's tutorials were hard to follow and that there was too much 'jargon' to understand, making the learning process that much more difficult.
Good read. At my company, we integrated react for performance critical components into our existing angularjs app in much the same way.
Sorry, but the 'simple and obvious solution' has now tightly coupled startFlowReducer's functionality to changeViewReducer. There should be a separate composing function if you're going to go that route.
The todo app is common because [TodoMVC](http://todomvc.com/) is sort of the rosetta stone for framework comparisons and Todo apps are easy to implement. If you're interested in seeing a larger example, there's a new effort to compare frameworks by building [a medium clone](https://github.com/gothinkster/react-redux-realworld-example-app).
Some of the [examples on the redux github](https://github.com/reactjs/redux/tree/master/examples/real-world) are more complex.
Many of the posts here are telling you WHY to use react without telling you WHEN to use React. So that's what I will do. React, and most other client side frameworks, try to provide developers with tools to easily create Web applications. These differ from standard websites in the fact that they are data-driven and are constantly responding to something, whether that be user interaction, Data that is being sent to and from the server, etc. With a lot of changing data comes the need to change the visual display the user sees. These means a lot of interacting with the DOM and changing it. This can be a really big performance bottleneck, and not to mention the nightmare of trying to manage the state of your application. Sure, there are optimizations you can make like using document fragments to minimize the amount of manipulation you need to do, but it still adds up. Most modern frameworks circumvent this by implementing what is called a virtual DOM that other users here have touched on. The gist of that is that it is an in memory copy of what the current real DOM should look like. These frameworks will listen for changes and then create an updated version of the virtual DOM and then only update the essential pieces of the real DOM based on the changes reflected in the virtual DOM. In short, walking a plain javascript object (the virtual DOM) is much faster than traversing the actual DOM. Combine that with the other optimizations of the virtual DOM and you can have a nice solution to your DOM bottleneck. Outside of this, there are a lot of pros that others have covered. The take away is that if you have a large, data driven application that manipulates the DOM a lot, you should probably consider checking out a framework like react or vue. 
Cause that's as far as such people get. They don't know how to use it beyond that and anything beyond that is far too complex which says a lot about redux itself.
&gt; dont want to waste another minute learning crap Well, if you want to make a "great living," then don't let potential employers or customers know this. In programming you must have the desire to learn every day for the rest of your life. You are obviously eager to get started, but you need a good grounding in computer science. Data structures, algorithms, category theory, etc, are not arcane topics, but tools in your toolkit that you can use every day. You will understand the "why" of your code, and not just the "how." Then when the difficult tasks come along in the future, you can handle it, and even help others (co-workers, and, if lucky, employees?). 
Pluralsight's (repo available on Cory House's github) redux course uses a different example, but the to-do app is pretty standard across frameworks. Tutorials are just jump-starts to get you familiar with the tech so you can use the documentation and community. There's also a few different examples in the redux repo.
That's exactly what I went through.. Backporting to state management library(MobX in my case) was a task of patience and hair-pulling. 
Given how `mithril` has set up its exports and the additional import from `hyperscript-helper`, he would (at a minimum) need to do something more like this: import * as createElement from 'mithril'; import { stream as createStream, render as mithrilRender } from 'mithril'; import * as createTags from 'hyperscript-helpers'; So, while it's not _quite_ as neat, it would still mean he is reducing the imports required (3 instead of 4) and the `createMount` configuration object can use shorthand notation instead.
They're two different approaches, which is better for what depends on your project. Redux establishes a clean architecture first and foremost, no leeway to go astray. The cost is a bit more boilerplate. MobX solves small cases very conveniently, and you *can* in theory get the same clean architecture but nothing enforces it, so you likely end up with observables here and there, mutations from everywhere. For a fair discussion of both technologies have a look at the following: https://www.youtube.com/watch?v=76FRrbY18Bs MobX Redux easier learned + - less boilerplate + - modularity + - dev tools - + inspection - + predictability - + maintainability - + eco system - +
Interesting; would the constructor for that just be a conversion from the object literal format to the constructor one? e.g. function Weapon(config) { this.name = config.name; this.smallImg = config.smallImg; this.largeImg = config.largeImg; this.wieldedBy = config.wieldedBy; } If so, what would be the advantage of using a constructor instance versus just using the raw data parsed from a JSON?
Do you mean this one: [Modern React with Redux](https://www.udemy.com/react-redux/)? I'm doing this course too, I'm up to the weather forecaster project. 
It's cleaner to store data and code separately. It's a form of [loose coupling](https://en.wikipedia.org/wiki/Loose_coupling). Also, you can read/generate/edit JSON using external programs. E.g., you could write a Python script that uses your weapons list to generate a help page describing all of the character classes and what weapons they can wield.
Yeah but god damn decorators ! Why are standards so reluctant to include them. They are omitted from most create X app and needs a legacy babel plugin to work.. Yes you can "not" use them but then its pretty strange syntax to me. I feel like its a "tiny" bit too soon for mobx 
&gt; a bit more boilerplate LOL!
Oh i use em, i use my 'transform-decorators-legacy' and i love it. But there are often little quirks, like recently, wanted to go "standard js" linter to remove "choices" and have the same style everywhere. But they don't support decorators. We're interrested in create react app for its now PWA by default but they don't support decorators.. 
Yes.
Google just had their I/O conference and they announced/endorsed a new initiative to make a spiritual successor to Todo apps: [Hacker News readers as Progressive Web Apps](https://hnpwa.com/) The goal is to show how each major framework approaches progressive web apps and server-side rendering.
"Rosetta stone" is a perfect analog for the to-do list examples, IMO. It's only really useful if you are already familiar with how to do the same thing in other ways. E.g., if you already know Angular and React, building a quick to-do list in Vue will make it pretty clear, pretty quick, what exactly the point of Vue is, and what kind of problems it helps solve. To *actually learn* these kinds of things, building a to-do list is only about as useful as dipping your toes in a pool to learn how to swim. It's a good first step, sure, but it's still just a first step. Need to actually dive in to get a meaningful experience. I *love* the concept of [realworld.io](https://realworld.io) for trying to standardize that next step, at least getting you waist-deep in the pool. [Their introduction](https://medium.com/@ericsimons/introducing-realworld-6016654d36b5) is definitely worth reading. Though I feel like state management libraries are a hard thing to pick up on conceptually if you don't have an immediate need for them, even if you do come across some bangin' tutorials. Personally, I'd recommend attempting to build a Trello clone in pure React, and see just how crazy state management can get. Then create a branch, and integrate Redux -- the "OMFG THIS IS AMAZING!!1" epiphany should hit pretty quick. Then maybe create another branch, and give it a shot with MobX. Or alternatively, check out a mobbed-up to-do list, since that baseline knowledge of Redux makes the "rosetta stone" useful now. 
I agree with your points, this talk was created with a very limited deadline, so I do see lot's of problems with it, problems that I wan't to fix (that's why it's just a plain github repo: https://github.com/m4n3z40/fp-intro-presentation) , then I can get your feedback (or PRs) and improve the presentation over time. Can you provide some more context about how currying differs from partial application? How can I improve the explanation of unary? How can the "divide and conquer" topic be more broad and accurate? How could the intro be more specific towards FP (I really think the declarative code point is really strong all on itself)? Can I improve the monads piece instead of removing it completely? how? Liked your idea about changing the title to be "more humble", but I really think the benefits of FP can be immediate, and I also think that with just the knowledge "glossed over" in this presentation, one can at the very least start his journey through FP and develop an initial experience that will help break the so feared walls of functional programming theories. Thanks a lot for your feedback. Love to read your follow up. Cheers. 
That moment when not even owner of repo is watching it.
Checkout wesbos.com He has an instagram clone you build. It's free and he is a bad ass teacher.
Thank you, how do I adapt to add in price name and other variables?
Awesome. Thanks for that solid overview. Everyone seems to be talking about using these frameworks for *everything*, so I'm glad to hear that it's not a necessity for small projects or sites. You've answered everything I was wondering!
Likewise with PWAs.
I use standard with decorators without a problem. Might have to use `"parser": "babel-eslint",` though
As a primarily web developer who uses Linux I really agree. Using React Native made a lot of sense right away being used to React. I'm really excited to see some competitors in the space too, especially NativeScript. Learning to deal with Apple stuff was hell. Usually new technology is hard for me at first and then I learn to appreciate it. Apple's work flow is very antagonistic of web dev norms like CI. It makes me feel like a worse developer the more I interact with it. And their restrictions to forcing you to use MacOS - even Microsoft has moved away from that type of lock in with .net, VS Code, Azure, and their IE virtual machines.
After some review over project requirements, as well as seeing how some other apps do this (Discord, for example), I think I like this approach more than my original plan. I played around with electron-vue last night, and I really think that Vue+Vuex is going to be a good fit for what I'm trying to do. Now, I'm struggling to properly structure my project; as I don't necessarily want all of the electron and CLI stuff mixing with my web app and PhoneGap/Cordova package. Any tips?
Native in the end is still generally smoother. Animations just run better, and input responds more quickly. Though these things have improved, I still find it to be lagging behind. Though native has a higher cost to develop for sure. 
But I don't think React Native is classified as a hybrid app. Yes you develop using web-like tool chains, but you end up with a truly native app. 
I had the total opposite experience. I loved Dan's courses. You get to see how he implemented the core part of the library, and how beautifully everything came togehter. Compare this to Wes' course. I felt like he threw wayyy too much at me right from the get go. IMO, there is no need to introduce 'react-router-redux' in a redux tutorial meant for newcomers. 
Thank you. Question: const product = products.find(prod =&gt; prod.id == item.productID); returns undefined?? Why is that? 
I totally agree. The lagging behind part is almost entirely due to Apple which is what makes this so frustrating. Hopefully we see some major progress over the next few years.
I've seen it on android devices too. Especially with cordova apps, but even with react native. Though it was a little bit ago (8 months maybe) that i last ran RN on an android phone. Updates have been improving this stuff.
In my experience it's even worse than described. I had to abandon an app last year because even though I was able to take photos, modify them with canvas, and save the resulting image, I was not allowed to save it to the main photo roll and got no feedback but silent failures. If there was documentation that had told me this, I would not have wasted weeks of pointless effort. Also, JavaScript local storage on iOS is stored in the cache folder and subject to unpredictable deletion. This makes a powerful UI feature only good for session-persistent data. Also, the UI click delay (ostensibly for their stupid double-tap to zoom feature) cripples a web UI by making it appear less performant. A more paranoid version of myself would claim a conspiracy to malign hybrid apps. The realistic me figures they just don't give enough of a crap.
The slow input is not a inherent problem, but a "feature" of Safari iOS. You can "trick" it into being blazing fast by using touch events like `ontouchstart` instead of `onclick`.
&gt; Users don't care if you app is fast they care if it's fast *enough* Welcome to the world of shitty software. I suspect *my* definition of enough is different than the project manager prioritizing work.
the link is to the rules section. It doesn't have anything on the parser configuration as far as I read. It's a config you set up in you package.json. Standard.js works very well without any config, but you'd be foolish to think you can use it on a big project without a couple lines of config.
My actual quote was: &gt; A Hybrid version of an app will never be as fast as a native version of the same app, but it doesn’t matter as long as the Hybrid version is fast enough. Put simply, if your users never complain about the performance of your app then it is fast enough. Fast enough means that your app *is* fast. 
No chance. Unless Microsoft really fucked it up, there's no way out of Windows 10s's environment. And if there is, you won't see a random kid stumble on the solution.
An example might be using a tableView. Tables work fundamentally differently in iOS land than on the web. RN creates a way of implementing a native tableView in JS, but it is kind of tricky to understand unless you've done it natively before. 
Yep. Same.
I would not say Apple is completely to blame. Consider this article about Android vs Apple JS performance: https://meta.discourse.org/t/the-state-of-javascript-on-android-in-2015-is-poor/33889 Its a little older, but here is also a follow up about how they addressed discourse performance a bit: https://eviltrout.com/2016/02/25/fixing-android-performance.html My point is that Android JS performance lags behind Apple, but Apple spec adoption lags behind Android. So it is a tradeoff that basically just points to hybrid apps being awful for mobile devices. Note: In the first link you can see that Samsung devices don't have the same issue as most android devices. Well that is because they custom compile their own browser for their phones rather than using default android or chrome browsers.
i don't know if this is the right way i now tried to put "required" to the radio button, checkbox and dropdown and it works but now i have the html5 validation textes shown - is there a way to not show them?
make it public bro
Awwww men.... sorry i linked the rules... here is the link to the page itself for you to understand its a library that has no configs and auto format code on a certain standard. Its nice to have because its the same everywhere.... its an initiative from a dude feross. but it caches on... https://standardjs.com/ yes you can configure it : https://github.com/feross/eslint-config-standard But its really not encouraged.. Just look at the descriptions.. &gt; Install &gt; This module is for advanced users. You probably want to use standard instead :) &gt; npm install eslint-config-standard I feel like you are being oblivious un purpose. 
None of these benefits justifies the syntax. Why not e.g. static lib = require('file') which would be instantly more readable to anyone using JS?
Damn, I don't know what the fuck is wrong with me. Thanks for the heads up!
Then why not declare this by one single new keyword? Like `static` instead of `const`? Where is the need for 2 keywords? What is the `from` doing in JS? Travelled all the way from Python? :) Your example is using `this`, which already suffers from many other problems. I would imagine this problem wouldn't occur with pure functions? 
It's it really that hard to call a function? 
By static I mean here that my imported functions do not change. If they do not change, there is no need to import them async imo. 
&gt;But if everything is filled in, except the Radio Buttons, Checkbox and Dropdown then i get no Error Message. &gt;i now tried to put "required" to the radio button, checkbox and dropdown and it works but now i have the html5 validation textes shown - is there a way to not show them? I don't see the mentioned problem. Both works fine.
I use projects with a different version of ts than the vscode version and intellisense works fine for me. Maybe an extension is causing your issue?
Right. But OPs article seems to be talking more about Cordova apps, which while they are native apps, are really more pure html/js just within a webview.
the name seems badly chosen. id3 is a pretty popular metadata descriptor
Bulk? I don't agree with you. I keep my models (all observables AND actions) in 1 place, ES6 classes .. which my react components observe. It works awesome. I get it, you love redux. I've used both for over a year. I don't have negative feelings about redux, but MobX is better than you're giving it credit for. You're entitled to your opinion, but don't spread FUD. It's not flux.
Its not for "advanced users". Its a config file just like any other ESLint config file. It has buncha ESLint rules, noting else. But yes, I agree with whoever said it will require some config to be used on a bigger project. Don't be scared or hesitant to play around with this stuff. I had that problem for the longest time, but that is how you will get comfortable with it. 
ES2015? Uh. That's so 2015 and late.
https://en.wikipedia.org/wiki/Greenfield_project &gt; a greenfield project is one that lacks constraints imposed by prior work
Todo is a perfect starting "app" by which frameworks or approaches compare themselves, because it contains the bare minimum of CRUD while being highly achievable. Achievable within a day, or more if you wish to spread out the lesson. I hope people aren't avoiding todo because it sounds so unoriginal and simplistic. It's worth your time as a first learning project partly because of how fast and achievable it is. The Reddit app featured on the Redux tutorials is a natural next step after todos, because it goes one step beyond todo -- async web requests.
There's no point in arguing with you.
There's actually many tutorials out there that are much more than just a todo app. My [React/Redux links list](https://github.com/markerikson/react-redux-links) has a section for [Redux Tutorials](https://github.com/markerikson/react-redux-links/blob/master/redux-tutorials.md). The latter section of that list is specifically for ["project-based" Redux tutorials](https://github.com/markerikson/react-redux-links/blob/master/redux-tutorials.md#project-based-tutorials), which are tutorials that try to build something meaningful-ish rather than just teach the basic concepts. To pick out three specific examples: - Teropa's ["Full Stack Redux Tutorial"](http://teropa.info/blog/2015/09/10/full-stack-redux-tutorial.html), which builds a client/server voting app using a TDD approach - Sophie DeBenedetto's 8-part [Building a Simple CRUD App with React and Redux](http://www.thegreatcodeadventure.com/building-a-simple-crud-app-with-react-redux-part-1/) series, which includes routing, AJAX calls, and the various CRUD aspects. Very well written, with some useful diagrams as well. - My own ["Practical Redux" tutorial series](http://blog.isquaredsoftware.com/series/practical-redux/) , which demonstrates a variety of useful React and Redux techniques through the context of a sample application. Hopefully those help!
That's possible. VSCode definitely warned me that the two TypeScript executables were different versions but it's possible that something else I did shortly following that fixed intellisense.
&gt; What is the `from` doing in JS? Travelled all the way from Python? :) you got it. they drew many inspirations from python, ruby, coffeescript, and so on when designing ES6. &gt; I would imagine this problem wouldn't occur with pure functions? [strict mode](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Strict_mode) has many differences. quite some modules would be affected
Could one still do hybrids via the AppStore?
&gt; A more paranoid version of myself would claim a conspiracy to malign hybrid apps. The realistic me figures they just don't give enough of a crap. We're talking about a company which forces you to buy overpriced proprietary hardware to compile mobile apps. In 2017. It's not really that irrealistic to think they purposefully ignore holes in apis used by hybrid apps.
&gt; And I don't think the IOS users will enjoy having a much inferior experience. Maybe this will finally convince Apple to improve their browser. Not if developers bends themselves and go native. 
Conceptually, I learned Redux by watching and reading up on Facebook's Flux Architecture before writing a single line of Redux. You have to understand unidirectional data to understand Redux within a React app. As for Redux's boilerplate itself. It sucks, but its so basic you can create your own abstractions if you want to. There is no _redux way_, which is against what some tweets or videos suggest. I've built 1,000+ components using React+Redux in several permutations with different team opinions.
Not necessarily. Native development, especially if you want to make use of native UX paradigms, is often cheaper just because a good maybe developer can move so much faster.
When you have to build for multiple platforms though, you're adding cost. Though you sometimes have to build separate native looking components, so there is some 2x overhead.
use the matching_item variable to get the values you want from the products and put it in item.foo
Yeah, I just wrote a pair of blog posts that go into detail on what Redux itself actually requires, the history and intent behind Redux, why common usage patterns exist, and some of the "variations" in how you _can_ use Redux: [The Tao of Redux, Part 1 - Implementation and Intent](http://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-1/) and [The Tao of Redux, Part 2 - Practice and Philosophy](http://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-2/). A couple of the points I emphasize in those posts are that Redux is absolutely a Flux derivative, and that you can add as much or as little abstraction as you want.
C++: will teach you about memory management without garbage collector and it's very close to C. You can use it to write node extensions. Besides, node is written in C++. Java: most used programming language, a lot of jobs, massively used in backend webdev. I prefer C++, but it comes to personal taste. I actually don't like them both, I prefer low cerimony languages like Python &amp; JavaScript.
So praise the lord that Apple did what it did.
I think you might be interested in Web Components specifically v1. Google developers has a nice writeup that contains similar examples to what you're trying to do.
You can tell VS Code which TypeScript version to use by setting `typescript.tsdk` in your `.vscode/settings.json` in your project folder.
Sorry there i sort of lost patience but not because of him, because its high time i get some vacation or rest. Did a nap now i feel clearer. Alright, i know all that and i have 3 projects using them. I guess my points was about decorators being stage 0 for so long and the little irritating things left and right about that very thing. Not that you can't, not that its super advance.. only that its stays 0 and does not move very fast causing slower adoption. 
Yes, although 'wieldedBy' is probably not something taken from your config, but is more of a game state? This way you keep your code and configuration separated. Your Weapon function (or class) contains all your weapon specific functionality and the JSON file your configuration for your set of weapons. Now, If you ever have to add a new weapon all you have to do is update your JSON file, without having to create a new build for your game. And maybe even load the JSON file from a server when perhaps you want to use a CMS in the future to manage your game assets.
Can confirm that it's the same for React-Native. Especially if you are using a lot of 3rd party integrations or advanced features, it is good to have someone on the team that knows the native parts of the platforms. This is largely due to the react-native integrations that are often poorly written wrappers around the existing native integrations that feel like they have been thrown together in a hurry to catch the react-native hype train. To be fair though, it's quite hard to write good react-native libs, since you need developers with a fairly broad skillset.
There's an [`invalid` event on inputs](https://developer.mozilla.org/en-US/docs/Web/Events/invalid) which you can cancel to prevent those error bubbles from showing up, but I don't think this is your real issue. I don't see a place where you actually prevent form submission when it's invalid (that's why `required` works for you — browser is doing that automatically for you). To prevent a form submission, you need to listen to `submit` event on the form itself instead of `click` event on submit button. Then you can cancel submission event if the form doesn't validate. [Here's an example jsBin](http://jsbin.com/tehedopihu/edit?js,console,output) — does it behave how you want it to behave? I've also extracted form validation into a separate function that returns `true` or `false` depending on whether form validates or not, just to make things slightly more readable.
One thing I haven't found a good solution for is when the URL param is a slug/permalink/vanity rather than the ID itself. Think app.com/some-post-title vs app.com/id_abc123. The slug may not be unique. 
the thing is, I understand Redux (I think so), what are reducers, pure functions, actions, one way data flow, but how to use this inside a react app, like the code, it doesn't make sense, like the examples just look anti-react
How about when using class or class function. When would you want to use one over the other?
What functionality does this library give over async await syntax in combination with Promises? Having functions return Promises instead of wrapping them in nsynjs-aware wrappers and then awaiting them has similar functionality does it not?
The funny thing here is that Apple does several hybrids internally so they can ship JavaScript changes to the server instead of full app builds. The JS is mostly for data massaging into preconfigured templates but works well. The first public insight into this is TVML for the TV Store. It's a JSCore bridge to the Obj-c runtime. 
Yes. You should be able to look at a variable (without any context) and know what it "is".
Yup, was doing a quick project that revolved around `getUserMedia`. Supported in Chrome, FF, IE Edge, Android Chrome. Not supported in desktop Safari, mobile Safari, and Opera.
At the last chrome dev summit, that was almost entirely about pwa, Apple devs were not present and a representative said that it wasn't on their list :( 
A whole tutorial around building a [SoundCloud application in React and Redux](https://www.robinwieruch.de/the-soundcloud-client-in-react-redux/). But you have to make sure to register your SoundCloud API Key in the beginning, because SC changed their API Key registration. It can take a few days.
In general, if you're working in an environment where ES6 syntax is acceptable (babel, evergreen browsers, node 6+, etc.), prefer to use the `class` syntax. Otherwise, use the legacy syntax.
I'd say the renderer that does web capable apps is the new IE and iOS Safari comes second. I hate it that when pinning an app to the homescreen it can look differently and fail a certain amount of features that are working fine in Safari. For example: SVG spritemaps. Simply doesn't work when opening with the web capable metatag active.
&gt; Why not use a fuzz testing algorithm and an ANN design algorithm like backprop ES/HyperNEAT? Because I haven't thought of it :) Gonna check out lychee.js, thanks!
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [reactjs/redux/.../**index.html** (master → c9ad6a4)](https://github.com/reactjs/redux/blob/c9ad6a40fe501919d359b910ea7c7f34532e11d9/examples/counter-vanilla/index.html) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dhzz9l5.)^.
touch-action will reduce the 350ms delay for websites viewed through Safari but will not if the application is 'added to homescreen'. There is no reason why features available on iOS Safari should not also be available for a homescreen app.
React Native is not hybrid.
Yeah and when you go look for why or solutions to fix that, you are often not getting the search results you look for. Still looking for some good sources on that too.
That's infuriating, I wouldn't mind if Apple didn't force users to use their Safari JS engine. Even Chrome on iOS is just a reskinned (and older!) version of Safari
* The term low level language typically refers to machine code like COBOL or Fortran. Java and C++​ are languages that require compilation into byte code. There's a difference. * Java can run on any environment thanks to the JVM. Thats a big deal esp. if you compare it with something like C#. * Systems language doesn't make any sense. * JavaScript has similar memory management to Java. It also uses garbage collection. * Words like superior, advanced, useful etc. are completely arbitrary and can't be quantified.
thank you
Great list but - who's got the time to watch all that stuff??!? Oh yeah, I get it - student. Sigh.
A native app that runs in JS and sends commands to native code via a JS-Native bridge and has HTML like declarative layouts...sure seems like a hybrid app to me. Where does the line for Hybrid app begin and end? You could argue that Cordova, etc are also all native apps, and technically you'd be correct (the best kind of correct). I am currently building a RN app and everything from the API all the way to but not including the views will run on the web in ReactJS. Edit: Did everyone miss this part where the app is portable to the web and all you have to do is replace the rendering layer? That means all the data retrieval, data storage, and core business logic of your application for a web client would be the exact same code in a shared library.
Looks like a great start! Just a few comments other than the variable naming. In ES6 syntax the variables you aren't redefining should be `const` not `let`. In for loops `i` is the normal variable for the first loop and `j` for an inner loop. You're of course entitled to do anything you want. When you take input from a user on a form you usually want to use `.trim()` to get rid of any leading or trailing spaces. You're not really using the API in the most effective way. You can search a pokemon like this `api/v2/pokemon/?name=`. But you did a good job searching through the results. It might be better to put a callback on your `cl()` function and return either nothing found or an object containing the sprite url and the text you want to display and then use that in your callback. Just my 2 cents. Really good job. Also it's `I know of` not off. :)
Also a web dev who runs linux, you just summarized my experiences with apple perfectly. 
Ultimately it comes down to needing to be able to debug and fix issues that may originate in the native modules themselves. You also need to be able to verify that the native module has proper error handling and isn't going to shit the bed when you put your app in production. That means verifying it has tests and is sensibly coded, covers edge cases etc. There are also cases where the library or module gets stale, or doesn't keep up with current versions. That usually means forking and taking over maintenance yourself. There are even disagreements with the maintainer about supported features which might cause you to fork. Mobile is hard, and will likely continue to be hard for some time. Hybrid frameworks can certainly decrease the initial investment, but they shouldn't be viewed as some magic easy button to catapult you into the mobile world with nothing but web dev experience. There is still a steep learning curve. It is totally worth the challenge though!
Sorry, I don't agree. Hybrid means that it combines elements of native and web applications and that's exactly what RN does. Facebook didn't want it labeled as a hybrid app because then everyone would assume the performance is as bad as other hybrid approaches. Is it a Hybrid app built on the same architecture as Cordova apps? No, it's just a different kind of hybrid app. If it didn't have any web tech in it I would see your point. We'll just have to agree to disagree.
Hi /u/TraxusInteractive, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Awesome! I work on the TypeScript team and I'm glad to hear you had a positive experience working with it. For the record, you can also get a slightly better error reporting experience on the command line with the `--pretty` flag. It's a feature I got to work on that I find not a ton of people know about. :)
I agree... you're well above entry level. Ahead of me in several areas, and I've been doing this since 1999 :O. I suspect either your resume is missing something, or not communicating your ability well enough, or recruiters are putting you forward for the wrong sort of role. How many agents / agencies / recruiters have you met face to face? 
Also WKWebView is still riddled with bugs. https://bugs.webkit.org/buglist.cgi?quicksearch=wkwebview
The App Store on iOS used to be a hybrid (not sure about now). Apple Music on desktop iTunes [is made with Ember.js](http://builtwithember.io/featured/2015/07/04/apple-music/).
&gt; That seems incredibly useful. I'm curious why that setting (and a couple other flags honestly) aren't enabled by default? Well, we can't really break tools that depend on TypeScript's console output. Originally what `--pretty` did was check whether the output device was a pseudoterminal (i.e. whether it could understand control characters that could affect the color of text). This would've worked for most tools, however, after experimenting with Cygwin, I found that there was some inconsistency between what could reliably be identified as a TTY, and decided to back off of the idea. I kind of wish I hadn't. Down the road, we could potentially have a default which does the autodetection. We're trying to move in the direction of easier-to-get better defaults with things like the `--strict` flag in TS 2.3. &gt; I just turned it on and it's working with tsc, though I still need to figure out why it's not working with awesome-typescript-loader. Ah, that's actually expected. The pretty error printer was only available internally. Alex from the Angular team actually [sent us a PR 2 weeks ago](https://github.com/Microsoft/TypeScript/pull/15808) to make it public so that tools like `awesome-typescript-loader` will be able to use it in TS 2.4. Sorry for the wall of text. The short story is things will continue improving and getting better.
This is a beautiful thread. Guidance, cooperation and learning. I'm proud of you too OP. To be honest, that is pretty decent code for having no help, and you've gotten solid advice here. If you keep this up, then I'm sure you'll go far.
I think there is a better solution to this so I am deleting this thread. Sorry if I wasted anyone's time.
This is the height of irony. Apple should do something to make us JS devs happy.
Is it possible to set this flag in tsconfig instead of on the command line?
I see what oyu are saying but where I am confused is that if we say if (e.target.parentElement.className == "key" || e.target.className === "key") { const key = e.target; And I click the &lt;kbd&gt; element inside the .key div, then &lt;kbd&gt; is the event target. So when I put this logical OR operator in my condition it still doesn't work. I think I must be missing something. I really appreciate your help EDIT: Not sure if this is the most elegant solution, but I used and if...else statement and your parentElement idea background.addEventListener('click', (e) =&gt; { if (e.target.className === "key") { const key = e.target; const keyNum = key.getAttribute('data-key'); const sound = document.querySelectorAll('audio'); for ( let i=0; i &lt; sound.length; i++ ) { let curSound = sound[i]; if ( curSound.getAttribute('data-key') === keyNum ) { curSound.play(); key.classList.add('playing'); background.classList.add('bg-playing'); } } } else if (e.target.parentElement.className == "key") { const key = e.target.parentElement; const keyNum = key.getAttribute('data-key'); const sound = document.querySelectorAll('audio'); for ( let i=0; i &lt; sound.length; i++ ) { let curSound = sound[i]; if ( curSound.getAttribute('data-key') === keyNum ) { curSound.play(); key.classList.add('playing'); background.classList.add('bg-playing'); } } } });
Any specific issues you can point to? - (I am aware of the lack of autofocus attribute support) but was curious as to any other issues.
The article doesn't say that. Indeed, in a comment, the author says: &gt; [It definitely takes Android longer to boot my app, but once it is open the performance feels very similar. iOS does seem to handle some expensive animations slightly better.](https://medium.com/@samdelgado/it-definitely-takes-android-longer-to-boot-my-app-but-once-it-is-open-the-performance-feels-very-9b940b93f64) IE: His app is slightly more responsive on iOS.
What I am saying is static lib = require('file') might be more readable inside JS that import lib from 'file' for exactly the same thing. I don't see how section 3 is motivating the need to remove the equality and replace it with the JS-foreign word `from`. 
Exactly, for a large file, it wouldn't be great. But not an issue for the 64 LOC, with more than half of them being comments. It is one of those "no one size fits them all". ;) 
You'll want to create a click [`MouseEvent`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent) with appropriate coordinates and dispatch it on the element at those coordinates: function clickAt(x, y) { const element = document.elementFromPoint(x, y); const event = new MouseEvent('click', { clientX: x, clientY: y }); element.dispatchEvent(event); } ^(You can [see code above in action in this jsBin][1]) [1]: http://jsbin.com/vejurojeho/edit?js,output
Possibly I didn't say it well. My use case is very basic and generic. I want from the import acting as copy-paste of my code from the file. In that sense it is static. If I understand correctly, this is what the bundlers like browserfiy are doing, without running the actual code. 
This is closer to React Storybook, but not ionic.
Good point about the shorthand notation. That makes the configuration statement generic and allows to keep the imports clean together. But I still don't like the number of JS-foreign tokens here: import { stream as createStream, render as mithrilRender } from 'mithril'; As far I can see, all these "as" and "from" only appear in the import syntax and nowhere else, so we are adding such generic looking keywords for single use cases. That can easily bloat the language. Especially, when seemingly a one single additional keyword would have been just as fit for the job: static { stream: createStream, render: createRender } = require('mithril') Here the `const` is replaced by the new keyword `static`, with the rest of the syntax re-used, not created.
Sorry you're right. What I meant to say is write a PHP app with almost no JS which would mean you're app wouldn't operate offline.
[removed]
And even the official Todo App Redux example is not "fully Redux": https://github.com/reactjs/redux/issues/2407
Yeah it just doesn't seem to update the props in time 
url1,url2,url3 should be const.Edit*Would it still work. Since const url = "url" + x. If not I can't think of what variables should be const instead of let. And something like val = val.trim() I know just typed api/v2/pokemon/?name=blastoise and got the first page. So I don't see how that will help. And what would I do with that object? If I will make version two of this. I would first get rid of the for loop and use .filter(). And something like let isItAVowelOrNot = (str.charAt(0) === a ll str.charAt(0) === "u" ll str.charAt(0) === "e" ll str.charAt(0) === "o" ll str.charAt(0) === "i") ? "an" : "a" 
CI?
Doing it server-side won’t work without a server :o).
I guess it's more like a 'can be wielded by' in his example. So yes..
Very interesting. I literally just spent the past hour adding Cloudinary to my project after biting the bullet and using their jQuery plugin. I might have to spend some time writing a plugin to get Uppy working with Cloudinary...
It's true right now for me in the latest version of Chrome and Node.js. Chrome 58.0.3029.110 (64-bit) =&gt; V8 5.8.283.38 Node.js v7.10.0 =&gt; V8 5.5.372.43 Not sure if this is expected or if it's some sort of optimisation bug in V8 that's hurting performance.
Yea, you've to wait for M59 / V8 5.9. That's where they are shipping the new Ignition + TurboFan execution pipeline.
I've been quite impressed with Auth0 for this purpose. Quite well documented and it's very easy to integrate with. 
Ive used NativeScript with Angular, the team is making very impressive progress very fast. 
Continuous Integration. Lets you have a build automatically tested, packed and deployed after every commit/merge to a repository. Gitlab Ci is a good place to check out how that works , for free. Maybe don't put anything production critical on there though. Stability is an issue. It is grating going from my "commit -&gt; push -&gt; watch the deployments update" workflow . To a , "Switch to a Mac -&gt; click build -&gt; fiddle -&gt; upload a package manually -&gt; wait for approval" workflow. 
Looks Promise(ing).
Awesome. Is it an option with the same name and a boolean value?
React Native does native code for uI in iOS. I've worked with iOS for 5 years and even though I know it well, react native is a great alternative. I don't think your points are very true. Some reasons to choose RN or iOS native are team experience, whether you want android app, whether you will be doing things in the app that don't have APIs in RN right now... But overall I can make most apps in RN as fast or faster than iOS and have them feel identical.
This is looking better and better. The highlight for me is the integrated Lighthouse.
Java is welcome too!
You gotta pass the ing as a parameter promise(ing) 
Well those aren't "JS Foreign" tokens, they are javascript. Ironically enough the word `require` is the only js-foreign thing you have there! Like it or not, they are part of the language now.
Yes you should still use `const` if you're declaring a variable even if that variable is using other variables to be built. So for val I would do something like: `const val = document.getElementById("user-input").value.trim();` Notice that you can just tack `.trim()` on the end of `.value` and save yourself a line of code. Even `url` doesn't really get redefined since you're using recursion. So that would be appropriate for `const` as well. I was a little wrong about the API. I got rate limited when i played with it so when I read the documentation I misinterpreted it. What i should have said is you can search a specific pokemon at `api/v2/pokemon/` with the name on the end. So it would look like `api/v2/pokemon/squirtle`, which should give you a single call where you can get all the info you want. As for the object what I was saying is that you can build a callback in your `cl()` function so it would look something like this `cl(x, callback)`. Then you could build on object with your results something like: `pokemon = { name: val, types: str, sprite: whatever}` Then after you've collected all this information you `return` it to the callback like: `return callback(pokemon)` Then you would actually use the spot where you called `cl()` to do the work of putting it on the page like: `cl(x, function(pokeResult) { //do something with the result to display it to the user });` This sort of pattern is how you create modular asynchronous code and you'll be happier down the line. The ternary you posted above is too long and not very readable. You'll want to look into regular expressions (regex) for that type of thing, it's a life saver. I hope this is helpful. 
Yes, it was. It will have to wait a week or two for me to experiment with this since I have finals now. I used programming yesterday as a way to procrastinate.
Ruined how?
Do you have examples of your work? 
Some people don't like the new filtering system. It doesn't allow multi-select for instance since you now select a pre-defined "level" and that tries to handle the filtering modes as best it can based on generally known constructs that align with what other logging systems do. That's the only major complaint I've heard of. However, with any change people will be upset. At this point if the new functionality were reverted, there would be complaints wanting it back.
That sounds like a good first step, thanks.
This is some of it from a little time ago, you can get a feel for my style. But really, I can make any type of graphic that would best suit individual projects. https://imgur.com/a/qsGCN
I've only met one recruiter face to face which was in an off-day meetup just to try and find out what I'm looking for and what I know. He had a role in mind for me, but he disappeared completely from the face of the earth. It's disheartening that recruiters get my hopes up and then go silent without so much as a 'sorry, you're not qualified'. I recently had a telephone interview with a company via a different recruiter, and the recruiter followed up with me for quite a long time to get that far - but he's the only one that's done so.
Hey this is great! Thank you - it behaves exactly how i want it to behave. 
@i_am_smurfing I havejust one last question. Now when i submit the form - i can't see the form anymore. is there a way to show the form, but also show a success message so that users now that the submission worked?
&gt; Working off of a large master stylesheet and adhering to it used to consume so much of my time. Maybe you just need to learn separation of concerns in CSS? At least in the "split CSS in modules and use a toolset to concatenate them" sense? &gt; Also, I don't understand the complaints about JSX being similar to early PHP, which is BS. Which you still haven't explained how it's BS, but okay. &gt; Maybe a lot of people are using React as the only hammer in their toolkit when it's not suitable? There's a number of ways to use CSS with React, it doesn't have to be so dogmatic. But CSS-in-JS is totes the best tool that shall be always used! No dogmatism here at all. &gt; Options are a good thing. Sure, and with CSS we already have a bunch of good options. Sass, Less, PostCSS, to name a few. Why are you trying to stick everything in JS?
Some people will tell you its all about *who you know*. Keep in mind that while there is certainly amazing opportunity value in that it is ultimately shallow. Knowing the correct people, for example, won't transform you into a strong performer. In the long run it is your understanding of the subject matter and confidence that will carry you forward. If jobs in this field are rare in your geography you might have to relocate to a different job market. Take my situation as an example. I live in a very large urban area. The side of the urban area that I live is among the fastest growing areas in the US. The value of my house has nearly doubled in the 8 years I have lived here. Facebook, Amazon, and a couple of other big names have put up large offices here near where I live. Despite this the job market has not caught up with the growth just yet. Everybody still commutes across town to the other side of the urban area (30-60 mile commutes). One of the towns that everybody commutes to was recently named the best city in the US to start your career as the jobs and demand for technology is insane crazy.
It's good stuff. I like it. I see that the post is removed. Is the offer closed too? 
Oh man, that is brilliant! Thank you. That is way cleaner. I need to learn to think more like that. 
How do I download Chrome 60?
I didn't remove it, ~~I guess it was a mod~~ ? Apparently not a mod ... I still see it not deleted when I am logged in to my account, weird.
have you tried e.preventDefault() ? [e.preventDefault()](https://developer.mozilla.org/en/docs/Web/API/Event/preventDefault)
this is great, thanks for sharing!
what about form onsubmit ? example : &lt;form onsubmit="myFunction()"&gt; myFunction should have preventDefault, and should run only if condition is cool (captcha)
I have tried using onsubmit with prevent default and returning false, but the form action still executes.
To clarify a bit, TC39 (the JS spec people) do not deal in files. .js can mean many things today where the only standard associated with the file name is through IANA but not used by web browsers or node for MIME association. The tools using .js all have historically fallen under the Script parser (or associated grammar productions) and evaluation mode of JS. The Module parser and evaluation mode of JS present backwards incompatible changes. This is true to a large extent even with transpilers which often implement a non-spec 3rd parser an evaluation mode somewhere in the middle. I would be curious what the statement that .js is standards based is related to and thinking long term why .mjs is a problem if it is just a tooling upgrade vs backwards compat problems.
That's a pretty good course. I'd recommend at least taking a look at MobX, too. It is a joy to work with. On our huge ERP system at work, we use Redux for the overall app state, and MobX optionally on individual component features. It's an awesome combo.
Many people didn't understand it was multi-selectable in the first place. The new UX tries to make the selections simpler and handled for you. It's trying to make the interface more clear to the majority of users.
You don't need a Promise for this either, any "container" with `.map` (or equivalent method, e.g. `.then`) will work: [foo].map(funcC).map(funcB).map(funcA);
So they have dropped their native DOM-tree diffing approach now?
Here's a general suggestion for JavaScript. Using "const" isn't going to help performance or memory in any noticeable way for the small browser things. You are perfectly safe to make every variable a "var".
My bad, it is a lot. &lt;form action="test.php" method="POST"&gt; &lt;input type="submit"&gt; &lt;/form&gt;
Ok thanks, that is good to know!
If the first action result determines the second action's arguments, then don't use props for this. This should be handled solely within a redux action (combining other actions). Also never do initial AJAX calls within a constructor. Use `componentDidMount` and not any other lifecycle.
No, why do you think that? [1].map(x =&gt; x + 1) //=&gt; [2] .map(x =&gt; x * 2) //=&gt; [4] .map(x =&gt; console.log(x)) //=&gt; [undefined] (`4` in console) The whole idea of `.map` is to "lift" regular functions so they can work on some container structure.
I feel your pain!! Please somehow let us know if you decide to do this. Also feel free to post in the [google ticket](https://groups.google.com/forum/?utm_medium=email&amp;utm_source=footer#!msg/google-chrome-developer-tools/kH3FiDLlsFg/ojrqo2p2AQAJ) with your use case!! This would be helpful to getting the functionality back. 
Hi daBarron 👋. Glad you like Auth0! We actually wrote an article explaining how easy it is to migrate your user database from Stormpath thanks to our database migration feature: https://auth0.com/blog/how-to-migrate-your-existing-stormpath-users-to-auth0/ Let me know if I can help you with anything else! Ramiro Nuñez Dosio, Social Media Manager at Auth0.
We're only handling I/O on our Node reverse-proxy and off-loading the expensive tasks &amp; heavy computer logic onto your application servers. This library was built with great consideration for maximizing the throughput of our reverse-proxy &amp; off-loading any tasks other than a reverse-proxy's main goal: distributing requests. Node is very performant for concurrent I/O. While the listener is single-threaded, the I/O operations all land in a thread pool. To your comment about NGINX, we're running metric comparisons between it and should have those out in the near future.
This might be an interesting read for you https://medium.com/@dtinth/what-is-a-functor-dcf510b098b6
&gt; progressive rendering isn't a priority for every development team for example Users don't care about your team's priorities. If the perceived loading time sucks, they will less frequently interact with your site or even abandon it entirely.
Straight from [Lighthouse](https://developers.google.com/web/tools/lighthouse/): &gt; You can run Lighthouse as a Chrome Extension, **from the command line**, or as a Node module.
All I want is the ability to highlight text within dev tools without wanting to rip my eyes out.
Yeah, technically yes. I didn't find better way yet. However, it's just executing a script. Besides, we can achieve performance benefits with asynchronous checks and caching. Personally, I keep thinking about better solution.
What exactly are those "artificial limitations"? You can open a PWA in Safari and put an icon to it on your home screen. If your goal is to have a PWA, then you don't need a certificate, you don't need Xcode or a Mac, you don't need anything. It's the kind of app iPhone supported since its original release, as *I just said above*, unlike native apps, which iPhone supported later on.
Thanks Android fans for questioning repeatedly why Mozilla needed to make Firefox OS with its open APIs. 
I was about to say that I thought Promises could actually execute synchronously if they're resolved immediately, but then I decided to [try it](http://jsbin.com/dilonuxuvo/edit?js,console)! So, an important take-away might be that promises won't help you calculate a value synchronously - they should be used for effects, or if you don't mind your whole computation becoming an async chain.
 return true;
* I agree, but I said "lower" level =&gt; e.g. c++ is closer to machine code than a scripting language is (not that c++ is machine code or assembly/etc). * Agreed. * Agreed, Java uses garbage collection, but JavaScript literally has no control over memory management short of the methods and processes we write down to the native code. Java can customize heap size, garbage collection types, etc. * I would disagree here.
No problem. Thanks for your work modding the sub. Will resubmit Saturday :)
Limitations like dropping back to the old Javascript VM, losing support for delay-free taps, broken SVG features, and various other inconsistencies that only exist when added to homescreen (see other comments on this post.) Also no interest from Apple in implementing ServiceWorker, orientation, camera access and other features. As a result, a lot of things that could be PWAs end up having a pointless Cordova wrapper with plugins to patch in missing/buggy features.
When will it be released? My current version is 58.something. Any how excited for the updates. 
Lost me at "Should I even test" Why write an article about comparing testing frameworks if you don't want to do it in the first place. Ask your colleagues to write the article. P.S. Beyond peace of mind there are some advantages in the structure you produce. If it's hard to test, that can be a sign of something greater. This is sure to get some hate so bring it on....I can take it.
Word, sounds good.
So it's a module that doesn't work with modern versions of Node....
thank mr skeltal
I don't put up with users like that, especially given the shit sandwich that is web development. premature optimizations are the root of all evil. Note you ASSUMED it wouldn't be performant, that is wrong, just an oversimplification (and why "testing" for it is moronic).
Try using the dark theme. Settings -&gt; Appearance -&gt; Theme
Try using &lt;form onsubmit="return myFunction()"&gt;
Good idea. The function doesn't run then. I think it's because that functon is not in the global instance 
You listed desired behavior, but not current behavior. Is the function being called? Have you verified its called in the right context? Are you comparing the state of the cart before and after? Are there differences? These are the things for here. Also, it would be awesome if your code was in Repl, or jsFiddle, or really anything else lol. I do want to help though!
https://jsfiddle.net/wgt52mc3/ / https://jsfiddle.net/wgt52mc3/2/ Something is undefined that wasn't in my file...
For the bonus question it is const { username, password } = formProps; return { username: !username &amp;&amp; "Username required", password: !password &amp;&amp; "Password required" }; This isn't exactly what you had above, it would return { password: false, username: false } but it will work fine if I'm correct in assuming that somewhere you have this line if (!error.username &amp;&amp; !error.password) .... For the other question, it is technically ok to mutate a temp object, at least according to Dan Abramov's reduxImmutableStateInvariant package, but once you get into the immutable workflow it just seems weird.
the post was recently updated to refer to the fork of the module that does work well with node ... and also new information on using the --inspect mode to use the chrome debugger. 
Make a network request to fetch the JSON and handle the response. Something like [axios](https://github.com/mzabriskie/axios): axios.get("/data.json") .then(response =&gt; { this.setState({ data: response.data }); }) .catch(err =&gt; { // Do something! });
If you're planning on using Redux with React, you will definitely want tests around your actions and reducers. It makes writing predictable state changes much easier. As for actual UI testing, I'm not sure I've got much skin in that game. 
Preach
Poor wording on my part. It's weird insofar as it's a different tack from the predominant approaches to programming in JS. When I first was introduced to FP in JS I found it to be extremely foreign.
no mention of snapshot tests or coverage reports that you get out of the box with jest. or the fact that mocha doesn't require a dom.. 
Savage.
What's so "weird and outlandish" about FP?
As mentioned in another comment, the key to immutable data updates is that you don't ever actually modify the _original_ data. However, it's okay to make copies and mutate the copies as you build up the return value. So, your initial example that makes use of `splice()` on a copied array is entirely fine. (Source: Redux maintainer, and author of the [Structuring Reducers - Immutable Update Patterns](http://redux.js.org/docs/recipes/reducers/ImmutableUpdatePatterns.html) section of the Redux docs.)
Cheers, you must be getting a bit of extra business as well as a few other authentication APIs. Seems like a crazy move from Okta/Stormpath to announce they are shutting down Stormpath without having compatible libraries/plans/examples ready to go, thats what im finding for nodejs anyway. At least they have announced that some of the libraries won't be ready by August so we can make other plans.
For me it isn't should I or should I not test, it's what do I test and how? I've haven't had it click for me. Sure, I run through things when they're done. Then I don't, generally, touch it again. 
Awesome! Very familiar screen. =)
I'd find a new team (or company.) That sounds horrific.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [d3/d3-request/.../**README.md#json** (master → 04e4363)](https://github.com/d3/d3-request/blob/04e4363a2a8de76334ec4706c44b7840c382745e/README.md#json) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply di29ksz.)^.
JS is multi paradigm language, it can do procedural, OO and functional. Functional programming is about immutable data and treating functions as data. Composing (gluing) functions, partial application (.bind, lambdas), error handling through monads (promise-like objects) rather than try/catch blocks. It's super easy to write unit tests for such code.
Why not `fetch`? https://github.com/whatwg/fetch
Non-Mobile link: https://en.wikipedia.org/wiki/Functional_programming *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^72267
This is a good guide to get started in Functional Programming
nope. it's used for debugging cli apps, it opens up an additional port for you to connect your browser to. But it only works in node 6+
If you're really being serious then what you might be wondering is if JS is a pure functional language. JS isn't. In fact lot of functional languages aren't except few like Haskell. Like , u/lajw explained, JS has lot of paradigm that one can follow and impure functional paradigm is one of them. 
Or even `this.setState({data: await fetch("URL")})` Surround in try/catch for error handling.
https://www.reddit.com/r/javascript/comments/5e3lcc/professor_frisbys_mostly_adequate_guide_to/
https://www.reddit.com/r/javascript/comments/5hfq6n/100_minutes_of_free_functional_programming/
Any reason to pick the rxjs over other reactive libraries that are often easier to use?
&gt; JS does not have functional programming What is the meaning of this statement?
Yes, I was interested in this. That JS is not functional programming language but it can be emulated/used as paradigm for writing code that looks like true functional programming, but it's not really. Am I right?
Tutorial author here. Thanks everyone that checked this out and very happy to answer any questions!
This seems reasonable if you're not using JS native modules or CommonJS modules (which might be worth looking into if you're unfamiliar with that)
I'm not either! I'll check some out. 
Functional invariants are not enforced by either the compiler or the runtime, but you can program functionally with some discipline. Libraries like http://ramdajs.com/ or immutable.js make it easier to embrace the functional paradigm.
I still don't understand why you say so. JS has functions as first class citizens making FP a perfect choice.
It's cannot be a functional language as it can be real functional langauge, take Prolog language and code bellow as example parent(john,paul). /* paul is john's parent */ parent(paul,tom). /* tom is paul's parent */ parent(tom,mary). /* mary is tom's parent */ ancestor(X,Y):- parent(X,Y). /* someone is your ancestor if there are your parent */ And after you declare aspects, you can ask you VM to find relative question ?- ancestor(john,tom). If you don't like this example, take a look at factorial or something else, Functional language give us a cool exp when you write some asserts (aspects) and ask VM, please calculate/find me an answer. You don't write an algorithm. In functional you write all data/asserts and ask VM about it About JS: Immutable data is an Immutable data, you can write it on PHP/JS and etc (it's not making JS functional language) Bind is a method, nothing else (just greating new function) Lambdas is a pretty simple Anonymous functions Procedures == functions in any language. Functions came out from Procedural programming, because it's a main idea inside Procedural programming. Every time, when you take an idea from functional language, you cannot say that it's functional programming, it's an idea.
I guess I'm saying it because functions that we call functions are basically are just a procedures, but not something from functional programming, making "functional programming" kinda new idea that is slightly copied from real functional programming paradigm. Like we talk classes, but we does not have classes in js. We have some kind of helpers with objects
You mean basically we can mimic functional programming in JS, yes? Like we imitate classes right now with sugar But it is not real functional programming, just imitation, yes?
That's plausible; many javascript frontends are thin presentation wrappers over backend behavior, so the backend is where the core business logic is. If you gave a few examples of projects you've worked on, I could mention the kinds of frontend business logic I might expect to find on them, if any.
That is a good point, but I consider it an enhancement of the FP rather than obstacle :) And here is a use case: https://github.com/dmitriz/un/blob/master/index.js#L19-L30 The last line renders the vnode stream by calling the `.map` method the FP style. The render function is a "procedure" with the rendering side-effect. However it is used exactly as a pure function here would be used to map the stream over. So you can have the best from both worlds - terse FP style and the power of procedures :) 
Only benefit is readability. Second method splits up the code a bit, but even that style is a little outdated. If I'm building a fairly large static(ish) site these days, I use a method called DOM-based execution which allows you to split up and organise code even more (especially if you mix it with class syntax)
and what makes the style outdated? here's why i ask - c, c++, java .... there's pretty much one way to structure the code the whole concept of an outdated syntax is kinda foreign to me 
Nodeschool bacon love workshop Will be a nice introduction to functional reactive. Try it out
The view will update if I refresh and I can confirm that the object in local storage is changing... I will ditch jquery but am trying to prove concept first. 
 Uncaught TypeError: now.getHours(...).toString(...).padStart is not a function at render (pen.js:68:41) at pen.js:99:1
Can someone explain the npm-shrinkwap.json vs package-lock.json thing? Why are there two? Do we need both?
I just wanna say I love your book. I rem back when I was starting React, I was super confused regarding lifecycle methods, even with all the diagrams. Your book finally cleared that up for me!
Would also like to know..
Great question, was wondering that myself Found this fresh documentation: https://github.com/npm/npm/blob/latest/doc/files/package-lock.json.md &gt; One key detail about package-lock.json is that it cannot be published, and it will be ignored if found in any place other than the toplevel package. It shares a format with npm-shrinkwrap.json(5), which is essentially the same file, but allows publication. This is not recommended unless deploying a CLI tool or otherwise using the publication process for producing production packages. &gt;If both package-lock.json and npm-shrinkwrap.json are present in the root of a package, package-lock.json will be completely ignored. Seems to be 2 different names for the same file, shrinkwrap is publishable, package-lock is not I wonder why they didn't repurpose shrinkwrap and add a `allow-publication` boolean field instead of creating a new file
It's been only published under `@next` while npm by default installs `@latest`.
&gt; premature optimizations are the root of all evil. We have tools for this. You measure, optimize, and check. There is nothing premature about this. &gt; Note you ASSUMED it wouldn't be performant Client side rendering w/o doing the initial view on the server side? Yea, that's slow.
I haven't taken a look with more attention to Ramda yet. What would you say is its main purpose? Am I right to assume that it tries to make JS more 'Haskellish'? I'm pretty sure it offers some handy helpers, even though I cannot see why R.map(x =&gt; x * x, [1, 2, 3, 4]) would be better than [1, 2, 3, 4].map(x =&gt; x * x). Have you tried it? If so, what are your thoughts on it? And what would be a good use case? I've read in some of their Github issues that they have been drastically changing the API throughout the releases, which might make its adoption more difficult.
I am sorry to say this but I used a few experimental JS stuff in there, like the padStart function. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padStart
You can definitely do that, but I think what you normally do is easier to read.
Uh, excuse me, but npm doesn't have `npm create`. Dealbreaker. 
[Relevant XKCD](https://xkcd.com/1270/) &gt; Functional programming combines the flexibility and power of abstract mathematics with the intuitive clarity of abstract mathematics. I've never met anyone who finds the functional style innately understandable. Nobody looks at a transducer and thinks "Oh, yeah, that make perfect sense" the first time. There's value and merit to FP, obviously, but you need to sell someone on the benefits of FP in a way that you don't need to with imperative programming.
It isn't slow, it just isn't fake. You have no idea what you are talking about, and probably would do well in a no-questions asked bureaucracy.
Sarcasm?
Lol very poorly received sarcasm, apparently. I can't believe they put resources into `yarn create`. So ridiculous. 
lul these patch notes
Doesn't really look like it, although there's no word about parallel installations which I seem to recall was the main reason Yarn was fast? It's a shame that there's no mention of Yarn here. Let's wait and see what the Yarn maintainers will have to say about this.
Yes, your program is updating local storage. Your Vue instance will initialize data (once) on load, which is why it updates when you refresh... Data does not update reactively, however, which is why the watch never calls the handler. After the initial load, I suggest using Vue to keep track of the changing data on the client, then save Vue's data to local storage when there is a change. Making updates directly to local storage, then trying to get that to the Vue instance is kind of backwards. var vue = new Vue({ el: '#cart', data: { cart: null }, mounted: function () { this.cart = // local storage fetch }, methods: { addCartItem: function () { // click handler that modifies this.cart data } }, watch: { cart: function () { // post this.cart data to local storage } } });
to install: `npm install npm@5 -g`
i think we are seeing these features __because__ yarn have show it's good/what people want (at least on an opt in basis). let yarn be the "playground" for experimental features/ideas, like coffee/typescript influenced es6 
Despite the conciseness of pointfree programming and the practice for a language like haskell, I usually condone the scala-like style presented here for doing FP in JS: https://egghead.io/courses/professor-frisby-introduces-composable-functional-javascript
Thank you! I tried npm@latest and got nowhere.
What does it matter? use yarn if you like the yarn interface. use npm if you like the npm interface. It's not like Yarn can't exist if NPM gets upgraded.
And even if it is, is yarn so slow and the improvement so profound that it's worth migrating? I doubt it.
You sir / ma'am deserve a beer. Do you have a donate page? Also, It works great but there are some ugly console errors. vue.js:529 TypeError: Cannot read property 'items' of null at Proxy.eval (eval at makeFunction (vue.js:9323), &lt;anonymous&gt;:2:147) at Vue$3.Vue._render (vue.js:3901) at Vue$3.updateComponent (vue.js:2443) at Watcher.get (vue.js:2780) at new Watcher (vue.js:2763) at mountComponent (vue.js:2447) at Vue$3.$mount (vue.js:7564) at Vue$3.$mount (vue.js:9663) at z-wave-siren-sensor:2575 ( vue.$mount('#cart') ) var vue = new Vue({ //el: '#cart', data: { cart: null }, mounted: function() { var url = "http://shop.domeha.com/api/v1/products.json"; $.get(url , function() { console.log('Running...') }) .fail(function(err){ console.log(err) }) &lt;div class="shopify-buy__cart__header"&gt; &lt;h2 class="shopify-buy__cart__title"&gt;Cart&lt;/h2&gt; &lt;button class="shopify-buy__btn--close"&gt; &lt;span aria-role="hidden" id="x-menu"&gt;×&lt;/span&gt; &lt;/button&gt; &lt;/div&gt; &lt;div id="cart" class="shopify-buy__cart-scroll"&gt; &lt;div class="shopify-buy__cart-items"&gt; &lt;div class="shopify-buy__cart-item" v-for="item in cart.items"&gt; &lt;div v-bind:style="{ backgroundImage: 'url(' + item.images + ')' }" class="shopify-buy__cart-item__image" alt="Product" style="background-repeat:no-repeat;background-size: contain;"&gt;&lt;/div&gt; &lt;span class="shopify-buy__cart-item__title"&gt;{{ item.name }}&lt;/span&gt; &lt;span class="shopify-buy__cart-item__price"&gt;{{ item.price }}&lt;/span&gt; &lt;div class="shopify-buy__quantity-container"&gt; &lt;button class="shopify-buy__btn--seamless shopify-buy__quantity-decrement" type="button"&gt; &lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"&gt;&lt;path d="M4 7h8v2H4z"&gt;&lt;/path&gt;&lt;/svg&gt; &lt;/button&gt; &lt;input class="shopify-buy__quantity shopify-buy__cart-item__quantity-input" type="number" min="0" aria-label="Quantity" v-bind:value="item.quantity" style="height: 30px; border:solid 1px #d3dbe2 !important;padding-left:13px;" /&gt; &lt;button class="shopify-buy__btn--seamless shopify-buy__quantity-increment" type="button" databind="click: addToCard(id)" &gt; &lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"&gt;&lt;path d="M12 7H9V4H7v3H4v2h3v3h2V9h3z"&gt;&lt;/path&gt;&lt;/svg&gt; &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="shopify-buy__cart-bottom"&gt; &lt;p class="shopify-buy__cart__subtotal__text" &gt;SUBTOTAL&lt;/p&gt; &lt;p class="shopify-buy__cart__subtotal__price"data-bind="text: total"&gt;&lt;/p&gt; &lt;p class="shopify-buy__cart__notice"&gt;Shipping and discount codes are added at checkout.&lt;/p&gt; &lt;button class="shopify-buy__btn shopify-buy__btn--cart-checkout" type="button"&gt;CHECKOUT&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; Are you able to discern what that is. BTW serious about the beer. You made my boss and I very happy that either of us can enjoy our holiday weekend. 
There are definitely still some significant differences between npm and yarn, but one of the bigger ones that yarn improved early on was download speed in relation to running a clean npm install for your packages. npm 5 is now also significantly faster with that process, so from a front-end developer perspective, there's not a ton of real use case differences and thus defaulting to simply using npm is the main staple. However, from a node-ecosystem perspective, there are definitely some interesting differences; in particular, yarn sees itself as a package management solution ideally designed to be extensible to any language (and it is also designed to be driven solely by community needs/desire, despite being backed by some significant companies like Facebook) - whereas npm in the last 1/2 year or so has started to re-align and restructure itself to solely serve the front-end ecosystem of its package management (npm's own statistics indicate only 20% of its users actually develop specifically for node, whereas the remaining percentage are developing for front-end solutions). They also have some interesting long-term goals of allowing for packages and its resources to be bundled into single files for an entire application (thus reducing all the overhead of flattening/resolving packages/etc). It's also important to note that yarn depends on npm's repository and that there really is no competitive issues between the two communities (they've worked closely with each other even before Yarn went public/open-source). There's a really interesting podcast ([nodeup](http://www.nodeup.com)) that had some of yarn's developers on back in Nov 2016, I'd recommend listening to it for more info.
Came here to complain about this [original presets](http://i.imgur.com/l7D7KiI.png)
https://soundcloud.com/front-end-happy-hour/episode-034-npm-install-beer-save-in-mouth For those of you wondering if you should ditch yarn, npm's COO addresses a lot of your questions directly in this episode. I'm having trouble justifying staying with yarn 
Of course it's slow. The client has to download a lot more crap, parse &amp; execute some JS, do another request (if the data wasn't bootstrapped), and then that JS has to mess with the DOM some more to actually display anything. You've seen waterfall diagrams before, right? Ever used that "capture screenshots" thing in Chrome's Network tab?
I can't find any "official documentation", but over on HackerNews there have been some users who have ran their own code with Yarn &amp;&amp; versions of NPM. This user [had these results](https://news.ycombinator.com/item?id=14423246) &gt; Also ran some numbers here (with warm cache. node 6.10.3). * yarn: 25s . * npm@5: 28s . * npm@4: 63s . * npm@3: 68s . Another user [had these results](https://news.ycombinator.com/item?id=14423208) &gt; On cold cache: Yarn: 20.94 seconds NPM5: 21.11 seconds &gt; With cache: Yarn: 10.35 seconds NPM5: 15.20 seconds So, in general, it seems the speeds are very close but that Yarn is still a tiny bit faster. 
npm 5 still feels slower. This isn't backed by data but I might run some tests later (in dev environment, CI env, etc.)
I used yarn on a recent project that I forked from GitHub that wouldn't work until I just went ahead and did an 'npm install'. Anyone else had this problem?
Here is an example that I ran across at work: We have a model and models have many revisions. We want to display them in a timeline (either a global activity view or only for that specific model) and make them clickable so you can go directly to that specific revision. Originally, each revision had a `modelId`, so we should use that and a `versionId` parameter to create the link. Recently, the database + backend has been updated so that `modelId`no longer exists on any version. Since we had no tests, we had no idea this functionality was broken until I randomly ran into it while working on another issue. If we wrote some unit tests for the front end, it would have been caught much earlier. I'm currently looking into getting Jest to work with our codebase (specifically because of the snapshot feature since we do not want to manually write all these tests).
Feature wars necessary for overall improvement, just use whatever fits use preference. There's absolutely no need for one or the other to be killed off. 
&gt; What you call crap What I call crap is something which isn't necessary for filling the initial viewport. It's something which isn't important yet.
but it is necessary. Everything has a cost be it in rendering time or maintainability or whatever. You do not have enough experience to realize that you are way off the mark here. Progressive rendering is all you seem to know (you have a hammer and everything is a nail).
 isLoggedIn() ? { login: 1 } : null; will resolve into `{ login: 1 }` if `isLoggedIn()` returns truthy and into `null` when `isLoggedIn()` is falsey. Which means it never returns a boolean and instead returns an object or null.
At first I liked this, but I often have scripts like "clean", and that collides with `yarn clean` (which you don't want to run usually). So now I have gone back to the habbit of using `run` every time rather than case switch based on whether there is a collision or not. YMMV
Is offline install (from cache) supported by npm?
- Read "You Don't Know Javascript" on github (free) - Read "Secrets of a Javascript Ninja, 2nd Ed." - Follow: @dan_abramov, @bmeurer - Google "javascript weekly"
I tried switching yarn for my project but the first time I tried `yarn install` it failed. Went back to using npm. Now that npm5 is supposedly faster than yarn and deterministic, I will likely never even attempt to use yarn ever again.
&gt; but it is necessary. For filling the initial viewport? No, it's not. &gt; You do not have enough experience Everyone who doesn't share your opinion is either stupid or has too little experience. How convenient. https://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect
Yup, as revealed in `npm view npm`, their `latest` is currently still set to `4.6.1` and `next` is currently set to `5.0.0` { latest: '4.6.1', next: '5.0.0', 'latest-2': '2.15.12', 'next-2': '2.15.12', 'latest-1': '1.4.29', lts: '2.15.11', 'latest-3': '3.10.10', 'next-3': '3.10.10', 'latest-4': '4.6.1', 'next-4': '4.6.1' }, Alternatively, you can always check what's available with `npm view npm version -json`. The JSON flag forces the complete print out of every version instead of truncating the list with ellipsis. So it will show this: ... "4.5.0", "4.6.0", "4.6.1", "5.0.0" ] instead of this: ... '2.1.10', '2.1.11', '2.1.12', ... 160 more items ]
Read this: https://www.gitbook.com/book/drboolean/mostly-adequate-guide/details A TON of frontend and backend stuff revolves around transforming/reducing data-structures into something more workable. Functional Programming makes doing this sort of thing extremely easy.
https://github.com/JamieMason/npm-cache-benchmark
Yes the improvements to npm 5 are profound. You can now use semver for git dependencies, while yarn still seems to be buggier on projects I've used it on.
yeah i run with "trash" instead of "clean" so i don't run into this problem. i think it might've been because of yarn :P
Not really enough information here, what exactly is your concern? Your application uses a few mb of memory over a few seconds, then seems to stop using almost all of it andthe drops are the garbage collector clearing it out, then it repeats. Whether or not that can be handled differently depends on how your game works and the functionality of any frameworks you might be using. The optimizations for this pattern I could see are organizing data differently, with the idea being that you could be repeatedly creating a bunch of data that only needed to be created once, or implementing something like object pooling to take the load of garbage collection cycles. The one thing I would keep an eye on besides that is how each drop seems to end slightly higher than the previous, same for the peaks. If that's an expected part of your game logic, not a big deal. If it happens indefinitely, it looks like a memory leak. 
https://www.html5rocks.com/en/tutorials/getusermedia/intro/ This says you can do webcam to canvas. Could you not just export the image data out of the canvas?
Yarn is still beating npm on my project by 10s. Looks like I'll be sitcking with it for a while longer. Will definitely use v5 on CI though.
There are plenty of ways to make colors transition. But I'll use this opportunity to explain why the code you tried didn't work. This should help a lot with everything else you are doing in the future. * The height of a page starts with 0 at the top and 10000 at the bottom. It's increasing as you scroll down, not decreasing. So the code you wrote is trying to scroll up above the top of the page since you are decrementing the number instead of incrementing it. * A while loop will execute all at once. By that I mean, the screen won't have time to redraw so you can see the change before it's entirely done. So what you really want is a delay between moving it down each time so the screen has a chance to actually move and you can see what changed. So essentially what you have there is `window.scrollTo(0, -10000)`. For scrolling down like this, one way to do so is as follows: function gradientFunction(height){ window.scrollTo(0, height); if (height &gt; 10000) return; setTimeout(function(){ gradientFunction(++height); }, 10); } gradientFunction(1); Let's break down what's going on here. You have a recursive function (a function that calls itself) called `gradientFunction`. It takes one argument `height`. This function first scrolls to the designated height as given by the argument. Then if the height is larger than 10000 then it will return so it doesn't keep scrolling after you've reached the bottom of the page. Then here's where the key part is, the `setTimeout` function. You can read the documentation about it [here](https://www.w3schools.com/jsref/met_win_settimeout.asp). The first argument of the `setTimeout` function is another function to call and the second argument is the delay (in milliseconds). So essentially what that is saying is to call `gradientFunction` again after 10 milliseconds but increment the height by 1 before doing so. So this means that next time around the height variable is at 2. Then 3. etc. And to finish this all off, you need to start this recursive function by calling it once with a starting value. So I did `gradientFunction(1);` and that starts the ball rolling. Hope that all made sense.
Wow, thanks for these kind words. Glad that the book helped you!
Thanks. Actually I'm doing this in the module pattern where I'm defining further constructors etc. as module methods. I just liked the 'inline' look, but wasn't sure if any ramifications. :)
I'm not sure how to answer that. I'm confident I understand (naive) how constructors and prototypes work and I feel they are closer to the native structure of the language itself. And IE.
So you do need a database solution. Either firebase (which I've never used but heard good things about) or rolling your own (load balanced flask w/ threads, docker, and AWS) is what I would dom. It feels ethically and from a tech standpoint weird to use the gist API.
This version does not add most if not all the features yarn touts. It adds the superficial stuff, and what can be easily integrated. Yarn is fundamentally different, and still fundamentally more reliable and faster.
I'd spend time on a C project.
Semantic UI has a nice method of that. You could take a look at their source code and just copy it out?
I can't seem to find the code you are reffering to, mind sharing a link if you have one?
for react, https://github.com/mozmorris/react-webcam this also looks promising https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia
Learn web technologies: HTTP, OAuth 2, the DOM, WebSockets, REST... I've met guys doing web who would talk about the ES6 modules and whatnot because they saw it online but couldn't explain clearly what a session is or how to use HTTP caching.
They talk about that here: https://code.facebook.com/posts/1840075619545360. tl;dr, they tried to get npm to behave, but it was a nightmare. Also, they probably just didn't want to deal with npm who are known for letting politics dictate engineering direction more often then they should.
&gt; var marker = new google.maps.Marker({position: center}); &gt; marker.setMap(mapOptions); &gt; map = new google.maps.Map(document.getElementById('map-canvas'), mapOptions); .setMap seems like it would take a map, not your options object. So.. Swap those around? &gt; map = new google.maps.Map(document.getElementById('map-canvas'), mapOptions); &gt; marker.setMap(map); Or you can set the map when you create the marker. &gt; map = new google.maps.Map(document.getElementById('map-canvas'), mapOptions); &gt; var marker = new google.maps.Marker({position: center, map: map}); 
Neither of the two suggestions placed a marker on the map
Not sure why you're getting downvoted. You've provided a helpful link. But thanks for that. Upvote for you!
Not sure what you mean by "superficial stuff". If you read the release notes you clearly see that npm offers a lot of yarn's features in its v5 version. You work for yarn or sumthin? Couldnt help but notice you created a new profile just to respond to my comment.
Yarn is from Facebook. React is from Facebook. Create React App is from Facebook. Facebook devs probably create 10 new React apps per day to test some prototype or feature. Are you still surprised?
RemindMe! 2 days "this"
Hmm, why would a company whose entire business model is npm try to make users stay? No idea TBH!
The command is just 'yarn' to install all dependencies listed in package.json
Nightlies are still using V8 5.8, reaaalllly hope it ships with 5.9
for loops are faster
The issue is your HTML loads before the Vue instance gets the cart data. In my example I initialized cart as 'null', and after many such problems as this, I'm very aware JS/Vue does not like looking for properties on a null. Two solutions: 1. Initialize cart data with placeholder info: cart: { items: [] } 2. Throw a v-if on &lt;div class="shopify-buy__cart-items"&gt; that relies on a computed property checking if cart data is ready (via length of object keys and items or something. It will only render when data is loaded. You could create a v-else placeholder div with some desired design for "Loading..." Enjoy the weekend! 
The Yarn CLI really messes with me. It just doesn't feel as intuitive as npm, it's been over a month now and I still have to constantly look up commands for Yarn. 
It uses a few jQuery plugins. You can see the minified plugins (with links to their GitHub repos) in the Sources panel of the Devtools. There's a small script at the bottom of the page that initializes the plugins
While that is true, the difference in build times was still not that huge. NPM install is not the longest thing that happens when i build or test. And i'd rather focus on my live reloading stuff instead. I can understand the need for it being faster, but i've never really thought "oh boy that NPM installation sure takes up a lot of my day".
Is Node 8 gonna come with this?
Where the demo at
thank you sir, will look into it. 
They implemented some of the best features of Yarn, which is pretty nice.
Thank you very much!
I'm glad I was able to help! Best of luck with your JavaScript adventures!
Well, there's a matching library in just about every language and it's well suited for angular2 and ngrx store... from a practical standpoint it's pretty flexible. 
You are a "true believer" in progressive rendering, and cannot see any other solution to performance, and costs be damned, and pander to an imaginary clientele that demands 100ms load times (more likely some half-wit manager). And the funniest thing is that it is fake, you don't measure time to live, you measure and pander to something only a stupid person would care about (ooh we tricked them that time! they thought the page was ready to go!). What gets you up in the morning, cheap tricks?
I think what you've suggested is kind of the same initial situation but inverted. As for using constructor, only example I gave, in real code I have initialisation and parameters being passed to the constructor function and it does stuff. Sometimes it's to provide local properties for the prototyped ones.
it's a bit of both, tbh: it's almost all stuff we *planned*, but having someone else show that it was actually a good decision and people were happy about it made it much easier to go ahead, instead of taking more careful steps. There's only so much cheese-moving we can risk doing without breaking a great number of people who rely on exactly the way npm does things. :) I, for one, think it's great to have an unstable playground that can afford to ruin people's day (and we've been talking about having a "canary" npm where we can try new ideas on responsive users)
@mpj is fantastic
Regardless of the downvotes you're getting, i am willing to wait an extra 20 seconds on initial build if it works. How often are you doing that? With npm V5 improving load time, why not? 
first mistake is not using a pastebin. I'm creating a new shorthand: bf;dr (badly formatted, didn't read).
Hi there, I need help.I do not know how to edit text format.Could someone can help me ? Thank you. 
The changes they would have had to make couldn't be classified as "modifying." It would have basically been a complete rewrite. If you have to do all that work anyway why would you choose to deal with the pull request process and thus submitting yourself to the will of other people who clearly didn't share your vision?
Me too boss, I'm agreeing with you.
Haha i just started reading this yesterday, completely unrelated to this post. From the github md's not the above site.
I recommend reading code (and issues!) of various open source projects on GitHub, it is inspiring. 
Unrelated but $(window).bind('pageshow resize orientationchange', function(e) { max_height(); }); Could become $(window).bind('pageshow resize orientationchange', max_height); Also, as you're using add event listeners in the first part, its a little confusing. Maybe use jQuery for both? Further, document.ready is device ready, so having a function in there that is triggered on deviceReady seems needless, and in any case you call that function right away after
5gb memory is very strange. Can you let me know your OS?
npm5 is a rewrite of a fairly core component of npm: the entire package downloading and caching infrastructure. Everything else stayed mostly the same -- the other big chunk that was changed was the way the installer interacts with package-lock.json (née npm-shrinkwrap.json), in order to take advantage of it having sha512sums, and short-circuiting a bunch of early-phase work we'd otherwise need to do. The rest of the CLI code is mostly the same -- we did some refactoring to use promises in more places, some fixes to make the new changes uhhh... work at all, but nothing earth-shattering. The entire download and caching infrastructure now exists in standalone packages now: https://npm.im/pacote (literally can do `pacote.extract('somepkg@^3', './here')`), https://npm.im/cacache (the new cache!), and https://npm.im/make-fetch-happen (the new http client!). Plus a few others. node-tar was upgraded as part of all this but hasn't landed yet. We're working on tearing apart the CLI into smaller chunks that people can use to build their own CLIs without having to first reinvent the universe in their own image. The dream is for people to be able to spin up custom, full-featured package managers in an afternoon that can compete with the latest npm right out the door, and for npm's overall codebase to be in small enough chunks that people can make significant contributions without having to know the entirety of the (massive, terrifying) npm codebase. Seriously, it took me like a year to catch my footing. And that's pretty much everyone else's experience on the team.
&gt; //Filitreleme function checkandcreate(name, pass) { Mongo Comment lines are working properly but the page refreshes twice
Yes
I guess it seemed clear to me because of the particular struggles I went through. When I switched asset bundling over to gulp/webpack in October of 2015 I knew I needed reproducible builds, so naturally I used shrinkwrap. Shrinkwrap was a nightmare and I dreaded modifying dependencies when I used npm. Even worse was when other devs who hadn't devoted as much time as I had to understanding how it works needed to add dependencies. Forgetting to shrinkwrap or doing it incorrectly had unfun consequences that took time to work through. To me it was a huge issue that nobody at npm seemed to care about (or at least not the right people). Fast forward a year to October 2016 when yarn came out and my builds got much faster and all of my shrinkwrap issues magically went away. I now have the ability to effortlessly make quick, reproducible builds. npm had _a lot_ of time to make this happen before yarn, but they didn't. That's why I believe that the vision wasn't shared.
I'm working on [this](https://github.com/maierfelix/mini-wasm) simple C-like compiler which compiles to WebAssembly
As someone who unfortunately has to fiddle with different CI configs and legacy deployment setups at work, I kindly disagree. We're currently moving everything over to docker and during our first experiments we obviously needed to get familiar with it and rebuild our containers constantly. yarn was a huge timesaver for that. With npm it would've taken ages to test
I work with a couple of megarepos (really complex projects), and when I still had my macbook air, a fresh install would take anywhere from 30-45 mins, with at least 90% of that time being consumed by `npm i`. With Yarn, that time went down considerably, to around 15 mins, and when using Yarn's cache, that went down to under 5 mins. Due to having to support multiple versions of those projects, it wasn't uncommon to `git clean -xfd &amp;&amp; git checkout release/some-other-version &amp;&amp; npm i` several times a day. Yarn literally gave me several hours a week back that I otherwise would have wasted waiting on NPM. That's huge.
Hi /u/nknklnlkn, this post was removed because /r/javascript is not a job board.
I recently updated every aspect of the Vuetify documentation and released a massive update. It's a Vue material component framework. [Vuetify](https://vuetifyjs.com/)
&gt; The content the user wants to see is more important than potential interactions which might follow. You are still thinking in "Web pages are glorified documents" terms, and not thinking about actual applications. Also the target market is a huge variable. I mean if your product is pure crap I can see it having an affect, and I understand your frustration, but the solution is don't work on pure crap. but "enforcing" progressive rendering as THE one size fits all answer to neurotic users for all web pages everywhere is just stupid, get used to it. The only result of compliance will be breeding more neurotic users and crappy web hacks.
You can watch every game in the NBA and still not be able to play basketball. It certainly doesn't hurt to read books (I have written several) but ultimately this is not a spectator sport. You're going to have to dig in and write some code. But that isn't the hard part. Here's the real hard part. It's an absolute guarantee that at some point (probably many points) you're going to feel like a total idiot. That's a completely normal part of learning how to program. It's also the biggest weakness of the 'self-teaching' paradigm. When you have self-doubt, so will your teacher. Having a real coach who has seen this before, and has the confidence you lack is absolutely priceless. I taught myself, 30 years ago, and now I teach many many others, because the way I learned was error-prone and more painful than it needed to be. My teacher back then was ignorant and unsupportive, and didn't know any more than I did. Who would want a teacher like that? 
Who types CLI commands in caps anyway? I don't think I've ever seen that
Thank you! I use Vuetify a lot. You have a very high quality project. Kudos
Good on you, I would have given up immediately. Haha
Last I saw, they are actually planning to merge with Lerna, not reinvent it.
Nice! I hadn't seen that yet.
The idea is neat but i imagine this might break the ToS for bitbucket, as it's not exactly what their private repo's are meant for
But `await` is new and cool so therefore we must use it everywhere. Hammers and nails.
public var RemoteIP : String = "127.0.0.1"; //127.0.0.1 signifies a local host (if testing locally public var SendToPort : int = 9000; //the port you will be sending from public var ListenerPort : int = 8050; //the port you will be listening on public var controller : Transform; public var gameReceiver = "Cube"; //the tag of the object on stage that you want to manipulate public var handler : Osc; public var msgValue; //VARIABLES YOU WANT TO BE ANIMATED private var yRot : int = 0; //the rotation around the y axis private var xRot : int = 0; private var zRot : int = 0; public function Start () { //Initializes on start up to listen for messages //make sure this game object has both UDPPackIO and OSC script attached var udp : UDPPacketIO = GetComponent("UDPPacketIO"); udp.init(RemoteIP, SendToPort, ListenerPort); handler = GetComponent("Osc"); handler.init(udp); handler.SetAllMessageHandler(AllMessageHandler); } Debug.Log("Running"); function Update () { var go = GameObject.Find(gameReceiver); go.transform.Rotate(0, yRot, 0); go.transform.Rotate(0, xRot, 0); go.transform.Rotate(0, zRot, 0); } //These functions are called when messages are received //Access values via: oscMessage.Values[0], oscMessage.Values[1], etc public function AllMessageHandler(oscMessage: OscMessage){ var msgString = Osc.OscMessageToString(oscMessage); //the message and value combined var msgAddress = oscMessage.Address; //the message parameters var msgValue = oscMessage.Values[0]; //the message value Debug.Log(msgString); //log the message and values coming from OSC //FUNCTIONS YOU WANT CALLED WHEN A SPECIFIC MESSAGE IS RECEIVED switch (msgAddress){ default: Rotate(msgValue); break; } } //FUNCTIONS CALLED BY MATCHING A SPECIFIC MESSAGE IN THE ALLMESSAGEHANDLER FUNCTION public function Rotate(msgValue) : void //rotate the cube around its axis { yRot = msgValue; xRot = msgValue; zRot = msgValue; } 
In my opinion, you need to write a lot of bad code in order to understand why the book stuff (aka "best practices") matters. That's when the lightbulbs illuminate...when you sit there with a big mess that you've written and wonder how it got to be so complicated, and what you could have done to avoid copy-pasting so much stuff everywhere. For me, the book stuff was so dry and confusing until I had actually built . It's not like being a surgeon where you'd better know what the hell you're doing before you operate on somebody; go out and make stuff that just gets the job done while you learn how to do it better. *And that process doing-learning-doing-learning should never end.*
&gt; You are still thinking in "Web pages are glorified documents" terms Sure. This doesn't apply to, say, games. In games, you use other tricks to mask loading times. E.g. Dead Space used elevator rides which worked exceptionally well in conjunction with the game's real-time inventory management. In a small game, you could for example display the title screen first and, if you're lucky, get everything else loaded in those few hundred ms it takes the user to click anything. &gt; neurotic users You aren't any different. If Reddit, Google, YouTube, or whatever would get slower, you'd use it less often. You might not be aware of it, but you'd behave like everyone else.
That is besides my fulltime work as React/redux developer. I want a sustainable routine. It's not a race, it's a marathon. But thanks for your valuable input.
"a questions"? So, var questions = new Array() ?
&gt; Hello Reddit, &gt; As part of my final project at uni, Im creating a simulation that gives a visualisation of your brainwaves. I have everything working, just not perfectly. &gt; I am using a OSC stream into Unity5 that controls the rotation of a cube in a scene, I have a problem with my code in that I cannot figure out how to slow down the roataion of the cube and to Set limits on the rotation depending on what number is comming in, &gt; E.G; If the scan shows 0-100 rotate the cube at XXX amount 100-200 rotate at XXX amount. &gt; I will happliy share the code to anyone that can help. Please PM or comment if you have any idea! Anything will be replied to! Will do, Thank you for letting me know, Im not very good at scripting 
It's not that reading books is a waste of time, but rather much of what you'll gain from reading them is subjective, depending on the experience you already have going in. In other words, the value of theory and best practices is lost if you don't already have a bit of foundation on which to apply it. Ideally, you probably want a bit of both, trying to do things with what you know and reading up on how to do it better. 
I think I broke it: http://i.imgur.com/G5K4ozS.png edit - steps to repro -- 1) add a few toppings 2) attempt to click the red '*' (assuming this would remove it, doesn't seem to) 3) uncheck one of the toppings error is logged after pressing the '*', `TypeError n.map is not a function`
Also, the alert message that appears after removing all items changes the width of the app. Please fix, my OCD won't let me place the order until its perfect and I'm hungry!!
Write software in JavaScript.
Yea I kinda figured as much. In that case it means that each object has two parts: the constructor and the prototype. As someone else suggested, the newer `class` syntax can be a good fit here as it lets you define both in one place. It does come with its own advantages and disadvantages, so you'd have to check a bit deeper into your use cases to see if you can use classes. Another option is to use a sort of factory pattern here. For example if you have several flavors of the same type of object, they may be able to share the same *parameterized* constructor function, with the parameter denoting the exact type you're looking for. You could then collect the various prototypes together into some object, for example. If the constructors themselves are substantially different then you can extract these and collect them into a grouping object as well. So you really have quite a few options, depending on what exactly you're looking for, and exactly how elaborate/extensive your use cases are.
The Yarn team has never expressed the intention of moving their efforts to anything but Yarn, regardless of the state of npm, nor have they expressed the remotest intention of contributing to our codebase in any significant way. They even seem to have avoided most of the dependencies npm uses (many of which take care of doing certain tasks in npm-compatible ways). I don't think I have ever seen a patch come through our issue tracker by any member of the Yarn team, except for one person who started bouncing around all our deps and adding `"files: [...]"` to them so we'd stop publishing `test/` for the ones that still did. And that was a long time ago now. To be fair, the way the project was running as of last year, we were being much much more conservative about making big changes to the codebase or UX, even with the changes that were scheduled for Q1 2017. We've changed that now, so change is happening a lot faster (while still being careful about backwards-compat), and we're putting more effort into making the codebase easier to pick up and contribute to AND letting community devs have more influence over its direction. A lot of the little details in npm5 were things people directly asked us to include, some of which were turned down years ago (before my time!), and we just went "ok sure why not that sounds easy enough". :) (For the record: the cache rewrite, which enabled offline, did most of the speed improvements, and enabled checksums in the lockfile, as well as "make shrinkwrap what the community wants it to be", has been on our roadmap for about 18 months now, and has been on our backlog as an important item for something like 4 years. I have a conference talk video where I'm outlining the plan, before Yarn was even announced.)
Cool. Can you put it on the web or does the tinder API not allow CORS?
Thanks I'll check those out 
You won't "master" it in 3 months, but you can learn all the basics and best practices in that time by reading the recommended books and practicing code to see the concepts in action. You have to actually code it though to embed it in your memory. JS for work nearly always entails some kinds of frameworks, build tools and libraries. This is what you'll usually be dealing with more than the underlying language. Here you just use whatever is in vogue in the moment, and by the time you've mastered it, it will be deprecated and all the cool kinds use something else.
That's a pretty great vision and aligns with reasons I never contributed to npm. Too massive and unconventional. I'm currently experimenting on an HTTP2 package manager geared towards ESM projects and these tools will help immensely to integrate with npm. Thanks!
im not going to go any further into reading the recommended books, it just turns me away from wanting to learn more. I'm paying monthly to a course called watchandcode which is what I'll stick with, I just wanted some more input on this, thanks for that.
You can't put it on the web, unfortunately, node only. It's because the client needs to set special headers, which is disabled in client js for security reasons. The node allows it, but regular Chrome does not
That is a nice improvement. I stand corrected, I guess? But really, I don't understand all the yarn hate. It's worked perfectly for me since I switched to it and with every project since then. It feels like a slicker Bundler (Ruby).
Sounds like you're talking about CORS. You can create a proxy endpoint using AWS API gateway and lambda so that this could be deployed anywhere. I did something similar for GitHub authorization at https://GitHub.com/moodysalem/gitlock
Possibly useful and free online: [Exploring JS – JavaScript books for programmers](http://exploringjs.com/) (disclaimer: I’m the author)
OMG! I didn't expect such a in-depth analysis. Thank you so much!
We're redesigning the registry API, and http2 is one thing we're looking at closely. ESM-awareness as well :) Just sayin' that if you integrate your http2 stuff with `make-fetch-happen`, I'd totally consider the patch, and npm would be able to take advantage of it as soon as a service is available for it 👌
Come up with some small app and start writing it. The things you should focus on are how prototypal inheritance works, functions are first class citizens, variable scope is to the nearest outer function, callback functions, learn how to use map/reduce/filter, I'd learn ES6 syntax which means you'll need babel and webpack. Skip jQuery, learn react.
Good point! I don't know...
here are the things i have a problem with: the comments require 2x the work to maintain because they basically explain the lines they precede. so every time you change code (which if the code is self documenting also handles changing documentation), you also have to change the line explaining the code. this hardly ever happens in practice so the comments tend to become lies that are ignored anyway. const self = this; is just wrong. since es5, JS has had a way to do this properly without breaking encapsulation ['validate.email.isBeingUsedBySomeUser'](email) makes almost no sense inside a class. the code is defining a class' interface, you typically don't want dynamically generated properties because it requires runtime inspection to know the interface of the class. **edit** now that i understand the intent, what i said about runtime inspection may not be correct, but this is still very confusing and weird. /** * Inject dependencies. */ this.schemes = schemes; terrible comment and bad code. this isn't injecting dependencies, it's tightly coupling an instance property to a global variable. the proper way to do this is pass in `schemes` to the constructor and then store that as an instance property. constructor(injectedSchemes = schemes) { ... this.schemes = injectedSchemes; } is proper DI return self.schemes.findUserByEmail(email) .then(results =&gt; { let isBeingUsedBySomeUser = true; let hasAnUserUsingThisEmail = (results &amp;&amp; results.length); return (hasAnUserUsingThisEmail ? isBeingUsedBySomeUser : !isBeingUsedBySomeUser); }); is this for real? this is terrible, it introduces an extra variable for no reason and makes things so complicated to find out if the results exists. do this instead: return self.schemes.findUserByEmail(email).then(results = &gt; results &amp;&amp; results.length); this is not what i would call good, or clean, or self documenting code. it looks like it was written by a senior in college who's convinced they're a hell of a programmer. **there's nothing wrong with that**. the problem comes when they start talking about how great their code is and trying to teach other people to do it this way. i will say that it's good that they included semicolons
I believe this was to explicit return boolean value, but this could be achieved just by `!!(results &amp;&amp; results.length)` or `Boolean(results &amp;&amp; results.length)`. And whole `isBeingUsedBySomeUser`variable seems to be not needed at all. So it could be just `results =&gt; (!!(results &amp;&amp; results.length))` instead of 4 lines of boilerplate.
In my experience, books become more useful the more knowledgable you get. I believe this is because, when starting out, you have to assume everything in a book is correct and/or useful, and feel it is necessary to learn it all before you start writing code. After years of writing software, you can pick up most books and immediately glean the useful information from it because 1: there is a smaller pool of unknown information for you to wade through and 2: You have stronger intuition of what is useful and works, and how to directly apply that to something you're working on. Not all books are created equal, but they are certainly not a waste of time to many of us. 
Speed what people always point to when talking about Yarn. The greatest thing Yard did right over NPM was introduce hashing. There is no integrity with NPM, which is why they occasionally have defects that break people's packages and it is the publishers problem more than NPM's problem. This is a large reason why I stopped publishing my personal software to NPM. I have enough problem with being a weak programmer. I don't need their errors compounding the problem like I did something wrong.
If you're going to spend a lot of time using a language, certainly if you're developing a career in it, it's absolutely worth while to read up on other people's ideas of best practices, and then assemble your own as you go Read books, read blog posts, look at open source projects, absorb what you can from multiple sources on what good code really is. Don't take any single source as religious truth, but value every author as a potential source of valuable insights. What did you find counter-productive about it? I don't know that book, maybe it's not very good. I'm not sure how you can generalize that reading about javascript is counter productive. 
Write many different projects using the thing. Also, learn different frameworks ... play with React, VueJS, ng4 ... see what you can do on the server with Node, Koa, Express, Socket.IO Nothing beats DOING. you can read all day ... it won't really stick until you DO.
Sorry if I'm misunderstanding but I think you just need to shuffle it around and use more of the React lifecycle. You have a state where the ID has changed, then you need to render different data. 1) You need to be listening to the store that will contain the AJAX data eventually. 2) the ID for the component should be a prop, and when it changes you should be aware of that change in the compenentWillReceiveProps https://facebook.github.io/react/docs/react-component.html#componentwillreceiveprops 3) At this point you need to make sure you update your data from the store, so you will likely have to go to your store and fetch the payload data. 4) If the store has no data (IE the AJAX call hasn't been made yet) you need to then send the GET_DATA action with your current ID. 5) Then once the AJAX call is complete the data will be put into the store, since you're listening to that store, your component will get the data, re-render, and voila! This will also prevent you from making additional calls to the server every time you create the element as it will check for data in the store first.
i've met one of the main contributors to Mithril. Brilliant dude. Keep learning and improving :)
well, it's still just 0.0.1 so probably wait a couple of weeks before you do. Shame I can't edit the title now...
I would argue that learning React makes you better at Javascript, and learning Javascript makes you better at React.
The `this` inside arrow functions is the this of the outside context foo =&gt; this.bar Is the same as Function (foo) { return this.bar; }.bind(this) https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions
If esm loader works as well as advertised in what it plans to offer over mjs wouldn't this mostly put egg on the face of the entire Node foundation?
No its not. Readability is the code being written so that the next person can understand it. Not that they have to agree with the architecture chosen and the abstractions used. Naming all your variables a single letter would be unreadable. Having single functions hundreds or thousands of lines long is unreadable. Choosing whether to use inheritance or not isn't readability. It's an architectural choice. One you are perfectly free to dislike but not one that has anything to do with readability. I can't believe you are even trying to claim otherwise.
You said you already are familiar with programming. Spend time on what makes js different. Its async nature (imho) is #1. Learn the classic callback pattern and the new await stuff. Functional scope is another big one. Read some blogs about the this keyword and prototypes. Then, try to "invent" a project that forces you into those situations, focusing on the environment you want to end up in (web vs node, for example). If you're going to be a web designer, my advice might not apply. I don't do client side js much. You might want to consider code combat like games too. I'm on codingame. Problem there is that you'll spend a lot of time writing algorithms... and it might not mimic the real world.
It's really only limited to your imagination. Maybe you'd like more customization for a particular website, or maybe you want to make something a little more complex that resembles a browser extension but without needing to be hosted in an extension store. I recently made a script that adds a word count bar to the bottom of a Google Docs page, similar to the one in Microsoft Word. I've also made ones that fix potential client-sides security issues on various sites.
Cool. Thanks!
Grind through free code camp exercises then do their projects or your own projects. Try to find an existing app that you can add a feature to. I remember the modules systems being a pain to figure out from scratch... Like spending a bunch of time trying to get some systemjs thing to work and not knowing noone uses it. Find a good primer on node's `require` and everything you need to use `import`. Examples on the internet will be in one or the other, and you'll need to convert in your head. If you find yourself futzing around with eslint rules or webpack config, give yourself a time limit or something. Maybe I'd spend most of the 3 months focused on node/backend? I don't know. You'd avoid a bunch of tooling time-sucks.
Maybe there are good local ones you can find. first one I found: https://github.com/adambom/dictionary maybe some databases are out there?
Undoubtedly. However, just about any software has possibly malicious uses.
So why not just use pinned versions in package.json?
It's like a website but has functionality.
I think is better when somebody can get quick results when learning something for the first time, rather than complicating themselves with best practices, browser compatibility and/or over complicated documentations. If you are experienced in a programming language, then jumping right up to JS should be fine. 
&gt;one key thing I dislike is that getters/setters, and value for a property are mutually exclusive. This is actually one of the biggest issues I have with JS get/set functionality, and I've spent quite some time looking at the various options and testing how I can use the various features available for this functionality. Let me first explain a little bit about JS properties. [MDN's Object.defineProperty](https://developer.mozilla.org/nl/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) is the most formal/elaborate way of defining a new property on an object. It accepts a 'descriptor' object, which holds some configuration regarding the new property to create. There are two types of descriptors: the data descriptor, and the accessor descriptor. A data descriptor will quite simply create a property that holds some piece of data, some value. An accessor descriptor can contain a get and/or set function. The way I see it, is that properties made with a data descriptor should hold actual data/values, while those properties made with an accessor descriptor represent different ways to access this data/these values. So these two types seem to be designed to be used together: you could first define a data property on a private object, and store your value in there; then you could define an accessor property on a public object, where the get/set functions will be interacting with the private data property. Perhaps you're familiar with PHP: what I just explained is essentially how class properties are generally handled in PHP; you define a private variable, and then a public get and set function for this variable. The above is, I think, the intended usage. If you want to deviate anyway, then perhaps you can look at [Proxy objects](https://developer.mozilla.org/nl/docs/Web/JavaScript/Reference/Global_Objects/Proxy). They can essentially act as a kind of gateway, or interface, or well.. proxy, between your object and the user. You can define so-called 'traps' on the Proxy for each of the various types of interaction, including traps for getting and setting a property value (and some way more powerful ones, too). So using such a Proxy object, you can get away with defining a public data property, and then passing not the public object, but a Proxy of it, to the user, with your custom get/set functionality defined as traps on this Proxy. I should add that, while it's a pretty powerful feature, it's probably not intended for this type of use, it's fairly slow, and there's also no built-in way to distinguish between properties - so whenever any data property is being set, you'd have to check whether it's your special one which requires custom set actions. Anyways, this is a fairly interesting topic to me, and there are several interesting related features like what I've described above. Maybe these can help you a bit further with your own plans as well. :)
You could do that with Vue as well
[@mpj's latest tweet](http://i.imgur.com/yHtt13n.jpg) [@mpj on Twitter](https://twitter.com/mpj) - ^i ^am ^a ^bot ^| ^[feedback](https://www.reddit.com/message/compose/?to=twinkiac)
https://www.codewars.com/ https://github.com/getify/You-Dont-Know-JS You could also just write a few applications in Javascript.
MDN has great JS docs, I would argue better than W3C. Up to you! 🙂
3 Steps to Master JavaScript 1. Practice by writing JavaScript 2. Practice by using JavaScript 3. Practice by teaching JavaScript
Developers need a browser that is actually one of the browsers they support in order to do meaningful testing. PhantomJS is based off a Webkit fork that is not used in a real browser and doesn't support the latest features. I'd like to see all the major browsers support headless versions to make it possible to do better automated tests, maybe this will get the other guys going. Can headless Chrome be abused by spammers and other bad guys? No doubt. I'm sure we'll come up with ways of mitigating that, as we have for malicious uses of PhantomJS and other tools.
I suggest the game [Screeps.com](https://screeps.com/), it is an mmo RTS where your units are controlled entirely through your scripts. I hadn't ever used javascript before and it was a really fun way to learn.
Thanks for the quick reply, it was a simple answer but it wasnt totally clear from my initial searches that an api was what I was looking for. After learning how to work with JSON and the wordnik api i got it all working!
If npm adds something like that I'd probably switch back. Hard to imagine life without it!
I designed a set of exercises to help my coworkers quickly spin up on syntax and simple patterns in 3 kung fu style forms. Perhaps this would help. https://github.com/cmstead/jsLearnerForms
Read the MDN docs :) Seriously!
so basically hashing is making checksums which work good for uuid's, but if u need to restore the string u need inflation/deflation libraries `www.npmjs.com` typically you would optionally use gzip/bzip then md5/other_hashing_algorithm on it.. however this popped up on hackernwes recently and probably would work good for u, im suprised i found the link at all https://github.com/sirrodgepodge/arrayCompress pseudo code, probably doestn work.. var c= require('array-compress') var mycompress = (str) =&gt; c.compress(str.split('')) // have to split this first var myinflate = (str) =&gt; c.inflate(str).join('') somestr = 'asdfasdfasdfasfd' uuid = mycompress(somestr) console.log(uuid) console.log('restored/inflated: ', myinflate(uuid))
The package lock also allows you to effectively pin versions of transitive dependencies as well, even if you pin in your package json.
Because that only pins your direct dependencies, but not the dependencies of your direct dependencies We lost a morning once when our builds suddenly started breaking, even though our package.json had all the dependencies fixed. Turns out one of our sub dependencies depended on uglifyjs, which just released 2.6.3 that [contained a bug](https://github.com/mishoo/UglifyJS2/issues/1154) Shrinkwrapping ever since before switching to yarn's lockfiles
When I was the A/B test engineer for Travelocity I wrote all my experiment and automation code to run directly in the browser. I could create automation to seamless manipulate a page in drastic ways the user wouldn't notice as well as walk up and down the shopping path almost too quickly to notice unless you were watching the address bar blink with changes in sub-second time. If you are solid with the DOM you can really write any sort of automation that executes too quickly to realize things are happening. With a headless browser you can use these same capabilities to write bot logic that surfs websites pretending to be a user and doing things on the page with almost all the same interactive capabilities of a user. These capabilities could be used for malicious things. One big distinction is that you can arbitrarily fire a click, blur, or focus event but that execution is not associated with a mousedown event. Since you can only arbitrarily fire click, focus, and blur events you cannot command execution of other events like mousedown. It is important to keep in mind that page surfing bots already exist, of which many are for malicious things. The google spider could be malicious if it is too greedy and sucks up too much bandwidth when indexing content. It is up to the publisher (server) to defend themselves from any threat. If bots are a threat and you aren't taking appropriate action then you are a victim, which certainly isn't the fault of a tool developer.
Thanks a lot that is very reassuring. I was not confident to finish my phantomjs books before reading your post.
Did they care that you were using it? As long as they don't have to use it themselves, or maintain your code, why would they care?
I'll second Secrets of a JavaScript Ninja, 2nd Edition. Fantastic book. 
Flawless.
Nah. Write hardware in Javascript. That way you can actually show people your skills without having to bring your computer. 
Dang, this could be good. I just wish the sure were more phone friendly.
Maybe i'm missing something but why isn't it phone friendly?
Look for Tessel.io :)
I've used the wordnik.com api for years and it's always treated me right 
Getting to grips with a new tool can be a daunting task, and sometimes you feel like you discover a whole new set of rabbit holes when you feel like you're finished exploring. Instead of starting with the documentation, I recommend finding an example (or even better, a tutorial) that seems related to what you want to do. Even if it's not the same exact thing, you can learn about the building blocks and mindset you need to use the tool effectively. [This](https://developers.google.com/apps-script/articles/mail_merge) seems like it would be a pretty good starting point, but I'm mostly guessing. I would recommend checking out the tutorial above and giving your original idea another go afterwards, but I also wrote a bit about the error you're getting in case you're interested. ---- From what I can see of your minimal code (which I normally appreciate, but in this case it's hard to tell what you are trying to accomplish and when you want it to run), you are trying to access the `FormResponse` property on your `form` object, but that property does not exist. JavaScript initially doesn't mind that, but it breaks down when you try to access `withItemResponse` on it - this is where your error comes from. `form.FormResponse` is undefined, and so it does not have a method named `withItemResponse`. This isn't very strange - `FormResponse` is not a property of the `form` object. It is a name for the type of data returned by `form.createResponse`. In order to get a `FormResponse`, you need to call `form.createResponse` (which you already do) and *keep* the result: var formResponse = form.createResponse(); You'll then use that object whenever you want to call any of the methods defined on the type `FormResponse`, like `withItemResponse` and `submit`: formResponse.withItemResponse('Core Teachers', logSummary); formResponse.submit(); However, you are misusing `withItemResponse`, which expects a single argument of the type `ItemResponse`. To get an `ItemResponse`, you need to have the original `Item` (the form field, more or less) and then call `createResponse` on *it* as well, keep the response, and then use that as an argument to `formResponse.withItemResponse`... this is when I decided to leave the exploration of the rabbit hole to someone else.
The docs are unusable - the frameworks fine. 
&gt; Can I write this kind of stuff ? No, your `render()` function or your stateless component should return something renderable (JSX, null, string, etc.). Although that setTimeout will be executed the return value from it won't be inserted at that point in the code. That's not how React (or JavaScript) works. The way React works is that your render should only change because the props/state have changed, so you need to model the decision to display `&lt;p&gt;Hello&lt;/p&gt;` from a variable in props or state. Here's an example using state, class Welcome extends React.Component { constructor(props) { super(props); this.state = { revealText: false, } } componentDidMount() { setTimeout( () =&gt; { this.setState({revealText: true}); }, 1000); } render() { return ( &lt;div&gt;{this.state.revealText &amp;&amp; &lt;p&gt;Hello&lt;/p&gt;}&lt;/div&gt; ); } } (the `&amp;&amp;` syntax is like an shorthand `if`... it's an alternative to writing `{this.state.revealText ? &lt;p&gt;Hello&lt;/p&gt; : null}` More generally if you're trying to do animation then considering something like the [React animations addons](https://facebook.github.io/react/docs/animation.html). 
JSX is not JS. React is a bad idea.
That seems interesting. What about adoption/downloads/users/tutorials etc.? How does it fare compared to something like React or Vue?
Whoosh
Thanks, this clears up a lot. It's a shame you the Yarn developers didn't jump in, although it does sound indeed like it probably wouldn't have been that easy at first either. Then again, now they're stuck with maintaining a package manager that might lose a lot of the interest it initially gathered, so...
Almost all of these libraries (React, Vue, Mithril, Inferno, ...) can use a hyperscript-like syntax to generate their virtual DOM representations, so you may even be able to implement your components in a library-agnostic manner and then supply bridges for the various different frameworks. If you don't want to go that far, and your primary goal is to make your library usable by as many people as possible, you'll want to go with React, since it's the most popular of these libraries by a (very) large margin. React currently isn't the most _interesting_ of the crop, but there's some cool stuff coming up in React 16 that may change this.
Those answering on SO are doing it for fun in the spare time. Don't expect instant answers.
I think it depends on the learner, and there's nothing wrong with different learning styles and preferences. One of the problems with current educational practices is that it shoe-horns everybody into one learning technique, regardless of how suitable that is for any individual student. It's most obvious to me in foreign language instruction. I am a very visual learner. I have to completely understand the grammar of new input to be able to make sense of it. I take extensive and carefully organized notes, even if I rarely look at them again. The process of taking notes is important for me to learn. I frustrate language instructors because I get hung up on low-level details, when the key to language proficiency is really to just produce, have what you said or wrote corrected, and repeat. I have a lot of difficulty gaining fluency. I have a friend who's exactly the opposite. He is a completely aural learner. He can understand the basic syntax of a language he doesn't know just listening to a bit of it. He gains fluency relatively quickly, and people find speaking to him enjoyable because he captures idiosyncrasies of a language relatively easily. But I am generally more accurate in translating someone's exact meaning. I typically remember not only words in the target language, but when and from whom I learned them, a wide variation in meanings, etc. I learn CS topics best by reading books, taking extensive notes, organizing and rewriting those notes, writing (and compiling/testing) code samples as I go along, and looking up *anything* that I don't feel 100% on in the process, no matter how elemental it might seem. I've tried instructional videos; they don't do much for me, but other people find them really valuable. So my answer is to discover what style of learning is the best match for you. 
&gt;Naming all your variables a single letter would be unreadable. Having single functions hundreds or thousands of lines long is unreadable. we could both write a several hundred line function that's **readable**, but not easily **maintainable** or **testable**. i think that's what you were getting at.
I learned JavaScript using the method I outline in this Blog Post:[How to Learn as a Software Developer](http://www.acucciniello.com/2017/05/19/How-to-Accelerate-Learning-as-a-Developer.html) I hope that helps.
i think using NODE_PATH=lib is an alternative worth considering, assuming this is a node project and lib is the folder where all the code lies. you can also specify multiple node paths with a colon if needed.
I personally think reading to learn is a very inefficient way to learn a topic like web development. The best way to learn is by doing, doing, doing and then doing it again. That's how you can build a skill. Reading will only get you so far.
Thank you for laying it out for me. It is a long program that calls a lot of data out of a spreadsheet, so this is the best I can do. I tried it this morning and it is now returning a new error - "Cannot find method withItemResponse(string,string)." I was curious so I put a Logger in for formResponse ------------------------------------------------------------------------- var formID = row[24]; var form = FormApp.openById(formID); var formResponse = form.createResponse() ; Logger.log(formResponse) Logger.log(formResponse.toString()) formResponse.withItemResponse('Core Teachers', logSummary); formResponse.submit(); -------------------------------------------------------------------- The logger returned "FormResponse" which must be an object. I need to figure out how to edit that object. I will look into trying to call up the individual questions and create a response to them. I'll get back to you with hopefully the solution. Thank you for the help so far! Update: Looking at the documentation more, there is an "itemID()" for each question on each form. These must be the way you access the attributes that you need to call up within "FormResponse". Sigh. 
Well, my concern is that Vue might fit my target demographic better (lighter web apps), but React is definitely more used. The library agnostic thing sounds really cool, could you elaborate a bit?
Also React's code is fairly verbose for what it achieves: https://github.com/funkia/turbine/pull/48
If you're looking for compactness and global usability, why not go with [web components](https://www.webcomponents.org/)? They (should) work with every framework, and for those without frameworks, since they're normal HTML elements.
Limited time, mostly! Thanks, I'll check this out!