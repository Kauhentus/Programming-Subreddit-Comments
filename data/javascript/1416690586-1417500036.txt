The most common example is finding the sum of an entire collection. function add (a, b) { return a + b; } [1,2,3].reduce(add); // -&gt; 6 It's extremely useful when you want to perform a constant operation against a collection, where you ultimately want to boil it down to a single value (as opposed to .map() which just applies that function independently to every item in the collection). I personally use it a lot when manipulating objects, as it saves you from having to define and modify a temporary variable (which means your operation is more pure). Another couple of examples (ignoring native methods): function min (arr) { return arr.reduce(function (memo, val) { return memo &lt;= val ? memo : val; }); } min([5,1,4,3,2]) // -&gt; 1 Compare this to another (common) solution, it starts to become clear why .reduce() is cleaner. function min (arr) { var lowest; for (var i=0,len=arr.length; i&lt;len; i++) { lowest = (!lowest || arr[i] &lt; lowest) ? arr[i] : lowest; } return lowest; } Safely get a deep property (using Ramda here) function getPath (path, obj) { path = _.isArray(path) ? path : path.split('.'); return _.reduce(function (memo, prop) { return (memo &amp;&amp; _.has(prop, memo)) ? _.get(prop, memo) : undefined; }, obj, path); } var test = { key : { subKey : 'hey!' } }; getPath('key.subKey', test); // -&gt; 'hey!' 
Welcome to PEG! http://en.wikipedia.org/wiki/Parsing_expression_grammar#Operational_interpretation_of_parsing_expressions
It's always nice to keep the same convention when multiple users work on the same project. That's why you can tell jshint to look up the parent directory for a `.jshintrc` file that may be included in the project. So adding to the IDE is one thing, but making it a part of the build process is better.
A reduce function takes a collection as input, and using just that input, derives and returns a single value. 
Which libraries should be selected? How would they be installed? How would they be referenced by the underlying Javascript engine? What happens when a library updates? What if a library gets abandoned? What if there is a major security hole in the library? What if native support for a given library introduces a major security hole? What if there is a conflict between that library and the libraries being used for a current project? What if a user turns javascript off in their browser? What if, what if, what if, what if... Web code is far less stable than other types of code, and far more dynamic. New popular frameworks arise in months, where browser releases can take as long as a year or more. A secure and responsive browser is a large and complex endeavor, and including external javascript libraries by default adds far more problems than the minor convenience it might give to a developer. The things you write off - library versioning, licensing, and install size - are actually extremely complex and challenging things to manage at a business level. All to save one additional fetch of a url from a well-established library website.
Neat, didn't know `npm version` accepts "patch"/"minor"/"major" in addition to version numbers. 
Oh, got it. Yeah, that is confusing, hmf. :/ 
that's two sentences joined with a comma lol
That's why CDN and browser cache are a good thing. If you use a library hosted on a CDN, and the user already went to a site that used the same library from the same cdn, the browser already has it.
I guess the article was more an exercise/teaching tool than a real implementation. I don't see why all this complexity is necessary to generate so simple a contract. To generate unique IDs, I personally use the code found here: https://gist.github.com/jed/982883 What I like about this gist is that there is a nice discussion showing the evolution in the implementation. The goal being to make it as small as possible. This is a good teaching tool also, but with a real useful result.
Just fyi, there's absolutely no such guarantee and I'm doing this project for fun and educational purposes. The website states clearly that it's a work-in-progress. And you definitely should NOT use it for any real projects. But if there's enough interest in the language, I hope that we can create a community around Spider that will build and maintain it.
It's just reddit though. Other communities were super positive about this project.
oh sure, it's just "come back when you've got a community" isn't an attitude that sits very well with me. if so, we'd get nothing but jQuery and angular content. 
Woah, deja vu. 
Very valid points. &gt; Which libraries should be selected? I'm imagining that there would definitely have to be a lot of community involvement as far as selection of libraries. &gt; What if there is a major security hole in the library? If the only things being included were JavaScript, HTML, and CSS, and they were from thoroughly tested and validated libraries (e.g. jQuery UI), I'm guessing security concerns would be no different than including the library any other way. &gt; What if a user turns javascript off in their browser? Yeah, this would be a concern, but I wouldn't see it as *more* of a concern than it is currently. &gt; The things you write off - library versioning, licensing, and install size - are actually extremely complex and challenging things I can't disagree with you on these points. But most companies that produce browsers are well established financially and have smart lawyers and programmers working for them :)
If different versions of libraries were included, the developer could choose which one to use though, in the code they implement, and change it whenever they please.
Are there such things as JavaScript to \[insert language\] compilers? Just curious
Yes, CDNs are great, but if your site uses a lot of JavaScript, you're kind of left *crossing your fingers* that your users already have the libraries cached, so your page loads quickly when they hit it.
So perhaps like this? http://jsfiddle.net/ynmjmwj5/ I don't know what to put inside the if statement if cell1 is true. I know in my head it is you cannot place an X or an O but I don't know how to say it. 
Your if statement has 2 problems if(document.getElementById("t1").innerHTML = ""); Single equal and a ; at the end. Try this http://jsfiddle.net/78pu4y7t/9/ I would recommend downloading WebStorm or any other IDE. It would highlight and explain problems like that.
I still don't get the point of these intermediate languages. IF you learn one of them first, you have an incomplete understanding of JS, and if you already know JS, why would you abstract it?
Question: The general rule of thumb is that major versions break backwards compatibility. Is this like "One old function is being deprecated." or like "A lot of the old stuff doesn't work anymore." I'm assuming it's more for the 2nd, right?
Flux is a design pattern that enforces unidirectional data flow (through the Dispatcher). It makes it easier to understand how non-trivial apps work because there is one source of change in the app (one "source of truth"). State resides in the stores. View components get their state from the stores. Stores get updated by actions via the dispatcher. It isn't necessary, and it does have a learning curve. But, as soon as your application grows (in complexity and with the #of people working on it), it will be much easier to understand. I like Facebook's chat example. https://github.com/facebook/flux/tree/master/examples/flux-chat The api is faked, but the infrastructure is there for communicating with an outside source. Good luck!
I think it's less about some code that instantly runs and more about protecting certain variables. Since javascript doesn't have public/private/protected type indicators on members in an object, you can kind of fake it by declaring variables inside functions like that, but only exposing certain objects on the return of that variable. That being said, your examples could generally do the same thing, but in the case of the function in question, it isn't named, and therefore isn't runnable a second time without copy-pasting the entire codeblock into a console. your example allows you to run that function whenever you want, and if that function is, say, a setup function, running it repeatedly could potentially do more harm than good. Ultimately though, it should be entirely up to the programmer how they intend for the code to be used (as usual)
They're known as self-executing anonymous functions or [immediately-invoked function expressions](http://en.wikipedia.org/wiki/Immediately-invoked_function_expression). Short answer, it creates a new context for when you want some privacy, but don't necessarily want to declare a function you won't reuse.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Immediately-invoked function expression**](https://en.wikipedia.org/wiki/Immediately-invoked%20function%20expression): [](#sfw) --- &gt;An __immediately-invoked function expression__ (or __IIFE__, pronounced "iffy") is a [JavaScript](https://en.wikipedia.org/wiki/JavaScript) design pattern which produces a [lexical scope](https://en.wikipedia.org/wiki/Scope_(computer_science\)) using JavaScript's [function scoping](https://en.wikipedia.org/wiki/Function_scoping). Immediately-invoked function expressions can be used to avoid [variable hoisting](https://en.wikipedia.org/wiki/Variable_hoisting) from within blocks, protect against polluting the [global environment](https://en.wikipedia.org/wiki/Global_variable) and simultaneously allow public access to methods while retaining privacy for variables defined within the function. This pattern has been referred to as a __self-executing anonymous function__, but Ben Alman introduced the term IIFE as a more semantically accurate term for the pattern. &gt; --- ^Interesting: [^JavaScript ^syntax](https://en.wikipedia.org/wiki/JavaScript_syntax) ^| [^Anonymous ^function](https://en.wikipedia.org/wiki/Anonymous_function) ^| [^Scope ^\(computer ^science)](https://en.wikipedia.org/wiki/Scope_\(computer_science\)) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cma8vj2) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cma8vj2)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
You know what else compiles to JavaScript? JavaScript.
&gt; The goal is to build a cool new language that fixes the bad parts of JavaScript. Then drop one `for` syntax? They could leave let's say `for in` and let it work for anything (object, arrays, generators). Then for keys you could use `for x in file.keys()`, or `for x in file` giving `{ key, value }` that would be even more useful. As for other features -- `super`/inheritance is available in ES6, other features seem nice to have but nonessential, e.g. ranges can be easily implemented as a JS library. Code safety is nice but the scoping part is something JSHint/other tools can do for ES (`==` can be banned through JSHint as well). Of course it is better to have it in the language, but I'd rather have a more restricted version of ES than a completely new syntax. I do really like existential operator, but I still hope it will get into ES7+ at some point. What about ES6/7 features though? Modules, more interesting string interpolation ('tagged templates'), generators, async/await (potential for ES7)?
Just for [incompatible API changes](http://semver.org/), so only the 2nd scenario.
It seems to me like having a named function, even if only used once, makes stack traces easier to read. edit: for stack traces the IIFE can still be named, but maintain the "private" nature. So thank you for the help.
Wouldn't the variables be protected anyway since they are inside the scope of the newly defined function (like in my second two examples)? I'm not questioning you, I'm just trying to understand it better. ~~I also think a named function makes stack traces easier to read. Do you think that is a worthwhile tradeoff?~~ edit: The IIFE could easily be named for debugging, while still protecting the function from running again since the named function is undeclared outside of the IIFE. So I think I understand, now. 
There are a few things at play here: * **Anonymous** - The function is not assigned a name so it cannot be called again and does not remain in memory. * **Brevity** - The code is concise. You may not be familiar with the notation but once you are the code will be easier to read than the alternatives you listed. * **Inline** - You can create this function and execute it within the context of, for example, passing a parameter. * **Scope** - Often the purpose of a throw-away function like this (known as an IIFE) is to provide a new scope block for encapsulation. In JavaScript there is only the global scope and scopes created by functions. In the new ES6 spec there will be a new keyword *let* that can be used in place of *var* to define a variable scoped to the most recent curly brace block. So if the purpose is to encapsulate variables, the following statements would both work: // current method alert((function(){ var foo = "hi"; return foo; })()); alert(foo); // reference error // ES6 method { let foo = "hi"; alert(foo); } alert(foo); // reference error // will not restrain scope { var foo = "hi"; alert(foo); } alert(foo); // valid code
Thank you, and everyone who upvoted! It's taken just about [two years](https://github.com/bigcompany/big/commit/505ee581c9546172b4233e65e4e355580adc0b3c) of developing the dependency tree to get to where we are today. The hook.io project is a major piece of the software stack I have been developing for [big.vc](http://big.vc). Using this same software, I've also built an open-source crypto-currency bank called [safewallet](https://github.com/bigcompany/safewallet). I look forward to seeing where this will all be in two more years.
Here is another example: http://jsfiddle.net/1pq8kr7m/
Good example. Power of closures in its briefest form ;)
Yes, they are.
 for(var i = 0; i &lt; 10; i++) { setTimeout(function() { console.log('Waited:', i, 'seconds'); }, i*1000); } for(var i = 0; i &lt; 10; i++) { (function(i) { setTimeout(function() { console.log('Waited:', i, 'seconds'); }, i*1000); })(i); } These two loops should do the same thing, right? Nope! Run both and notice the difference. This is where closures are super useful, async functions where the scope may change, but you need access to the the scope as it was when the async function was called, not what it is when it finally executes (or returns a callback, or whatever it may be doing)
I'm a bit outspoken and sometimes attract people to go through my history and downvote every post I make. I noticed this happened again recently. Really sticks out on the specific small subs. I don't care really, but this is likely why it was downvoted a bit. 
It's basically a loop that keeps track of the last value (not necessarily the last value of the array index, but the last value of your accumulation). The difference between a loop and a reduction is that the goal is to "reduce" the collection into a single value that represents something about it through the form of a function that keeps track of a variable that gets maintained per iteration, and the current item in the array. Think of it like this: var collection = [1, 2, 3]; var reduction = 0, current, i; for (i = 0; i &lt; collection.length; i++) { current = collection[i]; reduction += current; } versus var reduction = collection.reduce(function (prev, current) { return prev + current; }, 0);
The first example, the IIFE, is slightly more concise, but most importantly, it's an expression (ie. can be used inline). Function declaration obviously aren't expressions. You're right in noting that anything you can do with a function expression you can also do with a function declaration (and a little extra code), but many developers find using function expressions easier in certain circumstances. I personally don't find myself using IIFE's very often at all.
Not a single sentence, but: If I have a list of numbers, and I want to add them all up, I would `reduce` them with with a function that adds two numbers: I'd start with 0 and run my function to add 0 to the first number, then again to add that result to the second number, then that result to the third number, and so on until I had the final result. `reduce`, in general, takes a function (like our adding-two-numbers function) and runs it across a list like that, keeping track of each result as it goes to help summarize a list. It might be more useful for some folks (varying learning styles) to help explain this graphically: Given a list: [1, 2, 3, 4], a starter point 0, and a function (_ + _): [1, 2, 3, 4] 0 | | | | + 1 = 1 | | | + 2 = 3 | | + 3 = 6 | + 4 = 10 Yes, a `reduce` or a `fold` is more generalized than just summing numbers, but it helps to start with what people can conceptualize easily.
Naming a function expression also allows you to call it recursively from inside the function and/or access its properties. These are rare in the wild, but useful to know about: http://raganwald.com/2014/10/24/fun-with-named-functions.html
This would be a fucking nightmare on so many levels. You probably didn't think this through very far or are extremely junior.
I would recommend to use [c3 js](http://c3js.org/) it is more easier to implement and there is also good documentation available.
sinon can mock pretty much anything. Can you provide more details? 
&gt; does what it says on the tin, That is a pitifully pointless statement. What, instinctively, does "reducing an array" actually mean to someone that has never heard of this kind of behaviour before? If anything it could mean to flatten an array. The fact that many languages have their own names for this behaviour should tell you it is not so obvious. Walk(), Aggregate(), #inject:into:, foldl. All of those are synonyms for the same behaviour from different languages. If it was so obvious that it "does what it says on the tin" they would all have the same name.
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 4. [**Special folds for non-empty lists**](https://en.wikipedia.org/wiki/Fold_%28higher-order_function%29#Special_folds_for_non-empty_lists) of article [**Fold %28higher-order function%29**](https://en.wikipedia.org/wiki/Fold%20%28higher-order%20function%29): [](#sfw) --- &gt;One often wants to choose the [identity element](https://en.wikipedia.org/wiki/Identity_element) of the operation *f* as the initial value *z*. When no initial value seems appropriate, for example, when one wants to fold the function which computes the maximum of its two parameters over a non-empty list to get the maximum element of the list, there are variants of foldr and foldl which use the last and first element of the list respectively as the initial value. In Haskell and several other languages, these are called foldr1 and foldl1, the 1 making reference to the automatic provision of an initial element, and the fact that the lists they are applied to must have at least one element. &gt; --- ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cmafuff) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cmafuff)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
A simple example I've seen in the wild for this is to create lists of elements for writing (to screen, console, or even file). I also do this all the time when debugging in whatever language I am writing in, most notably in C# (where it is called Aggregate) as that is my bread winner at the moment. aCollectionOfElements.reduce(function (previous, current) { return previous + "&lt;li&gt;" + current + "&lt;/li&gt;"; }, ""); // empty string so that the first element is set to 'current' on the first iteration and thus gets wrapped. Creating your own sum() is, in my opinion, a pointless demonstration as nobody does that.
I think I got it. The image was probably loading too fast. I put the initApp() call inside an onload function with the image. Here is the code I added after getting the tileSetImage source: tilesetImage.onload = function () { initApp(); }
A wild demo appears: http://instructure.github.io/react-tokeninput/
I won't cram this into a single sentence, but one sometimes-useful way to look at reduce (ignoring side effects) is as providing a state machine: the initial value is the initial state. The array is a sequence of events. The reducing function tells, given an event and a current state, what the machine's new state will be. The result of reducing is just the final state of the machine when started in the give initial state and exposed, in order, to the sequence of events in the array.
Not exactly what you're asking for, but one of [CasperJS' own examples](http://casperjs.readthedocs.org/en/latest/quickstart.html#now-let-s-scrape-google) is essentially scraping Google. That is also the site for the rest of their docs.
I've run into this logic before, by C++ developers that wondered why anyone would use Java or C#. If you follow it back to it's conclusion, then we really don't need to use anything beyond plain C. Probably a lot of people would agree with that.
Pretty sure that's generated from a peg grammar. Why are you laughing?
Semantically, javascript just royally fucked those words up. He's being consistent with Coffeescript, which for better or worse gets those keywords right.
I believe that for mobile apps Canvas is the way to go. It keeps the DOM slim and it utilizes hardware acceleration. I had good experience with Chart.js. It's still a new project and there is good docs on the website. The options are limited and you have to know how to handle a canvas to extend it. 
In /u/gordonkristan's example the function doesn't return anything so the output is undefined. It should be: var incrementCount = (function() { var count = 0; return function() { return ++count; }; })(); The pre-increment would return a 1-based counter, a post-increment would return a 0-based counter.
mocked methods have to be attached to an onject IIRC, see https://github.com/cjohansen/Sinon.JS/issues/562
This answer made a lot of sense when I read it and should be emphasized, I think, to help OP: &gt; ...**reduce replaces commas in arrays with function calls** This turns the following: [0, 1, 2, 3, 4].reduce(function(previousValue, currentValue, index, array) { return previousValue + currentValue; }); Into: 0+1+2+3+4 (in a way...)
The major difference is that C# and Java don't compile to C. They are their own languages. CoffeeScript, et al are just abstractions of Javascript. 
https://github.com/thlorenz/proxyquireify/issues/15 plugging it in with karma &amp; browserify is my concern, it works great otherwise!
The advantage of `for-of` syntax is that you can simply do: for prop, value of object I think you'll agree that this is much cleaner than `object.keys()` or an object with key and value. Inheritance is available in ES6 with classes. Spider embraces prototypes instead. Which is compatible with any class system btw Note that ranges are extremely useful when it comes to array slicing and splicing and switch statements. About ES7 features - this language is still just beginning. Features like modularization, async/await and maybe even Go-like channels are upcoming.
JavaScript is always concurrent, single threaded, and runs the Internet, there is no choice for most of its use cases. The distinction between immutable / mutable data structures has become an important topic in modern UI programming for the web. One example is the use of DOM diffs, which provide a foundation for functional styles of UI programming based on state (React / Om). It simplifies development, while increasing performance and complexity of applications, all of which are run in a single threaded, async environment where the amount of potential state changes of an average webapp is estimated to be around the number of atoms on Earth. Immutability, not in the literal sense of object.freeze, but in the clojure-esc sense of pointers within a tree, maps on much better to the DOM tree than an "object". It allows for computationally cheap equality comparisons and map/reduce/filter chaining. It's important for 'the Internet of things' where computations must be efficient while maintaining programmer sanity and an ability to synchronize distributed systems without losing data or applying computationally intensive algorithms to solve the hard problems. 
grunt or gulp
Finally a language the compiles to javascript that Douglas Crockford might approve. Embracing javascripts prototype-based OOP is a good choice.
You may like my book “[Speaking JavaScript](http://speakingjs.com/es5/index.html)” (free online) whose target audience are people who already know how to program. JavaScript looks like Java and other C-like languages, but it works quite differently: * The scope of a variable is the surrounding function, not the surrounding block. * Functions work fairly straightforwardly, but parameter handling often involves manual work. * Arrays are unusual in that they are maps from numbers to values and not sequences of elements. You don’t normally notice that, but you have to be aware of it. * OOP is completely different from the mainstream. This is where you’ll need to invest the most time. JavaScript is a sparse language with many quirks. But it is also a pleasantly dynamic and lightweight language. One of its greatest features is that you can directly create objects (no need for classes), which is nice for quick experiments. 
I use IIFE mainly for 2 reasons: 1. So I can specify `"use strict"` on my whole file in one go. 2. So that I don't pollute the global namespace.
FYI there's jquery load function: $(tilesetImage).on('load', initApp);
Right. A function's variables surviving the function's death (via so-called _closures_) is not something that has ever tripped me up (coming from C++ and Java). Other features are much trickier, IMO.
What does the last parameter (0) represent in lodash's `reduce`?
Variables initialized with 'const' instead of 'var' was supposed to indicate immutability. I'm not sure if any browsers enforce that rule. Informally I use $ for 'state' objects, which are mutable, and _ for immutable objects. I prefix them with those symbols, like $turkey and _prop. 
One thing that the other responses don't address is that sometimes you just want a singleton. Singletons are often a bit of an anti pattern, but sometimes you do just need a module that runs once, particularly when instantiating various objects that exist in your page's architecture. You only have one DOM so it makes sense to only wire that DOM up to objects once. The other matter is convenience. Having to name a function and then run it is less handy than just running a scope inline. Your assertion that the function has to be anonymous on the stack trace is incorrect, by the way, because named functions can be used as IIFEs. Finally, IIFEs make clear to a reader that a function is run only once, so they don't need to worry about what might happens if it's called twice or more times. This is sometimes relevant if a reader is uncertain about the lifespan on symbols created in that function. Anything which tells a developer that they only have to reason locally is a great aid in making things easy to understand.
In unstrict mode you may also use arguments.callee.
&gt; turkey Thanksgiving on your mind? 
Did you think about a more natural langage than json ? Somethings like: &gt; !include path=hello.md Also, testing code examples could be à good feature 
It is the initial value of the accumulator variable. In this case, the value of the sum starts at zero.
Maybe post it in http://jsfiddle.net/
Aye, i ended up implementing a webview to be able to draw onto the canvas. Seems to respond well. 
&gt; It's a pretty wonky language since it's scope is not stack dependent, so stuff 'exists' when I would not expect it to, and vice-versa. If you are coming at JS from a C/C++/asm mindset then it is probably better to focus on what the language *semantics* say instead of worrying about how you think it is executed at runtime. In C/C++/asm the language model and the runtime execution model are so closely fused together they end up looking like the same thing. In high level languages what happens at runtime can be quite surprising. It is best to keep your eye on the language, for example, stop thinking about stack vs heap allocation. 
We can't help you without the full source code. There are lots of places to put it. http://jsiddle.net (like MadCapitalist suggested) is a good one where you can run the code as well. If that's not to your liking, then just throw it on http://pastebin.com
Wait for the city (after the second tunnel). Worth it. Also, [totally works on mobile](http://imgur.com/863gouw)
holy shizzles
Very true, have an upboat. Leaving aside the question of `"use strict"`, one problem with `arguments.callee` is that it is scoped to the function being immediately called, just like `this`. For that reason, it breaks if you try to use it inside an IIFE, in a callback expression, inside a function being passed to `.map`, and so forth.
That's a bit of a flaw... Don't worry, I'm sure /r/javascript will help you out.
Thanks for the suggestion. I'll definitely use that site in the future. For now, I managed to contact a friend who was able to help me out with the issue. Thanks again!
Glad to hear it!
CC doc comments are just way too annoying to write. Flow has zero Windows support. Out of those four, your best bet is probably TypeScript with AtScript as a possible upgrade path.
forms and their inputs appear as properties in `document`. Named items go further and can be queried directly: &lt;form name="myform"&gt; &lt;input type="text" name="bilbo" value="baggins"&gt; &lt;/form&gt; &gt; document.forms[0][0].value //-&gt; "baggins" &gt; document.myform.bilbo.value //-&gt; "baggins"
Note: no standard for type annotations has been proposed, yet. * TypeScript is very much about making JavaScript more appealing to people coming from Java, C#, etc. In addition to static typing, it also supports several ECMAScript 6 features. For example: classes and modules (but modules don’t yet support the final ES6 syntax). * Flow does a much deeper type inference than its competitors; it is thus even useful for completely unannotated (existing) code bases. Flow itself is only a type checker: it can analyze ECMAScript 6, but it doesn’t compile it to ECMAScript 5 (like TypeScript does). * AtScript supports both type annotations and meta data annotations. Currently, AtScript’s support for ECMAScript 6 is much more complete than TypeScript’s. TypeScript only keeps the type annotation data at compile time and throws it away afterwards. In contrast, AtScript takes extra care that both type annotations and meta data annotations can be accessed at runtime (which AngularJS needs e.g. for dependency injection). AtScript is still work in progress and the least mature of the four projects. It is not yet clear how much static type inference it will perform (versus runtime type checking, which it will definitely perform). * The Closure Compiler is focused on ECMAScript 5 (versus ECMAScript 6 being the focus of the previous three projects). The code it operates on will run as is in any modern browser (without compilation). The good news is that TypeScript, Flow and AtScript have declared their willingness to work together on a common syntax for type annotations. That syntax _may_ eventually become a standard. In case you are interested, I’ve explained how TypeScript, Flow and AtScript work in more detail in a [blog post](http://www.2ality.com/2014/10/typed-javascript.html).
There are plans to transpile Flow to JavaScript (from O’Caml), at which point someone may write an implementation that is truly cross-platform. A killer feature of Flow is that it is even useful as a consistency checker for completely unannotated code bases.
&gt; you already know JS, why would you abstract it? To program in a better language?
Why do you have both ``` (x) -&gt; x ``` and ``` this.printName = () =&gt; ``` ?
Someone asked what will happen once all modern browsers support ECMAScript 6. Answer: compiling to ES5 will still be useful, to support legacy browser. Otherwise: * Flow doesn’t compile and profits from native ES6 support. * TypeScript won’t need to compile, anymore (except for removing the type annotations). It will continue to work with static type information at compile time. * AtScript will compile much less, it will only generate the statements that create runtime information.
You could try this: function timer(options) { var interval = options.interval || 250; var remaining = options.timeout || 5000; var until = options.until || function () { }; var done = options.done || function () { }; var scheduledTask; scheduledTask = setInterval(function(){ remaining -= interval; var finishTask = until(remaining); if (finishTask !== undefined) { window.clearInterval(scheduledTask); done(finishTask); } if (remaining &lt; 1){ window.clearInterval(scheduledTask); done('timed out'); } }, interval); } // usage timer({ interval: 250, // 250 milliseconds timeout: 4000, // 4 seconds until: function(remaining) { // code to execute console.log('do something') if (remaining &lt; 2000) { // return anything when you want to stop execution return 'done'; } }, done: function(message) { // code when done console.log(message); } }) It uses setInterval to do something until you return a value. the function is reusable, but I would use it sparingly
I usually install [auto-curry](https://github.com/zeusdeux/auto-curry) as the first package. It forces me to think about the APIs I will be exposing in a manner that is reusable and composable. The second package I install is dependent on the type of project. If it's a frontend project then usually it's browserify. If it's a backend node project it's usually mocha. 
I'd steer clear of it -- it's loaded with errata.
Well.. the google page is static with pagination, the twitter search page is dynamic with ajax loading. What i would like is a scraper to either simulate reaching bottom of page (to load new data), then pull more results, or to make the ajax call from the twitter page to gather further data. 
Every language compiles to machine code, which we used to just write directly. They are all just abstractions. 
I don't understand how generators simplify code that is already async and using callbacks or promises. These look almost identical to `yield return` in C#
Seems interesting, but somewhat convoluted in practice. I wonder how debugging this stuff is going to work.
/r/tinycode 
Yes, and that article you linked to is using promises. You still need the promises, generators don't replace them.
Javascript remains my first choice.
Using something like co you can have a sequence that's async but looks sync.
You found solution??
Badly formatted posts are not going to help you or let us help you. Please upload code to jsfiddle codepen or even pastebin. As this is an assignment most of my help will be pointing you at resources you should read. No one here is going to write the full thing for you.
Start using them now and when you eventually end up in dependency hell it'll be an easy way to add in a module loader. 
A couple at least. 
It did a barrel roll at the end. 
[YES](http://www.pedalaweblabs.com/loucoporticorinthians/share/index.html) there are plenty of plugins for social buttons. Not sure about a login ui but I'm sure if you just googled JQuery plugin login UI you would find plenty
Chase HQ
You're on the right track, but your code is overly verbose and difficult to reason about. http://jsfiddle.net/92L1adkg/1/
Yup pretty much what I gathered/expected. I think definitely AtScript and TypeScript are the two major choices. Seeing as AtScript is in traceur already and provides features which TS doesn't, it could be a better choice. Though TS is far better established and aged (but saying that, AtScript supports TypeScript's syntax mostly afaik).
Looking at the source of some js1k demos feels like some programmers are just adding insult to injury when they go through the trouble of handling the mouse and touch separately and handle browser quirks, just to add portability.
Cool stuff. Is the code viewable thru git?
So javascript is as complicated as machine code?
Mind = blown - that was a great article 
Comparable 
Perfect. I appreciate that suggestion. Was simple as copying and pasting an integration script. 
I *hope* it will bring an end to the idea of a "native" application.
Keep in mind that the result of reduce could be an array too. With reduce you can make filter, map, foreach, etc.
The advantage is that it allows asynchronous code to be written like synchronous code would be. The 'classic' version, complete with nested callbacks: console.log("waiting 500ms"); setTimeout(function() { console.log("now making GET request"); //Using jQuery $.get("http://example.com/example.xml", function(response) { console.log("got data", response); }); //I'm not actually sure what the proper error handling is v0v }, 500) The 'modern' version with promises console.log("waiting 500ms"); delay(500).then(function() { console.log("now making GET request"); //Using jQuery return $.get("http://example.com/example.xml") }).then(function (response) { console.log("got data", response); }, function(err) { console.error("GET request failed", err); }) The new generator version: async(function*() { console.log("waiting 500ms"); yield delay(500); console.log("now making GET request"); try { //Using jQuery var response = yield $.get("http://example.com/example.xml"); console.log("got data", response); } catch (err) { console.error("GET request failed", err); } }) Code for the `async` and `delay` functions used above: function async(gen) { var iterator = gen(); //Start the loop next(iterator.next()); function next(result) { if (result.done) return; result.value.then(function(value) { next(iterator.next(value)); }, function(error) { next(iterator.throw(error)); }); } } function delay(ms) { return new Promise(function(resolve, reject) { setTimeout(resolve, ms); }); }
Nice, this seems like something that would work well as a NPM module.
For signup/sign pages, I think there are tons, but they probably tend to be married to a specific library/framework. 
Not accurate for a proper implementation but I help it provides some intuition: collapse a list of values into a single value by iteratively applying a function to the current result and the head of the remaining list. 
None because none of them offer any guarantee of types in the compiled version. A second issue is correctness. As stated in the [Atscript Prime](https://docs.google.com/document/d/11YUzC-1d0V1-Q3V0fQ7KSit97HnZoKVygDxpWzEYW0U/): &gt; Pragmatic Approach: The goal is not to build a type system that is correct 100% of the time. Rather, we want to be flexible and useful in the vast majority of real-world scenarios. Why use a type system that isn't provably correct? Flexible and 'mostly works' means that corner cases (where you really want typing) aren't any better. A guarantee that isn't a guarantee is worthless. My solution is to add a haskell style typing to the language using string literal statements (like 'use strict' or 'use asm') which gives a guarantee and as a bonus, is completely backward compatible with current browsers (meaning that your shipped code has guarantees instead of pseudo-guarantees that are lost during compilation). 'type foo = (Number -&gt; Number), [Number], Number -&gt; Number'; function foo(fun, bar, baz) { 'type x = Number'; //either here var x = 5; 'type x = Number'; //or here return x + bar.map(fun) + baz; //also needs deftype, defdata, defclass, type variables, etc } 
I am really loving [Pelican]( http://blog.getpelican.com/) for my blog. 
Been using co on the server side, would love to start using it natively client side too.
Hey man, I just wanted to let you know that this is legitimately the first compile-to-js language that I'd consider using for real, just based on your design document. I really like the feature set you have here, and it's not so different from javascript that the syntax is foreign. I'd be interested in helping out if I ever get time, which to be honest isn't that likely, but I'll definitely be watching. I hope some day it gets enough momentum to be usable in a prototype project or even production.
It'll still never be a straightforward - and therefore useful - object orientated language... Just some confusing mess of prototypes. Have you tried inheritance and interfaces, and abstract classes in JavaScript? It's all bollocks. Bloody JavaScript.
This is possible.
Ideabile (Italian) = something like ideable (English)... 
I use the Facebook comment plugin on my blog. Works as expected. I use this over disqus because there are more people with Facebook accounts than disqus accounts. https://developers.facebook.com/docs/plugins/comments/ 
Less code = better code? Make something more readable, easier to maintain or faster doesn't always result in less lines of code.
The point isn't that it is shorter. The point is that in the generator version you can just follow the logical flow of execution from top to bottom as though the code were synchronous code. It is much easier to read and follow the order that things happen occur in. There is also fewer scopes to deal with. 
That's like complaining about how a submarine isn't good at flying.
Javascript will move on from just powering web servers. There will be node-powered SQL databases, pure-Javascript backbone routers (no, not *that* [Backbone Router](http://backbonejs.org/#Router)), and in three years time, ES6 will be the official implementation language for all onboard systems on SpaceX rockets.
One advantage of TypeScript is IDE support (e.g. Visual Studio, WebStorm).
For example: https://medium.com/este-js-framework/whats-wrong-with-angular-js-97b0a787f903 The author is google developer expert.
[Este.js](https://github.com/steida/este) is a new stack build on react that should be investigated...
Well AFAIK Este.js does not have documentation and I was quite confused, what it really does and how to actually use it. I prefer larger community and mature staff.
Being a GDE doesn't mean anything other than being an enthusiast in one of their projects, I thought? I disagree with most of what he's written tbh. Angular is easy to learn. HTML isn't used in some magical way like he seems to describe, its still just markup. Honestly it comes across like he wrote that poorly formed rant after about half an hour with Angular.
Thanks, I will give this a try.
I am not going to defend the author (I also don't agree with everything he says),but GDE is guru, not enthusiast: https://developers.google.com/experts/ I think he has exceptional knowledge of JS ecosystem, but lots of he says is just opinion and so I am asking community here, what devstack You are using. 
for a more accessible stack, I have not yet found a stack as strong and easy as Backbone + Require.js + Bootstrap / Topcoat.io
Why do people insist on writing truncated variable names when we've had minification tools for years? Why did someone think that symbols with cryptic names like lnkName, txtAr and 'o' would be necessary? And what the fuck is o.shMs? This is like my (ex) co-worker who insisted on renaming all by variables with vowel-free alternatives, insisting that they resulted in smaller files, even after patiently explaining more times than I could count that files were both minified and gzipped, how text compression worked and **repeatedly showing him that there was no fucking difference in the network panel**. The logic is a big fat mess too. So, there's a link with a span in it, and the span has to be empty and needs a certain class? And why is the IE path different? What version of IE is this where you can't attach classes properly? IE Potato Edition? And why are we storing this state in classes? Actually, why are we storing it in the DOM at all? How can people work in an environment where updating the view accidentally and unknowably breaks a single source of truth for some random functionality? And just what is in o.hdMs? What is 'this', here? Why is my logic being predicated on a cryptic comparator being injected from elsewhere? What a big fat egg of solid fuck.
Thanks for tip. I am quite new to SPA and also considering Backbone. I will definitelly give it some afternoons.
Bower, JSHint and Mocha are good improvement too
Flow, by far is the most advanced type system, and will get you much closer to provably correct code that TS or AtScript will. It has ADTs, structural types, refinement types, type inference, doesn't treat null as a bottom type, and does it all without getting in your way. Essentially it's what you get when you throw an ML type system on top of Javascript, which makes sense since I believe OCaml was a major influence. AtScript and Typescript really feel more like an attempt at shoving a Java style OO type system into Javascript, something that has never really felt natural. When you look at some of the other tools coming out of Facebook, it's clear they have a very strong focus on proper FP and the desire to follow through with it. The difference might seem academic on the surface, but in practice there's a very big difference between an ML style type system the typical Algol/Smalltalk mashup that most people are familiar with in Java or C#
http://bower.io/search/
I've tried inheritance, which is why I don't go out of my way to use it in JS
This is a repository of all plugins, not hand picked.
Logic aside, I would hope that since OP pulled this function from eBay (presumably production) that the code had already been uglified hence the unintuitive variable names. Otherwise I don't know what to think... 
Somehow this freaks me out
Works just fine for me, what is your problem?
I was just looking at examples of js fractals the other day... they're definitely on my to learn list! This one is mesmerizing!
Look at the L fractal to generate plants/trees 
This is made using the [L-system](http://en.wikipedia.org/wiki/Lindenmayer_system). Pretty amazing considering how fast it is.
Yeah, this one is pretty amazing. If you're just getting into this sort of thing, the c curve may be a good starting place, it's one of the simplest to implement. 
Closure is more advanced than flow. has all the same types + type inference as flow and then a lot of stuff which is incredibly usefull like being able to write plugins for your own compile phases, dead code analysis and a bucket load of other features which flow and react together don't currently have. Flow is good however.
Can we call this the Mustachebrot set?
[JavaScript is object-oriented to its core, with powerful, flexible OOP capabilities] (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript)
He's the author of este.js. He's promoting his own framework and his consulting business. He's as biased as a person can be.
I can only assume it's from custom html in an ebay listing, and not ebay code itself. Right? :s
Http://unheap.com
Surely so. A major corporation would never turn out questionable code /s
The most beautiful internet mustache... I took multiple screenshots haha
If you are trying to use interfaces in JavaScript, you should stop trying to use interfaces and just use JavaScript. Seriously. I'm in college (java) and all my projects need an interface. It's a complete shit way to write a program that makes no sense when you come from a javascript background.
**Nitpick-post alert** Not trying to start a discussing in the terms of "Hah! You think that is a real fractal? **This** is a real fractal!", but... Is this really a "real" and proper fractal? The way the "feathers" overlap when you change the curvature of the "wings" doesn't look proper and clean, like it does in other fractals I've seen. If this had provided a zoom function would you be able to spot this *identical* structure in at every zoom level? It seems unintuitive to me that this would be the case with this incorrect overlap. That said, I'm far from 100% of the mathematical definition of a "real" fractal, and would be more than happy to hear the opinion of something more knowledgeable in these matters.
1023? Is that so it's less than 1KB?
Yes me too, i feel like it's alive - some kind of alien life which I don't want to touch! I think it's seeing so many components moving in perfect unison. 
I too would love to see hook.io compete with IFTTT. I love IFTTT but it is very limited due to its design. It lacks even basic regex parsing capabilities, but hook.io would solve that.
I know some of these words
Surprisingly performant!
A fractal is just any recursive pattern, where a process is repeated at every level to create its structure. Are you talking about the Mandelbrot/Julia set? 
The job I apply to 3 years from now will ask for 5+ years experience in a framework that won't even be released until 1.5 years from now.
writing code that does not take into account users unexpectedly modifying their DOM source tree is nearly as dumb as coupling JS logic to markup/style. but... ebay don't look like they update very often so meh.
As far as I know, the problem isn't OCaml, it's the parts of Flow which are written in C. For what it's worth, Haxe's compiler is also written in OCaml. It works just fine on Windows.
Counter clockwise circles with your mouse. slightly increase speed when at the bottom of the circle. Its totally a deep sea creature.
Just to toss out one more suggestion: if you're looking at Backbone, I would also recommend taking a look at [Ampersand.js](http://ampersandjs.com/). It's effectively Backbone 2.0, and includes a number of built-in features that Backbone is missing (and have to be handled using Backbone plugins).
Angular can be hard, and it has lots of moving bits you'd rather not have to know about. That's the price of admission, what you get is the biggest community among SPA frameworks (and hence 'guaranteed longevity', which is important if you are paying for people to keep developing the app). It's also not particularly worse than any of the contenders out there. React may seem like 'walk in the park', but that's because the users are mostly React enthusiasts still at this phase. With bigger community, you get more people willing to complain. 
What if its auto generated? :P
ES6 will be finally done. ES7 will get types and metadata annotations. There will be SIMD and Typed Objects (`new StructType({...})`), too. Those are my somewhat optimistic predictions.
The "Sample Imperative Approach" uses an awful lot of functional concepts, like monads/functors (javascript programmers tend to blur the distinction between the two by using implicit type conversions). That is a hell of a lot more interesting than the old list processing map/filter stuff.
For lasy evaluation =&gt; _.memorize make similar stuff.
Looks great, thanks for linking. Is there a video of this talk somewhere?
Legitimate question: should we write code that is defensive against someone manipulating the page via dev tools or something? I mean, yes we should as far as security and not letting them do things they shouldn't be allowed to do. I'm talking about defending against them breaking page functionality. My thought is that if your messing with the dom and the page breaks because of it then no big deal. Am I wrong?
I have no clue what's wrong with this code. Is it just cool and hip now to call things that are functional and working in production dumb?
so async(function*() { console.log("waiting 500ms"); yield delay(500); console.log("now making GET request"); try { //Using jQuery var response = yield $.get("http://example.com/example.xml"); console.log("got data", response); } catch (err) { console.error("GET request failed", err); } }) function async(gen) { var iterator = gen(); //Start the loop next(iterator.next()); function next(result) { if (result.done) return; result.value.then(function(value) { next(iterator.next(value)); }, function(error) { next(iterator.throw(error)); }); } } function delay(ms) { return new Promise(function(resolve, reject) { setTimeout(resolve, ms); }); } is easier to read compared to console.log("waiting 500ms"); setTimeout(function() { console.log("now making GET request"); //Using jQuery $.get("http://example.com/example.xml", function(response) { console.log("got data", response); }); //I'm not actually sure what the proper error handling is v0v }, 500)
Good discussion on HN: https://news.ycombinator.com/item?id=8651641 It was "nice" to see that a lot of people hit the same walls I did when I was on a team building an Angular app.
This will return something function foo() { return { p = 5; } }
Because I like to have consistent automation. I'm not always working on my main computer, so I don't like relying on my editor for code quality. Also makes it easier for other people to contribute (if there are certain tools you expect to be used by every developer on a project, that means they should be in your dev-dependencies).
Potato chips?
Tell that to C programmers they'll attack you on the spot and claim that varaible names of caliber: i,j,l,ln, lnpmrt are perfectly readable and giving readable names to variables is a waste of space and readability
Great summary of some compile to JS languages/preprocessors out there. Thanks for sharing!
What do you mean?
I guess forty years of chasing segfaults will do that to you.
More like a submarine that makes a terrible boat because it keeps sinking.
&gt; Note: no standard for type annotations has been proposed, yet. Atscript is intended to be to ES7 what Traceur is for ES6. Note that they're assuming the type annotations from ES4 will be brought back into ES7. Hence, technically, they were proposed a long time ago and shelved. With any luck, we'll be getting them in native JS sooner than later, as the major browsers are (for the most part) evergreen nowadays.
Please read up on reddit's rules @ http://reddit.com/rules, specifically point #1 of rule #1. Our [guidelines](http://www.reddit.com/r/javascript/wiki/index) also have more information regarding promotion &amp; self-promotion. **Consider this your only warning.** If you continue to post _only_ your site, we'll be forced to take action. Thanks for your understanding.
&gt; To me, the confusing part is that the function is apparently invoked with Call/Apply (or Bind?) because otherwise the current context of this has no "get" method. Not necessarily, if they did something like var api = { toggleMessage: toggleMessage, etc... }; Then `api.toggleMessage(...)` would have `api` as its scope.
Performs the functionality of jekyll? Only problem I see is where do comments come into play using Pelican?
Now that is an interesting thought. I'll look into this. The only problem I see here is that some people might not want the comment information posted back at facebook :P
There are no restrictions for clobber or overlap in the definition (unlike the definition of function which has a set relation-based definition). I can't really give a precise definitionfor fractal (it's not my field), but from what I understand the word fractal means that something has a definable replication process to produce complexity, a quantifiable complexity at a particular scale referred to as fractal dimension, and some form of self-similarity among any of it's parameters or attributes at any point in the replication process and/or scale. It's extremely broad.
You would still use a 3rd party comment system like isso or disquss which others have already suggested. 
Are you thinking of memoize? That's not lazy evaluation. It's more like caching.
How does this "break the DOM" as others have said and what should be done instead?
I'll be flying this golden bat in a meeting for the next 4 hours. 
&gt; I have no clue what's wrong with this code. Is it just cool and hip now to call things that are functional and working in production dumb? name calling aside, just because it works doesn't mean it works well, or it was the right approach. Just because it "works" doesn't mean it works well, and certainly doesn't mean it was the best approach.
What should be done instead? Sorry, I'm just trying to learn. Thanks
Very cool. Whats up with the code though? It almost looks like its been minified except it still has whitespace and comments
The JS1k demo DragonDrop is similar and equally impressive: [http://js1k.com/2014-dragons/demo/1903](http://js1k.com/2014-dragons/demo/1903)
This is a crowdfunding project my web design teacher created in hopes of getting funded in order to create a completely free, interactive, online javascript tutorial for beginner and advanced students. She asked to help spread the word, so I urge you to check out the link, and if you're interested, donate to the project to help make it a reality.
The downside to that is that users will end up installing jshint for every package (which could be hundreds if everybody did this). Overall install time / filesize bloat is affected. On the other hand, you could check in a .jshintrc file to get pretty much the same effect (having style enforcements for contributors). Edit. to clarify, for large apps/projects this isn't a problem. But for reusable modules it can get a little annoying having tons of baggage 
As someone who only has 1 graphical application installed, a web browser, that sounds really quite horrific. :P
OP /u/ashipman says, &gt; Naturally it breaks if a Firefox add-on adds an attribute to the span. The interactions with the DOM are a bit brittle (E.g. they don't descend looking for a particular class name).
Coming from someone unfamiliar with brace-tags, the readme could use a bit more info and/or links in it. At the very least, a link to brace-tags.
There is a checkbox to stop that.
this is a fractal iterated some practical number of times, technically speaking you could iterate again and make a bigger structure from this
I wish I could say that's the worst FE code I've ever seen.
will be much better if it has its own namespace.
You can't account for everything the client could be modifying... and would be ridiculous to try to do so. That being said, there are popular browser extensions that you should test to see if they mess up your code. For instance, you should test the most popular adblocking software... which often will block DOM elements that have classes/IDs like "advert".
Like, what? 5? I think you meant to put an object literal there.
Some of these utilities are a bit superfluous... var and = require('101/and'); and(true, false); // false vs (true &amp;&amp; false) 
or maybe it was supposed to mean that automatic semicolon insertion is disabled? function foo() { return { p : 5 } } foo(); // returns nothing vs function foo() { return { p : 5 } } foo(); // returns {p: 5}
Async is basically a library function which is defined once and used many times so I wouldn't count it since we are evaluating the snippet and not the codebase. Don't forget that the first example had no error handling so if you really want to compare the line lengths take those out (hint: they end up the same). async(function*() { console.log("waiting 500ms"); yield delay(500); console.log("now making GET request"); //Using jQuery var response = yield $.get("http://example.com/example.xml"); console.log("got data", response); //Removed error handling and replaced it with a comment about the lack of error handling to make it consistent with example 1. }) If you chose to could even move the second `yield` into the `console.log` to save off a line.
The function is called as a click handler &lt;a ... onclick="toggleMessage('bo-v4-4','BOTextArea', ...&gt; I think "shMs" is "show message", "hdMs" is "hide message". The function tests whether the form field has been shown by reading the message it put in the link name. Anything that fiddles with the message or its span will break the function. This has bitten me. The simple and obvious improvement would be to look at txtAr.style.display since it goes to the trouble of setting it. Or it could write an attribute e.g. "data-open" on the link. This is actual ebay code. You can see for yourself by finding an auction with a Best Offer feature e.g. http://www.ebay.com.au/itm/111389120619. Click on "Make Offer" and save the page that is the pop-up. I suspect the code may be ancient stuff that was written for IE since the original had CRLF line ends. 
It's been a while since I used Closure, but as far as I know it doesn't have ADTs, refinement types, or proper null checking, and the inference is very weak compared with Flow, still requiring type annotations to be added in most cases. I can live without refinement types and the advanced inference, but ADTs and proper null checking are a must have. 
I must be missing what you are implying by ADT's. if it is abstract data types, the library has tons of them which you would expect (structs, queues etc). if you are talking about ways to express them, it is very clever as well. Refinement (with pre and post conditions) are not supported but there are certain compiler hooks to achieve a modicum of this. as for null checks this has always been part of the compiler and it is well supported. The compiler went through a rewrite over the last year(ish) and is constantly being improved by google.
&gt; I must be missing what you are implying by ADT's Algebraic data types. Flow still doesn't do them properly, but it does them a lot better than Closure does. It still doesn't have pattern matching or totality checking, which it really needs to get the full benefit, but given the OCaml inspiration for Flow I suspect they'll implement that at some point. &gt; as for null checks this has always been part of the compiler and it is well supported function greet(person){ alert(person.name); } greet(null); Try that in Closure, then Flow. Let me know which one picks it up. In Closure, you would have to explicitly annotate the method with an explicit type, and also explicitly declare it as non-nullable. Flow infers it by default. Flow is a lot closer to null-safe by default. Closure requires you to be very disciplined, or you'll still very easily still get NullPtr exceptions at runtime. Flow is still a long way from perfect in this regard, but it's a lot less forgiving of bad code than Closure is. Gets you a lot closer to the nirvana of ML-style languages where runtime type errors (such as NullPtr exceptions) are guaranteed by the compiler to never happen. 
Works great with touch on mobile. Showed it to my wife and told her to touch and drag. "Heh. That's gross." was her response.
You can simply paste your line of code in the URL field of your browser. Try pasting this: javascript:alert('Holy shit'); Or try this cool one line of code notepad: data:text/html, &lt;html contenteditable&gt; If you paste the code above in an empty tab, and bookmark it (CTRL+D), you'll get a bookmarklet. 
amazing
This post is a year old... :\ And there's hundreds of useful front-end modules on npm; it's being used a lot for front-end these days. A [brief list](https://gist.github.com/mattdesl/73e3b9f902f9c834b721).
Removed, please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
I've always done a check in the current state and an if/else. Probably better solutions out there but I've never run into the need to have anything more complex than that. 
I'm the author of https://www.npmjs.org/package/easy-inject It uses the annotation system directly from Angular, and you can supply a hash containing the dependencies. Then you can do something like: var inject = require('easy-inject'); inject( function(foo, bar) { console.log(foo, bar); // outputs "Hello world!" }, { foo: 'Hello ', bar: 'world!' } ); Having said that, I rarely use this in my projects. Because Node's commonjs implementation works well, and dependencies can easily be spied upon and mocked using Sinon/Jasmine and other suites, I have never really found easy-inject or other dependency injection systems worth it in Node.
I noticed the same - would be interesting to see an example of the imperative version using old-school Node callbacks for maximum pain. 
I find it somewhat ironic that after decades of people ignoring fantastic languages such as Lisp, OCaml, and Haskell as too academic, Javascript of all things sneaks pure functional FP into the mainstream. The good news is once you're used to writing code in this style with Rambda, there's really not much learning curve to go the rest of the way. You're practically writing Haskell already. 
Still working on my own variation of this with gulp, although I took a slight turn with TypeScript. For Karma, take a look at browserify &amp; es6ify. Didn't really look at code-coverage tools, but I'm sure there is an Istanbul version that supports Esprima 2.0+
True! The same could be said about oop some decades ago. Maybe logic programming is the next hype..
https://www.youtube.com/watch?v=FrFUI591WhI
&gt;[**Writing High-Integrity JavaScript (HIJS) - Nathan Wall [42:18]**](https://www.youtube.com/watch?v=FrFUI591WhI) &gt;&gt;Nathan Wall's talk: Writing High-Integrity JavaScript at jQuery Conference Portland 2013 &gt;*^4,307 ^views ^since ^Jun ^2013* [^youtubefactsbot](http://www.reddit.com/r/youtubefactsbot/wiki/index)
I'm pretty sure you've got cause and effect switched. They don't update very often *because* their code looks like this - nobody can make changes without accidentally breaking something.
The readme doesn't say much. What is koa-launchpad exactly? It's a library for Node?
The writer of the original article that was on IBM Developerworks is the owner of the company who's website the article is posted on.
My apologies! I've restored it.
&gt; Generators are a really cool tool that lets you pause execution of javascript code, and coupled with promises can allow for the creation of expressive asynchronous code that appears synchronous. Cool examples, but I finished that article still struggling to understand what exactly generators are, and *where* they'd be used. Can someone explain the true benefit of generators? Are they used in tests? Production code? Are they purely a test tool? 
You're fucked and you probably deserve it.
Why are they giving out assignments on material that hasn't been covered in the course yet? Or, if the material *has* been covered, why weren't you paying attention in class? Also, is this actually Javascript, or is it Java? They are not the same thing. PDFs tend to be a good vector for viruses, so I'm reluctant to download and open that file. Instead, how about posting a TXT or HTML version, or linking to your school website where the assignment file originated? I still won't do your homework for you, but I might be able to help you figure out how to do it yourself (as per the idea of homework).
Depending on the scale of what you are looking for take a loot at https://github.com/gajus/gitdown and https://github.com/gajus/swing.
If you really have no idea about what to do, then doing the assignment for you won't help at all. You'll just manage to fail more spectacularly in the future. If you actually care about learning to program, I would suggest you read [this article]( https://codingkilledthecat.wordpress.com/2012/06/26/how-to-ask-for-programming-help/) on how to effectively ask for help. 
I was very surprised! Past experience has caused me to think "let's open this and see how shit it runs on my mobile". But this is excellent. 
I think I missed the part where you explained why I'd want to do your homework for you.
If you're programming for performance and respect from your peers, you'll use vanilla JS and implement the cross-browser methods that you need in an efficient manner. If you're programming for production at work or performance isn't a factor, using jQuery shouldn't impact your ego.
CIS 1200 @ the University of Guelph? Please tell me why I shouldn't contact your university to report you for academic dishonesty.
You could come and take a look at [Cluckles](https://github.com/ilikeprograms/cluckles). It lets you theme/customise bootstrap themes on the frontend, can use the editor provided or make your own using the data binding. Can also use the website and import/export from there. I made it so I could embed the editor in one of my other projects and use it to create themes, which works reallly well. MIT :)
Im not a fan of Bootstrap, so I'll pass, but good on you! Coold idea
Hehe thats fair enough man. Hope you find a good project to contribute too! Thanks for the compliment, I liked the idea, figured why not. Good project to solidify my JS knowledge and I get something from it. Win win really :)
@skitch920, @schooley, @nlx I was looking to read more opinions about the smooth animations like easing and stuff in javascript, if you run into such requirements and you want to go for performance then what are your best options
I've been doing a lot of heavy JS work which targets only the latest versions of the big 3 browsers (ok, for IE we support IE10 and IE11). I started with jQuery but found that I didn't really need it for much and I preferred to know exactly what was going on. Backwards compat wasn't an issue, I didn't need animation nor jQuery plugins. The modern DOM API is standard enough across the browsers to just use it directly. If I need animation then I would look at the CSS animation stuff. 
Ah cool cool. I have a terrible memory, but if I remember I will let you know :) I have a few ideas for projects, but I want to get my current projects stable/complete for now, then maybe start another one etc. Will have too much too work on otherwise! Good luck with /u/soggie
That downside is a strawman. Dev dependencies are only installed if you install the package directly, not if it is merely depended upon by other packages. If you install hundreds of packages as dependencies for your package and each uses jshint as dev dependency, you'd get exactly zero copies of jshint. Let's play devil's advocate: Even if all of them used it as a regular dependency (which would be wrong), npm only installs additional copies if there are conflicting version requirements. You can thin your `node_modules` folder with `npm dedupe` in case it nests common dependencies too deeply. The only situation in which depending on jshint would be a problem is if **all** the following conditions are met: * you're using tons of packages * each package depends on `jshint` as a regular dependency (not a dev dependency) * each package specifies an exact version of `jshint` as its dependency (so npm can't dedupe them) If you're talking about the overhead for actual maintainers and contributors: sure, they'll need to install `jshint` when they work on the project, but that's actually a good thing. Not only may they not have `jshint` installed globally, they may actually have a different version (or otherwise use a tool compatible with jshint, but with minor differences). This is exactly why `grunt`, for example, stopped recommending installing `grunt` globally; instead they released the `grunt-cli` package, which is just a thin wrapper around `./node_modules/.bin/grunt`.
Because fuck mobile armirite? (The touch support on this website)
Also how currying really helps when working on promises. For example, if you have a function that takes two parameters, and you want to grab one from a database call and another from the enclosing scope. With currying, you can do: var doStuff = ramda.curry(function(foo, bar) { ... }); fetchFoo.then(doStuff(bar)); Without currying this requires nesting functions which is a lot more verbose. 
We are building a feature toggle system https://github.com/finn-no/unleash
Sorry... what features are you toggling? Im confused
If interested in database github.com/yathit/ydn-db
I think it's difficult to just suggest projects to you, because the only way you can go a great job working on a FOSS project is if you're interested in the topic. You're the only one to know which ones. microjs.com has a lot of JS library projects. If you're interested in any of the topic in their category dropdown, pick one.
Cool thanks!
PureScript is also one language of the second type. Besides it uses haskell syntax, it is strong static typed, type inference and all the stuff of haskell, it convert almost line by line to JavaScript in pretty readable code.
This is one of the reasons I really like Haskell - all functions are curried by default. 
We would be able to help you better if you stated which limitations are starting to annoy you...
Does javascript has the most promising future in terms of backend developing at the moment? I wanted to learn Ruby/Rails but since I want learn javascript anyway I thought it would be better if I can concentrate on one language that can cover both: front- and backend.
From [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators): "Generators compute their yielded values on demand, which allows them to efficiently represent sequences that are expensive to compute, or even infinite sequences as demonstrated above."
&gt; Is the project maintained? Can't you get this information automatically by looking at the latest commit instead of using non-reliable human evaluation ? 
I think there is a GTK binding for JavaScript. If that's what you're thinking of. I could be totally off the mark, though.
FP can be completely imperative. This link somewhat misunderstands FP by suggesting it implies declarative programming.
I am always looking for help programming features, testing, documentation, and so forth for http://prettydiff.com/ If you want some visibility now would be the time to help out as the tool has started growing in popularity at about 15% month over month.
Yep, I see your point. I was under the impression npm installed devDependencies on indirect dependencies.
I don't know what are your interests so it's hard to suggest something so I'll just recommend checking out Atom and see if it's worth your time.
This is good, but a little on the 'jQuery is magic' side - investigation in to what `jQuery.ready()` is doing would be insightful. Here's that code: https://github.com/jquery/jquery/blob/10399ddcf8a239acc27bdec9231b996b178224d3/src/core/ready.js tldr: EventListeners, not `.on*`, the [DOMContentLoaded](https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded) event, falling back to the `load` event and a shortcut if the [document is already loaded](https://developer.mozilla.org/en-US/docs/Web/API/document.readyState). jQuery has some neat tricks up its sleeve with the ability to delay `ready` from other functions.
I think the OP wants a UI browser-style application, not a command line node.js-like one.
I went back and updated the code example at the end. Take a look at the `async` function. It's generic enough where you can pass a promise to it, and have the resolved value returned meaning you can write stuff like: ``` var posts = async(getPosts); // no callbacks here, just post objects ``` You can wrap your async calls, wait for them to finish, then keep moving through your code.
&gt; the biggest community among SPA frameworks (and hence 'guaranteed longevity' Then why don't we all just drop everything and work in wordpress? I'm sure you know, a big community does not automatically mean something is good. that said I like angular, but it is no panacea. It has problems, problems it creates for itself by being like it is. You should open up some of the validator(require, max-length, etc) attribute directives sometime, and look at how they work with scope. It is hairy and un-intuitive. Also, the way $digest works, is often cost prohibitive with things as seemingly straight-forward such as tables. With something like React or Knockout (or any mvvm pattern based approach), One can really achieve large data sets with reasonable performance. The ng-repeat approach is fundamentally not an ideal candidate for large sets, yet it is the 'angular way'. Just read all the hacks and workarounds out there. from track by, to bind once, to 'faster-repeat' directives, yet none really fix the issue. And honestly the list goes on. Does angular suck? no. I like it... but we have to be forthcoming about shortcomings. 
it's very simple to write this in a way that does not break. they can either check the element `className` / `classList` contains 'xpnd' or they can setup delegated events instead on a parent node. checking against a serialized outerHTML, given browser differences in nodes and " " around attributes - is fragile to begin with. having the toggler only work on a span is is not relevant / ideal. also, let's not even discuss accessibility and how a screen reader will deal with this lnkName.innerHTML.toLowerCase() == spancode+o['shMs']).toLowerCase() || lnkName.innerHTML.toLowerCase() == (spancodeIE+o['shMs']).toLowerCase()){ this is also ineffective, same operations performed multiple times, using a dom getter for innerHTML twice, toLowerCase twice, creating /concatnating new strings that are same twice... 
That's why I added that it's not particularly worse than the competition (unlike, say, PHP in its own field).
Wouldn't you be better off looking at if issues are resolved vs ignored, combined with latest commit in any branch
You could use them for something like a rotating random image component. You could have the generator generate a random image from a selection of images you instantiated it with and return the markup for the next image. You'd set up a timer to grab the next generated image. It gives you the markup for the next image, you place it on the page and animate in whatever way you want. Now whenever you want a new image, just ask the generator to give you a new one and you don't have to go back to the original array and get a random index or generate the markup. You just request a new image and it gives you what you need from wherever you are on the page. You could implement something like the [Android KitKat easter egg](https://www.youtube.com/watch?v=btzsbM-sxiU) (skip to 0:35 or so) where an interval replaces images on the tiles at random just by requesting a new tile (or group of tiles) from the generator and all you have to do is replace the current tile with whatever the generator gives you. It doesn't even have to be random. It could be a preset sequence of repeating values. Have it return 123412341234... infinitely and you can pass (or map) that to a function that returns something from an array in that order. They can be used to implement an infinite scrolling mechanism. You ask the generator for the next 10 records in the database and it has all the information it needs to go out, get the next 10 records (because it maintains the current Index internally) and it will give you what you need.
I think the best way to help other projects is to create your own! By building small, reusable abstractions as you need them, you can help authors you haven't even met yet as people discover your libraries, contribute patches, and as you do likewise.
I'm using SASS for the first time on a new project, and though it's definitely added value over the vanilla CSS I'm used to writing, there are a couple edges I don't love: - It lives in a separate file from my React component. (As Pete Hunt's pointed out, it's a separation of technologies masquerading as a separation of concerns.) - It's unclear how to depend on SASS in another CommonJS module using the current version of sass-loader. A technique like this could solve both issues: var Thing = React.createClass( { "mixins": [ jss.ReactMixin ], "style": { "text-align": "center" "&amp; label": { "background-color": "red" } } } ); module.exports = Thing; // ----- var OtherThing = React.createClass( { "mixins": [ jss.ReactMixin ], "style": { "extend": Thing "&amp; label": { "background-color": "blue" } } } );
Thanks for posting that. I was hoping the author would cover it, but all they kept repeating was window.load fires after all elements are loaded and jQuery.ready fires after DOM is ready.
if you don't mind me asking, what polyfills do you use?
Sorry I'm having a hard time seeing a use case for this. Can you provide some?
This is cool man, I love learning how libraries work! 
Not really my article. Still, thought it was an interesting idea.
The last example couldn't possibly work as presented. The async function is missing a meaningful return statement, and the output code seems to be expecting an array.
Of course! If you've never used something like Brunch, the idea is the user just installs plugins and does little configuring. So, adding jade to a bare-gulp workflow: var gulp = require('gulp'); var jade = require('gulp-jade'); var jadeify = require('jadeify'); gulp.task('build-app-views', function () { return gulp .src('app/views/**/*.jade') .pipe(jade()) }); gulp.task('build-vendor-views', function () { return gulp .src('vendor/views/**/*.jade') .pipe(jade()) }); __browserifyBundleOptions.extensions.push('jade') __browserifyBundle.transform(jadeify); with Parched it's simply npm install --save parched-jade Now you can save .jade views in `app/views/` or `vendor/views/`, and browserify is already configured. Your Gulpfile.js can be [as simple as this](https://github.com/raisedmedia/parched-example-app/blob/master/Gulpfile.js) while having support for browser-sync, jade, coffee-script, sass, svgs -&gt; webfont, svgs -&gt; retina sprite, minify css in production, minify js in production.
You're totally right. The fiddle was updated.
Bingo!
can someone explain the benefit of these changes in somewhat anguar beginner terms? I've been using angular for almost a year and I am still grasping some concepts. 2.0 looks like a whole other learning curve
&gt; "Hey, try my component, remember to add this CSS though!" I'm not really seeing the problem with this. Not to mention that thanks to this 'advantage', integrating a new component to a project with an existing stylesheet sounds like a bitch.
In angular 1.x, you could write dependency injection two ways: longhand and shorthand. If you used shorthand, you had problems in production when minifying your code without jumping through a few extra hoops. Angular 2.0 is trying to consolidate both of these into one explicit way of writing things, in order to simplify the process and cut down on confusion.
Sorry I assumed it was. I wouldn't call it an interesting idea as there are simply too many faults with assumptions made by the writer and a lot of ignorance of existing and better alternatives to handling the issue. If it was an article from the author describing his journey in developing the project and describing the clear weaknesses in the project as well as the strengths in the alternatives then I'd then give it consideration as interesting, but for someone to actually put this out as a viable solution is plain wrong.
backbone.js
Polymer.js
&gt; integrating a new component to a project with an existing stylesheet sounds like a bitch But how? You can always pass a class to a component and override its rules in your CSS, or you can pass a style property and not have to touch your stylesheets.
Was asked this question in an interview yesterday. I had to guess, and guessed the exact opposite.
than 
Backbone and ember are probably the two most popular. 
no
Do you really need a full blown FW? If you make that choice its a vendor lock in. You could also experiment with libs from npm and bundle with browserify. Dont like an ajax lib? Just swap it out for something else. React gets all the hype atm, but you could also go with something like knockoutjs, it has been good in my experience. (also good ie support) That said, we are about to rewrite a 5 year old app, and im going to be pushing react + npm + browserify. We need to support IE8+ so anything fancy is out of the question. But i plan to write everything in ES6 and then use 6to5 to compile, and use shims for ie as long as we need to support it. I feel this approach is smart because its very forward thinking, when the time comes we can drop the compilation step and use "native" es6 features.
Under what conditions **do** developers... th**a**n jquery**?**
Ember.js is another I've heard being used, never used it myself though.
By default, you should learn plain JS, and JS patterns, but use jQuery for things like ajax, dom manipulation, event handling, etc. * Hundreds of thousands of sites use it. * It's got thousands of tests for new and old browsers * It has an active developer community
Best read I've had I a long time. Thanks for posting.
You read https://leanpub.com/u/raganwald ? similar mindset (little composable functions), more esoteric content too.
If your goal is performance, your choice is always going to be vanilla JS provided you know what you're doing. Key words here are that you know what you are doing.
I remember the minification issue since I tried it a while back and the longhand way of writing the dependency injection wasn't too bad. I guess I'll wait and see how 2.0 is when it is released. It just looks like a pretty drastic difference between the two
I think this could be further improved regarding however you are approaching your problem, but in terms of how to write the code your provided "better" without the use of jQuery, the following would be one approach: var counters = { counter1: 1, counter2: 1, counter3: 1, }, elements = [ 'voter1', 'voter2', 'voter3' ], i, l; // Used in for loop for (i = 0, l = elements.length; i &lt; l; i++) { document.getElementById(elements[i]).addEventListener('click', function(e) { e.preventDefault(); }); } // Instead of calling increment1, increment2, etc. // Call this function as `increment('1')`, `increment('2')`, etc. // You could improve this function further by adding error checking and the like. function increment(index) { var count_value = counters['counter' + index]; document.getElementById('v' + index).innerHTML = count_value; console.log(count_value); counters['counter' + index]++; }; 
You never call any of the increment functions anywhere — did you mean to do that from the event handler? Anyway, I'd probably do it like [this](http://codepen.io/anon/pen/VYLWEb). Even still, that's too much repetition for my taste. I'd probably generate the elements programmatically, especially if there are more than 3. I'd also consider using a delegating event handler and installing only a single handler that handles all buttons. 
this is how I would do it: [jsfiddle](http://jsfiddle.net/jeffshaver/m3t6j44r/) could do it without the matches function and just check if the class exists, but whatevs.
&gt; You should use window.onload if you are dealing with images Oops. Just realized I made a mistake a few weeks ago … 
https://github.com/trueinteractions/tint2 Javascript native desktop applications.
then -&gt; first this then that (sequence) than -&gt; 7 is bigger than 5 (comparison) "Than" is the right word in this case. See: http://en.wiktionary.org/wiki/then http://en.wiktionary.org/wiki/than
Try looking at the source code of Google.com
What do you need to do if you don't have the async library?
No, not always. You can cut lines by combining statements, or being "clever" with your statements, but usually it just makes for less, but infinitely more confusing code. The example with generators (i'd be willing to bet) would almost always be regarded as more complex and confusing by most programmers.
Shit article that doesn't cover even the most simple factors relevant to the subject. Would not hire. Author needs to [read this and try again](http://www.reddit.com/r/javascript/comments/2nd8ie/difference_between_jquery_document_ready_method/cmclpfg)
 var counters = [1, 1, 1]; var voteCounts = []; for(var i = 0; i &lt; 3; i++) { voteCounts[i] = document.getElementById("v" + i); } function increment(i) { voteCounts[i].innerHTML = counters[i]; console.log(counters[i]) counters[i]++; }
You should also check out /r/gamedev . There's a great community of game developers who are helpful across all stacks, and there's a decently sized minority of us who specifically do html5 development!
The best aren't on Windows.
I have found that having a very strong basis in JavaScript pays off enormously when looking at 'compile to js' languages. Remember that you're still going to need to debug in JavaScript. and for the most part front end jobs will heavily prefer JavaScript over one of its derivatives. Plus it's fairly well understood that if you know js you can easily pick up something like coffee script or typescript or even dart (although that has its own standard lib of sorts, it will still be pretty easy)
As someone who has struggled to really get into the NodeJS culture along with tools such as grunt, bower, gulp, or otherwise I appreciate the simplicity and content of the article. Can I be greedy and request similar articles for bower and gulp also?
Yeah, let me see what I can find. I know I've seen a Gulp one or two. Here is one for [Gulp](http://danreev.es/posts/getting-started-with-gulp/). And [here](http://tech.pro/tutorial/1190/package-managers-an-introductory-guide-for-the-uninitiated-front-end-developer) is one that Rey Bango posted on this sub yesterday that covers Bower and some others. Edit: Added links.
[24 Pull Requests](http://24pullrequests.com/)
Both communities are very robust, and neither technology is going away anytime soon. I love node, but to be brutally honest it's not as approachable or easy to learn as rails. And the differences between front and backend js are big enough to be very confusing when starting out. But that's just my opinion, I'm sure plenty of people feel the opposite way :)
Many thanks!
most cases? you can provide counter example where DOM is not ready? Or you are talking about the white-space textnodes after &lt;/script&gt;?
There is also this [Grunt](http://mattbailey.io/a-beginners-guide-to-grunt-redux/) one which was just updated
(shameless plug) maybe checkout [parched-example-app](https://github.com/raisedmedia/parched-example-app) as well, it's built on top of gulp but removes the need for configuring each piece
Yep. View controllers will definitely take over the role normal controllers fill, but take a look at this example that uses a top-level controller called "root": http://dev.sencha.com/extjs/5.0.0/examples/ticket-app/index.html It's included in the Ext JS 5 download so you can see the source code there. The root controller (at Ticket.controller.Root) here is responsible for launching the login view, and on successful login swapping the login view out for the "main" application view. It's at a slightly higher level than either the Ticket.view.login.Login view or the Ticket.view.main.Main view - it orchestrates both of those in a kind of creepy puppetmaster way by handling the login event from the Login view with the Ticket.controller.Root.onLogin method. This is the method that sets up the main application UI and the support variables/classes it needs. There's an Ext JS 5 Architecture book coming out in Q1/Q2 next year that deals with this kind of thing FWIW. edit: the Ext JS forums are a bit hit and miss but either there or StackOverflow are probably better places to ask than here. You're just lucky I happened to be passing by!
side note: you would never survive in a hollywood movie. you would be the first one to discover it and then the first one to be killed by it in a very gruesome and painful way.
Bridging two different views. I have a line of business app with a single controller to handle view/navigation logic. Then a whole bunch of ViewControllers to handle their own views. But this root controller deals with at least three other discrete views and is reactive to programmatically generated events as opposed to user-generated ones. (One distinction between Controller and ViewController is they have a common BaseController but neither extends the other. Controller therefore implements a `refs` config, but ViewController does not. Refs is an easy way to work with views. Since this controller needs multiple, Controller is a better fit.) Could it be app.view.MyViewportController.js? Suppose it could. It'd need a bunch of .down() calls for what are otherwise fairly straight forward .getExpression()s, but that's the only major difference. But being a controller feels better. A lot like a `for(){}` vs `forEach()`. They do the same thing, but pick the one that fits the problem better.
I would suggest looking into Ractive.js. It is lightweight, newer, and easy to learn. It is very comparable to Angular and Ember, but a lot lighter. I have created a few web-apps for my internship using it and it handles data like a pro in an MVC environment. 
It's technically not ready because "&lt;/body&gt;&lt;/html&gt;" still haven't been parsed as the script is being executed. By "most cases" I mean 2 things: - the browser is smart (and forgiving) enough to close these 2 tags for you if you ever attempt to browse the DOM before the end of the document gets parsed; - rarely do you ever need to do anything with the DOM at this point that (1) would still not be loaded and that (2) the browser can't guess on its own.
If you can live with IE9 mode, HTA is also an option on Windows. I recently used it for some React/superagent based tools which work with intranet APIs, so I could distribute them as a single ~350KB minified file rather than having to lug a 20MB runtime around. This is the project template I ended up with after doing it twice: https://gist.github.com/insin/db37e6973c23289bf6c2#file-readme-md
So in case someone is as noob as me and can't see the alert('message'), but instead is getting a browser error message even when all the configurations are ok, change the 0.0.0.0 for localhost and it should work. If I didn't *english* well let me know :).
And here's another example, this is parched-svg2png: var SpriteBuilder = require('./sprite-builder'); var CSSBuilder = require('./css-builder'); module.exports = function(Parched) { Parched.createPlugin({ displayName: 'parched-svg2png', src: '*.svg', shouldProcessAssets: function() { return true; }, getDefaultOptions: function() { return { src: 'sprites/**/*.svg', outputCSS: 'app/styles/sprites.css', outputImage: 'public/images/sprite-map.png', usePlaceholderSelectors: true, cssClassPrefix: 's', httpImagesPath: '/images/' }; }, transform: function(context) { var optionsClone = Parched.vendor.xtend({}, this.options); return this.processManyFiles(optionsClone.src, context, this.buildEverything(optionsClone)); }, buildEverything: function(optionsClone) { return function(files, done) { optionsClone.files = files; var cssBuilder = new CSSBuilder(optionsClone); cssBuilder.done = done; var spriteBuilder = new SpriteBuilder(optionsClone); spriteBuilder.done = function(err) { if (err) { return done(err); } cssBuilder.build(); }; spriteBuilder.build(); }; } }); }; `Parched.createPlugin` Registers the plugin in the system `Plugin.getDefaultOptions` Allow the user to override things based on `displayName` `Plugin.transform` This is a method in a sequence passed to `Parched.createTask` `Plugin.processManyFiles` An easy way to process a glob/regex of files in a gulp stream `Parched.vendor` Basically the dependencies of Parched --- The idea is the user simply does `npm install parched-svg2png` and without having to change any settings will get a spritemap built and the resulting .css (or .sass, .scss, .less) file will be compiled and collected into a single `app.css`. If the user changes `outputCSS` to, say, a .sass file they can import it and start using Sass' `@extend`
Somebody had to do it! Being from the place where Deloreans were manufactured, I commend your naming skills! 
Wish it had the original source :( Still neat.
Nice post!
Thanks! I think I will give it a shot!
Dayum.
But you didn't explain what generators are, I think. Usually it's hard to explain/define a word without using that word.
Cool, I'll probably be using this soon.
The author created a postmortem with the clean code and an explanation for each part: http://birdgames.nl/2014/04/js1k-post-mortem-minecraft/ He also created a 2K Wolf3d with collision, door animation, etc. Cheers
Good little read for those starting out with Grunt. BUT, you should not be using "sudo" to install NPM modules. Look into using Brew then installing node via brew, so you'll only need to do "npm install moduleName". 
Very cool, thanks.
Got it. In that scenario, I'd do a search for an animation library with minimal dependencies. jQuery might have some built in methods for animations but it's certainly not built for optimization (may be as optimized as good as it can be in $'s environment though). Give this article a read - http://www.smashingmagazine.com/2014/09/04/animating-without-jquery/
It seems that underscore/lodash provide similar constructs to kefier etc. What is the difference? 
 "I want to eat" + " " + food is the same as: "I want to eat " + food
wow, how's your learning journey so far?
food is like a variable, holding your input. so, you typed foodDemand("cake"); which means food = "cake"; so, you have "I want to eat " + food; which equals "I want to eat " + "cake"; If that is what you are trying to ask.
Use an array: var aRatings = [ "zero", "one", "two", "three", "four"]; var nRating = 3; $('#example-rating-1').text(aRatings[nRating]); Or, if you don't like the "zero" option, remove it and use aRatings[nRating-1]
&gt;Or, if you don't like the "zero" option, remove it and use aRatings[nRating-1] Or just use an object
https://github.com/trueinteractions/tint2 It has wrappings for common UI widgets that are cross-compatible (webview, window, button, etc). You can also reach in to dotnet's CLR and use native classes and import any CLR assembly (.dll) and use its classes/methods/etc in Javascript.
wat
To learn the basics/root concepts of JavaScript, I recommended this e-book http://speakingjs.com/es5/index.html
Yeah this makes sense, since they are singletons we should probably only ever need a couple of them anyway. So I suppose routing is a good candidate for a regular controller. Maybe remoting could be another, for polling tasks that span the entire application. All in all it seems that the static controllers don't have as big a use case any more.
IBM? Man, going from angular to dojo is going to be terrible. Going from nothing to dojo [this book](http://www.amazon.com/Dojo-Toolkit-Visual-QuickStart-Guide/dp/0321605128) was helpful. I can't say I came across any screencasts during my time with dojo. The docs and the getting started demos are probably the best help you are going to find on the net. I honestly learned the most by reading the [dojo](https://github.com/dojo/dojo) and [dijit](https://github.com/dojo/dijit) source. I might be weird though. Good luck!
I realllly hated my first experience with react. I really how you set this project up. I might give react another shot. Thanks for sharing!
Canvas dom elements support the attributes 'width' and 'height', which can be updated on the fly. You can pull screen size information from window.innerHeight and window.innerWidth. You can also change a canvas's size with css, but this won't update the pixel width and pixel height that the canvas element renders, so you can get skewed and fuzzy results. If you want to make your canvas element update itself to the window size then attach a function to the window's resize event and update the mentioned values from that event handler. I'm not sure what you meant about a toggle, but you can always have your handler function check some property value before changing anything, which would allow you to disable resizing under certain conditions. 
There is no 'best' resource, only what works for you. If the codecademy tutorials don't mesh with you then a more traditional approach like books might work better. Personally I think the codecademy stuff is some of the best around, but that's a preference only.
[I learned the most from these tutorials](http://dojotoolkit.org/documentation/) and reading the code from the demos on [SitePens github repositories](https://github.com/SitePen).
Very interesting. What kind of "tests" are you looking for?
IBM put their weight on Dojo while the rest of the industry picked JQuery. Now everyone is moving to ReactJs after the Angular 2.0 debacle. 
/u/my_new_account hello, if you're still interested I wrote Part 2 http://www.reddit.com/r/javascript/comments/2ncw7n/understanding_react_and_reimplementing_it_from/
Got to say that it's pretty weird code, anyone that can answer OP question? My curiosity is *aroused*.
This was an awesome read, wonder if there was a talk to go with this I could view.
to simplify it: underscore/lodash work on objects/arrays, FRP libs work on streams. I'd recommend watching [this video](https://www.youtube.com/watch?v=XRYN2xt11Ek) from Netflix guys to get a better understanding of FRP in js/front-end context.
The problem is that every often solutions like Selenium or PhantomJS doesn't run exactly in the terminal. And I prefer to have the testing part of my deployment process.
Well no, because this application already has that - it's the MainController and the Main view is the viewport. A view controller deals with its view only. A an app controller has loftier concerns.
Routing is not necessarily a good candidate for an app controller. Routes can be defined in multiple places, so you can define the same route twice and handle it in different places. This allows your view controllers to handle a route, but when handling it only take care of the things that apply to that view. This avoids your route handlers becoming huge and doing things that span several views.
It's good to know there's confidence in Codeacademy. I was just curious as to what other options were out there. Thanks a lot though. 
What might this be for?
So, this doesn't really answer the question, but might help sleuthing? It was added in r6 as part of some fairly major changes: https://code.google.com/p/jquery-timer/source/diff?path=/trunk/jquery.timer.js&amp;format=side&amp;r=6&amp;old_path=/trunk/jquery.timer.js&amp;old=5 No idea if that helps? Additionally, it's now on Github - but the code looks the same. https://github.com/jchavannes/jquery-timer
I'll work with you. PM me. 
x-post /r/jquery
Slloooowww down there. Javascript's job is not styling, these are CSS issues that are solvable using preprocessors like less/sass. [Gotta keep em separated](https://www.youtube.com/watch?v=XN32lLUOBzQ).
haha, I'm reading through the explanations and I still have no idea. I'm both baffled and amazed that there is a recognisable 3D world being presented here with a level of water, tree trunks and leaves and... wtf. I would love these kind of skills to make little games like this with no frameworks or libraries, just my knowledge of numbers. I only recently discovered the bitshifting &gt;&gt; operators recently, can anyone explain how they are used in this context?
Lack of answers and high upvote count indicates lack of such service. To the drawing board!
kickstarter?
Loftier in what sense? As far as I can see the highest level in the application is the viewport. Any examples? The login example above could just as easily be achieved by the view controller of the view port?
Such a platform would be nice, but it'd probably end up being a specialized subreddit (in essence).
There is an interview with Meteor's Community Engineer on the Discover Meteor blog: https://www.discovermeteor.com/blog/engineering-communities-yuriy-dybskiy-interview/ Not exactly what you were asking for, but probably some relevant information if what you want to do is raise awareness and adoption of your open source project.
For not-for-profit, open source projects? Probably not.
And almost all other cross-view controller concerns can be handled by events or in the worst case the view ports view controller as a mediator. So the results of all this is that "app controllers" are redundant and only present for backwards compitibility?
Thank you
Pretty nice looking. Now you need a box for testing that regex and seeing what it matches against input strings :)
I think you should consider creating a social media campaign and using the existing tools. Facebook, Twitter, etc.. There is lots of free info that will tell you where your audience is what platform is best to reach them.
Animations should use requestAnimationFrame rather than setTimeout or setInterval. requestAnimationFrame will try to animate at the monitor refresh rate. It will also go to sleep when the browser is minimized, whereas the others will keep on running. Animations should also use CSS3 transforms, SVG or canvas drawing rather than doing DOM changes. If you're doing those things, it probably doesn't matter so much whether you use vanilla JS or jquery.
Does Reddit is a good place for that?
assembly.com?
Routes are essentially just a fancy way of configuring events that fire from changes in the URL or via redirectTo. Ignore the idea of a "viewport" and "viewport controller" as a special construct. A viewport is a UI container which is full-screen. That's it. Deal with it in the same way you would any other view.
HackerNews
Ah, ok. I think i'm getting wires crossed because I natrually think of things in more of a abstract (transducer?) orientation. A map is a map regardless of what it is working on. Granted I do see that the details of implementation matter. 
But what it do?
&gt; Also, the way $digest works, is often cost prohibitive with things as seemingly straight-forward such as tables. With something like React or Knockout (or any mvvm pattern based approach), One can really achieve large data sets with reasonable performance. Unless you want to *update* a whole bunch of them at once, in which case Angular suddenly starts shining while Knockout gets a huge black eye. It's a nuanced tradeoff that people in both camps tend to forget. Angular uses post-update dirty-checking, which means that the digest loop slows down the more things you databind, and Knockout uses immediate-mode update, which means ugly stuttering in your UI if you update a lot of data in response to a single event. Both have ways to work around their issues -- Angular has one-way databinding for things you know you aren't updating, while Knockout has the "rate limit" extender to delay updates -- but neither is a panacea. 
Maybe you should call alert(add(x,y)); or define add without arguments so that it wont override glboal variables.
Here?
The concept doesn't quite work with open-source (think https://github.com/gajus/gitdown) type of projects.
&gt; How come the output to this code is Functions are objects in Javascript, and can be passed as values. function add(x,y) {...} is shorthand for var add = function(x,y) {...} So when you call alert(add), you're telling it to alert the value of the variable "add", which is the function declaration, not the function result. Edit: also Javascript has function level scope, so when you declare x and y as function parameters, those are distinct variables within the add function, and do not carry the values of your outer x and y. You'd have to do this: var add = function() { return x + y; }; alert(add()); 
http://githubnews.com
Which version? sidenote: My company is stuck with a product built with dojo 1.5. I've been working for over a year yanking it out.
Essentially, you shouldn't be testing private functions. You should test the behaviour of private functions through the public functions. If there's no path to private functions from your public functions, then maybe they shouldn't be private in the first place. Test for behaviour not implementation. Your tests should read like a manual on how to use your object. If it has private methods that shouldn't be used, don't use them in your tests.
Hacker News
take the private methods, put them on a separate module and test that in isolation - then consume the module from within your public interface. This is much easier if you're using a CJS/AMD loader. 
I would try this. Mark your post with "Show HN: My project description"
I agree on everything. Would you be comfortable testing business critical code just by covering a public api? 
Thanks! Shared a few projects already http://githubnews.com/repositories/51 and http://githubnews.com/repositories/52
Interesting, how does it compare to something like React? A quick glance over their site told me its pure DOM vs VDOM and code lives in templates versus pure javascript.
+1
They are using the latest version thankfully, 1.1 i believe
Nah not IBM ;) well i've used jquery in the past and it seems similar no big deal. Good to learn something new but yeah switching from angular will be rough but no big deal. When you say 'from nothing' do you mean learning js from scratch? I already am pretty familiar with js. Think its still worth it?
Thanks for the github link, will check it out
Yeah I basically went from not knowing JS right into a Dojo project. &gt; I already am pretty familiar with js. Think its still worth it? I don't think so - I think the docs will show you everything you will need to succeed. 
It sounds like you want a very specific workplace. From home, using the tools you choose. I don't know how likely/realistic that is in this world without working for yourself. If you figure out how to not only get a remote job, but one that allows you to choose what libraries you use, please let us know.
It took me awhile to understand React's philosophy. Viewing several talks by Pete Hunt, [namely this one](https://www.youtube.com/watch?v=x7cQ3mrcKaY), won me over.
But nobody cares about their performance - critical loops should be written using native `for` syntax (or even decrementing `while `). 
There are _tons_ of active front end framework projects out there, here is a good example list: http://todomvc.com/
Or, a fundingless Kickstarter. It's communication; same shit different shape.
I figured that he was trying to easily add features by just adding to the array with minimum change in the code base but that is one bizarre way to accomplish that.
Oh, certainly re-factoring should still be a priority. All I'm really saying is that I don't think a hard and fast rule "don't test private members/functions" makes sense. This is a really contrived example, but say you have a parsing class, which uses a specific regular expression for part of what it does. You could test the regular expression by nature of testing parsing through the api, but it could also be useful while you're developing your class to validate your regex with unit tests. And sure, you could use those tests as part of development and then throw them away, converting the regex to private as a final step, but those tests also serve as part of the class documentation for you and any other maintainers. To me that's useful. If your parsing class gets to the point where it has many such regex's, then you probably need a module just for that, and that's a great re-factor, but that's not always the case.
My post definitely says that I *prefer* Ember, but am learning Angular because it seems like more employers are looking for Angular devs. I'm not a huge fan of a lot of the tools I've used at my last 2 jobs, but they're not deal breakers.
Thanks for the link. It's not that I'm not willing to work in Angular... Quite the opposite, actually. I was just looking for validation of my observation that there's more Angular jobs than Ember.
The Angular community is definitely larger than the Ember one. Mostly this is because Angular is pushed by Google, and people flock to their projects just on the backer alone. But the Ember community has been gaining tremendous momentum over the last year. Hopefully its not too hard to find Ember jobs in the near future, because its a great framework to work in :)
Unless there's a trick I don't know about, there's no way to arbitrarily set variables in the current scope in JS without using `eval`. Setting `this[param]` would be different. Of course, all the function in question does is copy the parameters to `this` anyways after some checking.
Good call, I should have been more descriptive that Hacker News.
That makes a lot of sense, so [does this](http://philipwalton.com/articles/why-i-test-private-functions-in-javascript/). but I'm still going to try to find a way to test it without putting test-specific code in my production code. I haven't thought of one yet, but I'm thinking and I'll let you know :P
Yes, great point. There are well-established conventions for handling these things in jQuery plugins, and the plugin's code does not follow them.
Not bad. Kinda slow when I hit submit. For complicated regexs I like https://www.debuggex.com/. 
I was thrown off by this at first too, but the variables being (re)set are declared as function parameters.
I have seen this in big commercial projects before, I can see the argument that it makes the testing better. However if your private function is not accessible and covered by calling a public function then the code might not be structured correctly. Sometimes TDD can make you write code to allow for easy tests but the code should be written for functionality first. 
I wrote a bit of example code to help someone else out with the dynamic parts of this challenge. If you pm me I'll dig it up and send it to you if you want. 
I like http://rubular.com
Yeah, I've noticed that odesk has some real low budgets. I've done the freelance thing before and I'd rather find a remote, full-time, gig. If I were to do the odesk thing, it'd be to supplement income. Like you said, it'd be hard to live off of it.
Hey dude, This might be the article you're describing: http://philipwalton.com/articles/how-to-unit-test-private-functions-in-javascript/
congratulations on your idiot api
I accidentally your script.. http://i.imgur.com/bS4bIZk.png That's zoom 25%
None of the nickle and dime approach of this service is appealing. 
Does it even lift?
Interesting idea. How do you plan to make the process of uploading data as frictionless as possible? edit: found the docs... 
or How I learned to stop worrying and love the console.
I have a silverlight app that needs to work offline, would this be an option for that? Problem is sometimes my isolated storage is 100s of megabytes. 
At first I thought you were being a dick. Then I opened up the JavaScript. I agree. You should just try giving it a read -should be pretty obvious.
Online advertising is a $120 billion dollar industry based on a nickel and dime approach.
I should be more helpful sometimes. If you edit the values being assigned in lines 4-10 and re-run the pen, you should see noticeable changes that will help you to understand what's going on. Bonus points: start messing with the code below there one bit at a time, and see what happens. This is the best way to become familiar with the code. Good luck!
`document.getElementById(this.id)`? Alternatively, `this` In full: function clickButton(){ if(this.innerHTML == ""){ this.innerHTML = nextTurn; turnSwitch(); } } *e- fixed typo `)` and block, thanks UgnisKarolis*
I remember using [Firebase](https://www.firebase.com/) and [Meteor](https://www.meteor.com/) to build an app way faster than I thought reasonably possible, although dealing with them required that I [unlearn and relearn some things](http://cube-drone.com/2014_02_19-Cube_Drone_76_Many_Angular_Ones.html) and accept the [badness that is MongoDB](http://www.sarahmei.com/blog/2013/11/11/why-you-should-never-use-mongodb/). 
Holy crap, I've been using devtools for years now and never seen that!
Yeah you're right. My point was focused on the `this` thing (I don't think pointing out the redundancy of the id lookup makes it harder to understand, and is worth pointing out to OP) but the broken if block could throw OP off. Fixed.
Loved the porn reference, and this is exactly right, it's all about jumping straight into programming, finding an interesting project, and try to complete it.
You're not calling the function.
The prompt will return a string, so given x = 3 and y = 4, it will return '34'. You'll have to throw a parseInt in there as well.
Firefox has the same....it's been there for a while.
~~Product~~GitHubHunt
The Chrome one is very new .. wasn't in 38 but is in 39
Want to echo this. Vue.js gives me the things I loved about Angular without the pieces I didn't.
Yep, I second this. I can't speak about Meteor, but Firebase makes any app that *could* run on a RESTful backend so much easier to build. Try Firebase, you wont regret it.
One of the better ones I worked with: https://www.debuggex.com/
https://github.com/dockyard/ember-easyForm
I don't think it be like it is but it do.
I took a quick look at Firebase. It looks impressive, but can't you get pigeon-holed into their framework, pricing, etc. since it's a cloud-based framework that they run? (and it's not open source if I'm understanding correctly)
&gt; Do I have to build all the forms and fields manually AGAIN If you'll use React, you can try: https://github.com/gcanti/tcomb-form
Such as?
Keeping it simple.
More like the rise of bad developers using huge JS libraries.
Hi Seeeejaaaay, I think you have the model a little confused. Servant charges a known amount of money. We have a tiered subscription based model starting at $5/month and increasing depending on need. The $0.0005 is the amount of revenue associated with each API request and has nothing to do with the customer. The reason we talk about that number is for developers' reference. Every time a developer's app makes a request for data, they receive half of the revenue associated with that request. This allows them to make money by virtue of us distributing the hosting cost among those applications that provide value to our customers. I hope that clears things up a bit.
##`undefined()` Firefox: TypeError: undefined is not a function Chrome: TypeError: undefined is not a function IE11: Object expected ##`asdf()` Firefox: ReferenceError: adsf is not defined Chrome: ReferenceError: asdf is not defined IE11: 'asdf' is undefined
This isn't especially a job for JavaScript, usually this should be handled by your server side code. Only suggestion that uses JavaScript would be to redirect any requests to the correct file.
If the variable is already declared, but holds the value undefined, you'll get something like that. var a; a(); Chrome: =&gt; TypeError: undefined is not a function Firefox: =&gt; TypeError: a is not a function Safari: =&gt; TypeError: undefined is not a function (evaluating 'a()') NodeJS v0.10.33: =&gt; TypeError: Property 'a' of object #&lt;Object&gt; is not a function
Well, you know.. Just pick up a framework.
depends on what it is. if its a plugin to a popular framework, there are usually repos out there you can submit to (jquery, npm, ng has a few).
100 is always the peak. Google trends shows relative search volume between queries with the maximum as 100%. 
Dunno about PHP but that link is Java vs JavaScript errors: http://www.google.com/trends/explore#q=NullPointerException%2C%20undefined%20is%20not%20a%20function&amp;cmpt=q Maybe someone could add common error messages from other languages like Ruby, Python, Lisp, Haskel etc.
This is kind of new :)
i was thinking about using switches and the conditions, just wondering how i would do it....
tomeito, tomeito
This would be a good start https://github.com/mmccaff/PlacesToPostYourStartup
Why do you need forms for? What kind of application is this, maybe there is a tool for it, eg: [swagger](https://helloreverb.com/developers/swagger).
that was only the start, I used webpack for it, see http://www.reddit.com/r/javascript/comments/2n9012/get_real_with_es6_and_webpack/
I admit I didn't test at all in firefox. This should be fixed now :). When I started, I was using jQuery. Near the end of development I decided to replace jQuery with my own lightweight code and in doing that I didn't cover all the cases. Thanks for the help.
What caused this? (I mean the huge spike in 2013 / 2014)
you picked a tough one to start with. this one is building up the image as bits with math. as such this is a hard one to tweak from a art perspective. take a look at [threejs.org](http://threejs.org) for a higher level graphics api.
I haven't heard of Tomato/Tomato, what's the api like?
Every developer was a newb at some point. This might indicate that a lot of people might have gotten into programming starting from JavaScript.
I think U+2000 or 2007 are what you want. If not, try U+3000 █=U+2588 =U+2007 =U+2000 =U+2001 =U+3000
...Browser scripting.
\&amp;nbsp;="&amp;nbsp;" or 0160 It turns " words" into " words"
Yeah looks good and I appreciate the instructions in the upper middle but it's not obvious where I'm supposed to click. Maybe some floating arrows or a tutorial or something. Thanks.
I was an avid firebug user, some day i discovered that firefox tools were better (more like chrome's), and i had to say goodbye to firebug.
Of course, it also happens if you misspell a method name, eg `Math.sine(1)`, or do something equivalent. I expect this is the vast majority of cases it comes up.
Standard in is not a titty. 
That's actually Hebrew for " ; twice"
It's easy to accidentally make typos now and then too. Unless you're implying all good developers use JSHint in their workflow ;)
Something like. function keydown_event(e) { var result, pos, len; if (typeof options.keydown == 'function') { result = options.keydown(e); if (result !== undefined) { //prevent_keypress = true; return result; } } if (enabled) { if (e.which === 8) { //backspace // Whatever you want to do here. } } $(document.documentElement || window).bind('keypress.cmd', function(e) { var result; if (e.ctrlKey &amp;&amp; e.which === 99) { // CTRL+C return true; } return result; }).bind('keydown.cmd', keydown_event);
It's yet a bit raw.
&gt; Requires server-side JavaScript. You won't be able to apply Handlebars templates to your client end without having a Node.js or any other Javascript based server. What? That is complete nonsense. You can just save your .handlebars files on the server and fetch them using an ajax call and compile them and use them on the page.
var el = document.documentElement || window; el.addEventListener("keydown", keydown_event, false); I think is all you want to replace the jquery with. I'd personally do it all in line and not hover above, move a span that surrounds the cursor element. i.e. &lt;div class="cmd" style="width: 100%;"&gt; &lt;span class="prompt"&gt;js&amp;gt;&amp;nbsp;&lt;/span&gt; &lt;span&gt;te&lt;/span&gt; &lt;span class="cursor blink"&gt;s&lt;/span&gt; &lt;span&gt;t&lt;/span&gt;&lt;textarea class="clipboard"&gt;&lt;/textarea&gt; &lt;/div&gt; If you see where I'm going with that. However, will \&amp;#x2000; not work? because it acts as a&amp;#x2000;&amp;#x2000;&amp;#x2000;&amp;#x2000;&amp;#x2000;&amp;#x2000;non breaking space.
wow a fucking ";" was jamming me up this WHOLE time????????????? motherfucking $@$%! thank you though. i feel like i should be hugging you while you are slapping me.
5 was an arbitrary number. the assignment doesn't say for how long the loop should go for. all it says is to use a while() loop. i picked 5 myself. i did not know about not having to use var if i was changing a variable's value though. so var is just to create it and then i can just use = operators to edit the value, correct? 
Yep, essentially "Unexpected double two-dots".
See the [previous discussion on Hacker News](https://news.ycombinator.com/item?id=8664671).
yeah but no JS dev should google that more than once.
If $ is not defined, that means jQuery isn't loaded (yet?), but your entire code depends on jQuery.
Languages don't become popular from experts using them.
From codecademy, Math.random created a random number from 0 to 1. You have to then break that down into 3 parts with if, else statements
Because your array is filled with Strings and not numbers :) If you are certain it will always contain numbers (integers or floats), try this approach: var array1 =[ '0', '1', '2', '3', '4', '10', '6', '7' , '8' ,'9' , '4']; var highest = -1; var cur; for ( var i = 0; i &lt; array1.length; i++ ) { cur = parseInt(array1[i], 10); // or parseFloat(array[1]); if ( cur &gt; highest ) { highest = cur; } } document.write("Highest is: " + highest.toString()); Or simply fix the array entries.
duh.. I cant believe I didn't see that. thanks 
You could also use Math.max and apply it to an array like so...as an alternative solution :) var arr =[ '0', '1', '2', '3', '4', '10', '6', '7' , '8' ,'9' , '4']; function maxArr(arr) { return Math.max.apply(null, arr); } alert( maxArr( arr ) );
You should direct these kind of posts to StackOverflow.com or even just do a google search before asking for help here...
totally rotten, by now.
I will call it that henceforth.
I find that outside of your basic concepts like map / reduce /etc - practical examples seem to be hard to come by. I also found it hard to get my head around currying/partial application - but it was one of those things where it was: "Ok, currying looks neat, I'm looking up functional JavaScript - and underscore keeps coming up, how do I do thinks like being able to leverage currying with underscore?" - and you end up getting some ugly boiler plate in the process. Recently been introduced to [Ramda](http://ramda.github.io/ramdocs/docs/), and also [this good slide deck on it](http://scott.sauyet.com/Javascript/Talk/2014/01/FuncProgTalk/) - and by putting the functions first, the data at the end - lots of the concepts that were tripping me up started to make sense. It's one of those things where in theory - it all kind of makes sense, and seems neat - but when trying to apply them to the types of problems I deal with daily, it gets to be a bit 'ehh .. errr, hows this actually work?' (samples in the slides were actually pretty good and made a few things click for me)
I always make sure to make my code linted ;)
You're not going to like my response because it won't really answer your question. There's nothing real-time about trulia and Zillow. They're not constantly refreshing prices and data up on the screen while it sits there. Its not a stock ticker or market watcher. Your question is the same newbies ask again and again. They stress about a framework for a tool they've never user before and know next to nothing about to begin with. Why do you think your site will need to handle a massive load? You haven't built anything yet to know that what you want to be building is attractive or viable. If you think your first project is going to take off and be a huge success then more power to you, but the reality is it will be a learning experience every step of the way. You're not going to get it all right on the first go. Ember, Angular, Backbone, Knockout, vanilla Jquery, or even more plain pure JavaScript. It really doesn't matter. Its all JavaScript and you'll need to learn JS anyway. Why are you so concerned about none language? The web requires you to know more than one thing. It's a fact of life. Get used to it. You need HTML, CSS, JavaScript, a back end server language like PHP, Ruby, Python, C#, Java, ColdFusion... Something. Start small and build up from there. Get pages rendering with data pulled from a database, then add more features. Instead of worrying about your framework, just BUILD SOMETHING. What you thought you need to know or thought you needed to do was probably wrong anyway. That's the nature of development. Our first assumptions are often wrong until we become more immersed. 
much better. 
Did not cross my mind at the time. This is definetly a better way of handling this specific task :)
Well since I'm getting downvoted for what I said above...beleuchtung is correct that it's not defined before you are trying to use it. Before the script above is executed make sure you have included jquery. You can easily check just by trying console.log( $ ) and if it shows as 'undefined' then it hasn't been loaded yet. A simple pattern to avoid leaving your stuff global like it seems you have it is... (function( $ ){ // code goes in here ( now everything is scoped and not on the window object exposed globally ) console.log( typeof $ !== 'undefined' ); // needs to return true for u to use it }( jQuery ));
I've never used meteor to create a full web app but I can tell you that if you are a newbie you probably arn't going to have a good time starting off with something like that framework. The idea of an isomorphic application is great but I'm pretty sure you will need to learn web development concepts and perhaps learn in a framework that has way way way more practical examples. I'd say in order of choice Ember -&gt; Angular -&gt; Backbone -&gt; Vanilla Ember and Angular are very opinionated and have a large community and are considered "2nd" gen so those are probably good choices. Backbone is "1st gen" and you can do some silly things if you arn't careful managing your views and subviews. As a newbie you won't be careful so I'd say that's out. Vanilla is great but if you are a newbie its going to take you x3 as long to do the same stuff and still have code organization. You will need to learn javascript regardless of what you pick since you are talking web dev and we arn't in 2004 any longer.
This looks like an awesome model to use with bitcoin payments and dapp applications
If you are new to web development I would recommend building the website with just plain old Javascript. Learn the concepts and patterns and put a strong focus on the fundamentals. When you are ready to move forward, look into a framework and rebuild your website. It will take you no time and you'll be amazed at how fast you can build something. Getting ahead of yourself because of a new cool tool will be very frustrating for you when you are trying to debug an issue you don't fully understand. Javascript is not as hard as it looks initially. Take the time to understand how it handles your data and how to best use design patterns. Good luck your build! :)
Isn't this just proof that some big site somewhere presented this error to lots of users?
Or /r/learnjavascript Don't know why you were downvoted. Questions like this, what looks like homework, get downvoted because this is the wrong subreddit. Have an upvote.
Can you explain to me what linted and radix are? Thank you.
I bet money it's Angular. Meaningless error messages are one of its endearing features.
If you start out with Meteor you're gonna have a bad time. I recommend building it in Django and add javascript as needed.
I think the articles title with Creating is much better than Forging. I expected this to reveal some insecurity 
Most statically typed languages also have nullable pointers, and that they are null is not known until runtime. The few exceptions make you pay dearly for the convenience.
Or if you misplace your 'this'
the radix is the '10' in 'parseInt(array1[i], 10);' The function parseInt takes as its first parameter a string to parse and as its second it takes an integer which tells it which base to parse it into. 10 is the default if you don't supply it, but there are situations where that gets messed up and you get something totally unexpected, whereas if you specify it as is done in this example that cannot happen. JSLint is a tool that spots potential issues like that. 'andersevenrud' is saying that they always use JSLint to validate their code.
You've given .34 (rock), .34 (paper), .32 (scissors). Math.random is not inclusive of 1. [0, 1). if (computerInput &lt; 1/3) { computerInput = "Rock"; } else if(computerInput &lt; 2/3) { computerInput = "Paper"; } else { computerInput = "Scissors"; }
I liked this version from a while back. var matches = [ "Both are rock, tie", // rr "Paper beats rock, comp wins", // rp "Rock beats scissors, player wins", // rs "Paper beats rock, player wins", // pr "Both are paper, tie", // pp "Scissors beats paper, comp wins", // ps "Rock beats scissors, comp wins", // sr "Scissors beats paper, player wins", // sp "Both are scissors, tie" // ss ]; alert(matches[ 3 * parseInt(prompt("Rock=0, Paper=1, Scissors=2"), 16) + Math.floor(Math.random() * 3) ]); If you only care about who wins: var matches = [ "Tie", "Comp wins", "Player wins" ]; alert(matches[ (2 * parseInt(prompt("Rock=0, Paper=1, Scissors=2"), 16) + Math.floor(Math.random() * 3)) % 3 ]); 
No they don't. I've been using languages with null safety for years. No inconvenience at all.
You could if you rely too heavily on the authentication and access control stuff in weird ways, but there really isn't anything all that magical about it in general. Most of its appeal is in how obvious its semantics are. I have ported a couple apps from firebase to websocket APIs without too much trouble. 
Please name them.
This is... amazing.
Although this code is in PHP it is almost the exact same code to do this in JavaScript: [Conditional Matrices](http://www.reddit.com/r/PHPhelp/comments/2nicrw/rock_paper_scissors_lizard_spock/cmdw5rg)
thank you
Actually, in practice the most common reason to get "undefined is not a function" is calling a non-existent method on a real object - an error that a static type system could prevent regardless of whether it's null-safe or not. (If the object itself was null/undefined in an object.method() call, you'd get an error on the property access, not the function call.)
I'm not sure you want to see a Haskell error message. They are informative, but quite an overload to look at initially.
Ah, sorry, it's not down, it's my mobile BaconReader app on android showing me a 'website not available' message for some reason. Trying it in mobile chrome works great.
Won't that fail about 1/4 of the time? The random call could generate 2, which isn't one of the possible choices. 
AtScript doesn't do static type checking despite the annotations, IIRC.
I'm interested. Could you tell me more about how you see Servant working with bitcoins and dapp applications? My email is on the Servant website. Best, Austen
Apart from the defined languages, a recent language with this feature is [Rust](http://www.rust-lang.org/) (both values and references are guaranteed to be non-null - to have nullables you need to wrap your type into an Option).
Yeah I fixed it, forgot that case.
And rust pointer semantics are not the most convenient thing to work with. Maybe once the language stabilizes and we see how libraries form around static regions/lifetimes, the picture will be different. But I am not confident that the restrictions inherent in rust pointer semantics will ever play nice with high order functions. Rust is just a baby yet though. Its pointer semantics are bound to go through another overhaul or 2 before it stabilizes.
There are other options to coding with one language (JavaScript) that is not meteor. You can use the mean stack (mongo express angular nodejs) and unlike meteor the mean stqfk and node are used on real sites.
Right. Though the most inconvenient part of this is generally not that it is happening at runtime anyhow, its that it makes no reference to anything relevant to the lexical scope in which it occurred. You do not actually need a full blown static type system for this, just parsers that construct sane stack traces.
My experience differs quite a bit from yours - I don't find the overhead of the type checker in Haskell or Scala particularly burdensome - quite the opposite. I generally use it to guide me to the correct solution, and I'm often faster with it than without. For me, "Convenience" is any tool that lets me do my job better. A static type checker might feel to some like it requires a little more initial cognitive effort at first, but requires far less time and effort to debug your code. When writing Javascript, I spend 90% of my time digging through stack traces and stepping through debuggers and console.log output to work out when something isn't working. In contrast, code I write in Scala or Haskell almost universally works the first time I run it. Certainly not 100%, but close enough that it's pretty rare that I rarely if ever do runtime debugging. Obviously everyone's coding style is different and not everyone likes to work this way. But for me, having spent years as a Python developer, and working heavily on both Scala and Javascript codebases in my day job, I'm far, far more productive and can write much more stable code with an ML style type system than a dynamic one. I'm simply pointing out that, at least from my experience, statically typed languages are far less burdensome than people seem to think. I'm not saying static typing is the "One True Way" and demanding people bow down at the Ivory Tower alter in front of Simon Peyton Jones. People are most welcome to keep using dynamic languages if they prefer. I won't be offended. I was replying to what I considered a misinformed post about the hurdles of static typing, not trying to convert the world to Haskell as the meaning of life, the universe, and everything. &gt; or by just getting used to doing things using mind bending masses of complexity like implicits and monads I'm still not sure why people find Monads so confronting. They are an incredibly simple and trivial construct that takes about 15 minutes to explain and have somebody using productively in Scala - I say this from experience, since I've thrown several developers into the deep end into a Scala codebase with heavy use of Monads - with no prior FP experience whatsoever - and every single one of them has hit the ground running and been writing productive code within a day. &gt; there are plenty of perfectly sound programs that require you to do cartwheels for days and weeks in front of the type checker to convince it that you know what you are talking about. Sure, and if you happen to have a problem that is best solved in a dynamic language than you should use one. I'm not stopping you. The thread was about null safety, and I was replying to a post with false misconceptions claiming any language that provides static null safety are difficult to use. I provided several examples of language that provide null safety without being difficult to use. Even if you want to make arguments about Scala or Haskell being some mystery voodoo languages that only savants can use (they aren't), there's still the examples of - Kotlin - which performs null checking the same way every other Algol language does - but simply verifies at compile time you've done it. - Java with nullability annotation, which does the same - Flow, which adds partial (but pretty good) null safety to normal, unmodified Javascript code *in a dynamic language*. There's also numerous languages with optional static typing if you want compile time guarantees in most cases, with the trivial ability to bypas the type checker if you want to.
Sure. "There are languages everyone hates and languages nobody uses". Still popularity is not indicative of anything except wide appeal. Certainly nothing to do with quality. 
people think they love javascript ... but they really just love the dom api! 
I think that article is pretty misleading actually. It seems to suggest that a function only becomes a closure once it "lives on" past the end of its parent function (either by being returned or assigned as a callback, for example). This simply isnt true. All functions in javascript are closures. for example: var x = 2; function logX(){ alert(x); } logX(); Here, logX is a closure. In fact, you dont even need the outer `var x` declaration. just logX by itself alerting "undefined" would be a closure.
No. JavaScript is a functional language. Functions are first class citizens, like objects. You can pass functions around just like other objects. var fun = function(fn) { fn(); }; fun(undefined); =&gt; undefined is not a function This is indeed the JavaScript pendant to (e.g.) a NullPointerException in Java.
If only I could see the overflow content of the tables on my mobile device. "Front end developer" ...
That would indeed be nice.
If you need a framework to use another framework, I guess you're doing it wrong...
You mean the framework or the... oh I see what you did there.
On the surface it's a valid point. Dig deeper and this more like a relationship between jQuery and other JS frameworks that depend on it. For example they are using AngularJS directives to power their own stuff. 
An example of pragmatic javascript usage. Excellent ;)
http://lmgtfy.com/?q=flash+hangman+tutorial
There's a difference between extending a framework with further functions or introducing a further layer of abstraction.
That's not really a valid principle. In fact, having different frameworks that do one thing and do them well (which though, I think is fair to note, cannot _really_ be said about Angular), and combining those you need for your purposes isn't really doing it wrong. Your comment is just phrasing - and what I said above is as well. There's not really argument for why it is "wrong".
The author seems to be very confused about difference between function declarations and function expressions. The entire first table is wrong, past 1st row. function(num1, num2) { return alert(num1 + num2); } ..is not an "anonymous function declaration". There's no such thing as anonymous function declaration. Function declaration, unlike function expression, must have an identifier (https://es5.github.io/#x13). (function sum(num1, num2){ return alert(num1 + num2); }(1, 2)); ..is not a function declaration either. How can you have FunctionDeclaration as part of GroupingOperator (`(` and `)`) if that operator can only contain an expression — https://es5.github.io/#x11.1.6 :) And so on. http://kangax.github.io/nfe/ goes into more detail on all this.
&gt; Add the fallowing before the BODY tag in your html file: **fallowing**
I guess jQuery did something wrong because it also had jQuery mobile, jQuery UI. Or that Express JS is doing something wrong - because many people use frameworks built on top of express instead of using Express itself. Or - the base library/framework gets out of your way enough that building a framework on top of it is actually a smart choice. Angular aims to solve very different problems than Ionic - and Angular happens to be a good tool for Ionic to build on top of. 
Yeah I saw the slides earlier, definitely one of the better ones out there. I've noticed a bit of the same with practical examples... there's a lot of theory and basic stuff, but when it comes to practice not so much. Maybe more if you actually learn Haskell or something, but even then it's generally far from web development.
Ramdas implementation of pipe/compose is also rather handy - especially now that they have a version that works with promises - pPipe/pCompose. Being able to have something like var someValidationProcess = R.pPipe(step1,step2,step3,step4) someValidationProcess(inputData).then(function(result) { }) has actually cleaned up a bit of code - and it's only scratching the surface There was a bunch of things that felt like should have been easier with underscore / lodash - but the simple thing of moving 'data to the end' instead of at the start, R.map(function,data) instead of _.map(data,function) has actually made quite a few things click for me and feel more natural. 
You and people like you have a very good point about what you're saying. But please answer me honestly. How long do you think this will be sustainable? Will 45 year old you be capable of keeping up with 27 year old you? Also, are your employers paying for the time that you spend learning? We, as people, should be worried about how we can get more for less, but it's exactly the opposite for web devs. I think this is the only profession in which people purposely give their own time to learn new stuff every time changes happen. Because it's addictive and we like it. And then other people make real money out of us while we (sometimes) get a moderate raise.
45 year old me can already code circles around 27 year old me. I suspect 70 year old me will do the same to me. You know why? There are tricks you learn, if you're smart, that make developing easier. Syntax doesn't matter. It changes constantly, but the underlying concepts are the same now as they were in the 60s. The rest is just abstractions built on top of that. When you understand what those abstractions are buying you, there ain't nothing new under the sun. 
... or it could be developers learning from their mistakes... 
Walk through your logic. When they click the submit button, what *exactly* is running? When does it *stop* running after they click it? What's missing there? Remember, it runs the function you specified, not the whole script block! This is also a good time to learn how to use breakpoints and step through what the javascript does! Press F12 to open chrome dev tools and learn how to use breakpoints! You literally tell it to stop where you want and then press 'next' a lot to go down line by line as it executes each line to see exactly what the code is doing. Google for more.
That's the first good explanation in that thread. I still dislike the whole "throw enough frameworks at your problem and it will probably vanish" stuff, but that's my own opinion and I will accept that others have their own.
Fair enough. My favorite framework remains vanilla.js
I'm not sure what IIFE have to do with defining a function.
From what I understand everything in javascript is an object. You need to parse it if you want to navigate it as xml DOM. if (window.DOMParser) { parser=new DOMParser(); xmlDoc=parser.parseFromString(txt,"text/xml"); } else // Internet Explorer { xmlDoc=new ActiveXObject("Microsoft.XMLDOM"); xmlDoc.async=false; xmlDoc.loadXML(txt); }
Just got some ideas of the quiz. Here is my work! http://jsfiddle.net/yumiko/L5y2gng9/5/
Yeah, somehow he thinks an expression has to be an assignment to a variable, but that's just not true. Strange he didn't even test these, his unnamed declaration will throw an error.
Looks good. http://jsfiddle.net/9eu6xgsd/4/ This is what I was talking about before re: backspace.
First of all, this result is common for the internet explorer, which created a snippet of document.all when collecting Nodes. It's more for historical reasons than for anything else. Actually the W3C DOM specification is rather vague about the constructor of DOM Node collections; For example, Safari returns them with type=function instead of object.
i believe meteor has an easier learning curve for someone starting out than using ember or angular. not saying that it's the ideal framework for this situation but i guess for someone starting out it's an advantage in terms of time to have the full stack set up for you already.
Hi, I am a newbie to space missions and I need to know if Arianne 5 is the best rocket to launch a telecommunication satellite.
I spent more time than I care to admit on this, thanks for sharing.
Yeah, my team tried out ionic during the prototyping phase of the iOS app we made this summer, after already having a version in angular. The main screen of our app has a pretty massive table view, and there was nothing we could do in ionic to make it scroll smoothly. Hybrid apps seem like a cool idea until you actually see one running. Maybe things will improve in the future, though. 
Wow. I remember spending my pocket money on this game on the SNES ~20 years ago. Don't think this is that different (at least for the first 10 minutes play)... How long did it take you to make?
Thanks for your reply. I'm just getting started to learn more about Javascript and programming in general and while I feel young and capable, I know that at 17-18 I was a much faster learner than I am now, so I was worried that I won't be able to keep up in a few years if things keep changing like they do now.
how do you deal with pollution?
There are also other ways to solve this problem. For example, you can hide some of the latency using time warping techniques: https://www.youtube.com/watch?v=YD7iqHJ0NUI&amp;list=UUnWkvAQheWcjbpgmPWQj84w
going on 3 hours now... must. stop. playing.
I was assuming it meant more parks and tearing down less trees - I did that and my pollution is still "very high" :-/
Anyone know what this thing floating around in the water is? (it moves ... ) [Imgur](http://i.imgur.com/dZYB5yb.png)
a boat?
Would be interesting to see comparison table of these similar to canvas one — https://docs.google.com/spreadsheet/ccc?key=0Aqj_mVmuz3Y8dHNhUVFDYlRaaXlyX0xYSTVnalV5ZlE#gid=0
that's when the "drama era" for javascript started.
This days I hate everything that come from Angularjs.
What does this have to do with JavaScript?
Who cares?!
I meant to get js help
Replace coal with nuclear. Reduce density of your industrial zones by mixing them with parks.
Yeah, it's completely not a way of defining a function. It's just doing something with it after you've defined it.
Eh, I've seen some good question and answer threads on reddit. And occasionally you'll see someone reward gold to a helpful answer. Obviously stack overflow is better for pure question+answer stuff though. 
former Simcity dev here. Just had to say this is *really* damn cool. Definitely going to share this around. Keep up the awesome work! One suggestion i would like to make. In Simcity, clicking the right mouse button de-selected the active tool. This makes it easy to go back to moving the camera around without having to navigation the menu again or accidentally placing something. Also, the Esc key would deselect the active tool as well. Its a tiny thing, but makes a big difference in usability :D
Array object inherits from the Object object and has unique methods on its prototype. A node list is not an array. It does not have access to the Array prototype and so receives none of the array methods. It is just a listed collection with a length property. The primary difference though is that a node list maps to an API (DOM) instead of data natively available from within JS.
$ is a variable, just like any other. It just happens to be named $. This was initially used by jQuery, but has been adopted by any library that has a selector engine (aka DOM lookup). The reference error you're getting is simply telling you that $ has not been defined. This means that jQuery has not yet loaded on the page at the time where your code executes. Also... I refactored your code.... var choice = { rock: 0, paper: 0, scissors: 0, lizard: 0, spock: 0 }; var choices = []; for(var c in choice) choices.push(c); var TIE = 'Draw'; var WIN = 'Win'; var LOSS = 'Lose'; function setRules(tie, loss){ loss = loss.split(' '); for(var c in choice) choice[c] = WIN; choice[tie] = TIE; choice[loss[0]] = LOSS; choice[loss[1]] = LOSS; } function result(target, opponent){ switch(target){ case 'rock': setRules('rock', 'paper spock'); break; case 'paper': setRules('paper', 'scissors lizard'); break; case 'scissors': setRules('scissors', 'rock spock'); break; case 'lizard': setRules('lizard', 'rock scissors'); break; case 'spock': setRules('spock', 'paper lizard'); break; } return choice[opponent]; } var wins = 0; var losses = 0; // shorthand for $(document).ready() $(function(){ // cache our selectors to improve performance // these are defined as global variables // (notice the lack of the var keyword) $rsplsgame = $('#rsplsgame'); $choice = $('.choice'); $choiceText = $choice.find('span'); $choices = $('#choices'); $info = $('#info'); $again = $('.again'); $choice.click(function(){ $rsplsgame.removeClass('rules'); $info.animate({opacity: 0}, 300); $choiceText.animate({opacity: 0}, 300); }); $again.click(function(){ $rsplsgame.addClass('rules'); $info.animate({opacity: 0}, 300); $choiceText.animate({opacity: 1}, 300); }); $choice.click(function() { var userChoice = $(this).attr('id'); var compChoice = choices[Math.floor(Math.random() * choices.length)]; var userResult = result(userChoice, compChoice); var compResult = result(compChoice, userChoice); $choice.removeClass('win lose draw'); $(this).addClass(userResult.toLowerCase()); $choices.find('#' + compChoice).addClass(compResult.toLowerCase()); (userResult == WIN) &amp;&amp; ++wins; (userResult == LOSS) &amp;&amp; ++losses; $info.animate({opacity: 0}, 50, function(){ $info .html('') .append('&lt;h3&gt;You ' + userResult + '&lt;/h3&gt;') .append('&lt;p&gt;Wins: ' + wins + ' - Losses: ' + losses + '&lt;/p&gt;') .animate({opacity: 1}, 50) }); }); });
no demo, no bower install, no thanks.
God yes, the camera controls are the largest falling here. I accidentally built a nuclear power plant trying to move the camera...twice.
Accidentally placed a fire station because of this. Didn't know how to remove it so my funds slowly diminished.
OMG...You are super sophisticated. Thank you so much for helping me up. I learned a lot from you comments. 
&gt; From what I understand everything in javascript is an object. JavaScript also has primitives. https://people.mozilla.org/~jorendorff/es6-draft.html#sec-primitive-value "member of one of the types Undefined, Null, Boolean, Number, Symbol, or String" That's why there is crap like this: &gt; typeof 'foo' "string" &gt; 'foo' instanceof String false &gt; new String('foo') instanceof String true Dart, for example, doesn't make this distinction. There are no primitives. print('foo'.runtimeType); // String print('foo' is String); // true
Sloppy... Yikes
now to create some type of collaboration mode. Where the city will never sleep. Websockets maybe?
or we write the worst possible solution so they get an F and go back to typewriter maintenance.
Nah I'm not using any libraries for this. I'll take at look at your code, though. Thanks!
&gt;When writing Javascript, I spend 90% of my time digging through stack traces and stepping through debuggers and console.log output to work out when something isn't working. In contrast, code I write in Scala or Haskell almost universally works the first time I run it. Certainly not 100%, but close enough that it's pretty rare that I rarely if ever do runtime debugging. When I write Haskell, I spend 90% of my time staring off into space trying to figure out how to trick the type system into doing what I want it to. People forget that there is also a design phase to programming, and do not account for it in their estimation of time spent and effort exerted. While I too like debugging less, and the power of debugging and testing frameworks and tools that strong static type systems make possible, I do not like the CONSTANT cognitive overhead of strong static type systems that you have to contend with before even writing a single line of code. It isn't just an learning curve thing. I have been coding in haskell for about a decade, and the things that bugged me about it in my first month of using still bug me today. &gt;I'm still not sure why people find Monads so confronting. They are an incredibly simple and trivial construct that takes about 15 minutes to explain and have somebody using productively in Scala - I say this from experience, since I've thrown several developers into the deep end into a Scala codebase with heavy use of Monads - with no prior FP experience whatsoever - and every single one of them has hit the ground running and been writing productive code within a day. Yes, if some system has already been designed and mostly implemented, you do not really need to understand monads (even in haskell sometimes), just the chunk of code you are working on at the given moment (for the most part). But if you are the person looking at a functional specification, and a blank editor, its a slightly different story. But either way, it is still difficult for many many many many many people to wrap their head around even their usage. Why? I dunno, its just not very intuitive, and programmers in particular are not very good at just using a tool without first understanding how all the moving parts cooperate. I have no experience with monads in scala, so maybe scala makes them a little more obvious. I know F#'s computation expressions (while not really monads) do in fact make the utility of monad-like abstractions obvious. &gt;The thread was about null safety, and I was replying to a post with false misconceptions claiming any language that provides static null safety are difficult to use. I provided several examples of language that provide null safety without being difficult to use. The point of null safety is for you program never to be in a nonsensical state. In practice, in languages like haskell and the like, people don't actually use null safety. Even the prelude contains functions like *head* on pure well typed data structures that never the less fail if used with an unexpected value. The alternative would be a function like *maybeHead*, and even then you are just pushing the burden of runtime checks off to something else. The consequence of not checking that a list is empty, or getting the value closed over by an option/maybe type without checking for the Nothing/Null alternative is exactly the same as accessing the property of a possibly null/undefined value in javascript: a runtime error. The consequence of doing it everywhere is that now a substantial part of your code is superfluous runtime checks. If you want to follow this to its logical conclusion, the only programming languages that are actually null safe aren't even turing complete. The are total languages, most of which are dependently typed, and something as trivial as a week of cartwheels will not get you anywhere near tricking it into believing that your program is well typed. And no, I was saying that languages actually used today that have static null safety do so with large penalties elsewhere. I use functional programming languages in large part because I can deal with this trade off without much trouble for the most part.. I love new programming languages and type systems and all the bleeding edge stuff--academically, but in general when I want to get paid on a regular basis I am going to choose something that I know I can actually get to a first milestone within a reasonable amount of time. 
haha. it is because you have to unlearn all the lessons you've learned over the years and go back to newb coding. I browse this for shits and giggles. Its hilarious: http://codecrap.com exec('sudo ' . $_GET['command'); //one of my favorites
 &lt;option&amp;nbsp;/&gt; The fuck? Also, create a test case (jsfiddle etc). **Edit:** Works just fine: http://jsfiddle.net/jrvzrxq1/
The URL is a string, but you're missing quotes around it, so JavaScript is going to try to find an object named `google` and then look for a property of it named `com`. This should have resulted in an error in the console about an undefined reference to an object named `google` which should have been a hint. 
In a few cases the function constructor creates very fast functions, at least with SpiderMonkey.
Plugin.prototype = {} //avoid overwriting the default prototype
You don't have to use JavaScript. Use the target attribute on the link. That's what it's for. `&lt;a href="http://google.com" target="myFrame"&gt;Google&lt;/a&gt;` `&lt;frame name="myFrame"&gt;&lt;/frame&gt;` Though frames are deprecated. Use iframes instead.
Awesome
&gt; When I write Haskell, I spend 90% of my time staring off into space trying to figure out how to trick the type system into doing what I want it to. People forget that there is also a design phase to programming, and do not account for it in their estimation of time spent and effort exerted. Look... I really wasn't trying to get into a "Haskell is teh awesome" debate. Some people like it, some people don't. I'm getting to the point of being scared to even mention the language on Reddit, since inevitably I'll get drawn into a debate by somebody trying to convince me it's the worst thing ever - even if I only allude to it in passing. It was one language mentioned among many, and not even the primary one I was using for example. So I'll summarise it as so - Every developer thinks differently, and is trying to solve different problems, so the best language is the one that works for you personally for the task at hand. If it lets you deliver a stable product in a reasonable timeframe, it was the right choice. In my case, I found Haskell (and all the baggage that goes with it) to match my style of thinking very closely, so it works for me. This doesn't mean I don't have gripes with it - it has plenty of things that shit me, and I consider it a transition language that's best suited to inspire a new generation of languages (i.e Rust). But it's the "least worst of" that I've tried for me personally. Your results may be different. That's fine. We don't have to both prefer the same language. &gt; The point of null safety is for you program never to be in a nonsensical state. In practice, in languages like haskell and the like, people don't actually use null safety. Even the prelude contains functions like head on pure well typed data structures that never the less fail if used with an unexpected value. Yep, Haskell is not completely safe language. True totality checking is a hard problem - and as you say, fundamentally you can't have 100% totality checking in a turing complete language. The primary difference between safety in (say) Haskell and Javascript, is that in Haskell it's opt-out. It's trivial to avoid using partial or unsafe functions, and if you do occasionally need to use an unsafe function, you have to make a direct decision to do so. Yes, technically you can make a mistake that will fail hard at runtime (or recurse forever) but it's much harder to accidentally do, and it's much easier verify with tools. In (say) Javascript, everything is unsafe by default. It's difficult to use linting tools to verify correctness, and it depends entirely on a lot of developer vigilance and discipline to make sure you're catching all edge cases. Haskell may not provide 100% totality checking, but that doesn't mean you should throw the baby out with the bathwater and give up on the concept entirely. To be very clear, I'm not making this specifically about Haskell vs Javascript, or saying that one or the other is universally better. There are plenty of languages on both sides of that spectrum that would also hold true for these arguments. And to reiterate, in all cases, the correct language is the one that *works for you personally on the problem at hand*.
What the what? So first I need ruby and Jekyll then I need node/npm and yeoman? No thanks. I'll stick with Pelican, built in scaffolding command and only one language and package set to manage. Using a static site generator should make managing your site easier and require few tools. 
What about the theme, it looks better than pelican.
For such a simple game I'd just go with css. They're all very basic shapes with little animation
I don't really know what you're trying to do. But... If you have a string like: var s = "'abc', 123, def, 5.0, 'etc', whatever"; and you do... s.split(', '); you'll get an array such as... ["'abc'", "123", "def", "5.0", "'etc'", "whatever"] Be aware that all of those are strings and yes, you will get those `'` in your strings. So you'll probably have to clean that up, though it may make more sense to get better input to start with.
Firs, "looks better" is entirely subjective. I will agree pelican's default template is not the most attractive. Fortunately Pelican just uses jinja2 templates so finding another or writing your own is pretty trivial. This way you could replace the default CSS with say bootstrap 3 like I did on my site. https://stephentanner.com
If it's a well defined question stackoverflow is the one to use. If it doesn't have an exact answer is more theoretical, then reddit (there's a lot of great programmers on reddit). IRC is good for help and advice on your project specifically or if you don't yet know what question to ask or if you need to know something simple real quick. Stackoverflow is king but reddit frees you from having to be 1000% proper to avoid having your question deleted.
I'm reading a template so that is the way that it will come. Also s.split(', ') will break arguments like "The dog, jumped high".
They want you to pay with something that's "not a number". In other words, you need to pay with your body.
Also it's a bit of a hack, but couldn't you add brackets to it then parse it as JSON? It's basically JSON already: var s = '"abc", 123, "def", 5.0, "etc", "whatever"'; arr = JSON.parse("[" + s + "]") [JSFiddle](http://jsfiddle.net/ny0h5L9k/) 
Great idea, and so simple!!!!!! Also JSON.parse would take care of security issues.
Asking an IOS/Andorid developer for hes opinion on ionic is like asking a designer for hes opinion on a theme you just downloaded. Lets be honest - Ionic wont give you the smooth transitions and the native feel - but its *just enough* for most content centered apps. 
Yes you can. Thanks!!! [edit] The problem is single and double quotes. It would be nice to be able to use both.
[**@chhantyal**](https://twitter.com/chhantyal): &gt;[2014-11-29 13:02:06 UTC](https://twitter.com/chhantyal/status/538679295590555648) &gt;Thanks javascript, would be great if you could also let me know which currency to use to pay for this amount [*pic.twitter.com*](http://pbs.twimg.com/media/B3nF9tkIgAES_vc.png) [^[Imgur]](http://i.imgur.com/KI9PKfR.png) ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/2nr638%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
For anyone interested in these kinds of demos, I very strongly recommend [the nature of code](http://natureofcode.com/). It's a free ebook that combines coding with physics, nature and biology.
yeah, I'm getting this on mouse over. i don't know if it's an overflow easteregg or something
https://news.ycombinator.com/item?id=8673101
Definitely an easter egg (hovering shouldn't even do anything!).
Very cool!
Good one.
Superb One.. i was looking for the similar one... Thank you
Pro Tip: create your shell accounts more than 6 minutes before posting. And describe whatever this is, because I sure as hell don't know what's going on 
Have not used React, but I know ractive is pretty easy to pick up. It works wonders for SPAs'. Essentially, you can have a multi page website or app run on the index with template swapping and no page refresh. 
Yeah i was thinking about doing Array() on it, never really tried. I just did a loop cause i can in coffee.
This game is terrible!! How do you steer the fish? I tried arrow keys and wasd and it doesn't work! How do you feed the fish! All of my fish are dying! You should really make it easier for players. Maybe a tutorial or smth? J/K, great project ;)
I love this kind of stuff
requireJS is your good friend...
https://docs.google.com/spreadsheet/ccc?key=0Aqj_mVmuz3Y8dHNhUVFDYlRaaXlyX0xYSTVnalV5ZlE#gid=0
I would but I have to use JavaScript to do it
Usually when I see this, it's because JSON that needs to get parsed or there was a string without any numerical data they passed into parseInt(). If the web dev who built this site cleaned up the data, NaN wouldn't be a problem.
Shameless plug: I am working on a very simple framework called [DejoJS] (http://decojs.com) based around RequireJS and KnockoutJS that does just this. Instead of having javascript that runs for every page, or javascript that runs for specific pages, it has viewmodels that control certain parts of the page only. On page load it looks for elements with data-viewmodel attributes and loads the JavaScript file specified in the attribute and binds it to that element (and it's children) only. This let's you apply javascript to only the parts of the page you want javascript to control, and requirejs will load only the modules needed for that page. Adding more functionality later is also really simple. 
I still don't find this useful because non-primitives can't be hashed for collisions. Consider: var x = new Date(), y = new Date(x), // x.valueOf() === y.valueOf() z = new Map(); z.set(x, 1); z.set(y, 2); z.size(); // 2, would be nice to see 1 It's nice the key can be returned as a `Date`. But for Objects, if it's not the same variable reference, then it doesn't collide, which is not particularly useful... 
A little late, but webcomponents has a concept of 'unresolved' elements, and you can style them accordingly with the :unresolved pseudo-class. There is also the pattern of setting the unresolved attr on the body tag which (by some unknown mechanism) seems to wait for all custom child nodes to initialize before showing any of them. 
One of their initial goals (but don't think they have it anymore) was trying to have Ionic be 'framework' agnostic - but different wrappers/etc to use with other frameworks. Sort of 'write as much as possible as vanilla JS, then just wrap it up inside of Angular' - with Angular being the first integration that they worked on. Don't think that's a goal anymore and they are pretty much dedicated to angular now. 
oh my apologies, did not know the code would appear like this
Yes, actually I coded this after reading that book, i strongly recommend it. There's a link to it in the github repo (https://github.com/cazala/shoal), but I should add one in the demo too.
If the page specific JS is only a few kB, don't bother. &gt; it would not make sense to try and bind an event to a button that is not on a page You can use event delegation and a generic handlers. A big benefit of doing it that way is that the handlers will also work for dynamically generated content. So, for example, if you load the contents of some tab dynamically, the gallery inside will work just fine. The event will bubble up to `body` and your generic gallery handler will be there to handle it.
Try indenting by 4 spaces
Where I work, we use Require.js too. When I got there, it was set up so that each unique page had its own main.XXX.js file that bootstraps the required page modules. This way each page only has the JS that it needs. The drawback to this approach is that the Require.js config stuff, like mapping file paths to module names gets duplicated in each main.XXX.js file. We took a slightly different approach and created 1 file containing all the module name to file path mappings and require that first before requiring our page modules. There is an extra HTTP request involved because of the nested require statements, which will probably need to be addressed at some point. Something like this: // main.XXX.js file require(['config'], function() { require(['module1', 'module2'], function() { // bootstrap page here }); }); 
Yeah, it would be nice to see something like C# where you can override Equals() and GetHashCode() to have different objects in memory act as if they are the same.
Or better yet, make a [jsbin](http://jsbin.com/) and report back.
do they have a javascript wrapper? i couldn't find one when i looked. or can i just use post? o.O need a little direction
well i'm trying to build it into a greasemonkey script.. think anything out there would let me do this? thanks
they do.. i can just use a GM_xmlhttpRequest
yes i am using jquery in it. i'm going to mess around with them and see what i can do. think you can find a post example to write/edit them? that'd be amazing :)
yes
I wonder how far you could go to match the real game before performance bottlenecked you. Maybe in pathing?
I prefer ES6 module syntax over the IIFE module syntax. 
Is this a class requirement? function loadIFRAME(url){document.querySelector("iframe#iframe_id.iframe_class[name='iframe_name']").src = url;}
lol. you might want to go back to basics and read up on what an algorithm is. 
http://en.wikipedia.org/wiki/Algorithm &gt; In mathematics and computer science, an algorithm [...] is a step-by-step procedure for calculations. http://en.wikipedia.org/wiki/Algorithm#Informal_definition &gt;An informal definition could be "a set of rules that precisely defines a sequence of operations." which would include all computer programs, including programs that do not perform numeric calculations. E.g. some loop with one `if` inside is an algorithm. It isn't a very complicated algorithm, but it's still one.
I've been interviewed by worse. Edit: to be clear. That is an algorithm. Simple as that. Expressed in JS it seems (is) trivial. But you could express the same with maths. Not me, I'm not very good with math. But it's possible, and I'm pretty sure you'll be happy to accept that as an "algorithm"... The only difference? One seems trivial to you. 
https://github.com/do-web/jTinder/blob/master/js/jquery.jTinder.js#L168 Yeesh
I'd be interested in taking part in something like that (if not actually organising), but probably not on a daily basis. Maybe something more general web dev might have a slightly wider appeal as well. 
Hapi. It's the least bad of the bunch.
Oh of course you can't always get es6 though :(. One day maybe :)
At a guess; theName=name.value; theQuest=quest.value; theColor=color.value; is where your problem is coming in. You've assigned the result of document.getElementById to theName and not name. theName = theName.value might fix the issue with your code. However, there's a few other things which seem to be stopping it from working; 1) Variable Declaration - any variable needs to be preceded with a var to declare it. WRONG: something; RIGHT : var something; 2) document.getElementById syntax - if you're looking for a specific ID, pass a string. What you're doing in your code is passing a reference to a variable. WRONG: document.getElementById(something); RIGHT: document.getElementById('something'); ALSO RIGHT: var something = 'something'; document.getElementById(something); 3) Code formatting in general - This one's actually irrelevant for the code actually functioning, but if you're submitting code for others to review, make sure it's well formatted and very readable; it makes their jobs a lot easier because the code is much easier to understand :) 4) Now you've read this far ;) Here's a [link](http://codepen.io/anon/pen/gbaaKx) to the working codepen.
I've tried that, and changing it to theName.value just stops the code from working entirely. :c I've tried changing it to theName=toString(name);, and that just outputs [object undefined]. 
In the future can you please apply the code style to all that html? You just need to highlight it all and click the code button, and people might be able to read the code. To anyone else on /r/javascript. I made a fiddle http://jsfiddle.net/9un0temv/ Can anyone tell me how the document.getElementByID calls possibly worked without string arguments? Anyway to answer your question, I can't tell decisively why your code isn't working, but here's a working version as a JSFiddle: http://jsfiddle.net/dmof6acz/2/ Here are some of the things you needed to fix: * You haven't closed your &lt;p&gt; tags. Like all HTML tags, you need to close it with &lt;/p&gt; * You aren't declaring your variables with `var`. Always use `var` when you're making a new variable. * You aren't quoting the input IDs. e.g. `theName=document.getElementById(name);` should be `theName=document.getElementById("name");`. At the moment it's looking for a variable called `name`, which doesn't exist yet * You're storing a reference to an HTML element in `theName`, e.g. `theName=document.getElementById(name);`, but then trying to access it using the variable `name`, e.g. `theName=name.value;`
Reddit needs you to double line break for lines to show up properly :) Also, have you tried [Sublime Text](http://www.sublimetext.com/3) ? It's what I use at work and has a lot of syntax highlighting and linting built in.
I see. Good to know for future posts. I have not tried Sublime Text yet. I'll have to look at that. Thanks again. :) 
Does JS even do that? I think PHP has been known to do that but then what did we expect from PHP...
All good things to add to the list of things to work on remembering with this. Thanks for the pointers. :) 
The only way it could work is if there was a global variable named 'name' with a value that was convertible to a string. Debugging this live I'd just type 'name' into devtools and see what it evaluated to. (Probably set by code not shown.)
When you create a DOM element with id `name` some browsers automatically create a global variable with that name pointing to the element. Of course, you shouldn't rely on this behaviour.
Edit: removed my rant. Was useless. As for the answer, the javascript world has a lot of newcomers. And idiots. (ha! Mini-rant) I'm glad I have a lot of backend work to do the coming months :) 
They're calculated when the script is added to the page. Then maybe it would be better to add a list of values manually to the array, but for now the script just calculates them when creating the instance
Not with Firefox. It performs the native calculation way, way faster. It also outruns Chrome like crazy :D Tested on Arch Linux x86_64. Edit: it does help IE 11 (Win11) a bit though: with cache: 10,435 ops/s, ±1.63% faster. 32-bit Firefox on Windows outperforms both like crazy still, native only :)
Yep. I don't know what firefox did, but I guess they sold their soul to a demon to get this performance. Or maybe every other browser has a lame implementation of maths functions, but that sounds... weird
http://en.wikipedia.org/wiki/Stream_%28computing%29
&gt; in modern HTML, the doctype is often simply rendered like this: &lt;!doctype html&gt; No it isn't. Look in your developer tools of your browser. Look at the spec. But the rest of your post is correct.
I was honestly not expecting this wealth of information from one question. xD So much to learn, so much farther to go yet. Thanks for the tips, I'll do my best to work this in as well. :) 
I switched from requirejs to Browserify and I seriously couldn't be happier. requirejs seems so convoluted and overly complex now. Browserify just works in ways that requirejs doesn't. Definitely look into it.
What are you getting at exactly? You said it yourself, we like it. I'm doing this on my own for me not for them. They just happen to pay me for my services that might be related. Sounds like a dream job compared to most.
And you are?
This only does 360 angles. If you want to trade memory for computation speed when calling simple functions, you could do memoization.
You can make a table of size n behave like a table of size n^2 if you do sin(x) = sin(floor(x)) + cos(floor(x))\*(x-floor(x)) and cos(x) = cos(floor(x)) - sin(floor(x))\*(x-floor(x)). This is especially useful if you almost always need both sine and cosine together anyway. If you make your table use a power of 2 rather than 360, you can fit the angles into range with bit masking instead of modulus and then fixing up negative values. Then you can save an additional 3/4 of the table by storing a quarter cycle and reflecting/inverting for the other quadrants.
I've been making programming tutorials since 2007. I was trying to do videos beyond the basic stuff. I had to take a break though because work wouldn't let me talk about what we were making. I normally just make videos on what I'm working on. 
Well, both options are viable, my idea was that if you want fast computation, you might want it all the time, including the first time. If you use something like this it means the compute time of these functions is critical. If each time you are using a new number it has to be cached first, this can be a problem. Then appart from that, I don't think the huge startup cost is that huge. Compared to the loading time of a page, having a few ms of initialization doesn't seem to be a problem. I'd better lose these ms at the start once than randomly during my program execution. Then again, it depends on what you do. Another problem is that the code would need additional, "heavy" logic in the function to check if one particular number has been calculated before, and then either return it or calculate it and store it. Also, I don't know if that would be efficient, but since there aren't that much value they could actually be hard-coded, which would probably make the initialization time faster. But really, calculating 360 values doesn't have much cost.
I was thinking of that, but I assumed the computations needed to get the correct value would kill the performance a bit. Yes, you can store 75% less value, but really what's 360 floats in an array nowadays? On the other hand, the logic to fetch the correct value will be added to the processing time at every function call, making the overall thing slower. But really I don't know. I thought of that, didn't try it, maybe it can be better, if any code ends up with better performance let's use it.
Oh you're right. I was thinking in reverse - chrome is being 75% slower, but that means the code is actually 400% faster. Mixed things up in my mind. Well, 400% is cooler anyway
Completely forgot that they have a different name, thanks for the info
It depends. What are you trying to build?
Ha yea I did
I may have worded that poorly. By "rendered" I mean "written". Not how the browser displays it in the DOM inspector or how the spec uses it in its examples. Case in point: [even html5boilerplate uses lowercase](https://github.com/h5bp/html5-boilerplate/blob/master/src/index.html#L1) (and lots of projects use html5boilerplate as a start). I prefer the lowercase version, too, personally. The use of uppercase has historical reasons (a lot of SGML used uppercase and so did DTDs) and those reasons have nothing to do with what it means today (just an arbitrary token, like `"use strict";` in JS). To me, writing the stub doctype declaration in lowercase emphasises that this is not an actual (incomplete) doctype declaration but merely a vestigial token.
Agreed. This would likely be a short task with embedded SVG and CSS. Give the "lights" unique IDs, then the color change, for instance, is just a matter of changing the fill on the given ID. Not entirely sure about click/touch events in SVG, but I'm sure that's possible. That said, parent poster (or others): have any good resources on SVG? I just got into messing with that myself a couple days ago. 
OK I like the outcome but I was hoping for something cooler in the implementation.
Without some sort of iterator or differing information per request, how is this any better than a simple random token like a session ID? 
Use Date functions to determine the time, and set window.location.href to redirect. Don't rely on this to be accurate (i.e. it should only affect cosmetic features), though. It's using the client's clock, which could be set to anything. (Assuming you're talking about JS in the browser.) 
Right but what I think /u/x-skeww is saying is that runtimes like V8 will optimize the code for you and remove the body of the for loop because it's not doing anything. [This video](https://www.youtube.com/watch?v=65-RbBwZQdU) explains how that (roughly) happens.
Great post, my thoughts exactly. Relatedly, it often seems like the stronger the frameworks/libraries get, the more important your command of vanilla becomes. 
I'm a fan of picking and choosing components for web apps, but it's undeniable how fast an inexperienced (or specifically web-inexperienced) dev can bring up a web app with a framework. Additionally, when many not-necessarily-js-devs work on a product with a web app frontend, an off the shelf framework helps to enforce and inform some structure. Someone who doesn't know angular can learn just enough from stack overflow to make a change or fix a bug. When you roll your own, the onus of documentation is now on you.
This is why I love Dojo. I use vanilla wherever it makes sense, and Dojo everywhere else. Their dedication to backwards compatibility is incredible, and I don't have to pull in library X, library Y, and library Z, but library Y must be version 1 for X to work and the latest version of library Z wants version 2 of library Y, etc .NET Rocks has a good talk on it at http://www.dotnetrocks.com/default.aspx?ShowNum=1059
Another great article, Jimmy. Thank you for keeping us informed. 
Yes, I certainly agree that monolithic frameworks provide a well-worn structure. You can replace that with standards and 'best practices', of course, but an end to end framework can mean developers implement best practices unconsciously. A world without monoliths puts new emphasis on teaching architecture and specialized design patterns. We might even see knowledge of design patterns replace frameworks as the requirement in job postings.
Thank you!
Glad you wrote this, put words to the feelings I have had for a while.
This problem has actually already been addressed. They added a new collection-repeat directive that renders collections in a way that is very similar to how native platforms do. Check out [this blog post](http://ionicframework.com/blog/collection-repeat/) 
I am going through this exact thought process at the moment, I've been using angular for 2 years and I started writing a prototype for a new product in angular 3/4 months ago, stepped away to do some other work and then more info about 2.0 was released and React/Flux picked up pace. I've always wanted to pull away from it and use a modular approach yet it involves A LOT of R&amp;D and It's difficult to justify it to employers since Angular is so easy to be productive with initially.
Edit: sorry I didn't meant to reply to your comment I'm using the phone app this is meant for the main thread. I prefer callbacks over generators and promises. Callbacks are fundamental to all nodejs programming and promises / generators use callbacks under the hood. When choosing a library, I don't care if they use generators or promises under the hood as long as I'm not forced to use them myself. Synchronous code is a psychological coding style that doesn't work well with callbacks - generators and promises are better to use if synchronous code is what you prefer. When node 0.12 comes out, if Koa (or apps built on top) have an api that's generator agnostic I would probably use it over express. Better error handling and the potential for more stable / flexible / creative server patterns will probably emerge from Koa, but I'm waiting until 0.12.
I certainly hope so :) that ensures I'll always be employable lol
Dojo doesn't get much love around here, but it is stable, maintained, and it is a one-stop-shop for a heap of functionality which is developed together by the same people and released together. You don't have to worry about tracking a bunch of smaller libraries which may or may not even run correctly when put on the same page. 
Oh ok. Didn't watch the video but I think I see what you mean. It's not the case here I think, since we can clearly see that stuff gets executed differently depending on the code inside the for-loop
That's the clickbait effect. But it could be worse, I could have written "Someone found a way to get +400% performance for sine and cosine. You will never believe what the trick is!" 
Good link, thanks!
Yeah the problem here is that people are just trying too hard to make things easy and it actually just makes things more complicated. Holes aren't getting dug because everyone is too busy trying to invent a better shovel that makes digging easier but has a steep learning curve. A similar thing was happening with VB6 back in the early 2000s you couldn't find a help example to do a simple task that didn't include importing several dlls into your program, eventually the fad programmers will weed themselves out, but right now everybody and their brother wants to make mobile apps.
Excellent post. On several projects, I came very close to using many of the current JavaScript front-end frameworks &amp; libraries. Upon examination I quickly return to Ruby On Rails. Nothing in the JavaScript world has been able to sway me. I use jQuery, Ajax, Russian Dolls caching, turbolinks, my code is ultra efficient, compact.
I'll fill it out if you give us a copy of the resulting data.
I must say I've never drunk the Angular Kool Aid and stuck to Backbone, and now playing with React / Flux. Even when I had to use Angular it was something I had to do for work, like using a CMS I don't like, and never invested in it.
I think Dojo is terrible. It does a few nice things but it's totally not worth it. Whenever I had a tough problem or bug, it was *always* a "dojo problem", meaning - it could never be solved from outside - every problem needed to be patched in the source files. Also, I hated the stores/databinding, found too often that I need to do DOM manipulation and DOM events manually, etc etc etc. I used all my google powers to try and find better ways of doing things, but all I've found are very scarce and limited resources with very small community (as least on SO).
Just wanted to say that this was really well written. Kudos!
Regarding one of the final conclusions. &gt; The answer might be to eschew monolithic frameworks in favour of microlibraries Sounds very much like a Unix philosophy to me! Do one thing and one thing well (and I couldn't agree more)
Wow. Any advice for a final year university student looking to go into frontend dev, but is only lacking in JS? I was literally about to take the plunge and finally learn Angular/Ember since that's what most jobs I'm looking at list as 'desirable'. I know basic JS and programming concepts, but really I'm not much more than a humble jQuery noob. I know I *should* hunker down and just 'learn' JS but I've got a fear that no one will care unless I know my way around frameworks...
Here ya go. var onetime = function(fn) { var noop = function() {}; var executed = false; return function() { if (executed) return noop; executed = true; return fn; } }; $(window).scroll(onetime(function() { var styledDiv = $('.resume_right'), targetScroll = $('footer').position().top, currentScroll = $('html').scrollTop() || $('body').scrollTop(); styledDiv.toggleClass('fadeInRight animated', currentScroll &gt;= targetScroll); })); But you should know that jQuery has this functionality built in already: http://api.jquery.com/one/ $(window).one('scroll', function() { var styledDiv = $('.resume_right'), targetScroll = $('footer').position().top, currentScroll = $('html').scrollTop() || $('body').scrollTop(); styledDiv.toggleClass('fadeInRight animated', currentScroll &gt;= targetScroll); });
I don't like it either. Dojo does really weird things like reinventing fn.apply ... or as they call it dojo.hitch()
Thanks!
The advice is not to get invested in any one framework...learn vanilla JS first and know it well. After that, using any framework (like any programming language) is just a matter of syntax.
 var sinus = _.memoize(function(x) { return Math.sin(x); }, function(x) { return Math.floor(x/Math.PI*64)/64*Math.PI; });
great post - very well written and informative - keep it up the good work.
Very cool read. I'm just starting to learn JS. One can see how daunting it is that not only is it hard to choose a learning resource, but it's made all that more difficult by not really knowing *what* to learn.
Oh, sweet mother of Cthulhu, please no. You know what we call the glue code between a collection of hand-picked libraries? A framework. And often, a very poorly built framework at that. I'm dealing with that in my current gig -- they thought, "we will pick small libraries like Backbone and glue them together." It's a giant mess, because they are not as talented as Yahuda or Misko. (And I don't even really like angular!) I want someone to sit down and think up the patterns on how to build 90% of new front ends, and I want them to build a system to make that easier. You know, like Ember. There will always be that 10% of apps that are genuinely doing something different. You know what? In those, it totally makes sense to eschew the frameworks. However, you are probably not a unique little snowflake. Now, *can* I build a framework (Again, the glue code between all of these smaller libaries **is** a framework) each time I build a new application, or refine it from the previous one? Sure, I can. However, that means I'm wasting time on plumbing rather than solving problems. Am I thrilled at all the solutions? Not really, though Ember does a better job than the rest. That's what excites me about all the experimentation. Hopefully, eventually, someone will come along a better idea. So keep writing frameworks! We haven't figured it out yet! Or glue libraries together for your application, extract out the framework, and open source it. That's how we got Rails, after all. But don't lie to yourself -- you're just deciding to write your own framework.
Your title doesn't make much sense. There is no "core Javascript language," javascript is the language. The article you link to doesn't say that either, the title is "What is Javascript?" And the subtitle suggests a comparison between the language and the various libraries you can use to manipulate the DOM (client side), work with the file system (fs in Node), etc. 
[...](https://i.imgflip.com/eraq8.jpg)
put it in a separate span and make it opacity 0
I really not sure I understand how this is much different than hosting an api for my data and selling the service based on usage to developers that want to implement it to get my data. There are many extremely cost effective solutions for cloud based database hosting that make deployment and infrastructure very simple (using mysql, mongo, or even something like rethink). Maybe I'm missing something? Do I have this backwards? I found the marketing material kinda confusing due to a lot of hype-speak. Could use a simple breakdown of the full life cycle of service. 
Why are you using a string in the first place when you have access to JSON? { "key1" : "value", "key2", // no value, but that's fine as it's not required "key3" : function(){return 0;}, // functions are completely valid "key4" : true, // boolean is also valid "key5" : 472389622643, // long integers also valid "key6" : [0, "blue", true, function(){alert("WOW!");}] //the possibilities are endless }
The point is that your benchmarks should always calculate something, because some of those effect-free operations already do get removed by some compilers. In the future, they will probably remove even more of that garbage.
I'm trying to parse a Swig template directive so no I don't have JSON to start with.
Are you serious?
Actually, Dojo's lang.hitch() isn't the same as fn.apply(). It is the same as fn.bind() though. The reason Dojo has it is because fn.bind() is a relatively recent addition to JS. 
You can't go around escaping one set of quotes, in my opinion, and unescaping them after you've parsed the data - to get a simple generic solution.
I'm in a similar position and have been tinkering with 'vanilla JS' as people have said, though Ember is the framework I have started to lean toward in place of Angular.
The site mentions storing things like products and contacts... is that the typical data regular users would be hosting? And then where does the money come from? 
Great article. In my experience, I've found modular "Unix style" JS dev takes some time to get used to and can feel clunky at first. But once you get used to it, you'll have a hard time going back. 
A few simple illustrations would also help. Overall, it's a good start, though I wish you had finished this before posting.
backend work! that sounds dirty. 
nope. you and the dictionary have different definitions. ಠ_ಠ
&gt;in order to prevent $(window).scroll(function() { from being called more than once If you want to register some handler only once, only register it once. In the example above, your handler is an anonymous function. You couldn't register it twice even if you wanted to. Sure, you can register yet another anonymous function which does exactly the same thing. However, something like that "onetime" thing isn't going to prevent that. So, the question is: Why is that "$(window).scroll(function() {...});" thing executed more than once? What are you doing?
in my recommendation Express.js better than Koa.js and may be more professional web developers have more reasons to choose another one but after read completely agree of the usefulness Express.js
GNU/Linux.js.
In most internet apps, people make the same types of data over and over again (Products, Blog Posts, Contacts, Updates, Job Listings, etc.). Servant is trying to identify those commonly made types of data and offer them as Servant's Data Models. [Here are the types of data we are starting with. We call them JSON Archetypes](https://github.com/servant-app/json-archetypes) The money comes from people who pay Servant to host their data. People pay for monthly allowances of API Requests on Servant. This money is then split 50/50 with the Applications that use those API Requests. People pay Servant to host their data. Servant splits that money with apps that put that data to use. 
This was a really good opinion piece, and I would just like to say that in my experience (since late 90's), when you choose the road of putting a lot of small, well-defined libraries together it will seem as awesome as when you start using a new framework. The difference is that with a framework you'll have to start dealing with the warts and the things you don't agree with, and learn how to work with or around them. With a bunch of small libraries, you will eventually write a framework to glue them together. I do work with Angular a bit now, and the way Google has gone about announcing the 2.0 changes is insanity. They've announced they are deprecating the existing product for the next 1 1/2 years, and are hoping people will come back around to their new improved shiny thing. Terrible situation. I also write Clojure on some projects, which is a community that heavily favors the small-libraries approach, but on production systems I've noticed that you start to see the glue code that is really just the beginnings of a full-fledged framework to tie everything together. As with pretty much everything in technology, it's a trade-off amongst many factors, two of which are speed of development vs. complexity.
i m sorry for the 2 days delay,, Hi x-skeww thank you for the reply,,, yes u r right for the observation but my copy paste make that space,, any way i even tried from ddl.append($("&lt;option /&gt;").val(item.Value).text(item.DisplayText)); to $("&lt;option&gt;&lt;/option&gt;",{ value: item.Value, text: item.DisplayText }).appendTo(ddl) with no lack again.. and i dont know how to write my java class server side code to jsfiddle, cause i m taking the select drop down data dynamically .. i dont know what to do.. and i hate ie 11 as well even if it has so many new features,, eg user agent... etc..
Realised that sending the readme.pdf was terribly old fashioned, but in attempting to create a github repo... found there's a name clash. Can I send you the readme.pdf via reddit?
It is not the most important part of front-end dev, UX and HTML/CSS are. In reality there are always eager programmers around that want to do JS and do not understand design. So consider not to learn it, as there are "10 very good reasons to stop using JavaScript". If you do learn it, then learn vanilla.
Sounds awesome! I'd love to take a look when you get the GitHub repo up.
Done. It is at: https://github.com/tussock/jsObjDB The Readme.md file has an intro. The docs folder is jsdoc generated detailed documentation. The jsobjdb.js (or jsobjdb.min.js) relies on lodash or underscore. The other source files are for the unit tests.
Repo's up at https://github.com/tussock/jsObjDB. Readme.md gives introduction. Docs folder has detailed documentation. I'd appreciate any feedback on it. Thx. 
It depends greatly on what you mean by front-end dev. Do you mean "web design" or "software development" in the browser? You probably mean web design in which case you should continue to learn and practice the core programming concepts, using something like Python where you can focus on the core ideas and not be distracted by HTML or CSS etc. Later on you can learn JavaScript in the context of the browser, and how to manipulate HTML/CSS. 
A monolithic framework (not just JS, but in general) can give you a full blown application quickly, yes... *if* everything works the way you expect it to. Just the other day I was trying out what was a relatively small framework (bordering a library). Everything went great until I hit one road block. Not a bug, but a problem. Without amazing documentation, I'm now pretty much faced with a gross, hacky fix, spending a huge amount of time reading the framework's source to find the 'proper' way to fix it, or... probably just write it all myself without any framework in less time. Just my opinion.
Do you mean my use of sort in the cursors? Or something else? 
I want to ensure that Cursors can be treated as arrays for the purposes of for loops and _.each. IIRC just having a length attribute is not enough in lodash, it seemed that 'subclassing' array was required. Is there a better way? 
Understood. Just reading about it... I'm not sure there is a better way to inherit Array semantics without overriding the prototype. I'll keep researching. Thx for the hint. 
Have you heard of Meteor's Minimongo? It seems to have some of the same goals: https://www.meteor.com/mini-databases I'm going to take a look see how they compare! From your post it sounds like you have taken care to add some optimizations, which will be exciting
I really like their change tracking and live queries. Looks like their queries are similar (both use Mongo as a basis) - they are going for a full mongo implementation, which is interesting. Sadly they lack indexes - which are pretty darned useful giving huge performance gains - and persistence. 
Yeah, persistence in Meteor is done by syncing the database over DDP to the server-side MongoDB. The Mongo API duplication is so that the same code can run on the server and the client, with the client code using Minimongo and the server code using real Mongo. I think indexes are the biggest difference, I wonder what it would be like to have indexes with the reactivity and full Mongo API. I also love the cursor chaining (I'm a big fan of that in Rails). The API looks mostly good to me - the only things I'm curious about are the name of the library (jsObjDB) and naming the functions as "delegate" - why not "addEventListener" or "on"?
Indexes make a huge difference - especially when you have thousands or tens of thousands of objects. As to naming - until about two hours ago, I had called it ObjDB (the name used in my project). Seemed fitting at the time. But that's not unique, so I added js to the front when I added it to github. You've hit on a tricky topic with delegates! The reason I chose delegate is that the delegate function is called for all events on a DB. I initially had a delegate per event, and called them eventHandlers, but my use of the DB became much cleaner with delegates. Delegates are passed potentially several cursors: - inserted, updated, failed, deleted depending on the operation. For example, an upsert operation will potentially have inserted, updated and failed data set. An insert operation will have inserted and failed cursors. I can now create one delegate handler that deals with all operations by focusing on the types of changes rather than the event which caused the changes. For example: My delegate code examines the inserted cursor, which exists for both insert and upsert events. I must admit - I'm interested in feedback on delegates because they way they have been structured is different to the standard "onEvent" - it will be interesting to see if others find them better or worse. Thx for the feedback.
Bien joué 
&gt; I could put in all this time to learn a certain framework, but I'm going to be usurped in a year and have to continually make the mental commitment of learning the hottest new thing. After a certain point, it leaves unhappy and jaded with JS dev as a whole, and has already had me looking at other career ventures. Then take this as a learning experience and quit just learning and relying on frameworks. If you must learn a framework for your task at hand, do so understanding that it may be gone in a year. Concentrate your learning at the basics of the language. Learn why a language does what it does and how to perform the task in the language. Raw JavaScript can be powerful in itself. Start there.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Greenspun's tenth rule**](https://en.wikipedia.org/wiki/Greenspun%27s%20tenth%20rule): [](#sfw) --- &gt; &gt;__Greenspun's tenth rule of programming__ is an [aphorism](https://en.wikipedia.org/wiki/Aphorism) in [computer programming](https://en.wikipedia.org/wiki/Computer_programming) and especially [programming language](https://en.wikipedia.org/wiki/Computer_programming_language) circles that states: &gt;Any sufficiently complicated [C](https://en.wikipedia.org/wiki/C_(programming_language\)) or [Fortran](https://en.wikipedia.org/wiki/Fortran) program contains an [ad hoc](https://en.wikipedia.org/wiki/Ad_hoc), informally-specified, [bug-ridden](https://en.wikipedia.org/wiki/Computer_bug), slow implementation of half of [Common Lisp](https://en.wikipedia.org/wiki/Common_Lisp). &gt;This expresses the opinion that the perceived flexibility and [extensibility](https://en.wikipedia.org/wiki/Extensibility) designed into the [Lisp programming language](https://en.wikipedia.org/wiki/Lisp_programming_language) includes all functionality that is theoretically necessary to write a complex computer program, and that the core implementations of other programming languages often do not supply critical functionality necessary to develop complex programs. &gt; --- ^Interesting: [^Ironclad ^\(Common ^Lisp)](https://en.wikipedia.org/wiki/Ironclad_\(Common_Lisp\)) ^| [^On ^Lisp](https://en.wikipedia.org/wiki/On_Lisp) ^| [^Practical ^Common ^Lisp](https://en.wikipedia.org/wiki/Practical_Common_Lisp) ^| [^CLSQL](https://en.wikipedia.org/wiki/CLSQL) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cmhsyhv) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cmhsyhv)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
&gt; is actually talking about reaching from the global scope into some function scope and "pulling things out" This language is intentional. If a needed reference cannot be accessed the reference must be declared higher but continue to be used in its original scope. That is plucking it out and placing it higher. &gt; But then in [3] you go the other way and say that a closure is used to access variables in a lower scope from a higher scope, which it also is not but it's actually different of what you just said. Immediately under this language there is a code example. I updated the code example to exemplify this. &gt; (By the way, the reference to "a side effect" is also mainly pointless here and I don't think it adds anything interesting.) It is pretty necessary to understand that closures can be written to from a lower scope, which can impact data in different unrelated locations. &gt; Finally what your example is doing is only "progressing the scope chain" as you call it. No closure is being created and, of course, nothing is accessing variables in a lower scope. The global variables are used in closure as well as variable "a".
Interesting article. Every approach has its own advantages and disadvantages. Microlibraries were already used quite a lot (think about jQuery and jQuery plugins)... the major problem here was that you often ended up in a dependency hell (managing them). This might be easier now with tools like Bower. Another major problem I encountered was the inconsistency in code. Some people used library A for problem X and other people used library B for the same problem, or even no library at all. I like monolithic frameworks in the way that they "guide" the user to follow their best practices. They're not always THE best practices, but they work fine (to me).
Well, I'll update the future tests to put the results in a sum or something then
It will work with fractional degrees in the next version for which the resolution of the lookup will be configurable. Anyway... it works. Yes it's an easy method, but it works so I don't see your point. And the setup time is just a joke. Compared to page load times, web request times, basically all the initialization that happen in most JS code, calculating 360 sines/cosines is just nothing. It just works, and it's easy. Edit: Added the resolution, so it now works with fractional degrees or whatever the user wishes. Also, [setup time](http://jsperf.com/smath-initialization-time) - 0.03ms for 360 values, 0.3ms for 3600 values. And if you still need more precision than that, well then just use the native function. As stated in the readme, this library is not meant for precision, it's meant for fast approximation.
The example, and the whole explanation, is still only about "accessing variables in a higher scope". Nothing about closures there.
Anyone any idea if this could be used for animated games? Fast enough? Assuming here that the player can concentrate enough to follow moving parts in the 3d illusion.
Who chose those libraries and made a curated distribuition out of them? Isn't that a framework, in the end?
&gt; Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems. — Jamie Zawinski 
I recommend use of try/catch to wrap this, as it can fail on broken JSON.
I'd love to do that, the problem is that these text files already exist, they're the base files for all Paradox games for which I'm trying to build a web editor, qnd they all use this format
you'll have to do a search and replace on the = to :
Login required.
Very cool. Sadly my 8GB Core i5 laptop can't handle it (crappy gfx card means 100° CPU).
This implementation seems quite slow, compared to the rate at which it'd need to render frames to make for a playable game, but maybe it could be optimized further. Additionally, a render that's aware of moving objects might be able to cache specific parts/steps of the Magic Eye conversion process, so hey, why not.
The `Img-` and `CanvasDepthMapper`s [operate per-pixel](https://github.com/peeinears/MagicEye.js/blob/master/depthmappers/CanvasDepthMapper.js) in a `for(y...){for(x...){...}}` fashion so it's sadly far too slow for games.
If the cost of calling Math.sin or Math.cos 360 times is "a joke" then why would I want to stick extra code in between my own use of them? Do I really need to get a "new version" of a library to do something the built in Math package already does?! The performance improvement claims are what's outrageous. If it's not a bottleneck, don't optimize it! 
I'd say learn some frameworks. They'll teach you best practices and mostly everybody is using them so it will help you employability. Don't get too caught up in deciding what the right thing to learn is. The sad fact of the matter is, whatever you learn now, you'll either forget out it will become outdated in 5 years
Kernel writen in C.js with the help of Torvald.js 
I am a Lisp lover so I may be biased, but if the problem domain is sufficiently small enough then a framework for that problem is really just a DSL(Damn Small Language! Nah, Domain Specific Language) which can actually be very nice to maintain and provide productivity benefits. This is especially true since it is unlikely in my experience that any framework will just "drop in and work", you usually still end up writing quite a bit of glue. Also in my experience, frameworks often end up pissing me off in long-term projects by constantly getting in my way. Personally, I'd say for a longer term project(multiple years) you should stay away from monolithic frameworks, but if you are just making a small website that you don't plan to mess with too much(say 1 yearish development with very few changes after that year) a framework sounds like a good idea. 
That does not look enough. To make it a valid JSON string you have also to take care of missing commas and double-quote all the keys.
Can you make an example of a non trivial problem that does not involve algorithms or equations?
It can be a bottleneck. I make html5 games, and in graphics, especially if you get to 3D stuff, you use a ton of these functions all the time to calculate coordinates stuff. cosine and sine are functions that are largely used in many sort of calculations, so when real time performance is critical, winning 400% can really help. On the other hand, calculating 360 cosines/sines *once* is a joke, it has no actual effect on your program. But calculating a large amount of sines/cosines at each frame, which is pretty common in real-time applications, is something that can and should be optimized as much as possible, unless you can find a situation where losing 0.3ms at startup is critical... And, well, you can see the jsperf screenshots. The performance is +400%. It's not a claim, it's a fact. As long as it works and it is usable, I don't see any problem.
Oh right, didn't notice there was two elements.
IMO, if someone thinks they can explain closures to a 6 year old, then they don't really know the answer themselves. That stack overflow question has some good answers, but not necessarily the top ones. There are a few good ones further down.
I googled and think this guy does an excellent and straightforward explanation in less than 5 minutes https://www.youtube.com/watch?v=yiEeiMN2Khs A video sometimes says more than a thousand words *and* pictures :-)
"Completely backwards incompatible" is not true. By writing sensationalist articles like this, you are not helping the community, you're just pushing forward your own agenda. Listen to the [Adventures in Angular podcast from November](http://devchat.tv/adventures-in-angular/016-aia-ng-1-3-and-2-0-with-brad-green-igor-minar-and-mi-ko-hevery) w/ Igor / Misko / Brad where they talk about the differences between 1.3 -&gt; 2.0. Yes there are some breaking changes, but they haven't even finalized 2.0, so how can you people spew so much hatred for it?
You mean something like [this](http://3dimka.deviantart.com/art/3D-Stereogram-Tetris-36795242)? Also, the DOS game "Magic Carpet" had a RDS stereogram mode (I can't find any videos of it), but it wasn't very good because the "background" plane was too close... probably a limitation of the technique.
&gt; However, that means I'm wasting time on plumbing rather than solving problems. Based on the article, I inferred it as having to replace the foundation of a house. I would much rather waste time fixing some plumbing than replacing the foundation.
&gt; how can you people spew so much hatred for it? It's part of my evil secret agenda to destabilize Angular and promote React in its place. It's all a big conspiracy that goes right to the top. Don't tell anyone though.
Fair enough that caching or pre-computing results of frequently used functions can be a big win. Though why stop at sine and cosine? If you use this a lot in a game there are very likely surrounding game-specific calculations that could be included. (See "memoization" for a neat way to do this in general.) My biggest problem here is presenting this as a package or a library rather than as an optimization technique. Reading the headline I expected an integer approximation, or fast table-based interpolation. Or at least docs explaining the tradeoffs. I had to read the code to understand that there's not much there. A junior programmer might see a claim like "4x faster than the built in Math library" and toss this in without really knowing what it does, and then usually I end up going through it later to (for example) find out why suddenly there are discontinuous jumps in what used to be a smooth curve.
[kinda](http://bellard.org/jslinux/)
So, first let me precurse this comment by saying I'm by no means a guru programmer, or a master of JavaScript (Yet). I try to learn a bit more as often as I can, and am always looking for better ways to gain understanding. So take my critique with a grain of salt. I mean no insult or harm in my statements here. That being said I think the -idea- here is a good one, though I fear the execution falls a bit short. Considering that we're dealing with a 6 year old for ease of understanding, it's important to bring the knowledge you have into the context that children will understand. My suggestion would be get into the child paradigm, and stick there through out the explanation. I love the work you've done on this, but I would suggest that you go fully into the child mentality, stick with just words, and concepts they understand, and then evolve them slowly to understand it in more normal dev terms. Not sure exactly how to do that, and I would love to see where your project finally ends up. 
Try to understand questions before answering them. OP wants the handler to fire once, not the registerer.
Inexperienced dev here - but that's exactly what i'd do. 
Keep it simple, right? :)
&gt; Additionally, a render that's aware of moving objects might be able to cache specific parts/steps of the Magic Eye conversion process, so hey, why not. Excellent point.. could have overlapping canvases for different depths. /me stashes idea away for later perusal
This strikes me as a voice of reason amongst a chorus of anxiety. I frankly don't understand how the community can bemoan breaking changes to a stable and extremely well thought out framework that are 1+ years away, and then in the next breath start recommending escape to a smattering of libraries and alternative frameworks that are either not as mature or are in no way less immune to change in the future than Angular. I am curious about the 1600 google apps built on angular figure though. Where is that from, if you don't mind me asking?
Without solving a (simple) equation you can not say when you reach the bottom of the page to trigger the loading of new content. Without a (simple) algorithm you cannot implement the pagination of the content.
Anyway, I really don't understand what are you doing in a programming related subreddit if you are against algorithms and equations. Programming is just about solving problems (or creating them) using algorithms and equations, even if you don't realize it.
you got it
I should preface this with, i'm assuming you're making a node app. This sounds like something I would do, but I would clean it up a bit, since you said you were going to have a hundred of them, and place those guids in a json file then in your app.js file you could just do something like. var classGuids = require('./guids.json'); exports.classGuids = classGuids; hope this helps.
 function require(name, deps, func) { //Set optional defaults name = name === undefined ? null : name; deps = deps === undefined ? [] : deps; func = func === undefined ? function(){} : func } Granted it doesn't have any destructuring, but that seems way more concise to me. Each line works as an independent statement to describe the actual action that's being taken, rather than being a three part composite operation over 14 lines of code.
I tried, but I didn't succeed. OP made it sound like that line is hit multiple times. "in order to prevent $(window).scroll(function() { from being called more than once"
I'm still rocking **IE8 compatibility.** var subscribers = [ // Array of subscribing functions. function(){ console.log(1) }, function(){ console.log(2) }, function(){ console.log(3) } ]; // Calling each subscriber function. for (var i=0; i&lt;subscribers.length; i+=1) subscribers[i]();
Are you seriously not adding anything of value to the conversation?
You make a very good point. @kaigenji Can you please specify?
One of the most important criteria when picking a framework is making sure it has adequate documentation. It literally is in my top 3 needs for a framework...without good documentation a tool like that is near useless.
&gt; Let’s figure out if we can make Function.prototype.call work for us… Or don't and KISS.
Nice idea, but it seems to me like you're introducing a lot of boilerplate when an options object would still be more straightforward.
Only thing I'd add is to name them in all caps... that's the typical convention when dealing with constants... obviously they aren't "constants" in the truest sense of the term in JavaScript, but at least if you stick to the naming convention it's a clue to other devs that "hey, don't alter these!". The alternative of course is to embed the magic values in a single function, so instead of... var MY_FIRST_CONSTANT = 123; ...you instead write... function MY_FIRST_CONSTANT() { return 123; } Using it doesn't look all that different obviously: alert(MY_FIRST_CONSTANT); ...versus... alert(MY_FIRST_CONSTANT()); ...the benefit of the later is you won't be able to change the value at runtime (you know, without overriding the function anyway)... but the cost is function call overhead (which won't matter unless you're calling this frequently in type loops and whatnot). If you go the function route I'd highly recommend creating a namespace for them to avoid global pollution... var Constants = { MY_FIRST_CONSTANT : function() { return 123; } }; ...and really, there's no good reason to not do that even if you don't use functions... var Constants = { MY_FIRST_CONSTANT : 123 }; ...and of course, you could always embed Constants within a larger App singleton, or whatever your structure of choice is. 
Not a node app but I see where you're thinking here, good input thank you.
Using existing Node.js style callback APIs with Koa is as easy as: var readFileAsync = Bluebird.promisify(fs.readFileAsync); var contents = yield readFileAsync('/var/log/apache2/error.log'); And you can easily go in the other direction to make sure your promise-based APIs work with standard Node.js callback format: exports.yourFunction = function(inputs, callback) { return yourPromiseFunction(inputs).nodeify(callback); }; I think built-in interoperability with Node.js style callbacks is one of the best things about promises.
I roll with ES6: const x = 1; const opts = Object.freeze({x: 1, y: 2});
Perhaps you could find [devdocs](http://devdocs.io/javascript/) and [html5 index](http://html5index.org/) useful. Failing those, I always end up on [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript).
I don't know how much you know about hex so I'll start from the basics. **Hexidecimal Numerals** = 0, 1, 2, 3, 4, 5, 6 , 7, 8, 9, A, B, C, D, E, F **Decimal Numerals** = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 Decimal | Hexidecimal ------------------------------- 00 | 00 10 | 0A 15 | 0F 16 | 10 32 | 20 64 | 40 Just like in the decimal system, when you increment through the last possible numeral on the rightmost side, increment the one directly to the left and start at the first numeral again. Add one to the hexadecimal number 0F and it will become 10. 00 = 0, FF = 255 Hex color is laid out like this: \#(red)(green)(blue) so #FF00FF is equal to the color purple. The way to tell if a color is going to be light or dark is to estimate where each color value lies between 00 and FF then estimate them together to see what the overall values tend towards. Very high values in any of the color channels will make the color tend to look lighter. \#FB00CC is going to be light since 2/3 color channels are closer to FF \#11F10A is going to be darker since 2/3 color channels are closer to 00 \#801FF1 is harder to estimate since each channel tends it's own way but the F1 + 80 will still end up making it a lighter color. 
Share this with /r/CrossView, they will love this website.
Why this over something like PouchDB?
I'll just leave [this](https://github.com/es-shims/es5-shim) here…
Sometimes JavaScript developers can be like environmentalists. Everyone wants to plant their own tree. 
I developed http://thestorefront.github.io/DataCollection.js/ If you'd like help, feel free to give me a shout.
Very interesting project. The Luminosity variable which is part of the HSL values, can be used to determine if a colour is light or dark by converting HEX to RGB, and then converting RGB to HSL.
Yup, you probably don't want to use this stuff in a web page (at least without a very strict CSP amongst other things), cordova/phonegap style phone apps would be another place this could come in handy.
Which "the variable values"? The developer console (F12) should allow you to input any JavaScript expression (including a global variable) and see what it evaluates to. Is that what you want?
if they are in the global namespace, yes. If you open up the chrome console you would be able to just type console.log(varname). If they arent in the global namespace you could create a global app object and then assign variables to that. window.App = {} and then assign your var to that object window.App.varname = varname
&gt;Different libraries have varying syntax, how do you expect to just "hot swap" them out? Not saying you don't have a point, but I think you're making it sound simpler than it would be in practice You hide the library behind a facade. All the rest of your code then interacts with the facade. When you change a lib you only have to change the code within the facade, keeping the facades pubic interface the same. Not a quick job, but not a total nightmare either. it does mean writing the facade initially, which like many have said isn't far off implementing a framework.
JavaScript is too extensive for a cheat sheet. Your selection is already too big for one page, unless you omit important parts. If you browse through this website, you'll get why: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference
So this makes sense when you have varying arg types but what about if you have multiple args that have the same type. How do you know which function reference is supposed to be the reference you want to use? or are you simply trying to fix the situation when you have varying arg types and want to set "defaults"
In addition to simply typing global variable names in the console, the chrome developer tools let you go through each JavaScript file and set breakpoints, where the code will stop so you can examine the values of all the variables available there. This lets you see the values of closed-over variables as well as globals.
How many IndexedDB abstractions are we going to see? This is the fourth one I've seen on this subreddit in the past few weeks.
smells like homework..
In the first paragraph: &gt; ...it’s generally a better idea to pass an options object instead for mutliple arguments
In the first paragraph: &gt; ...it’s generally a better idea to pass an options object instead for mutliple arguments
I wouldn't say Safari is an older browser. But IndexDB isn't ready for prime time yet there. 
You would need a way to determine which args is which, this is mostly to just let optional args in with the added bonus of being able to set default values
Not JS-related. But they explained in the comments/on their G+ blog: &gt;We never thought a video would be watched in numbers greater than &gt;a 32-bit integer (=2,147,483,647 views), but that was before we met &gt;PSY. "Gangnam Style" has been viewed so many times we have to &gt;upgrade! &gt; &gt;Hover over the counter in PSY's video to see a little math magic and &gt;stay tuned for bigger and bigger numbers on YouTube. 
Is there are reason you want this as a jquery plugin?If you are learning JS you might want to try this in vanilla js and actually "learn js" Maybe you are using bootstrap + jquery for modal functionality but it doesn't mean you have to depend on it for your colorpicker. I think you would be narrowing its use if you limit it to a jquery plugin. 
I haven't seen anything like this exactly the way you have it there are plenty of cheat sheets out there. Feel free to use this as a base to build one though. I literally just typed this and did not even run it so if there's errors just assume I put them there on purpose as a learning exercise. // Variables var someBool = true, someString = "Hello World", someNumber = 3.141; // Expressions var sum = 1 + 1, difference = 2 - 1, product = 2 * 2, quotient = 10 /5; var compareValEqual = 10 == "10", compareValAndTypeEqual = 10 === "10" compareValNotEqual 10 != "10", compareValAndTypeNoeEqual = 10 !== "10"; var compareLess = 10 &lt; 100, compareMore = 10 &gt; 100, compareLTE = 10 &lt;= 100, compareGTE = 10 &gt;= 100; var and = true &amp;&amp; true, or = true || false, not = !false; var bitAnd = 10 &amp; 01, bitOr = 10 | 01, bitXor = 10 ^ 01, bitNot = ~10, bitShiftLeft = 10 &lt;&lt; 1, bitShiftRight = 10 &gt;&gt; 1, bitShiftRightFill = 10 &gt;&gt;&gt; 1; if(true) console.log("Condition is true") if( i === 1 ){ console.log("i is 1"); } else if( i &gt; 1 &amp;&amp; i &lt; 4) { console.log("i is 2 or 3"); } else { console.log("i is not 1, 2 or 3") } switch(i){ case 1: console.log("i is 1"); break; case 2: case 3: console.log("i is 2 or 3"); break; default: console.log("i is not 1,2 or 3"); } for (var i = 10; i &gt;= 0; i--) { if(i === 5) continue; console.log(i); } var continueLoop = true, i = 0; while( continueLoop ){ i++; if( i === 10){ continueLoop = false; } } // Everything in JavaScript is an object // To declare objects us { } var myObject = {}; // Add properties directly in {} as key value pairs or using dot or bracket notation after it is initialized var myObject = { name : "John Smith" } myObject.age = 21; myObject['location'] = "Anywhere"; // Functions can be declared by using the function keyword // Named function function namedFunction(parameter){ //.... return someVal; } // Named function using var (reinforces function is an object) var anotherFunction = function(parameter){ return someVal; } // Self Invoking Anonymous function (function(parameter){ })(parm) // Method myObject.sayName = function(){ console.log(this.name); } // Defining a method in object literal var myObject = { name : "John Smith", sayName : function(){ console.log(this); } } // Functions can be passed as parameters setTimeout(function(){ console.log("Hello World") },1000); // JavaScript usually includes built in objects for // Math // Date // String // Array // Their methods may differ depending on implementation // Browsers usually include built in objects for // document // JSON // XMLHttpRequest // These will depend heavily on the browser and the version 
At around 15 KB, that's some pretty heavy duty stuff to avoid `for` statements. function each(a,f){for(var i=0;i&lt;a.length;i+=1)f.call(a,a[i],i);return a} 73 bytes.
&gt; At the end of the day though, this isn’t straightforward code. And in fact, it’s quite slow. So I can’t recommend ever writing this code, though it made for an interesting thought experiment. You and the author are in agreement. Nothing wrong with dicking around once in a while. 
FTFY http://pastebin.com/X89ibKmj The Video_ID seems to be the id of the &lt;video&gt; element, which on that page turned out to be "wet-boew-mediaplayer0-media". Also there seemed to be some commented out lines probably on mistake. And captionsToSRT was returning a string that was not being used, so I used console.log. 
Old has nothing to do with age... It has to do with the modernness of features 
Old has nothing to do with age. Got it. 
I disagree. A front-end dev who doesn't know JS is not a developer, they're a designer. If you take the JS out of an app, you lose all your UI, leaving you with nothing more than a static mock. The line between front-end devs and front-end designers is drawn with JavaScript.
If you're using the word "old" for something that has nothing to do with age then you're using the wrong word.
I always use a JSON object for arguments. So, theres only one argument in the function declaration, but the caller can include any number of arguments. funtion x(input) { for(key in input) {alert(input.key);} } x( {"wow":"wow","im":"im","cool":"cool"} );
https://developer.mozilla.org/en-US/docs/Web/JavaScript
This comment pretty much sums up why I come to reddit.
First see if you can get your hands on the parser used by the people who saved these files, and port it if necessary. If you can't do that, I suggest writing your own parser. A regex is a poor way of parsing a format you aren't very certain of the structure of, because it won't throw errors if it encounters something unexpected, but instead do either nothing or the wrong thing. Also it's hard to read.
Not really, it goes over some concepts such as currying and partial application which are still used today.
"Implemented" would be more correct since the concept existed way before Crockford showed it. But anyway it's also called an IFFE or just "the module pattern" or it has other sibling implementations like the "revealing module pattern" Either way you are still talking about something that isn't based in the language itself. Now if you had said es6 classes arn't mentioned then I'd probably say you are correct it is outdated :)
Crockford covers closures and modules. Immediately executing functions are closures too. So he covers it all! 
It's a great book. I highly recommend it. Core understanding of the fundaments is very important and the basis for everything.
It's in there. Crockford calls it the Module pattern. They're better known as IIFEs (Immediately Invoked Function Expressions). Also, and this is just my personal taste, but I find var widget = function() { function doStuff() { ... } return { do: dostuff }; }(); To be a cleaner way to do IIFEs, especially if you actually want to be able to use them and aren't just invoking them once or tossing the closure around as an argument.
This is a better one - http://www.kenneth-truyers.net/2013/04/27/javascript-namespaces-and-modules/
I see what you're saying. I misunderstood what your code was doing at first. This is possibly because I'm more used to 'optional arguments' only meaning that you don't need to provide that particular parameter when calling the function, not that it's position may also change if you are not specifying a different optional argument before it. For example, with my implementation I would achieve the same effect as your call by using require(undefined, undefined, function() { console.log('show me'); }) It's a little more verbose, but * A lot easier to write tests for * No ambiguity when two arguments have the same type * Very clear when reading that you are purposefully omitting an argument (written once, read many times) That being said, now that I see how it works, it's a very clever pattern. I wouldn't use it in the majority of functions, but I think for some select, top level api endpoints (think jQuery) it's nice. Do you think there's a way to to generalize this into a function you could call directly on the arguments object? How well does this extend to the case where there are non-optional arguments that are also part of the function? 
I don't think you'll find what you want for free. But I really like Codeschool.com. It's not free at $30/mo - but it does have interactive coding in the browser. There are free lessons so you get a feel for the format.
I'm still figuring this out myself, but my thoughts: 1. put the scripts at the end of the body so they don't block the page while loading and executing. an exception is modernizr. 2. Use a top level module (APP) and look at the namespacing pattern: http://www.kenneth-truyers.net/2013/04/27/javascript-namespaces-and-modules/ look at the module pattern (tons on google). I have APP.AppController, APP.AppModel, APP.AppView and a few more modules under each. It keeps it nicely organized and since APP is global, you can access anything from anywhere. Not good practice, however. 3. Put an immediately invoking function in there to run initialize or hook it to the onload event so it runs as soon as the document is loaded and ready. 
Hey, I appreciate the help. Unfortunately I am a little new to this and not quite sure where to place the code you provided. I am actually in the middle of taking a course on javascript but haven't learned much yet. If you can elaborate of your answer a little more that would be great. 
I prefer this method especially for creating "instances" of a module not single use "singleton-esque" global modules. It depends on the use case of the module though var Instance = (function( window, document ){ var module = function( paramA, paramB ){ this.stuff = paramA; this.otherStuff = paramB; return this; } module.prototype = { constructor: module, doStuff: function(){ return this; } } return module; }( window, document )); and instantiated like so... var moduleInstance = new Instance( "param1asdasd", "param2blahblah" );
Crockford is probably rewriting the book. He has a new talk that he is doing called 'Javascript: The Better Parts' that is worth checking out as well. https://www.youtube.com/watch?v=bo36MrBfTk4 http://xahlee.info/js/js_Douglas_Crockford_the_better_parts.html
I have shimmed Map and used it in an app like 1.5 yrs ago. So yes but not a weakmap if thats what you are talking about. You are stuck in the past my friend. You should probably learn about what the language can do not just what is available in the browser right now
I did a quick google search and there are es6 map implementations on github from 2012. So yea... lol Granted ill give that its not a full es6 shim...
Easiest way to do this is just disable the Register button until the user checks the box. [Something like this](http://plnkr.co/edit/pjzN9eSR8v9JOVEaMdJu?p=preview).
I don't have the book in front of me, but I remember most of the core concepts being sound. A few of the language nits and pitfalls he mentions in the book are in the process of being fixed by strict mode and ES6 -- for example, the 'with' statement is banned in strict-mode code, along with 'arguments.caller' and 'arguments.callee.' And in ES6, 'let' statements can give you real block-scoped variables, avoiding the pitfalls of 'var' that Crockford always complains about. Some of Crockford's stylistic preferences are, well, debatable. But again, the majority of the book deals with fundamental features of the language, and those still apply.
A "javascript object notation" object :P 
If I remember correctly he doesn't like "let" in his latest talk the "The better parts". EDIT: As some people have mentioned, I was a little incorrect in my statement. You are correct I was just remembering back from 2 months ago. I went to watch that part again. He does mention it as a good part but really just says you can be write "good" programs without block scoping features. My mistake...
This is extremely interesting. I wonder what pitfalls there are to it.
Very different styles. I try to avoid OO as much as possible, so I almost never use new, this, prototype, etc. But whatever works for you.
I also say ATM Machine and PIN Number. Come at me, bro 
Ah well... curmudgeons gonna curmudgeon.
I hear ya. Must be my java background shining thru :)
Why didn't they call it dojo.bind (like _.bind) instead of hitch. Reminds me of that terrible kevin james movie.
Similar to what others have said. A normal convention in Java is using uppercase values. I'd say a simple namespace or module pattern that holds the constants should suffice though :)
In fact it does, on page 40. Nothing in depth, but it's in there. 
Lol I dont write that way, normally. Just slapled it in the comment. And, really? Cool. The more you know. (but then whats the point of JSON.parse()?)
Awesome, Thanks for the suggestion. How would I go about placing that into my PHP file that I listed above? I am quite new with this...
Everything in the book is still pretty solid. But it's fully based on the ECMAScript 3 version of JavaScript, and there are certainly "Good Parts" of the ES5 and ES6 specs that aren't included. 
Namespacing is great, but most of the value for things other than libraries like Backbone/jQuery and their plugins has been removed by the various JavaScript module formats. Namespacing is a hack around the fact that JavaScript only has global scope. But AMD and CommonJS modules are (at the very least) much more sophisticated hacks, and ES6 modules are a first class solution to the problem that doesn't require hacks. The weird thing is that the author clearly knows about these solutions since he covers them in the next post in the series.
I asked the same question before reading it a month ago only to find it still very relevant. It's a simple introduction to some of the more complex or confusing parts of JavaScript and I'd recommend anyone read it.
I have this suspicion that JavaScript will take over the world. Eventually, all applications will be built as web apps. Application development and web development will become one and the same, and the operating system will shrink to a thin layer that exists primarily to support the Browser. Elementary school students will start learning JavaScript alongside basic mathematics.
What your php file is doing is generating a HTML file and letting the browser on your user side handle what's going on. Anything inside a &lt;script&gt;&lt;/script&gt; is javascript that the browser reads and runs. The code above uses jquery, a library to overwrite basic html behavior, you would essentially put that in a script tag than put your function submitform inside like so &lt;script&gt; $("form").submit(function(e) { e.preventDefault(); e.returnValue = false; var submitForm = function (event) { var checkChecked = document.getElementById("checkID").checked, errMsg = document.getElementById("errMsg"); if (!checkChecked) { errMsg.className = ''; return true; } }; submitForm(e); }); &lt;/script&gt; The answer below is also a lot simpler, appears to work, and doesn't depend on your custom form etc. Although not recommended, you could just wrap it in a script tag and put it inside your html file.
I think that's a bit unfair. He may have a good reason. It's not like every new feature added to a language is guaranteed to be a good idea. Sometimes new features are just as short-sighted as the old features they were trying to fix, at the cost of making the language more complex as well. 
Chrome books are already there. Providing really nothing more than the chrome browser and a handful of shortcuts to the google apps. It is pretty cool, and for most cases perfect for an average user.
nah its still a good read. You can learn stuff from slightly-very outdated books. 
It's not a reality yet, but I would really like to see something written by academia like Rob Miles's CSharp Yellow Book. 
Now you are mixing the standard (JSON - the text format ) with the javascript function JSON...which by the way...is the native implementation of a JSON parser i.e parses text to convert into a JS object. You could use eval to do the same thing but JSON.parse has some security handles built in.