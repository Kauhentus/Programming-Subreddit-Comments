A friend of mine told me about it when I was looking for learning exercices for Crystal. It is very great, and in addition, after submitting a solution, you can see other's solutions. It showed me some best practises, and simpler ways to do things (example : using regex when Crystal has a bunch of functions to check strings).
Then try [mapping macro](https://crystal-lang.org/api/0.23.1/JSON.html#mapping%28properties%2Cstrict%3Dfalse%29-macro)
The compiler itself is not extensible. The more related think I can think of is what is done in playground https://github.com/crystal-lang/crystal/blob/5fd965e999bec40ff3ae9af1493d113cc9677419/src/compiler/crystal/tools/playground/server.cr#L16 There are AST transformers and visitors to do manipulation. Then you would need to print the AST and compile it. That works fine in playground because the source is a single file. But for profiling, if you aim to instrument more than one file it might be not that trivial. Another approach I did in the past was to manipulate the AST before using the compiler internal classes https://github.com/bcardiff/afix/blob/master/src/instrument.cr . Here some lost regarding compiler flags occur because I didn't call the full compiler chain. But was enough to lookup for some particular ast pattern (integers assignements) and instrument them with manual built ast. A third option, is to fork the compiler and add the transformation in the compiling process. This would look similar to the previous one regarding AST manipulation. Then you would need to compile this crystal-with-profiler compiler and use it on the target program. Note that some instrumentations require the result of the parser only, some would require expansion of macros, some would require the type inference to be done, etc. Depending on the needs, you should hook to different part of the compilation process. https://github.com/crystal-lang/crystal/blob/master/src/compiler/crystal/semantic.cr might offer some guidance to the internals of the compiler. For https://crystal-lang.org/2016/02/18/buenos-aires-crystal-meetup.html I made a small sample: https://github.com/bcardiff/crystal-tool-demo (probably outdated Apr 2016). Some technicalities why this is not done in crystal is due to the lack of dynamic library loading, that would be needed to make some sort of plugins.
Nice tip. 
Yes, it's stored locally like SQLite. I'm unfamiliar with NetCDF, but I've considered making Crystal bindings for HDF5, another file based general data store. Any sort of time series data should fit nicely for TrailDB. We use TrailDB at AdRoll mainly to densely store events for posthoc analysis.
Yes, it's stored locally like SQLite. I'm unfamiliar with NetCDF, but I've considered making Crystal bindings for HDF5, another file based general data store. Any sort of time series data should fit nicely for TrailDB. We use TrailDB at AdRoll mainly to densely store events for posthoc analysis.
In my experience (tried to run binary on fresh OS install), no, because they would not have needed libraries installed. I would like this to be possible though...
Besides system libc, I'm not sure what dyn. libraries are required. Depending on what shards you add this list could be bigger. I'm not sure if the compiler has flags to generate totally independent binaries (static linking). You can check the libraries dependencies with a command. On Linux you can check the dynamic link libraries with ldd command. On Mac I think is with "otool -L ".
Is possible but you need to check binary dependencies first. For example on Linux: ``` ldd mybinary linux-vdso.so.1 (0x00007fffde98a000) libpcre.so.1 =&gt; /usr/lib/libpcre.so.1 (0x00007f1defbb4000) libgc.so.1 =&gt; /usr/lib/libgc.so.1 (0x00007f1def94a000) libpthread.so.0 =&gt; /usr/lib/libpthread.so.0 (0x00007f1def72c000) libevent-2.1.so.6 =&gt; /usr/lib/libevent-2.1.so.6 (0x00007f1def4d6000) librt.so.1 =&gt; /usr/lib/librt.so.1 (0x00007f1def2ce000) libdl.so.2 =&gt; /usr/lib/libdl.so.2 (0x00007f1def0ca000) libgcc_s.so.1 =&gt; /usr/lib/libgcc_s.so.1 (0x00007f1deeeb3000) libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007f1deeafb000) /lib64/ld-linux-x86-64.so.2 =&gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007f1df00d6000) libatomic_ops.so.1 =&gt; /usr/lib/libatomic_ops.so.1 (0x00007f1dee8f9000) libcrypto.so.1.1 =&gt; /usr/lib/libcrypto.so.1.1 (0x00007f1dee47c000) ``` So, I can copy these libs to client machine without installing new dependencies or crystal compiler. A similar method is used to create mini docker containers for running crystal binaries, see: https://manas.tech/blog/2017/04/03/shipping-crystal-apps-in-a-small-docker-image.html
Thanks for checking and I second your feelings.
Most binaries come with a list of dependencies, so don't let that scare you off. That's what package managers are for. In the short term I'd suggest bundling everything you need into a Docker image.
Depends on the llvm version too
I got bored at work: https://gitlab.com/snippets/1689690
And again, those ‚Äú20xx will be Crystal year!‚Äù üôÉ Love your work though. Thank you and a happy new year! üéâ
In case you missed it, this is a response to [recent Hacker News comments about Crystal](https://news.ycombinator.com/item?id=15945262). 
Welcome to the real world :P
Negatory - I swapped mail with a core member over a week ago and they tipped me off this plan and announcement were coming.
Rust can expose a C interface and you can use bindings to that in Crystal.
Thanks, this is exactly what I was looking for! Declaring a rust function #[no_mangle] pub extern "C" fn hello() { println!("Hello world!") } and building a shared library did the trick.
Awesome! Great job to all those that made this happen. Happy Holidays.
üëèüèª
good job
Thank you team crystal!
As you probably know Crystal is a statically type checked, compiled programming language. More on the topic on their site https://crystal-lang.org/ It‚Äôs still in Beta, last stable version is 0.24.1. We've built two applications, the first one is just API, the second one is redirector, which is incredibly fast ‚Äî redirect may happen in hundred nanoseconds even with DB connection. Here's the link to the service http://to.click, feel free to comment if you are interested in more details. Also we have two bots: http://clc.to/bot for Telegram and Slack app which is currently unavailable for public, but surely will be later on.
Wow, works amazing!
Literally a blank page when I load the site https://pastebin.com/Mr2TyFEH is the page source for me, not sure if the servers overloaded or what
works for me
working for me too now
Probably deploy issue, sorry for any inconvenience %) 
May I ask what did you use as the web framework?
We would like to make sure that widely used services is fast and reliable enough, so we decided to use Crystal lang. The very first question was what to start with, there‚Äôre two popular frameworks named Kemal https://github.com/kemalcr/kemal and Amber https://github.com/amberframework/amber but both of them seemed too heavy for the quite simple task, so the first thing we did was a try to use low level functions to build routes and handle requests, it worked but seemed ugly so we decided to migrate to router.cr https://github.com/tbrand/router.cr as a quite light weight solution that fit our needs. Nevertheless Crystal is not in production stage it's stable enough, we faced several issues with DB but all was solved quite easily. For public frontend we use ReactJS. Private hub is built with Ruby on Rails as we've quite wide experience with it.
We would like to make sure that widely used services is fast and reliable enough, so we decided to use Crystal lang. The very first question was what to start with, there‚Äôre two popular frameworks named Kemal (https://github.com/kemalcr/kemal) and Amber (https://github.com/amberframework/amber) but both of them seemed too heavy for the task, so the first thing I did was a try to use low level functions to build routes and handle requests, it worked but seemed ugly so we decided to migrate to router.cr (https://github.com/tbrand/router.cr) as a quite light weight solution that fit our needs. Nevertheless Crystal is not in production stage it's stable enough, we faced several issues with DB but all was solved quite easily. For public frontend we use with ReactJS. Private hub is built with Ruby on Rails as we've quite wide experience with it.
Hey, great that you want to try Crystal. It's really an amazing language and I hope you get to know it well ;) I'll try to answer your questions as far as I know: * I don't think Crystal is explicitly intended for realtime applications, but it surely can be used for this. I'm not too familiar with how the GC behaves exactly, but maybe you might wanna take a look at the implementation in `[src/gc/boehm.cr](https://github.com/crystal-lang/crystal/blob/master/src/gc/boehm.cr)`, which is mostly just bindings to LibGC. Boehm GC is considered to be *good enough* for the current state of Crystal's development but it is clear that it will need to be replaced eventually, probably by a customized native-Crystal. There is an issue currently discussing the use of [immix GC](https://github.com/crystal-lang/crystal/issues/5271) which is used by scala-native on LLVM. You can also disable garbage collection entirely (`-Dgc_none` compile flag) but this obviously won't work with the stdlib (there was some project working on a minimalistic stdlib for embedded use, but I can't remember what it is called). It should even be possible to use a custom GC for specific requirements. So, currently, there is certainly room for improvement, but the maintainers are aware of this and there are ideas how to develop further. * Crystal's macros are very powerful and you can do almost anything with it as long as it generates valid code. The macro interpreter provides a limited set of operations to modify the AST directly. For more complex code you can embed the output of any executable (for example a Crystal program generating code). * Crystal essentially uses the same concepts as Ruby: blocks are essentially anonymous functions, they can be used for higher-order functions. You might wan't to take a look at the [Iterator class](https://crystal-lang.org/api/Iterator.html) (and Enumerable) which provide methods like `map` etc.
Also you can disable the GC for sections of code if you want by wrapping it in `GC.disable` and `GC.enable`
Fantastic. Thank you for your detailed answer.
I'm the author of Kemal :) May I ask why it seemed too heavy? 
The framework they linked has fewer lines of code than your readme. Kemal is not simple enough to bug free, and not complex enough to be a full framework. I guess that's their rationale.
Thanks RX, yeap, that's it, we don't need full fledged web server, we need tiny error prone server that can handle 2 routes and respond back ‚Äî nginx + router.cr makes this pretty good.
Can not sign up. Error :change was rejected 
FYI, I had to comment out: &gt; (spacemacs|defvar-company-backends crystal-mode) from config.el, otherwise Spacemacs would break. FYI, I'm running Emacs25 with the Spacemacs develop branch.
Just fyi, I don't think you mean "error prone" there.
source?
The image comes from an article[0] while the source data comes from [1]. [0] https://stackify.com/popular-programming-languages-2018/ [1] https://www.indeed.com
Huh, where is rust?
Wondering why scratch is there lol
I created a new develop branch to fix your feedback problem. The master branch and the develop branch of spacemacs are slightly incompatible, causing it to not work properly. Thank you.
From their methodology &gt;We took the 50 most popular languages from the Tiobe Index and searched for ‚Äú(‚ÄúLanguage name‚Äù) Developer‚Äù. Searching for "Crystal Developer" for me gets loads of results for Crystal Reports, so I think these results are very misleading. Either way, it doesn't pass the sniff test: - it's a metric related to maturity - we're not being beaten by popular languages which are post-1.0 (rust)
A reassuring post to start off 2018. Crystal is "good enough" at the moment. That is to say it's not perfect and there's room for improvement but at the same time, you can build useful stuff with it.
*suite
great
Its actually much more than this now, perhaps 45%. The port's actually going fairly quickly.
I wish i knew how to help with this. maybe one day
Same
It's not even that difficult (at least not all of it). I managed to get the time implementation ported rather quickly. Didn't expect that, especially considering I have 0 experience working with Windows APIs and only little C programming skills at all.
Thanks, that means a lot to me.
I've had this bizarre notion to slave a Ruby instance to Crystal for runtime interpreting. Then I think about using v8 and Opal and I laugh and laugh and find something else to do.
Thanks!
Take a look at this post that explains some benefits of Amber https://medium.com/@eliasjpr/amber-crystal-web-framework-1d76f5abfe2b
Hello, probably you will get a much more helpful reply if you ask those questions on their gitter https://gitter.im/amberframework/amber :)
Hi, amber developer here, amber console was removed because is was very experimental, so we decide it's not suitable for amber projects yet, see: https://github.com/amberframework/amber/issues/352
yeap, thanks, meant error free :)
can you please specify browser and OS? in general it works good, but we see csrf protection error for your requests
Worked now. Thanks. (android Chrome) 
&gt; Any natural way to make nested/nested routes? See scoped routes here: https://amberframework.org/guides/getting-started/routing/routes.md#routes
Sweet. Is it meant to be pronounced like the name "Oscar"?
I am pretty sure `crystal deps` will be removed in the next version of Crystal, fwiw https://github.com/crystal-lang/crystal/pull/5544
&gt; Make sure you have `require "markov"` in your code This was the issue. I had used the command `crystal init app markov_chain` . The line was `require "./markov_chain/*"`so I understand how that came about; I figured it was pulling all in from that directory like a relative import in pythonese?) I changed it to `require "markov"` and it worked. In any event thanks for the pointer and I'll be mindful of similar in the future! 
&gt; In the end, Lucky uses one class per action because ... it helps to stay clean and focused yea, reminds me &gt; I have to kill fast and bullets too slow! Said John Freeman. And started killing Combines with bare hands
Please keep the hype in check: this is very much an experimental project, it may never replace the bdwgc we currently use.
I am very excited for this.
I have been following some people in the data driven movement and I am curious what you think about having a GC optional? I don‚Äôt even know what that would look like. 
Starred
Crystal IS production-ready. I have several web products live, and both their uptime and performance are awesome. However, IMO, you have to dive too deep into Crystal to make things work smoothly - I speak about macros, workarounds because of unstable API, lack of shards and questionable level of code quality in some even quite popular libraries. From my half-a-year experience, Crystal is not newbie-friendly yet. The good news is that it needs good high-level shards only to solve this issue (is it an issue? ü§î), and it‚Äôs just a matter of time. My opinion after six months? I still think that Crystal is the best programming language ever. Thank you, devs.
I am starting to convert my nodejs game server over to Crystal now, after seeing the kemal websocket benchmarks. About 30% done (10k lines of code left), and it's been a blast. WSL w/ Crystal has been a joy to work with because I can also alt-tab and enjoy gaming, or code. Can't wait to see what the future holds. And the community in general has been EXTREMELY helpful. 
Learning about people using it in live projects was one of the reasons why I wrote this article. I've been playing with Crystal for quite some time already, but when it came to creating a new product I always took the "safe option" (Rails, Node etc). I guess I'm convinced now that it's ready to use in the next project
The biggest problem crystal faces right now is dearth of libraries, and dearth of documentation. The official docs are pretty good, but there is no rubydocs.io or hexdocs.pm equivalent, which I can just point at a github repo and view the autogenerated docs for a project. I've been using it mostly to replace small little CLI scripts I used to write in ruby/bash. Its absolutely wonderful, and when I manage to get statically linked binaries working, its basically perfect
But there are so many languages that don't use semicolons. 
Wow, thorough. I'll definitely pull this down and play with it. Did you mean rails-esque, by the way? :P
I did. Changed it in the readme. Now I feel embarrassed.
Why use a router in crystal when the one Comcast gave me works fine? The monthly fee is what gets me, but I mean.. github has a paid private repo so I guess that's comparable. Still, with that said, not sure I understand this.
... these are not the droids you‚Äôre looking for.
Really wish crystal could add NPM support, natively. With electron, if possible.
Don't know why this got downvoted. Your name says it all.
I don't think it will be production ready until a sizeable company adopts it. 
Nope. It lacks stable 1.0, no windows support, no parallelism, very small ecosystem, very small dev team and very few job opportunities out there, *Production ready* C#/.NET/.NET core Java JS Ruby Python *Production ready RC 1* Go *Almost production ready use at your own risk* Nim *Not production ready* Crystal
What exactly do you mean there? That's a lot of different languages/technologies. Where would Crystal fit in?
Nice! I hope crystal gets popular in Korea. For some reason ruby never made it big in Korea. Maybe because it is considered japanese but i know that koreans mainly use python,java,c#, c++ and nowdays rust is getting popular.
How do you know about ruby in Korea?! Are you living in Korea? :) I hope crystal gets popular too. 
Rule number one of crypto club: don‚Äôt roll your own!
Thanks! Just rolled this in to production for our user passwords. It works great, and password recovery is fast.
Why might this be better than 3ROT13 (not to be confused with ROT13)? Someone ELI5?
I've never used 3ROT13, so I don't know exactly, but I can say that since this rotates by 26 characters instead of the standard 13 it's also twice as secure
I love you guys. Best programmer memery I've seen in awhile
I will be sure to take this into account. Maybe by allowing you to specify your own character range.
I was scanning saramin for Ruby/Rails keywords some time ago and did not get many hits. Also the Rubymotion developer Laurent mentioned Ruby was never big there.
My understanding is that 3rot13 encrypts with key1, decrypts with key2, then encrypts with key3. Key1 and key2 must not be the same, and weak key checks are also performed. 
That would be great. I literally just ported the code from the Rust library so there are definitely things that could be improved.
Were you thinking something more along the lines of this? ``` String.build do |str| input.chars.each do |c| if 'a' &lt;= c &lt;= 'z' str &lt;&lt; (((c.ord - 'a'.ord + amount) % ROTATE) + 'a'.ord).chr elsif 'A' &lt;= c &lt;= 'Z' str &lt;&lt; (((c.ord - 'A'.ord + amount) % ROTATE) + 'A'.ord).chr else str &lt;&lt; c end end end ```
Honest question: Why is it inefficient? I know nothing about Crystal, but apparently their iterators are also lazy, just like Rust's. Is it because it doesn't pre-allocate?
3ROT13 is slightly more secure than a single ROT26 but also extremely slow. If you still insist on making it more secure, simply chain it together: ROT26.encrypt(ROT26.encrypt("plain-text")) Simply chaining twice is already 75% more secure than 3ROT13!
You should definitely take advantage of Crystal‚Äôs [method overloading](https://crystal-lang.org/docs/syntax_and_semantics/overloading.html) for your `on` method. That way, you can be more assured in the arguments you‚Äôre getting and catch errors on compilation instead of runtime.
Can you give me an idea of how to do that in this case. `*arg` will almost always be an array containing one Bool followed by a number of Procs, I don't see an obvious way to overload and specify the types here. It's been a long time since overloading was something I even considered. Thank you ahead of time.
When you write `input.chars` that invokes `String#chars` which builds an Array with the chars. Then `map` will create a new Array. Then `join` will finally create the resulting string. So, lots of allocations. To make it more efficient, you can use `each_char` instead of `chars`. That returns an iterator. To make it the most efficient, just use `each_char` with a block, and build the string as you go. The iterator is fine but it does, too, need a memory allocation (it's a class). I was actually going to send a PR for this but... meh :-P
Ah, I see. Classes are on the heap in Crystal?
Theoretically you could have the same performance as rust using `string.each_char.map.join`
&gt; Personally I don't like the name though :P 'Crystal' seems generic to me. I think 'Sapphire' or 'Emerald' would continue the Ruby gemstone tradition and be more expressive. Not being sarcastic ... I just think the name is a bit uninspiring. Despite Crystal syntax &amp; some features being inspired from ruby and a lot of the core dev's being ex ruby devs, I honestly believe they don't want Crystal to follow in the shadows of Ruby, but rather cast its own shadow over Ruby which why I think they named it Crystal. I could be wrong though as a php dev, but that's how it looks from my POV.
You're right; the devs have mentioned in issues that being a "faster Ruby" has never been a goal, and IIRC asterite was once joking that he was drastically going the change the syntax just to make sure no one sees it that way.
Ruby could just as easily have been named [Coral](https://en.wikipedia.org/wiki/Ruby_(programming_language\)#The_name_"Ruby"). What would Crystal have been called if that were the case? Crustacean? 
Crystal is an amazing language, and while I too agree that it draws much inspiration from ruby, it has already evolved far beyond it. I think all rubyists will love crystal, but I am not sure if all crystalites will love ruby. Type safety and compilation are huge velocity gains for developers. Furthermore, not only does it further the ruby community‚Äôs paradigm of convention over configuration but it enforces it.
The Boehm GC does not return heap memory back to the OS by default. This means that if you heap size grows, your app will allocate more memory and keep that memory allocated for the crystal process. If you look at the GC free memory from within the process you will see that it freed the memory to be used for new crystal objects. Freeing the memory will stop the heap from growing, but the process will still keep that memory for itself. There is a setting you can use https://github.com/crystal-lang/crystal/issues/3997#issuecomment-283765417 Also read that thread for a more detailed explanation.
The GC is running all the time. Running GC in a fiber in a loop will not change anything.
You're ignoring the answers provided and repeating yourself. (Just an observation, not trying to be rude.) The memory is "free", in that it is available to be used. It is just not reallocated to the OS.
&gt; The memory is "free" But the ram usage still is high. And other applications on my server (for example, my simple php forum w/ mysql, nginx, etc) can't use it since Crystal has that "memory allocated". There must be a way to de-allocate and free it up. It's not fair to my other programs I feel.
He is telling you that there is no way to do that. Crystal does not give any memory back to the operating system once it grabs it. If you need that then you need to use different language.
&gt; You're ignoring the answers provided and repeating yourself Yeah.. I'm just repeating myself, and NOT trying to understand anything at all. Btw, remind me not to ask another question here again. So sorry it takes me a while to try to understand things and also so sorry for not being smart enough.
Just ignore those responses, you are asking a perfectly valid question. I had the same questions. What the OS tells you how much ram a process is using is different from the free memory with the process it self. Every time you create a new object via the GC, the GC looks for free memory. If there is no free memory, the GC requests memory from the OS and adds that to the heap memory. This increases the size of the memory a process uses according to the OS. The GC uses the free heap memory to create your objects and when they are not used anymore, the GC can reclaim the memory used by the object. This happens automatically for you and you don't need to do it yourself. This memory is returned to the free memory in the heap. The memory is not returned to the OS. So the process still uses the same amount of memory. If you are familiar with ruby, you would see that after a few GC runs, the heap size may be reduced. This happens because the ruby GC gives some of the heap memory back to OS if it hasn't been used for a few runs. The crystal GC does not do this, it will only increase the heap, never reduce it, hence the process memory will never be reduced in size unless you restart it.
Sorry. You're frustrated. As I said, I wasn't trying to be rude -- believe it or not, I was actually trying to help get the point across. Lot's of good information in this thread.
&gt; Lot's of good information in this thread. Yeah, and takes me to get shamed in doing so. Pretty fucking pathetic.
woah. dude relax. you are being very sensitive.
There is a new GC being written specifically for Crystal though by ysbadadden. Maybe it will change some of this behaviour, but who knows?
Forks! Im tbrand! We are discussing and developing the blockchain everyday! Joining our slack from github!
One thing I'd like to add, is the community. For an actual real word proof, search "Dillybob1992" on the Crystal's gitter. And look how much help I received for questions (which is what drove me to create that Crystal TCP Server example w/ Godot). They are extremely helpful in there. The lead developers post regularly in there as well, and it's such a promising feeling to know, you will always (99% of the time), get help with your questions.
So much this. /u/RX14 is another member worth mentioning for the level of help he gives in the community, too. They're all great though.
I have been playing around with this language for almost a year now and I love it. I became one of the sponsors because I would really think Crystal can make a difference in the programing languages paradigm, and since I have little time to commit to the project as a coder, I would like, at least, to collaborate as a backer and some sort of Evangelist / spammer (whenever I have the chance I always talk about Crystal.) The only thing I worry about is that it has been labeled as "promising" for a little bit too long now. I think the biggest challenge is to transition from "promising" to a "real amazing" language.
It's u/RX142 actually, RX14 was taken :) Thanks for the kind words!
oh sorry, my bad! I mixed it up w/ your IRC/gitter handle
Yeah I'm RX14 everywhere else so it's definitely confusing.
Possibly relevant username alert
I'm still waiting on an answer haha, but yes I may just eat 'em if I don't get it.
The classic chicken/egg scenario. The next successful stage after "promising" is "proven" (in production, at scale), and I haven't heard anybody telling that story yet. I expect that it'll poke along in "promising" purgatory for another year or two, until some hail-Mary project that's already in deep schist reaches for it in a desperation move, and proceeds to save the company. Then it gets the "overnight success" treatment from the glossy business-IT pubs/sites, gaining enough boardroom credibility to be approved for trial projects in existing companies. When enough of those start succeeding, we're back to Ruby circa 2004 or Java circa 2003. Exciting times; not yet for the faint of heart.
I meant the parent commenter's. :)
Ahh yes. Relevant indeed.
In order to make that transition they need more people on the core team. They need better programmers on the core team. They need people who are more open minded on the core team. They need to embrace the developers they have and listen to their needs and take them seriously. Very serious changes to take place in the language. Static compilation, multi core, better garbage collection, faster compilation, and of course better documentation. Also the marketing has to change. Stop pitching this language to Ruby developers and instead pitch it to go developers. At the same time work to make crystal compile as fast as go and run as fast as go with the same level of quality tooling. 
I use this lib in my TIL cloning project https://github.com/ChangJoo-Park/today-we-learned :) 
&gt;You can name the repo priority_queue.cr and just change the dependency it will work. While this may work from a technical or language point of view I think it would lead to confusion for the consumers of the lib. 
Isn't that a recipe for disaster. It means a long running process will keep ballooning on high peek demands but never release this memory and thus starving the other processes of memory. Silly example: At x time there is a spike in usage, your service spikes to 90% memory usage but runs fine. The GC internally release the memory when thje demand goes down and the process can reuse it ( but it still holds the 90% allocation ). That means that any other process, lets just say the database will need to work with only that 10% left. Sounds like a serious decision flaw to me. By that logic somebody can spam a service to have it reach 100% or higher, forcing the system to put memory into the swap file and starting all other processes ( including the OS ). Nice way to take down a server. Unless you left something out like: The memory is returned to the heap and other processes can use it, only the OS can not properly show the correct memory usage of the process. Now that makes more sense to me. 
&gt; They need better programmers on the core team. There are like 6 people in the core team. One of them recently back, is the guy who wrote Crystal for the last 6 years. Unfortunately just about every developer has a day job, so progress will always be less fast. &gt; They need people who are more open minded on the core team. As in? &gt; They need to embrace the developers they have and listen to their needs and take them seriously. Example of such needs not met? &gt; Static compilation No idea what is going on with that. I am not a developer, just somebody with a passing interest in Crystal. &gt; Multi core You mean multi thread? In experimental: https://github.com/crystal-lang/crystal/wiki/Threads-support Part of the hiccup is that its linked to the GC as i understand. See also: https://crystal-lang.org/2017/12/19/this-is-not-a-new-years-resolution.html Multi-threading Rework the fiber scheduler to handle multiple threads in parallel 680 ~Effort in hours Manas.Tech is supposedly working on it. Not sure if this is active now or not as the company itself the first business is still earning money. &gt; Better garbage collection https://github.com/crystal-lang/crystal/issues/5271 In development ... https://github.com/ysbaddaden/gc Issues: the developer is limited to his own system and needs more work for windows etc ... &gt; At the same time work to make crystal compile as fast as go and run as fast as go with the same level of quality tooling. Go is a custom compiler. Part of the language design for Go was such that it can read and analyse the source code fast. And produce a output. But as a counter result, Go is less optimized as compiler and ends up being slower the for instance Rust or Crystal there LLVM back-end. LLVM as a back-end to a proper language produces faster programs but does such at slower compile time. More time goes into the actual optimization process. Your kind of asking to travel to the moon without understanding the technology behind it. There is only so much one can do to make the compiler faster. Do not forget that Go is developed longer then Crystal by several C/C++ veterans who got paid by Google to work on it non-stop and they have a bigger team / resource pool. The fact that Crystal that relies mostly on volunteer work while using LLVM is beating Go in a whole slop of benchmarks is amazing by itself. We all want features now, fast, now, faster ... Windows support is essential for me but like impossible for me to do so ( totally lacking in knowledge about writing a compiler ). So yes, all we can do is wait or use a alternative.
It's really quite common for `require "foo"` to live in `RX14/foo.cr`. It's not that confusing because you're just adding a constant extension. Require already allows you to require normal files without the `.cr` extension.
It does not give a compile time error because there is an implicit `else nil` branch in the case. There was some discussion regarding what would be a good behavior to let the compiler complain about missing patterns in case expression. But catching them in compile time is not supported yet. https://github.com/crystal-lang/crystal/issues/4749 https://github.com/crystal-lang/crystal/pull/4837 I would feel comfortable with something like this: ``` case a when Int32 pp a, typeof(a) else unrechable # some built in construct that will complain if # reachable during compile time # but requires discarding case/else if all is covered end ``` Currently you can use runtime exception for sure.
Thanks for the link. I came to Crystal because of the power of the union type and trying to get away from Go's interface{} type. An implicit else nil defeats that power. Oh well, I'll come back to Crystal if they implement this. 
&gt;There are like 6 people in the core team. One of them recently back, is the guy who wrote Crystal for the last 6 years. Unfortunately just about every developer has a day job, so progress will always be less fast. So you seem to agree they need more programmers at least. I stand by my assertion that they also need better programmers. People with pretty deep experience in writing compilers, garbage collectors etc. &gt;As in? The current team are not really open to new ideas. The community has asked for things which in my opinion have been quite reasonable like a pipe operator and tagged structs and better ways of dealing with JSON and YAML files and the core team has outright rejected them. There were also requests for rather small items to seek better compatibility with ruby and again rejected. The Immix GC is another example. The team recently said something like "don't hold your breath for that" meaning they are not taking it seriously. There was an issue recently in to_s which recently changed it's output and when people complained the devs said "don't rely on the output of to_s" or something like that. the rest of your post is just excuses as far as I am concerned. Yes garbage collection is hard, yes multi core is hard, yes static compilation is hard, yes fixing the compile time is hard but this is why they need more and better programmers. BTW looks like they hit a wall with the compile times. I don't think they can improve that without changing some things in the language and again they are not open to ideas on that.
That's cool. That means you could use greek symbols etc. Could make some math stuff a lot cleaner looking.
I think it's unfair to dismiss the whole language on such a small point. Quite often you depend on the return type of the case itself, in which case you would get a compile error since you suddenly have a implicit else nil where you shouldn't.
The memory is returned to the heap and other processes can use it, if swap space is as big as the ballooning crystal application. Users log out at night, their RAM memory space no longer gets actively used and gets swapped to swap space on disk as other request for RAM get preference. Modern OSes check RAM activity constantly and optimize.
Wow. What a rational response. 
Tell me what language is open to outsiders coming in and telling the developers what to do. I have been in the Crystal, D and other communities and everywhere you will see the same response. As long as people like us do not pay for the features to implement or our visions do not match with the developers, your barking up the wrong wall. Trust me, i have seen massive issues in several open source programming languages that directly affect there attraction for new users. But most developers who work on the core are unpaid, so they do not take orders from us unless they like the idea. And ... most developers are stubborn, see D for instance where Walter refused markdown in function documentation until he tried it and ... suddenly after years changed his mind. The issue with a lot of languages is, you can not work with pure democracy or else your language ends up a big mess as everybody wants something and not all people understand the technical issues it can create on the compiler / language. You know the beauty of open source code? Do not like the direction a language takes and you have the skills ( and people ), fork a project. &gt; the rest of your post is just excuses as far as I am concerned. And i will be honest, if that is the attitude you present to the developers or other people... It rubbed me the wrong way. They are not excuses but facts ... simple as that. &gt; this is why they need more and better programmers. Like open source developers who want to work for free grow on trees. Its always the chick or egg problem in any language. 1 -&gt; Your language has issue ( language, marketing, ... ) so people avoid it 2 -&gt; Not a lot of people use your language 3 -&gt; Hard to find more professional people who want to volunteer ... Loop back to (1) This is why in general only language who have a sponsor or corporate overlord grow, as they have the money to push and fix issues until the gain momentum. And not even then its a guaranteed success as a lot of languages have failed even with corporate backing. Take my advice unless you are directly involved into a project, the chance people inside a project like this will listen to you are 5% at best. And that is if your idea matches with them. I know its hard to stand on the sideline and yell with good intentions. If i had the time, i will have been glad to fix issues in different languages and push them more. But like most people, i have a family, a life that takes time, just as most people who yell from the sidelines. We have good intentions and see issues but when the developers do not see them or do not have time to fix them... 
I mostly agree with /u/arconx. We simply can't accept every proposal, because it's not possible for everyone in the whole world to agree. There are reasons we make various decisions, and they're always debated in the open where you can follow our reasoning. Regarding the immix GC, saying "don't hold your breath for that" doesn't mean we're not taking it seriously, just that it's a very early project and it may or may not succeed.
No, you're correct. It's not ideal at all. It makes running multiple programs with spikey memory usage on a single box impossible. Fortunately it's not particularly common. I think in the future we're going to have to distribute a GC built with fixes for &gt;8GiB memory usage and the config option to return memory. You can perform the swap attack on a GC that does release memory just by holding the application at high memory usage, so i'm not sure it's an additional attack vector.
Yea i know RX142. If i am honest, so far i like the direction Crystal is going. While i do complain a few times ( different nickname ) about Crystal, i like that its a very open project and the implementations are not bad. If it think back to Go with its silly Gopath that hinders people or its forced structure, the lack of generics. Or Rust while brilliant in design, horrible in actual writing style. How about we declare a variable "let buf xxx" and are not forced to write in function each time "fn readBuffer( &amp;mut xxx )". It gives me carpal tunnel syndrome each time grabbing the &amp; on a US layout keyboard. When somebody has been around the block with dozens of programming languages like me, you know that every language has issues and annoyances. It all depends on how much they bother productivity, learning ( when starting with the language ) or frustration. For me the most important feature is Windows support, almost all the rest actually work great ( if we do not count the Blue Screen of Dead issues ... think you know now who i am **lol** ). Without it i simply lose 88.7% potential client base in a instant. For a language this young without major corporation backing, is a small miracle they got this far. Is the slow compilation annoying, sure. But there are solutions for that with auto building ( https://github.com/samueleaton/sentry ). Saves instant second and half moving your hands from the keyboard to manual start the compilation. Now that is a interesting feature to build into the tool support for Crystal *lol*. Its actually amazing that you find this feature on every language but nobody actually builds it in to the compiler or package manager. Anyway, keep up the good work. Its probably not said enough by us complainers **lol**
Ah! Thanks for clarifying why you need this feature. While you can see me arguing your point of view in the discussions linked, there ended up being no decision made.
This would seem to indicate you're using the wrong data structure. If this is your own format, think about restructuring your data. If this is someone else's format, first convert it to something more sensible and then back again. If you need something you can access some set of (id,key,value) by either key or value, you're approaching database levels of complexity. SQLite can run completely in-memory, but I don't know enough about what you're doing to fully recommend it.
I agree that you seem to be using the wrong data structure here. Regardless, the replacement for `Array#assoc` would be `array.find { |(k, v)| k == search }` assuming you have an array of tuples of two elements (from `hash.to_a`). Although, you can just get the index directly: `array.index { |(k, v)| k == search }` would be equivalent to `insert_at` in your linked stack overflow answer. Here's a full answer to the stackoverflow question in crystal: https://carc.in/#/r/3ijz
The thing that annoys me so much about Crystal is the global state. The classes can have a global state (`@@` ) and macros can be defined outside a class/module. If you have Kemal in your project, and then you load in one of your shards a project that also depends on Kemal, they start to share a common state.
Indeed, but, i don't know if this is the heritage from being so similar to Ruby, but the projects tend to do this kind of stuff, which leads, in most cases, to a bad code. I just know Amber and Kemal, and both do it. In a small project, "it's ok", but as your code base grows, this problem starts to bite you. In the end isn't the fault of the language, in some places, yes, global state can be useful. Maybe the core team could do more posts about how to write good code in Crystal. My main language today is Go, and while is possible to do global state trough the packages, it's strongly discouraged by the community. Just changing the topic a little, i asked this one time at the forum, but don't got any answer. Do Crystal core team plan to implement any kind of data race detection like Go in the future?
Please would you report this bug yourself? You seem to have reduced it very well.
Yeah I agree we should be discouraging it, and yes it probably comes from the Ruby heritage. I strongly suggest making issues for shards and libraries which you think are egregiously using global state and make the case for them to stop it. I don't use global state very often if at all in my applications. It makes things untestable. There aren't any plans for a data race detector, and if I had to guess, any data race detector that appears would be far down the line. Just not our highest priority right now, sorry. I'd really enjoy any PRs or libraries that do this though.
Just had another look at your `PriorityQueue` code again, and it looks really good! The only thing I can spot is that you might want to run `crystal tool format` on the code. Really well done!
Let's merge this into shards :-)
You can always define a method to handle the logic, and put a type restriction on the expected type. If you then add a new type, the compiler will give an error. That is, the exhaustiveness check doesn't currently work for "case", but it works for method arguments in overloads.
Same as in Ruby. Classes must begin with a capital letter, and emojis aren't considered capital letters.
 alias Model = Int32 | String # type must be (Int32 | String), not (Int32 | String | Nil) def someFunc(x : Model) : Model case x when Int32 x + 1 when String "world" end end someFunc(1) someFunc("hello") So if you try the code above, the code doesn't compile because it's expecting an | Nil However, if you add | Nil to the Model type, alias Model = Int32 | String | Nil it does compile, and I thought it might do what I want. But then when you add an | Bool to the model alias Model = Int32 | String | Bool | Nil the compiler doesn't complain about not handling the Bool type. Perhaps I misunderstood? 
Yep, I tested it Ruby after I was playing around in Crystal. It makes sense, just something interesting I came across while trying to build something ridiculous. 
I've never used Crystal, but assuming its pretty Ruby-like.. I wonder why Query objects dont use class methods? UserQuery.age('30') seems nicer than UserQuery.new.age('30'). Is it something about Crystal that makes the later preferred? Or just the framework author's preference? Just curious. Regardless, coming from rails, I really like the design of Lucky! May have to give it a go soon.
I mean: alias Model = Int32 | String def someFunc(x : Int32) x + 1 end def someFunc(x : String) "world" end someFunc(1) someFunc("hello") That way you cover all types and `nil` is gone.
There's nothing preventing Crystal from being able to do that, but then you have to repeat those instance methods in class methods too. I mean, you'll have to define `def self.age` and `def age`. I guess instance methods might be preferred because you can compose operations.
 I did what @asterite mentioned in Crecto, class methods and duplicate instance methods: https://github.com/Crecto/crecto/blob/master/src/crecto/repo/query.cr Not especially DRY, but it works.
Done: https://github.com/crystal-lang/crystal/issues/5684
thanks for the context about the name ... I guess I'm persuaded. Looking forward to seeing how this project develops.
 The thing is that while you keep framework code DRY you penalizing all the developers that going to use that framework because they have to type extra `new`. I would say it's much more important to keep the public API clean than the internal implementation. Really don't like that approach, it's clearly that `UserQuery.new.xxx` looks worse and yet it's still implemented that way.
I've been using Elixir and I can say that you have to type a lot there, and I accept that. I think typing a bit more doesn't hurt. And code bloat (because that generates more code, takes more time to compile, takes more time to optimize, takes more time to document) is important to avoid.
This is just the start, it used Mongo to start with as an adapter. I plan on making it more expansive as I use it.
I have been meaning to create this for a while, but it's taken some time to get up the motivation. This framework is heavily based off of the Telegraf and Telebot javascript frameworks, as well as the already existent telegram_bot Crystal lib. I expounded upon the ideas, and some of the code, in telegram_bot and added a more robust event management system. There is still a lot to do, but it's ready to be tested!
This is amazing! I wonder if something like this already exists for Ruby or not? But i can totally imagine this embedded into dev environment/workflow of a web project and Ngrok tunnel being already ready for you to test your HTTP Webhooks from external tools on project boot. Wonderful! 
I actually based it off of an existing ruby project after getting the idea from a telebot example. I have a working example using my Telegram bot library tourmaline. Glad you like it!
Do you mind sharing the Ruby project you based this off of?
Superb! Thanks.
Sources: https://github.com/TechEmpower/FrameworkBenchmarks/tree/master/frameworks/Crystal
https://github.com/luislavena/radix https://github.com/TechEmpower/FrameworkBenchmarks/blob/master/frameworks/Crystal/crystal/server_radix.cr
Thanks :)
It would be great to see Lucky framework in this chart. Also looking at the numbers, looks like the raw speed of crystal goes down when dealing with databases. 
But it doesn't though, does it. It takes about a minute to compile the whole spec suite and the compiler, which is 1/4 of a million lines of code. Smaller codebases are far faster.
For plaintext and json: because they're written in C with about 3 lines of python to glue the C extensions together. And that C has been hyper optimized whereas the crystal http server has not. For the DB tests, it's largely that crystal's DB drivers haven't been optimized much either.
This is based off of a golang project called [json-to-go](https://mholt.github.io/json-to-go/). I decided to take the same concept and make it work with Crystal. Still in beta, so let me know if you have any issues or feature requests.
Wow that's awesome. Sorely needed.
This is awesome!
I actually have some games written in Gosu and tried to port them over by using SDL2 https://github.com/jwoertink/crono My thought was to build a Gosu API compatible framework wrapped around an already working SDL2 library. I ran in to some issues since that SDL2 shard isn't updated often. I have another try using CrSFML which seems to be going better, but the way this library works will make it a lot harder to do a Gosu like interface. I'd love to work on it more if you wanted to help out!
As Gosu is written in c++, I was wondering if we could not use this tool: https://github.com/Papierkorb/bindgen Since Papierkorb managed to port (at least a part) of Qt, this should works well but I'm really out of my confort zone here.
I left Crystal for Rust. It's much different, but it accomplishes the goal of erroring at compile time more often and already has Fearless Concurrency‚Ñ¢ and windows/mac/linux support.
Hrm, why the throw away account? Maybe you're just trying to spread FUD? Did you see https://crystal-lang.org/2017/12/19/this-is-not-a-new-years-resolution.html ?
Well, according to the CHANGELOG for 0.24.1 https://github.com/crystal-lang/crystal/blob/v0.24.1/CHANGELOG.md at least compiling times for release builds are getting faster. I do agree however that again, communication has been scarce, except for a couple of guest posts there is nothing going on in the Crystal Lang blog. Gitter is much more active, but I do understand that most of the potential Crystal users will not get all the way down to gitter to try to get some information regarding the language status. Some of the core devs such as /u/asterite or /u/RX142 are active on this sub, so sometimes you get to know what are they working on. Helping through bountysource seems to be the easiest way to contribute, although that is a leap of faith that is up to everyone to take. (I did) Maybe a community manager role for Crystal Lang would help wonders keeping potential users informed, but I'm not sure if that is suitable or not for the current status of the Language. At the end, there is nothing else but to wait and to wish for the best... or to move on to a different language. I choose to think that the lack of communication is because the core dev are busy making 1.0 a reality :) 
I may not fully understand the gravity of the development issues. Perhaps the Crystal org needs to be independent and raise funds or an ICO. We would have enough firepower for a better software delivery.
You can always use Docker + Crystal for Windows. I am agree, that a lack of contributors is the huge problem of the language. 
That is never an option. You want to deploy and develop to and for Windows.
I would appreciate more non generic bounty source to fund a full time crystal developer. Someone IDK that will primarily work on Windows/Paralellism or whatever.
Rust is a different language and does not feel like Crystal at all.
You could develop for windows albeit not the elegant method with the Windows 10 BASH solution. I have been working on it since Bash was released. It‚Äôs a decent option.
That's not an option. It's such a stupid argument that I find it hilariously dangerous when it comes to software. The WSL layer can only be considered an option when you ARE writing software FOR Linux. Never an alternative to a Windows binary.
I'm pretty sure there's a simpler/native way to do this, but here's a simple library I did while porting [Entitas-CSharp](https://github.com/sschmid/Entitas-CSharp) to Crystal. Feedback welcome and appreciated.
WSL is not an option. It is not a target platform. It is like deploying and app to a vbox linux guest. Yes it works but has an incredible friction that you would not do it as a first option. You need to interact with win apis and the entire ecosystem and that is smh you generally want to do. If you do not care about the platform maybe your software is too generic and the os itself is irrelevant. 
I know what you mean; Rust certainly doesn't have that ineffable *feel* to it that Crystal does.
I encountered Ruby in the early 2000s, when version 1.8 was still fresh, and the language has happily kept me company since then. Crystal seems to be a natural extension of Ruby, and what it needs are well-funded projects that in turn fund the language's development.
[Blockchain](https://oscarbaruffa.com/wp-content/uploads/2017/10/slj1-345.jpg), on a more serious note congrats to crystal.
We'd be more than happy to learn about how you utilize Crystal and how's your experience so far.
Sorry but you **can't** give your binary to your customer, and tell them: But first you have to instal WSL, then docker, then you can finally run this program. Did I mention that it only works in Windows 10? Upgrade your windows, too! 
Rust feels enormously complex for developing apps where you would use something like Go or Crystal. There is at the moment no alternative to Go if you do not count Nim. Nim is a better option than Crystal at the moment as it's more complete but also suffers from small development team and small ecosystem.
I want to write Ruby for all sorts of applications. I do not want to use Go because Crystal really feels like Ruby and I would love to write backend systems and desktop apps in something like Ruby.
IIRC one of the developers said Crystal could compile a lot faster if type signatures were required in method definitions. To me that seems like a pretty good tradeoff but the team is not going for that. 
There is one other alternative and that's kotlin. Kotlin native is a compelling alternative to Crystal and it's already more advanced than crystal is. As for nim I think the nim team is more accomplished than the crystal team. They have written a blazingly fast language. If it didn't have significant whitespace I'd be all over that. 
How does Kotlin leverage the "native"? What about the ecosystem ? 
It's a solution for developing on windows and deploying to linux, which covers a portion of the userbase which needs crystal on linux. No, it's not a long-term solution but it does solve real problems for real people.
Only thing I know is RX is working on windows atm and idk what asterite is working on.
So far so good: I've installed Crystal on Ubuntu on Windows as well as on an Ubuntu machine, did some tests, got some Ruby code to run on Crystal. Nothing earth-shattering but it's a start. What I like is that the language is relatively limited, so it usually seems pretty clear what needs to be done. I do like Ruby, but it has become (ok, maybe has always been...) a rich language, so time is spent on choosing the best way to implement each step. With Crystal, application design work (defining objects and functions) will obviously be very similar, but coding Crystal might be a more focused affair, where the path to take at each step is more clear/obvious because there are less choices. It may mean more lines of code, but that's not necessarily a bad thing if it improves readability.
I'd be up for this, wonder if the rest of the core tram have time though.
Great! Do you know any good place where I can pitch this Idea to the core team members? I was thinking about a github issue, but it doesn't feels right
Mailing list. But I posted it in the core team private chat and no reply yet...
I will give it a try. Thanks!
Indeed it looks like it had no traction at all. Well it did worth the try
Agreed, DB access is the choke point right now. Crystal-Radix is near top of the pack in JSON and Plaintext where db access is not used. In data updates several Ruby implementations out perform the best Crystal implementation. There seems to be room for improvement on the drivers.
It‚Äôs very fast. I have a solid experience with Crystal and some apps with in production. ‚ÄúFast as C‚Äù isn‚Äôt just a buzzphraze. Crystal compiles and it really allows to reach speeds comparable to C. I recommend you to invest your time in this language maybe building some DB benchmarks, you won‚Äôt be disappointed üòè
Thanks for your reply. I am currently writing up some micro benchmarks such that I can have a better idea how the performance of the db access compares across a few programming languages and drivers. I have done a few tests at work where I have rewritten API functionality from Go to Crystal and actually noticed speed improvements when testing the response times of single requests. Micro benchmarks will only tell me so much though, especially when its so easy to be comparing Apples to Oranges when using different technology stacks. In particular, I am curious of how well the drivers hold up once the loads become more concurrent. Would be interesting to hear how developers with large production databases have found the Crystal-DB drivers to hold up to highly concurrent loads.
I like it. I love the small but healthy Crystal community. 
:(
I suggest you look at https://github.com/crystal-lang/crystal-db/issues/77
something is not right indeed 
Thanks! I too love the Crystal community, but sadly bigger community == more support in general
For those interested, I ran several microbenchmarks which suggest that Crystal and Go have very comparable database access times when requests are being made sequentially. Out of the box PostgreSQL appears faster than MySQL for both Crystal and Go using default configurations on my machine. In fact both https://github.com/will/crystal-pg and https://github.com/abidon/crystal-pq were the best performing drivers overall on my microbenchmarks, with https://github.com/lib/pq closely behind. What I currently do not know is whether this holds true when the loads become concurrent / or the system/database traffic gets heavier. This is something I want to test more. #77 does seem to explain why concurrent db tests could be slower on Crystal. I will have to see what I find out on my next series of benchmarks. 
First of all, it is great to read that this is going to happen! Really looking forward to ^^ As for the time, speaking for myself, any time is fine. I'm happy to stay up late / wake up early for this. I guess that since most of the core team is located on Buenos Aires (at least I think that is the location for Manas tech) I guess UTC -3?
Oh great!, Please make it Saturday or Sunday, I'm busy during week
right. Argentina's timezone. I'm from there too, but I'll available anytime! Thanks
I liked! I want to do a similar presentation for my company, too. I also wanted to show a small example of binding to a C library. 
Sometime between 9am and 9pm PST would be great
„Äú(Ôø£‚ñΩÔø£„Äú)(„ÄúÔø£‚ñΩÔø£)„Äú
his layer provides support for the Crystal language with the following features: - =crystal tool format= on file save - integration [[https://play.crystal-lang.org ][play.crystal-lang.org]] using [[https://github.com/veelenga/play-crystal.el][play-crystal.el]] - Linting with flycheck - test runner (=crystal spec=) - =crystal tool= integration - Interactive REPL ([[https://github.com/brantou/inf-crystal.el][inf-crystal.el]] and [[https://github.com/crystal-community/icr][icr]]) - static code analysis using [[https://github.com/veelenga/ameba.el][ameba]]
TFB DB tests here: https://www.techempower.com/benchmarks/
Relevant issue here: https://github.com/crystal-lang/crystal-db/issues/77
Relevant issue here: https://github.com/crystal-lang/crystal-db/issues/77
The man in the post comments doesn‚Äôt realize that projects like Go and Rust are sponsored by industry giants and it gives core developers the freedom to work on these languages as much as they want. On the other hand, that‚Äôs why Crystal is great - people have small time and try to use it at their best, stating priorities and skipping things like keeping donations page updated. Crystal is a homegrown project, and I still love it. I personally think that Windows support is not essential, because R3AL developers tend to use Unix anyway. I‚Äôm also afraid that 1.0 will be bloated with other tons of unnecessary features which would affect core functionality, just thinking. My deep thanks to the core team and to contributors! From my 3 years of programming experience, the whole abstract concept of Crystal (beauty of Ruby and native speeds) is the very best thing ever happened to the IT world. Keep on! And the last but not least - it may sound crazy, but I advise the core team to reduce ambitions to satisfy the whole community, because there always will be people disliking something or wanting more.
How's the progress on windows? I haven't used crystal in a while and would love to start using it again.
I'm currently learning Ruby on Rails. Are the Crystal frameworks developed / stable enough to run an application is good as on Rails?
The short answer would be no. Rails was first released in 2003, that means that it has been there for 15 years. Also, Rails is built on top of Ruby which is also a mature language, thus the stability. Crystal, on the other hand, is still in beta (alpha?) state, that means that from version to version it suffers from breaking changes that affect current frameworks, being Kemal, Amber, Lucky the most popular ones. This being said I would say that those 3 frameworks are stable enough for learning even for deploying production ready applications as long as you know what you are doing. If I would have to rank those 3 frameworks based on their stability I would say that Kemal is the most stable one, due its simplicity. Then Lucky and finally Amber, being this one the closest to Rails in terms of features (although as far as I know there is no asset support out of the box right now) The community around those frameworks and the Crystal community, in general, is really friendly, so I'm sure if you need help you will find it soon enough. I especially recommend checking gitter in case you find yourself stuck with any issue with any of those frameworks. 
As far as i can tell the Windows development has massive slowed down. RX142 is the main developer on this. But RX142 seems to be busy with other things ( please correct if i am wrong ).
Hi &gt; Has development slowed considerably, is that something to worry about? We are pretty active, check our gitter room: https://gitter.im/crystal-lang/crystal &gt; What is the status of SMP support? Is there or will there be a GIL? Currently, Core team is thinking on implement multi-threading, check this: https://github.com/crystal-lang/crystal/wiki/Threads-support &gt; What is the GC story? Crystal isn't as flexible as nim, but current gc works pretty well, although we have been discussing some alternatives, see: https://github.com/crystal-lang/crystal/issues/5271 &gt; What are Numerics like? Pretty like Ruby, we have some issues about that, though, see: https://github.com/crystal-lang/crystal/issues/2995 &gt; How does Crystal deal with the expression problem? Is there anything like Haskell's type classes? Are there interfaces or some such mechanism? Crystal is a bit more complex/featured (pick one) than Nim, Julia, Rust or Go in this field, there is a nice recent presentation discussing some of this points: https://pragtob.wordpress.com/2018/01/27/slides-where-do-rubyists-go/ BTW, you can try interfaces in crystal using abstract methods on modules, see: https://stackoverflow.com/questions/41778511/interfaces-in-crystal &gt; Is there a REPL? Yeah, there is ICR https://github.com/crystal-community/icr but isn't a real REPL. Crystal is compiled as you said, it needs to get info at compile time, there is some tricks using LLVM-JITor Marshaling but crystal hasn't reached that point yet. &gt; Are there multiple backends supported? Not yet, currently is just LLVM compiling to linux, macOS and Windows [WIP] on x64, x86_64, ARM and other architectures. I think when crystal get more stable we can try to add other back-ends like JS, see: https://github.com/crystal-lang/crystal/issues/4778#issuecomment-320440976
Crystal newbie here ... * From my understanding a lot of Pull requests are made but for some reason they are not committed to code. Crystal has more active developers compared to Nim and it helps that Nim does not need to reinvent/re-implement a lot as it simply relies on a lot of C feature sets. Julia is a different mater. The issue is more in a language like Nim you have Araq main developer. So he does most of the work. With Crystal the work is more spread among people but it also increases coordination difficulties because more people have a say. Both systems have advantages. Nim can push faster with one main developer. But if Araq is sick or something happens to him, Nim has a high change of ending up a dead language. Crystal is slower but because more people know the core, if something happens the project keeps going forward. A major different between Nim and Crystal is, that Crystal is actively used by a company called Manas. And they also do a lot of development. Something around 1300 development hours last year alone. * SMP is planned for this year. If the new year timeline hold up ( what seems to ), the next months will be spend by Manas to implement / rework the fibers, to make them behave more like Go Coroutines ( automatic SMP spreading ). See https://crystal-lang.org/2017/12/19/this-is-not-a-new-years-resolution.html * GC is fixed. Sorry but its impossible to find a language that is as easy like Crystal and that is GC-free. The only new languages that offer "technically" GC free is Rust and if you ever programmed in that language, you know its impossible to compare Crystal and Rust. There is some research going on to using a new form of GC ( Immix ) that shows a lot of promise. https://github.com/crystal-lang/crystal/issues/5271 People look blind over GC but in most projects you do not need to be GC-free. Unless you plan on doing system programming or drivers or embedded programming. But then your better off with Rust or C++ or C+ anyway and not with Crystal/Nim/Julia. * Multiple backends ... Currently not. I assume you ask this question regarding Javascript ( Nim Backend ). Well, not that i know. It uses LLVM so that means its capable of later expanding into different outputs ( see other projects that use LLVM ). WebAssembly if the standard finally includes a GC ... Crystal is a nice language that is very compact. Doing my own little tests shows it being almost as fast as Go. But at a massive compacter code. Some silly http+database access code is 69 lines of code in Go ( error handling, structs, ... ) where as the exact same code is 17 lines in Crystal. It feels and behaves more like a Scripting language what makes it more easy. My advice is just give it a try and see. I have done dozen of languages from Nim, D, Julia, Go, Rust and i keep coming back to Crystal. Nim is not bad but it has issues in syntax that feel slapped on instead of integrated into the language. I hope this information helps. 
Yeah, thank you for your reply +1
Nice reply! Yeah, crystal and their frameworks are still on early development. They are lightning fast and have awesome features like apps compiled to one single executable, static type checking, ruby-like syntax, precompiled templates, WebSockets, and other capabilities out-the-box. However like CaDsjp said, you need to know what are you doing because these are pretty young tools, and IMO new concepts like Type system, macros, etc should be learn by dynamic developers like rubyist and pythonist before/during using them. So, don't compare us to other super stable framework yet (like rails), but stay tuned for new awesome updates and features. Once we get ready, we can be a great alternative. 1. Kemal: http://kemalcr.com/ (Sinatra alike) 2. Lucky: https://luckyframework.org/ (new concept) 3. Amber: https://amberframework.org/ (Rails alike) 
The point of underscore or it's clone lodash in JS is to overcome JS weaknesses as a language. It doesn't makes sense to have underscore or lodash in Ruby or in Crystal.
Some yes but in future I change it
&gt; because R3AL developers tend to use Unix anyway Take a look! :) https://twitter.com/wycats/status/973761496277704704
Thanks guys. I think I might give Crystal a go. Any good libs for binary protocol packing/unpacking? What is ide/editor with best support currently? 
It makes really no sense to promote this as a Crystal port of lodash. This will only drive people away. I wouldn't even consider using a shard copying the behaviour of a library that solves problems not even existing in Crystal (because it has a great stdlib - in contrast to JS). If you want this shard to be useful, you should focus on and rethink it's purpose. What exactly should it be good for? Does using it add a real value?
Yep, as one of the commentators says, Windows is enterprise. I don‚Äôt want Crystal to be ‚Äúenterprise‚Äù - bad associations with Java on .Net Free devs like me prefer nix (be it mac or linux), you do know that!
Why enterprise is bad? I mean I use Java and C# all days at university and work, they are pretty fast languages with a huge community of developers spread around the world and supported by most companies. I guess if we want to see crystal being used by companies in embedded systems, lightweight systems, high RPS applications we should introduce crystal at least a bit to the enterprise world.(a.ka. Microsoft, Oracle, IBM, etc) Cheers :)
Does anyone know what is the status of Windows support ? I can only find comments from last year ..nothing recent.
&gt; You: "enterprise" is bad, I can't explain why Hehe, seems most people think like you http://www.debate.org/opinions/are-corporations-evil &gt; I: introduce crystal at least a bit to the enterprise Well, I didn't say crystal to become enterprise but be available to work for enterprise solutions.... at least a bit
1. Limited experience. It was ok. Startup time bugs me a bit. 2. MS centric. Don't trust that the experience on non-MS will be first-class. 3. I don't find working with PHP enjoyable. 4. JS has improved but it still feels like there are a lot of crutches/hacks to make it nice to work with (all centred around Babel). I don't enjoy working with it outside of a web browser. I use Crystal because it's familiar (due to Ruby experience). I like Crystal's c-binding interface. It's not my main language atm but could be in cases where Ruby is a weak choice 
Hi, I'm 24, but with just a few years of experience in the IT world, because I was studying another different career (not related to IT at all) when I was younger ;) 
1. go for kotlin on vertx, instead 2. some interesting SOA companies use these, but i never hear about anyone especially loving what thye do. 3. generally considered languages for ecommerce. Most programmers seem to hate life or love koolaid. Or you are Facebook, but they build with LLVM. 4. usually appeals to those with little experience in programming languages. Frameworks are rare as most patterns are assembled by those without training to build a framework. Node is not fast compared to anything compiled Ruby hate is overblown as there are plenty of enterprise jobs for it.
Look at what successful companies are doing. Apple, Google, Amazon, Facebook, Ebay, Reddit, etc. How many of them are using Windows and C# and .NET. None of them. There is a reason for that.
sorry for intruding here but I just wanted to say that I totally agree with this last phrase. &gt; I'm using Crystal because I find the mindset very similar to ruby. I think it, I write it, it works and I'm happy. There is something that just feels really good when writing in Crystal.
Great comment!!!, Thank you for sharing :)
&gt; There is something that just feels really good when writing in Crystal. Oh Yeah!!!
I use crystal because it's fun, fast and powerful. I've been having to do a lot in Go lately as well. The team is always surprised when I can write the same thing in crystal in half the time and have it run twice as fast. Laravel is fast but not nearly as full featured as Rails, and the ORM is terrible. Check out amberframework in crystal lang. https://amberframework.org 
Apparently Apple has an internal rails team with multiple internal rails apps for managing inventory and other processes within the company. I know this because they just interviewed me for that position.
Nice, thank for your comment!
I can`t decrypt my cipher used OpenSSL, because crystal return this error: undefined constant OpenSSL::Cipher::AES But lines 'require "openssl" and include OpenSSL' containts in my code. Where did I go wrong? Crystal 0.24.1 (2017-12-22) P.S. Sorry from my English.
By any chance, did you forget to have OpenSSL installed on your system?
Hi, take a look: https://gist.github.com/faustinoaq/c10e3e37d4d1a21cf13118a07920190f
Thanc You! All is works! Almost all... What do parse binary file? Like in Ruby "unpack('L*')"? "to_slice" method each by every byte, like Ruby "unpack('C*')". I would convert Slice from file - to Array, to edit it. 
I found solution to use casting: `as` : https://crystal-lang.org/docs/syntax_and_semantics/as.html
If you stick with simply CRUD apps Amber is fine and my favorite among Crystal web frameworks. The good news why you should stick with both Crystal and Ruby is they are so similar that learning one translates many times with learning the other. So concentrate on Ruby now and by the end of the year (hopefully) you can program in two stable languages (learning the differences in crystal doesn't take a lot to pick up on)
Thanks. It is awesome suggestion. I missed this approach, because in Ruby or C it is anti-pattern to have assignment in the condition statement. But in Crystal I think it should be rethinking. Thanks again.
Using .not_nil! is the first thing that comes to mind.
I usually use the unless keyword: unless foo.nil? *process here* end Good way of letting the compiler know not to exec the block if your object is nil Fixed: https://play.crystal-lang.org/#/r/3u3h 
Yep Go and Crystal are my two main languages these days too
You're pretty much spot on with this comment. We do have cross-compilation, and llvm isn't the issue with compilation speed (its the type inference, and we know how to fix it). Our ruby heritage is I guess divisive, its both a great asset and a liability.
This is awesome!
Nice ... but its the kind of news you expect to see a blog post about and some cross posting the news.
I don't know if crystal-db can do that. In Granite ORM you can use `.to_h` method because it was implemented here: https://github.com/migeorge/granite-orm/blob/master/src/granite_orm/fields.cr#L57
thank totakaro. going to try granite orm now, will get back to you
I used JSON.mapping in an old project, it might be useful https://crystal-lang.org/api/0.23.1/JSON.html#mapping%28properties%2Cstrict%3Dfalse%29-macro
The `NamedTuple` will be copied, but the two strings `"Mike"` and `Hello my friends"` will be passed as reference, not copied!
The only "memory leak" is that you're using globals... I would think that copying by value should be less likely to create memory leaks. There are more objects, but less references to each object since the named tuple would only exist within a small scope at most. That said the trade off is that more time is spent doing garbage collection, but that's different from a memory leak.
You are wayy overthinking this. Come back if you have a performance problem and your metrics are telling you that you are spending too much time copying. There's a fairly common saying: "Premature optimization is the root of all evil" 
&gt; there's a fairly common saying: "Premature optimization is the root of all evil" hey, please no passive aggressiveness. this has nothing to do with performance issues, it's about me understanding how crystal works. just because my question has some overlaps with "performance" doesn't inherently mean i'm here to try to make my app run faster. i'm just worried about increase of memory usage over copying, that seems reasonable imo. i know crystal is fast btw, that's why i'm switching from nodejs and php. 
&gt; copying by value should be less likely to create memory leak so, if 100 players on my server all chatting.. and the NamedTuple is being passed by VALUE each time that function is called (basically duplicating bytes).. isn't it reasonable that the developer (me) to try to understand if what i am doing is even wrong or right? that's why i posted my code to get feedback, i'm not entirely sure! i don't mean to use globals. but i am coming from nodejs and in JS i have globals everywhere, i can't help it. i'm still trying to transition over, and even the usage of types are actually really neat (static type them out). and it feels good to do it, but sometimes, it gets irritating because i'm so used to dynamic languages. but i am doing the best i can, please just bear with me
Sorry if it came across as passive aggressive.
thanks for response, i understand it a bit better now &gt; It would make sense that hashes are allocated on the heap by default. You're giving up memory to get speed, which is not necessarily "bad". but if the data is allocated on the heap and doesn't get free'd by the stack like NameTuples do, that means now the GC has to more work. this also means now, that memory is going to be in the heap and not released back to the kernal. that's not very fair imo, because i want my crystal app to release memory to the OS every 2 hours or so, so the app doesn't utilize all my system ram (not fair to other services running on the server). and, hashes are easier to work with imo, because the keys are not strict like in NamedTuples . and when i'm sending character information, sometimes I don't need to send specific keys (depends on the function). however, NamedTuples are easier to write and syntaxically, i like em but i don't like the strict aspect of keys.especially if i'm doing an array of NamedTuples . that's why i wanted to use hashes and opyrpin warned me. but i do understand why now, because NamedTuples are allocated on the stack and faster, and as `Benoit de Chezelles `mentioned on gitter, that stack get's free'd. which is much nicer than an hash taking up heap memory?
It shouldn't use up all your system's memory unless your actively storing that much data. You can feel free to trust that your language will handle that for you. If you feel like the data that you're storing will use up all the ram, then look at persistence solutions(databases, s3 buckets etc)
Very useful! Thank you!
That is great to know. Thank you to everyone who donated.
Well there's no such thing as *perfect* GC, so if you want to full gc that releases memory all the way back to the kernel I guess you can write that. It would probably result in worse performance in almost all cases, but I guess it's possible. But as it stands memory usage is certainly bounded, unless you try to store too many things at the **same** time. If you store them at different times (ie object lifetime expires) total memory usage is bounded. Intermediary objects that have expired get cleaned up. I looked up https://en.wikipedia.org/wiki/Boehm_garbage_collector and it looks like it uses a mark-sweep and generational collection. This is not surprising. It certainly seems like the industry has decided is the best overall GC strategy. I remember reading somewhere that Instagram decided that no GC was more performant and that it was better to be fault-tolerant and restart python when it ran out of memory. That's certainly not acceptable to you, but it was interesting.
**Boehm garbage collector** In computer science, the Boehm‚ÄìDemers‚ÄìWeiser garbage collector, often simply known as Boehm GC, is a conservative garbage collector for C and C++. Boehm GC is free software distributed under a permissive free software licence similar to the X11 license. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/crystal_programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
I am using Amber in production as an API server, however it is not a high traffic application.
I assume that several of the top backers use Crystal in productions: https://crystal-lang.org/sponsors/ Your not going to pay 250 to 2000 dollar / month in donations, if you do not use crystal to make money. Most of my work with Crystal has evolved around testing and seeing how it stacks up against Go for our projects. Speed wise its in the same range as Go just the compiler being a lot slower. Its most power for any company that has a Ruby background, is the more or less the "drop in replacement" ( with a bit or work). Its not like your going to rewrite your entire stack, unlike going to a other language. My own tests comparing it to a few scripting languages ( like Ruby, PHP ) has Crystal crushing them ( no big surprise ). We are talking realistic routing, DB access reads from a cluster DB, Json REST Api etc... From this point of view its plenty production ready. The main issue is frankly, the slow compilation speed ( compared to Go and the "quick and dirty" scripting languages ) and the slow development speed of the language. I like to see Crystal going to a fixed release schedule like Go/Rust, where you more can anticipate official feature releases. Now if a company has the balls to put 2000 dollar per month on the line to sponsor the language, ... that sounds a lot like a ringing endorsement for the language in production.
I think your are looking for this? ARGV.each do |key, value| puts "#{key}=#{value.inspect}" end 
I don't know, I am new to crystal, and I want to create a command line program. When I run your code, it just waits for a second, then the program finishes...
What you're looking for is `gets`. Just like when you want to write some output you would use `puts` (put string), you can use `gets` (get string). Since crystal takes a lot of inspiration from ruby, you can read up on https://www.codecademy.com/articles/ruby-command-line-argv. See how ruby handles it, and you're like 98% of the way there in crystal. 
That is because your are running the above mentioned code but not providing any command line arguments. Do this: crystal arg.cr x y z Or do crystal build arg.cr and then run your executable with arguments. ./arg x y z
&gt; we also have some Google Cloud Functions running crystal code (by calling crystal binaries from node.js) how does this work? you don't need to install any dependency for running a crystal executable? @veelenga was asking about this the other day on Twitter https://twitter.com/veelenga/status/981762528689651712 
I have a question. When you say slow compilation time...do you mean when you are developing and you save files to test it takes a while at that point? Surely compilation time should not be a problem when deploying it to production. I could be wrong,
Compiling source to binary executable is somewhat slow. The actual executable is lightening fast. But the compilation speed of the source to binary executable is rather slow. Where as Golang has you compiling at maybe 0.5 seconds, Crystal is more along the lines of 2 seconds. It does not sounds a lot but when you make a lot of small changes, it does becomes a bit of a drag. And this is on a almost 5Ghz cpu... There are ways around it by using file watchers like Sentry: https://github.com/samueleaton/sentry This cuts out some of the boring recompilation work / time. Now seeing as Rust also uses LLVM as the back-end compiler and its fast, it simple means that Crystal is rebuilding too much code on each intermediary compilation job. Remember that Crystal has only show up 3 years ago as almost pure community project. So its not so feature complete as languages that had more years and corporate backers to put dedicated employees on those projects ( Rust, Golang ... ). For what they produced in that short amount of time, its impressive. The fact that companies are starting to use Crystal in production is saying a lot. If you are coming from a scripting language like Ruby, Python or PHP there are as far as i know no other project that deliver the easy of a scripting language with the power of a C language. And i looked... Rust is too complex and a better fit for people who are into C++, not web development. Go is more easy but my god does that language feel like pulling teeth so much. Dlang ... uch... 20 years to late and still a mess. So unless anybody can point out a other language that makes people who are used to the easy of scripting languages and deliver the raw power of C comfortable? At best we need to live with some of the minor disadvantages until Crystal gets a bit more feature complete compare to its competitors.
Thanks for taking the time to write that. You are exactly right. Crystal is appealing to me for the exact reasons you point out. I have a lot of experience with Ruby. I tried Go but felt like it was not going to be too fun to develop for the web with. Then I found Crystal. Again, thanks for taking the time, it has really helped with where my head and thinking is!
Were using Kemal as REST API handler in prod 
I strongly suggest you use [`JSON.mapping`](https://crystal-lang.org/api/master/JSON.html#mapping\(_properties_,strict=false\)-macro) so that you can use `to_json` on the character class directly. Don't worry about a memory leak, it's the job of the GC to cleanup the `Character` instances when they are no longer used.
&gt; so that you can use to_json on the character class directly. thank you but that seems really redundant because now i have to type all my keys and type again in the JSON.mapping. that doesn't seem fair there must be an easier way?
We have ideas for how to make crystal compile faster, we just need the time to implement them and see if they work. So this will surely improve in the future!
Nice. That is kinda like the Crystal version of Sinatra, right?
Yeah, the duplication between `DB.mapping` and `JSON.mapping` is a known problem, and in the future we'll probably change how this works. But for now, it's a neccesary evil that you have to copy/paste the mapping arguments between the two.
&gt; But for now, it's a neccesary evil that you have to copy/paste the mapping arguments between the two. fine with me. sorry if i came off as nitpicking. i was just kinda curious how to do it and if that was ok. i have no problem doing it like that, especially if i understand that's it - okay to do (official) - not performance issue - i understand why i need to do it ;) thanks /u/RX142.
Thanks for the update RX. Might it not also be useful to include a file watcher like Sentry into Crystal its standard tooling?
Yeha :) 
No, I don't think so. I don't really want to bloat the crystal tooling, and existing tooling exists and solves the watcher problem well. My favourite is http://entrproject.org/, which isn't even written in crystal. File watching is orthogonal to the function of a compiler.
Go is indeed not a lot of fun. Not to talk bad about Go as its really nice how everything integrates in there tooling. But so many aspects feel so forced. visited := make(map[String]String) visited = {} of String =&gt; String What is more clear? Or how about some real program: Crystal: db = DB.open "postgres://xxx@x.x.x.x:00000/dbname" sql = "SELECT id, title FROM episodes" names = @db.query_all(sql, as: {Int64, String}) names.each do |id, name| context.response.print id context.response.print name end PHP: $dbconn = pg_pconnect ("host=x.x.x.x dbname=dbname port=00000"); $query = 'SELECT id, title FROM episodes'; $result = pg_query($query); while ($row = pg_fetch_array($result, null, PGSQL_ASSOC)) { echo $row[0]; echo $row[1]; } pg_free_result($result); pg_close($dbconn); Golang: type Episode struct { Id int64 Title string } type Episodes []Episode connStr := "user=root host=x.x.x.x port=000 dbname=dbname" db, err := sql.Open("postgres", connStr) if err != nil { panic(err) } defer db.Close() rows, err := db.Query("SELECT id, title FROM episodes") if err != nil { panic(err) } defer rows.Close() var episodes model.Episodes for rows.Next() { var episode model.Episode if err := rows.Scan(&amp;episode.Id, &amp;episode.Title); err != nil { log.Println(err.Error()) } episodes = append(episodes, episode) } if err := rows.Err(); err != nil { log.Fatal(err) } // And then we still need to output this episodes :) Sure, you can use interface{} to reduce the clutter but your moving from compile to run-time. Or GoPath what can trip people. Or the infuriating error bubbeling up instead of a basic try cache. Or the fact that Go still has no official versioning. Not a issue for Google as all there code simple resists in one big repository. But for people outside of Google, this can be issues ( i have run into this several times ). Here is a good topic about Go ... its just a drupe in the bucked. https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/ I am not saying that Go is bad. Far from it. But a lot of the things that is supposed to magically solve ended up just the same. For instance the whole composition in big projects turns out it has the same issues as classes with inheritance. Magic bullets do not exist and issues only show up when project grow beyond a specific size. For people coming from a scripting languages at first Go is defiantly not bad. Probably why a lot of Python users have switched over to Go ( to even the Go developers surprise ). I love Go for a lot of things but it feels a lot like pulling teeth when you come from a PHP background. Crystal has been much more easy for me when doing web development then Go. Don't be shy to ask anything. A lot of people here are very helpful. You can find the core developers and others on Gitter. https://gitter.im/crystal-lang/crystal They do not bite. Well, RX14 might if people forgot to feed him ;)
Your PHP example could be improved by a lot if you were using PDO.
hello my friend. crystal developer named Serdar Dogruyol, @sdogruyol on github is using kemal in production for his hotel services.
that go code seems really confusing.. glad i choose crystal, geez....
i use fluxbb's db class. works really nice, but it is different than pdo i think. although, bjarne told me queries in c are harder to code, but i should be fine. doesn't bother me.
Oh i think he is the creator of Kemal as well!
While you had issues with it, i was also playing around with your solution to make it work. And yes, you can force a variable that holds a named tuple into a for loop that is expecting a array, hash or tuple literal. One solution i was looking at was allowing a hash and then using a for macro to expand the hash into text that is usable. macro everything_mapping(hash ) JSON.mapping( { {% for key, value in hash %} {{key.id}}: {{value}}, {% end %} } ) end data = { id: Int32, username: String, password: String, max_char_slots: Int16, group_id: Int32, g_id: Int32, selected_characterid: Int64, } everything_mapping(data) Something like that. A indirect route but that also failed for the same reason :) The issue is as far as i can trace back, a macro is evaluated before any run conversion. So if you have the "data" as a named tuple but it sees it as a variable. If you try to convert the variable to a hash, it fails again because the macro run has first priority. 1. Macro 2. Any compile evaulation 3. run-time That is how i see the steps happening. That kind of forces people into using providing the named tuple directly. Unless there is a way to convert during the macro run-time? Anybody?
wow, you can do for loops inside a macro? that's really cool, opens the door for me, for custom loops and stuff. could help me in the future as well i think. didn't know you'd play around with my code and take mine and opyrin's code to the next level. very thoughtful of you, appreciate it a lot.
O yea ... you can do iterations in macro's. :) https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/macros.md#iteration &gt; didn't know you'd play around with my code and take mine and opyrin's code to the next level I also wondered what the issue was and found it fun trying to solve it. A good learning experience. Technically that code is horrible because i was looking at the wrong problem to solve and that code actually does not work. But oprypin already posted the correct solution. Fyi i am also a Crystal newbie. Hell i am probably more of a newbie because i am a pure PHP programmer and have no background in Ruby. :) &gt; i've been posting questions for the past week and there's always someone there in gitter :P Yea, i have seen your backlog of questions on Gitter *lol*. Its one thing i like about Crystal. The community is very helpful and some of the people you can talk to are core language developers, so they know the ins and outs.
My guess would be how would the compiler know what temp\_data was if the type wasn't equal to "DB\_User"? Maybe try taking out the if statement to see if it compiles the way you'd assume. If it does, then try adding in an else case and see if you still get that error. 
Girn, I see you had issues understanding the Macro stages on Gitter. Let me give you a few examples how the normal process works: Your code: require "json" require "db" macro everything_mapping(a) JSON.mapping({{a}}) DB.mapping({{a}}) end class DB_User everything_mapping({ id: Int32, username: String, password: String, max_char_slots: Int16, group_id: Int32, g_id: Int32, selected_characterid: Int64, }) end In the compilation you have technically ( for Crystal 3 steps ): Macro expansion Compilation Run ( or run-time) Step 1: The above code in expanded by the Macros require "json" require "db" class DB_User JSON.mapping({ id: Int32, username: String, password: String, max_char_slots: Int16, group_id: Int32, g_id: Int32, selected_characterid: Int64, }) DB.mapping({ id: Int32, username: String, password: String, max_char_slots: Int16, group_id: Int32, g_id: Int32, selected_characterid: Int64, }) end Step 2: This code that is now valid run-able code, will be compiled to a executable Step 3: Now the above code will be executed during Run-time ( So when you run the executable you created. Or when you use Crystal xx.cr = Crystal run code without creating a psychical executable ). Macros are nothing more but a way to prevent repetitive tasks by inserting valid code, in the positions the macro defines. You can NOT ever never expect macro's to perform tasks that only work during run-time. So lets say you have some data "xxxx".to_json and you want to push the result into a macro. You can not because the macro can not analyse this. What it can do, is put that code where you want it to be and ready to be used during run-time. Or like the example you posted in the original post. The macro is like a lazy public servant with a attitude like "temp_data is a variable, what do you expect me to do with that. I can not use that... that is somebody else there department ( aka run-time )." Think of it as a advanced copy and past mechanism. It possible to go even more advanced and have a almost run-time behavior during the macro time but that is not in Crystal. If you have ever dealt with D-language, they have compile time function execution (CTFE) and there you can perform advanced tricks like that. But its slows down the compile speed a lot and it can make things very messy and complicated because the barrier between macro/CTFE-time and run-time is very thin in that language. If your never used macros it can get confusing, especially for guys like us who come from scripting languages where macros do not exist. :)
Somebody said requiring types on method signatures would speed up compilation. I think that's an acceptable compromise. 
That's not a compromise, that's destroying the only unique feature the language has. We can do it with only a few type signatures and speed up the whole language.
Amethyst last release was almost 2 years ago, I dont know if its even in a usable state right now.
All of the amethyst devs have moved on to Amber
Amethyst is most likely defunct now. If you're looking to compare some frameworks, check Amber and Lucky. 
Might want to check out [Lucky](https://luckyframework.org/). It's a web framework created by [Paul Smith](https://github.com/paulcsmith) @ Thoughtbot. Some more info: * Lucky announcement [blog post](https://robots.thoughtbot.com/lucky-an-experimental-new-web-framework-by-thoughtbot). * Lucky discussed on the BikeShed podcast (another thoughtbot thing) * [Episode 142](http://bikeshed.fm/142) * [Episode 136](http://bikeshed.fm/136) * [Episode 132](http://bikeshed.fm/132) * [Lucky guides](https://luckyframework.org/guides/overview/) 
Although previous comments might have been true in the past, looks like Amethyst is taking a new direction. https://github.com/amethyst-framework/amethyst/issues/81 
basically the compiler don't know what is the actual type is, when you print it prints out what is there, but when you try to change it you need to specify the actual type, example: https://play.crystal-lang.org/#/r/3vv9 I called .to_h on the JSON making it a Hash of JSON::Any =&gt; JSON::Any, the thing is it's now not in the wanted type of String, Int64. I think you shouldn't try to actually change the JSON but create a new hash that handles the changes. Think about it like a container of data and not really a Hash
&gt; but when you try to change it you need to specify the actual type aww got it. makes sense. yes, i understood this very well (on gitter, you say you just woke up). thank again as well. 
 after your advice / insight / information, i got it working: require "json" test = Hash(String, Int32).from_json(%({"r": 5, "b": 51})) test["r"] = 1000 puts test["r"] # BOOM! &lt;3
Awesome!!!
The initial values for `prev` and `cur` are 64-bit - the problem is the addition. The macro interpreter uses the method [num_bin_op](https://github.com/crystal-lang/crystal/blob/50aacaa2e1db62a0d77e893d34797405103fc852/src/compiler/crystal/macros/methods.cr#L461) which calls `NumberLiteral.new` without specifying `kind`. [NumberLiteral defaults kind to i32](https://github.com/crystal-lang/crystal/blob/50aacaa2e1db62a0d77e893d34797405103fc852/src/compiler/crystal/syntax/ast.cr#L217). Here's an example showing this. https://play.crystal-lang.org/#/r/3wax macro kind {% a = 0_u64 %} puts "{{ a }}: {{ a.kind }}" {% a = a + 1_u64 %} puts "{{ a }}: {{ a.kind}}" end kind # 0_u64: :u64 # 1: :i32 I'm not sure if there's a workaround.
My vote goes to Amber. Just seems more elegant but that is probably because of my Rails background
Please update the "Community Driven" section in amberframework.org! 30 releases, 1k+ stars, 1k+ commits
Its most definitely an oversight in macros. Please report it!
I also have this question/dilemma. But I think you don't nees to know Ruby to learn Crystal, they have similar syntax but I think it ends there. I thinking of reading the Overview on the website and the docs, while I try some basic exercises. After that I was thinking of play with Amber, as I something to develop a small web app. Any other suggestions?
Since you have prior programming experience with Swift, getting by with the official docs ([Book](https://crystal-lang.org/docs/), [API](https://crystal-lang.org/api)) and getting some pointers from the helpful people in the [gitter](https://gitter.im/crystal-lang/crystal)/irc channel should be enough. You *definitely* do not need to learn Ruby prior to learning Crystal. In fact, I think that would be counter-productive. If you find yourself dealing with a problem you can't seem to solve, search first and then ask a question on [Stackoverflow](https://stackoverflow.com/questions/tagged/crystal-lang) and tag it with `crystal-lang`. Quite a few of the core team &amp; language contributors are actively answering questions there, as well as some community members (including me!). The community is very welcoming, so don't be afraid to say hello or ask a question! Some helpful tips: * Crystal is object-oriented and *everything* is an object. So any built-in operation you can perform on a `String` will strictly be under the [String API documentation](https://crystal-lang.org/api/String.html). For example, `"hello " * 3` produces `hello hello hello ` and can be found under [`String#*`](https://crystal-lang.org/api/String.html#%2A%28times%3AInt%29-instance-method). * Crystal's standard library is quite feature-packed, so make sure you look through first and see if what you're looking for is available before starting browsing for shards. For example, coloring terminal output is in the standard library under [Colorize](https://crystal-lang.org/api/Colorize.html). * The [awesome-crystal](https://github.com/veelenga/awesome-crystal) repository keeps a list of interesting shards for various domains of programming. * Search for all public shards on https://crystalshards.xyz/ Good luck!
I found writing cli clients for various API's I consume in ruby/python/java to be a very useful learning process. I also did some toying with the crocoa/hoop library for os x UI development. That was an eye opener on the macro system, for sure.
&gt; How does Crystal deal with the expression problem? Crystal recompiles everything from scratch each time you make changes. With that, the expression problem disappears.
Very nice answer +1
though you definitely do not need to know Ruby to do Crystal I can only see it helping. A\) they are in many ways similar \(some small programs can be ported right over with a few changes\). Its relatively rare in programming to see this between two languages. B\) Crystal is not yet at 1.0 so the language is not even set and is unlikely to be very much earlier than late 2018 to be at 1.0 \(fingers crossed on that as well\) C\) As a new language not even out of beta you will find few resources for specific questions. Stackoverflow for perfectly understandable reasons. D\) it will be a few years at least before the packages for Crystal will approach that of Ruby and with Truffleruby on the horizon as well you could find yourself with projects that could be much easier to accomplish in Ruby and still have great speed. I've found my ruby knowledge serving me extremely well in Crystal. When I take note of the differences in the languages I can figure out how to do somethings by reflecting back to Ruby.
Lovin it. A lot of the streamlining I liked in Rails but in a much more performant language
What a happy guy on the preview 
They're not on the stack. When structs are inside local variables they are on the stack, but if they're inside an instance variable *of a class*, or in a class variable, they're wherever their container is (i.e. On the heap) So it's more accurate to say values (structs, tuples, numbers) are always where their container is, and local variables are always on the stack. And classes are always allocated on the heap, and then their pointer is treated like a value. The rules make a lot of sense but are hard to explain.
Tuples (as well as structs, primitives and other `Value` type objects) are generally stored *as value* and not *as reference*. In the case of local variables, that means they're put on the stack. If used as an instance variable of a `Reference` object, they'll obviously still be stored on the heap, though not as reference but embedded in the enclosing data type. As an example to illustrate this, the following code shows the size of an instance of `Foo` (which has instance variables as value types embedded): ```crystal class Bar @foo = 1 end class Foo @foo = 1 @bar = 2 @baz = Time.now end instance_sizeof(Bar) # =&gt; 4 == sizeof(Int32) instance_sizeof(Foo) # =&gt; 32 == 2 * sizeof(Int32) + sizeof(Time) ```
Thanks for the reply, it does make more sense to me now :)
Ah I see! That is interesting, I never wondered about "where primitives are stored" they were more intuitive, thinking of Tuples (and all Value types) in the same way helps wrapping my brain around the concept. Thank you!
Anyone compared Amber (https://amberframework.org/) with Lucky (https://luckyframework.org/)? BTW, great to see high quality frameworks already on Crystal.
since crystal is written in crystal doesn't that mean there is a parser built into the language?
It'd about time for a new release! The last major release 0.24.1 is even four months old. 0.24.2 only included bug fixes. And a new release process that should make future releases easier... Still waiting for this to pay off ;)
Great work! Thanks to everyone who has contributed in some way the project. Really excited about the future of Crystal!
Wow, Thank you so much for this! very nice! &gt; So I propose to just remove completely tab "Projects" Yeah, please /u/RX142, /u/asterite, remove these tabs, is just misleading content if no one has time to maintain them. A nice alternative are public organization projects to track all issues and PR automatically in one place, by example. I'm already maintaining the project board for Amber and Scry, and have been pretty automated, please, see: https://github.com/orgs/crystal-lang-tools/projects/1?fullscreen=true https://github.com/orgs/amberframework/projects/1?fullscreen=true &gt; like Amber Framework which has achieved a great milestone getting more than 1000 stars on Github. Oh yeah!, I'm currently working on a bunch of new features and bugfixes to make amber v0.8.0 a super awesome release :) &gt; (4) Wiki outdated and with content in Spanish I'm a native spanish speaker, so I can try to translate the outdated wiki +1 &gt; I always feel a lot of negativity about what's missing in the language, whether is full Windows support, parallelism, faster compiling times, you name it. I think crystal goals are pretty nice, I think these missing features can be achieved. /u/RX142 is already doing a pretty awesome work in Windows support [See his Twitch channel](https://www.twitch.tv/rx14). Crystal has some nice attempts to do enhancement in parallelism [See wiki](https://github.com/crystal-lang/crystal/wiki/Threads-support). And I has been proposing some ideas to make crystal compilation faster during development. [See my crazy idea of a Crystal VM](https://github.com/charly-lang/charly/issues) I guess a compiler rewrite would be nice to experiment. First writing a nice specification about what crystal should be, and then building the programming language around it. I have seen some nice projects related to programming languages written in crystal (1), so I'm thinking in something like a mini-crystal to experiment new ideas for the language. (just like mini-ruby). This "mini-crystal" would be a compiler rewrite without stdlib, and just the language itself, with incremental compilation, windows support, and parallelism.(2) 1. https://github.com/runic-lang/compiler 2. https://github.com/faustinoaq/mini-crystal 
Great summary! Thank you for this. &gt; 133 Pull Requests Yes, I think we should simply close pull requests that are more than 2 months old. If nothing happened at that time, nothing will happen now, given that everyone probably forgot about it, plus many give merge conflict right now. If there's interest, someone can open a new PR or first discuss things in an issue. Anyone up for this task? &gt; 542 Issues There are two problems with this: 1. Some issues are used to discuss stuff, so they can't be closed until the discussion is over. For this, I already suggested creating an `rfcs` repository, or simply discussing it in Google Groups or some other medium (maybe install a Discuss? That was offered some time ago). But not many seemed to like that idea. So that number of issues can't be lowered. 2. There are some bugs for which fixes don't exist, and probably won't exist in a long time (or will never exist, unless someone other than me can understand the compiler's code). I'm counting 119 open bugs, and I'd say %95 can't be fixed right now. And there are many other bugs that are not yet marked as such. &gt; 6 Projects This was created in a hurry with the idea that it would somehow make everyone start coding this, but of course it didn't work. I agree we should remove this tab, nobody is working on these "projects". I'd remove them by I'm not an admin in the project anymore... :-( &gt; Wiki outdated and with content in Spanish I didn't know about this. I guess we should do a clean up. &gt; 47 Branches Yup, needs a clean up too. Anyone with commit access can start doing that. Be careful not to delete the branches related to parallelism, though. --- About the "spring cleaning": it could be good to make it look like there are less issues/PRs in the language, but it doesn't progress the language or code in any way. It's nothing that a user using the language could benefit from. So it's just for the devs, to free their mind from the thought "Oof, there are so many open issues/PRs". But maybe that's good too. --- Even will all the above, I think the language can greatly improve by just making the standard library, docs, documentation and tools, which is what everyone is currently focusing in. And that's huge. Keep up the good work, everyone! 
Agreed with closing pull requests, but any kind words: "Thank you for the contribution", etc. so as not to alienate developers who want to continue to Crystal. Coming from Go, the knock against that community is that it's hard to contribute to the language. 
Looking forward to amber v0.8.0! 
 &gt; 0! 0! = 1 
Yeah, please, we need to share some "thanks" before closing issues &lt;3
I was also convinced that you were Japanese :D Then I read somewhere (I think it was gitter) that you were from Panam√°. I thought it was fun because I'm half panamenian and I live in Tokyo, so definitely we should meet some day :D
Great post, It was a (much needed) boost of positivity!
&gt; Being Windows the most recently updated (July 1, 2017). Windows portion is false. Which is closer to Jan 2018. https://github.com/crystal-lang/crystal/issues/5430 There's fairly decent progress with windows, just not at a pace that I'd like. Nothing you can really do aside from hope more knowledgeable people hop on that project
I think there is a typo in the blog post title "Learning the Crystal langauge and Lucky web framework" (langauge)
Serious question, what's the fascination with these dev's parsing html with crystal rather than using pure template files and embedding data into the files themselves? Feels like every single framework does this right now out of the box. Which forces you to rely in their html parser rather than your own html code. 
I think this link is wrong &gt; is creating the Lucky web framework, it links to crystal page instead of Lucky project page.
about NetCDF \[link\]\([https://www.unidata.ucar.edu/software/netcdf/](https://www.unidata.ucar.edu/software/netcdf/)\)
Nice! We need more sci bindings for crystal. GDAL, PDAL, Pandas etc.
Really nice PR!
looking forward to having this available on the next release ‚ú®
Like this a lot!
It's hard not to like Crystal coming from a Ruby background. But I found the lack of a dynamic type when its would prove useful -- something Dart has -- really holds me up. It's lack makes some code really ugly and weighty, often requiring the use of macros and/or attributes (not to be confused with Ruby attributes) to compensate. Loading a YAML file is a good example.
I don't understand the proliferation of this type of program. Why not just write a binary for the task? The example sam.cr file is mimicking Rails actions `db:migrate` etc, but the need to pass the invocation through crystal makes the command _very_ verbose. A plain binary would be invoked as `crystal run src/db_migrate.cr` whereas a sam task has to be invoked as `crystal run src/sam.cr -- db:migrate`. Moreover, the migrate script itself is going to be 40-50% longer because it needs all the sam boilerplate... I guess I am grateful that it doesn't look for a Samfile though... 
I guess this sort of proliferation is due to the number of people coming from Ruby / Rails backgrounds. 
I get the introduction to Ruby developers used to Rails. But I think it's best to teach newcomers instead of hiding Crystal's advantages in favour of Rails conventions.
Seems like a great article, but hmm, he claims Crystal doesn‚Äôt have the `Enumerable` module, which of course is terribly wrong.
I don't think it claims Crystal's lack of Enumerable module, but that that module has fewer features than the Ruby counterpart and a different behavior. Which is true I think
Fast compilation, as solution might be partial compilation
Oh, right; i misread Oops. But Crystals `Enumerable` has most (if not all?) of the methods he says it doesn‚Äôt have‚Äîwith just different names. Or am I mistanken here as well?
Windows support, self-hosted GC, cross-compilation and cross-linking.
One small omission I noticed recently: there's no equivalent of Ruby's \`File.find\`. \*\* globbing goes some of the way but seems to currently broken with symlinks.
Never going to happen, don't count on this.
Http proxy support. 
What a reason to it? Macros? Generics?
Good debugger
Class reflection &amp; Ruby's `#call` functionality. Yeah you can do what you need without that, but you're writing way more boilerplate code for what? Only two things that have me putting crystal on the sidelines currently.
Not going to happen. Debugging in compiled languages is and was always terrible.
Reasons: - The ability to not specify type annotations in methods (also return types) - The ability to reopen classes and redefine methods - The way `require` works Summary: because it's how the language works (it's not compatible with that compilation model)
That's a shame. Graal's ecosystem at this point looks like a better solution :(
Hi asterite, what about this https://github.com/charly-lang/charly/issues/168 ?
Hi, What about this https://github.com/charly-lang/charly/issues/168 ? :-P
That's a VM, it has nothing to do with compile time. Well, it's a workaround. But until I see that implemented I won't believe it (good luck interpreting assembly code and low level primitives). 
Well, I think asterite is right, Ruby is dynamic, Crystal is static and compiled. I think macros and crystal codegen are enough to avoid boilerplate code.
I don't have time anymore. Plus for Crystal it's already too late for a change, and nobody will like the change. And then it'll be just like Go with Ruby syntax. 
Interesting, I though crystal already supported this :-P
Well, I think LLDB and GDB are pretty nice tools, currently I'm using Native-Debug on VSCode and works pretty well: See: https://marketplace.visualstudio.com/items?itemName=webfreak.debug Would be nice to use LLDB as well, but crystal have some issues with this: see: https://github.com/crystal-lang/crystal/issues/4457 If this is fixes We would be able the use the awesome `lldb` debugger: Also See: https://github.com/vadimcn/vscode-lldb ;-)
Hehe, no problem ;-)
Maybe we can from scratch with this https://github.com/runic-lang/compiler ;-P
I think Julia lang already managed to do this in some way :-)
Yeah, but it can only used in non changing environments as it just copies the objects out of their memory. So of you do one code change your serialized form is useless. So for savegames it is not suitable. JSON/YAML/MessagePack would be way more useful. 
From your comments in this thread it looks like crystal is finished ? :-(
No, why? I'm not the only one developing Crystal. The community keeps it alive.
We already have cross-compilation, just not cross-linking. Self-hosted GC doesn't make sense for crystal.
Julia is dynamically typed
I realised earlier today that if we make the change that arguments with type restrictions are casted to their type restrictions, we can theoretically parallelize most of the typing.
not really, debugging C and C++ isn't toooo bad. We can make it most of the way there with some work (see rust)
Casting of Arrays Types, as in`([1u8,2u8,3u8] of UInt8) as Array(Int32)`. Also for Type Unions. 
I guess you could technically roll your own Proxy class to do it yourself, but the language should really have it baked in by default. 
I forgot to mention generics. They are a real PITA regarding this, if their methods are not typed, because any instantiation can change the return type of a method. Think for example having a module, and that generic type including that module. You can't know all types of a given method until you know all instantiations. A bit hard to explain. 
Ugh, you're right. Nevermind.
https://github.com/goby-lang üòâ
Add a Dynamic type like Dart has. I don't think there is any reason to be "religious" about this. The vast majority of code will still be 100% static, but there a few places where having the option for Dynamic would greatly enhance an API and consequently programmer productivity. We all want fast type-safe code, but some times a simple and elegant API is the better trade-off. 
That would be OK with me. In fact I would trade the requirement for specifying type signatures and return types for faster compilation any day.
hehe, Thanks, golang is nice but I prefer crystal features and syntax üòâ
&gt; if their methods are not typed, because any instantiation can change the return type of a method Why not implement this to boost full typed code then? so, this code isn't parallelized: ``` class Foo(T) def initialize(@bar : T) end def bar(baz) {@bar, baz} end end Foo.new(Bar.new).bar(Baz.new) ``` but full typed code IS parallelized: ``` class Foo def initialize(@bar : Bar) : Nil end def bar(baz : Baz) : Tuple(Bar, Baz) {@bar, baz} end end Foo.new(Bar.new).bar(Baz.new) ``` WDYT?
So, if you write types, then you get faster compilation...
I've been trying to learn crystal by trying to port a lib written in another language I use and isn't available in Crystal. So far, it has been a quite an effective learning technique
Oh yeah, under what you're saying now. If you want to work on that it seems a very cool project.
Parallelism and windows support are at the top of my requests list. That thread-support branch is stale! Not enough interest in using all our cores? :)
Parallelism is a must in a server side oriented language
Devise is a rails specific gem though
Yeah, sorry about all the negativity. It's just that this whole situation frustrates me, because I really want Crystal to become a language that was good and sound, but now I realize that's probably not going to happen. The reasons are that the only progress happening in the language is the standard library. Well, there is some progress in the language itself, when I'm in the mood or bored and try to tackle features or bugs. But if it's not me, then nobody else is doing that (well, some do fix small bugs here and there, but never the critical ones). And people have hope that someone from Manas is going to do that, but that's not true, simply because they don't have time (at least now) and they don't have the knowledge of the compiler (only I have it, because I've been coding it for the past four years). So, yeah, mainly frustration. But I won't intervene anymore from now on. I'll let the language flow without me, maybe without my negativity it will reach a good port. I really hope so!
I think setting the right expectations for the language is important whatever gloomy those might be ;) 
I don't think Crystal really needs more features. The language as it is right now is very powerful, fast and has an immense standard library. The last couple of months I've been doing a lot of Crystal by myself \(not for a living\) reading the source code, playing with it, creating small projects and mostly reading almost every issue/pr created in the repository. What I have seen is that working on the compiler is very hard because, besides is a hard task per se, some parts needs a rewrite having written down before exactly what it has to do, not adding new features like a Frankenstein. I think Crystal needs to settle down what it wants to be and stick with it. Improve documentation and developer experience, but I don't think it needs more features. For example one of the last Pull Requests of Asterite was very cool, \(Explosive birth of automatic casts!\) because it adds better developer experience, we need more of that, revisit parts of the language that can be improved but aren't new features. Summary \(lately I write too much\), **I think** Crystal needs to refactor complex parts of the compiler and better developer experience \(more docs, better error trace, tools, etc\) but not new features. My humble opinion, as always.
Oh, nice +1
I‚Äôm a n00b to lower level languages. Why doesn‚Äôt a self hosted garbage collector make sense for crystal?
Crystal is a language with a runtime, which means its very difficult to use as a shared library. So the gc code would have to be compiled every time you compile a crystal program. This would increase compile times a fair amount. On top of that, the gc cannot use the gc itself for obvious reasons. Crystal has so many tiny language features which allocate memory which are so easy to miss that it would be really difficult to avoid allocations in the entire gc code. Plus our low level pointer fiddling syntax is a little verbose compared to C or rust. Ysbaddaden already tried to write a gc in crystal and hit these issues. He subsequently rewrote his gc in C.
You are not but you kinda answered yourself :-D https://www.reddit.com/r/crystal_programming/comments/8ilwwd/comment/dyvq9o9 It would be easy to raise money for you to take on crystal full time but I guess even you are not that experienced to take on the most critical stuff in crystal and on top of that you are not having that much fun right ? 
i would like to see the ruby community to step in and move to crystal instead of trying to patch mri
Totally, a language cannot have everything. Crystal actually have a nice set of features, the core team could set the scope of the language and refactor whatever is needed to accomplish that. Despacito y buena letra :\)
No and it shouldn't be. It's impossible to implement `call`. It can't happen. If you want a dynamic language use a dynamic language not crystal. You can't have both.
Hehe, What about this https://gist.github.com/veelenga/91fb751286b35f1b497f1a1c41228c06 ? Sometimes hacks can do some fun :)
I am OSX user, but a language cannot be popular without Windows support.
&gt; So, yeah, mainly frustration. But I won't intervene anymore from now on. I'll let the language flow without me, maybe without my negativity it will reach a good port. I really hope so! Hey, /u/asterite I understand your concerns. You wrote almost [all the compiler by yourself](https://github.com/crystal-lang/crystal/graphs/contributors). But there is a lot of people that still like crystal and want it to become a nice language. Can you share us some guides before you left?, I mean, can you inherits us your knowledge about crystal internals a bit more. There are a lot of developers than can collaborate in the compiler itself (not just stdlib) but we don't have any guide or specification about how crystal do all stuff. By example: How codegen works? How inference type works? How crystal parser/semantics works? What assembler do crystal use? How concurrency works internally? All these stuff is almost a black box for most of us :( Please, we need more stuff like [this Crystal Internals post](https://crystal-lang.org/2015/03/04/internals.html) Yeah, we have the code, but a Crystal Internals guide would be a nice help for us to continue this awesome language you created. Ref: [Please see Elias comments here](https://github.com/crystal-lang/crystal/issues/4864#issuecomment-386388681) &gt; ). And people have hope that someone from Manas is going to do that, but that's not true, simply because they don't have time (at least now) and they don't have the knowledge of the compiler (only I have it, because I've been coding it for the past four years). Sorry but I'm worrying about this,Where is the confidence behind all these crystal collaborators in bountysource? What they are contributing on? :( Please, I still think Manas is a great company, but if they don't have the knowledge or time can we figure out how to fix this ;-)
Yeah, we should put scopes to this, crystal is already a very nice language, we should not complain about other features.
Now try and send the method arguments.
Yeah, that's the limit, I already read veelenga's comment ;-) 
This is a great question. To be 100% honest I was pretty against HTML in code at first. The main reasons were: * It was tricky to learn. Lots of edge cases, structure differed from what I'd write in "regular" HTML * I was very used to HTML The reason I went with HTML in Crystal was because after a bunch of experimentation it ended up looking like regular HTML. The structure is very similar and so far every one I've showed it to has been able to understand it and use it quickly. Here are the advantages of this approach: * Stronger type-safety. In most (all?) templating languages in Crystal if you try to print `nil` it will happily do so and print an empty string. This is *never/rarely* what I want. In Lucky it will tell you to handle your `nil` cases at compile time * You can declare exactly what the page needs to be rendered. This makes it easy to see what you need to pass it without scanning the whole file for what it calls * *Super* easy to refactor and clean up code. Everything is a class and method so you can extract new methods to make things clearer, modules to share behavior, etc. There's no need for special methods for rendering "partials" * You can declare abstract methods on base classes for things like "page_title" so you never forget to add one. These are some of the main reasons for it. Some may prefer templating languages, but I'd urge people to at least give this a try. It feels very natural after just a couple days and soon you may not want to go back! :)
Actually, Visual C++ has a pretty good debugger user experience, but unless there is some serious investments made into developping this kind of tool, I'm pretty sure crystal won't have one anytime soon.
May I suggest another way to tackle the problem? Maybe a low hanging fruit that might bring some of the wanted speedup could be made by using partial cached compilation. What I mean by partial cached is that partial parts could be compiled and cached, but discarded when the context changes. The hard part here, as I see it and not mistaken, would be to define what is the context.
Some sort of reflection could be possible, as example: class Object macro methods {{ @type.methods.map &amp;.name.stringify }} end end but Ruby's #call is definitely not something that a compiled language could deal efficiently with. One solution would be to have a some kind of JIT-compiler at runtime which in turns would mean that you created some kind of Crystal interpred language.
The community isn't patching, but improving the language. Ruby and Crystal cover similar use cases, but a scripting language has its own strengths and weaknesses and the same goes for a compiled language. It really is about using the right tool to solve the problem at hand with its constraints (which necessarily includes developper skill set and adjacent tooling). I think what would be more desirable would be that the Ruby community considers Crystal as a alternate solution to using C/C++ when language performance is an issue.
I understand the desire to be tought how the implementation works, but I don't think this would help /u/asterite in any way: he clearly stated that time and manpower are the issues. So asking to take time to summarize/explain in an easy way the internals of Crystal is like asking to write a technical book to help students at the university. The way I see it is that /u/asterite probably knows which parts must be improved and what effort/skills/knowledge are needed. Assuming that I'm right, I think it would be easier to enumerate those parts (maybe as projects with several github issues) and associate the kind of skills/knowledge and some pointers from /u/asterite to help other developpers to jump in and take charge of some part(s).
Then Lets just get rid of this pest ‚ÄòWindows‚Äô for once! (I wish)
&gt; You *definitely* do not need to learn Ruby prior to learning Crystal +1 Great advice
It's not low hanging fruit at all. Getting any partial cached compilation to work would be a huge undertaking. The compiler just doesn't really have any sane way to cache parts of the compilation
Without having looked at the compiler, I assumed there was some kind of intermediate tree on each `require`, so I guess there is none. Maybe a first step would be to have that? What do you think?
I would appreciate a less defeatist tone here, I'm trying to help. Starting with "I don't understand" and ending with "It's impossible" doesn't really spur dialogue (which might be the intention). I'm gonna ignore that for now and explain what I meant anyways. At the simplest case, a single file without any dependencies will produce a single AST, but adding a second file into the mix with `require`, it should either reuse the current AST (as the global one) and continue adding nodes or, as I thought the compiler was doing, make a new one and merge both before executing the next step. Assuming the latter and taking inspiration from Rust incremental compilation [efforts](https://blog.rust-lang.org/2016/09/08/incremental.html), it should help with the dependency tracking part. I might be wrong, but that strategy was making sense for me.
parsing and merging the ASTs together takes a tiny amount of time, the type inference algorithm is what takes up 80% of the time in the compiler. That has to operate on the whole AST, not just a part of it. So any change means you have to redo 80% of the work.
this looks epic, can this work with a tcp server?
If you consider that there is nothing to keep as information between compilations, then I understand that the type inference algorithm cannot be improved by some sort of inline cache. But, the whole point of incremental compilation is to reuse previous information from previous compilations to prevent doing the same work again and again. Unless there is something really unique to Crystal that I don't grasp, I'm quite confused by the premise that "it's impossible" to gain speed by previous compilations.
What prevents this from being implemented as part of stdlib? Parallelism has been on the roadmap for quite some time. Would this fulfill that?
/u/asterite. i think you are underestimating what crystal has already accomplished, and how great it is already. especially for us "regular devs" who just want to use it to spin up a game server, simple tcp server, etc. crystal has worked beautifully so far. i think your expectations about the language are too high. i mean that's not a bad thing at all, because obviously the lead developer should have high expectations. but i just don't want you to give up just because of **YOUR** expectations. because what crystal can already do for us regular devs is more than enough! and the language is slick, fast, and awesome. it hurts my heart to see you not as excited about it as most of us are :(, please don't give up. 
Crystal's type system and type inference and compiler are incredibly unique and complex. Other languages can do incremental complication because they have simple, well reasoned type inference which is limited in scope. Crystal doesn't have that at all. There's no way I can think of to do incremental compilation even with a rewritten compiler because the algorithm makes it fundamentally impossible.
Its an experiment to see how fast and how useful this method of parallelism is. Its definitely not nearly as easy to use as if we got proper threaded parallelism working.
This is very very alpha, and only works for sending very basic structs down the channel for now. I don't recommend using it.
stays exactly the same. This is one area we can improve compile times with, bit it takes a bit of a breaking change.
I see. Thanks for the reply! üôá‚Äç‚ôÇÔ∏è That would be a nice tradeoff to choose from. But I'm sure that has been already suggested
Based on what you're saying, the problem lies within the algorithm (its intrinsic complexity). I'm still really spectic about the reasons why it would be impossible to improve by reuse. Unless the time‚Äìmemory trade-off isn't practical, it's almost always possible to use more memory to diminish execution time (referring to some sort of cache strategy here). The other reason why I'm sceptic is that specifying types (which is equivalent to caching) doesn't reduce compile time which suggests that there is presently no trade-off in the implementation. Maybe were are saying the same thing, but from different perspective and definition of "impossible"?
With complete respect because I await Crystal 1.0 with GREAT enthusiasm. Why be doing experiments like this now rather than putting the time into core especially if you think the approach is inferior?
&gt;Why &gt; &gt;not &gt; &gt; do experiments? Spice of life my friend. Pretty silly response. because crystal needs to get to 1.0 to truly take off
Hah. Whatever floats your boat man. Any particular reason you‚Äôve gone to insults? I was merely suggesting that no one HAS to do anything and some people like to experiment. It‚Äôs how ya learn, it can be fun, it can relieve stress. No one has to work 100% on something in the way you think they should. 
are you a child? My goodness. You keep running down someone asking a question that was asked in complete and stated respect not even asked of you &gt; No one has to work 100% on something in the way you think they should. said nothing of the sort and equally no one has to think like you do to ask a simple question. Now run along and play with your Nintendo.
Yeah. I can see how genuine you are. Have a good one then. 
&gt; With complete respect because I await Crystal 1.0 with GREAT enthusiasm. i think he was just fiddling around with it and decided to create a repo lol. if you check the gitter logs, rx14 is active almost all the time (sometimes even livestreaming), doing crystal stuff. i'm sure he's stll putting the "time into the core" :P
eh, little drama i see. nothing too bad, just try to keep our heads up. i'm very biased about crystal because i use WSL and the recent april update, actually made the compile times insanely faster. iuno wtf microsoft did, but my MasterServer.cr used to take 4-5 seconds. after I did the april update, it seemed like ubuntu was uninstalled so I re-installed it. now, when i run `crystal src/MasterServer.cr`, it's like 2 seconds top. i know it just seems like a few seconds, but the compilation was night n day. i'm just saying that, because i know a lot of people are thinking windows support will make crystal really "popular!". but, from my biased point of view, crystal is already shining and popular in my eyes. because i'm using WSL lol. however, it's not native windows support which is what they are talking about i think. which i agree, i think that would boost popularity. however, my point is.. i hope people are not that discouraged by not having "native windows support". i've been doing my gameserver for the past month or so on gitter, and WSL has been working great so far. so i hope developers don't just "not use crystal, until native windows support is added", when they could just start using WSL now! time is gold, don't waste! i hope that makes sense. but, i am just a regular "dev". im not a contributor, and no nothing about the "core" or whatever. i'm just an indie game developer converting my nodejs server to crystal. and honestly, it's great. there is a fine amount of shards. redis, hardware, and other shards help a lot. some reason, i always feel like asterite, and others are not listening at how great the language is already. i've tried to tell them, but no response. i just want them to know that. in any event, enough of me babbling, i have no where to post my thoughts. might as well post here instead of spamming gitter 
&gt;i'm just saying that, because i know a lot of people are thinking windows support will make crystal really "popular!". Actually I am not one of them. Ruby guy here and never found windows good for it. I've always thought the team was just a little over ambitious with goals for 1.0 and thought right out the gate windows support was one reason why. I'm more from a huge breaking changes perspective. Pre 1.0 gives the impression big changes are possible to come.. Maybe my understanding on that in regard to Crystal was wrong?
Parallelism and a more centralized way of managing dependencies a la RubyGems or Rust's Cargo (ie. a package registry instead of linking directly to Github repos).
An internationalization shard already exists (TechMagister/i18n.cr), why not contributing instead of creating a new one ? :)
Why not go straight to crystal, what does tinkering in rails first do for you?
I'm still not that great when it comes to putting types as I still encounter a lot of problems (my fault hehe) and so the dynamic nature of Ruby on Rails with the a whole bunch of gems in the development which speeds up the development and also materialize my ideas quickly.
I guess if the project is not time sensitive and you treat it as a way to learn ruby and crystal great, do what you want. But if I were consulting and the final project needed to be crystal I would go straight to that. Forcing yourself to analyze the types earlier in you career is probably good, you might make more visual progress with rails but you will probably have some bugs and some parts of the ruby app that you won't understand due to all the magic. The rails magic doesn't have to be magic, all the gems it pulls in are open source, if you do go the rails route make sure to dig into the gems that rails pulls in. Drop me a message if I can help with a specific technical/coding problem.
I come from a rails background and have been putting my tinkering projects into amber instead for the last 6mo and it‚Äôs okay. Amber is still in its adolescence, and I frequently have to monkey patch my way around missing features or bugs. But diving into the source and learning how to do that has been a great way to learn crystal, and the gems backing amber have a very welcoming and helpful community. I have a little experience with Lucky, and it has some nice ideas but my familiarity with Rails makes working with Amber easier. What gems are you looking for that would make working with Amber easier?
You are going to be really frustrated. The paradigms are completely different.
This is huge! I've been working in a Rails environment and this feature missing has been more or less the only thing holding me back from doing my next project in Lucky. Looking forward to test and see the performance.
They are contributing to future effort, because right now there's no time for Crystal, but in the future there will be. Be patient.
It's too complex, and the compiler needs a rewrite, so there's not much point in explaining how it currently works.
I understood that it was complex (prohibitive) in the current state. Sorry for not aknowledging it more clearly, I was sticking on the "It's impossible" part which wasn't sitting so well with what I think is possible.
Do you plan to let people collaborate on that rewrite?
Of course. That's the idea. 
I think Xcode has pretty good debugging too
Long story short, you never actually close the sockets, and they don't close by themselves (just hang there waiting for TCP timeout).
### Solution ok, did some testing and with the help from gitter, i added: `server.write_timeout = 2` and then checked `netstat -ntu` seems like the sockets are getting closed now
I think some things have been accomplished here: https://github.com/crystal-lang/crystal/pull/6074
Because the api might change a lot and not be stable right now. It's better to wait until and if it becomes a community standard shard add it later to the standard lib. Also sometimes it's nice to release updates to a lib independent of the language otherwise but fixes and new feature for a quickly changing library would have to wait for a language release.
Just add parallelism, tidy things up and call it version 1.0 More is not required. And if the parallelism was as simple as possible (maybe a copy of the Go approach?) then that would be fine. 
You won‚Äôt be able to copy over your Rails files as-is over to an Amber project. For the most part Ruby and Crystal are very similar languages, but 1-1 compatibility is not a goal of Crystal (and by extension of Amber)
How was spider-gazelle.com already taken?
I think it's fine to want to create new alternatives but Crystal certainly doesn't lack web frameworks or ORMs. Web frameworks: Amber, Kemal, Lucky, many others. ORMs: Crecto, Clear, Granite, LuckyRecord, many others.
You are being facetious, yes? 
üòÜ
The name is funny, but not suited for a serious web framework. But I don't get so many dislikes, is for that reason? I'll take a look
WAT???
Looks pretty cool and simple. Looking forward to using it in my side project. :)
&lt;/sarcasm&gt;
This is exactly what we need, what a great idea!
Hate the name and logo with a passion. Total turn off. Also on the face of it don't see anything it offers over Amber. change the name. Is awful \(literally the worse name I have ever seen for any framework\) enough to hamper its adoption regardless if its good or not.
0.25.0 coming next week? üéâ https://www.slideshare.net/sdogruyol/crystal-a-language-for-humans-and-computers/29
I think he is now having issue with getting a framework working 
Also, Crecto needs a logo. If you are a logo designer or have any ideas send them over!
In case folks here haven't seen it yet, the Crystal part's on Github: https://github.com/mint-lang/mint
I didn't see in the documentation anywhere, it possible to use existing javascript libraries along with mint?
Good question!
Very nice new site.
What is the minified size of the compiled javascript? It would also be helpful to see a todomvc benchmark or some tests rendering thousands or tens of thousands of list items on a page.
Thanks!
I'd like to add that it's very sad that this is still visible almost at the top of the Crystal subreddit. I would hope this does not reflect the overall stance of the Crystal community?
thanks for that very complete answer ! To be very honest, the first solution is very likely to be sufficient for my project's needs, but I really wanna try to at least experiment around the second solution :) ! Thanks again, I'll take a look at all of that!
Very cool, it has some Elm vibe, but simpler, which I like it. Does It compile to WebAssembly? That would be awesome.
This is very interesting work - parallelism using processes rather than threads has many advantages for the kind of work I do. But how does the GC in the child process work? Is there any? 
This makes me wish `crystal tool format` also renamed files to conform to the usual snakecase naming convention.
For anyone interested here's the recording of Crystal Team Live Q&amp;A 2017 [https://www.youtube.com/watch?v=E25AGpYyQw0](https://www.youtube.com/watch?v=E25AGpYyQw0)
I love you, Crystal core team.
I love you both
I dove in a week ago and wrote a small URL shortener with counting stats at GitHub.com/thewalkingtoast/mpngin It didn‚Äôt need much at all and my Ruby skills applied nicely. Very optimistic! I hope the cross-compiling story eventually is as nice as Golang but that‚Äôs not a deal breaker for me as I‚Äôd expect CI/CD to compile.
Thanks so much for the upvotes guys, and to totakaro for posting my blog post on Reddit :)
&gt;GitHub.com/thewalkingtoast/mpngin That's awesome! Great job :)
Glad you're excited about Crystal :) FYI, In the "exception handling" section, it can be shortened further to just: ``` def self.mount?(path) stat_path = File.lstat(path) rescue Errno # It doesn't exist so not a mount point return false end ``` The `begin` statement is implied in any block: https://crystal-lang.org/docs/syntax_and_semantics/exception_handling.html#short-syntax-form
Oh cool, thank you so much, I wasn't aware of this! :)
Amazing. Can't wait to try the authentication and testing out with flow.
Hi, fridgerator(1) and elorest(2) are already using amber in production. 1. https://tovi.io/ (paid tool) by https://github.com/fridgerator/ 2. https://nikolamotor.com/nzt (vehicle UI backend) by https://github.com/elorest/ and more have been commented on https://gitter.im/amberframework/amber I guess Amber needs something like this: https://github.com/kemalcr/kemal/wiki/Kemal-Users I don't know much about Lucky but I think Paul has being using it at Thoughtbot :)
Thanks, and it‚Äôs still a lot of potential for adoption yet I see many would still choose Ruby for mature language.
What's the forum.
Integration with Turbolinks and Stimulusjs would be awesomeü•á
Isn't something better than turbolinks? One project I worked on (Rails + turbolinks) I had just nightmare with frontend and testing (capybara) because of all the twearks turbolinks had... Maybe they improved it.
It's pretty easy to test it using headless chrome/firefox. I've also open sourced a rails5 boilerplate app using turboliks, stimulus, docker and other https://github.com/sebyx07/rails5-boilerplate I will build one using lucky too
Yes, I'm using Lucky for production. Our app is running a sort of test in production at the moment while we get used to the crystal ecosytem before we actually release it to the public. It should be live to the public soon though.
What is the reasons for using Lucky?
I have another project where I'm using Kemal because I needed something light. For the production app, we wanted something a little more robust than Kemal. At the time, there was really only a few viable choices that were out of the "super experimental" phase. And of those, Lucky was the prettiest, and Paul was really helpful in answering questions right away. Lastly, it wasn't my decision lol.
Yeah. I really like Amber but in the end our company couldn't take the risk with Crystal not being 1.0 and/or beyond the breaking changes stage. So we are still with Ruby and will either upgrade to Truffleruby when that is ready or rewrite if Crystal gets up to speed. 
Thats my replacement for [rubular.com](https://rubular.com) now.
Yeah, same here. Well, actually, I'm using .NET (sometimes PHP) until my coworkers'd feel crystal is stable enough :-P
Hey [Amber Users](https://amberframework.gitbook.io/amber/amber-users) is available now :-)
Amber User just gotrenamed to Amber In Production, see: https://amberframework.gitbook.io/amber/in-production
Changelog https://github.com/crystal-lang/crystal/blob/0.25.0/CHANGELOG.md
I see on github this isn't an official release yet. Is this meant to be a type of pre\-release similar to 0.24.0 was, and we can expect 0.25.1 sommetime soon after?
Hi Crystal 
hi there :wave:
No, it's just a tag, it means we've decided what 0.25.0 will contain, but we haven't actually released it yet. /u/CaDsjp's title is incorrect. 0.25.0 will be released today or tomorrow.
well /u/RX142 there is no way to edit a Reddit post so I guess you guys have no option but to release it now üôáüèª‚Äç‚ôÇÔ∏è
The JSON improvements are very welcome, and their docs are much clearer. JSON serialization should be a fairly trivial task, and having to figure out how to use the JSON.mapping macro had unnecessary friction. Much better now :)
Congratulations guys, great job!!! :)
^The linked tweet was tweeted by [@crystalkemal](https://twitter.com/crystalkemal) on Jun 17, 2018 16:23:12 UTC (4 Retweets | 11 Favorites) ------------------------------------------------- Happy Ramadan Feast to everyone üôè Kemal 0.23.0 is here üéâ - Crystal 0.25.0 support - Security improvements - Bug fixes and more [https://github.com/kemalcr/kemal/releases/tag/v0.23.0](https://github.com/kemalcr/kemal/releases/tag/v0.23.0) \#crystallang [@CrystalLanguage](https://twitter.com/CrystalLanguage) ------------------------------------------------- ^^‚Ä¢ Beep boop I'm a bot ‚Ä¢ Find out more about me at /r/tweettranscriberbot/ ‚Ä¢
Your profile picture reminds me of content cop idubbbz
Turbolinks is included (and can easily be removed if unwanted). Lucky also has webpack setup so you can easily add and import stimulus if you want to :)
I hope you like it! Hop in https://gitter.im/luckyframework/Lobby if you have any questions or feedback
I think it happen after Dockerize all process: https://github.com/tbrand/which_is_the_fastest/commit/1a93e5bd87503c1cfd839329dd98d647020a9cea#diff-04c6e90faac2675aa89e2176d2eec7d8
I'm using Lucky for a medium-size project and I am impressed. It's going so well so far that I have another project in the pipeline that will be based on Lucky too. I recommend everyone to give it a try.
Yeha, I too saw it, it's kinda weird.
I am not sure if I will port my php rest api to Elixir (Phoenix) or Crystal (Lucky). I really need type safety, but I fear Lucky being unstable or giving too much errors in runtime because it's very new.
Do you find whether the performance is on par or better than Amber or Kemal?
The performances are excellent, Crystal uses a FFI for C. It's a zero-cost abstraction. The TechEmpower results confirm that: https://www.techempower.com/benchmarks/#section=test&amp;runid=f26afdb3-7c19-4c20-84de-228b10434f84&amp;hw=ph&amp;test=plaintext
Awesome, how did you run the tests here?
Oh I didn't, they're now automated. I just stumbled on the link from S-YOU yesterday. I can't remember where to find the links to all TechEmpower builds.
How can it possibly be slower than Ruby?
Yea that‚Äôs what I was wondering. It seems like something about the new testing setup might not be well suited for Crystal or it might not be optimized correctly. 
Hey! In my testing, it was faster than Kemal and Amber, but even if it weren't they're all so close that I don't think performance would be a good reason to choose one over the other. The main reason to choose Lucky would be if you value catching bugs at compile-time. Lucky heavily prioritizes that for rendering pages, routing, and querying/saving to the database. But I'm also biased :)
This is a totally reasonable fear. I think that with Lucky you will likely see *fewer* runtime errors even though it is new. That's because of the type system and the fact Lucky leverages it heavily for all kind of things. With that said, each new version tends to have breaking changes, so when you update Lucky, you need to update your code. I try to write nice upgrade notes to help. If you're concerned about stability I would stick with Elixir and Phoenix and follow Lucky for a 1.0 release. Once that happens that means the API will be stable and you can use it w/o worrying about updating your apps every few weeks :) LMK if you have any other questions. I've contributed a number of libraries to the Elixir/Phoenix ecosystem so I can probably help!
Hi there, I haven't checked out Kemal. I compared Lucky and Amber and went with Lucky. I like the fact that it is type safe everywhere. I haven't develop anything with Amber so I cannot say how good it is. My medium size project is a platform containing the following: * User and Role Management (I extended Authentic) * Contact Management * Product Management * Products Evaluation * Import data from CSV files (\~100mb of data everyday) I am very glad with the performance. The app is super responsive and the client loves it. # Background I was really into Rust. I was checking out Actix and Rocket. After some tests, I showed that to my employees. Some of them were intimidated. I have to make sure my crew is okay with the language. Rust is excellent, I love it. However, where I live, programmers are mostly working in the gaming industry in C++ or IT in C#. I've seen PHP and Javascript too. I didn't want to use C# to stay independent of Microsoft so I continued my quest. Then I stumbled on Crystal. Crystal has a lower barrier than Rust and is quite performant. I thought it would be a nice compromise.
Crystal is running in one core All other are running in multiples cores
Here you are! https://tfb-status.techempower.com
Thanks for the reply! I will play with Lucky soon and start the prototype in July. I hope I won't have problems, it seems great! What is the default community?
Appreciate!
Another question, what aspects are type safe in Lucky that others Crystal frameworks are not?
Sounds great! https://gitter.im/luckyframework/Lobby is the best place to chat and get help right now :)
Great question! * Type-safe routing. It will fail if a route doesn't exist when linking or creating forms. It also automatically sets the HTTP method so you can never mess that up * Type-safe strong params/whitelisting. If you try to make a form input for a database field that is not allowed to be saved by users it will fail at compile time, and give you a helpful error letting you know what to do * Catches missing assets at compile-time. Gives you a nice message helping you find typos in your assets names. * The ORM is also type-safe. Queries are type safe so column typos have compile-time errors. Also passing incorrect values fail. * There are also typed methods that are only available on certain columns. For example, you can use the `ilike` method on String columns, but it will fail at compile time if you accidentally use it some other type of column. * Validations are type-safe. You use actual methods and not strings/symbols. So if you mistype a column name, rename it, etc. the compiler will find the bug and point you to the problem There are other spots but these are the ones I can think of for now More info * https://robots.thoughtbot.com/designing-lucky-actions-routing * https://luckyframework.org/why-lucky/
If you can‚Äôt access link to TechEmpower sites, they are having maintenance this weekend.
That's correct, Crystal runs on a single thread, but one thread can spawn multiple fibers. Multiple threads might come in the future. 
\`HTTP::Server#listen\` has a \`reuse\_port\` option ( only works on linux I belive ). This lets you run multiple instances of your server that will all listen on the same port. [https://crystal-lang.org/api/0.25.0/HTTP/Server.html#listen&amp;#37;28port&amp;#37;3AInt32&amp;#37;2Creuse\_port&amp;#37;3ABool&amp;#37;3Dfalse&amp;#37;29-instance-method](https://crystal-lang.org/api/0.25.0/HTTP/Server.html#listen%28port%3AInt32%2Creuse_port%3ABool%3Dfalse%29-instance-method)
Thanks, so I do this but it seems to don't have any effect :/ ```ruby s = Array(HTTP::Server).new 10.times do |i| s.push HTTP::Server.new route_handler end s.each do |s| s.listen 8080, true end ```
You need to create new process for each core, check TFB tests: https://github.com/TechEmpower/FrameworkBenchmarks/blob/master/frameworks/Crystal/crystal/run.sh#L3
Yes, a parser specifically for parsing the Crystal language, not a parser generator.
What's the error you get?
``` .....F Failures: 1) CLI #cli correctly handle subcommand Failure/Error: ct.sub.should eq ["extra"] Expected: ["extra"] got: [] # spec/cli_spec.cr:83 Finished in 98 microseconds 6 examples, 1 failures, 0 errors, 0 pending Failed examples: crystal spec spec/cli_spec.cr:80 # CLI #cli correctly handle subcommand ```
 .....F Failures: 1) CLI #cli correctly handle subcommand Failure/Error: ct.sub.should eq ["extra"] Expected: ["extra"] got: [] # spec/cli_spec.cr:83 Finished in 98 microseconds 6 examples, 1 failures, 0 errors, 0 pending Failed examples: crystal spec spec/cli_spec.cr:80 # CLI #cli correctly handle subcommand 
On line 37 you're passing a class type instead of a variable. Maybe that's it? Also, I'm surprised this would compile... actually, all of those you're passing a type when they don't expect a class. I'm on mobile so not able to try it, but that's my guess
Line 37 isn't passing a class type. Its a type signature that the cli macro is using to select the appropriate method, i.e. `mproc = -&gt;set_sub(Array(String))`.
no
Probably \`old\_run\` is assigned inside an \`if\` and used outside it, or something else. It probably has nothing to do with JSON parsing. You should show a bit more code.
FYI, turned out the problem was forgetting that `args` is passed by reference. Just had to `dup` it and all was well. Made sense after all.
I am looking forward to working with crystal on a production app in the future if for no other reason I absolutely hate deployment with rails. It goes fine sometimes but when it doesn't its REALLY bad.
Milliseconds Vs Microseconds..... 1000x difference. But of coz Amber is not any where as feature rich as Rails. Even Lucky, the framework from Thoughtbot isn‚Äôt close. If any framework were to compete they will need an ActiveRecord Equivalent. 
I think the main difference in speed is because of Crystal spitting an optimized binary vs Ruby being an interpreted language. Even if Crystal gets Active Record equivalent, the differences in speed would still be insane.
I like Go for deployment ease. Simply copy pasting a binary an running it feels like such a magic!
Well I am pretty sure an Optimised Ruby using raw other framework could be sub 10ms response, and may be pushing 1-2 ms response time as well. But because database access is the bottleneck, and how an ORM uses that database ultimately dictate its performance. 
Yes, for general apps out there, Rails is still the best choice as performance is not the issue for 90% of the servers.
Looks really good! I might be using this. The examples use ruby strings though, so that needs to be updated. Also might want to mention that you can just use `CLI.cli`. The examples using `include CLI` give me the impression that the `CLI` module injects macro gunk into my class, which isn't the case.
The rumour is ruby 3.0 will offer (try to) a compiled option... no details, just from Matz at Bath ruby this year. That and one other note, is all that made it to my notebook from a 2day conference... 
It looks nice, but why implement another test framework? `Spec` and `minitest.cr` are much more powerful and can easily get `TAP` format output.
Thanks! Will do.
Hey RX142, do you think the CLI namespace is okay? I wasn't sure where to put it. At first I had it at the toplevel namespace, but then thought better of it.
Should be fine.
Cool! It's nice to see a frequent cadence coming from the team now.
Could be for fun, learning, or practice. The community may not need another test utility, but the owner may enjoy writing them. Some people like building cars from scratch üòÖ
You should be seeing a new major release every two to three months, then a bugfix release (or two) a few weeks after.
I probably should read my own article to see how many typos I made üòÖ
It‚Äôs ok. I only caught one. Good write up though on the real world diffs between the two languages (spec suite, deployments, etc). 
Awesome! Really cool to see the language evolve like this 
Come to think of it, Go needs more HTTP routers... http://dayssincelastgohttprouter.com/
Unfortunately Crystal frameworks use too much Macro and error messages are really hard to understand sometimes, mainly because I got used to Elm error messages. I have a question, what db migration tool do you used?
Thanks! I went through and did a quick edit so hopefully I caught most of the typos üòÖ
It's worth noting that any web framework or library can get these exception pages with: https://github.com/crystal-loot/exception_page So feel free to use it. It's super easy! Check out these PRs: * https://github.com/luckyframework/lucky/pull/528/files * https://github.com/kemalcr/kemal/pull/466/files 
This is currently powering the exception pages for Lucky and Kemal. It's super easy to integrate with! The README has examples and here are some PRs * https://github.com/luckyframework/lucky/pull/528 * https://github.com/kemalcr/kemal/pull/466 Huge thanks to @faustinoaq and @rstacruz for their work on this
Thanks to you folks! I am getting really excited about the collaboration between web frameworks: [https://github.com/crystal-loot](https://github.com/crystal-loot)
Really? I am suprised not hearing it elsewhere. Just to clarify, you don't mean JIT (just-in-time compiler)?
Yes, my apologies for not being specific, it is the JIT option.
That's an excellent idea
Granite. It comes with Amber.
Would you mind showing your migrations codes?
Probably not. You would need to be able to install additional OS packages and run the binary or hook into fast-cgi, AFAIK this is not possible with GoDaddy. Similar question about go was posted [here](https://www.reddit.com/r/golang/comments/4vjhp4/does_golang_work_on_godaddy_basic_linux_web/) a while back.
If you can execute custom applications on your shared hosting, your should be able to run an amber app. I don't know if go daddy shared hosting provides that. But they also offer VPS and you can probably get a cheap cloud server anywhere else. You don't need sudo and you shouldn't need that for any web application. Unless you want to expose it directly to a public port, but it's usually a better idea to put a web server/reverse proxy like nginx in front of it. On shared hosting platforms, this is usually provided for you.
It's that ;) Thanks to you :D
Disclaimer: I wrote this This was inspired by [magefile](https://github.com/magefile/mage). Not intended to be a tool like Rake.
I just have one migration, which looks similar to what is prescribed here - https://docs.amberframework.org/amber/guides/models/granite/migrations
I already have a `cake` in my exec path, from coffeescript.
Hmm, maybe you can alias something else? Cake doesn‚Äôt come with an executable, it is simply an alias in your `.bash_profile` so it can be changed easily.
What if I have ssh access to the shared server, and can run executables?
Yah it's not a real "problem". I like the project.
Potentially, I wouldn't know without trying it.
Great name and logo. U design it?
Yes. Based of the Crystal logo.
I see this request sometimes and wonder why. You can get a cloud vps for $5/month 
Hi, I already running my amber project in a pretty old shared hosting (RedHat with Linux 2.6) I'll publish a tutorial of this :) Also, I'm using a jailshell to run it, is a bit hackish but it does work incredibly well, I tested it with wrk and is almost 3X faster than php. BTW, I'm using a shared PHP hosting because I was working in several PHP projects and I was wondering If i could execute amber is a low resource machine as well. https://i.imgur.com/BJoNgcT.png 
Awesome!!! Thank you! I'll add this to Amber as well :)
Indeed, My client has a 24$/year shared hosting and I'm using a PHP script to manage the amber app process :)
1. That's not async/await, it looks like futures 2. Futures are already in the std (but maybe they shouldn't): [https://github.com/crystal-lang/crystal/blob/master/src/concurrent/future.cr](https://github.com/crystal-lang/crystal/blob/master/src/concurrent/future.cr)
According to the author: &gt; don't use Crystal's Concurrent::Future class because :nodoc: I guess he is meaning this line: https://github.com/crystal-lang/crystal/blob/master/src/concurrent/future.cr#L1
i thought crystal was synchronous tho? looks cool i'll check it out
Freaking awesome, and this is coming from a WSL user! RX14 is a beast. Always helpful in chat (gitter) and on SO, etc. It's soo appreciated!
It implements CSP like in Go, which means implementing async/await on top of that is totally contrary to the philosphy of the language... async await really sucks because it makes you have twice the amount of code: [http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/](http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/)
It's because it's not ready to be used. Things will come with time, implementing stuff like this in shards right now is not the correct way to do it.
interesting, thanks ;)
I really see no usecase for this that spawn do end Can't achieve 
I'm not a finance expert, but they look like useful functions. One thing that I would change is to use BigDecimal instead of Floats. Using floats may yield unexpected results due to rounding issues. In crystal with divisions of bigdecimal, I noticed that you have to use the .div method with a precision level otherwise it will be really slow. price_a.div(price_b, 2) will use a 0.00 precision. 
Thanks mate, I shall look at BigDecimals
He did other nice posts on his blog: [Learning the Crystal langauge and Lucky web framework](https://perens.com/2018/04/19/learing-crystal-langauge-and-lucky-web-framework/) or [Dynamic Linking of Shared Libraries Doesn‚Äôt Make Sense for Modern Languages Like Crystal](https://perens.com/2018/07/01/dynamic-linking-of-shared-libraries-doesnt-make-sense-for-modern-languages-like-crystal/) respectively in april and july.
``` if a = @age a += 1 end ```
Use @age.not_nil! In the spot where you know it won't be nil. Though, in this case, could you just initialize with a default value of 0 or something? 
Thank you, assigning to a local variable first works.
Yes, his latest post: https://perens.com/2018/07/06/tiny-crystal-language-programs/ takes crystal off in a new direction where one normally only expects to find C. Very intriguing. 
In this case, yes a default value of 0 works. Good point to try to avoid Nils as much as possible. Sometimes it is unavoidable like the head and tail nodes of a linked list so I'll try to figure out the behavior of #not_nil!
This works? Shouldn‚Äôt this only change `a` and not `@age`?
 if a = @age @age = a + 1 end [https://carc.in/#/r/4gzy](https://carc.in/#/r/4gzy)
You can also refer to: - https://crystal-lang.org/api/0.23.0/Nil.html - https://crystal-lang.org/docs/syntax_and_semantics/if_varis_a.html
Actually, the second link doesn't explicitly refers to nil, and doing `if var`, I meant this link: https://crystal-lang.org/docs/syntax_and_semantics/if_var.html
Also ‚Äò@age.try &amp;.+=(1)‚Äô
Ugliness is in the eye of the beholder ;-) I don't think that code is ugly, but it's doing two seemingly unrelated things at the same time. So maybe: ``` st_from_site.each do |s| st_from_oldr.each do |ss| s.last_dump = ss.last_dump if s.name == ss.name &amp;&amp; s.id == ss.id end end stations.concat(st_from_site) ```
I don't think the code is ugly either. But maybe move some of that logic to separate functions? ``` def set_last_dump(s, ss) s.last_dump = ss.last_dump end def check_equality?(s, ss) s.name == ss.name &amp;&amp; s.id == ss.id end st_from_site.each do |s| st_from_oldr.each { |ss| set_last_dump(s, ss) if check_equality?(s, ss) } end ```
Thanks for your good ideas ;) I'm sad cause I can't use \`zip\` because the 2 arrays can haven't the same size.
Four spaces in front of each line will render the code in a code block style so it's easier for us to read
Thank you for the link. I think I was reading that page and trying some of the suggestions there but I missed "The above logic doesn‚Äôt work with *instance variables*, class variables and variables bound in a closure". I guess I gave up to early :)
Thanks, I'll experiment with that.
But `zip` traverses booth array in tandem. What you want is [Array#product](https://crystal-lang.org/api/0.25.1/Array.html#product%28enumerable%3AEnumerable%2C%26block%29-instance-method): https://play.crystal-lang.org/#/r/4h5c In your case: ``` st_from_site.product(st_from_oldr) do |s, ss| s.last_dump = ss.last_dump if s.name == ss.name &amp;&amp; s.id == ss.id end stations.concat(st_from_site) ``` 
Impressive work!
There is a great existing project called SushiCoin that's using Crystal. It's great to see people discovering new ways to put this beautiful language to use.
how this is works?
syscal shm: [https://github.com/tbrand/iemon/blob/master/src/lib\_shm.cr](https://github.com/tbrand/iemon/blob/master/src/lib_shm.cr)
In case you didn't know, there is also `property!` https://crystal-lang.org/api/0.25.1/Object.html#property!(*names)-macro that comes handy on lazy initialized properties. But I encourage to avoid lazy initialized properties when possible.
From reading the README, it looks very cool! I'm going to start using this in my Crystal projects rather than a Makefile. Not every system has Make on it, so that's nice to have. 
Thank you, I'll experiment with it.
Implement it yourself then
Take a look at shards at https://crystalshards.xyz/?filter=Aws it would be very nice to have a great AWS shard
Other AWS sdks are huge. This would be an INSANE amount of work for one person.
There was a discussion about this here: https://github.com/crystal-community/crystal-libraries-needed/issues/31
Implement just what you need leaving a space for further development. Take Ruby code as starting point...
I've looked at the ruby code in the past. From what I remember it dynamically creates modules and functions based on versioned hash objects. Crazy dynamic stuff. I remember thinking at the time it might be easier looking at another statically typed languages implementation.
I don't think this is really something to blame the Crystal team for. Installing the GPG key should work as described, I'm not sure why you're missing \`dirmngr\` but \`sudo apt install dirmngr\` should to the trick. Maybe this could be noted in the installation instructions, but I'm not sure if this is a common problem. Anyways, just googling for the error message might have saved you some effort. The other error happened because you skipped the second step of the installation instructions, adding the Crystal dist server to your apt sources. The command for this is stated in the guide: echo "deb https://dist.crystal-lang.org/apt crystal main" | sudo tee /etc/apt/sources.list.d/crystal.list
I don't blame the team. Like I said, I was frustrated when I wrote this. Sorry about the tone, wasn't my intention to flame someone, i just wanted to blow off some steam and potentially provide a solution if anyone else has that issue. I did do everything in the guide, including the line you quote. Here is a complete log of everything I did (it's very long so might be hard to navigate): [https://gist.github.com/simenge/476ba065467340a93461482d8ef5e5e1](https://gist.github.com/simenge/476ba065467340a93461482d8ef5e5e1)
The issue with \` apt-key adv \` is actually a bug in WSL: [https://github.com/Microsoft/WSL/issues/3286](https://github.com/Microsoft/WSL/issues/3286)
That actually makes me feel a bit better. Maybe I'm not a complete idiot here.
Odd. Been using Crystal on WSL for 6++months and a linux noobie myself (never had this issue). Probably a bug with WSL, am sorry
It is: [https://github.com/Microsoft/WSL/issues/3286](https://github.com/Microsoft/WSL/issues/3286) Apparently it works on older versions of ubuntu. But there are workarounds
After looking how: [https://crystal-lang.org/api/0.25.1/JSON/Serializable.html](https://crystal-lang.org/api/0.25.1/JSON/Serializable.html) does it, maybe having each attr as either union type with nil or a default value isn't so bad? \`\`\` property foo : String? property bar : String = "default" \`\`\` 
Any cool applications using this?
 sudo echo "deb https://dist.crystal-lang.org/apt crystal main" &gt; /etc/apt/sources.list.d/crystal.list -bash: /etc/apt/sources.list.d/crystal.list: Permission denied Just in case you were wondering: your shell is what handles things like redirects (the `&gt;`). In this command, you're basically running *just* echo as sudo, then your shell (which is running as your normal user of course) tries to save the result of that to the file. 
I installed Crystal last night, for the first time, on a native Ubuntu desktop. Everything worked without a hitch.
The issue is apparently with the latest version of Ubuntu in the Windows store. Did you get that? There is a documented bug in WSL mentioned elsewhere in this thread that affects at least Ubuntu 18.04 on WSL.
Yeah the Ruby SDK dynamically generates the code from the AWS API documentation. Impressive stuff, but not very readable. I'm not sure any of the other official SDKs would be "better" though...
I'm not using Windows at all. I'm booting directly into a virgin copy of Ubuntu 18, where the Crystal installation works great. This would suggest that the problem is with WSL, and as you mention, that does seem to be the case.
wow.. awesome!
 Sitemap is like an indoor map of a shopping mall. Every butique, restaurant or services are single items and all the goods or services offered in each of them - content (IA). Creating a sitemap starts with identifying the entry point, in this case it could be a home page or a login page. Then you can add pages with categories and sub-categories. Instead of creating your sitemap from scratch you can use an existing website as a template. To do so I would recommend trying Slickplan, they offer a fully functional free trial. 
I love the --static option. Makes it super easy to just upload my executable to my vps server, and then do `./test` don't have to worry about installing crystal, dragging the lib folders, etc. 
FWIW I believe this can still break because it's impossible to 100% statically link glibc. 
I usually just install crystal on my server and build with --release then upload. True static compilation is fairly unlikely unless you have the resource that Google had while building Go (basically from the ground up)
I don‚Äôt think there is enough adoption for that yet. 
Adoption for Ruby, by the sounds of it came from Rails, with Flutter from Google, Dart has taken a massive jump in popularity, Swift only because of iOS, Go has "The server". If Crystal is a compiled language similar to Go, then maybe "The Server, but with less code" might be it. But Crystal for sure needs something, one of these frameworks could really help with the adoption, two main frameworks, doesn't. Just means people get confused until one wins. Merge? Have a vote? I'm not sure about that one. 
FWIW, I‚Äôve taken a look at both and Amber feels like it‚Äôs got a bit more momentum / activity. Honestly though I think there‚Äôs room for multiple frameworks here, even operating on the same layer/level. 
Yep, certainly feels like Amber has more contributors, followers, stars etc at this point in time. 
The only thing Crystal needs is a 1.0 type stable release with huge breaking changes behind them. The frameworks after that will take care of themselves and the ecosystem will feel free to grow. I don't think its necessary at this point to pick the one framework that will dominate. IMO Its not a good thing to lock into just one at this stage. I think Elixir/phoenix is hurting Elixir. If you don't like phoenix (which I don't) then theres nothing else. A lot of people talk about it but I still don't see the world rushing to Phoenix. Even with all the talk I don't see much being made with it. A good amount of people haven't liked the "magic" in rails and left Ruby because there was little other choice. Choice is good not bad. But to answer your question if I had to choose it would be Amber. For obvious reasons the people who most will be ramping up Crystal use will be Ruby developers and Amber takes much less than an hour (probably less than 20 minutes) to wrap your head around as a Rails developer. However like Lucky too so truth is if we were going full steam ahead right now with Crystal we'd be getting to know both.
Great answer, Go has been such a success because of it's focus on servers, compilation, compile times, then people started building API's and the frameworks never stuck. I wonder if Crystal will find it's niche in Microservices, API's, serverless, compiled packages and frameworks will just be a 'thing' that Crystal has. 
Nim does this as well but it is a different beast.
Lucky is also much newer
If Manas pulls it off Crystal's nich will be the fastest best performant language with a near drop down easily readable syntax of any present language - like ruby meets C# Thats a pretty good niche by itself.
The good thing is, because of Crystal's type checking, the compiler will tell you when a variable type doesn't fit. Yes, it might sometimes be confusing to keep track of type changes. But it it can be really useful if used wisely. And it's perfectly safe to do because of type safety. A use case is for example transforming the same value to different data types. It wouldn't necessarily make sense to be forced to use different variable names for this: number = "1" number = number.to_i You can however, enforce a type on a local variable and assigning a different type will fail: number : String number = "1" number = number.to_i # type must be String, not (Int32 | String)
There is nothing wrong with that program at runtime, so it's sound/make sense to allow it. Types aim to differentiate which programs make sense (ie: are able to run) with respect to the ones that don't. Making a variable have a fixed type is something convenient for some compilers. A scenario were I've see a variable changing it's type is when an argument needs to be converted or transformed and the old value can be discarded. ``` def foo(a) a = a.to_s # do something with a now that is a String. # ... end ``` I fail to see how this can be a bug facilitator. If the types does not match the compiler will complain before there could be a bug. If the types end up making sense, is again, because the program make sense in runtime. It could be a bug, definitely, but it will be a semantic one probably.
I am a fan of types so I went with Lucky and I am not regretting it. In fact, I have now two projects written with it. Also, Amber and Lucky developers are *starting* to work together to improve both frameworks, so my guess at this point in time is that going with either Lucky or Amber is a good choice. Collaboration is great: [https://github.com/crystal-loot](https://github.com/crystal-loot)
Can you tell me the main differences between the two? I like Lucky's docs and the backing of Thoughtbot. 
&gt; FWIW I believe this can still break because it's impossible to 100% statically link glibc. not sure. I'm compiling my game server that has tons of libs (listed [here](https://i.gyazo.com/dde1acb14cebc6a707abe4a060bd03ce.png)). i compile on my WSL i7 2600 home computer with --static, then just drop it into the cheap $2 VPS. works flawlessly, never had an issue
Coming from me it wouldn't be a fair comparison since I haven't work much with Amber. Lucky enough, developers are working on it: [https://github.com/crystal-loot/web-framework-comparison/issues/1](https://github.com/crystal-loot/web-framework-comparison/issues/1).
I think this is a great question. TL;DR Lucky is hyper-focused on preventing bugs at compile time and designing applications that can quickly be changed without worrying about breaking things all the time. The Amber and Lucky teams are working on a comparison document. You can see the initial issue here with some example code: https://github.com/crystal-loot/web-framework-comparison/issues/1 but a more thorough document is still in the works. I think momentum is similar in both projects. There are more articles and stars for Amber but it has also been around 2x longer. Lucky was announced just last November so that accounts for some of it. For me the main reason to choose Lucky is if you want the prevent bugs, have easier debugging and easier maintenance in the future. Why is that? Well some of that is addressed https://github.com/crystal-loot/web-framework-comparison/issues/1 but I'll try to go into a bit more depth here: Things Lucky will catch at compile-time that Amber and others do not: * Calls to missing routes (I believe the Amber is working on adding this) * Catch missing or incorrect parameters passed to routes * Catch missing or incorrect calls to parameters inside controllers * Missing or misspelled column names in html forms * Missing or misspelled column names in database queries * Catch trying to submit a field in an HTML form that is not allowed to be saved (basically compile-time checks for Rails strong params) * Compile-time checks for email to, from, and body. If one is missing you'll know at compile-time * Catch accidentally printing `nil` in HTML. I believe all other templating solutions will print a blank string instead There is more to it than this, but it illustrates the focus Lucky has on preventing bugs, minimizing need for testing every tiny detail, and helping users debug when something is wrong by pointing to the exact spot in the code that is causing issues. Lucky also has some unique approaches to saving data, querying data and rendering HTML. It is a bit different but that is also why Lucky is so good at catching bugs. For example, a lot of what Lucky does would not be possible if it weren't for separate classes for each HTTP action, form and query. I can elaborate more if people are interested, but to me, this is the big difference.
As dev0ourer mentioning it is important to note that Lucky came out much later. Lucky development is also split across a lot of different repos which makes it hard to track activity. The focus changes between releases so some repos get more commits than others depending on the priorities :) With that said, I do think Amber is more well-know and has more articles. Things are improving as more people are using Lucky in production though
Some of the issues are mentioned [here](https://news.ycombinator.com/item?id=9317211), but basically anything loaded at runtime (e.g. name resolution libraries) cannot be linked statically, and if the C library on the system it's compiled on is *newer* than the target system, you're going to be in for a very bad day. You likely lucked out because both Debian and the Ubuntu versions that WSL uses are LTS distros.
really nice!
interesting, thanks for the info. good dev setup then haha. infact, i've been loving debian so i'm happy 
Does your approach add to the complexity of building an app? Or do you believe it decreases complexity and programmer hours? Elm is a perfect example of excellent bug reports, so if that's your aim, it's a good aim. Thank-you for all your hard work on Lucky and i'm rooting for you for it to be a success!
I'm a bit biased, but I do think it makes it simpler. You don't need to worry so much about breaking things, and when you do the compiler helps to find where the issue is. To get type-safety like this, it also forces you to write smaller classes, which I think are easier to read, maintain, and test. I think Amber is easier to pick up if you are familiar with Rails/Phoenix, but Lucky is not far behind. I think the initial investment is worth it so you can leverage the powerful type system in Crystal to its fullest. I'd say the hardest part of Lucky is getting used to rendering HTML pages with Crystal. The benefit is that you can have a lot of power at your disposal and you prevent more errors. I think it is worth investing a bit of time to learn it, and then saving lots of time later by having a lot of easy to maintain code, but this depends a lot on what kind of apps you want to build and how long you expect them to be around. I hope that helps!
Is it fair to say that an easy comparison would be, Lucky forces Types all the time to be able to alleviate more errors at run time and Amber is Type optional? It depends if you're a Types person or not in the end. But Amber has the choice? 
I'd say "force" isn't quite right. It isn't really any harder to use, Lucky just makes it easier. For example, here's how you link to an action: link "All Users", Users::Index.with(page: 1) It isn't hard to use IMO, but because of the way the link helper and action are designed Lucky ensures that the route exists, all required params are given, and that the correct HTTP method (get, post, delete, etc) is used. The user doesn't need to do anything, they just get that for free. So if anything it is easier because of it's design. I'd say with Amber there are things you can't do with types because of the way the objects are structured. For example, here is an action in Lucky: ``` class Users::Show &lt; BrowserAction # defines a route for "/users/:id" # Defines a method for every param, so in this case, Lucky defines an "id" method to access the param in a type-safe way route do text UserQuery.find(id) end end ``` Lucky will infer the route is "/users/:id" because it is a "Show" action. Because this is all done in one class for one action, and because the route is defined in the action, Lucky knows that this action *always* has an `id` param. So it creates an `id` method for you that is never `nil`. If you mistype that or use a param that doesn't exist, Lucky will let you know at compile time Most frameworks do something like this: `params[:id]`. That can't be caught at compile-time. It seems small, but it can bite you, especially as you start adding query params and using nested resources. It is impossible to do this in a truly safe way if you have more than one action per controller: ``` class UsersController &lt; ApplicationController def index p id end def show p id end end ``` `id` should be present for "show" but should be `nil` in "index". There's no way for the compiler to know when it should or should not be `nil` when using multiple actions per controller. So you would have to either make the type `Int32 | Nil` and call `not_nil!` or do what most frameworks do and have you access the params in an unsafe way with `params[:id]` This is one reason Lucky has one class per action. Does that make sense? Another example is with queries: ``` UserQuery.new .age.gt(18) .last_name.desc_order .first_name.ilike("%Pa") ``` You get a type-safe query builder. If you mistype a column or pass a string to an int then it'll be caught at compile-time, and as you can see there is no extra ceremony here. You get it pretty much for free in Lucky
Awesome, thanks for the detailed answer!
Thanks! let me know if you have any questions/issues/suggestions!
A lot of people is coming from Ruby to Crystal due to performance issues, so I think it would be good to see a benchmark for Lucky. If nobody else is working on that, I will add Lucky to Techempower benchmarks in order to have some approximate numbers 
That would be really helpful.
I don't have a benchmark handy, but a company is testing Lucky and will be moving it to production soon. You can see the chat here: https://gitter.im/luckyframework/Lobby?at=5b4d25fa7844da435c3364f8 and here https://gitter.im/luckyframework/Lobby?at=5b4fb5618fe2780689c20a4e I don't know if Lucky is the fastest Crystal framework, but it's definitely fast :)
This is great! I'll try to find use cases for GCFs now that I can easily use crystal :)
Yeah the idea is anything that is expensive and should be offloaded from your web server. Image transformations, heavy processing, PDF conversions, that sort of thing.
Looks awesome. Would you be able to do some benchmarks of the overhead of this? I'm assuming that GCF calls a Node.js function that executes the binary?
Yeah i can see when it would make sense. I see Crystal is a powerfull/flexible language. But with power comes responsability :) Keep up the good work! I look forward to test Crystal when i get the chance.
Yeah, modern languages are all about flexibility and performance at the same time. Looking forward for Crystal. I like its sintax. 
in my opinion crystal need better tools, for instance go has several tool that works like service, so you can connect these to any editor (vscode,sublime,emacs,vim) and provide auto completion,go to definition documentation, auto imports,etc...this is pretty nice and right now working with crystal seems to be more cumbersome yes, there is some tools like scry, cracker, but seems not have active development and they're more like a proof of concept that a working tool (I'm using visual studio code and emacs and the autocomplete doesnt work for me) this is not a criticism, we must understand that crystal is a young language and many of great collaborators doesnt work full time with it, so obviously it 'll take more time to develop robust tools, but I think that when crystal has nice tools like go its adoption will be faster...best regards...
BTW you can view the source code at: https://github.com/paulcsmith/crystal-mastery
This is so awesome! Thank you for this &lt;3
Awesome!
That's correct. I've done some stress testing, nothing super formal, but I'm seeing the same times for a plain node.js function that returns a value, and the same function written in crystal, so the overhead is probably negligible. This is probably helped by the fact that GCF runs in a memory-mapped file system, so fs calls are technically memory operations instead of io operations.
Crystal isn't just a young language. Its in beta so to speak. No way it can be compared to beta and no language still in development has tools. No way anyone should be comparing it to Go or any fully released language.
Looks promising. Great stuff as usual RX14
It would be nice to be able to do ‚ÄòNote.from_re(rs)‚Äô and ‚ÄòArray(Node).from_rs(rs)‚Äô
This article looks amazing! I should read it. 
Thanks so much for this, please focus on content for absolute beginners, or beginner learners, as most Ruby developers will have an easy grasp on figuring out Crystal already. 
Please keep up with the tuts on Lucky! Doing gods work.
Haha thanks! I plan on writing another one soon. I have a draft of another post I need to finish. I appreciate you reading :)
Good idea, I have added that now. Looks like what you had in mind?
The numbers seems a bit off, did you... * ... compile the Crystal programs with `--release`? * ... spawn threads in proportion to how many CPUs you have? * ... configure the same database for every framework? If you didn't, it would obviously be favored to Phoenix. Not allowing the crystal compiler and LLVM to apply optimizations and only run on a single core vs Erlang VM' scheduler of processes across multiple OS threads.
1. Didn't realise you could compile the framework to a executable file. How would i do that? I can rerun them. 2. Ran each one with what was recommended for my CPU based on what others noted. 3. Each one ran it's own Postgres database. 
I dont think `SO_REUSEPORT` works correctly on mac, and will be hard to test multi processing. This test should really be done on linux.
1. crystal build program.cr --release Then. /program
ok :)
Just pushed a better readme and alternative syntax using from\_rs on your object
Yep, looks good. Thanks üôè 
The lucky one is also bad because it looks like you‚Äôre running it in dev, which goes through Browsersync. That will cause a massive slowdown since it proxies every single request. You can instead do: crystal build ‚Äîrelease src/server.cr Then: ./server.cr That‚Äôll run it in production mode and will tell you what port to hit
Also, thanks for running this :) it‚Äôs always fun to see how well stuff performs. 
but why you need JSON::Serializable? you can write you initializer similar.
Thanks for that, just coming into Crystal as a total beginner.
I'm sure i did something wrong, Lucky was timing out a lot after the 1000 mark. I will try do another test with your recommendations within the next few days.
That is true, but all it would do is mimic the functionality so it doesn't seem worth reinventing the wheel to say. Using JSON::Serializable also allows the library to take advantage of it's other features here: [https://crystal-lang.org/api/0.25.1/JSON/Serializable.html](https://crystal-lang.org/api/0.25.1/JSON/Serializable.html)
I nominate the OP :)
Thanks for your time writing this article and benchmarks, Crystal compilation times issue is kind of well known but this "real usage" scenario brings more attention to this big problem. I hope Crystal to achieve real gains in this subject not too far in the future.
nice clickbaity title. Partial or iterative compilation would definitely speed up development, and Amber could go a ways into using some different mechanisms to make compile times much faster. 
doing the same test (100 scaffolded models) but compiling with the `--release` took 17 minutes for me :(
It's not clickbaity it just shows immaturity of Crystal and its ecosystem. Crystal desperately needs more qualified developers that can fix issues at their core atm. 
I understand the article's points, but Elixir is an absolutely terrible comparison point. The reason its compile times are so fast is because it's just compiling to bytecode, whereas Crystal compiles to LLVM which is then optimized, compiled to assembler, and linked together. A more accurate comparison would have been to maybe Swift or Rust (which also use LLVM). 
It's not about qualified developers. I believe it's a problem without a solution. If Crystal is useful to as it is, you use it. Otherwise, choose another language. 
That‚Äôs not to mention that the deployment story has so far to go with Elixir
LLVM isn't the bottleneck. Codegen is reasonably fast. It's the semantic stage in the compiler that requires a lot of time and space to calculate.
We don't have enough context from the author but we can imply that they are evaluating web frameworks in Ruby, Elixir and Crystal. From this point of view, the comparison makes sense, even though implementation wise they are very different technologies.
There are valid points about issues in Crystal's compiler. Unfortunately, the only a single Crystal web app framework (Amber) is benchmarked without considering limitations of the framework. It just claims to show an exhibit of the languages's slow compilation time. This is hardly an honest evaluation of the Crystal compiler itself, but rather just comparing Amber with Phoenix and Rails regarding time to launch an application.
Development time, compilation time, execution speed... Something has to give, doesn't it? If the compiler has to do things you'd rather not do yourself I think it's to be expected that it will take longer to compile than one that needs every little thing explained to it in excruciating detail. I have a complex application (a mmorpg server) that I've been writing in Ruby and Crystal in parallel since 2015. Killing and reviving an enemy 3000 times in a row (literally 3000.times { ... }) and all that it involves (item drops, experience gain for the killer, scheduling and then aborting the respawn of that enemy, writing all the packets involved...) takes 100 seconds in Ruby and 3-4 in Crystal (without --release). That difference alone makes waiting for compilation worth it in my opinion.
AFAIK the Elixir team has started working on making "releases" part of the language itself.
The article also included the times to compile the Crystal compiler, the time to compile dependencies and also the times for a new Lucky application (which was slower than Amber).
&gt; If you don't like phoenix (which I don't) then theres nothing else. What is wrong with using Plug and Plug.Router then? It gives something very close to Sinatra. The web part of Phoenix is mostly a wrapper around Plug.
They have, they added the guy who built the two previous release tools. I should say I am hugely excited for what they're going to do, I'm a big Elixir fan. It was just that I also found Elixir to be a really poor comparison.
This programming language really needs incremental compilation!
I don't think I understand this response - is this to say that Crystal has no usefulness in larger MVC applications, and to use a different language for this purpose?
And probably the memory usage is huge too
&gt; 30 seconds is a relatively long time for 50k LOC LOC is a terrible metric. I was actually super impressed by how fast the compiler compiles itself in debug mode.
It is. You did a lot of amazing work but you are no expert in everything. You said it yourself that you have a hard time fixing some of the compiler bugs that are just piling up. To me that is a sign of a worrying issue that the lang needs more qualified developers that are experts in different areas.
--progress would be helpful to see :) I haven't had an issue with the compile times. I'll take it for dynamic typing in a compiled language with syntax I actually enjoy. 
It depends on the app and how long are you willing to wait. 
Yes, and these times either don't tell much or don't support the argument: 30 seconds for the compiler might be long in comparison, but it's als quite complex piece of software and 30 seconds shouldn't really bother anyone. An empty Lucky projects compiles in half a minute, and subsequent compilations rank at 5 seconds. These results simply don't attest a compilation issue.
What a cool experiment to have such a large project written in two languages. If love to hear more about the differences in development and performance you found along the way. &gt; Explained to it in excruciating detail Reminds me of Go. Great language with amazing compile times, but be ready to be very explicit.
&gt; It is. You did a lot of amazing work but you are no expert in everything. he's not saying he's an expert in everything sir, please have more respect towards lead devs
Why would it be unfair ? I am not bashing anyone for lack of skills. I am just pointing out that asterite cant handle all of the complex problems alone. 
50k lines of code, 1 minute?
There is a lot of truth to this, but I don't think it is as big of an issue as the author states for a few reasons: Ruby of course does zero type-checking at compile time, and Elixir does very very little. It'll catch some stuff like typed function names, but not much else. This is an \*extremely\* important difference. I had plenty of bugs in Elixir so what do you have to do? Write tests. Lots of them, just like in Ruby. Those test suites take a long time, can become brittle, and most importantly take \*a lot longer than 30 seconds to write\*. This is the key difference for me. Crystal compilation is slow, but I'll trade it any day so that I can have a solid system. Another thing is that if you write well typed programs that the compiler can check, you end up writing far-fewer tests and debugging speeds up substantially. This saves a lot of time, and changes how I write code. I know write larger pieces of code before running specs or testing in the browser, and then let the compiler show me the bits the broke. It is a dramatically faster workflow, that is only possible with powerful type-checking. One more important fact, while Lucky is slower than Amber at initial compile, but \*much\* faster once you start adding code. Scaffolding CRUD models takes about 50 seconds w/o cache and 30 with. This gives me hope that it is not Crystal and I'm positive the talented Amber team can figure out the bottlenecks and get their compilation down.
&gt;8 minutes ago This isn't to say I wouldn't love faster compilation :) But even w/o it, using Crystal has some distinct advantages that make the compile times worth it for many types of programs
The compilation speed affects designers more than developers (depending on your workflow of course). But for the way we build things at my company compile time hasn't been a big issue for devs, but it \*can\* be a pain for designers. Making a change to the HTML and waiting for 10 or 20 seconds sucks. If you use React/Vue though then you're at the mercy of webpack, which may or may not be any faster. It's definitely faster to make changes to HTML in Rails/Phoenix though
I think you are missing the point of that section. If compiling a fresh Amber project with dependencies take 25 seconds and a compilation with cached dependencies take 5 seconds, you can estimate the compilation of the dependencies themselves, which are around 44k LOC, is roughly between 20-25 seconds. That is inline with the time taken to compile the compiler (with ~50k LOC). Also, aren't you just skirting around the problem? If compiling Amber/Lucky apps are slow because of meta-programming and if compiling the compiler is slow because of complexity, what are you proposing? That we should be wary of writing complex applications? How is that different from the article's conclusion? If your point is that the examples used by the author are outliers, can you provide examples that you believe would better reflect average compilation times? Was the author just terribly unlucky that all examples he picked pointed to the same problem?
A type system can catch a whole category of bugs but it doesn't replace the huge majority of the tests I have in my applications. So I think focusing on a type system as a replacement for tests is misleading at best because **the tests you should be writing on all of those languages should be roughly the same**. Trivial mistakes like off by one errors and returning true where you should return false will not be caught by a type system and if you don't write tests, they will only be caught in production. However, I can attest that types lead to a better development workflow, because you catch many mistakes earlier. Types are great for documentation, they can be used as a design tool and they help with performance too. But they definitely do not replace tests, not even close. &gt; One more important note, while Lucky is slower than Amber at initial compile, but *much* faster once you start adding code. Scaffolding CRUD models takes about 50 seconds w/o cache and 30s with. Would you mind sharing the commands you used to scaffold the application? I am trying to put those benchmarks in a repository, hopefully comparing more languages, and I would like to include Lucky.
I don't think this is *necessarily* true. There are lots of things that a well-typed program will catch that you may not even think to write a test for. I'm thinking particularly about \`nil\`. A huge portion of bugs result from that. I also think that it depends heavily on *how* you use the type system. I see a lot of code in Elm/Crystal being written in a way where the compiler can't catch much. If you take the time to write out more types and use methods instead of passing around strings and symbols you can have a system where the compiler catches a ton of stuff you would miss and you need fewer "low-level" specs. You can see some examples of what I mean here: [https://www.reddit.com/r/crystal\_programming/comments/8zthzl/amber\_vs\_lucky/e2mqbx8/](https://www.reddit.com/r/crystal_programming/comments/8zthzl/amber_vs_lucky/e2mqbx8/) A conversation with a simple script for generating a bunch of CRUD actions [https://gitter.im/luckyframework/Lobby?at=5b59c314db8bd24550b3d476](https://gitter.im/luckyframework/Lobby?at=5b59c314db8bd24550b3d476)
But that's only an issue if templates need to be compiled into the binary. If you use runtime-templates, that makes development much faster. Neither is necessarily better, but it's an option. As long as the templates don't use any fancy features (they should be pretty dull on the logic side, anyway), it could be worth to explore if a template engine can compile templates for release builds but interpret them in development.
This is true, but I think you'd lose out on a lot of the type-safety. For example, you might mistype or miss a variable. You might pass the wrong type, etc. Definitely an option if compilation speed is an issue, but I don't think I'd make that tradeoff. I love my some type-safety :)
Amber's architecture is unknown to me, so I can't tell anything if the results are outliers or if there might perhaps be simple improvements. The thing is: Neither does the author nor most people commenting here. It's just an assumption that the conducted tests represent the compilation time of a somewhat large real-world application using Amber. But without knowing and considering the details of the framework, such a benchmark simply doesn't tell much. There might be simple changes that could dramatically improve compilation time without invalidating the scenario. This wouldn't be a surprise, after all both the framework as well as the language are still in development. I don't try to reject the assessment that Crystal compilation times are high - and maybe to high for complex software (although there are always other aspects to consider). Everyone involved in working on Crystal knows that. The point is that the empirical examination conducted in this article does not sufficiently demonstrate what it claims to do.
There will be missing libs and you‚Äôll have to implement them yourself. Consider using Ruby for your first production project instead because its ecosystem is much bigger. Otherwise, if you have plenty of time and can afford not to stick to the time plan, use Crystal
Also it‚Äôs a good idea to avoid Rails and do Sinatra, Sequel and Roda instead. Or Hanami
Why are you focusing on Amber? The issue was also shown: 1. when compiling Amber's dependencies (which does not take Amber's architecture into account) 2. when compiling the dependencies of another web framework 3. on the compiler itself You said &gt; I don't try to reject the assessment that Crystal compilation times are high - and maybe to high for complex software and then &gt; The point is that the empirical examination conducted in this article does not sufficiently demonstrate what it claims to do. To me the main claim in the article is that compilation times are high. You say that everyone working on Crystal knows that. Now I am not even sure on what we are disagreeing on. ':) In any case, you can't disagree with the data. Was the author unlucky to only pick outliers? Can you provide examples that you believe would better reflect average compilation times?
Judging by the vague project specification OP delivered, it sounds to me like Crystal already has all the libs the project needs. Are there any specific libs you've found missing other than drivers for the endless stream of "odd" databases for a project like this?
Isn't `nil`mostly a self-inflected harm though? A lot of the issues with `nil` could be solved by simply not passing `nil` around in the first place. Ruby is a very `nil` driven language. Ruby can't change this, but both Elixir and Crystal have the opportunity to. There are plenty of alternatives to `nil`, especially on typed languages. Thank you for the links above. 
I think passing it around is definitely part of it, but it can still happen in Elixir and Ruby. I think the problem is the idea of a "missing" thing or "nothing". So in Ruby you might use a Null Object pattern and return a `User` or `Guest`, but if I come into the code later, I may not realize that a particular piece of code returns a `Guest` and I might call a method on it that `User` implements, but someone forgot to implement in `Guest`. Since I didn't know, I didn't test it. I ship the feature and get a bug. In Elixir or Ruby that would not be caught, in Crystal it would. You probably already know, but in Elixir you see a lot of tagged tuples, but it's not always clear what the return so you can still get into the same trouble where you call something on nil/an-unexpected-return-value I definitely agree that types do not replace tests, but I do think they can replace certain *types* of tests. 
I'd say choose the one you like if you don't have a lot of risk and have time to learn it. The reason I say that is that you need to love what you're doing if you're learning on your own. I started programming and tried some more "common" languages and hated them. I quickly stopped. Once I found Rails I \*loved\* it and chose it. Luckily it worked out, but even if it didn't, I would have been glad because it was enjoyable enough that I stuck through and actually learned something :) The things you learn learning Crystal will be applicable to other languages if you decide to move from Hobby -&gt; Professional at some point anyway! So if you love Crystal, give it a go! Just know that like other said, you may not have the same tutorials and external libraries to choose from. Lots of people are happy to help. Feel free to pop in to [https://gitter.im/luckyframework/Lobby](https://gitter.im/luckyframework/Lobby) if you decide to use Lucky. Always happy to help a fellow programmer :)
For example, job processing other than paid Sidekiq; nicely working attachments solution
&gt; You probably already know, but in Elixir you see a lot of tagged tuples, but it's not always clear what the return so you can still get into the same trouble where you call something on nil/an-unexpected-return-value Tagged tuples in Elixir at least forces you to pattern match on the success case OR write a `case` expression. So you are either assuming only one value is possible or you have to handle all of them. In one way or the other, you have to unwrap the value. The type system can still help in two ways though: 1. Let you know if you are trying to match on a format that won't ever be returned 2. With an exhaustiveness check. Although exhaustiveness checks also have their annoyance, like forcing you to handle all clauses explicitly In any case, I am not arguing against a type system. Just against `nil`.
My guess is that the argument isn‚Äôt so much that it‚Äôs high (it is) but that it is an ‚Äúissue‚Äù For what I build it‚Äôs not an issue. It would be nice if it were faster, but not immediately necessary 
If it is an issue or not will obviously depend on the person. If the author found it is an issue for him, I don't think there is much we can do about it besides providing counter-examples.
&gt;I am now considering starting a web application project that would actually go online. This web app is not so simple as its contents will be user-created. Sounds like a basic CRUD app. If so here is no reason not to use Crystal except that most ideas evolve and with Crystal you more likely to run itno a situation where you have to build something from scratch because of a smaller ecosystem. With Ruby you are going to have a gem available - so also with javascript npm pacakage 
The amber benchmark is the main point of the article. And compiling the compiler and an empty Lucky take 30 seconds. That's imho still acceptable and doesn't say anything about large web applications. It's probably going to be slower, but who knows by how much? I don't disagree with the data, I disagree with the meaning that is put into them. The benchmark results are not valid to confirm the claims, but the claims are still true.
I could drone on forever about this but I'll restrain myself. In favor of Crystal: * Reading XML files at startup (and it has to read thousands) is much faster and the interface is similar to REXML/Nokogiri. The difference in speed almost makes up for the time it takes for it to compile. * The data that holds the knowledge of the boundaries of the world (preventing characters from walking/attacking through walls/rocks/trees) is loaded into memory from files that are almost 1 gb in total. In Ruby I had to create my own data structures with FFI pointers because using arrays or binary strings put the memory usage of the process to 10+ gb. Crystal already has such structures (slices) in its stdlib and better implemented. The process of reading the files and converting them to usable objects of the language at startup is also faster (~1 minute in Ruby vs. ~10 seconds (without --release) or ~3 seconds (with --release) in Crystal) as is, of course, actually using them at runtime. * I just don't know how to write integration tests for the server. There are too many things I can't fake without essentially writing a bot and have it play the game. The checks that the compiler performs catch most mistakes, especially when I rewrite something that could break some obscure path of code somewhere. In favor of Ruby: * The approach to networking is more up to you. Crystal gives you a blocking IO interface that you have to deal with using fibers and sometimes it's just not what you want. That's the most significant difference between the two versions of the server. * Being able to eval from inside the game and query the state of anything in the running program is a boon when things are not working as expected. * Although without the compiler checking things for me there are more mistakes, I can often reload the offending file without even leaving the game and having to restart the server. It's hard to choose and it's a good thing that it is. That's why I don't and use both.
&gt; That's imho still acceptable and doesn't say anything about large web applications. Of course it does say something. Even if you discard the Amber benchmarks, with the other results, you can at least expect a linear growth (although global inference is going to be worse than that). Meta-programming just makes it worse. Sometime ago the Go community was slightly up in arms because a project with 700k LOC was taking 100 seconds to compile. They brought it back to 80 seconds in recent releases. If you still believe 20 seconds for 40k and 30 seconds for 50k is still acceptable, it is clear we won't agree on this. So I'm happy to agree on disagreeing. 
I have a work project going in to production. It's not an easy route, and we could have chosen something more stable, or better developed, but where's the fun in that? It's been a lot of fun submitting so many PRs to projects, and being on the ground floor watching this evolve. Make a prototype in crystal, evaluate how hard it is and how far you get. If you don't like it, try something else. Just like trying a new recipe when cooking. It might not turn out, but you learn a thing or two. 
Can you elaborate why avoiding Rails is a good idea? 
"if all you have is a hammer, everything looks like a nail." Rails is not always the answer to every problem. It's overkill for most people's projects. I've found that Sinatra was enough for the simple web apps I've deployed. Rails would have been like using an articulated bus to drive my nephew to the store for ice cream.
One of the most pleasurable things in using Ruby as opposed to Crystal is you can use byebug or pry for debugging. With Crystal, the theory is that you won't have as many bugs because of the static typing. When things go wrong in Crystal, you'll be stuck with using `puts` to log values. As a novice, and as a more experienced programmer, solid debugging tools are invaluable. 
This is incredibly cool! Nice writeup
Really cool! 
By that extension Sinatra/Hanami etc would just be smaller hammers, whereas Rails would be the bigger hammer. It‚Äôs not like any of these frameworks/libraries solve any specific problem sets differently or exist to solve problems different from each other. They all help create/ship web apps. ¬Ø\_(„ÉÑ)_/¬Ø 
&gt; This web app is not so simple as its contents will be user-generated. Looks like as per OP, his project is not that simple. May be he does need the bigger hammer? Again I‚Äôm just going by the facts that‚Äôve been presented. It‚Äôs hard to make a recommendation based on the very little info valuable, which is why I was curious to know why Rails was not a good idea?
Glad you liked it!
Thanks! :)
This looks nice but one important feature is missing and that's being able to deal with multiple files. I often want to have config.yml, config_environment.yml, config_local.yml or even config_hostname.yml. and be able to override the values in previous files. 
Are you using Ruby like a scripting language and Crystal for the server most important and performance-needed things?
Nope, I'm doing the same things twice in both languages.
We'd *love* to check it out! But please share the link with us :-)
[here you go](https://github.com/frol/completely-unscientific-benchmarks/blob/master/README.md) :)
wow... that's awesome lol
Thanks. I corrected the link so it points at the repo root and made shure it was visible in the main post as well 
Great. It would be nice to see crystal included here too - https://benchmarksgame-team.pages.debian.net/benchmarksgame/
Out of curiosity, would you say def initialize(x) @x = x @y = Random.rand(Int32::MAX) end is more or less readable than the following? def initialize(@x) @y = Random.rand(Int32::MAX) end I'm leaning toward "the latter is more readable when one gets used to it", but... dunno.
Hmm, yes I kind of agree with you, however I also sometimes prefer the explicitness of having the initializations in the same place, no matter where, especially when it's rather complex code to read. But I guess thats really personal preference, there is a much more silly mistake further down thats plain out bad: class Tree def initialize @root = nil end @root : Node? This is what it should have been: class Tree @root : Node? = nil But nothing that should affect performance though.
Haha yeah I saw that too but thought "God I sound like such a nitpick". :D In fact, `@root : Node?` works as well (as long as it's nilable, `nil` will be a default).
Yeah, ofc you're right :) I have no problem people commenting it though, it's just for fun! But apparently it's apparently starting to get a bit late over here. 
Don‚Äôt reinvent the wheel, run nmap, parse output!
"[Why don't you include language X?](https://benchmarksgame-team.pages.debian.net/benchmarksgame/play.html#languagex) Because I know it will take more time than I choose. Been there; done that. Measurements of "proggit popular" programming language implementations like Crystal and Nim and Julia will quickly attract attention and be the basis of yet another successful website (unlike more Fortran or Ada or Pascal or Lisp). So make those repeated measurements at multiple workloads, and publish them and promote them."
Very interesting topic, Thank you for share it!, I already discovered this issue some time ago, I think some crystal devs are right about you can't get all things at same time because you need to sacrifice something (Development time, compilation time, or execution speed) . The compiler theory developed in this post is quite right, I would rather prefer a different approach to solve this by using a dual backend or a Crystal VM and sacrifice execution speed for development purposes, WDYT? Ref: [https://github.com/charly-lang/charly/issues/168](https://github.com/charly-lang/charly/issues/168)
Thank you for these tutorials! I'm thinking about doing some personal projects in Crystal and will definitely use these :) 
I already tried something similar some time ago to replicate [ip_address_list](https://docs.ruby-lang.org/en/2.5.0/Socket.html#method-c-ip_address_list) method in Ruby, try this: ``` lib LibC struct Ifaddrs ifa_next : Ifaddrs* ifa_name : UInt8* ifa_flags : UInt32 ifa_addr : LibC::Sockaddr* ifa_netmask : LibC::Sockaddr* ifa_destaddr : LibC::Sockaddr* ifa_data : Void* end fun getifaddrs(ifap : Ifaddrs**) : Int32 end class InterfaceAddress property interface_name : String property ip_address : Socket::IPAddress property netmask : Socket::IPAddress property family : Socket::Family def initialize(@interface_name, @ip_address, @netmask, @family) end private def extract_in_addr return nil unless family == Socket::Family::INET octets = ip_address.address.split(".").map(&amp;.to_i) integer = 0_u32 octets.each_with_index do |octet, i| integer += octet * (256 ** (3 - i)) end integer end def ipv4_private? a = extract_in_addr return false if a.nil? if (a &amp; 0xff000000) == 0x0a000000 || # 10.0.0.0/8 (a &amp; 0xfff00000) == 0xac100000 || # 172.16.0.0/12 (a &amp; 0xffff0000) == 0xc0a80000 # 192.168.0.0/16 return true end return false end end def ip_address_list output = [] of InterfaceAddress C.getifaddrs(out current_ip) while current_ip if family = Socket::Family.from_value?(current_ip.value.ifa_addr.value.sa_family) output &lt;&lt; InterfaceAddress.new( String.new(current_ip.value.ifa_name), Socket::IPAddress.from(current_ip.value.ifa_addr, sizeof(LibC::Sockaddr)), Socket::IPAddress.from(current_ip.value.ifa_netmask, sizeof(LibC::Sockaddr)), family ) end current_ip = current_ip.value.ifa_next end output end ``` Ref: https://github.com/t-richards/interface_address/blob/master/src/interface_address/lib.cr#L2 Ref: https://github.com/Papierkorb/tuntap/blob/master/src/tuntap/lib_c.cr#L96 
That's great to hear, I'm sure you'll like it! You can join us on [Lucky's gitter channel](https://gitter.im/luckyframework/Lobby) if you need help tackling any issues :)
Never posted in there, but have taken a look around. I really want to get good, help the crystal community grow even more :) 
I don't think it's possible. It has not been designed for that.
I've been programming for 3 years and I found that contributing to open source and getting my PRs reviewed has helped me the most in improving my skills. Actually I published my first [crystal shard today](https://github.com/mikeeus/lucky_react) and although it's super simple, it was something that hadn't been implemented before. I think young projects like Crystal and Lucky are great places to learn while contributing something of value. 
Hi there! Crystal being a \_compiled\_ language, well - no, you can't run Crystal code without compiling it. But, unless there's any technicality that you're thinking about, I'll guess you probably don't care \_that much\_ about code being compiled or not - you'll probably caring about developer experience, about not having to run different commands to get your code to run. In that case, well - yes, Crystal can help you. Instead of \`crystal build src/my/main.cr\` and then running it, you can always \`crystal run src/my/main.cr\`, which will compile your code and then run the resulting binary. If your project isn't \_that\_ big, chances are you won't notice any difference versus "interpreting" a project in a different language.
So, I haven‚Äôt found yet if such thing as Lucky exists in Crystal /s
Great article! Thanks /u/paulcsmith0218
Waiting for crystal 1.0 and popular method aliases added back ( eg: .to_s .to_str .to_string ) see python‚Äôs exit vs quit thing. Programmers also deserve to be happy.
Thanks! I am having a hard time formatting the code, I am quite new at crystal, and could use some guidance.
I'm glad you enjoyed it!
Totally understandable. Getting in pre-1.0 isn't for everyone. I personally love that Crystal removed the method aliases so there is one way to do things, but I bet it would be fairly simple to add a shard that monkey patches them in if you \*really\* want them :) I wouldn't necessarily recommend it, but it is possible!
Very cool! I disagree with the idea of having \`--release\` on by default though. Sure people benchmark and forget to turn it on, which is annoying, but I think that's far better than someone using Crystal and wondering why there programs take a super long time to compile.
You shouldn't expect method aliases being added to Crystal stdlib. The no-aliases policy is pretty strong (and that's a good thing IMHO). No developer is happy about remembering whether \`to\_s\`, \`to\_str\` and \`to\_string\` all just do the exact same thing or if there are maybe subtle semantic differences. Apart from that, according to my experience, Crystal is actually pretty stable. There are a few breaking changes here and there, but nothing substantial. So in my opinion, there's not much point in waiting for 1.0 =)
Note that in Ruby to_s and to_str are different. That's another good reason for avoiding similar looking methods and aliases. 
Hi, Lucky is actually a framework built with Crystal. You can [check out the guides here](http://luckyframework.com/guides)
Let me know if there is anything incorrect!
I didn't realise it was so straight forward! Have you thought about making a tutorial on passing Crystal types into C functions? e.g. hashes
callback seems to receive an int in C and passed a Float64 in Crystal 
Yeah that does look very strange, especially because there are no comments on this. How is that correct / desirable, anything ?
 Why don't you use static linking for the library? Such a custom library probably doesn't make much sense as a shared object, having it directly embedded in the binary makes it easier to distribute. Naming the lib (C file and Crystal bindings) \`nbody\` instead of a generic \`functions\` would make more sense. I also added two comments directly on medium about incorrect description of Crystal features.
Ah, OK, I se the problem. Yes, the signature in the "C" callback is incorrect. It should take a double. Very strange that didn't cause any problems when running the code. Thanks. I'll correct it.
It's corrected now. But very strange this didn't give any compiler warning or error when running the code. Actually I could write whatever I wanted int the signature (tried with "char", and even leaving it empty and it still works and give the correct result...
Thanks for the comments, they're addressed and rephrased. Just out of curiosity, what would you call the result of the 'lib' declaration? I couldn't find any definitive answer on that in the documentation (and I couldn't find it in the source code either). Regarding linking, well, it only uses funtionality from the C standard library so I didn't do any linking to keep everything simple. I might look into changing that if you think it makes it a better example to do it. Naming, yeah, but everything ended up named "nbody-something" so I felt I needed to make the namings different so its easier to follow the example :) But I agree the naming is not perfect.
It's not strange. Depends on the calling convention. Things are passed on the stack, which in untyped, so declaring an int in Crystal and receiving a float in C will probably work. Same the other way around. 
On Mac an extra file is indeed generated with debug info, and --no-debug disables that. So the description wasn't that far from reality :-) 
Yeah, and its only a pointer we're passing so i guess that doesn't communicate anything about the callback function its pointing to either.
Never used Crystal on a Mac ... :D
Maybe just "lib declaration"? =) The example also uses functions from your custom functions lib and they are linked into the final executable. But because you compile the library to a shared object, this \`.so\` file needs to be available in the library path when you execute the binary. If you compile the lib as a static library the linker adds it directly to the executable and you don't need to have a shared library around for running it.
Haha, ok :) I'll stick with that. I see what you mean regarding the linking, but if I move the file Crystal compilation produces as it is now to another folder (even to another user) and delete the \*.so file - it still works. I think that my unprecise naming of the file might be the cause for confusion, if you see the compilation flags I send to GCC and the steps i made I actually only create a c object file, since LLVM would link to that and I just wanted to show how to use your own C code in crystal an how easy and powerful it is. Since i don't mention anything about shared library in the text I should just rename the file to functions.o since that is the correct name to avoid confusion.
Oh yeah right, it seems you just called the library \`[functions.so](https://functions.so)\` but it was in fact an object file, so no shared library. There is however still one reference to \`[functions.so](https://functions.so)\` in the text.
Yep, see it. Cought it now. Thanks a lot for reading through and giving comments :)
I don't think thats any point anyway until 1.0 release is out an parallelism is implemented (many of the algorithms used that in that benchmark really benefit from that). And as the maintainer of the benchmarks himself commented, the focus of the benchmarks are on more established languages so we'll just have to see how things evolve;)
It'd be nice if `created_at` and `updated_at` didn't have to be hacked into the materialized view. Is there a way to turn off the requirement for these fields?
Nice! üôå
awesome!
Missing Cloud SDK‚Äôs could be a huge roadblock for Crystal adoption, I‚Äôm glad someone has laid the groundwork for AWSüëåüëè
This is AWESOME!!!!!!! Was waiting for it for so much time. This would drive so many people to the community
^The linked tweet was tweeted by [@bararchy](https://twitter.com/bararchy) on Aug 07, 2018 15:13:39 UTC (2 Retweets | 9 Favorites) ------------------------------------------------- We have reached 5 full-time [@CrystalLanguage ](https://twitter.com/CrystalLanguage ) devs in [@NeuraLegion](https://twitter.com/NeuraLegion) , couldn't be happier! ------------------------------------------------- ^^‚Ä¢ Beep boop I'm a bot ‚Ä¢ Find out more about me at /r/tweettranscriberbot/ ‚Ä¢
Nice! Good luck !!
Thanks :) 
We‚Äôve come full circle 
Indeed ;)
So do I :) That tool is a little step into that direction...
Nim is indentation based? damn now I'm definitely not trying it
Most people won't care, indeed ;) But when choosing a new emerging language to experiment, people look for many things : is the language strongly-typed or not, is it object oriented or functional, does it have a syntax that matches their own habits and preferences, does it have support for concurrency or not, etc etc And only then they will decide if the language is worth their investment in time and efforts in order to be learnt. My goal with Cibyl is just to remove a possible "no" on their personal check-list. This has worked with me, and I hope this will work with others...
You are awesome!!!!!
I am not the author of Leafgem, just shared it since nobody talked about it on the sub :) 
You guys are awesome!!!
This is huge ! Thanks !
What's the status on porting Immix to Crystal? 
https://github.com/crystal-lang/crystal/issues/5271
Awesome! Are there any open source apps that use Kemal? Seeing how it's being used would really help me learn Kemal and Crystal.
Yeah, the new Kemal features are awesome. You can see Kemal Users here: https://github.com/kemalcr/kemal/wiki/Kemal-Users
Legend! Very useful
[crystalshards.xyz](https://crystalshards.xyz) is open source and actually uses Kemal :) [https://github.com/f/crystalshards](https://github.com/f/crystalshards)
Figured it out: require "http/client" client = HTTP::Client.new "google.com" response = client.get "/index.html" puts response.status_code # =&gt; 200 puts response.body # =&gt; Long html string client.close
Looks like the client doesn‚Äôt support automatic following of redirects yet: https://github.com/crystal-lang/crystal/issues/2721 You‚Äôll need to pull the redirected URL out of the Location header and make an additional call.
``` require "http/client" p HTTP::Client.get("http://oauth.reddit.com/r/crystal_programming/hot.json") ``` this makes it obvious that it's just the redirect from HTTP to HTTPS, requesting HTTPS directly returns a 403.
Other people have already provided the solution but just for additional understanding: A 301 response is NOT an error but a normal response indicating that you should look in a different location. In this case it is a redirect to the same url on https, so it wants you to use a secured connection instead of the current insecured one. The PHP method apparently follows these redirections automatically, but the Crystal one does not (yet).
Let‚Äôs give it some time...
&gt; the community doesn't seem to care about that Perhaps rather than not caring it's about not knowing how to? Most users came from Ruby. Most rubyists don't have experience with programming compilers. And the few who do simply don't know how to do that particular thing, including the original mastermind behind the language. I don't get this *so hard done by I don't care anymore* attitude. 
Ary has a bi-polar attitude towards crystal, and is very public when he is feeling negative. His comments have gotten me down before too. IMO, right now, Crystal has the most momentum that its had in the 2+ years that I've used it.
But is anything he said untrue?
Probably not, but I dont know anything about compilers. It doesn't really matter to me anyways, I would rather program in Crystal than any other language, even with a slow compiler. Though, I still think the compiler will be improved in the future.
What I meant is that the community doesn't seem to complain about slow compile times. This is what they don't care about. If the community, which is the one using the language, doesn't care about that (big compile times) then there's no point for me (or others) to try to optimize compile times. Or at least it doesn't make sense to do that if it brings frustration (what happened to me). 
Yes, sorry about my bipolar attitude towards Crystal. I'm trying to handle it better. 
Its understandable. You built something and you are the most critical of it, and you are emotionally invested in it.
IMO the only true mark of a project's death is when the developers don't think anything needs to change. 
Oh! If that's the case, I personally think Crystal needs a lot of change :-) (though all change is hard)
It has a beautiful syntax, but it has some strange issues and too many method aliases. There isn't a large ecosystem yet so it probably won't survive. It's also unbearably slow. The language is Ruby (before Rails) :) How about a language that requires 2 days of setup to use for anything "serious" and that has strange handling of dates (and plenty of other things). JavaScript. Which is of course thriving! My point is that it is very hard to tell whether something will survive, let alone thrive. Sometimes it takes years. Sometimes it skyrockets from nothing in just a few months. Sometimes something is ahead of its time and never takes off. In the case of Crystal, I think it is a lovely language. In its current state it would be hard (but definitely not impossible) to use in production due to breaking changes every few months. Then again, it is pre-1.0 so this is to be expected, and is a good thing since it means the language is improving. Personally, I think the compile times are bearable and the other language features make it my favorite language around. Scala, Swift, Haskell, and others also have large compile times, but people use them and love them. I'd \*love\* incremental compilation, but I think Crystal can survive and maybe even \*thrive\* w/o it.
[There have been](https://www.reddit.com/r/crystal_programming/comments/91r8im/crystal_has_a_compilation_issue/) complaints on compile times and your answer was that it's likely an unsolvable problem unrelated to manpower. It seems there are two possible scenarios here: 1. Crystal is doomed by its very design and there's no fixing it as it is so use it like a toy language or abandon ship. 2. Crystal could be fixed but the community is not pulling its weight, choosing instead to muck around the low hanging fruits of the stdlib when there are more important issues to address. Do you strongly identify with any of the above?
I'd like to echo all the appreciation and excitement I've heard and shared with others over the last few years regarding Crystal. It's an exciting project and had brought back the joy of programming that I lost with Go. I'd much prefer open source teams that are honest about their concerns than pretending like everything is perfect. I'll take the Crystal maintainers over the Go maintainers any day.
You, as a maintainer of lucky, feel that it is possible to thrive? That is a good sign. I think that as more people use it, it will have more resources to make it faster. Compilation is a really difficult problem, but we're all aware of that with crystal. Considering that the language has only recently has one full time developer, I think that it has a really long history ahead 
I prefer not to comment on such things anymore. 
Both scenarios are very pessimistic. They might be realistic, but there are other possible scenarios as well: 3. Crystal's design is a trade-off exchanging compile time for awesome features and developer happiness. While that makes it not suitable for applications with large codebases, there are still great use cases and that's what people love it for. 4. Compiler performance could be improved, but that requires manpower and momentarily developers are busy with more important features. 
There is actually already \[cr-dotenv\]([https://github.com/gdotdesign/cr-dotenv](https://github.com/gdotdesign/cr-dotenv)). What's the benefit over that?
I am confident it is possible. I do not know if it will or won't survive, but it definitely can, especially as more and more people are interested and contribute. There are more libraries than ever, and the quality is improving. I want to use Crystal every day at work and I'll do what I can to make that possible :)
I wasn't expressing my views on the subject (which I gave [here](https://www.reddit.com/r/crystal_programming/comments/91r8im/crystal_has_a_compilation_issue/e30jb22/)), I was seeking an answer to OP's question from the best source we have and attempting to sum up points that have been brought up a few times before.
Ignoring problems with a language/compiler probably doesn't correlate with long-term success for that same language. Basically any language that can get and hold on to a community of developers can thrive. So i think it makes sense to try to make your compiler as useful in a general purpose way as is possible.
I would wager a number of languages have fallen by the wayside using that kind of thinking over the years.
I'm afraid /u/the-asterite 's words make sense to me :-( Maybe we should remove some crystal features like he said, WDYT? 
With slow compiling speed, Crystal is indeed not very suitable to develop large applications, especially web applications (live reload experience). But you can't rule out the potential of using it to write small console/GUI apps, replacing C++/Delphi/Go as a better RAD language. Well windows support and portable binary are still the issues, though.
Parallelism is an actual issue as well
One thing to note though is that while the stdlib is easier to start with, doing work there eventually prepares people to graduate and do stuff in the compiler as well. It is big and complex, and it takes a while to get experience enough to do stuff there. 
This is not my project, I just saw it and I thought about sharing it because It can be useful to someone. it might be better to open an issue on GitHub and ask for benchmarks there 
I would say - remove some features. Nowadays I almost completely switched to JavaScript/TypeScript from my RoR days. And, while JS is ugly, it's almost as powerful as Ruby. I believe it should be possible to limit features of Ruby (Crystal) and make the language simpler (and its runtime and compiler simpler too) without loosing power and beauty. It seems like what Crystal really needs is a killer feature. In case of Ruby it was terrific productivity of RoR. For the Crystal such feature could be parallelism. As soon as it kick off - the money will stream into it, and the money have this magic property to solve pretty much any issues, including slow compile times etc :)
Are you sure this is the only way to solve the problem?
Yeah, nice to see you putting out a lot of Crystal libs! However, I don't like the fragmentation. Would be better to have one great library for the same thing instead of two (maybe a little less great ones). Although, to be honest, don't see much sense in that kind of thing, anyway. Loading its own environment configuration shouldn't be the applications's job. The environment should already provide that (either using dotenv or any other means).
I wish it would be possible to tackle the slow compile times and parallelism. Or somehow opt in for it for larger projects if possible with typ specification and banning some of the features. 
So, what about using something like bountysource? I'd be happy to give some money if that would encourage someone to tackle the incremental compilation and/related compilation hurdles/issues. I might not be able to give a lot, but if a few more people would throw in something too it might become attractive for someone with the necessary skills ‚Äì which, unfortunately, I haven't. I really enjoy using crystal and would love to use it as my main language someday (given enough experience with it), so it would be sad to see it go. Asterite would have to be OK with that, of course.
They actually do that https://salt.bountysource.com/teams/crystal-lang
Well, can it be compiled to WASM? Support web assembly (and integrate that into these nice web frameworks) and then you have your killer app.
what?
I do not like fragmentation either, most of the similar libraries I wrote are not update for a long time. the other was not good architecture which i favored. It could not be done with PR easily. The best practice is use docker with a large number of environment variables and local develop, use dotenv is easy to operate the data. That why huge same library in different languages in github.
I've totally missed that ‚Äì I've been thinking of the bounties for features/issues, to directly encourage development for a specific feature. &amp;#x200B; But as it's on the roadmap anyway salt.bountysource seems great to ‚Äì I've just pledged a monthly amount :)
I beg to differ. Crystal is great for web applications. Live reload is nothing you should really need in a web application, unless you're doing frontend stuff. And there are alternatives to recompiling the entire project. All the actual server features in the backend can easily be developed using unit tests which compile much faster than the entire app. Windows support is in the works. Statically linked binaries are already possible, it just needs to be compiled with musl on alpine linux. And parallelism isn't really an issue for the majority programs. Most use cases can just fork and use some sort of IPC.
Yes, there is already an issue for that. Unfortunately it will probably need to wait for WASM to mature for being able to support GC and fibers. [https://github.com/crystal-lang/crystal/issues/829](https://github.com/crystal-lang/crystal/issues/829)
Macros is a killer-feature of Crystal, removing them would drastically decrease it's usefulness. I wish the team worked on improving meta-programming part of the language (macros feel cut and not released their potential yet at the moment)
&gt;unless you're doing frontend stuff Yes, unless you plan to use crystal to build API-only application (and using React/Vue/Angular as SPA in the frontend), time to reload (recompile) after changing a single character in a template is a huge issue. &gt; Windows support is in the works. We all hope for the day it is done. &gt; Statically linked binaries are already possible, it just needs to be compiled with musl on alpine linux I mean on all the three targets: linux/darwin/windows. &gt; And parallelism isn't really an issue for the majority programs. Agreed. That's why I didn't mention it.
Crystal currently can't run on WASM because GC and coroutines can't be implemented. Or it would at least require tremendous effort.
It doesn't need to be an API-only webapp to separate logic from presentation and use run-time templates. In some cases it's certainly better to have compile-time templates like ECR, but especially in larger applications it quickly gets easier to develop application logic and templates separately. &amp;#x200B;
As someone who likes Ruby, but really wants a compiled language with optional static typing; I wish I could contribute to improving compile times. It wouldn't surprise me in the slightest if once compilation performance and parallelism improves, a lot of Ruby people would start considering Crystal more and more. Ruby, Elixir, and Crystal are all really fun to use, and all have their drawbacks; but people enjoying using them has obviously led to improvements and more features. I have strong hope for Crystal. I just wish I had the knowledge to contribute to improving it. üòï
I'm not convinced that compilation time is a problem AT ALL. Even if I had a nice fast C compiler, and still loved to code C, I'd gladly take the slow compilation for full type-checking that a modern language is capable of, let alone full type checking without all the boiler plate of specifying types and then populating them in separate steps.
It is something like that. As far as I can tell, the compiler will only bring in parts of the standard library that it needs. Compiling a "Hello world" binary resulted in a \~400 KB executable on my system. That's in release mode. Stripped it is just under 300 KB. Doing a dump of the executable with the nm command shows it is mostly related to garbage collection (GC\_ functions), pthread, and other Crystal internals.
There was a post, I think from Bruce Perens, that played with compiling without std lib, resulting in executables of a few kbs. I will look for it and paste it here. 
https://perens.com/2018/07/06/tiny-crystal-language-programs/
I think it's doable. If I'm not mistaken, there is a llvm byte code to wasm translator. Also the BohemGC can be compiled to wasm. There are other gaps missing but several languages are in the same place and probably it will be filled with time, in the wasm spec or externally. 
I mean, it's pre-1.0 so for any strict, enterprise-grade definition of "production", the answer MUST be "no". But otherwise... go ahead. It'll be fun. &amp;#x200B;
Well, rather than puts, there is the Logging module in the standard library. printing/logging is what programmers tend to use for debugging a lot of the time anyway. But I think there ARE debuggers for crystal too, right?
Cool, thanks. Actually, this was the post that first got me interested in Crystal, but I'd lost it, and misremembered the complexity (I guess because the language was completely new, and I'm used to languages where giving up the standard library introduces a world of hurt). It looks fairly straightforward, actually.
You probably want to use higher precision for all calculations.
I temporarily gave up on Crystal. I wont put any time on development of any new projects in this language. Sadly I dont see crystal getting significantly better in any of the pain areas. * I see now that Crystal might get Windows support that's a good thing and will be huge. However I am afraid you guys dont have the manpower to keep the parity in terms of features and performance My biggest issue is that I dont think the compiler speed will ever be fixed. I would rather have an interpreter for development and a release for full deployment. I saw some projects regarding this but afaik the development has halted. I also dont see any viable solution to the parallelism and it will take too much time before it can actually happen. I am very thankful for all the hard and great work you guys.
I do not fully agree here. As someone who came to Crystal from JS ecosystem and Nim, i love what the language has to offer. I have only ever written very small web based projects but for none of them the slow compile times was ever a big issue. Would I like to have faster compile times? Yes. But even if I dont, I see it as a mild irritant. It just isn't a big enough issue to dissuade me from using this language. I feel confident that as the language matures and gets more corporate users, the compile performance will improve as well. I recently tried Rust and it also has a huge compile time issue. In fact, for a simple bare bones web server, there was a lot of dependency fetch before compilation even began and overall Rust compile times felt slower to me. Then again, while irritating, the compile times on neither language is bad enough for me to drop them.
&gt;the compile performance will improve as well. with Crystal's current choices (global type inference, class monkey-patching), it will be incredibly hard. 
The User Interface doesn't have to be graphical. A UI is the interface that the user uses to "talk" with one program
Source of complaints you‚Äôre seeing?
I don‚Äôt save links and it‚Äôs hard googling for them on a small phone screen but you can find lots out there and even in this article if you read through to the bottom you‚Äôll see how the guy says it took 5s to build and a link to other ‚Äúbuild time horror stories‚Äù
A hello world with Rust is about 5MB. Just saying.
Maybe, but it's completely ridiculous. The assembly for a hello world program should be barely a few bytes more than the string itself.
"Wrote a micro service in crystal, blown away on how easy it was." Sounds like someone made themselves a government.
I may be wrong, but I would imagine that determining whether a GC (or anything else) is needed and linking it in accordingly is no different from determining whether a library function is needed, emitting the code to call it, and having the linker link it in because it's referenced by the code.
Someone asked this question in the past: https://groups.google.com/forum/#!msg/crystal-lang/h0QwpsuRh0Y/dCZdgOm7HwAJ;context-place=topic/crystal-lang/_vlnJx47UfE My old answer still applies: Crystal is not meant to be used for low-level programming. It's a high-level language with: - Garbage collection - Non-blocking IO by default (linked to `libevent`), with a runtime scheduler that's always on (lots of code for this, always linked and present) - Regular expressions (linked to `PCRE`) Then `puts "hello world"` will involve a lot of code, it won't result in a direct assembly translation to moving that memory piece somewhere from memory to the "screen". A compiled with `--release` "hello world" program in Mac takes 300K on my machine. A similar program takes 2MB in Go. Then, I don't think we'll ever improve this situation, because for high-level programming it doesn't matter much.
If that's all you need, you can write it in assembly. But in Crystal I doubt your main application is going to be a hello world. And at that point I don't think executable size matters that much (except for embedded programming, something I don't _personally_ think Crystal is suitable for).
Why is pcre linked, though, for example, if pcre isn't being used?
I was envisioning some sort of gui like you find with git desktop clients.
I think this whole thread is overly pessimistic. I don't think compile times will kill Crystal, but not finishing parallelism and windows support and getting to 1.0 in reasonable time can. I think that really hampers investment from others in shards, drivers etc. Also, better IDE support will lessen the need to compile to check if things work so often and will be a huge benefit in my eyes. Rust is a good example here. Rusts compile times are not great either as someone pointed out, but the "cargo check" runs fast so developing is fast because you just don't fully compile the whole time and adding to that the integreation to VS Code looks up information and highlights mistakes pretty fast. And as someone coming from C#, it's not like extremely fast compile/reload times is something all languages have anyway. Its a pro, but not an absolute must. Crystal has all the basics right. Fantastic perfomance in many scenarios and better than the cometition in this segment, great syntax and readability, very promising web frameworks, nice std lib, enthusiastic community and pretty good PR so far. You could add some more static typing on method signatures and return types if that makes compilation/tooling easier and faster etc, I wouldn't mind but it must be possible to accept that compile times will not be the biggest selling point and still do changes to make sure they're within "acceptable limits" for even larger projects without changing the language totally (I hope :)
The thought that a little extra ram is easier than more engineers to maintain your ultra complicated efficient code applies here.
Related gist comment here: [https://gist.github.com/teaearlgraycold/c7b181f7bc543ee9c37cfd45df5f8856#gistcomment-2154719](https://gist.github.com/teaearlgraycold/c7b181f7bc543ee9c37cfd45df5f8856#gistcomment-2154719)
I think it would help if there was some sort of technical document produced for the problems he outlines, something that makes it easier for other compiler revs to jump in feet first.
`pcre` is being used by the `Regex` class, and when you write `/foo/`, which is a part of the language syntax.
Right, but I mean, if you don't right /foo/, then I would have expected that the Regex module wouldn't be linked, and so they PCRE external lib wouldn't be linked. Am I missing something that makes this impossible, or has it just not been done that way for the sake of expediency / simplicity? NOTE: I'm mostly just curious about the possibilities at this point. I understand that Crystal is &lt; 1.0
I think seeing some things like WebAssembly support can blow the doors off of Crystal investment. Things that are more public facing and give the world a taste of Crystal in a vertical fashion (isomorphic). There's no doubt Crystal is sexy and we need to put in features that push that envelope out to get deeper wallets and devs with more time to invest in resolving such issues.
Again, a nice shiny bounty that the community pushes could resolve the manpower issue.
Killer feature would be WebAssembly for a truly vertical (isomorphic) experience.
That's great and all, but I think we need a bounty on the biggest headache(s) of /u/the-asterite, such as the very one that this post is about in order to bring in some core talent that will be attracted to both the money and simultaneously become a serious mover in the community. If the funding is sufficient it might pull in a team.
Agreed and I think folks have mentioned this before.
I actually think PCRE is dynamically linked... well, it depends on the system. But PCRE is always used, there are these two lines right in `lib_pcre.cr`: ``` LibPCRE.pcre_malloc = -&gt;GC.malloc(LibC::SizeT) LibPCRE.pcre_free = -&gt;GC.free(Void*) ``` That is, we setup PCRE's allocator to use our GC. That always happens at program startup. Sure, we could do it conditionally but that would be more complex. Actually... I tried commenting all of `Regex` and `lib_pcre.cr` code and it's still being dynamically linked. I can't remember why right now. But in a nutshell, it's very low priority right now for us to worry about such things (there are bugs, windows support, parallelism, etc.).
and what do you like here compared to Nim ? thx
If you thought writing a microservice was easy, try writing a cloud function! r/https://github.com/sam0x17/gcf.cr (shameless plug). 
You can easily combat this problem right now with modularization/microservices/serverless or patience if you can't be bothered. I currently use a combination of the three with my \~15k lines of crystal web app and I'm still going strong ;). Seriously though, I guarantee most of the people making this complaint aren't the people who have large crystal code bases, and this is likely something that is going to get heavily optimized once we hit 1.0.
Intel Core i7-7600U with 24 GB of RAM on my dev laptop (Lenovo X270) ;)
If they created a bounty to create such a doc I would help fund it. 
&gt;LibUnwind is not available. It is if you build LLVM with MSYS2 GCC. You guys know MSVC isn't the only way to use LLVM on Windows right?
Mostly the ecosystem. Nim still doesn't have good libraries with lots of users
Hello world needs to allocate memory, and to allocate memory you need the whole gc. There's no reasonable way to avoid that. The main size of the executable comes from the io scheduler and fiber implementation. Every application which does io depends on the scheduler, and the scheduler depends on fiber support. There's no way to avoid this.
I have a 2017 MBP with 16gb ram. My crystal app in development takes make 3seconds to compile. It has never even been on my radar as "I wish they'd fix this!". I run crystal in production, and have no issues with build time, and it's a full scale web app, not micro service. Now granted, my only other exposure to compiled languages is with unity which takes several minutes to build each project. I'll take a fee seconds any day. lol 
In a C context, that's probably right, but these languages don't have the same goal neither the same functionalities.
Probably not. I like Crystal, but I am unaware of any existing libraries for performing ML. Also, for a 5 year project, I'd pick something a bit more stable and/or guaranteed to last throughout your research. 
Nope, no allocation required. I wouldn't be AT ALL surprised if the currently implementation does, but NEED is a strong word, and untrue in this case.
NO. Pre-1.0 means pre-1.0
You light up the room.
I was thinking it would be more like (in contrived/simplified pseudocode): if stored_dynamically(item): emit(dymically_allocate(item)) else: emit(push_on_stack(item)) and then the linker would pull in the GC library containing the dynamically_allocate() function, if required.
Just use python for everything. You won't have any problems. With crystal you will have a problem eventually. The python community is 100x what crystal is now.
This all makes good sense :) It seems surmountable now, at least, even if not soon, which gives me more faith in the language/toolchain, to spend more time becoming proficient in it :)
While it is possible that crystal is not mature enough for that kind of long term project, if you namedrop crystal to your computer department then that would be great. There is a lot of possible work for computer scientists, even on an academic level :)
&gt;I see now that Crystal might get Windows support that's a good thing and will be huge. However I am afraid you guys dont have the manpower to keep the parity in terms of features and performance &amp;#x200B; with all due respect sir, crystal is already fast. i use it for 2 gameserver. a master gameserver with inventory matrix for every player, and a gameserver instance (separate) that runs on a low end vps (vultr, lightsail, buyvm, etc). hell, even gullo's ipv6 nat runs great with it and can handle much more players than my old nodejs gameserver (with a 15hz tickrate). &amp;#x200B; performance is not an issue i feel tbh. it's already very fast, and they are active on github as well. heck, even their lead dev was helping me on gitter a couple days ago. &amp;#x200B; compile speeds are not a problem at all sir. i'm on a i7 2600 that's nearly a decade old, and using WSL on bash. my master server (not game), has a plethora of functions and methods. adding to friend list, creating a party, joining a pty, remove user from friend list, create a game, create a channel, switch channels, join a channel, update a player's inventory \[which is an array Matrix \` Array(Array(Int32)).new\`\]([https://i.gyazo.com/23a22d95c84155cbd891b79ef948c3ae.png](https://i.gyazo.com/23a22d95c84155cbd891b79ef948c3ae.png)), etc, etc i can go on! I also use the mysql db module, i use the redis module, json, socket, and more. I also load in a bunch of json files (\`Items\` for example). the compile times are almost literally the same amount of time since i first started, like 2 seconds longer i'd say. and i have over 3.1k lines so far in 5 diff files total. &amp;#x200B; that might not be a lot of code, but i just laugh when people think these compile time issues are actually an issue. it's jut not imho. anyways, that's just my 2 cents... i hope u don't leave and give it a second chance.
In NeuraLegion we use Crystal in production at its current state, we use it for advanced machine learning and protocol analysis, the only "issue" we encountered was the Json::Any change, which took around 2h of work to fix.
It's ok Ary, we love you anyway. You folks just keep up the good work and I'm sure Crystal will have a bright future. If speed were an indication of a languages survival Python and Ruby would have died a long time ago.
I mostly agree, if by Python you mean Python 3. You CAN have problems with python's performance, especially with threading and raw compute power (if possible, write horizontally scalable microservices to mitigate this), and also with its lack of type safety on larger projects (write LOTS of tests to mitigate this), but... yes: Python will get the job done with a lot less risk.
That's correct, it's a special rule only for tuples. It exists so you can do: &amp;#x200B; \`\`\` def foo if condition {1, nil} else {1, 2} end end \`\`\` &amp;#x200B; and what you get is a simple(r) type, \`Tuple(Int32, Int32?)\` instead of \`Tuple(Int32, Nil) | Tuple(Int32, Int32)\`, which is also less efficient. &amp;#x200B; But I'm not sure that rule should stay in the language, it's not very intuitive.
Difficulties overriding nested dependencies? What does that mean? Are core developers also needing this fixed? https://github.com/crystal-lang/shards/issues/105
Looks useful! I‚Äôll try it out 
Thanks! I've been looking forward to more casts. These are really helpful, especially for someone like me with no ruby experience.
I'm glad you've found it useful! I deleted an episode that wasn't uploaded correctly so that is why there is a missing episode with id 3 :) Thanks for pointing it out though just in case it was a mistake
Go already released WASM backend with support for goroutines and gc. 
That's correct. Reading the problem description, it seems you should use BigInt from the standard library: https://benchmarksgame-team.pages.debian.net/benchmarksgame/description/pidigits.html#pidigits In next versions of Crystal your program will raise on overflow instead of producing an incorrect result. 
at this point i‚Äôd suggest also looking into elixir for a high performance management system. it‚Äôs what it was designed for, and will particularly excel in concurrent needs (which seems to be why go/crystal made your list?)
Just FYI: &gt; appose You mean, "as opposed to". "Appose" is a completely different word, which almost means the opposite of what you intended to say.
I do not know, at all, but I thought I'd chime in to say that the boehm GC used by crystal *is* multithreaded, even though crystal itself isn't yet.
What do you mean? \`BigInt\`, in the standard library, is implemented on top of GMP.
I see, I get it
I think you meant to say concurrency, but really mean parallelism. Crystal uses the same model as Go and Rust: channels. You can write them now, but they won't actually run in parallel, until that feature is completed. You might then need a few tweaks to what you wrote when the implementation is done, but hopefully not.
there's [this](https://github.com/RX14/parallel.cr).
How reliable is this shard?
I see, but I wish the particular Fasta could be rewritten for everyone to learn, do you mind to rewrite?
i haven't used it personally so i can't really say anything about the reliabilty.
..that I will have to titch you..