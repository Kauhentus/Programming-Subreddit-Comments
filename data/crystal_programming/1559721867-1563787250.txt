Did you know that Crystal's doc generator already supports some keywords like \`NOTE\`? See [https://crystal-lang.org/reference/conventions/documenting\_code.html#flagging-classes-modules-and-methods](https://crystal-lang.org/reference/conventions/documenting_code.html#flagging-classes-modules-and-methods)
I did something for Nim [https://xmonader.github.io/nimdays/](https://xmonader.github.io/nimdays/) please feel free trying to port them (they're practical) and explained every line in every project :)
ooh this looks very nice, thanks for this. :-)
Blacksmoke16 (on github and gitter) wrote one for Athena.
is this the one you are talking about https://dev.to/blacksmoke16/creating-a-json-api-with-athena--granite-510i
That would be it yes :)
thanks
I did, I just am not a fan of the formatting or that it uses `NOTE` instead of something like `@note`. I'd like to be able to have `NOTE` be a private in-code note.
I forgot that you could output docs in JSON format, that's very helpful. Hopefully it has all the information I want.
Maybe a few parts might still be missing, but they can be easily extended.
Yes, having a mechanism similar to annotations would probably be better.
I like how configurable YARD is. You have defaults in place, but you can also modify it to fit your needs. Add different parsers for different languages, follow the rspec syntax, add your own annotations, etc. The biggest thing I want though, templates.
Whoo! :)
I recently had a similar problem with a python application. You have to make sure you are flushing stdout/stderr - otherwise it will not show up.
Exactly same :) to add, you achieve this by setting the sync property on tge stdout object
yep. There's seems to be an issue with the way crystal sets up `STDOUT`
I don't think it's necesarrily an issue, I think it's just how streaming modes default when stdio is hooked up. stdout only buffers in line-break mode when connected to a tty (if you set tty: true in docker-compose, you can verify that logging will now work correctly). There is good reasons for this default, but I would maybe say that a good change to Kemal's logger would be to change this default. If you wanna understand the idea behind it, http://www.pixelbeat.org/programming/stdio_buffering/ gives an overview.
Yeah, I already investigated source code. But thank you for explaining!
Awesome!
Thanks! :D
First time hearing of this, I've been exploring some of the crystal ecosystem. This looks really nice. The routing actions concept is cool.
So glad you like what the routes in actions :) If you have any questions we'd love to answer them at [https://gitter.im/luckyframework/Lobby](https://gitter.im/luckyframework/Lobby) &amp;#x200B; I hope you can give Lucky a try one of these days
but when will it be for windows?
The new website repo is this one, right? https://github.com/luckyframework/website-v2
Congrats on the release!
One of the bigger Athena releases to date bring some new features as well as some QoL improvements. - A DI/Service container module which can be used outside of Athena as well. - An implmentation of [Crylog](https://github.com/blacksmoke16/crylog) as the logging framework of choice. - A revised way of handling environment specific configurations
Want to give a holla for the new guides, they're a big step up. I'm not using lucky at present but have a lot of respect for it as a project and seeing the security guide is good for inspiration to improve my own current frankenstien project, and seeing the examples in Crystal really helps. Thanks for putting that knowledge out there!
Yes that is correct!
I'm so glad you're liking the new guides! Thanks for the kind words and good luck with your Frankenstein project :D
[removed]
This is awesome!! Congrats and thank you for making the Crystal ecosystem better and better!
Thanks! I'm trying!
üéâ cool man
This is great! Thank you! I played around with it and wrote a blog post (in Spanish) here: [https://picandocodigo.net/2019/tourmaline-framework-para-bots-de-telegram-en-crystal/](https://picandocodigo.net/2019/tourmaline-framework-para-bots-de-telegram-en-crystal/)
Muchas gracias amigo! I hope you had a good experience :)
Super cool my dudes üòé üëç
Great! Makes it much easier to develop. Thanks!
Works here
Check out https://github.com/veelenga/awesome-crystal
Thanks. Does lucky plan on officially supporting websockets? How far do you plan to take the the batteries included approach? I like that auth and email etc are part of the framework but is there long term goals of adding something similar to active job and active storage? Maybe all inclusive like laravel? I looked into amber but I‚Äôm already use RoR and elixir/Phoenix so it didn‚Äôt quite draw me in like lucky has. Sorry if it‚Äôs too many questions and I know you linked to the chat but maybe the response will be useful to others and not get lost in chat history. I will for sure be giving lucky a spin!
I think that this project is doing something with OAuth2 I‚Äôve been using the python port of it tho, so not sure how he has it implemented in Crystal. I‚Äôve been having trouble getting crystal to run on my system so I haven‚Äôt played with it much yet. But checkout the project see if it‚Äôs running OAuth2 to audible servers. My gut instincts says it is. Might be good example code. https://github.com/omarroth/audible.cr
Even if it is doing that, it would use the client function. A quick look at this confirms this. However, I have discovered ORY Hydra ([https://ory.sh](https://ory.sh)) and it uses a universal REST API. Thanks for your help however!
Perfect, glad you found a solution. I‚Äôll check into it myself. Might come in handy.
Happy to answer here. Yes there are plans for web sockets, but first goal is to get Avram (the ORM) really polished and extendable so that it works for all kinds of use cases. I think long term activejob/storage type thing could be cool. I think they would be external libs maintained by Lucky that you could easily add in. &amp;#x200B; There are plans to also make it easier to add third party auth through Google/GitHub etc. And also some other more prototype plans that I haven't really released much of because it's still in early phases of testing. But yes, I want Lucky to make it super fast and easy to build great apps and I think that means extracting common libraries like you mentioned!
Thanks again. I appreciate you taking the time to respond. It instills confidence. Just to be clear I think lucky looks great and these are just questions based on my own curiosity/preference and not expectations. I specifically brought up jobs/storage because I don't remember the last time I worked on an app that didn't utilize s3 or background jobs. I look forward to seeing how crystal and lucky progress.
‚ù§Ô∏è
Honestly I think the most important thing is to check out each framework‚Äôs style and see if one or the other is a better fit for you. I found that Amber is just easier to reason about and I find the syntax extremely straightforward, but i might be different (and I‚Äôm coming from a Rails background). Lucky is also a terrific and has an excellent community. Check them both out and see which one you‚Äôre drawn to - you‚Äôll be in good shape either way.
I ran into trouble getting Amber sites to render on Firefox. I'm building a lucky site right now to try it out and it's really nice to write. What I have played with a lot in Crystal is using Kemal with React.js and that flow has been flawless for me.
Nice! I'm curious, how do you do an `OR` in sql using lucky?
I haven‚Äôt used any yet so take this with a grain of salt but I‚Äôve ‚Äúdecided‚Äù to use lucky based on a preliminary high level look. It‚Äôs a different approach and I really like the authors commitment to communicating with the community. He also seems very passionate and committed to his goals. I spend my days in rails and Phoenix and amber just feels like a weird mashup of the two. That could be a good thing. I dont know. It comes down to preference.
If you happen to be making a JSON API, [Athena](https://github.com/blacksmoke16/athena) might be a good option as well. Otherwise, I think it comes down to whichever you prefer. Take a look at the docs, the supporting shards (like ORMs etc) just to see what would fit your needs the best. Possibly even start two new sample projects with each just to get a feel for how they work as actually using something is a lot different than reading documentation.
I feel like every time I've tried to use Amber I've run into issue after issue with models, migrations, etc. I've been using Lucky for the past couple weeks and I've been loving it. It has great documentation, a very powerful ORM, a very expressive view system that actually uses Crystal for the views, and so much more.
I think this is a really great point. Amber is a lot more Rails like than Lucky. One of the goals of Amber is to be very easy for Rails developers to jump into. If that is a goal of yours, Amber is a great fit! &amp;#x200B; Lucky is ok straying from what Rails does if we feel it is more maintainable, clearer, or if it means we can catch more bugs at compile time. I think that Lucky is one of the frameworks most focused on catching bugs at compile. It'll catch missing route params, incorrect HTTP methods, and even typos in assets! A lot of people forego writing tests completely because Lucky helps catch so many bugs at compile time. The tradeoff is that Lucky does things differently than a lot of frameworks so it there are some new concepts. We tried to document things well in the guides though :)
I‚Äôve used and enjoy both. Amber is very easy to work with if you‚Äôve used something like Ruby on Rails before. Lucky does things differently and takes longer to learn but I really like it. There are some limitations to Lucky, though (currently). If you need complex forms with things like many-to-many relationships you‚Äôll probably struggle. That said, you can switch out that part of the system for an alternative.
Hi there! üëã &amp;#x200B; I'm the creator of Lucky. I am of course biased, but will attempt to be objective. I'll also detail \*why\* I created Lucky. &amp;#x200B; I initially took a look at Amber and was intrigued. I also looked at Kemal and was quite impressed. The thing that I felt was missing for my use cases was strong compile time guarantees. I wanted something that would catch tons of bugs before they ever hit production. I also wanted something with batteries included. So if I wanted to send email I could, if I wanted to use React, I could. &amp;#x200B; So I started working on Lucky. It has a generator that lets you choose if you want web pack or not, api mode only, and even lets you choose to have built-in authentication. It catches all kinds of bugs. It will catch if a parameter is not available, it will catch missing assets (and even give suggestions! "Did you mean 'logo.png'"). The ORM is also super flexible and catches bugs at compile time like misnamed columns, incorrect types, incorrect associations, and more. &amp;#x200B; I'm happy to go into detail here or answer questions. The guides are also quite helpful [https://luckyframework.org/guides/getting-started/why-lucky](https://luckyframework.org/guides/getting-started/why-lucky) &amp;#x200B; \## On Amber &amp;#x200B; One of the goals of Amber is to be familiar and intuitive for Rails developers. I think Amber fulfills this goal super well. It also combines some approaches of Phoenix with the idea of "plugs" which is pretty cool. They also have some features like encrypted secrets that Lucky does not have. &amp;#x200B; You may be able to get started with Amber faster, but you will trade off some compile time guarantees. The way Rails works makes it difficult to catch as many things at compile time. &amp;#x200B; Another thing is that Lucky uses Crystal for building HTML pages. Everyone I've talked to has been hesitant about it, but in the end really likes it. But if you don't then that could be a deal breaker for you. If you're building APIs then it doesn't really matter either way :)
One other thing. Some people worry about performance between frameworks. I probably wouldn't. They're all frreakin fast and even a 50% difference will probably not be noticeable in practice. With that said I think all the frameworks are pretty close to each other in terms of performance. Since Crystal is so fast it makes it easy to make a fast web framework :)
Totally true. Nested forms can be quite tricky. We're working to make this super easy in the future, but it is currently quite difficult! &amp;#x200B; Thanks for the feedback!
No problem! I‚Äôm definitely looking forward to trying your nested form solution when it‚Äôs ready üòÄ
I don't want to sound bias since I'm on the Lucky core team, so I'll lay out a few facts the best I can. * Lucky only supports postgres * Amber uses a MVC approach similar to Rails * My company runs Lucky in production with millions of users &amp;#x200B; Both frameworks have a gitter channel. Come in both and say hi. We can all give you some tips on getting started. There's also SpiderGazelle and Athena you can look in to. So plenty of choices!
Thanks for reaching out, great work for what I've seen so far! I was really surprised/intrigued that Lucky uses Crystal for creating HTML. I kind of dislike the ERB/ECR syntax, so that's a big plus. Also the focus on catching as many bugs as possible also catches my interest ;) I only worked a short time with Rails, but I can definitely see a logic choice for Amber if you are a seasoned Rails developer, because of the similarities. I already had a mild preference for Lucky by reading the docs alone. Your comment and community activity nudged that even more towards Lucky!
Thanks, will do!
Thanks, I will keep Athena in mind as well
Kemal is too minimal for me, but a fair choice (and a great foundation for other frameworks!)
Good to hear. It's mainly intended for JSON APIs, so if you're planning on using server rendered HTML etc then Lucky/Amber would be the better choice.
Fair enough. There's also Athena, which has some really neat and unique ideas. You should check out /u/blacksmoke16's blog posts about it on dev.to
Right now you'd have to do that with a raw string :( \`.where(column\_a = 1 OR column\_b = 2)\` however there is a WIP PR that will allow you to do something like this: \`[UserQuery.new](https://UserQuery.new.name).age.gt(55).or(&amp;.senior(true))\`. We're still working out the exact syntax and implementation but that is the rough idea of how it will look
Great, thanks for the response! I just asked out of curiosity because I know `OR` is a tricky one when designing these kind of APIs. I like the `.or(&amp;block)` idea, then you can chain multiple stuff in there.
Did you try \`embed\`? [https://crystal-lang.org/api/0.21.1/ECR.html#embed%28filename%2Cio\_name%29-macro](https://crystal-lang.org/api/0.21.1/ECR.html#embed%28filename%2Cio_name%29-macro)
You could do: &lt;%= ECR.render("template.ecr") %&gt; Or a bit more hacky but also more efficient: &lt;% ECR.embed("template.ecr", "__io__") %&gt; You definitely don't want to overuse this. It's important to understand what this does: ECR works by reading your template file, say `&lt;header&gt;&lt;%= my_site %&gt;&lt;/header&gt;` at compile time and generating crystal code from it like io &lt;&lt; "&lt;header&gt;" io &lt;&lt; my_site io &lt;&lt; "&lt;/header&gt;" So with this we're generating, for the first case something like: io &lt;&lt; ECR.render("template.ecr") Given `ECR.render` is a macro call, there's a new expansion round and it'll become io &lt;&lt; String.build do |__tmp| __tmp &lt;&lt; # ... whatever template.ecr expands to end `ECR.embed` skips the `String.build` but needs to know the io variable name to generate. (Hence also replacing the `&lt;%=` with `&lt;%`). A simpler solution might be to just define a struct or class for each of your templates and call them from the template: # stuff.cr struct Site ECR.def_to_s "site.ecr" end struct Part ECR.def_to_s "template.ecr" end # site.ecr &lt;%= Part.new %&gt; Note this generates essentially the same code as the `ECR.render` variant, but to me it feels like the least API abuse.
So it isn't exactly fit for html templating in even slightly sophisticated web apps, is it? I was excited about crystal having a built-in _compiled_ templating language. Disappointing :(
Wow, the shard docs are truly amazing! Nice job!
Oh cool. I thought I was the only one using DF
Im using DF with NodeJS, but i will migrate to Crystal...
That's cool. Is it a personal project or for work?
Work. u?
For a client, like a lead gen tool. Learning quickly that DF is easy to set up but hard to master. Contexts constantly jumping backwards. It's not super smart.
Yup. Thats true... But, as you say, its super easy... I think that it will get better (i hope)
Hey, u could contribute to the project ;)
If I ever use crystal and DF together I'll consider it ;)
Hi, im new here to using repl.it i wanted to know how to run specific file in repl. For example, by default it has a main.py when i create a python repl. Then i create a new file, name it to hello.py then i write print("from hello py file") and want to run hello.py so that it only shows output of this hello.py
You have to import it from the main file. Just do `import hello` and that will get it included and run it
As a long-term PyCharm user looking to move to Crystal, this is very welcome news.
Yesssss
Is it so? It was just move from one category to another. I don't think this means they'll necessary do it. So I wouldn't get my hopes that high.
Unfortunately you are right. According tot he ticket: \`We don't plan to add support for Crystal in the immediate future.\` Really sad.
Yeah, I guessed so. To be honest, I don't think there's a way to create an efficient IDE for Crystal, with stuff like autocomplete or docs on hover.
Bad news guys [https://imgur.com/PIEhPHBl.png](https://imgur.com/PIEhPHBl.png)
Actually... just for fun I might try to do something, we'll see.
You make it a snap! &lt;3
This is awesome.
Thanks!
&gt;So it isn't exactly fit for html templating in even slightly sophisticated web apps, is it? If it were fit for sophisticated web apps, it would have to have opinions on how web apps render, which is not the responsibility of the standard library. A language's standard library is for providing building blocks and, in that regard, ECR succeeds very well. If you want something that provides this functionality, it takes very little code to build. require "ecr" ############### Template "library" that provides rendering a template within a layout module Templates macro layout(name) macro render_template(to io) ECR.embed "views/{{name.id}}.ecr", \{{io}} end end macro template(name) macro content ECR.render "views/{{name.id}}.ecr" end end end ############## Usage example class Foo include Templates # Macros provided by the template library layout "application" template "foo" def render render_template to: STDOUT end end # Renders "views/foo.ecr" into "views/application.ecr" Foo.new.render &gt;I was excited about crystal having a built-in *compiled* templating language. ECR is every single one of those things. :-)
\&gt; and then a unique hash which I assume is stored somewhere in Facebook's database matching the image to an uploader. Ummm that's kinda a big leap. Perhaps they just want to prevent wasted resources when somebody attempts to upload something that has already been uploaded.
Not really such a big leap with Facebook's checkered past. Also, not all images are tagged in that way, so it's doubtful that it would be used to prevent duplicates.
Awesome! I was too lazy to do this myself. Thanks!