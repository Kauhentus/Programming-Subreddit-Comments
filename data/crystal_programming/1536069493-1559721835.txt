And v0.7.1 now, thanks for fixing the issue with the session cookie on logins ;)
that icon is something
Sure, nobody says it can't work right now. It probably just needs some extraordinary funding from a tech giant and a few thousand man hours of experts in WASM architecture, garbage collection and concurrency to get it done. Unfortunately, Crystal has only one paid core developer and a lot of pending tasks, many with a higher priority than supporting another compiler backend. So, it might just take a bit longer than Go...
Fast and mostly familiar. Though there are some completely unnecessary differences from Ruby that had me swearing (particularly the lack of single-line "if... then... end").
Are there any projects you are doing with Crystal now?
I used to be into Node.js, but it's not great when performance matters and it will never get a proper standard library. So I learned Rust, but at a time when it wasn't ready for production. Then I moved to Go, which I definitely like, but lack of generics and proper dependency versioning made me look for something else. So I looked into Rust again, but it's really hard to learn and I just couldn't get myself do to it. I've never done much Ruby, but there's not question that it's extremely optimized for developer productivity. It's also very slow though, I and I prefer compiled languages. So here I am, learning Crystal. My current project is a fairly simple web app backend. A few routes and some database CRUD, nothing special. It could be written in any language, but I chose Crystal because it runs fast and I can write it fast. It's the best of both worlds, even if it is a fairly small language at the moment, it has huuuuge potential.
I wonder if you have experience with Swift? I have done Swift on web development, the technical debt and complexity is definitely bigger than Ruby and Crystal 
Keen to see your benchmark if Crystal is faster or on par with C++
No, but my impression is that Swift is not really relevant or used much outside of the Apple ecosystem.
You can do `puts "Hello" if true` or is it just the difference?
I haven't yet. I'm a long time Ruby user and I mostly work on Rails-based apps. I've been closely watching Crystal's development. I have been wary to use it for anything that would need the ecosystem that Rails provides since things seem a bit immature at this point. However, the Lucky framework has me interested. What's the largest/most complex production app you guys have deployed?
It is not. Swift is vaporware outside of OSX &amp; iOS. 
While I curious you mentioned Crystal is immaturity in which parts?
No clear vision about how to solve compile times, parallelism, no windows support yet, small ecosystem, too few core developers, no 1.0 etc etc etc
For me, especially the lack of native paralellism is a killer. Process based concurrency only goes so far and 'proper' N:M scheduling of fibers onto OS threads would instantly make it much more viable.
Interesting, where can O read more about N:M scheduling?
Would it not be the same approach as a node app? Start n instances of the application using something like supervisord or templated systemd unit file. Then have something like haproxy or elb load balance to different instances of the application running on different ports?
See for example https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Scheduler for implementation details about how Haskell does it or https://morsmachine.dk/go-scheduler for a more high level information about how Golang does it.
Second this. However watch out for port starvation.
I was thinking about load balancing server that will work across different instances of Crystal 
There is a `reuse_port` option for `HTTP::Server`, so you can start server with: server.listen("0.0.0.0", 8080, reuse_port: true) And then use a simple shell script to start a required number of processes (Linux): #!/bin/bash for i in $(seq 1 $(nproc --all)); do ./server.out &amp; done wait
Thanks for your reply! After some discussion, we decide to use Crystal :)
A Mime Types registry is coming soon to Crystal, check this open PR: https://github.com/crystal-lang/crystal/pull/5765 In the meantime, I think your best bet would be to rely on something like `file`: https://stackoverflow.com/a/2227201
There’s also these related projects: https://github.com/spalger/crystal-mime https://github.com/jwaldrip/mime-types.cr https://github.com/Rinkana/Crystal-MimeTypes But, I doubt any of these do what you want them to do. 
Pushed a few fixes
&gt;Yeah, Go is obviously the much mature language that you should use on a serious project. Not to mention that a lot of companies already use Go, and its popularity would also mean that you either could find people to join your project, or find a job with your skills... If you're not one of those critics of Go's simplicity. I like Go's simplicity but I dont enjoy writing Go. Go is a boring tool that gets the job done. That's super cool and fine but I was looking for the Ruby feel and ergonomics that you can only get with a very few languages. I would say Nim is production ready for a very long time since it compiles to C/C++. There's a few companies that actively use it and there are some decent libraries. Of course it cant match Go's maturity and Google's financial support but it got the financial support of a medium sized company which is better at this point than anything Crystal has at the moment. 
It does compile to C/C++, which should make it production ready... but there are times that the transpiled code isn't consistent. You'll need to delete the \`nimcache\` folder to get things fixed. As someone in the nim forum pointed out: If the code generated is not consistent, how could I trust the output of the compiler for production-grade projects? Which explains why, even though it has all the needed features, [Nim isn't version 1](https://forum.nim-lang.org/t/2544#15793). Is Crystal any better? Well, at least it got a [roadmap](https://github.com/crystal-lang/crystal/wiki/Roadmap). Let me be clear: None of Crystal's features are unique, and most other languages can already do what Crystal aims to do. Would I use it for any production grade projects? No. Is it fun to use? Yes. I'd use it for my side projects and hobbys anytime... I mean, even with Ruby's well known performance issues, people still flock to ruby. The syntax is just really easy to get into, and clean. Crystal uses the same syntax as Ruby, with the added feature of it being performant due to it being a compiled language.
In my opinion, you should encourage a team to evaluate Crystal, Go and Python with a few small prototypes and determine their code complexity. Perhaps, if you need to scale with parallel computation, your team could contribute to Crystal since the core team have yet to implement. Cutting edge ML for the Crystal, I mean tailor Crystal for ML seem feasible than use a popular language that aren’t design for ML. 5 years is a long time but it’s depend on the decision maker and the team’s job scope. We all know Scala started as a language for academic but it became a steep learning curve, I wish I could learn ML with without difficulty.
Rinkana's \`Crystal-MimeTypes\` has basic support for byte pattern matching, it only includes some image types, HTML, XML and PDF though.
https://stackoverflow.com/questions/50456754/in-crystal-how-can-you-tell-if-a-file-is-text-or-binary/50486110
Use it.
Honestly. number one thing for me? More updates as to the status toward 1.0. Theres been no updates on the blog where things are since December 2017. I and others I know swore this would be the year but based on lack of general progress reports (releases don't give the picture) can't even say with confidence 2019. So knowing how things are progressing would be a big help.
Unless I am misunderstandng that has nothing to do with the language itself.
`var : T` declares a local variable. So a bug was fixed and now it gives a proper error. Use `@var : T` for instance variable declaration. 
What Crystal needs is a killer app. Rails was what drove Ruby to popularity, after Ruby reached a critical mass of course due to its own merit. I know there is a Rails-like project and that’s great. Not sure if that’s still the future or maybe something else is. TBH Rails started to feel like too much to me and started to skew to solutions like Sinatra. Or maybe Crystal could be great for desktop apps or video games, but it might be late for the party. Maybe not!
The release posts don't show up on the blog, you need to look at the release notes section at the bottom of the page
I just build everything in crystal now. If someone has a problem with that he can suck it. ^^/s
not talking about releases. updates as to progress similar to the post made in december 2017. What needs to be done how many projected man hours. No one wants to project dates but if its going to be 2021 before a 1.0 then people will lose interest. Manas projected 2017 which was an admitted mistake but many people thought for sure 2018 for sure. Will it be 2019? 2020? no one knows either in terms of date orhow much work is left. Life goes on other technologies and languages arise etc. Plus we know no ecosystem will reallly start picking up until 1.0. I know the community doesn't want to hear it and will down vote this post too but I know truffleruby will be ready within 6 months definitely a year so I will invest time in it. Asking people really engaged in real programming work to do it in Crystal when no one knows if a stable release is even within an 18 month time frame isn't likely to be successful.
Well I don't have a picture either. It's impossible to say since at the very least parallelism is still in the exploration phase not the implementation phase. I'm gonna say late 2019 at absolute best. The only way to help that is an order of magnitude more money, such as mozilla or google have for rust or go. Unfortunately that's the reality of this project.
I hear you but maybe thats the downside of open source for smaller teams. Maybe Manas would do better with a business model that brings in cash. I was once very excited with crystal as a ruby developer but what I need will mostly be addressed by Truffleruby. Technology developed too slowly runs the real risk of being overrun by even newer technology emerging that develops faster. I loved Crystal but now see a pretty good chance of it being outrun by something else.
If crystal is just about speed to most users then it was never going to succeed in the first place. Crystal to me is about type safety and usability. If crystal dies I won't be considering truffleruby, I'll be using go or rust because they, especially rust, provide far more "if it compiles it runs", considering 95% of my bugs are dumb typos or type errors. I also hate ruby's toolchain and dependency management. I hope more people than not in this community share my view, or I don't think crystal will be successful.
pretty sure you don't control reddit and what people may or may not comment on or discuss. This thread is about how to promote Crystal and how we can do better. It may offend you no end to hear that knowing whats going on with it would help to promote it but thats your problem not mine. The point is just common sense no matter how common sense in this application infuriates you. Its a testament to Manas that people are watching Crystal. NO slight on Manas in the least. Your ignorance of business motivations hardly means that its a judgement or complaining to suggest a business model incentive for Manas. They work a whole lot better than donations. Many open source initiatives have been financed because they have built in a business model (premium support, infrastructure, tooling, training). educate yourself rather than getting emotionally upset. &gt;For the look of your comments so far within that reddit group, I think that you take a lot for granted and don't understand the intentions of open source projects and what it takes to keep them alive Thats a perfectly stupid assessment to make based on reddit participation in one "reddit group". Actually fully aware of the intentions of open source and the challenges that go with it. Thats precisely why I made that comment. Open source projects without corporations backing often struggle based on the amount of work that needs to be done - particularly language level &gt; You have to a least understand that they don't owe you anything and who said they did? you are laden with illogical assumptions. this thread is about what would help promote Crystal. So if I say that knowing where the project is at in regard to 1.0 every six months it means I think Manas owes me anything? I didn't even say such an update would have to be written by Manas. think before posting. I certainly hope your views are not the views of Manas or the community because it is an awful sign when a open source project community states that because its open source keeping the community informed is a taboo suggestion &gt;it would help if you could talk less about you and what you want and more about what this thread was about: how to promote Crystal? well you might henceforth consider that for yourself or continue to be a hypocrite since you posted what you didn't think would work, what you think is helpful and your assessments about others which is in fact - all about you. again in a post about what would promote Crystal - if letting people know where Crystal is in regard to where it is going doesn't help in your mind then thats a problem in and only in - your mind. Its just common sense. promote means you want people using it who are not disposed to using it already. I know many wanting to use it but not willing to jump in because they don't know when it will be stable. How can it not help to promote if you let people know where things are? Your objections to that are vastly silly. Even RX stating he thinks late 2019 helps. It gives a time frame thats more realistic (without locking in any date).
/u/patleb and /u/Mike_Enders, please keep it civil. Now's the time to stop this comment thread.
the reason there's no update is because the update would essentially restate the roadmap: windows and parallelism I'm working on windows and it's progressing well but nothing usable by average end users yet. Parallelism has recently had a lot of exploration, there will likely be good news for this by the end of the year. Even after the roadmap is notionally complete, there will be a lot of feedback and refactoring required before we can be comfortable releasing 1.0
Thank you! I'd say that I should have noticed it but I probably would have stared at it for hours.
Patleb to clear the air of some very false assumptions and leave it there. 1)I do not agree with you that stating an update from time to time is not constructive. It helps in all open source projects nor do I buy your assessment of post history as its total nonsense. 2) I Never asked anyone to speed up their work. Thats a lie. Nothing about speeding up their work or them needing to inform me of their progress (the community can handle that - I don't think any core team member should bother with that so you are dead wrong -and to the whole community) . Mentioning the blog in no way shape or form means that the team should post updates. Others have posted to the blog. 3) You seem pretty young and emotional. so its you not understanding not me. Business model does not at all in an open source project mean dropping existing business models. The things I listed are quite common - and YES - they are ways in which the community helps to pay back a programming team.... by ordering paid support, using their hosting infrastructure , training etc. I'd be very surprised if Manas didn't do that down the line. its EXTREMELY common in open source Like I said if this attitude is part of the community of Crystal's ethos - don't dare ask for updates from anyone or you are disrespectful you will drive a lot of people away from Crystal
More than done. Nothing to add anyway
Last post in this thread as I get the impression unless you are in total fanboy mode the natives will get antsy. This is what I was referring to [https://crystal-lang.org/2017/12/19/this-is-not-a-new-years-resolution.html](https://crystal-lang.org/2017/12/19/this-is-not-a-new-years-resolution.html) excellent post - that just states an estimate of hours left. One of the best posts I have seen that didn't remotely have a timeline. It let people know what was going on with no claim to be speeding up or owing anybody any dates. I do not see the sin in suggesting that updating that every nine months helps to promote Crystal (not that you were saying that). &amp;#x200B;
That's quite surprising to see how someone emotional saying that someone else who isn't showing any particular emotional reply is emotional... do you see a pattern here... projection maybe? I doesn't really clear the air (and I don't see how you could think it does), you're attacking me again and twisting what I'm saying. You just fail to understand the point of my comment: you were being insensitive and this is not something I tolerate, so I called you out. I'm not here to educate you and I looks like there is not much more I can do to help you deliver your message without being offensive. On my part, I see that there is something that I should not have said: &gt; it would help if you could talk less about you and what you want and more about what this thread was about I'm sorry about that, it was out of line. For the lying part, you pretty much did the same kind of comment in this past crystal [thread](https://www.reddit.com/r/crystal_programming/comments/8jpkab/parallelcr_parallelism_for_crystal_as_a_shard/) which proves that I'm not lying: &gt; Why be doing experiments like this now rather than putting the time into core Your discourse is transparent and I'm merely suggesting to respect the effort that have been put into this project and trying to understand how asking for more could be seen as insensitive. Now, I don't see how this could not be offensive for a company that is purpose is to make money: &gt; Maybe Manas would do better with a business model that brings in cash. How could you know if Manas isn't bringing enough cash or their business model isn't what it should be? This is pretentious and offensive to the people who run and make the business decisions at Manas. Regardless of how you think my answers could affect the community, it would have been the same in any circumstances. It just happens that I read what is going on with Crystal on reddit. Sorry [RX142](/u/RX142) for ignoring your comment, I had to answer to this comment and I'll stop as soon as there is no more attack against me.
No, you're both going to stop right now. Its perfectly fine to leave any perceived personal sleight unanswered. Locking this thread.
&gt;like Go's simplicity but I dont enjoy writing Go same here bro. Cannot stand writing Go.
Nice! had no idea there was a sidekiq crystal implementation.
I would argue Nim's generated C code is good enough for most use cases. I would argue it's "consistent" enough. Nim is perfectly fine and usable for what it is.
Because I assume the cost of a single person for this task to be at least 100k/ pa
Hi there :) &amp;#x200B; The "generic" Crystal Bountysource you mention is actually \_really\_ used for that. @bcardiff's job here at [Manas.Tech](https://Manas.Tech) is almost 100% working on Crystal nowadays, thanks to the money we get from the BountySource. That money allows Manas as a company to allocate him to work on Crystal instead of working on our client's projects. Should the BountySource income keep growing, we will allocate more people to work on Crystal instead of working on other projects. &amp;#x200B; So \_yes\_, you could create a new funding to get people outside Manas to work on Crystal - but the one that's currently there is not for anything different at all :) &amp;#x200B; Hope to have clarified the situation a bit 🙃
Depends on who you are going to hire and why. Just beware hiring people is expensive especially people who are good at crafting compilers, people who truly understand multi threading, people who can port a giant lib to windows, people who know garbage collectors etc.
There are other options. If crystal i good at producing small project, as long as those projects can be even shared library, then the language become usable for large scale projects. I would be happy to have the option to build shared libraries, and also to transcode to C.
congrats really loving Amber
BountSource++
Thanks for the answer. I am not sure if people were aware of this as it is not very transparent...at least I was not. 
Fixing your links: * [Website](http://lupincr.com) * [GitHub](http://github.com/lupincr/lupin)
Proud contributor for about six months now. 👍
Thanks. I feel like having to clone the repo down cd in there, and run a file from there then delete the rest of the repo would be too many steps for a simple installation method though.
Well, that's reasonable. I didn't know how the application is packaged, so I was actually just spewing ideas, sorry.
Hey this looks neat, but the website doesn't explain anything, and the github lacks examples too IMO. Personally I don't get the relation between gulp and a programming language like Crystal. Maybe could you compare with a Makefile, or Python's Fabric, Ruby's … ? Regards.
From a database you can create a transaction. If no exception happen in the block, the transaction is commited. ``` db = DB.open "mysql://..." do |db| db.transaction do |tx| cnn = tx.connection cnn.exec "..." end end ``` Otherwise you can manually execute `tx.commit` or `tx.rollback` inside the block to explicitly commit or rollback. Also, nested transactions are supported. Definitely a new nicer introduction can be given at https://github.com/crystal-lang/crystal-db/blob/master/src/db/transaction.cr . Feel free to send a PR! 
Cool! Nice interview!
I will update the article and write more on the subject as I learn more about it! Thanks for the educational response.
Why do you recommend people to upgrade to bionic just to install Crystal? Upgrading in general is not a bad idea, but it's by no means a requirement for Crystal. It can be installed as well on precise, trusty or xenial. I fear this advise is misplaced as it suggests that Crystal could only be installed on bionic.
I have never used \`crenv\` and don't see much need for using multiple Crystal versions at once. Even if it's constantly developing, breaking changes are pretty rare and it's by fat better investing time to update all code to be compatible with the latest release. Such, I mostly use the latest release as \`crystal\`, and sometimes the nightly build as \`crystal-nightly\`. Occassionaly I have some custom builds but they're just addressed by their absolute path. There might be valid use cases for \`crenv\` and it would surely be great to have a guide on installing and using it. But I would leave it for another article, because it's a separate topic from just installing Crystal on Ubuntu.
Not upgrading... Having several versions of Crystal installed using crenv,... or docker containers should work, too
Breaking changes are usually pretty rare these days and require mostly very simple refactoring. If the upstream repository misses the update, you can just implement it yourself and send it as a pull request. And use your fork in the mean time until the update is merged. Sticking to older versions of Crystal doesn't help in the long run, as they will become outdated very soon. I'd rather try to keep everything up to date as soon as possible. That's a better investment than switching Crystal versions.
&gt;That's true but for experienced Crystal programmers. For a newbie like me, I tried Crystal a few times and crashed horrible because I wanted to use some library like crfml or crystal-gobject and they were broken after some lang. version, even with popular ones like kemal. My fault, of course, because I don't like to learn the language alone and then start adding shards. I did some bug hunting &amp; reporting but that's not funny at all. I like to test bindings for cool stuff and for that I need to have installed the corresponding Crystal compiler for each project. This is not a Crystal issue, the same happens to a lot of languages I play with (Ruby, python, elixir, lua (luajit vs interpreted!), node!) and for this reason I use a multi-language version manager like anyenv or asdf. It's ver easy to switch and manage all of them with same interface and installed in my $home.
Yeah, for that use case, it's totally fine. But typical developers (experienced or not) don't rapidly try out new (and old) stuff which needs them to constantly switch between different Crystal versions.
Purchased!
[quicktype now supports Crystal](https://app.quicktype.io?share=lriue1bPALoW05EvJOW3), contributed by [Anton Maminov](https://github.com/mamantoha). quicktype generates Crystal types inferred from JSON, or from JSON Schema or TypeScript inputs. quicktype also has a [CLI](https://blog.quicktype.io/quicktype-multiple-samples/), as well as a great interactive [VSCode extension](https://marketplace.visualstudio.com/items?itemName=quicktype.quicktype). Please let us know what you think, and consider contributing!
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://blog.quicktype.io/quicktype-multiple-samples/) - Previous text "CLI" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20e6bo1gm) 
what percentage of the content do you get, as it is stated to be a beta ebook for now?
I also agree, but I'm not suggesting this as a wish list feature. They're at a critical point right now. The longer they can go into development, the harder it will be to implement these features. Likely, if they push 1.0 without these features, they'll never be adopted. Which I would see as a huge loss. Java is still major language in web development and Crystal could be the language to replace it, but it needs features such as these to be the front runner.
Could you provide an example? Because when child objects inherit from parents, they don't have to change the behavior of their parents. In fact, they should not change the behavior of the parent. This is a violation of the Substitution principle and is a bad design practice. The child should instead encapsulate the parent through a Has-a relationship. Doing otherwise will introduce bugs into a system that are difficult to root out and makes the system very difficult to reason about. Directly accessing fields does break encapsulation and also violates composition so that is also a bad design principle. The use of protected methods doesn't break encapsulation. It's a type of limited public accessibility. But ultimately though, I'm not asking for an Is-a to be cast to a Has-a. I'm asking for OOP languages to implement Has-a Inheritance in a way that doesn't require a large amount of unnecessary wrapper methods and to prevent violations of the Substitution principle which come from overrides. As developers, we already do the latter by hand. Why not have a language do it for us? I also really like Haskell and my understanding is that Haskell has inspired a lot of the work that's been going into languages like Go and Julia. Part of what makes Haskell great is that you can reason about many of your objects because, as you said, the only real relationship is "x behaves like this". OOP is meant to have this and also "this is true of x". But both of these relationships cannot be held always true of x so long as "y subclass of x" can be substituted for x and "y doesn't behave like this" and "this isn't true of y".
It's extremely common to implement the "rule of thumb" in a base class and override for a necessary subset. Calling this "wrong" ignores that it's frequently the tidiest feasible solution. To use the ever present example of animals - imagine one has a Mammal class and part of some breeding stimulation you have giveBirth(). Your simulation shipped, all is well until some Aussies want to add an Echidna. Well, they're a Mammal but lay eggs. Your choices are (1) refactor the existing Mammal class to split it in to Monotremes, Placentals and Marsupials, changing all the existing subclasses to descend from one of those (arguably correct, but often massively disruptive, especially for authors of public libraries), (2) ignore the real-world is-a relationship, smack in a sibling to Mammal and reimplement stuff or (3) override behaviour. Guess which comes out as the lesser evil? Anyway, before designing any type system I would encourage you to consider changes after initial design, and how you deal with locked hierarchies you can't change. Too much academic consideration of type systems only pays attention to green fields design.
Crystal don’t have to replace anything, it should encourage newbies and experience to adopt and solving technical debts without much effort.
I agree with how the language should be adopted. I just think that, like most people here, Crystal is a turning out to be a really great language. It can be a great way to address technical debt and many other things. Fixing OOP would be another good way to address technical debt because it would allow developers who are using Composition to reduce the size of their codebase.
Thanks for the example. That's a good one to think about. I still think that this is essentially the same argument that has been coming up in my development for years. It's difficult to do X, so let's just do Y instead, when doing Y requires violating the Substitution rule. I understand strict hierarchies, but it's better to understand why a hierarchy is strict, than to just insert something into that hierarchy with overrides. Going back to your example, the Echidna poses a problem, only because Mammal, as you've defined it, is something that gives live birth, i.e. it's a strict hierarchy of creatures that give live birth. The Echidna doesn't give live birth, so therefore it shouldn't be in the hierarchy of things that give live birth. Now, it might have lots of fields and methods in common with your creatures that give live birth so you could implement a Has-a relationship. But it doesn't make sense to place the Echidna in mammals since it could then be treated as a creature that doesn't give live birth. But also, once you realize that your hierarchy is strictly creatures that give live birth, you can institute an abstract class above mammals that branches into the Echidna which is also a correct solution and a very good one. Strict hierarchies provide a lot of benefits towards testing and development and they're a big reason why OOP is so good for implementing large scale projects. Compromising that with overrides only weakens the foundation and makes the project more difficult to maintain in the long run. I mean think about it a quarter of the developers at a company did this. A company with 200 employees would have 50 overrides that would all be exceptions to the rule, would have be documented, and each time you wrote code, you would to check to make sure you weren't dealing with the exception. What about 1,000 or 10,000 employees? That overhead is unmaintainable. I am an academic. But these ideas of mine have been developed strictly outside of academics as a part of my experience being a developer, and I think that it's something that concerns all of us.
I see the best is you could bring up your proposal with a few code example in Crystal repo and get the maximum visibility to see what will happen, not all devs are into this reddit group but they will first visit the Githib repo. What do you think?
I had to write a hierarchy of Stream classes in Rust a while ago (think Node.js streams with piping, etc, but in Rust, and with gzip and crypto variants, etc). The lack of data-based inheritance made this process extremely awkward if not impossible, and because of other issues with borrowing I eventually moved this to Crystal and was able to implement the whole thing in 3 hours (vs 3 weeks of getting nowhere with Rust).
People also aren't forced to use OOP in crystal, but it's there if you want it.
I think that's a really good idea. Part of why I posted in here was to see what the community thought before I brought it to the devs. I really appreciate you (and everyone else) taking time to comment on this post.
That's awesome! I'm really glad you were able to do that. It's such a good feeling when languages speed up development time.
It's okay for them to have different implementations of various methods so long as they overload or so long as the Car doesn't have those methods. The Is-a Substitution principle is only violated when the sub-classes override and change the behavior of the overridden method. For example, let's say that we have a Car abstract class and a BMW and a Mercedes that extend from Car. Let's say that there is a drive() method on Car that you want to override in BMW and Mercedes. To do this and be correct, you should declare that drive() is abstract. An abstract method doesn't have behavior, so while it is technically overridden, the behavior of the Car hasn't changed because it didn't have any behavior before. What wouldn't be correct is to implement drive() on Car, and then override drive() in both Mercedes and BMW. This would be a violation of the Substitution principle because the behavior of Car would be fundamentally changed by BMW and Mercedes. In this case, you would have a BMW which is Car, but doesn't drive like a Car. That wouldn't make sense, and would create an exceptional case that future developers would have to remember and deal with every time they use the Car class.
That's a good point. Crystal can be strictly procedural, but most procedural code in Crystal will make use of Objects which is another reason why it's important for Objects to obey the Substitution principle. It would be awful to write procedural code which deals with Cars only to have a method return a list of BMWs and Mercedes that don't behave like a Car.
I get what you are saying but I still disagree. Having a default implementation that can be overridden is extremely useful. It might make sense, though, to add a permission modifier to methods making them unoverridable.
Use "[Sign in via GitHub](https://api.crystaljobs.org/oauth/github/init)" button on the website to add yourself in the list. Note that all entries are pre-moderated.
it will be nice after some site improvement &lt;3
Can you be more specific please?
I should add "Jobs" section as well, so companies coudl post their entries...
this is...pretty freaking awesome!!
@proyb2 How did you compiler and run benchmark? These are my results: $ crystal build bf.cr --release -o bin_cr --no-debug $ time ./bin_cr mandel.b ./bin_cr mandel.b 29.51s user 0.65s system 88% cpu 34.016 total $ go build -o bin_go bf.go $ time ./bin_go mandel.b ./bin_go mandel.b 73.26s user 1.05s system 92% cpu 1:20.18 total My environment $ crystal -v Crystal 0.26.1 (2018-08-27) LLVM: 6.0.1 Default target: x86_64-apple-macosx $ go version go version go1.11 darwin/amd64 
Thank you!
Oh, have retested and found I made a wrong timing, but crystal is still slower by few more seconds. You have use a newer code for Go? [https://github.com/kostya/benchmarks/blob/2bcded9f593737dd9665a2145e79f6076f923636/brainfuck2/bf.go](https://github.com/kostya/benchmarks/blob/2bcded9f593737dd9665a2145e79f6076f923636/brainfuck2/bf.go) &amp;#x200B; Crystal BF2 real 0m36.617s user 0m34.047s sys 0m0.731s &amp;#x200B; Go BF2 (Original) real 1m32.816s user 1m26.388s sys 0m1.413s Go BF2 (Improve) real 0m33.100s user 0m31.020s sys 0m0.679s &amp;#x200B; &amp;#x200B;
So would you even recommend learning it?
If the fact that it's a new language still in development doesn't bother you, by all means go ahead.
Well, you can do a lot with Crystal. Since there are C bindings in Crystal, you can use literally thousands of C libraries in Crystal. Graphics libraries, encrypting libraries, algorithms, frameworks, GUI libraries, networking libraries, math libraries etc. You can use all these libraries with all its functions: [https://crystal-lang.org/api/master/](https://crystal-lang.org/api/master/). There are over 3500 shards you can use in your applications: [https://crystalshards.xyz/](https://crystalshards.xyz/).
Can I ask if your mmo has a public server or git page?
Btw, does Crystal support Windows? I've been wanting to try it. 
&gt;\+ if @pos &gt;= @tape.size \+ @tape.concat Array.new(@pos - @tape.size + 1, 0) &amp;#x200B; Great! It's faster than Go by &gt;2 seconds. I knew "while" is slower but the code could be made more readable as a "while" replace if possible. real 0m30.722s user 0m28.911s sys 0m0.528s &amp;#x200B;
Kinda. Not 100% support, but it's getting there. Give it a shot and see how far you can get. 
Will do. Thanks
It doesn't because it's not *my* mmo and both servers and github repositories for it have been forced to close before on copyright grounds.
I really wish there was a gtk3 binding for crystal.
I think I should change the name. I've called like that because the initial purpose was to serialize/deserialize simple settings object into easily editable files
What would be some use cases for a library like this?
Awesome!
Think about this: You have an application which connects to a server, on the first run you set all the attributes from the application (e.g. the server's address, the maximun number of retries if the server is unreachable), then these settings are persisted on a file (say `~/settings.cfg`) which is easly editable by your editor of choice. OR You're writing a daemon which, by default, has some settings that have to be persisted/loaded/modified but you don't want to write something else to set those settings 
This is great, Thank you!
Perfect thanks!
The JSON macros deals with strings: it loads an objects from a JSON string and serialize objects to JSON strings. This little tool also writes/reads to/from files
Oh that's useful
Oh that's useful
Anyway I'm planning to write others formats for serialization (JSON, YAML, maybe XML). So feel free to contribute to this project by forking/opening PRs or simply by opening issue and discuss about the project.
Have you looked into Amber? I quite like it since I come from a Rails background.
Lucky Framework is also worth checking out for sure.
Random-framework-I-want-to-promote is good too ;)
socket.send always returns instantaneously, so the question is not really applicable. [more details](https://stackoverflow.com/a/17420228)
Was reading that thread some more, found this: https://stackoverflow.com/questions/5407182/blocking-sockets-when-exactly-does-send-return#comment50590424_5427819 so basically, if you have enough space in the kernel buffer, they will write and not be blocking (if i got that right) 
Correct.
You shouldn't try to make it impossible to do something just because you don't like it. If that' show you feel go and design your own language based on SOLID principles. There are actually plenty of crystal-like languages that compile to crystal, so there is always that avenue. 
I may not have been representing my position well, but I'm not proposing this feature because I have any issue against overrides. Programming languages are tools to write software, and as such, they are designed to support the features that we as developers need to write good software. Part of that support comes in the form of assisting developers in implementing and enforcing good design principles. The SOLID principles are a set of principles that are very common in software engineering --- especially in web development, which is a critical focus for Crystal. This feature is a good feature for Crystal and will make it a better language for the web developers (and other developers) that will be using it to write software.
Do you know ruby and rails well? if not then learning Ruby well will help you dramatically with Crystal. Given some of the things you have been through My fear for you is that you spend too much time on Crystal before its ready to pay financial dividends. Ruby still pays well and its like learning two languages in one (but of course significant differences as well)
I do not know RoR that well. I appreciate your concern and will definitely take this advice. I enjoyed Ruby when I used it before. 
Implementing proper OOP isn't the same as just removing support for overrides. In most cases, overrides are supported as a default implementation as OOP. In order to actually enforce the Liskov Substitution principle, Crystal will need to implement a more complex Type Hierarchy. One that can support the notion of both Is-a and Has-a relationships (currently Has-a isn't supported in the Type Hierarchy). It will also require changing the implementation of the dispatcher, so that the dispatcher can correctly navigate Is-a and Has-a relationships. The benefits of this implementation are numerous. Not only would we have a safer and more intuitive implementation of OOP, we would also have an implementation of OOP that will allow for a wider range of object relationships. That's huge! I'm sure there were plenty of people from C and C++ who looked at Rust and said, "Oh, your feature is just that you're removing support for pointers?" They did that and more and now Rust is benchmarking better than C/C++. Enforcing proper design leads to more readable code, simpler implementations, and better performance. This feature would do all of that for Crystal and more.
Done! :)
If I had to do something like this, I would probably use [Kemal](https://github.com/kemalcr/kemal) for this. The README in the link I posted has a lot mor information, but as an example you could do something like: require "kemal" get "/mysite/MyHTMLFORM" do "Hello World!" # could also serve a file or call into additional methods end post "/mysite/MyHTMLFORM" do ... # put your form processing code here end Kemal.run You can also use other HTTP methods like PUT and OPTION, if you define the handlers for them. I personally do not have any experience with TCL, so maybe I misunderstood your question. Please let me know if this answered your question sufficiently or if you have more questions. We're happy to help! :) 
Yes, the serialization format can be changed, the idea that I really like is having one single object to deal all the serialization/deserialization without having to setup other things than the path to the persisted file
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programminglanguages] [\[x-post \/r\/crystal\_programming\] Could Crystal save OOP?](https://www.reddit.com/r/ProgrammingLanguages/comments/9l65ah/xpost_rcrystal_programming_could_crystal_save_oop/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Its hella fast. I love it. Personally, I think that it is not great for newbies. I use it for writing general purpose applications. It is way faster to write than C/C++. I would not use it right now for a web application, even though I want to, only because there are not a lot of stack overflow threads on it right now, so when you encounter a complex problem you are kinda stuck in most cases, or have to do a lot of digging in the API documentation. It really helps though to learn Ruby first, which is much more forgiving and to have a little bit of knowledge with compiled and statically typed languages before you jump right in. With that said, I think it should be used as much as possible once you learn it, because of its speed and its syntax. In the future, I hope to create a web app with the amber framework when they both evolve and become more documented.
You can also do crystal eval from the command line e.g. `crystal eval 'puts "hey"'` If you are using amber framework, you can use the \`amber exec 'crystal code here'\` feature to execute code within your application's environment. But yeah beyond that and what you already mentioned there isn't much. It's a compiled language so this stuff is a lot harder.
Is there a way I can make my script not terminate at the end, then use the eval command to inspect my variables?
How about this? https://github.com/madeindjs/Crystagiri/blob/master/README.md
Currently there is no built-in way to "inject" yourself into a running execution state, and since crystal is a compiled language, this would be extremely difficult to do. I think it will eventually happen though post v1.0.
I've used this quite a few times with very good results [https://github.com/kostya/modest](https://github.com/kostya/modest) Gives you the ability to search with CSS selectors and the likes
Currently, SG is one of the fastest web frameworks out there and a lot of its speed due to to its ability to use multiple cores. Stephen von Takach, a maintainer of SG has a nice write up of how they executed clustering in the framework. I hope that this would be great for some folks who are putting out their webapp.
Bit late to the party here, since I came from the r/programminglanguages crosspost, but... No. Just no. Let's put aside whether or not Crystal should be the language to do this for a bit, and focus on whether this should be done at all. Short answer, it shouldn't. Ever. Let's use a real-world example - cats. Everyone loves cats, right? Good. Let's say you have a `Cat` class, and you want all your cats to have a method that gets their fur color. There's no "default" fur color that would really be logical, so you make it an abstract method - you want to ensure every kind of cat has this method, but each one will have a different answer. Cool, your system works - but so does OOP as-is. No benefit, no drawback... yet. Now let's say you want a method that returns the sound of the cat's meow. The logical default here is just that - `"Meow"` - and most cats don't actually need to override that. Only a select few cat breeds have distinct enough meows to bother, after all. So you add a base implementation that returns `"Meow"`, and a couple of overrides for that where they're applicable. Suddenly, you have an odd compile error on your hands - this works in every other OOP language you know, but for some arbitrary reason, you can't do that here. Cue immediate frustration, and no good way to solve the problem. I think the fundamental problem with your idea is that you misunderstand the purpose of the substitution principle. A child class does not have to be a perfect substitute for it's parent class in terms of *result values*, but rather in terms of *type signatures*. When you call the `getMeowSound():String` method, no one who's ever used an OOP language would expect it to always return `"Meow"`, but they do expect it to always return a string, and rightly so. What you're suggesting in many ways defeats the entire purpose of using OOP in the first place, by making inheritance completely pointless - if you can't reuse code from somewhere higher up the chain with slight contextual modifications, then you've lost about 90% of the reason for that chain to exist. Furthermore, what you're suggesting isn't really composition, as you claim it to be. You've created for yourself some strange, ugly abomination that tries to combine inheritance and composition in a way that gets all the bad of both and very little good from either. Allow me to explain. When you're dealing with an is-a relationship, you're dealing with something like cat breeds. A `Siamese` is a `Cat`, and so is an `AmericanShorthair`. The problem comes when you start adding things like `Whiskered` to the mix - while it's true that a `Cat` is `Whiskered`, it often doesn't make much logical sense when you're trying to deal with it in those terms. So instead, we add a `whiskers:Whiskers` field to `Cat`, and we can now say that a `Cat` has `whiskers` instead - it's now a "has-a" relationship, which is much more logically consistent with what our system is trying to model. In other words, we've switched from inheritance (is-a) to composition (has-a). There is no parent-child relationship between `Cat` and `Whiskers`, and the two are not intrinsically tied; we have simply stated that one of the things that `Cat`s have is `Whiskers`, which could just as easily be a `Tail` or `Claws` without changing anything about what a `Cat` fundamentally is. What you're suggesting is not composition; rather, it's a mangled sort of inheritance that in the process entirely defeats the purpose of using inheritance in the first place. There is now an intrinsic link up the chain in this weird, convoluted, impossible to reason about way, that wouldn't need to be there at all if you'd just left things alone. Suddenly, not only does your child inherit almost pointlessly from the parent, but it also composes in the parent as well, creating this strange cyclical relationship that just doesn't have any logical reason to exist other than to solve a contrived problem that already had a much better solution. Frankly, I hope this idea disappears quickly and silently, so that we can all move on and never have to think about it ever again. Congratulations, sir/madam/otherwise, you have successfully created the most hideous monstrosity to ever call itself an improvement on the principles of OOP. TL;DR, I cannot fathom any other explanation for you thinking this is a good idea than that you don't have a shred of a clue about what makes OOP work. Please never try to make this a thing. Have a nice day =)
I think you can do something similar with Kemal. Is that correct? u/sdogruyol
Thanks!, Exactly what I am after. 
I'm pretty sure I remember this already being brought up. Its not included in Kemal becuase its really easy to do yourself and outside of the scope of what Kemal provides. I'll let Serdar answer though.
They are using multiple cores in the techempower benchmarks.
Also possibly helpful: [Selenium webdriver for Crystal](https://github.com/ysbaddaden/selenium-webdriver-crystal/blob/master/README.md)
Thank you! I think I am going to go with this route. Do you what would be the best way to find the inner text of a div element with a specific id, rather than iterating through each node?
Thanks for sharing. I've read over this a few times and after doing so, it seems to me that you haven't presented my position correctly. If you don't mind, allow me to address your examples and then provide a few new examples of my own. &gt; A child class does not have to be a perfect substitute for it's parent class in terms of *result values*, but rather in terms of *type signatures*. When you call the `getMeowSound():String` method, no one who's ever used an OOP language would expect it to always return `"Meow"`, but they do expect it to always return a string, and rightly so. I agree. My proposal doesn't change the approach here because this is valid. &gt;we can now say that a `Cat` has `whiskers` instead - it's now a "has-a" relationship, which is much more logically consistent with what our system is trying to model. In other words, we've switched from inheritance (is-a) to composition (has-a). There is no parent-child relationship between `Cat` and `Whiskers`, and the two are not intrinsically tied; we have simply stated that one of the things that `Cat`'s have is `Whiskers`, which could just as easily be a `Tail` or `Claws` without changing anything about what a `Cat` fundamentally is. I agree with this as well. This is correct way to compose `Cat` and `Whiskers`. My proposal doesn't alter the approach here either. Neither of the examples that you have provided here address my proposal. Let me explain why and I'll elaborate more on my proposal. Your first example uses that of a `Cat` which could be subclassed into both the `AmericanShortHair` and the `Siamese`. The inherent problem with using `Cat` as a contrary example here is that a `Cat` is a category of Objects which we would define as an abstract class, not a concrete class. As I stated in my proposal, abstract methods can still be overridden. Thus, having the `AmericanShortHair` and the `Siamese` implementations both implement `getMeowSound()` differently, but with the same type signature, is still the correct approach within the context of my proposal. My proposal addresses the situation when behavior is defined on a concrete class that is then overridden to make the behavior distinctly different. For example, let's say there is a concrete class `Integer` which implements the method: `add(Integer x) -&gt; Integer`. The behavior of this method is that it returns the sum of `self + x`. If we were to write the following code: `new Integer(4).add(8) # 12`, the result is 12. However, what if we then write a subclass of `Integer`: `WildInteger` which overrides the `add` method. `WildInteger` has the `add(Integer x) -&gt; Integer` which returns `self * x`. Therefore, with `WildInteger`, the following code: `new WildInteger(4).add(8) # 32`, would produce 32. I then define a function `foo(Integer x) -&gt; Integer` which takes x and returns a copy, but it is not known whether the copy will be of type `Integer` or of type `WildInteger`. What is the result of the following code: `foo(4).add(8) #` ? The answer is non-determinable. Since `WildInteger` is a subclass of `Integer`, it can be substituted for `Integer`. Therefore, it is valid for `foo` to return a `WildInteger` rather than an `Integer`. This is substitution. Because this is allowed, any type signature which returns an Object type can return that Object or any of its subclasses. It is for this reason that OOP is often referred to as a *"data abstraction, not behavior abstraction."* However, classes are meant to be behavior abstractions. If the Integer has a defined method add which is meant to return a sum, then all Integers should return a sum when add is called. My proposal is to enforce this by prohibiting the override of any method which is not-abstract. The result would be that the compiler would throw an error when `WildInteger` attempts to override the `add` method defined by its parent class `Integer`. Either, `WildInteger` should not override `add` or it should not be a substitutable child of `Integer`. \*\*\*As an additional side note, I've been refraining from saying this because I don't know everyone's mathematical background, but if you haven't taken Modern Algebra, I would highly recommend taking some time to review Groups and Rings. Groups are the mathematical basis of Classes, and they are essentially a behavioral abstraction. Understanding Groups will help you a great deal to understand how Classes should be implemented.
&gt; My proposal addresses the situation when behavior is defined on a concrete class that is then overridden to make the behavior distinctly different. This is the same situation I was addressing with the `getMeowSound` example - a concrete base implementation, which is overridden by one or more subclasses. It is perfectly logical in that situation to define a default behavior on `Cat` itself, which only the applicable subclasses then override - for example, for `Cat` to define `getMeowSound` as returning `"Meow"`, and `Siamese` to override it to `"Mrrow"`, while `AmericanShorthair` does not need to touch the method as it's desired behavior is the default. Discussion about whether `Cat` should be abstract aside, it's hard to deny that the ability to have a base implementation is quite important here, especially as more and more subclasses start to pile up - I'd much rather be able to have a sensible default than be forced to implement the method on every single child class regardless of if I needed to change anything. Your method seems to violate DRY so badly it's appalling, all in favor of stripping out something that isn't an issue in the first place. &gt; However, classes are meant to be behavior abstractions. If the Integer has a defined method add which is meant to return a sum, then all Integers should return a sum when add is called. My proposal is to enforce this by prohibiting the override of any method which is not-abstract. Classes are not meant to be behavior abstractions, or they *would* be behavior abstractions. What you're looking for is a use case that is completely covered by [dependent typing](https://en.wikipedia.org/wiki/Dependent_type), and the solution you've come up with is far less flexible and useful, removing valuable options instead of adding new ones. Simply put, the situation you refer to as an example for why your system is necessary is *not* a problem that can or should be handled by the compiler - it is a naming issue, nothing more. If you want to be able to enforce `add` returning the sum of two integers, you should look either to dependent typing or to a strict style guide, not to a fundamental reimagining of the paradigm. &gt; And to address your TL;DR, I'm already designing a language which takes this approach to OOP. No, it's not hideous. It's actually a really powerful approach. It has simplified a number of features for my language. I'm even putting material together to start a blog. I'm sorry that you don't feel the same way, but please don't hate on it until you've seen what it can do. I wish you luck in your language implementation, but I will warn you that I seriously doubt it will see any major adoption, especially considering it conceptually revolves around such a radical change to the basic principles of OOP. I wouldn't get your hopes up that you will "fix" OOP, and most likely what you create in this area will end up little more than an interesting experiment in the grand scheme of things. Apologies if I've been somewhat overharsh; it's a bad habit of mine. Have a nice day =)
**Dependent type** In computer science and logic, a dependent type is a type whose definition depends on a value. A "pair of integers" is a type. A "pair of integers where the second is greater than the first" is a dependent type because of the dependence on the value. It is an overlapping feature of type theory and type systems. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/crystal_programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Mm if there is js logic that change the Dom structure then I think you need to reproduce that environment, nowadays I think it means using something like a headless browser (phantomjs, Chrome, Firefox in headless mode) 
I am developing a web application with Lucky Framework. kemal / [run.sh](https://run.sh) is also likely to be used in Luckyframework. &amp;#x200B;
Well, it's not just weather. In the future, I would like to be able to do this for other things that google gives you.
Ah gotcha.
I was trying to get Native Debug work with Crystal. Even though breakpoints and stacktraces were working fine, I was not able to get local variables working. 
Kemal had \`reuse\_port\` support for a long time, there's even a recipe in Kemal Cookbook [http://kemalcr.com/cookbook/reuse\_port/](http://kemalcr.com/cookbook/reuse_port/)
I'd stick to using Google APIs or another one. Scraping Google webpage data for information "you are going to have a bad time". As it has limitations, limiters, bot detection, etc. 
Thanks! I will check out Selenium.
Did you compile your program with `--debug` flag? Well, I think Crystal still have a debug issue ;) https://github.com/crystal-lang/crystal/issues/4457 /u/RX142 Am I right?
I compiled with debug flag yes.
If you look at the [source for `Object#to_json`](https://github.com/crystal-lang/crystal/blob/391785249f66aaf5929b787b29810aeb4af0e1e8/src/json/to_json.cr#L2), you'll notice that it hinges on other overloads being available (for example, `Object#to_json` is defined in terms of `Object#to_json(io : IO)`). You _could_ try to implement these all yourself; however, generally you'll want to [`include JSON::Serializable`](https://crystal-lang.org/api/0.26.1/JSON/Serializable.html) for your struct instead. [`JSON.mapping`](https://crystal-lang.org/api/0.26.1/JSON.html#mapping%28_properties_%2Cstrict%3Dfalse%29-macro) is also available, but I'm pretty sure that the community as a whole is moving towards the annotation-based method.
While this totally works, I prefer the `JSON::Serializable` approach for now. Nevertheless, thanks a lot!
Very good answer, I'll also stick to the `JSON::Serializable` route for now. I should have dug deeper and taken a look at JSON's Serializable instead of assuming that all the JSON magic is just there by default. Thanks man!
No problem!
Yep, whatever works for you mate
very cool project. just ran the examples but it seems like a nice api.
By the way, lime is the name of a graphics library for Haxe.
Oh didn't know. But now changing the name afterwards would be kind of complicated I think. But one difference is that on the haxe repository it's called "Lime", this library here is always called "lime" (except for the `Lime` module).
Lemonade is closer
That example should do well with a screenshot or animated gif to illustrate what you get and not only show the code.
That sounds like a good idea. Thank you.
Whoops, I guess I linked the docs by accident. Here's the GitHub repo: https://github.com/woodruffw/netstring.cr
Nooooooooooooooooooooooooooooo
?
You have an interesting point... But that mortal kombat logo! How can you hate on that.
Toasty! 
The compiler can't know that because `context.request.body` is a method call - or actually a chain of method calls. But let's only consider the last method `#body`. It can return different results every time it is called, so maybe in the first line, it returns an `IO` but in the second it returns `Nil`. The solution is to store the result of the first method call in a local variable: if body = context.request.body context.response &lt;&lt; body.gets_to_end end IMHO \`if val\` reads much better than \`unless val.nil?\` and is semantically equivalent (except when \`val\` is \`Bool\`).
I see! Thanks for your help.
Faster than me, there is a cheat sheet found on Yourube video description.
How good is he at understanding and explaining the things ? He seems to be on the path to just make a video about anything and everything and caters to tech/it people instead of your average joe. He seems to be interested in pumping up views and subscribes.
Its more or less just the syntax of the language. He usually do it with every "learn x in 1 hour" video
Feedback/issues/suggestions are welcome :)
lime is the name of many things
You may scale via message passing to processes like github.com/foi1/crystal-json-socket
Why hasn’t there been a 1.0 release yet?
Looks like a fantastic collection of fixes!
@bcardiff This post has way too many "some"... I'm counting 17, including 5 in the introduction alone. :D
Awesome!
Err, I think you meant /u/bcardiff?
Sorry! I would argue that in spanish that won’t happen. But... I might have some of the same issues sometimes :-P. Thanks for fixing some of them. 
You might be able to run/compile each program with a custom prelude (on mobile right now, don't remember what the command-line option is off the top of my head). You would probably want to require stuff like Array and Hash, but not File. You might also be able to disallow `require` with some macro trickery. 
There's http://carc.in/ https://github.com/jhass/carc.in Which basically does what you want. It can run crystal , c and ruby sandboxed.
ruby on rail can be found on professional website, crystal much much less. there must be some documentation about ruby vs crysal on crystal's website
learn ruby. Crystal is not at 1.0 yet so the community and ecosystem around it will continue to be comparatively small. By the time you get the hang of ruby (should not take a long) you will find you can pick up Crystal quite easily.
Learn Ruby, then learn Crystal. The reason to learn Ruby first is to appreciate what Crystal is so much better in terms of execution speed, type system, etc., etc., and because there are way more ruby/rails tutorials going back 10 years.
Right, starting Ruby to gain a strong foundation before picking up Crystal, that’s the better path to get the best of both world as there may be projects that you need to deal with Ruby and confidently to port slow code over to Crystal e.g. microservices could be popular strategy.
How long does it take them to update the Homebrew tap?
The big limitation with the [run.sh](https://run.sh) approach is that docker will SIGKILL all your processes without allowing them to terminate gracefully. &amp;#x200B; Of course, as @[straight-shoota](https://www.reddit.com/user/straight-shoota) mentions, using a process supervisor, like say Kubernetes, is the ultimate solution to multiprocess management - at least with docker, it's probably an unnecessary complication for smaller deployments. &amp;#x200B; So I think the very basic, and optional, process management I've included in Spider-Gazelle meets the needs of simplifying smaller deployments without sacrificing graceful termination.
&gt; Kuber Kubernetes for multiprocess management sounds like a litle bit overkill IMHO. What about something like monit (https://mmonit.com/monit/)
&gt;https://mmonit.com/monit/ mmonit is like docker without the benefit of containers. Systemd would be just as good on linux. Systemd would work well with [run.sh](https://run.sh) as it sends SIGTERM to child processes by default. &amp;#x200B; However when using docker, which is probably more common these days, the only way to have multiple processes without using [run.sh](https://run.sh) would be to have multiple docker containers which is administrative overhead. I'm also not sure you could use reuse port with multiple docker containers without exposing the host network which is bad practice. So you would need to have a nginx load balancer (or similar) to distribute requests.
It's already updated
Here is a screenshot of the new project wizard &amp;#x200B; &lt;img width="780" alt="screen shot 2018-07-10 at 10 37 15 pm" src="[https://user-images.githubusercontent.com/22394/42552586-e500ee6c-8491-11e8-9443-eaf33ceb5f4a.png](https://user-images.githubusercontent.com/22394/42552586-e500ee6c-8491-11e8-9443-eaf33ceb5f4a.png)"&gt;
Check out screenshot of the new project wizard here: [https://github.com/luckyframework/lucky\_cli/pull/221](https://github.com/luckyframework/lucky_cli/pull/221)
Because this method results an uncommunicated number of processes I suggest improve this solution with a unix socket and passing json across the processes for collaboration. Ex. I need a reload config end point in my API and when I call it I want to reload the config YML in each child process. So the process that receives this call send the command across the unix socket to the root process and the root process broadcast the reload message to the child processes.
Thanks :D
I would say learn crystal first. Crystal, via the type system, helps enforce good behaviour, so you'll be a better ruby programmer for knowing Crystal. Crystal's easier to install and distribute than Ruby too. &amp;#x200B; I would say overall Ruby has a surprising amount of subtle gotchas and frustrations that you won't realise exist until you use Crystal. Personally I wouldn't start anything new in Ruby and you'll get a whole lot more joy out of Crystal
Nice work!
Indeed there are! There's already a basic simulator in pegasus_sim.cr, which reads from STDIN. It wouldn't be too hard to generate similar code dynamically. Thanks for your comment :)
This is actually exactly what I need. I was just working on writing a crystal-based parser for a new programming language that compiles to js.
Have you seen mint? [https://www.mint-lang.com/](https://www.mint-lang.com/)
⬢
What was it before?
It was purple.
It was purple.
I liked the purple :/
I recently added a Crystal backend to the repository. The API is somewhat unstable, and perhaps could use more OOP, but your feedback would be much appreciated!
Sweet! I'll try at take a look at it soon!
Well, as stated in the [PR](https://github.com/github/linguist/pull/4290) that originated this change: &gt;Crystal associates with black color. Its logo is black, it's website and documentation are black-and-white. Which makes sense in a way, but I do agree that it will take some time to get used to that :D
there is also the google group: https://groups.google.com/forum/#!forum/crystal-lang
I guess people might misunderstand it as C, because a lighter variation of the black is being used for C already.
I like it but it also reminds me to C.
The documentation is (a different shade of) purple though. I still wonder why.
&gt; black looks super jarring racist.... :)
If my Crystal app requires 500Mb RAM to compile, will deploy work on 50Mb RAM plan or I'll get an out of memory error?
We allocate a little more memory on the top of the selected plan memory limit. But yeah if it really takes 500 MB to compile it would crash on a 50 MB instance. However we did tests with a 100 MB instance and it compiles without any memory issue.
Crystal is well known for its big memory requirements when compiling, several gb is normal. If the platform requires to compile it there I think it is a no go for this language there :/
The platform doesn't "require" to compile. You are free to do whatever you want in fact. It's just the current amber template does compile but you are free to change it or rewrite it completely.
Thanks. I signed up in your site, will check features. Regards 
Cool, thanks for that, will look at it.
The other options are better, but you might consider using a docker-based solution. If set up right, this could give your users a virtual file system to play around with as well, though you'll have to manage a docker installation which can be annoying
So bad, I liked the purple. They should check with the core team :-(
why do you want to avoid a lib already written in C ? Writing such a library is hard work, and re-using existing work is way faster, and secure than writing another one from scratch
Check the various game/media Frameworks. They might have what you're looking for. 
I would go with crSFML as base
Very cool!
I would like a very light library that can read flac and mp3 format and can be other audio codecs, if possible, I would like not to bother with video codecs that are usually present in multimedia libraries. Do you know a good library written in C?
No mention for Generics and Unions, these are fantastic as well
On FreeBSD/aarch64 you can just `pkg install crystal shards` :) It was pretty easy to cross-compile the compiler, Crystal even builds the linker invocation command for you. I don't remember how exactly I did it but it was easy.
Windows support is not "mere weeks away"
We highly appreciate contributions under crystal community org: [https://github.com/crystal-community/](https://github.com/crystal-community/)
What skills and interest do you have? Maybe we can find a specific project that might interest you 
I make a lot of Rails APIs and was wondering if there's a framework akin to Rails I could help out with. I also have contributed to Cassandra drivers/orms in Ruby
There is Lucky which is the closest to RoR, other then that there is Kemal which is closer to Sinatra
An easy one might be Crystal’s port of Flipper: https://github.com/metaware/flipper Author here. 
https://crystalshards.xyz/
It's not the future of programming languages and it won't be until it can compete with the likes of Rust or Go. It's a nice language but the core team is just not competent or brave enough to take it to the next level. They need incremental compilation, faster compile speeds, static builds, easy install into minimal containers (alpine for example), multi threading, a language server implementation, and probably some tooling around translating from ruby to crystal or something. They also need to figure out how to deal with more dynamic data, the pull parser isn't that much fun to work with when trying to deal with complex json data and such.
🚀
It’s great to see all the major Ruby gems getting their Crystal ports done! Eagerly waiting for Interactor and Factory Bot ports next! 
I actually think NumPy is a library that definitely goes well with Crystal. I might start that one as well.
I ported some of the calculations over: [https://github.com/drum445/financials](https://github.com/drum445/financials)
Wow, this guy seems pretty rude. https://github.com/github/linguist/pull/4290#issuecomment-443697393
Funny thing is I've always kind of associated Crystal with purple, cause of the docs and the color on GH. I didn't care one way or another when it was changed, but after reading through the discussion, I think I'd rather it stay purple for now.
Honestly I liked the purple. What’s so distinguishing about black? Is there no other language color on linguist close to black? I can kinda see how Vlad was being proactive and grabbing the color before another language could. Just don’t want crystal being associated as another color of grey. 
&gt; It feels like the core team is a bunch of old dudes who love Perl and Basic and they deny to see the world full of JavaScript, GraphQL, gooey design and tiny subsription startups with Stripe accepted (metaphorically speaking). I mean, the overall feeling is not far from sitting in "Programming in Delphi" with old big lamp monitors. It's not right in 2k18. Seriously, wtf. Seems pretty uncalled for, in an argument about a color change on GitHub. (and fwiw, I am totally happy if the core Crystal team AREN'T those types of developers, because that frontend, hype driven development world is a gigantic mess)
You can get an idea looking at these resources [http://crystalshards.xyz/](http://crystalshards.xyz/) [https://github.com/veelenga/awesome-crystal#devops](https://github.com/veelenga/awesome-crystal#devops)
Oh thank you
Basically I see crystal as eventually being a death-stroke to dynamic languages. It has super high level, super easy to use ruby-like syntax, but it compiles directly to binary like C, and has C-like speeds. It isn't confusing or restricting like Rust, it doesn't have weird python conventions like Nim, it isn't old and partially abandoned like D, and it isn't all about math like Julia. It is cross platform, with windows support almost done. Parallelism is getting there as well. Web assembly will be after that. The high level language features and macro system make it possible to do most things you would think would only work in a dynamic language, it disallows some of the more harmful things, like on-the-fly function definitions. Because of this crystal code is easy to perform static analysis on, which means if it replaced javascript, we could have only the minimal amount of code that actually runs on the page included in each web page, instead of including entire libraries. &amp;#x200B; Main advantages: * ruby-like syntax * extremely performant * can compile native static binaries on linux + osx, windows coming soon * blocks/closures * asynchronous IO / fibers * object oriented, but you don't have to use any OO features if you don't want to * parallelism coming soon * windows support coming soon * cross platform * super easy to use macro system (though could use better documentation) * interact directly with C APIs with ease * has corporate backing (manas, rainforestQA, and others) with at least two paid full time devs
thats seems like a lot of positib points, are there any negative ones too? 
From my limited experience, the main negatives seem to be side effects of it being such a new, in development, pre 1.0 language. As of today: * Compiling is slow, even for smaller programs. This makes the feedback loop of developing more painful than I would like. There has been a ton of discussion about this, and it seems like it's still very unsure whether or not the compiler speeds will be able to be significantly improved, and it doesn't seem to be a current priority for the core devs. (Somebody correct me if I'm wrong.) Apparently a lot of the problems with the speed are core issues to how the compiler and type system works, and it would be a massive undertaking. * Editor tools aren't super great yet * Debugging isn't super great yet. This is kind of a problem in general for compiled languages, but Crystal specifically has some big problems. (e.g., you can't `debugger` into a block.) This paired with slow compile times makes debugging and development slower than it should be. All that being said, the language is still young, and the language and tooling is being primarily developed by volunteers. I imagine most of these issues will be resolved over time. The one that concerns me the most, from the various threads on the subject that I've read, is the compiler speeds.
oh thank you very much
No parallelism yet.
The ecosystem is small, the language isn't at version 1 yet (so breaking changes can happen), and compile times are very slow.
&gt; Compiling is slow, even for smaller programs Not only compile time, but also memory usage of compiler because of its design. Related to this, looks like it'll be hard to implement incremental compilation. What else? ...Probably, in the future they will swap the GC implementation. There are some experiments on it.
&gt;Not only compile time, but also memory usage of compiler because of its design. Related to this, looks like it'll be hard to implement incremental compilation. It makes me a bit worried for Crystal. I realize every language has tradeoffs and to write a language as fast and slick as Crystal, the compiler efficiency had to take a hit. But if there isn't a major breakthrough I feel like a lot of the developers Crystal is designed to attract will be turned off by the language.
for me the only negatives are that parallelism and windows support aren't done and the official 1.0 release is not out yet.
The compiler is slow because the design of the compiler means it has to be slow and can't be made any faster unless the language is changed. At this time the developers have basically given up on making a faster compiler or an incremental compiler. 
What does Crystal offer that Kotlin doesn't? Kotlin is already more mature than Crystal, offers a ruby like system, amazing IDE integration, can compile to native binaries, etc etc. BTW You can not build static binaries with Crystal. It will always have dependencies on C libs. Go is much better in that respect.
That's unfortunate, and the main reason why I'm worried about Crystal's long term success and potential. It also feel like a bit of a contradiction in goals. Crystal seems aimed at optimizing for developer productivity and happiness (the Ruby philosophy), but that's at odds with such slow compile times.
I think the developers got in over their heads. Having union types and non nillable types and type inference means every time an assignment is made the compiler has to determine the type and then check to make sure the method is supported.
I wonder if we'll ever see a fork of Crystal that removes one of those in favor of compiler speeds...I wonder if just requiring mandatory method return types (rather than inferred) would help significantly (even if that would be a huge breaking change for the current language design). I'm mostly talking out of my ass though, because I know very little about compilers.
I recently cross-compiled and wrote step-by-step tutorial. [https://translate.goog](https://translate.google.com/translate?hl=en&amp;sl=auto&amp;tl=en&amp;u=http%3A%2F%2Fconstxife.ru%2Fblog%2F2018%2F10%2F16%2Frpi-crystal.html)[le.com/translate?hl=en&amp;sl=auto&amp;tl=en&amp;u=http%3A%2F%2Fconstxife.ru%2Fblog%2F2018%2F10%2F16%2Frpi-crystal.html](https://translate.google.com/translate?hl=en&amp;sl=auto&amp;tl=en&amp;u=http%3A%2F%2Fconstxife.ru%2Fblog%2F2018%2F10%2F16%2Frpi-crystal.html) \&gt; I've also tried [the unofficial compiled version](http://public.portalier.com/raspbian/), but it doesn't work. Strange. I tried this too, and it worked for me, but it was not actual version.
Requiring types in method signatures would probably help tremendously but for some reason the core developers are adamantly against that. Honestly the biggest problems with crystal are the core developers. They have odd set of priorities. On the one hand they are happy to break compatibilities with ruby and other the other hand they get really weird about forcing types in method signatures. 
Not true, I compile static binaries all the time. It can be a bit dicey, but if you use a musl-based distro like alpine linux it works the vast majority of the time. There is a docker image that automates this process: https://hub.docker.com/r/durosoft/crystal-alpine/. This is how we are able to run crystal in lambda/google cloud functions (e.g. https://github.com/sam0x17/gcf.cr). Kotlin runs in the JVM, so it's going to be an order of magnitude slower, and you get all the JVM-related baggage. The closest thing you could compare crystal to would be Nim. 
&gt;Kotlin runs in the JVM, so it's going to be an order of magnitude slower, and you get all the JVM-related baggage. There is kotlin native which uses LLVM as a back end. &gt;The closest thing you could compare Crystal to would be Nim or D. Both of which are robust and proven. &gt;For example I can't stand Go, but some people swear by it. The world needs lots of styles of programming languages. I can't stand go either and in an ideal world everybody who uses go would migrate to crystal for the generics and macros alone but..... Go has real concurrency, go has good windows support, go makes it trivial to compile static binaries, go improves in speed with every revision, go compiles super fast, go produces faster binaries. Crystal need about three to six more excellent compiler developers. People who really understand how this shit works.
Well yeah Crystal need more compiler devs that can tackle or just experiment with the most complex problems. 
That's for sure. Crystal is a much bigger undertaking than people realize. You need very skilled and motivated developers that are able to bring it to a state where it can start competing with langs that have multi billion dollar corporations behind them. I am not saying the current devs are not skilled or motivated enough. They are...But the number of problems and the complexity increased so much that I dont think they can tackle them alone. 
Can compare with Golang faas? https://github.com/openfaas/faas
That's for sure. Crystal is nice but wont be able to survive long enough without fixing the most pressing issues. It's nice for toy programs non mission critical stuff but wont be something people will reach for compared to other languages. It's sort of this never ending problem in the Ruby community that we are not able to see the momentum and work on stuff that matters instead we focus on implementing pointless features for the sake of "productivity". 
This is not the ruby community.
but with the official 1.0 release the windows support should be fully developed? 
Crystal mimics Ruby community very well.
Yeah, I can do another comparison using golang. I used apachebench to benchmark the different functions and used the median response time of 1000 requests for each deployed function 
As a general clarification: I created a language template so that you can write crystal functions for OpenFaaS. The performance was magnitudes better than JavaScript and Ruby. The Faasflow bit is a bit confusing maybe. It's just a library for executing multiple functions in sequence on OpenFaaS
Looking forward to an articles in Medium would be good for future reader as well
Epic summary!
Note: I'm a core developer and I'm not against having required types in method signatures. In fact I think it will make the language easier to reason about (but a bit slower to write, maybe). But I don't think all methods can be typed right now because the language relies a lot on duck typing, so if we change that we'll also have to introduce some form of interfaces or protocols. And with that the language will change a lot and it will probably look like some other language (maybe C#). My priority for a long time was cutting down compile times and memory usage of the compiler. However, the community said that this wasn't a big issue at the moment and that they could wait those seconds, and that they preferred more features and more performance for the generated code. I think the community is right. We can worry about compiler optimizations in the future. Once the core devs tackle parallelism and Windows support they can spend time rethinking the language implementation.
+1 for crystal ^^
Awesome! I've been working through AoC2018 in Crystal too, so I'm curious to "compare notes". &amp;#x200B; For your day1 part 1, I think it can be simplified a bit by replacing freq = 0 all_freqs.each do |i| freq += i end with freq = all_freqs.sum(0) &amp;#x200B;
Yeah, definitely. I was very tired when I wrote these, so most of it is probably not very idiomatic. 
&gt; freq = all_freqs.sum Or just: freq = all_freqs.sum
I also am doing Advent of Code in Crystal! Here are [my solutions](https://dev.danilafe.com/DanilaFe/AdventOfCode-2018).
Or even more simplified `input = File.read("#{__DIR__}/input.txt") puts input.split.map(&amp;.to_i).sum`
The VPS I run this thing on isn't the most powerful thing and I wanted to get more bang for my buck, the difference in performance is astounding.
Yes
My understanding is Crystal already has parity with Go in terms of concurrency support. You can spawn millions of fibers like you can spawn millions of go-routines, and it is built on the same underlying technology. Once parallelism is enabled, crystal will have full parity with Go in terms of that stuff. 
Thanks for sharing, I have been doing it in Crystal as well, although my solutions are a lot messier than yours. I definitely feel like I have a lot to learn and improve after seeing how good it can be done. &amp;#x200B; Here are my solutions: [https://gitlab.com/chillfox/advent\_of\_code\_2018](https://gitlab.com/chillfox/advent_of_code_2018) &amp;#x200B;
Nice!
I can confirm this is built using amber :-D https://i.imgur.com/cPV1Dqf.png If you want to open source your code you can add yourself here: https://docs.amberframework.org/amber/in-production#open-source-projects-using-amber 
Nice!
You also can try to cross compile your binaries. Some benefits on my Raspberry Pi 3B: - No sloooow compilation times (Desktop PCs are faster) - Free up space and just keep binaries (and a few dependencies) See: https://github.com/mrfoto/slacker/issues/1 If you want crystal on your RPi anyway you can crosscompile crystal itself :) 
Would be great if you can share some metrics on the kind of performance boost you had on similar actions between the two stacks? 
It's already open source, there's a link to the GitHub under 'about'. Thanks for telling me about that though, I'll add myself soon.
I have no idea how to properly test that.
I have kind of shelved doing too much with Crystal How slow is slow? I guess that determines if the community is right. 
Actually a good part of it is at present
&gt;My understanding is Crystal already has parity with Go in terms of concurrency support if you ignore parallelism. That's the most nonsensical thing I have ever heard. &gt;Once parallelism is enabled, crystal will have full parity with Go in terms of that stuff. What about the rest of the stuff?
&gt;In fact I think it will make the language easier to reason about (but a bit slower to write, maybe). But I don't think all methods can be typed right now because the language relies a lot on duck typing, so if we change that we'll also have to introduce some form of interfaces or protocols. Why is that? Why can't the methods be rewritten and overridden if necessary to use other types. 
What python conventions are weird? IMO it has better syntax than Ruby, but i din't actually used Ruby, only tried it few times.
I'm not sure I understand your question (I was talking about typing all methods, not about rewrite and overwrite), but as an example `Enumerable#sum` right now works for any type that has a `+` method. That's what I mean it relies on duck typing. If we wanted to type that then we'd have to say that the `T` of `Enumerable` in that method has to implement a method `+` that returns `U`, and in turn that `U` has a method `+` that returns `U` (I think). So we'll need new syntax for that, or interfaces/traits/protocols. It'll be a completely different language.
[https://medium.com/@t\_pei/serverless-crystal-14b22ecc4352](https://medium.com/@t_pei/serverless-crystal-14b22ecc4352)
I've already tried your guide. The problem is I have manjaro on my machine, and for arch-derived distros it's not that simple to install easly llvm 3.9. I might have to compile it as well. Simply don't want to, as I isn't my project goal and have already wasted three days. Maybe I'll try tonight with the compiled version, hopefully I can figure out how to make it work.
Yeah, I thought about cross compiling my project for rbpi, the fact is when I try to compile the simples hello world possibile, the compiler gives me a bunch of errors about c and llvm.
Thank you for a well written article!
I also just updated the article with a Benchmark for Go as well, Go is even faster than Crystal at 16ms vs 27ms :)
OMG. That's just absolutely crazy. &amp;#x200B; Is there a specific reason for this?
Concurrency != parallelism, and the team is very close to having parallelism done. Reportedly it's been working just fine in several branches for a long time, they are just waiting for windows support to be done so they can add it to master for all three platforms at once. Crystal has lightweight threads that are basically identical to go-routines. This allows for extremely efficient asynchronous IO, and the ability to spawn millions of mini-threads. You can do this without parallelism, and these things are the main attraction of Go. Very few people who think they need parallelism actually need parallelism, and for those that do, you could probably start coding your app right now and by the time you are done parallelism support will already be out.
I forgot to mention, for the moment, the compiler is situationally rather slow, particularly with optimizations enabled. This will be resolved in the 1.0 release I have been told. There are some easy optimizations they could do to speed this up, but it would make more sense to do this once the language API is 100% stabilized. 
I started in python and moved to Ruby later, and I have to say python has a lot of weirdness that makes no sense to me in 2018. Tab/four-space indenting is unsexy. Having an eternally split 2.x and 3.x drama that has taken 10 years to play out sort of sucks. The whole ":" denotes the beginning of a block thing is weird AF. The refusal to just call it null or nil is weird, the whole capitalized True/False thing is weird and feels like old school basic to me. The language just always put a bad taste in my mouth until I found Ruby. 
The reason is so that anyone can build a compiler from source without trusting manas. See: [this famous paper](https://www.ece.cmu.edu/~ganger/712.fall02/papers/p761-thompson.pdf).
I'm aware of the concept of bootstrapping purely from source. Just wondering if there was some causal motivation to do this \*now\*.
This is really cool, currently I'm working on a docker image for crystal 0.27.0 on raspberry pi, and I have to do this starting with Crystal 0.24.2. Very excited to see how easy it will be to compile from source on every crystal version in between.
I just got really motivated to spend 24 hours using git bisect and typing the results into a bash script for some weird reason
Everything from 0.16.0 on up compiles the next compiler perfectly, it's only when you get deep into the old old sourcecode you get super weirdness
I guess it was a challenge. I always said it would be terribly hard, even maybe impossible. I really don't know how you did it, you made it look like it was super eaay. 
Great job! 
It wasn't overly hard, it *was* terribly time consuming and fustrating and there was a lot of swearing and backtracking several compiler versions and running `git bisect` again. There's a bunch of patches [here](https://github.com/crystal-lang/bootstrap-script/tree/master/files) and a bunch of reverts, cherry-picks and `sed` invocations in the [script](https://github.com/crystal-lang/bootstrap-script/blob/master/bootstrap). So it was a lot of work. But I'm glad I got it done.
Well it looks like you guys painted yourself into a corner with that one. 
See, I knew there was a reason :D
Well, the language is usable and people are doing great stuff with it. I don't think we are cornered :-)
 sponsors += 1 
The tuple size is known at compile time. And the type of each component is also tracked during compile time. This means that index out of bounds can’t happen. And there are less unions you will need to deal with. Given, ``` a = [0, “s”] t = {0, “s”} ``` `a[0]` is `Int32 | String`, while `t[0]` is `Int32`. Accessing the index number 2 will raise for array and directly won’t compile for tuple. The article at https://crystal-lang.org/2016/09/09/a-story-of-compromises-and-types.html might offer some further information. 
Tuples are also much faster than arrays because they're compiled (i.e. "baked" into the code), see [https://carc.in/#/r/5quf](https://carc.in/#/r/5quf): `array init 11.36M ( 88.04ns) (± 3.83%) 48 B/op 19.68× slower` `tuple init 223.5M ( 4.47ns) (± 3.05%) 0 B/op fastest` `array fetch 61.61M ( 16.23ns) (± 1.47%) 0 B/op 4.86× slower` `tuple fetch 299.74M ( 3.34ns) (± 6.32%) 0 B/op fastest` *P.S: Fetches are equal in* `--release`*, but I guess that's because the array is baked as well, which is not a common scenario for real-world apps with dynamic arrays.*
Thanks for the response. I have very little experience with typed languages so this is very foreign to me. It sure seems like a huge hassle. I can't remember the last time I accessed a member of an array by index. Even after reading that link I still don't think I get it. I guess I'll have to play with it. Thanks again.
&gt; I can't remember the last time I accessed a member of an array by index That's the only way to access an array member though? Unless you're talking about stuff like `arr.first`, `arr.last`, which are just syntactic sugar for `arr[0]`, `arr[-1]`
Another explanation with an example from the standard library. Say you have a hash mapping numbers to strings: hash = {1 =&gt; "one", 2 =&gt; "two"} In Ruby, and in Crystal, there's `Hash#first` (it's actually `Enumerable#first, which is included by `Hash`). Let's try it in Ruby: first = hash.first # =&gt; [1, "one"] In Ruby this returns an Array with two values. Now let's ask for the length, or size, of the second element of that array: first[1].size # =&gt; 3 Cool, it works! What about in Crystal? If we also returned an Array here, what would be its type? Remember, Crystal is typed so every expression in the language must have a fixed type. The above `first` variable in Crystal would be `Array(Int32 | String)`, meaning it's an `Array` that can hold `Int32` (integers with 32 bits precision, the default integer in Crystal) and `String`. Now, you as a programmer know that this particular array has two elements, that there's an integer in the first position and that there's a string in the second position. But from the type `Array(Int32 | String)` the compiler can't know that. So if you would try that in Crystal: first[1].size the compiler would say "undefined method `size` for `Int32`", because yes, `size` exists for `String`, but it doesn't exist for `Int32`, and the compiler doesn't know there's actually a string in the second position. No problem, we can do: first[1].as(String).size That is, we tell the compiler "yes, we are sure there's a String in the second position". But types start to get in our way, ugh. Crystal solves this (actually many languages have tuple types) by having tuples. A tuple is a type for which the compiler knows its size, and what's the type in each position. So in Crystal the above `first` variable is given a type of `Tuple(Int32, String)`, meaning it has two values, the first one is an `Int32` and the second is a `String`. Now, if we do: first[1].size it works, because the compiler knows that if we access the second element it's a `String`. The string representation of the value of `first` is: {1, "one"} Aside from types, given that a tuple has a fixed size, and it's immutable, it can be represented much more efficiently than an array that can grow and shrink (it can be allocated on the stack and passed by copy). Because of that, a tuple is returned in for example `Enumerable#minmax`, which returns the minimum and maximum elements of a collection. No need to allocate an array of two elements just to return those values. Python has tuples too and I believe their point is also to save some memory, but types don't matter there because Python is dynamic.
sponsors += 1
[removed]
Nice work! like it you implementation
In Ruby, I usually just map and/or iterate rather than looking for specific elements.
Thanks for this explanation! I think I followed what you wrote, but I'm not sure how the type system is helpful. From what you wrote, it seems like a big hassle? I know people *really* like type systems though, so I'm sure I'm the one missing something. Do Crystal arrays have similar restrictions to custom classes? In Ruby, I avoid primitives as much as I can in favor of custom classes. If I have duck-typed objects, can I have arrays of them without some hassle? Or do these limitations of Array only apply to Crystal primitives?
You can think of a tuple simply as a list of numbered variables. It's particularly useful for returning multiple values from a method. And it's an efficient alternative to an array for fixed-size lists.
Have you seen this error in Ruby? NoMethodError: undefined method `foo' for nil:NilClass Or this one? NoMethodError: undefined method `size' for false:FalseClass You are trying to invoke a method on an object, but the object doesn't respond to that method. Well, with a good type system those errors just can't happen. Well, you do get the error but when compiling the program, not when running it. That's one use of a type system and a statically typed language. If you combine that with compilation to native code you can also be more efficient on memory because you can represent data structures more compactly, and you can also run the generated code through an optimizer.
Typed system is important in security side where you knew PHP, Javascript had countless bugs that leads to software quality problem and vulnerabilities which is why typed checker were introduced. Without typed system, any inexperienced coders could made a wrong assumption about their data, spent less time worry about bug fixing and you'll be more happier to enjoy vacations.
Gotcha, I see what you mean now
 You need to do a permanent sleep instead of a Fiber.yield. A sleep with no args puts the fiber on hold forever, ensuring that your other fibers are getting time without blocking IO.
The issue isn't that fibers don't get cpu time, issue is that the non-io fiber gets all the cpu time and doesn't give the other fiber to do work. 
Then you need to call fiber yield inside your other fibers that are causing the blocking. 
Yes I think that might be the solution here as asterite also suggested that on StackOverflow. I guess I was just expecting that Crystal would manage that automatically, instead of me intervening the Fibers
Crystal can't and won't intervene in your fibers execution unless it's given a verifiable reason to do so. Namely yield or sleep, as well as any IO blocking. It is mainly up to you to manage how your fibers will run, and in what order. 
Thanks for the guidance 
Crambda....the name is not so appealing XD
I would say cramdba is a very rememberable name and great for googling (just hundreds results).
Thanks guys. This is awesome. I think this will open up the language to a broader community. Now we only need a Crystal based Discourse clone to replace it :P
Really liked this episode! /u/paulcsmith0218 made a great point about the way that Crystal markets itself as fast ruby but that can sell itself a bit short. The type system is much more than just a fast Ruby. Enjoyed a lot! 
I believe Pragmatic Publishers has a book in beta right now (or will soon), "Programming Crystal"... Haven't read it though.
Do you know anyone that teaches maybe crystal. I'm looking to learn Crystal as I learnt C a time ago. 
If you're having trouble finding resources to learn Crystal, consider learning Ruby first as the languages are reasonably similar. Some differences but it'd be easier to learn them after figuring out the Ruby similarities.
Ok 
I'd second this. I learned Ruby a while back, then jumped over to Crystal as soon as I heard about it. Even now I sometimes prefix my searches with "ruby" instead of "crystal" if I'm stuck on something and there's not much good crystal documentation.
Indeed. And this whole syntax and concepts were originated from Ruby too. Exploring Ruby first before Crystal whether it is for fixing something (albeit different libs) or just learning the language, this is the best option.
Its actually 132 sponsors. I used to be a private sponsor for Crystal for a long time but this has cone to a halt because the money spending is totally not transparent. It seems that the money goes to Manas.Tech ( nowhere really mentioned in the donations pages ), a development firm that uses Crystal. Going back in history blogs and posts, we see posts that Manas donates time to the Crystal development but they also use part of those donations, supposedly going into Crystal development. Manas is a regular company ( that can deduct these time donations). Normally with projects like this, the money goes to a non-profit Foundation. Now, lets take a look at the income for 2018. We see a regular income between 2000 a 2500 dollars. In exchange, we see that Manas has done the following work: 04 Sep 2018 Using CircleCI 2.0 09 Mar 2018 Crystal Automated Release That is all... This links to 120 hours of Distributions listed in 2017 ( this-is-not-a-new-years-resolution blog post ). We see Crystal donations from May 2017 outperforming the time spend by Manas, as they had too much work to "donate" time to Crystal. And i am placing donate in quotes because the moment you mix in other people money, its not really donations anymore. Legally they are mixing. For 2018 just in Bounty Source, Manas got close to 28.000 dollar in donations ( 30.000 dollar or more by end of the year ). We are not looking at the 12.000 dollars from 84 Codes ( also not on Bounty Source ). That money is spend on hiring Brian J. Cardiff for full time development on Crystal. So here is my question, where is most of the 28.000 dollars money gone? Not in Multi-threading it seems. Not in Windows support because most of the work is done by community members. We also question the fact that Manas is donating time but at the same time is using the donations for Crystal development. Its a very clear conflict of interest. I advice for Manas to move the donations into a non-profit for Crystal because it not just a perception issue but also a legal issue! We can not donate to Crystal, knowing that the donations are simply being used to back a other company its personal interests in Crystal. The conflict of interest is too much in this case. So for the future of Crystal, sort out this legal issue first and move Crystal into a non-profit foundation, with donations going directly to the non-profit. And employees working under this non-profit, not as Manas employees being pay for by sponsors, or however its is structured now. As stated, the whole setup is legally and perception wise confusing.
Is this what you're asking? def get_and_validate_int val = gets if val.nil? || !val.to_i? puts "#{val} is not an integer" exit 1 end val.to_i end print "Enter an integer: " int_1 = get_and_validate_int print "Enter another integer: " int_2 = get_and_validate_int puts int_1 + int_2 You get input with the `gets` method, which will block until you enter a newline. You have to be careful, because the return type of `gets` in Crystal is `(String|Nil)`, so you have to do the nil check before checking to see if the input is an integer.
Is that the simplest method. If yes thanks for sending but didn't expect to be this long 
start point is [here](http://rosettacode.org/wiki/A%2BB#Crystal): 
Though I was more of asking in my first question on how to declare an integer to use it in a calculator I guess this mostly answers my question 
If you don't care about validating user input, you could make it shorter by casting the result of `gets` as a string, and then just immediately calling `to_i`: print "Enter an integer: " int_1 = gets.as(String).to_i print "Enter another integer: " int_2 = gets.as(String).to_i puts int_1 + int_2 The program will of course crash though, if you enter something that's a non integer.
You sure that won't cause an error on a compiler I was doing something similar and it kept doing something with nil 
If you're just asking how to declare an integer and not get it from user input, it's literally just number = 1 # or whatever value But I'm still not 100% sure I understand what you're asking.
Do I have to include any libraries. Along with that if I don't awesome but I wanted to ask how to download a library on Ubuntu I don't remember where the compiler is saved now? 
It'll compile, I already tested it. Maybe you were trying to cast the result of `gets` as an `Int32`? That won't work, because `gets` will only ever return a string or nil.
Use `not_nil! ` instead of `as`
I just found [this](https://github.com/askn/crystal-by-example).
&gt; In addition, the work Manas.Tech and Sikoba will be doing to develop this platform will result in the development of many blockchain and cryptocurrency libraries done in Crystal. Most of those libraries will be released as open-source, so that will be an important contribution to the Crystal community as well.
We also have sushichain as well!
I read somewhere that sushichain is going to be powering a game right?
It can. It's very similar to the same ideas brought forth by etherium except that the smart contracts are actually controlled by a single computer on the network rather than as a distributed program. I've actually been trying to get the authors of sushi chain to give me some example d apps so I can better understand what their system is trying to accomplish.
I think this is the game I was talking about https://www.youtube.com/watch?v=HsNh-AeCZkQ
Very interesting. I haven't heard anything about this from the sushi chain community. Although most of what I've been doing lately has been just dissecting the source code.
I'm glad you liked it!
I dont know how much money (investment) this would bring to Crystal but beware the same things has happened to Nim with Status. It sounds good at first but crypto and blockchain are too volatile. Hopefully Nim and Crystal wont get affected by these companies crashing. 
We have to see in 2Q2019 when they deliver MVP to the public. http://www.sikoba.com/www/index.html
I think Derek Banas has a decent tutorial on YouTube
That's really cool! This should be top priority PR and hopefully will be reviewed soon by the core members and be merged into 0.28.0 
I love to see how it scale reliability when you spin up billions of billions fibers in a stress load testing, perhaps we need a dedicated dashboard?
This PR is obviously a huge step, but there is still quite some road to travel for a complete multi threading implementation.
Unfortunately, it does not play nice with the Crystals Boehm GC. One of the solutions is using Immix GC but that project has not been touched in almost 10 months. So do not expect to see the multithread fibers that fast. I do not understand why ysbaddaden is not hired to permanently work on Crystal. He does a lot of the more advanced work ( MT, Immix, ... ).
Because currently they only have one full timer, and that is bcardiff. 
Nice code golf! 
Thanks for the topic! I'm still actively experimenting and just wrote down my initial thoughts [https://github.com/kemalcr/kemal/pull/511#issuecomment-450017389](https://github.com/kemalcr/kemal/pull/511#issuecomment-450017389) &amp;#x200B; Would really love to get some feedback!
The best just keeps getting better
I discovered Crystal last summer with its fantastic documentation, I work with NodeJs, PHP, JAVA, Python and C++ and I wondered with the simplicity of Ruby syntax powered with strong typing and compiled language. Now I had programmed impressive microservices for authentication (20k request/sec) and web services with OpenSSL lib linked without pain 😀 Thanks to the Crystal community I have resolved some doubts and the rest I have resolved simply reading the Crystal source code in GitHub. I am waiting the grown of the community with many expectations.
&gt; What do you think? Did you like the progression of everything related to Crystal this year? What do you think it could be improved? You asked so here goes. &gt; community asked almost everyday for a new releases and for status reports of the long term issues ........ &gt; &gt;Today everything is different: I haven't seen an official update in over a year as to where things are in relationship to 1.0 and the forum has literally no posts in the news section. zero. This fact alone has made us put down Crystal, pull back plans to contribute and just go into a watch stage. A couple posts her on reddit have indicated 2019 is unlikely to be the year for a 1.0 release either with no indication there will be one in 2020 or 21. Its not even that theres no 1.0 for the foreseeable future - its that theres zero official updates. Development of a language takes time but to be completely in the dark is not good for a community and yes it does raise the question - if the team is really that interested in Crystal and its community why would the official updates in regard to the very thing you say has become "Everything different" not come at least twice a year? I mean even a relatively short post on the crystal blog would indicate a level of interest in the community being informed of whats going on without trying to figure things out by picking through github conversations.
Sad to say, same page here. Frankly, with no multithreading and not-really Windows support, *still*, we left for Rust. While I much prefer the syntax of Crystal, it's not hard to get similar performance with Rust by using very lazy copying, and the upper bound of performance is much higher in Rust if you need, plus of course parallel execution. I'm disappointed that Crystal is still struggling with important, basic issues. (How do you advertise "fast as C" while not providing multithreading?!) And I'm further frustrated that they refuse to even *consider* modern syntactic sugar like pattern matching or pipelines or whatever. I used to preach the gospel of Crystal, but the future is too unsure for us to consider investment anymore. I was never a fair-weather friend; I made excuses for it in good times and bad. But there's no communication, slow progress on important things, and the lack (and possible impossibility) of incremental builds... it's just too much. I'll patiently await my downvotes. It's okay. I understand...
Crystal is done by a few volunteers, which small amount of money that guarantees at least some time are put into it. Compared to Rust, which Mozilla is funding it along with Samsung and many others, they literally have 1000x more resources than Crystal. &amp;#x200B; I understand Crystal is not progressing fast enough, but I don't think I can blame them.
I don't disagree at all. However, postponing the multithreading story until now seems *extremely* poorly thought. Especially considering Ruby's own past with multithreading support, you'd think it would have been a priority. The choice to avoid any modern syntax, on the other hand, is a choice not strongly tied to availability of funding, so that's just a choice I disagree with. Rust has a zillion more resources than Crystal, no doubt. But that doesn't change the fact that my confidence of Crystal as a platform has waned. I believed in Crystal near the beginning. I'm not sure I do anymore...
Thats no doubt true but it doesn't take 1000x resources to update the community on their blog - We are on the eve of 2019 and the last official update was Dec 2017. &amp;#x200B;
I disagree that learning Ruby will necessarily help you when it comes to Crystal, and I didn't like Derek Banas's "tutorial"/demo. Crystal wasn't my first language, but I learned it by simply reading the [book](https://crystal-lang.org/docs/), front to back. I found that very effective. 
I'm 100x more productive in crystal than in Rust, so by the time my Rust program is done, multithreading support will be ready anyway
&gt; I haven't seen an official update in over a year as to where things are in relationship to 1.0 and the forum has literally no posts in the news section. zero. This fact alone has made us put down Crystal i've been partially in your shoes before, but you should def try it out again, just cause lack of posts in the forum is not a good indicator at all imo. most of the devs are active there. it's def not a super booming forum because it's relatively new, and the devs do check it daily and if there are questions, they will never go unanswered. heck, i made a SO question and it was answered by [Jonne Haß](https://github.com/jhass). also, on their forum i asked some personal questions about Ary's educational background and stuff. they are very cordial and interactive with the community. now with regards to 1.0, i found [this](https://crystal-lang.org/2018/03/09/crystal-automated-release.html) blog post that mentions 1.0. and a few others IIRC. you are correct and I agree with you though, having more blogs showing inspiration about 1.0 would be ideal. but really, i have over 15k loc or so with crystal so far with my master and game server files. the incremental compilation is not really an issue (takes about 2-3 seconds to compile). and since i've been using WSL for a year+ now, the windows support is not an issue for me (but i do understand it is an issue for others). heck, now that i think of it, i will prob move away from WSL if windows gets officially supported. i am not entirely sure yet tbh. i do agree that multithreading feature would be awesome. i saw this PR recently: https://github.com/crystal-lang/crystal/pull/7214 but am not sure if that is related 100%, but it seems like the devs are getting there. trust me, the only "bug" i've ran into was the dumb timeout issues with TCP and MYSQL connections (the exceptions don't get called on WSL). which caused an extreme amount of headache debugging stuff. but once i figured out it's a WSL only bug (i actually created an issue WSL's repo about that), crystal has been running smoothly ever since. you should def think of giving it another try. there are always people who are active on gitter, etc that can help with any problems you ran into. if you go to the crystal's gitter, and search `girng`, you will see just how much support i've received for the past year+. i love it and sorry for this long post, but just sad to see how you feel. 
We have been using crystal (Kemal, Amber, and gcf.cr) in production without hiccups and with very manageable upgrades between versions for over a year now. Other than parallelism and windows support, I don't know what else remains to be done before 1.0 drops, but especially in the last few months the language has felt extremely polished from our perspective. I think many people have found the lack of PSA-style communication upsetting and unnerving, which is something the core team should definitely work on, but if you look in the areas where the the real communication occurs (release notes, the issues tracker, in PRs, and in Gitter), the language seems quite healthy and alive at least from my perspective. &amp;#x200B; I think we would definitely benefit from detailed monthly summaries from the core team, as well as keeping the milestone/roadmap pages very up-to-date, and linking to them in prominent places (e.g. in every monthly summary). At the moment finding the proper windows checklist in github is a non-trivial task.
I wonder how many clients are using DuoCMS?
&gt; i've been partially in your shoes before, but i think you should def check it out again, theres really nothing to check out. I would have never wrote my reply if I hadn't checked more than the forum. Most of us know gitter, the old google forum, the new one, github and the blog already. &amp;#x200B;
&gt; theres really nothing to check out. I would have never wrote my reply if I hadn't checked more than the forum. Most of us know gitter, the old google forum, the new one, github and the blog already. sorry, wasn't clear. when i say "check it out again", i meant you can try to re-consider your initial thoughts on why you don't want to use crystal
&gt; i meant you should try to re-consider your initial thoughts on why you don't want to use crystal. I think you are making a bunch of unfounded assumptions just off a fairly obvious suggestion that better communication would help. A lot of developers have multiple projects and have been following crystal for years (so its not an "initial thought") . We have to make decisions on more than one project and based or decisions on more than wants but anyway glad its working out for your project. 
&gt; I think you are making a bunch of unfounded assumptions just off a fairly obvious suggestion that better communication would help. so sorry for posting, do you want me to delete my post?
nope. Why would I?
&gt; nope. Why would I? i thought we got off on the right foot, but not sure why you think i'm making "unfounded assumptions"? where? 
I wrote a few "scripts" in crystal because I thought it would have binary portability, and it was fun, but setting up a new computer wasn't really that much fun because I had to install all of crystal to get it working (zero-dependency builds on MacOS are apparently quite hard). I recently rewrote them in Nim, as it seemed to promise a lot of the same things Crystal does, but is about 10 years older and has a neat mix of OO, Functional, and Procedural features. I've spent a lot of the last 2 years writing Elixir, and have fallen back in love with FP langs. Nim is fun to write, has a metric ton of cool features, extremely malleable syntax (Macros and Templates basically let you add whatever syntax things you want. Pipes, composition, pattern matching, you name it) pretty easy to debug, compiling a zero-dependency binary is a piece of cake, its fast as hell, and the final binaries are really really small. I still want to see Crystal succeed because the base promise of "ruby, but fast, compiled, and typed" is a very good thing. But it hasn't seemed to progress much from when I last used it in January
Multithreading support should not be overly emphasized. \*Using\* multithreading in applications correctly is really hard. Certainly, for some use cases multithreading is a necessity. But considering the complexity required to ensure multithreaded code is free of race conditions, I suppose it's only a fairly small portion of use cases where it's really a deal breaker. When threads are only lightly coupled, spawning multiple single-threaded processes and communicating over IPC is most likely more performant than multithreading in a single process with shared memory. And it avoids a lot of headaches. So I wouldn't consider missing full-out multithreading a huge loss to the language. Now it's coming to Crystal and that's great. But it's certainly not "too late". It has always been in the back of the heads and other features have already been designed with multithreading in mind.
NO I just meant you are assuming things in your replies to me that really aren't true. You assumed I had missed a post on the blog - i didn't that wasn't an update and you assume by the way you write that because Crystal is working out for your project its ready for mine and others. and then it seems from your statement its a matter of convincing people to want to try crystal when YES a bunch of us already have and have built things with it. I'm just answering a question asked that apparently is very important to to others as well (given that criticisms of a language are usually downvoted in its own reddit and mine response has been upvoted). When you adopt a language early there are a lot of considerations (that have nothing to do with wants) . I think a lot of people are willing to fully commit even with no 1.0 but not if the communication is once a year or less. I've heard the gitter thing before and to be honest - its not a productive answer if you want to enhance community growth. Asking new people and even old interested people to scroll through pages and pages of gitter to glean here and there where things are at is not good communication. A blog post every six months takes 20 minutes. Surely if you want to increase donations and participation you can do that ONCE every 6 months. If you don't and don't think thats important then that raise doubts about where the thinking and interest int he community is. Just for the people who actually donate there should be an update and if there is then copy and paste and the blog entry is done. I say this a s a company head that was considering donating So that blog post would have paid for itself and then some (from others). I'm sorry and this will probably get downvotes but theres really no excuse for this or any gitter work around. Surely there is a $20-$25 benefit in posting an update twice a year just in attracting and keeping donations. If thats an issue then maybe being open source is the problem. We always assume OS is the best but there are a lot of great projects that die because they are open source without a major sponsor 
Amen to that. I totally agree with your words. Communication is lacking in many ways. As a newly appointed core member I can't say anything about why that's been so difficult in the past, but it is my goal to help improving it.
Hey glad to hear . I know we have been talking about updates on 1.0 but frankly even announcing when core members come on board and introduce themselves its a kind of update that things are happening. utilize your blog. Its on your main site people expect to find news and be kept up to date and sure would like to know more about you, what you will be doing and welcome you to the community as a core member. Congrats!
I mean you should have known. It's not a simple issue to solve with such a small team of people. I would not say Rust is an alternative to Crystal in any way. It's entirely different language. Many of use want Crystal to succeed because we love Ruby not Rust.
There are at least recently some introductions in the [forum](https://forum.crystal-lang.org/c/community/introductions). It's not all core members but for every member in the community. That's little improvements, but still needs more publicity.
As a matter of fact, I have yet to see the issues to be "solved". &amp;#x200B; Multithreading is hard, with many trade offs, and none of them seems to be quite what the Crystal developers wanted. Rust technically might have solved it but the trade off is 100x learning curve. 
&gt; You assumed I had missed a post on the blog well because they had a blog post already mentioning 1.0 in March and stuff &gt; that because Crystal is working out for your project its ready for mine and others. and then it seems from your statement its a matter of convincing people to want to try crystal when YES a bunch of us already have and have built things with it. yes, i love the language so much i feel sad that others can't use it. that's supposed to be a problem? is this a form of sutble gaslighting? because it's not gonna work on me. i was merely just sharing my experience on how awesome the language has been. and the possibilities. obviously i can tell there you have no wiggle room, and guess what? that's fine &amp; dandy because it's your right, but i'm not making any unfounded assumptions &gt; For me 1.0 status , multithreading and startup time is not the issue. The communication is. I think deep down every seasoned developer here expected bumps, delays and issues with a relatively new language. If you get the communication with those then its "par for the course" and you can remain engaged and excited. if not then its just human nature. You wonder whats going on. yeah, i understand. i just was mentioning cool stuff happening and trying to increase my ethos by mentioning something that a lot of people want. and could benefit crystal a lot. so i just figured it was worth mentioning &gt; I've heard the gitter thing before and to be honest - its not a productive answer if you want to enhance community growth. Asking new people and even old interested people to scroll through pages and pages of gitter to glean here and there where things are at is not good communication. i was just saying that because i was trying to say the community is really supportive. even spending an entire year dealing with someone who has never even used ruby. and they did. but yeah, i'm not saying scrolling on gitter is a good idea either, i agree with you that's probably not ideal to find information, but i was mostly just saying that to show that the community does care and is willing to help 
&gt; Amen to that. thanks for throwing me under the bus
&gt; well because they had a blog post already mentioning 1.0 in March and stuff Read it before in march. So you assumption was wrong. it had no update. &gt;yes, i love the language so much i feel sad that others can't use it. that's supposed to be a problem? is this a form of subtle gaslighting? because it's not gonna work on me Wow thats a lot of nonsense and stupidity. no one said anything was wrong with your emotions. Someone asked an opinion about what could be improved and I answered. I think we are done here.
I would rather they focus on developing Crystal instead of doing such "administrative" tasks. Guess Crystal needs something like a community manager then ?
I find Rust to be incredibly difficult to work with for the kind of projects I would typically use Ruby/Crystal for. My main is Go with a bit of Nim here and there and cant imagine using Rust for that kind of components I am writing. Not because Rust is a bad language quite the opposite actually but because Rust has an insane learning curve and tons of gotchas in terms of features and code readability that I find frustrating. That said Rust's stability and tooling is amazing but i understand the manpower and investments by Mozilla &amp; friends that went to Rust. The bigger question is if that would be the case for Crystal if it had the same amount of support. Sadly I think many of us take features that are extremely complex and expensive to do for granted. Maybe it's time to just admit that Crystal might never get a proper MT and Windows support and instead focus on fixing bugs that is until Crystal gets proper funding. I am sure Crystal devs will keep pursuing the most requested features but I dont think they can deliver it fast enough for people to pick up on Crystal.
I would love Crystal having a "sales" person that would try to pitch Crystal to some of those companies that heavily rely on Ruby. Maybe even approach the japanese conglomerates and companies that would be seeking a faster/better Ruby. I dont think we have anything like this. Sadly.
&gt; Wow thats a lot of nonsense and stupidity. no one said anything was wrong with your emotions. Someone asked an opinion about what could be improved and I answered. I think we are done here. you should re-read your reply to me. you think i'm making "unfounded assumptions" by merely sharing my experience with crystal with you. there is absolutely nothing wrong with that, and i have said nothing that was an untrue about your statements. so in essence, you're saying what i'm doing is wrong, when it's not. i also have a right to share my experience just as much as you do. &gt; Read it before in march. So you assumption was wrong. it had no update. i already mentioned that i agree with you in my OP. it would be ideal, that there should be more updates about 1.0. but you said "I haven't seen an official update in over a year as to where things are in relationship to 1.0" which that blog post was in March, of 2018 that was mentioning 1.0...
&gt; But it hasn't seemed to progress much from when I last used it in January. I'm sure that it has in that time, but to a user, the feeling isn't there merged PR's since January start here: https://github.com/crystal-lang/crystal/pulls?page=81&amp;q=is%3Apr+sort%3Acreated-asc+is%3Aclosed which have around 28 pages of PRs (some are closed though). to say it hasn't progressed much is not true
\&gt; When threads are only lightly coupled, spawning multiple single-threaded processes and communicating over IPC is most likely more performant than multithreading in a single process with shared memory. For any half decent multi-threading implementation, this is not true, ever. Not even close. Even if you have a contained multi-threaded implementation where each thread has its own exclusive heap, which would eliminate data-based race conditions, and provide some limited data sharing via an in-memory storage, it will be orders of magnitude more efficient than IPC. Crystal users have to stop being dismissive about multi-threading. Yes, it is hard and it is complex to implement, but a lot has advanced in terms of user abstractions. Actors, CSP, STM, etc. make implementing concurrent systems considerably more accessible. Most applications today *will* yield improvements by leveraging multi-threading. Saying otherwise just makes Crystal feel out of touch. Even web applications can benefit from it, at least to improve cache locality and reduce memory usage.
Matz is working on a new container on cloud computing that might be worth for the Japanese organization to adopt instead, it’s only this part might be a good way to pitch Crystal in their native language may probably work.
I mean \*really\* lightly coupled tasks, such as handling HTTP requests with no internal state in the individual handlers. Communication between individual processes would essentially be zero, or only signals like HUB and KILL. This is a very common use case for typical web applications written in Crystal. Spawning a single-thread process for n cores and hooking them all up on the same port using SO\_REUSEPORT will certainly be more performant than a single process with n threads. Multithreading always comes with a synchronization overhead. Sure, multiple processes use more memory, but Crystal binaries are typically relatively low on memory usage. I wouldn't even consider this as a potential limitation unless the number of cores is very high.
NB. I don't want to cut down the benefits of multithreading, by any means. It's just that I continually hear people say that a) Multithreading is strictly required for highly-performant applications or will instantly improve performance of Crystal applications. Both are wrong. There are already highly-performing Crystal applications without any multithreading support in the language. And it's unlikely they'll gain more because if MT. And it will require effort to make code safe and performant in a MT environment. We need to ensure that libraries have MT in mind. That's is a lot of work and effectively, many applications probably won't benefit from multithreading as much as public hype suggests. 
I really can't tell anything about the future development for multithreading, but windows support is definetly on the horizon. It needs some more work put into it, but it essentially works pretty far already. I don't see any huge road blockers on the way to become fully native on Windows.
I'm not sure what you mean. I didn't relate to the exchange between you and Mike.
you said "Amen to that", when his reply was towards me apparently "refuting what I said". which was not true
\&gt; That's is a lot of work and effectively, many applications probably won't benefit from multithreading as much as public hype suggests. That is because you are considering MT as an after thought. On a system that are built with concurrency in mind, you can drastically reduce resources if you leverage concurrency. For example, take a web application on a machine with 8 cores. If instead of 8 workers, I have 1 process with efficient MT, I would have: 1. Less connections to the database. With 8 workers, I would probably have a pool of 10 on each, and you will probably be fine with half or one fourth of that. Since prepared queries, caches and many things are per connection, you will decrease CPU usage, I/O and latency. This will make life better for both your app and the database. 2. Metrics. If your application is computing metrics, you can have a single instance aggregating information from all cores, and push that over (likely) single connection. Instead of aggregating everything locally and pushing each one individually. This reduces I/O, CPU and memory. 3. Cache. Because you know that one process in one machine can serve literally dozens of thousands of users, especially because Crystal is performant, you can likely give up on things like Redis and memcached for caching for an in-memory cache. This will reduce latency, give you more control, and remove external dependencies at the cost of memory. 4. Asynchronous processing. You need to perform something in the background? Sure, just move that to a thread, no need to bring a whole queue system for the simplest of tasks. This improves latency and remove yet more external dependencies. The huge majority of web applications would leverage 1 and 2, but 3 and 4 are extremely common too. Having powerful ways to achieve concurrency will literally change how you design your whole system. But that requires you to think about concurrency as a starting point. Nothing that I said above is new. Java has been doing it for years (even with primitive abstractions) but languages like Go, Elixir, Clojure are all about pushing that forward and making it really accessible. Of course, this does not deny that there are highly performant Crystal applications today, but I strongly disagree that it is unlikely they would benefit from concurrency. \&gt; And it will require effort to make code safe and performant in a MT environment. We need to ensure that libraries have MT in mind. This is only if by "MT" you literally mean "multi-threading". Then I actually agree with you. But as I said earlier, most developers leverage concurrency nowadays through more powerful abstractions which makes all of the above much more attainable.
Okay, so you mean using multithreading to put as many parts as possible into a single process. That's a valid approach, but a question of philosophy if you fancy such a monolithic design. I prefer to separate responsibilities a little bit more. The more parts you put into a single basket makes it easier to break. I find that more decoupled components are easier to maintain (smaller scope, concerted interfaces). They scale better horizontally (just add more cores, doesn't matter if it's the same machine) and can be more resilient (if one process crashes, there are still seven others to go and you can easily transfer workers across different machines to guard against hardware failures). I do acknowledged this is opininated and you seem to have a reasonable, but different view. &gt;But that requires you to think about concurrency as a starting point. I think that's probably the gist of it: If you do *think* about it from the start and *know* what you're doing. Otherwise it's just going to break sooner or later because even with advanced tools, multi-threading is still hard to do right.
The only entry in my reply above that would lead to monolithic design is the asynchronous processing one. Bullets 1 and 2 are simply reducing resource utilization. 3 is usually hidden behind a storage abstraction, so anyway goes. In fact, many tools in Ruby do provide those features! But few people use it because MT in itself is not very efficient in Ruby. My point is not that you will always design things like I described but that you have the option to explore them. In other cases, I agree smaller components are simpler and do scale better horizontally. Finally, I am afraid I am beating a dead horse here, but thinking about concurrency is not as hard as you make it sound. If you remove data races, which is not a problem in Clojure, Elixir, and to some extent in Go, then you are left with concurrency issues that are inherent to the system, such as the ones that would also exist on IPC. For instance, issues that arise from having different workers talking to the database. You have to think about those problems anyway, otherwise you end up with bugs like two users winning a bidding auction, which is a concurrency issue. Other than that, solving data races is hard, but that’s a problem the Crystal team should solve so Crystal developers don’t have to. It is not about advanced tools, it is about proper abstractions.
Any links in to Matz's reference? Google search didn't show up anything 
They are already being used internally at Yahoo Japan. And some other places for small tools. The problem is no one wants bet on a pre 1.0 languages with little to no company backing. Japaness companies for various of culture differences has been historically low on Open Sources funding and upstreaming. 
FastContainer
I actually do that for a while (some of the community member know that). I've pitched (and sold) Crystal to many Ruby shops before, and currently doing the same in \[RainforestQA\]([https://rainforestqa.com/](https://rainforestqa.com/)). Migrated two microservices to Crystal and currently migrating a critical infrastructure project to Crystal too.
That's nice however I am just hoping for a bigger company to jump in.
Working on Windows and being a supported on Windows are 2 entirely different things. Do you believe Crystal devs have the manpower to maintain and keep up with the nix ? What if there's a regression affecting Windows ? How big will it be on a priority list ? Also there's a Windows ecosystem that needs to be supported. MSSQL driver and things like that.
Right. Unfortunately for us.
Same here :) Everything takes time though, and I believe 2019 is looking much more brighter for Crystal.
&gt;but you said "I haven't seen an official update in over a year as to where things are in relationship to 1.0" &gt; &gt;which that blog post was in March, of 2018 that was mentioning 1.0. sigh like I said before Thats NOT an update. It just mentions 1.0. See i just mentioned 1.0 - was that an update? &gt; also there are posts scattered all across github and other mediums of devs talking about 1.0 as well duh...thats what I mentioned already. &gt; but it's not like it's being forgotten about. No one said anything was forgotten about. Yet another unfounded assumption you are making. Like i said you are full of them even though you deny all of the ones you have made. I take i you are a young developer so let me give you a tip. Love people and like technology. In this thread someone asked for suggestions and I gave them one. This isn't like someone offended your mom or didn't want to date your sister. No need to rush in with unfounded assumptions and defenses. Its all for thei mprovement of crystal 
&gt; No one said anything was forgotten about. Yet another unfounded assumption you are making. Like i said you are full of them (and I read my replies and they are fine. I stand by what I wrote) even though you deny all of the ones you have definitely made. your entire post was about why the lack of updates in regards to 1.0. hence, you think it's being forgotten about, when it's not.
&gt; your post was partially about the lack of updates in regards to 1.0. hence, you think it's being forgotten about, when it's not. Nope more nonsense assumptions on your part. I made it clear several times the communication was the issue. if you can't read thats not my fault. &gt; let me give you tip. don't assume people are trying to argue with you and give you a bad time, when they are merely just simply trying to converse/share their experience with an awesome language. Nope...You are not merely dong that. You are rather ignorantly at this point making assumptions about others and that adds zero value to this thread.
&gt; Nope more nonsense assumptions on your part. I made it clear several times the communication was the issue. if you can't read thats not my fault. yes, you think 1.0 is being forgotten about (lack of communication), when that is not the case. that's not an assumption. that's a fact. &gt; Nope...You are not merely dong that. You are rather ignorantly at this point also making assumptions about others and that adds zero value to this thread. nice, so more name calling and ad-hominem attacks? it sure does increase your credibility. if you continue to call me names, i will not be responding to you. 
&gt;yes, you worry that 1.0 is being forgotten about (lack of communication), Nope. lack of communication is not the same as being forgotten. You are being quite stupid now telling me what is in my mind. I was entirely right to save you are full of unfounded assumptions. You've proven me correct. &gt;nice, so more name calling I am describing your ignorant assumptions yes. and very accurately. &gt;i will not be responding to you. that would be an improvement.
&gt; Nope. lack of communication is not the same as being forgotten. You are being quite **stupid now telling me what is in my mind**. I was entirely right to save you are full of unfounded assumptions. You've proven me correct. https://media.giphy.com/media/l0IypeKl9NJhPFMrK/giphy.gif &gt; I am describing your ignorant assumptions yes. and very accurately. i've made zero assumptions. you are the one who became defensive over me just sharing my experience with crystal, and trying get you to re-consider it. you turned it all around, and now are putting me down by calling me names. it's pretty sad tbh 
&gt;i've made zero "unfounded assumptions". you are the one who became defensive over me just sharing my experience with crystal, Nope...now you are just lying. I took no issue with you sharing your experience with Crystal only with your assumptions about others. Now you are even claiming to know that I am worried about things being forgotten and lying thats not an assumption. Keep lying it doesn't change the truth. 
&gt; I took no issue with you sharing your experience with Crystal only with your assumptions about others. you quite literally said my gitter point wasn't a "productive answer". &gt; I've heard the gitter thing before and to be honest - its not a productive answer if you want to enhance community growth. Asking new people and even old interested people to scroll through pages and pages of gitter to glean here and there where things are at is not good communication. when it is. because it shows the crystal community is supportive of new people asking questions via gitter. that's part of the experience. and then you made up an issue about "scrolling through gitter", which was actually an **unfounded assumption** on your part, because that's not even what i was talking about. i quite literally said "if you go to the crystal's gitter, and search girng" i never recommend or told you to literally scroll through pages. i was making the point that if you searched for `girng` and saw the results, you'd see how much help i have received. but please, continue with your name calling and how i'm now a liar... 
&gt;because it shows the crystal community is supportive of new people asking questions via gitter. that's part of my experience. Never said it wasn't. That however is not an official update. Is english your second language? &gt;you quite literally said my gitter point wasn't a "productive answer". and its not. scrolling through gitter posts is not a productive way of getting updates. Fact. &gt;and then you made up an issue about "scrolling through gitter", which was actually an unfounded assumption on your part, No its just fact of how gitter works not an unfounded assumption like what you love to make. &gt;"if you go to the crystal's gitter, and search girng" Not what the thread is about. Sorry. &gt;i never recommended or told you to literally scroll through pages. i was making the point that if you searched for girng and saw the results, you'd see how much help i have received. No one denied that you or any other people get support. Its not an official update though so for this thread and topic yep its not a productive answer.
&gt; and its not. scrolling through gitter posts is not a productive way of getting updates. Fact. i never told you to scroll through gitter posts though. now you're just making stuff up. &gt; its not a productive answer. wrong. it definitely is because it shows how supported the crystal community is. 
&gt; i never told you to scroll through gitter posts though. now you're just making stuff up. Sigh more silly assumptions. i never said you did. I said thats how gitter works and it does. &gt;wrong. it definitely is Nope - wrong it isn't. You answered my post with that so I ought to know what my post was about and scrolling through gitter is not a productive answer to get an official update every few months. You can beg till the cows come home its not &gt;it shows how supportive the crystal community is. my post which you responded to states no where Crystal is not a supportive community. I think it is and everyone here wouldn;t be interested in it if it wasn't. If you don't understand English you should be slower to make assumptions. &gt;nice, another belittlement. keep them coming. we have people from all over the world so its fine to have english as second language. look if thats not the issue then the only alternative is you are a totally ignorant soul. No intelligent person tries to tell someone else online whats in their mind and what they worry about. Thats pretty stupid so if english is not your seocond lnaguage say the work and I'll put you on block. don't have time for stupid arguments with people who actually believe they can read minds and emotions over the internet.
&gt; Sigh more silly assumptions. i never said you did. I said thats how gitter works and it does. yes you did. see your previous post above, see the bold: &gt; I've heard the gitter thing before and to be honest - its not a productive answer if you want to enhance community growth. **Asking new people and even old interested people to scroll through pages and pages of gitter** to glean here and there where things are at is not good communication. &gt; my post which you responded to states no where Crystal is not a supportive community. i know? that's part of the crystal experience i was **personally** sharing with you &gt; we have people from all over the world so its fine to have english as second language. look if thats not the issue then the only alternative is you are a totally ignorant soul. No intelligent person tries to tell someone else online whats in their mind and what they worry about. Thats pretty stupid so if english is not your seocond lnaguage say the work and I'll put you on block. wat 
&gt; yes you did. see your previous post above, see the bold: You can't read basic english to save your life. that says that gitter is not an answer to what my post was about which YOU responded to - official updates. &gt;i know? that's part of the crystal experience i was personally sharing with you and I didn't care because once again you assume with no foundation that I am unfamiliar with gitter and the community support there. For the last time my post was not about support but updates on progress to 1.0. Anyway I have no more time for this back and forth. Grown ups go to work. If you are that dense that you think you can read minds and STILL don't know what you were responding to was official updates you need to go on my block list right now. Ending time wasting activities is a new years resolution. bye. you can babble about some other mind reading claims to yourself. 
&gt; You can't read basic english to save your life. that says that gitter is not an answer to what my post was about which you really love to put people down don't you? &gt;and I didn't care because once again you assume with no foundation that I am unfamiliar with gitter and the community support there. For the last time my post was not about support but updates on progress to 1.0. what? if you didn't care, then why talk about "scrolling through gitter pages"? when i never even said that, you made up. in fact, you twisted my words in my OP. that's not what i meant at all. &gt; Anyway I have no more time for this back and forth. Grown ups go to work. If you are that dense that you think you can read minds and STILL don't know what you were responding to was official updates you need to go on my block list right now. Ending time wasting activities is a new years resolution. i cannot read minds, would be cool though. 
I would suggest to not bother too much about that guy, he's particularly abrasive and mostly just throw a tantrum when the 'discussion' doesn't go his way. So far, I've seen it happen 3 times on this subreddit.
&gt; I would suggest to not bother too much about that guy, he's particularly abrasive and mostly just throw a tantrum when the 'discussion' doesn't go his way. So far, I've seen it happen 3 times on this subreddit. i mean now looking back at it, i guess i came off a bit too wordy and giddy in my first reply to him. but honestly, i was just trying to share my experience and good things about crystal, in the hopes of maybe he will reconsider crystal. i'm def not doing that again 
I understand, but a conversation is a two-way street and you took it on you to re-explain/re-word what you meant to help him understand what you were saying (or your new thoughts or aknowledging on what you agreed) and this kind of person won't ever do the same or bother re-evaluating the context: they stick with what offends them (regardless of if it's true or not). So basically, I was just telling you to not bother because I'm pretty sure you're not the one at fault here and it would most certaintly make you feel better.
&gt; I understand, but a conversation is a two-way street and you took it on you to re-explain/re-word what you meant to help him understand what you were saying (or your new thoughts or aknowledging on what you agreed) and this kind of person won't ever do the same or bother re-evaluating the context: they stick with what offends them (regardless of if it's true or not). So basically, I was just telling you to not bother because I'm pretty sure you're not the one at fault here and it would most certaintly make you feel better. wouldn't be surprised if i am partially at fault, and if i am, i will accept it i don't mean any harm against that user but once he started with the name calling and stuff, it lit a fire in me to continue to argue, because i really just can't stand that. btw, thank you for your previous post. it does mean a lot. 
No problem. Also, that's a normal response when being attacked (I would have done the same), don't feel too bad about it. I don't think he realizes how abrasive he is, so there is not much you could have done better except letting go when it started to escalate. But, I'd admit that it's difficult to become aware when it's time to let go (and act on it).
Sill hurt from that exchange long ago. So emotional. I get it. Fanboys are forever upset when they are pointed out as such
Yeah, about that, not really. The last time, I have to admit that I was just testing how you would respond and escalate through arguments. Sorry if I offended (or if this offends you now), but by the way you were name calling, I figured that I had kind of the right to make you show your cards. I sincerely hope that you could someday realizes how offensive are your responses, you're hurting people by doing so regardless of your intentions (good or not) and dismiss yourself from fruitfull discussions. On that note, have a nice day.
&gt; Yeah, about that, not really. Yeah pretty much No name calling just stating facts. When someone tells you they know what you are worrying about when its not true thats silly and unproductive. Its claiming to read minds. Any intelligent person can tell thats a bit much. I do think by the way the poster wrote he has english as a second language. Thats actually not a bad thing. it takes a lot to speak more than one language but it can explain why someone is making a lot of unfounded assumptions but all those assumptions were a bit annoying so I ended the exchange. I actually expected more fanboy responses. You've been the only one really (although the person you are responding to is probably close) and that because your ego was bruised from a past discussion (on it seems the same issue). So my suggestion is the same as to that poster. Love and fall in love with people and merely like things like programming languages. Its actually always more productive and useful to give constructive critiques but there are always a few in a young language that can't handle it because they are emotional and in love with tech rather than just using it. I didn't even remember you but you still are hung up after three months so that might be something for you to consider You have a nice day too though. &amp;#x200B;
It was Crystal clear when the core team set out to build a better language in the space age. We hope it will be a Crystal clear goal when they deliver 1.0 milestone.
[https://github.com/Bombasarkadian/ruby-kaigi-notes/tree/master/day-2](https://github.com/Bombasarkadian/ruby-kaigi-notes/tree/master/day-2) &amp;#x200B; That is the only reference I could find, but doesn't seems Matz is working on it.
It is my understanding that Win32 is intended to eventually become a fully supported platform (tier 1) before Crystal 1.0 is released. That means it will get the same priority as the linux and darwin platforms currently on that support level. The standard library is supposed to be as much platform-agnostic as possible, so the Windows specific ecosystem will primarily exists in external shards. Some important ones might be maintained by the Crystal team, but the majority will be 3rd party contributions. But by the amount of people requesting Crystal on Windows, I actually believe that's a minor problem, once we have reached initial Windows support.
So, Ruby drb system supported this since v 1.8? https://en.m.wikipedia.org/wiki/Rinda_(Ruby_programming_language) http://ruby-doc.org/stdlib-2.5.1/libdoc/rinda/rdoc/Rinda.html Interesting 
Desktop link: https://en.wikipedia.org/wiki/Rinda_(Ruby_programming_language) *** ^^/r/HelperBot_ ^^Downvote ^^to ^^remove. ^^Counter: ^^230143
**Rinda (Ruby programming language)** Rinda is a software library for creating modular and distributed co-operating services in Ruby using the tuple space or Linda distributed computing paradigm. Based on a source code initially released to the Ruby community by Masatoshi SEKI in 2000, Rinda was later absorbed into Ruby's core distributed Ruby (DRb) module. Rinda has been distributed as part of the core Ruby library since Ruby 1.8. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/crystal_programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
looks interesting, this does look like it could just be implemented as a shard (as in ruby) I think I might try to use this to get a feel for the pattern. 
Java spaces was another project based on Linda. Tuple spaces are a great tool to prototype systems with due to their simplicity, but you’ll quickly find that taking a tuple looks a lot like a state machine, and code complexity can quickly get out of hand. If you can keep the interface simple it’s an incredibly useful tool. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/vim] [WIP vim-crystal-compiler: Compiler support for Crystal in Vim](https://www.reddit.com/r/vim/comments/af4keg/wip_vimcrystalcompiler_compiler_support_for/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
I think this is an awesome project! I'm not well versed in Vimscript as I had to break out my book last night to make an autocommand. I'll take a look though.
Adding better crypto primitives libraries and examples is never a bad thing. Choosing either Nim or Crystal are hard choices in this regard for cryptocurrency project, so don't worry too much about the floodgates ...
Aside from parallelism it feels surprising baked. I've been evaluating Crystal for a new project and have to say that it's far better than I expected. The standard lib is intuitive and syntax works as expected for an experienced Rubyist. Unfortunately the way that network primitives are scattered around the stdlib (just like Ruby) feels lacking compared to Rust, Go, or even Nim for doing the kind of heavy lifting that's expected of a compiled and statically typed language. Basically everything is there, but I got kind of spoiled by Golang's Net package which is very thorough and well organized. Probably a good oppty for a high perf networking shard. Speaking of golang, the LLVM backend and C ffi to Crystal *feels* so much better*.* To be honest, I'm really surprised that more Gem developers haven't ported their work to Crystal. My hope for you guys in 2019 is that more people discover it and contribute. 
Great! Let's get in touch
Author here. This is still WIP, but happy to answer any questions / take suggestions / receive feedback. My first crystal project! Since I do a lot of web development (and love Vue.js), I wanted a way to better integrate w/ the awesomeness that is crystal on the server-side. 
Great work! A small hope in my Head was that one could actually skip the nodejs backend process and render a .vue file straight into html in crystal (small subset of features would be enough) - this would be a complete gamechanger for me. Sadly, this is not the case, but also my own fault because I associated this with the project title.
10000% this. that was actually my vision when I started the project (and, frankly, it's still a long-term goal!). For an MVP, though, it probably saved me 200 hours to do this with a node process since the ecosystem is already setup and you can fire up a Vue SSR process in node relatively trivially. There's a crystal project called [duktape](https://github.com/jessedoyle/duktape.cr) that embeds a lightweight JS runtime in crystal (via C bindings) and I started by investigating that. Could still be an option. Even better would be to call the V8 engine directly via C bindings. Or, of course, simply implement the Vue compilation process in Crystal. Anyway lots of options and will gladly consider those in the future... Thanks for the feedback!
Fantastic! This is awesome! Although I'm trying to use SPA where possible, some pages need to be rendered server-side, for example, an OAuth2 authorization page. You shard will make it possible to write Vue instead of raw HTML! Thank you! &amp;#x200B; In the future I'd love to see this project somehow making use of Vue CLI with all its zero-configuration thing, so you wouldn't need to use webpack to extend the functionality! &amp;#x200B; I'm a little bit concerned about the built-in routing. Shouldn't it be disabled by default as soon as all the pages are rendered on the server? :thinking: I.e. when a user clicks a link on a rendered Vue page, the request should go straight to the Crystal server, shouldn't it?
Thank you for the kind words Vlad!! I was worried about the routing too (I know client-side routing has a time &amp; place, but not by default). I think - and at from initial testing this is the case - that even though we're loading up vue-router on the client, unless you use the &lt;router-link&gt; vue component, you won't actually be using client-side routing. So this is another best-of-both-worlds situation -- &lt;router-link&gt; is there if you need it, but by default regular links are regular links. (And from my testing, the request for a regular link does indeed go straight to the Crystal server)
This is awesome!
So, for B4, which the errata states is "Production ready, sent to layout" we see all the "good stuff", the interesting stuff, i.e. concurrency, is... removed! They slimmed the book down a couple of chapters (and double-digits number of would-be pages). &amp;#x200B; Fine, I get it, the Crystal team themselves don't know when they'll have concurrency up-and-running (which made me stop following this language all together), but... if you start a "Preview" edition of an up-and-coming language, either: 1. Have it in "Preview" state for as long as needed, i.e. until the language is feature-rich and said features are stable enough that you can write a tutorial book about them. Or... 2. Don't start the book at all! &amp;#x200B; (For example, the competition, Nim, is already post-1.0 and has A SINGLE OFFICIAL tutorial book, but it's a comprehensive one at that (not very surprisingly, it's by Manning). &amp;#x200B; Personally, I've given up hope of using Crystal in a concurrent way any time soon (and with that, hope of using the language at all), and with this bait-and-switch by PragProg, I'll think twice before any other purchase I make on their site. (Two concurrent threads at once, you might say). Just my two (concurrent) cents... 
Try Show HN too, I like to hear how it’s useful for others to adopt Danger As A Service.
So excited about news of Crystal on production. I hope that some other company will use it to make Crystal more popular
Wow this is really exciting 
you are everywheeere :P
You know the saying, if you have nowhere to go, you are everywhere at once :P 
Here's a sample that should help you: ``` require "openssl/cipher" # --- ENCRYPT --- key = Random::Secure.random_bytes(16) iv = Random::Secure.random_bytes(16) plaintext = "Some plaintext" cipher = OpenSSL::Cipher.new("aes-128-gcm") cipher.encrypt cipher.key = key cipher.iv = iv io = IO::Memory.new io.write(iv) io.write(cipher.update(plaintext)) io.write(cipher.final) io.rewind data = io.to_slice # --- DECRYPT --- cipher.decrypt cipher.key = key cipher.iv = data[0,16] data += 16 io = IO::Memory.new io.write(cipher.update(data)) io.write(cipher.final) io.rewind puts io.gets_to_end ``` You can run it [here](https://play.crystal-lang.org/#/r/63q4). Without much code it's difficult to help you more than that. Generally if you're sending encrypted data, you would store the ciphertext and iv separately, like this: ``` { "ciphertext": "VB49UrDm33AvqTAq7m4=", 'iv": "wbqygmjC2vFNigiCzeAtRA==" } ``` Although I'm not sure what your application is. Hope this helped you.
What is the rationale behind all the abbreviations? Why not have an api that says 'payment', 'future_value' etc? 
I went with what Excel/numpy use as that seems to be the standard naming convention for these functions. Cheers
Can you elaborate on the network primitives? I am using Crystal for a personal api server and so far the standard lib has been sufficient for my use.
It's not a biggie. I was commenting on organization, not really a lack of features. For comparison, checkout [https://golang.org/pkg/net/](https://golang.org/pkg/net/) \- note how everything is neatly classified / organized there. Crystal's API reflects (pun!) Ruby's API, which is a bit disorganized in contrast. 
Busybox is your friend! Are there any folks out there building serverless stuff in Crystal with OpenFaaS? 
Ah! got it. Thanks.
&gt; an interpreted compiler Superposition requires quantum computing.
&gt; an interpreted compiler backend
Thanks for putting this out there. I'd been doing something similar with the ysbaddaden Crystal Alpine images previously but there were a couple of oddities to it (and may not have even been officially supported). It looks like Crystal has first-class alpine support now so I'm going to give this another go following your guide. The fact we can run from scratch is a bonus!
"awww crap how do i cross compile the compiler again" day came around quick!
😅
There’s a SDL2 shard that’s super easy to use to make a window 
The slow compilation is largely the result of the type inference algorithm and thus it would not be improved by interpretation rather than compilation.
Oh... I see, but would interpretation at least help with feedback loops?
Possibly, but how useful is debugging if it only works on a runtime that you don't use in production? I would rather see a debugger that worked well for the compiler.
There's these repos of mine - just open up a window: https://github.com/Groogy/crystal_lib_glfw3 - more basic rendering: https://github.com/Groogy/boleite
Nim is not 1.0 yet.
Nice work. FaaSt turnaround! ...I'll see myself out...
What exactly does it do?
Hows the windows support coming along? We nearly at beta yet?
In theory theres a QT5 shard, but I'd be damned if I can get the thing to compile. I'm a bit concerned its abandoned.
Exactly. The linked page doesn't say, either.
Looks to be Lambda style serverless execution. Now with Crystal support.
FaaStRuby is a serverless FaaS platform for Ruby developers with first class support for Crystal - for when you want things to be really, really fast :)
hahaha thanks.
I've been thinking about an interpreted Crystal for a while too!! I think it could allow some very interesting things :)
I think that you can actually just fork the compiler (it's bootstrapped so it's written in Crystal) and add another backend - I didn't read the source but I'm sure that this won't be too hard and can be done by a small team. The interpreter can be written in Crystal.
You don't even need to fork the compiler, i can `require "compiler/crystal/syntax"` and play with that :) I know crystal's compiler and most of how it works, i've read many parts of it and did a few pr already! 
How is it different from the `vim-crystal` plugin? (apart from the fact that the quickfix list is pretty badly populated in that plugin 
I think the idea was to write bindings only for what you need. Wrapping a big lib with every fn call is going to be a big task. Nim has a little utility called C2Nim that automates a big part of the job. It would be pretty cool if a brave and smarter-than-me soul built such a thing for Crystal. 
Nim's not particularly complex, I might check it out. Thanks! 
You may want to hit up [https://github.com/girng](https://github.com/girng) on the crystal gitter chat. Experience with both godot and crystal..... might be a good place to start.
Almost as helpful as telling me about that person is telling me about gitter. Thanks! 
So, checkout https://github.com/oprypin/crsfml, this project and oprypin has all the info you might need, also, gitter ;) 
&gt;A direct implementation in [~~#~~**CrystalLang**](https://twitter.com/hashtag/CrystalLang?src=hash) with no special effort at optimization delivers nearly equal performance! Crystal is using one core, Go 2.5 cores. smokin'! 
Crystal is the future! 
Damn. Hopefully that will be supported in v0.30.0
Why not showing some number?
I'd guess because it was just a quick off-the-cuff tweet and not a detailed study
Well the concern is that it's development will slow, or cease. If there are not enough businesses that rely on Crystal enough to help keep it developed there is the potential that the language could fizzle out and die, leaving you with production code on a dead language. Like you pointed out it's not something specific to Crystal but something that needs to be taken into consideration when picking any new technology - is there confidence that the stack you choose will continue to prosper while you use it?
This is risk assessment on the language. Meaning that he associates high risk with choosing a language not backed by a large corporation. There are other factors to take into consideration when choosing a language, but if you really cannot take the risk that the language becomes irrelevant 5-10 years from now, then not having major backers could be a red flag. That being said, like I said, other factors are also important to take into consideration: growing community, skill reuse (meaning Ruby-skills --&gt; which was the same selling point when Node.js became popular), active development, what kind of problems are your trying to solve with the language (scaling issues maybe), etc. Otherwise, going from Ruby to Rust seems a bit drastic: there are some low-level concepts to tackle when making the jump to Rust. Going from Ruby to Go is easier and makes more sense to me, so I would take what he said with a grain of salt. On my part, Crystal served me well on some scenarios where I would use Go for the task. Also, when choosing a newer language, you don't have to put all your eggs in one basket: if possible, you can extract just some part as an api or a cli that could be used with other languages or the main application (which is what I've done so far with Crystal).
In my humble opinion, having mayor backers is not as much of a problem as the lack of tangible progress, transparency, and clear goals/roadmap regarding the language. This has been asked and answered several times both in this subreddit and on the live Q&amp;A sessions held by the core dev team. I do respect core dev decision on this. I am a fan of this language and I wish I could use it for work, but I have tried several times to sell it to my company, but at the end, I couldn't for the reasons aforementioned. I do, however, use it for all my pet projects and I'm loving it. 
&gt; Otherwise, going from Ruby to Rust seems a bit drastic: there are some low-level concepts to tackle when making the jump to Rust. Going from Ruby to Go is easier and makes more sense to me, so I would take what he said with a grain of salt. They just rewrote their dispatcher, and I think that cleanly implementing an algorithm in Rust wouldn't be much harder than doing so in Go. And as for performance, rust can offer a 2-4x performance increase compared to Go, which is very much worth it if a large part of total time is spent in this part of the code. Especially for an organization as large (or at least as widespread) as deliveroo. It's not unreasonable to think that deliveroo is getting into the territory of hosting costs far exceeding the very small difference in the cost of dev time for implementing this code in Rust instead of in Go. 
I don't give a shit about backers, but I do care about basics like documentation and unfortunately Crystal's biggest web framework Amber, has very loose and lacking docs. Something as simple as enabling CORS for simple API's is a mess and I literally had to dig down into the CORS plug to figure out how to call it. I'm sure it'll get better, but I'm staying away until it does. --- *I know my feedback is purely about Amber, but that's the main use case I have given Crystal so far.*
Yeah... scratch what I said about their choice compared to Go, I might have been a bit too fast to give my opinion on that (didn't think too far ahead on this one). &gt; I think that cleanly implementing an algorithm in Rust wouldn't be much harder than doing so in Go Well, I've done both and, unless, you've been doing some Rust for a while, I don't just "think", but know that unless you need Rust for some memory-safety that it offers and low-level cases that you would use C/C++, it's easier to transfer from Ruby to Go than from Ruby to Rust for non-trivial code (I'm not saying Go is better, but it's easier to grasp in it's entirety). &gt; rust can offer a 2-4x performance increase compared to Go I don't think that you can possibly know that unless you have access to their code and have benchmarked it in both Go and Rust (for what I've seen, Rust is faster, but not by that much and it's rarely the decisive factor when compared to Go for the same task). &gt; hosting costs far exceeding the very small difference in the cost of dev time for implementing this code in Rust instead of in Go Also, you have to keep in mind that they have not migrated from Go to Rust, but from Ruby to Rust which for sure makes a difference in hosting cost but, again, I don't think that you can possibly know the difference in cost between Go and Rust unless you've done both. After a little bit more consideration about their choice, I think that their decision came down to what language would be beneficial to interface with Ruby and speed up some bottlenecks and, for this scenario, C, C++ and Rust (which most likely, some devs at Deliveroo were already using) are common to use... and Go not such much I must admit and I wouldn't recommand it either if it's to interface directly with CGO. It's a better candidate if the code is to be extracted as an api or a cli like I suggested for Crystal earlier.
You could take this as an opportunity to contribute to the documentation. So far, I think that they did a pretty good job about having the basic neccessary documentation to get you started with the framework.
I feel you, I may actually do that. There's so much potential here, and if only the docs were much better and hand-holdy for the obvious use cases usage would probably increase a lot.
Those are valid reasons for not choosing Crystal. There is real concern about the future of the language and the pace of development and the leadership of the core team
I see this a lot, but my company went full steam with crystal. We’re running several Lucky apps in production which handles several million users. We do see some issues here and there, but for the most part things are pretty stable. The way I see it is, as long as it works, we will continue to use it. Once it stops, we will use something else, but until then, it’s all crystal! 
I've done a little bit of work with Amber but I think it lacks direction, which affects its update and continued development. Out of the box it asks you which ORM and templating engine you want to use - it can't even make those decisions for you. The team seems to hold backwards compatibility with high importance, despite both the language and framework not having hit 1.0 yet. Crystal needs a gold "MVC framework" and I don't think Amber fits the bill.
I agree
How many developers are coding in Crystal?
Name one successful programming language with no or very little corporate backers.
Ruby 
I would argue that Ruby still has a lot of corporate backers they are just scattered all over the place.
I am running Crystal in production and I am very satisfied with the results. The core components of FaaStRuby are built in Crystal, and I don’t plan/need to change that. I want it to be a big case of using Crystal in production, and at the same time help accelerate the adoption of the language by allowing users to easily put their own Crystal code in production. So I clearly don’t care about having large corporate behind it. There are other kinds of work required to ensure the longevity of the language besides contributing directly to its development. All that being said, have you guys tried the Lucky framework? Kemal? We should be actively promoting those alternatives!
There's also the fact that it hasn't hit a major release yet; things may change quite a bit before it does and that could easily break a codebase. I wouldn't go so far as to throw Crystal into the "toy projects only" category, but I'm cautious about when and where I choose to use it at work for exactly these reasons.
So I should maybe bracket this by saying I do totally see where you're coming from and that interop with Ruby probably was a big factor here, and I definitely agree that in cases where you might migrate to Go it would probably be a *great* use-case for Crystal. Buuuut... &gt;unless you need Rust for some memory-safety that it offers and low-level cases that you would use C/C++, it's easier to transfer from Ruby to Go than from Ruby to Rust for non-trivial code I'm not sure that this is actually the case. When I'm writing Rust it does often tend to be because I want that really low level of control, but I've also replaced some little bits of Python with Rust that's barely more low-level if it is at all. It's definitely a specific set of cases where there are way higher level crates available, but even if you have to deal with a bunch of low-level implementation details, you could typically get that stuff in place and then make it opaque to people working with whatever API you've exposed, which is really a big part of what languages like Python or Ruby or Go or Crystal do themselves, isn't it?
Lucky seems to be the way to go. It makes bold decsisions and tries to forge a strong identity. It's still a bit young and lacking functionalities, but it is more promising IMHO.
It would probably make more sense to use the Ruby-like convention of snake-cased words, e.g. `present_value` instead of `pv`, or at least aliasing the methods in this way.
What company are your working on?
Not the first 10 years or so. Ruby appeared in 1995 and Ruby on Rails in 2005.
Fair enough. But I think it is really a tough market.
Yes, you are right, but in this case, you're actually accustomed to Rust with probably already some set of tools already in place. I was stressing the point that all things equal, Go is easier as a transition when coming from Ruby when it makes sense to use Go. It always possible to simplify usage of some complex code by wrapping it by a sound api, but it doesn't make the language less complex, just the usage of that specific case. I'm not arguing about which one is better, but which one is easier to grasp in its entirety as a language. The same logic goes when comparing C to C++, C is less complex than C++ (and again, not saying that C is better than C++).
Yes it is
That was true at one point, but nowadays Matz (and a few more IIRC) is employed by Heroku, which is a division of Salesforce, which has some $8 billion yearly revenue. 
&gt; That was true at one point Well, we are in the same point :-) 
We have a 3 dev team.
I can’t really say the name, but it’s in the adult entertainment space.
Here is was thinking ... Millions of users but only a 3 man development team?! &gt; but it’s in the adult entertainment space. Ok, now it became clear *lol* I assume your company is also a financial backers for Crystal? https://salt.bountysource.com/teams/crystal-lang What did you run before using Crystal? PHP/Ruby? Did switching to Crystal make a difference? Maybe a blog post in the future?
We donate to crystal individually, but haven’t convinced the boss to donate as a company. Sorta hard to put our name or logo anywhere :p We use Ruby still and have several rails apps as well as a few node and PHP all in production and then a little go and elixir sprinkled randomly around. We are a small team, but I’m the “jr dev” with 15 years experience lol. The switch has allowed us drop servers left and right as we can use less resources. It also speeds up development quite a bit because the compiler forces us to catch bad data errors. Our hosting costs have dropped $1,000~$2,000/mo so far. We still have some more work to do to get that cost down. I blog on dev.to pretty often, so you can find me on there to check some of those out.
Yes, lets hope we persist long enough to change that :)
And it handles several million users? Then why is everyone so afraid of using Crystal? This case right here is a proof that Crystal turns out to be a happy ending for millions out there. &amp;#x200B; (sorry, I've been reading too much Cyanide &amp; Happiness lately...)
Feedback welcome. Any issues/suggestions feel free to make an issue.
Everything is not successful unless it succed
I like that you added constraints for the params. I haven’t used annotations yet; does the placement right above method definition lock it to that method? Would it fail if there was a space between that and the method? They couldn’t be defined in a module then included, right?
Thanks, I made the PR for the router I use, so it's not limited to Athena. https://github.com/amberframework/amber-router &gt; does the placement right above method definition lock it to that method? Yes, the annotation above each method "registers" the "action" for each route. &gt; Would it fail if there was a space between that and the method No, it would work just fine. &gt; They couldn’t be defined in a module then included, right? Correct. But i'm not sure why you would want to do that? What would your usecase be? 
No real usecase. I’m just trying to understand how crystal annotations work. I’ll have to try using them in something so I can play with that syntax.
Gotcha. If that was a general annotation/crystal question, then yes you totally can do that https://play.crystal-lang.org/#/r/6a1z. However, it wouldn't work in specific regards to Athena.
Please take the time to at least give a one sentence "what is it?".
Yet another web framework 
Probably the link to GitHub won't provide as much information as their web, so I will link it here: https://onyxframework.org
Yes. But, why?
Because Crystal is a fantastic language, and a language in this space needs a full stack answer to Rails. In developing such a framework, you end up with some great extractions for things like object-relational mapping, templating, routing, http protocol, routing, etc. with a chance to build on what previous frameworks have done right while avoiding what they did wrong. Even if it never gets 1/1000th the momentum of rails, the exercise itself is valuable. “What are the consequences on full web stack development of the design goals Crystal has?” Is an interesting question to answer.
Do you have something like a 15min from scratch app tutorial? _(similar to what rails provided back in the days..)_
Sorry, what is this? I visited the website and still don't get it
Is "configuration over convention" a typo?
No Idea, I'm not involved in the development of this project. I saw it on my Twitter Timeline and I thought it might be of interest for Crystal's Reddit community
Seems to be a new Crystal framework. For what I could check, looks like https://github.com/onyxframework/onyx is the main component, and you can plug and play additional components such as a web server, REST support, ORM and such.
Guys, as a community we really need to get better at welcoming and supporting projects and initiatives. The hostility/flippancy in here is disappointing, honestly. I'd dabbled with Onyx::SQL for a past project and I really liked the abstractions. It was nice to work with, and if you aren't reaching into the depths of database specific features you'll do well. From what I know about Vlad's rate of programming and care for his projects, this framework will do well and is probably already a good choice if you fancy experimenting with something new. That's not to say I can't empathise with the desire for Crystal to converge around one or two main frameworks but I've found that each of them do bring something to the table and are worth considering on their own merit.
Agree with that. A one sentence describing what it is should be provided. Also a list of features of the \*framework\* should provided, the features on the top are for Crystal.
Thanks for kind words! &lt;3
Right now there is [https://github.com/vladfaust/crystalworld](https://github.com/vladfaust/crystalworld); I'm working full-time on these things, and tutorials are on the way
It is a framework - for what? Web Server? I see some http handler and rest is mentioned , but I can’t find an information what kind of framework is it.
It seems to be a very basic HTTP framework, providing a way to build REST APIs, handle HTTP requests and send responses, interact with some SQL databases through an ORM, and more. So, it isn't exactly a web framework in the sense that something like Rails is, but more of an HTTP framework. At least that's what I could come up with at a glance. Hopefully OP can correct me if I'm wrong.
I noticed the same thing and agree with you completely. Crystal will likely converge more around specific things naturally in the future, as it becomes more stable and hopefully more widely used. It makes sense that there's a lot of "competition" at this point, which is exciting in a way. I miss the days of old in Ruby when there was a hot new gem every day. As languages mature and stabilize, packages do as well. 
Thank you for your effort! A doubt, I see that the framework is very minimalist (like sinatra/kemal), right? you plan to build something on top of it more like ruby on rails or amber?
Onyx consists of a number of loosely coupled components. It definitely allows to build web applications with \`Onyx::HTTP\` and \`Onyx::REST\`, but \`Onyx::SQL\` is not necessarily about web -- you can use \`Onyx::SQL\` in desktop applications as well. In a couple of days \`Onyx::EDA\` (Event-Driven Architecture framework) will be released, which is also not tied to web. Thus said, Onyx Framework is not a Web framework, but a generic framework with components suitable for many tasks.
The framework includes many elements to build full-featured applications. It's richer than Sinatra/Kemal in terms of web development because it includes powerful Action-View REST layer inspired by Hanami; and it also has an ORM.
I hope not
Why? I didn't know this was a stance someone would have. Wouldn't that describe anything that doesn't have conventions
Well, yes. But it is nice when it is explicitly stated. Conventions are nice when you get started with a new thing but it can become a pain later on if you happen to disagree with one of the conventions.
&gt;Vlad Any benchmark?
Company politics also play a big part. it’s the same within the animation industry, I work in if it’s not industry standard then we are not using it, or not worth its weight regardless how awesome it is. all movies are either created in three applications and even though Blender exists it’s still the black sheep. It’s why for an example Oracle has always been a big thing for databases and why they can make buckets of money from. If i am to partner or get into the bed of another’s company how can I pitch what I want with a language that isn’t well known? All other comments are valid but when i’ve tried to push something else, Debian for CentOS it’s always come back as “well redhat cuz” it sucks. 
I'm currently working on that part
Hey, wanted to share the article with you before posting it somewhere else like HN or another subreddit. Feedback very welcome! Also got an updated website at [https://onyxframework.org](https://onyxframework.org) \-- check itr out :)
Pretty impressive ! The framework looks very good, although many things have to be done by hand, such as generating migrations :( A doubt, another orm? why? there are 3 or 4 in crystal. I hope you create a module to work with html. &amp;#x200B;
params dsl can use requires or optional, likes ruby grape
I loved the website. But I have some questions. Why another web framework, and why another orm, instead of contributing to already existing ones? Just curious. Is Onyx based on any web framework from another language or is entirely new? 
I know The Pragmatic Bookshelf have released a book about Crystal here : https://pragprog.com/book/crystal/programming-crystal I have not read it yet, though. Apart from that, I usually turn to Gitter and the official Crystal forum for help.
Also, if you come from a Ruby background, there is Crystal For Rubyists: http://www.crystalforrubyists.com/
Thanks, I just buy the book and start reading.
I can recommend this book. I bought it immediately when it finally became available as a beta ebook. It was announced since already in 2017, and I thought it got silently canceled because nothing happened until the end of 2018. The book is well written, examples make sense. Only the fonts could have been different.
If you don't, Crystal is kind of built for Rubyists, and there's tutorials everywhere for Rails. You could learn Ruby first and leverage that into learning Crystal. 
It's not a time-based thing, it's based on feature-completeness. 1.0 won't happen until we have multi-threading and first-class windows support. If you don't need to use it on Windows and `fork` does good enough for you then it works fine now. 
There is actually a roadmap: [https://github.com/crystal-lang/crystal/wiki/Roadmap](https://github.com/crystal-lang/crystal/wiki/Roadmap) It's not super detailed though and there is no time frame for any milestones. But it gives a general overview on what's planned before 1.0 There are probably some things missing. And not everything listed there will need to be done before 1.0.
(Oh, and it might not even be Crystal's roadmap. It could even well not be a roadmap at all and you could be reading this post on MySpace or hearing it backwards in a subliminal 70s hippie song.)
Very nice
Love your commitment and passion, very impressive!
Sounds like Crystal is still yet to go through a mayor re-writing in order to achieve some points on this Roadmap. Given the current amount of work that the Core Team can put into the project, do you think is a realistic roadmap? What do you think is required to help the language to reach this 1.0 status?
Great job, I use the Ruby version regularly I'll definitely start using Crystal's too! Thank you.
And Ruby wasn't even close to popular or successful until Rails came out. 
At least in the recent past there haven't been that many breaking changes so I think you should be fine. Worst case scenario you can just stay with 0.17 until you finish your project.
I think we're at a point where the will most likely not be any substantial changes to the language. We will certainly continue to have breaking changes to both the language and stdlib APIs in upcoming releases until 1.0. But it should be relatively easy to adapt existing code and every release will have instructions for this.
I think lucky is the most important project in the crystal ecosystem. It's the only project that attempts to leverage idiomatic crystal, strong typing, and compile time correctness to web development. Great work lucky. I wish the core crystal team had your level of commitment and dedication to the language itself.
Thank you for the kind words. Those are indeed some of Lucky's core goals so I am glad that came across. &amp;#x200B; I think the Crystal team has been doing a great job with the time and resources they have and can't wait to see what happens next. Even with Crystal in its current state, I absolutely love it!
[nope](https://github.com/crystal-lang/crystal/issues/921)
It would have been nice to be able to write libs in Crystal that you can call from Ruby.
Well that's possible iirc, using the ruby API, and making a shared library load1ble by the Ruby VM
Can someone explain to me why a DownTo Loop is better? Other than being shorter. &amp;#x200B; &amp;#x200B;
I would imagine the answer was obvious. But let's explain it a bit. &amp;#x200B; If you have a hundred million dollar business depending on the X, whether X is software, tools, trucks, or anything, you want to make sure X have a path forward. For a printer, that means replacement cartridge, for cars that means servicing parts. For Software, you want the company do continue to be in business for next 10 years and offer support. That is one reason why Startup might have decent products, but never get any traction in Enterprise. It doesn't matter even if your product is free, no one wants to save a few thousand dollars and risk a hundred million dollar business. ( That is until they get a Big name customer on board, then everything else will move ) &amp;#x200B; In the case of Crystal, if the team decide they will stop developing it, and no more update, no security release, are your company going to take the burden and do it all yourself? From Compiler to ToolChain? Unless you are Google, IBM or Apple, where you could afford to even design the whole ecosystem from scratch. &amp;#x200B; That is precisely the reason I have been saying for years about Ruby. You need more people learning it, and more company betting on it for the whole Ecosystem to be growing and sustainable. It won't dead in the sense as no one using it, there are even people doing Perl. But if you cant find jobs with it, it will forever remains in niche. And a vicious circle that goes to no one learning it, less contribution to it. No more modern tools, people leave because of that, Rinse and Repeat. Ruby Rails remains fine in places like UK, US and Japan. And some part of EU, but outside of that, you cant even find jobs in China, Taiwan, South Korea, India, SEA. And those are huge market. &amp;#x200B; May be this whole business sense and ecosystem thinking is a little hard to drill into programmer's mind. Mostly because they don't care. &amp;#x200B; Moving back to Crystal, it is perfectly fine to do some small tools with it. Yahoo Japan has been using it internally. But for anything minion critical, I doubt any big corp wants to touch it ( Yet )
Type inference could make things super weird for REPL. If I make a snazzy_print(x) function, later when I snazzy_print("string") its THEN that snazzy_print gets its type. Its all a bit lazy and lazy things can be strange to debug 
It's a little bit more diverse. Theoretically, you can do it. But practically, it's difficult because Crystal expects and uses a rich runtime library including garbage collector, scheduler, io handling, regular exceptions and more components. This all would need to be included in a dynamic library because Crystal's stdlib needs it. And that would likely lead to collisions with similar components in the binary or other libraries. These issues are all caused by the stdlib because it needs a certain environment and expects to be the single king in its space. The language itself supports compiling as a dynamic library.
Because all the logic for controlling the loop is in one place: \`99.downto(1) do ... \`. In the example using \`while\`, that's three separate lines.
You can totally use FFI to write gems on top of crystal lang code. much better than cgo ... 
Best thing ever. Best of both worlds. Cant wait to see updates on Crystal.
That's so true I concur.
one of the things I love about Crystal BUT lets give Ruby a lot of the credit here. Crystal was inspired by Ruby and that came from the wisdom of Matz its founder. &amp;#x200B; and as a caveat there ARE differences so be careful
Thanks for keeping at this! I dabbled with Lucky a little and unexpose was one of the patterns that threw me off a little - well done on removing that requirement.
Thanks for the feedback! This was a huge annoyance and I’m glad it is gone too :D I hope it’ll make things much easier now 
my pi3 is dead due to a cat related accident but I don't recall having any problems. it's working fine on armv61 though. https://i.imgur.com/oxROvld.png
Works fine on my PI. I'd start from scratch and recompile crystal see if you made any mistakes along the way.
Also funny thing, if you miss some shard in Crystal, you can just copy ruby gem, little modify it, and if it not hard metaprogramming or c bindings, it works already.
You are missing libraries. Install libgc, libevent, etc.
Nice! Great read for the morning coffee , its awesome Crystal is used by info-sec peeps , great job and a great writeup 
Thank you for the kind words. I'll be releasing part 2 within the next week or so. I'm really excited to try some of the new tricks I found out.
I'm pretty sure I'm going to expose my reddit username due to the timing of this, but if you're able to show the pull requests over on the carbon repo some love I'd have much gratitude - some are getting a little stale. No harm if not though (as hopefully goes without saying) all of this is a labour of love!
Thank you so much for this! I just realized I was not watching the repo so I did not even know there were pull requests. I'll look soon!
`--release` flag just tells LLVM to compile it with optimizations and such, not that it should be compiled statically. For that you need to use the `--static` flag, however this only fully works on Alpine linux currently. Some links: https://github.com/crystal-lang/crystal/wiki/Static-Linking https://forum.crystal-lang.org/t/run-executable-on-another-computer-without-crystal-installed/448
no, sometime works, sometime error.
Weird. To be honest I actually use crystal in docker to avoid this kind of crap. If you want I can share you my dockerfile so you can use it yourself.
You can't link a binary for MacOS on Alpine...
What's wrong with the answer on the forum? [https://forum.crystal-lang.org/t/run-executable-on-another-computer-without-crystal-installed/448/8](https://forum.crystal-lang.org/t/run-executable-on-another-computer-without-crystal-installed/448/8?u=straight-shoota) You should be able to statically link libraries when you have them available as static libraries (\`.a\` files). This should work for \`libgc\` for example. You just need to convince the linker that it shouldn't link against the dynamic libraries that are also available. Of course you can also pack your application with the required dynamic libraries, but I'm not familiar with the MacOS specifics.
Oops, I updated initial reply.
&gt; even when linked on Alpine Still doesn't make any sense. You link MacOS binaries on MacOS and Linux binaries on Linux (such as Alpine).
Is there a way I can package the libs for crystal in a .framework file, and ship my binary with it?
Static linking isn't entirely working either on Alpine: https://github.com/crystal-lang/crystal/issues/4276
I try docker crossbuild with [https://hub.docker.com/u/multiarch/](https://hub.docker.com/u/multiarch/) it fails to compile.
ouch mosquito is a really confusing name. Took a long time before I realised we weren't talking about the MQTT broker (Eclipse Mosquitto).
Weird but I find the API documentation[0] of Crystal more readable and easier to navigate than Ruby hmmm [0] - http://crystal-lang.org/api/
There should be more information on the exact failure in the output above that line. But you're most likely missing one or more of the libraries required for building your application. Make sure you have \`libpcre\`, \`libgc\`, \`libpthread\`, \`libevent\`, \`librt\`, \`libdl\` available. Without any further information on your environment, I can only recommend looking at the installation instructions provided at [https://crystal-lang.org/reference/installation/](https://crystal-lang.org/reference/installation/)
Hey guys, I've updated (or better say, released) the framework documentation. There might be some typos or even bugs. Let me know if you catch some! :D
Very good effort, thanks for taking the time to make that. I think crystal clear documentation (hehehe...) is crucial for the ecosystem
Just wanted to draw a table but ended up with a library ¯\_(ツ)_/¯ Some thoughts on crystal: - love the idea of enums for type safety but as a public API can get quiet long when namespaced? - miss the send method in Ruby but will look into macros to help with some boiler plate - function overloading is pretty handy I think also encourages you to make more small objects so you can pattern match - structural typing doesn't work when passing things to initialize
really useful
&gt;love the idea of enums for type safety but as a public API can get quiet long when namespaced? You can actually use symbol literals representing enum names as method arguments.
omg that's great! Thanks for point it out /u/straight-shoota
Hi all, just starting working a bit more with Crystal and assembling some tools. Hopefully they can be of use to others as well. For those working on multiple libs and projects that may build against different compiler releases this is a super thing wrapper for the CLI that will let you run builds / specs / doc gen against the release defined in your shard.yml. Any artifacts will dump back out to your local filesystem as though the process was run locally.
Does it deep json?
Good work! That got me thinking, how much effort would be required to make a clone of nvm/rvm for crystal? Even with just the main command, I think that could be quite useful
Thanks! Rather than re-inventing the wheel, I'd highly recommend checking our [https://nixos.org/nix/](https://nixos.org/nix/). It solves a lot of common dependency management issues in a very elegant way. This is just a cheap nasty hack as all the compiler releases are already packaged in docker containers but there are not public nix expressions for each of them (major releases yes, but the minors don't appear to have entries in the [public packages repo](https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/compilers/crystal/default.nix)). I also have a few colleagues that I'm yet to convince to drink the kool-aid so this is a low-barrier to entry alternative for providing common build environments.
There is already [crenv](https://github.com/pine/crenv). However, I don't think such version managers are as useful for Crystal as with interpreted languages. You only need the compiler once to build an executable, which then runs without a Crystal installation. With compiled languages it's also easier to stay on top of development and always support the latest version (especially after 1.0 is released which will guarantee backwards compatibility).
Nice! Didnt know about crenv :)
There's also https://github.com/quicktype/quicktype (which supports crystal, too). Not to lessen what you did, just pointing out possible alternatives :)
19 LOC now, thanks to [https://github.com/mlvzk/pastebin-cr/pull/1](https://github.com/mlvzk/pastebin-cr/pull/1)
Very nice! Repl.it has always been a great tool.
I'd say go for it. I'd also be biased and suggest trying my framework, but since this is probably a real for money type thing, going with a more proven/mature framework would probably the better idea. Depending on what the project is; Kemal, Amber, Lucky are all popular solutions. I'd say most of the core features of things are in place, ORM libraries for example. The only thing that is lacking would be more specialized things, like GraphQL or more uncommon technologies. Could always make your own in that case ;)
Actually I'd be going without a framework, and build my own abstraction over the utilities provided by the stdlib. I've seen and played with the variety of frameworks and really liked them, specially Lucky. However, their documentation is insufficient for my needs and I'd feel insecurity. Thanks for the reply!
Yea man, sounds like a plan. Can really cater it to your needs then. 
Will anyone else have to read and /or maintain your code ever? Then new language AND home grown web app code instead of framework is probably not a great idea. If you are the guaranteed only dev ever, then go nuts. 
I'm currently going through something similar (although building a start-up level application for a single client). By far the biggest issue I'm facing is the lack of safety in numbers. I'll say right off the bat that for some people this isn't an issue and they can feel comfortable diving 'all in' on new frameworks but right now it feels like a high amount of risk throwing yourself into a framework that realistically only one or two people are using. All of the frameworks have their merits, and dedicated authors, but I ended up going with something similar to you; the most lightweight stack I could manage to understand completely and relying on the stdlib where possible. A big secondary factor was the interaction that I had with library authors when asking preliminary questions about their libraries and mainly just getting a feeling for how much they care about their work. I ended up with; * [Clear](https://github.com/anykeyh/clear) as my ORM. Yacine *really* cares about making this a stable and supported library and it really shows in his commitment to github issues, documentation and project roadmap. For it's size, receiving deprecation warnings in the console was a huge (and pleasant) suprise. As an aside, my goal is to replace much my usage of the query builder and model with prepared statements but for where I can't do so, I'll be more than happy to rely on the models given by Clear. * [spider-gazelle](https://github.com/spider-gazelle/spider-gazelle) for my web layer. Slightly esoteric choice as it's not usually flagged up in comments as one of the more mainstream choices for web-app development but I found it's abstractions on top of the stdlib were the ones I'd write myself anyway. I've always been more of a hanami/rails person than a sinatra one so it had a nice balance of an incredibily small footprint (in terms of understanding) as well as familiar abstractions. The rest of it is mostly self written but a couple of libraries here and there to assist with plumbing; .env loaders (poncho), config initializers (habitat). On the whole I'd recommend it. I'm doing this for a real project but as we're still in the process of launching this with the client I ultimately can't feedback on stability but I will say that the joy of development has been high, very high in fact. Crystal does a good job of keeping you sane so if you're comfortable diving in and taking a risk on some of the things you take for granted elsewhere are still progressing then I'd say go for it! Welcome aboard.
Hey, minisculepenis, just a quick heads-up: **suprise** is actually spelled **surprise**. You can remember it by **begins with sur-**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey /u/CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". And your fucking delete function doesn't work. You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
Hey BooCMB, just a quick heads up: I learnt quite a lot from the bot. Though it's mnemonics are useless, and 'one lot' is it's most useful one, it's just here to help. This is like screaming at someone for trying to rescue kittens, because they annoyed you while doing that. (But really CMB get some quiality mnemonics) I do agree with your idea of holding reddit for hostage by spambots though, while it might be a bit ineffective. Have a nice day!
I would advise against Crystal for the main app unless you can afford the R&amp;D for non existing libs and integrations. If you have a team of skilled devs that can do it and contribute to the community then you are fine with whatever you choose. Look at Reel Valley in Nim world and its authors. They made a cross platform game as a team of 3 highly talented devs but they had to reinvent shitloads of non existing libs even though Nim’s C integration is relatively easy. But the main guy contributes to core Nim and he has the skills to fight the immature lang and the ecosystem. 
delete
You're all just spam in my eyes at the point. I made a typo. Get over yourselves.
What are all this retarded bots fighting each other now lol
delete
A game usually needs very different libraries than a web application (and probably much more). It always depends on the specific design goals of course.
Well they have a fb web game as well and had to develop at least the mongodb driver. 
I’m using Lucky for a big project in production. Whenever you have questions outside the documentation you can chat on gitter and get an answer.
Just do it. If something happens to crystal, port it to JRuby or truffle. Hiring ruby devs eager for new challenges is easier than hiring for go. 
Hey there, Nico from manas.tech (home of Crystal) here, happy to jump on a quick call and help you understand challenges, risks and opportunities. Feel free to reach out to nicod at manas dot tech.
For future people coming to check out the Lucky project, can you give some tips as to what was lacking in the documentation? I've been trying to update it more, but being in it all the time, I may miss some stuff that newcomers are looking for. 
This is a very generic comment (sorry!) but one of the things I struggled with is that there seemed to be a bit of a void between the guides and the source-code, kind of like a human-friendly API reference. I tend to find the default generated Crystal docs to be a bit difficult as you kind of need to know the name of the class you're looking for before you can find what you need, and the classes don't always map well to higher-level concepts. Purely referencing this as they're similar crystal projects, but [Onyx](https://docs.onyxframework.org/#what-is-onyx-framework) and [spider-gazelle](https://spider-gazelle.net/#/controllers/overview) are close to getting the balance right for me. This isn't to knock down the Lucky guides, the content is good - great in fact - but I find them a little wordy. What I need is closer to the above whereas the guides can feel closer to individual blog articles, if that makes sense!
Ah interesting. I can agree there. I prefer short and to the point myself, so I can see how “too wordy” makes things a bit muddy. Thanks for the feedback. 
what can serverless applications do?
Anything serverfull ones can :P jk You can build anything from simple functions to glue together other services to full APIs or Web Applications.
that will be complex.
It's simpler in some ways, more complex in others. IME they're great for async actions, but less ideal for things that need a fast request / response cycle. &amp;#x200B; Still, there's a lot of promise in the tech. Try it out.
I wonder if you could expand a bit on Spider Gazelle. I'm currently looking at porting a Rails app that's CPU bound and would like to keep the structure as similar as possible for everyone's sanity. SG doesn't market itself well like amber. When I bring my proposal to management and say I want to Crystal a Spider Gazelle, they'll think I'm high. Is it mature enough that I should give it a chance? 
Very cool. I'll be keeping an eye on this.
Costs money? pass
What an interesting idea! I enjoyed how visual it is watching the pistons navigate the program. 
What? Did you mean, "how ready is Crystal for production-use?".
:)
Simple question, simple answer; yes it's ready.
Thank you! Im glad someone got something out of it!
No clustering without an enterprise licence is very limiting as it means that small businesses and start ups won't be able to have high availability background work processing. &amp;#x200B; Given that why would we use this over ActiveMQ or RabbitMQ? Or even a managed solution such SQS?
Puedes preguntar en español también sin problemas. 
Thank you for your questions! &amp;#x200B; \&gt; small businesses and start ups won't be able to have high availability background work processing &amp;#x200B; Well, yes. Once high availability becomes critical, it's neither small business nor startup anymore 🙂 &amp;#x200B; \&gt; Where is the source code &amp;#x200B; As I've mentioned in the topic, Worcr is currently in pre-alpha. You can "pre-purchase" its license right now with 80% discount. ETA of alpha is May.
&gt;Well, yes. Once high availability becomes critical, it's neither small business nor startup anymore 🙂 I disagree. Every small business and start up I've worked with has availability guarantees that make HA a requirement. &amp;#x200B; A HA postgresql cluster on GCP costs $18 a month. A HA dynamodb cluster is in the AWS free tier. A HA Redis cluster is $15 a month on Heroku. &amp;#x200B; HA is not an enterprise feature, and without it Worcr is not suitable for use outside of hobby projects.
Neither Sidekiq nor Faktory currently support clustering. You can use third-party Redis instance for HA, as mentioned [here](https://github.com/mperham/sidekiq/issues/3655). The same is achievable with Worcr OSS and Pro — as I've already answered in the forum topic, Worcr can operate with external SQLite databases. I don't know about Faktory Ent, but Worcr Ent definitely will support clustering.
Sidekiq does support HA. If you are using sentinel or redis failover you just have to pass a Redis connection pool as the connection. [https://github.com/mperham/sidekiq/wiki/Using-Redis#complete-control](https://github.com/mperham/sidekiq/wiki/Using-Redis#complete-control) If you're using one of Redis compatible HA databases (such as AWS' or GCP's offerings) you just give it a normal connection. &amp;#x200B; There are no HA solutions for sqlite, so the external database option doesn't help either.
&gt;There are no HA solutions for sqlite There is [https://github.com/rqlite/rqlite](https://github.com/rqlite/rqlite). However, I understand your concern. I have draft ideas of Worcr supporting PostgreSQL and MySQL as well.
That's great, thank you :)
You've convinced me that having PostgreSQL on start is better. Thanks!
Next stop, the world! 
Not sure how I feel about this graph. I mean first, CSS isn’t even a language. 2nd, while I loved CoffeeScript, surely its not being actively used?
CoffeeScript still comes standard with Rails and I know at least one company uses it (it's where I work) although we are hoping to move away from it one day
CoffeeScript is my saviour whenever I need to use JS. 
Yeah it still gets used around the place. Thankfully its on its way out, it always just seemed to me pointless obsfucation. Typescript has a purpose, making JS's type system slightly less trashier, whilst it still being javascript. But I never quite understood why Coffeescript needed to go nuts with the obscure syntax. I have other flamewar inducing hot takes, but this one is this one!
Yeah, I don't get it. I tried writing some coffeescript one time, because TBH I obsess over the aesthetics of my code way more than I should. Anyway, I got most of the way done (just a few event listeners, nothing big) when i realized how much energy I was wasting like coming up with the JavaScript, translating it into what I *thought* would be Coffeescript, then googling to find out how to *actually* get it to behave like I expected. And immediately rewrote it all in JavaScript haha.
Originally CoffeeScript had a lot of features that were not in JS, but many of those features have since been added to the spec. Some directly inspired by CoffeeScript, others just because the language is progressing. In a world where people were still using Prototype.js, the idea of a Ruby/Python-like language that integrated all these JS programmer libraries into the syntax and helped with the “function function function” nesting hell that node ushered in was pretty awesome for some of us. So I dunno when you last looked at it, but originally CS’s obfuscation had a point: adding features that JS lacked. This was like 10 years ago though. Today even the creator has moved on and it’s becoming more of a fun niche language now that JS has evolved and TS has arrived. 
It might be because of legacy code.
Exactly. Which makes me wonder the activity level of the code based in the graph. 
Fantastic news ! I hope someone will have the time to make a recap' post here on reddit for those who missed it
Added a new section https://dev.to/blacksmoke16/utilizing-macros-annotations-in-a-web-framework-3abk#orm
You'll be able to watch the recording later ;)
APRIL 1
1. build with release flag. 2. get dependency list 3. copy dependency static lib to a folder 4. build with that folder example `shards build --release` ``` otool -L bin/demo bin/demo: /usr/lib/libpcre.0.dylib (compatibility version 1.0.0, current version 1.1.0) /usr/local/opt/bdw-gc/lib/libgc.1.dylib (compatibility version 6.0.0, current version 6.2.0) /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.250.1) /usr/local/opt/libevent/lib/libevent-2.1.6.dylib (compatibility version 7.0.0, current version 7.2.0) /usr/lib/libiconv.2.dylib (compatibility version 7.0.0, current version 7.0.0) ``` ``` brew reinstall -s libgc cp /usr/local/opt/bdw-gc/lib/libgc.a vendor cp /usr/local/opt/libevent/lib/libevent.a vendor shards build --release --link-flags="-L`pwd`/vendor" ``` ``` otool -L bin/demo bin/demo: /usr/lib/libpcre.0.dylib (compatibility version 1.0.0, current version 1.1.0) /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.250.1) /usr/lib/libiconv.2.dylib (compatibility version 7.0.0, current version 7.0.0) ``` now the binary only depend on system libs that installed on all mac.
and if you are build cli app for mac, use brew to install dependency is not bad, a cli user has installed it.
Thanks so much! Going to try this tomorrow.
The upcoming 0.28.0 release adds \`CRYSTAL\_LIB\_PATH\` for defining locations where the compiler should look for libraries. See [https://github.com/crystal-lang/crystal/pull/7562](https://github.com/crystal-lang/crystal/pull/7562)
\&gt; I understand that static linking does not work with crystal. &amp;#x200B; You're referring to fully static linking, and that doesn't work with MacOS.
You just made my week. I wrote an app in crystal, and then when I tested it on a friends computer, I thought that my entire work was useless. Thank you!!!!
OMG, it's sooo BIG!
Do we know how the windows port is coming along?
[removed]
There has not been much progress lately, but we're expecting some movement in the future. This topic was addressed in the live Q&amp;A starting form 33:43 [https://youtu.be/JkKqkzCoR-8?t=2018](https://youtu.be/JkKqkzCoR-8?t=2018)
Cheers mate. What's the major hurdles left? I'm wanting to port a Midi / UDP bridge from python but I'm a bit anxious starting it in crystal if I can get it up on windows. The alternative is Go, but man does that language make me sad
This is great! I will add support for it on faastRuby as soon as you guys release it.
The next bigger step is porting the compiler so it can be self-hosted on Windows. That's maybe not functionally relevant, but improves developer experience on Windows a lot. Cross-compiling from WSL already works fine, though it's a rougher process. We hope to reach that over the summer. Apart from that, we need to implement fiber context switch for Win32 calling conventions, which also blocks porting most IO-related parts. An overview of the current progress is available at [https://github.com/crystal-lang/crystal/issues/5430](https://github.com/crystal-lang/crystal/issues/5430)
Nice use of neo4j. Actually, I wanted to say thank you for developing a Crystal Neo4j driver. Personally, I think the Cypher query language is the most intuitive db query language. As for the LiveView implementation, I think it looks good. A bit laggy because I'm in Sydney and Heroku free tier is in US East 1 or Europe. I do wonder how well this would scale. My understanding is that LiveView takes advantage of the battle tested genserver to hold state.
I'm curious how much latency you are seeing from US-Easy to Australia. Is it &lt; 200ms?
Very cool stuff! Thanks for sharing
Yes of course. It's a compiled language. That's the entire point of crystal. (Among other advantages of course)
I'd say it's close to 200ms. On a phone so it's my perception while looking at the LiveView clock. Lag is acceptable this morning but I'm on a different network to last night.
One of the ways Crystal could be considered slower than Ruby is if you account for Crystal's compilation time.
PERFORMANCE!
even then. Unless you plan to run your programs only once and then delete them, this is still a pretty pointless argument.
If you're doing coding quizzes such as Project Euler or Advent of Code, it's non trivial difference when jumping between Ruby and Crystal.
&gt;Nice use of neo4j. Since I wanted to show off deferred data loading, I figured I might as well show something that loads an unreasonable amount of data from a DB to do it. :-) Simulating loading data with a `sleep` could work, but there's no substitute for loading real data and I have Neo4j DBs on hand for testing. I also wanted to put up an example of loading data in multiple stages. For example, streaming data from the DB and rendering to the client in chunks while the query is still loading — I've done this over websockets to improve UX before and it's *really* effective sometimes. But I figured if I spent any more time tinkering with the demo I'd never actually publish it. :-) &gt;A bit laggy because I'm in Sydney and Heroku free tier is in US East 1 or Europe. Yeah, anything that renders entirely server-side and has fully centralized web-facing infrastructure will have this issue. The websocket is better in most cases than dealing with a TCP handshake, TLS negotiation, and TCP slow start on every interaction, though. Not to mention, if the app doesn't do `Cache-Control` appropriately for static assets, it's even worse. &gt;I do wonder how well this would scale. My understanding is that LiveView takes advantage of the battle tested genserver to hold state. I've got some ideas for improvements. This implementation is definitely not perfect — for example, it doesn't handle a websocket being closed due to a spotty connection yet. I would like to have something similar to GenServer, but the parallelism story with Crystal is quite different right now. You can throw one Elixir app on a single machine with dozens of cores and max out the CPU while sharing memory among all of them. It's unfortunately not something we can do yet with Crystal, so we'd need something that allows multiple Crystal processes to share the same pool of live views to handle the case of scaling out across processes or even servers. I'm not sure what that is yet because this was built for just a few features of a web app that hasn't needed to scale out yet. :-)
Sounds about right. When I lived in Perth, best-case latency was about 250ms to east-coast US servers (traceroutes showed it going through Sydney). A bit more on a typical day.
Compiled doesn't necessarily mean faster, but yes, Crystal is designed to be fast to run :)
I would say that in dev and test this is the way programs are usually run.
Yes, but that is not how the term "performance" is usually understood.
Totally. I was saying that it's common, not that it's what performance means. Crystals compilation times are one of the drawbacks
reinvent \`[APS.NET](https://APS.NET) WEB FORM\`
Is that 0.74s through crystal's REPL or a command line directive?
Might also depend on what you are writing. If you're writing a web app that is largely IO bound (DB/API), the difference might not be as much? But if you are trying to handle a large number of visitors on such a platform, Crystal might even payoff more in lower memory footprint.
Command line.
very interesting. I'll have to dig in more to see what is happening inside.
The answer is depends. if you are running it through the shebang ruby might be faster in some cases. If you are running a complicated app crystal will likely be faster. but Ruby is a moving target. It's getting faster all the time and projects like graal are promising to make it faster than crystal.
Every benchmark I've run shows Crystal running *at least* 5x the speed of Ruby, frequently reaching 10x. In porting a web service from Ruby to Crystal, I've reached 35x the request throughput in Crystal of the Ruby service it replaced. It's not just the code itself running faster, but it encourages other techniques that scale better. For example, you can use stack-based structures when feasible to avoid GC, shaving milliseconds of CPU time from every request. Crystal also handles web requests in disposable fibers, allowing you to handle as many concurrent requests as necessary while a Ruby web service uses a capped thread pool (Puma defaults to 16 threads), forcing you to limit the number of concurrent requests.
\`undefined\`, pun intended
Very nice!
I have built a single (extremely simple) webservice (&lt;https://shashort.15318.de&gt;, source is linked in the footer but probably not very useful as I have no idea what I'm doing 99% of the time) with [Kemal](https://kemalcr.com) (one of the available frameworks) and I found it pretty usable and comfortable. For templating, there's already ECR from the stdlib, but I'm sure different template languages have Crystal bindings. Full semi-official database support is there for mysql, postgresql and sqlite, I think. Take a look at [Awesome Crystal](https://github.com/veelenga/awesome-crystal) and see if projects there strike your fancy.
This is a pretty common question, and there’s no strict answer. It will be released when it gets to that point. But the question you should ask yourself is what is it about 1.0 that you need? 0.28.0 should be released soon, start with that.
Some people just want their code to continue working in future versions.
Even in that case it isn't _that_ bad. Build program with current version. When a new version comes out, look at breaking changes, if anything affects your code, update it, otherwise update and will be fine.
Yup. Which is totally a valid reason, and understandable. My only thing is that I’ve worked with many languages post 1.0 that had updates with breaking changes. PHP did it, Ruby has done it. Crystal hitting 1.0 can’t guarantee that 1.1 won’t deprecate something. The more people that use it now, the closer we can get to a “1.0”.
You can always just keep using the compiler version originally used during development. Yes, you will miss out on new language features, but if you don't use Crystal because "pre 1.0" you miss out on the whole language.
There's Jinja: https://github.com/straight-shoota/crinja
My company has basically gone all in on crystal. We now have several Lucky apps running in production, and our user base is several million users. We don’t really do anything too complicated, and we do run in to some issues here and there, but it’s been pretty solid for us.
For longest time people used Node.js in 0.X.Y versions. I think there are objectives that a language wants to achieve and then there are goals. I have been using Crystal in a geolocation server for years now; it’s pretty high traffic and low latency scenario. With more libraries coming in I think it’s matter of time until people start using the heavily and this language really takes off.
for how long?
no changes in API
I’ve been working with crystal for 3 years now. We’ve have apps in production for a year.
What's the company?
And this is somehow fine for hobbists. If you want to use in a production environment API stability it's almost a necessity, because this process that you outline come with a labour cost, it's not free. We (as in my team and I) don't care much about this, but we've been bitten in the ass by changes to elixir's APIs for example, and this as cost us time to analyze the problem, weight pros and cons, and then update the code accordingly if pros outweight the cons. So, even if I adhere to your school of thought, I understand that is a costly approach and suited at most for small teams. In this scenario adding a feature is a nightmare if the code is not sufficently tested.
Why are you downvoted. This is true. As an early adopter of Swift, this is exactly what happened. I was migrating the code base with every major Swift version up until Swift 4
Let me know what you think, and ways I can improve it!
No clue, but reading back maybe I came off as condescending? Definitely not what I was going for. I just wanted to point out that waiting for 1.0 is arbitrary. Waiting for a feature like “solid windows support” makes more sense because that’s something that could show up prior to 1.0.
I can’t really say the name of it, but it’s in the adult entertainment space if that helps any lol
This is really cool! I hope you continue with coding after high school; as an engineer with over 15 years experience I am impressed!
Thank you! I do plan to continue coding after high school, and I am currently taking CS classes at my local community college.
Crystal doesn't really have a REPL; you have to compile all the code each time.
Oh! Crystal used to have a REPL but it seems it was removed last year because it was too difficult to maintain. hope they bring it back. And yes, Cystal's estwhile REPL would re-compile and rerun code with every command — it was just so fast that it worked without the developer noticing it.
Ah, I've been watching Crystal for a while but only started actually using it in the last couple of weeks.
obviously it will. on average 35x performance.
3 years? Wow. What was the first Crystal version used? What web framework? Or inhouse?
good job.
brew pr fail.
I make no claim that this is a good idea (make your own mind up), but to install it I've just ran: `brew upgrade https://raw.githubusercontent.com/Homebrew/homebrew-core/ca8f21cd49a9 36bf154235b365fa23929f9f688d/Formula/crystal.rb`
Really good release, thanks for the continued effort. I get more and more confident I've chosen the right language for my projects when I see these releases. Standard collection of comments over at HN but I like it, and I don't think the complexity is too bad (I'd comment over there but I don't have an account). In line with a recent [Ruby article on language complexity](https://metaredux.com/posts/2019/04/02/ruby-s-creed.html) I don't think the same criticsm applies, and the only one I have my doubts about is the limitless range "operator". I can see the double or triple dots being a little too ambiguous at-a-glance although I expect this is something I can get used to, plus I don't think it brings so much complexity it'll need to be ripped out to free the syntax for something else further down the line.
I started with Kemal and crystal 0.11 I think it was. Couldn’t really do a whole lot back then so it was more just play apps that all ended up being thrown away.
Meanwhile ruby 3 is going to have types as part of stdlib... What does this mean for the future of crystal?
&gt;ruby 3 is going to have types as part of stdlib... What does this mean for the future of crystal? Maybe nothing. Crystal still has other improvements, like better performance, single-binary deployments, etc. It's really cool that Ruby is adding types, but IMO both languages are completely separated now. Only the syntax is somewhat similar.
&gt;Maybe nothing. Crystal still has other improvements, like better performance, single-binary deployments, etc. Crystal does not have a single binary deployment. The binary has dependencies on C libs and LLVM libs AFIK. But ruby having types does subtract one reason people try Crystal. The ruby type system is not likely to be as strong as the Crystal one but still one less reason to try Crystal.
Personally, I've found Crystal to be a lot closer to C++ and Go than to Ruby, as far as translating libraries. Gosu in particular is bindings to C++ in Ruby, so that would be a relatively simple translation. In *many* cases Ruby cannot be translated to a compileable Crystal due to the fact that Ruby is a dynamically typed language and Crystal is statically typed.
Of course. But in terms of re-using the object hierarchy and structure of code, Crystal is obviously Ruby + type information.
https://github.com/Homebrew/homebrew-core/pull/39026
ci not pass.
- You have to annotate the types of instance and class variables [unless their types are obvious enough for the compiler to infer them](https://crystal-lang.org/reference/syntax_and_semantics/type_inference.html) and the types of arrays/hashes/sets/procs etc. - You have to take into account any gems that the Ruby app uses which would also need to be translated (unless you're lucky and a Crystal version exists and has a close enough API). - Any usage of metaprogramming needs to be replaced with macros, and macros can't do 100% of the things Ruby's metaprogramming can do (and vice versa). - Strings in Crystal are not mutable so code must change to accommodate that if necessary. - Translate methods with different names (`include?` -&gt; `includes?`, `key?` -&gt; `has_key?`) and keep an eye for the more subtle differences (like `each` returning `nil` in Crystal instead of `self`). - Unlike Ruby, Crystal doesn't allow you to take leaps of faith like calling methods on things that could conceivably be `nil` unless you are explicit about it (`not_nil!`, the `getter!` macro, `as` casts...). - Integer overflow is a thing in Crystal. - Other syntax differences like: - `rescue =&gt; ex` -&gt; `rescue ex` - `my_var.tap(&amp;:my_method)` -&gt; `my_var.tap(&amp;.my_method)` - `my_var &amp;.my_method1 &amp;.my_method2` -&gt; `my_var.try &amp;.my_method1.my_metod2` - Crystal is better equipped to deal with low level things that in Ruby would lead you to using stuff like Array#pack, but it's not trivial to translate that kind of code (which Gosu probably uses). Porting a big Ruby app to Crystal is not something that can be done quickly and on a whim, but it certainly is easier that porting from any other language.
`brew install` [`https://raw.githubusercontent.com/Homebrew/homebrew-core/c84afb93cbd06d7fe774000c19feca943ea77ddf/Formula/crystal.rb`](https://raw.githubusercontent.com/Homebrew/homebrew-core/c84afb93cbd06d7fe774000c19feca943ea77ddf/Formula/crystal.rb)
You might check out crenv
I've had luck statically compiling on an alpine Docker image, and then being able to use that binary from Docker scratch - so I think static compilation is indeed possible.
Jeremy and the team are using Lucky now and contributing quite a bit back to it. Thanks guys!
Full static linking is only doable on Alpine ATM. Some links: * https://github.com/crystal-lang/crystal/wiki/Static-Linking * https://www.reddit.com/r/crystal_programming/comments/bbe0h1/packaging_a_crystal_application_for_mac/ * https://www.reddit.com/r/crystal_programming/comments/ay8d4o/why_cant_crystal_run_on_other_computers_without/
Updated to work with newest Athena version.
I know a lot of people coming to crystal haven’t worked in ruby, but one key design is “slick as ruby”. Making this change would break that nice ruby bridge. Would this also mean you’d have to call methods with @ on them? @some_string.@downcase.@split.@class.@@name In that case, how would I know if point.@x was calling the instance variable x, or a method/attribute x?
&gt;I know a lot of people coming to crystal haven’t worked in ruby, but one key design is “slick as ruby”. Making this change would break that nice ruby bridge. The devs have already said this is no longer a goal for Crystal so it wouldn't matter. &gt;Would this also mean you’d have to call methods with @ on them? @some_string.@downcase.@split.@class.@@name No just like you don't have to do that with calling instance variables in ruby now. You just say object.variable. &gt;In that case, how would I know if point.@x was calling the instance variable x, or a method/attribute x? You wouldn't and you shouldn't really. In ruby everything is a message right?
I do like the idea. However, the @ is a symbol already associated to variables. Wouldn't it be clearer to have another one devoted to methods? Like $ or * ?
I like the use of the @ because it keeps things consistent. The same symbol would apply to both functions and variables.
Keeping Crystal as similar to Ruby as possible for the time being is a good strategic decision IMO. Crystal is still young in terms of adoption and that bridge from Ruby has been very useful to bring people over and try the language. When I am doing a faastRuby demo, I usually show how you can speed up an endpoint by orders of magnitude just by renaming handler.rb to handler.cr, making no changes to my example code at all. When people see that, it immediately sparks a curiosity to try Crystal. This example creates the feeling of a very smooth learning curve! Major changes in the language like you are proposing could be nice for non-Ruby newcomers, but Crystal should try to milk that cow (ruby similarity) a little bit longer IMHO.
&gt;Keeping Crystal as similar to Ruby as possible for the time being is a good strategic decision IMO. I agree but the developers don't agree. They have said many times that's no longer a priority or a goal. When it comes to method visibility crystal is already not compatible with ruby. In crystal you have to annotate every method as being private with ruby you can just type "private" and every method after is private. Crystal doesn't work that way. Also this wouldn't break any ruby code. It's additional syntax, you can keep the old syntax, just expand def @blah to def public blah.
I think that you're mixin up some concepts here. You talk about consistency, but it's not. `@` could be considered as a `self` shortcut (without really being the case). So, for variables: @foo --&gt; self.foo @@foo --&gt; self.class.self.foo Then, if you want to keep things consistent, it would make more sense to have: def self.foo --&gt; def @foo
&gt;But this would not make things consistent when calling the method, since you could not call the class method by using @ like you can with instance and class variables. But that's only internally. If I have an instance variable or a class variable I don't call it by using the @@ for example Someclass.some_attr The thing that this would break most severely is that in crystal all methods are public by default. To me that seems wrong.
You really can't call either way. Instance variables are not publicly accesible except with methods, what you're referring to are methods metaprogrammed onto your class with attr class methods.
You are mixing up concepts: public/protected/private scope has nothing to do with instance/class context, these are not the same thing. Also, getter/setter and variables aren't the same thing either. What I was refering to is the consistency of `@` vs `self`, what you propose is inconsistent with what it would stand for. In the version I proposed earlier, it would imply: self.class.foo --&gt; self.class.self.foo --&gt; @@foo(arg) which would conflict with class variables if the syntax has to be consistent with how it's used for variables. Otherwise, it could just be a shortcut for class method definitions.
Hey, patleb, just a quick heads-up: **refering** is actually spelled **referring**. You can remember it by **two rs**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey /u/CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". And your fucking delete function doesn't work. You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
Hey BooCMB, just a quick heads up: I learnt quite a lot from the bot. Though it's mnemonics are useless, and 'one lot' is it's most useful one, it's just here to help. This is like screaming at someone for trying to rescue kittens, because they annoyed you while doing that. (But really CMB get some quiality mnemonics) I do agree with your idea of holding reddit for hostage by spambots though, while it might be a bit ineffective. Have a nice day!
Hey /u/BooBCMB, just a quick heads up: No one likes it when you are spamming multiple layers deep. So here I am, doing the hypocritical thing, and replying to your comments as well. I also agree with the idea of holding reddit hostage though, and I am quite drunk right now. Have a drunk day!
&gt;Also this wouldn't break any ruby code. It's additional syntax, you can keep the old syntax, just expand def @blah to def public blah. Good point. I think I have a better understanding now of where you are coming from.
Just because compatibility with Ruby isn't a goal doesn't mean they think that the syntax should not also be as "slick" as Ruby, as they say.
Wow, this was a cool read! Thanks for sharing! May I ask how long it took you? Just curious :)
I started about a month ago. There was a lot of trial and error and complications but, overall it was a really fun learning experience. I'm glad you liked the article!
&gt;There was a lot of trial and error and complications I can only imagine. Looking forward to part 2 :)
You may try [https://onyxframework.org/](https://onyxframework.org/)
Which: [http://kemalcr.com/](http://kemalcr.com/) Why: Over 2,500 stars on github, widely used and tested by many.
https://github.com/Blacksmoke16/athena It has some unique features compared to the other frameworks. The main two are that it uses annotations as the way to [define routes](https://github.com/Blacksmoke16/athena/blob/master/docs/routing.md#defining-routes) (similar to Spring or Symfony) and the route actions are simply methods within a class, so code blocks work, testing is simple as calling the method with the params you want, and is pretty clean code. I created it mainly for the JSON API type of project, and has some pretty slick features related to that such as [Param Conversion](https://github.com/Blacksmoke16/athena/blob/master/docs/routing.md#paramconverter), and a flexible system for [CORS](https://github.com/Blacksmoke16/athena/blob/master/docs/routing.md#cors). I've also wrote a [blog post](https://dev.to/blacksmoke16/creating-a-json-api-with-athena--granite-510i) using it to create a backend for a blog website, which would be a good overview of how everything works, with examples and such. I'm also working on an annotation based ORM which would make the models more crystal like as they would just be properties with annotations on them.
Amber is just a mess honestly, don't use it for anything production. It's docs are outdated, there's bugs in literally the most basic things you'd expect and it's a waste of your time.
It certainly hasn't been my experience. What kind of bugs in the most basic things are you talking about?
there was a bug where running the test suite would wipe out your entire development database. no edge case, just a simple "run the test suite" command would do this lmao
That bug was over a year ago, `AMBER_ENV` wasn't set correctly.
Who cares? It was a bug that I experienced and probably more the deeper you go into things. This was a surface level bug that should have been caught quickly
&gt; Who cares? Please stay respectful, I'm telling you what the bug was (which isn't really a bug, but a missing feature). &gt; This was a surface level bug that should have been caught quickly Not necessarily, your development environment could be different from most other people or Amber might be used by more experienced people. I certainly didn't mind to set myself the environment variable.
to be honest, this feels like the answer which makes the most sense.
kemal
&gt;No just like you don't have to do that with calling instance variables in ruby now. You just say object.variable. No, you can't access an ivar like this, neither in Ruby nor Crystal. This only works if it is exposed using \`attr\_reader/attr\_accessor\` or \`property/getter\`, respectively.
First of all, you're talking about methods, not functions. I don't think this proposal would be an improvement, because it only creates problems and I can't see that it fixes any real problems. * Defining a method named \`@som\_func\` but calling it as \`some\_func\` is inconsistent. Same goes for \`@@\`. * Identifiers prefixed by \`@\` can refer to both a method and an ivar, depending on context. This is really confusing. Look at an accessor for example (similar to the \`getter\` macro): \`def @my\_ivar; @my\_ivar; end\` and \`@my\_ivar\`. * It's not self-explanatory \`def foo\` would be private and \`def @foo\` a public method. Using \`private def foo\` and \`def foo\` is explicit and easy to follow.
Give faastRuby.io a try. The setup is pretty minimal: gem install faastruby. Then check the faastRuby Local docs at https://faastruby.io/docs/faastruby-local/ You can mix Ruby and Crystal in the same API! Full disclosure: I am the author.
Kemal is great for doing API stuff. I have a shard called Kave for versioning the API, and I’ve used Crecto for handling models. You’ll want to make sure you add something like helmet for doing secure header stuff. If you need something a bit more structured, then Lucky in API mode is great. I have several in production that handle really well. Lots of features and structure built in.
lucky
Thanks for metionning Kave and Crecto, I'll take a look at these! By the way, I'm curious, why dont you version the API with route scoping, like I would do with rails?
I actually don’t like the api info being in the route. When changing api, it can make updating a client so much more difficult. When it’s in the header, you usually just change in one spot. This cake about when I was doing an API for a mobile app, and I had to change a single endpoint, but the other 30 endpoints were essentially the same and unchanged. I think I have an option with Kave to use the route though... I remember working on that, but not sure if I finished it or not. Been a while since I used it lol
The problem with putting it in a header is that not all clients will be able to specify a header, for example webhooks from other platforms. In this case you'll need to have some API routes that are versioned by URL in addition.
Amazing article with so good explain. I love it
Yeah, that makes sense. I haven’t run in to that before, but I think that’s a good case for having the option either way.
Can you write a spec that shows what value you would expect? That might make it easier to see what’s going on for someone not familiar with these times.
&gt; I have to run the main bulk of my code in a fiber Everything runs in a fiber anyway, just that it happens to be the main one. So nothing to worry about with the straightforward approach. But it *is* true that the program's exit is tied to the main fiber's exit. Knowing that, perhaps in your case the problem is that you started Kemal in the background and let the main fiber (and so the entire program) exit?
Huh! That made sense! Thank you :D This works: ``` require "kemal" spawn do get "/" do "Hello, world!" end Kemal.run end count = 0 while true puts count += 1 sleep 1.second end ``` Problem solved. 1+
Thank you for asking. But I fix now everything work perfect :)
Replace while true sleep 1.second end with sleep
What is it going to do? Sleep forever? :o
Yes, the same thing that the original loop does but without having to switch back to that fiber every second just to sleep another second.
Thanks! :)
I'm guessing you meant `POSTS` instead of `FILES` for the first line? &amp;#x200B; I think what you're running into is that `Dir.entries` is evaluated at runtime, and is not a compile-time constant. That makes it an expression, which can't be iterated over in a macro, which is what the errors says. &amp;#x200B; What you should be able to do instead is use the [`#system`](https://crystal-lang.org/api/0.28.0/Crystal/Macros.html#system%28command%29%3AMacroId-instance-method) macro function. You can run something like `ls` to get a file listing and then iterate over all of the entries.
I think you can do your parsing stuff in another file, then use the `run` macro to run the file and get your array of filenames. Macros can be a little tricky though, so I’m not sure if that will work or not, but that’s where I’d start.
Crystal doesn't allow `@instance_variable` or `@@class_variables` at the top-level (outside of a class). You can, however, use a plain variable like so: `foo = "foo"` 1. I'm not familiar with Readline, but looking at the docs, it seems you're right. There's no way to access the history like that. You might have to wrap Readline with your own functionality or find a shard that can do that. 2. Yes and no. What you're looking for is in the documentation under [Top Level Namespace](https://crystal-lang.org/api/0.28.0/toplevel.html). It's defined under [kernel.cr](https://github.com/crystal-lang/crystal/blob/master/src/kernel.cr) in the source code, but there's no Kernel class. 3. Doesn't look like there's any Crystal equivalent (yet) for Shellwords. There's [an issue](https://github.com/crystal-lang/crystal/issues/2657) that mentions possibly including it at some point. Couldn't find any shards for it either - would be a good shard imo. 4. Correct. AFAIK, that's a reflective method and Crystal doesn't have reflection, though it mimics it pretty well with macros. You'll have to use a setter method if you want to modify an instance variable from outside the class. 5. There's a `responds_to?` method (with an **s**), and that works for me, with and without `self`.
Sorry, I meant `responds_to?`. I have been unable to use it within a class for its own methods. &amp;#x200B; Your point on shards brings me to another question. Is there a **repository of shards** I can browse through, or search. I read that shards are directly on github, but how I can look for a particular one (apart from google which gives me a lot of links relating to crystal-reports, or discussions about what I am looking for).
**Dir.glob** not working with match\_hidden (0.28.0) I am trying this on local, as well as play.crystal-lang. &amp;#x200B; `Dir.glob("*")` This works fine. &amp;#x200B; `Dir.glob("*", true)` On play.crystal-lang it does nothing at all after taking some time. On my machine, it gives me an error saying: `in /usr/local/Cellar/crystal/0.28.0/src/dir/glob.cr:23: tuple type too nested: Tuple(Tuple(Tuple(T)` &amp;#x200B; `def self.glob(*patterns, match_hidden = false) : Array(String)` &amp;#x200B; On looking at the source code, the method appears to call itself, although I can't be sure since I am too new to Crystal.
Try with `Dir.glob("*", match_hidden: true)` If you look at the method definition, the first arg is `*patterns` which will match all positional arguments. To be able to specify the arg `match_hidden` you need to call it using a named arg. See https://crystal-lang.org/reference/syntax_and_semantics/default_values_named_arguments_splats_tuples_and_overloading.html for more info on that!
That's strange, it certainly should work. Here's an example: [https://play.crystal-lang.org/#/r/6ty9](https://play.crystal-lang.org/#/r/6ty9) Maybe something is different with your class structure? &amp;#x200B; Yes, [crystalshards.xyz](https://crystalshards.xyz) automatically indexes all shards on GitHub. It lets you search for shards as well. Additionally ,there is [Awesome Crystal](https://github.com/veelenga/awesome-crystal), which has a curated list of shards.
Thanks, I did try `match_hidden = false`.
Thanks for the shard links. Yes, `responds_to?` is working, but I think the issue currently is that in some cases I am using a String rather than a Symbol, so it won't compile. In some cases, an option may be something like `ENV["EDITOR"]` which is obviously a String. Earlier I was using `to_sym`. I might have to rethink this, so all choices are symbols.
**RUBY\_PLATFORM** ?? `opener = /darwin/.match?(RUBY_PLATFORM) ? 'open' : 'xdg-open'` I did find a discussion some days back in which no one really seemed to answer why they needed to know the platform. I need to know it sometimes to decide whether to use a Linux tool or OSX one. Another case is deciding `locate` vs `mdfind`.
Good! FYI, Passing `match_hidden = false` creates a local variable named `match_hidden` and pass the value `false` as a positional arg (same as before..)
\`responds\_to?\` is not evaluated at runtime like in Ruby, so you can't use it with strings that are only known at runtime. Crystal has static type checking, so it already knows at compilation which type an object can be and what methods it responds to. Trying to call \`responds\_to?\` with a dynamic value looks like an error in your app design.
A user is shown a menu of what he can do with a file. Most options are methods, but in some cases it could be: open with `PAGER` or `EDITOR`. I guess I could just evaluate the run-time values within a method, rather than put them in the key mapping. It's not very clean or consistent I agree, it's something that has grown over the past ten years or so.
`f = "~afile.dat"` `puts File.expand_path(f)` `&gt;&gt; /home/crystal/file.dat` &amp;#x200B; `File.expand_path` incorrectly handles files starting with a tilde. It also lops off an extra character, I think it assumes it is a slash. Can expand\_path only expand the tildle if the filename starts with "\~/" ? I tried to see how other apps work. `ls ~bin` gives an error but `ls ~/bin` works. &amp;#x200B; [https://play.crystal-lang.org/#/r/6u1o](https://play.crystal-lang.org/#/r/6u1o)
[https://play.crystal-lang.org/#/r/6u41](https://play.crystal-lang.org/#/r/6u41) `in line 13: instance variable '@flag' of Foo must be Symbol, not (Array(Symbol) | Symbol)` I think I understand what is happening here but I don't know how to deal with it. Is it that in Crystal, a hash must never have a variable value ? At compile time, the compiler does not know whether the returned value will be Symbol or Array(Symbol), so it does not allow me to set @flag. But I know it will be a Symbol. @flag = :center @options = { "truncate\_from" =&gt; { :current =&gt; :center, :values =&gt; \[:left, :right, :center\], :var =&gt; :truncate\_from } } @flag = @options\["truncate\_from"\]\[:current\] I know that `:current` returns a Symbol. but it seems the compiler infers that the result could be an Array. What do I do?
Hey you should probably also add a function for working out which way Mecca is. I'm not a muslim, but I remember my old Muslim workmate had to work out the direction when we travelled. I'm sure there are published algorithms for putting in coordinates and then it gives you a direction. Maybe even use the google API so folks could do something like putting in "Barcelona spain", and it fetches the coordinates and replies something like "Mecca is East , 15 degrees north" (or whatever it is). That'd be super useful for Muslim folks I imagine
Probably because you didn't initialize `@list` in the constructor, so it will be `nil` after construction. The type doesn't narrow inside the `if` statement either, unless you were to assign it to a local variable first.
Instance vars can be modified from outside the current scope in a concurrent environment. Thus the value of \`@list\` can theoretically change between the not-nil-check \`@list\` and the call to \`@list.empty?\`. Local vars are only visible in the current scope and the compiler can make sure there is no chance of external modification. See [https://crystal-lang.org/reference/syntax\_and\_semantics/if\_var.html#limitations](https://crystal-lang.org/reference/syntax_and_semantics/if_var.html#limitations)
You don't need to guard the instance variable if it can never be \`nil\`. For this you need to assign a value directly in the initializer: ```cr class Foo def initialize @list = [] of String end def main @list.empty? end end Foo.new.main ```
Thanks, I get it. A similar query I had some time back. How does one initialize a String without a value ? In ruby code, I did `@var = nil`. Do I do: `@var = uninitalized String` I tried that but ran into trouble, trying to check `if @var` Currently, I've made them `@var = ""`, so now I have to check for `@var == ""` rather than `if @var`
`uninitalized String` is clearly the wrong way. You should almost never have to use `uninitialized`, except when writing C bindings and maybe some other very special case. You can just assign `@var = nil` like in Ruby. You only need to declare the instance variable as nilable (`String | Nil`). Then it depends only on your domain how a string with no value should be represented. Does there need to be a distinction between non-existing (`nil`) and empty string (`""`)? Do you need frequent checks such as `if string` or `unless string.empty?`.
Since I use Ruby at work I'm looking forward to being able to utilize Sorbet. But man that method signature syntax is ugly and feels so ad hoc. I wish we could just switch to Crystal, but that won't be happening anytime soon.
This is ridiculous. &gt; Of course, using Sorbet is optional, but looks like the Ruby team has an intention to merge it into the core, meaning that sooner or later Ruby which we used to love will be no more. There will be no joy of sitting aside a lake observing its beauty, but heartless business requirement of confident deploys. Nobody is coming for your Ruby, dude. Types will always be optional. Even if you work somewhere that insists on types, they don't remove all the creativity from your work. "Heartless business requirement of confident deploys?" So dramatic. He goes on to complain about the runtime overheard added by Sorbet except... this is only if you want additional type checking in production, which is far from guaranteed to be popular. If you strip types at compile, you're left with plain Ruby. If/when Sorbet or whatever it becomes is merged into Ruby, I wouldn't be surprised if those type definitions ended up providing the Ruby Virtual Machine with opportunities to optimize its performance. I understand why folks are excited about Crystal but I think that the need to aggressively bash one piece of technology just to make your preferred tech look good is childish.
Well said. We're stronger together.
If/when Sorbet is merged, I wouldn't be surprised if some of the type checks could be intelligently dropped. Of course for the record, Python has also added static type syntax in PEP 484, and the result was a lot less scary than many anticipated.
I would go even further and say that typing in Python is one of the best additions to it in a long time. Being able to statically type check your code before deploying is great for catching possible type-related bugs, and mypy has definitely pushed me to become a better coder. The types (in my opinion at least) add a lot of clarity to the code that used to soley be captured in documentation. It's also allowed for some really cool metaprogramming now that you can inspect types for things like dataclasses.
Nice set of features! When I do RoR I usually include `factorybot` and `forgery` or similar gems to generate test data easily. I'm pretty used to those idioms. Am I missing something or spectator is tested with spec and not by Spectator itself?
I would use factorybot as well, back when it was called factory\_girl. I'd like to have functionality like that in Crystal at some point. I've found that the named arguments work well enough for my needs. Yes, it uses Crystal's default spec for testing. I'd really like to switch it at some point, especially since there's some really bad test code in there. But I felt it wasn't ready to be used on itself during development. For instance I only had the `eq()` matcher for most of the development, while I fleshed everything out.
This looks fantastic! I can see this quickly becoming the new standard. While I appreciate the minimalism of the built-in spec framework, this seems much more suitable for larger projects.
Very nice, wanted to do something similar for a while now but never found the time. One question: usually people generate classes for each context and methods for each example, but you chose modules for contexts and classes for examples. Does it provide any benefit or is it purely stylistical?
Love the \`foo.size does not equal 12\` thing. \`given\` is very nice too!
I'm pretty sure that especially larger projects will experience huge performance issues. The implementation uses lots of macros and every spec adds a type. Types and macros are work-intensive and put stress on the compiler. So I'd expect compilation performance to skyrocket once you have more than maybe a few hundred specs (which is peanuts for even medium-sized projects). Additionally it'll eat lots of RAM. /r/icy-arctic-fox have you done any larger-scale performance tests?
I'm not a fan of this. While working with Crystal's standard \`spec\` library, I'v come to really appreciate the minimalism compared to rspecs magic fu. At first it seems like you're missing a lot of very nice helpful features. But in the overall picture, it makes everything easier. &amp;#x200B; \`spectator\` claims to "reduce complexity of test code." This seems true, because with \`before\` and \`after\` hooks, the individual tests often contain only the expectations themselves. But a test is more than just an expectation. The setup and teardown steps are moved away in a different context. This in fact increases complexity. You can't follow the entire substance of a test anymore at a single place. It's scattered at different locations. When there is no automatic mechanism for hooks, you need to call them explicitly in each spec. That might add a little bit of boiler plate, but to the benefit of making it easier comprehensible. This is a much more important aspect than having some duplicated code. You want to be able to come back to your code after months and understand it without having to figure out which hooks might be involved in setting the stage.
The consequence of not implementing direct support for it will be that people extract methods or macros that does it instead. I certainly know I would if I were to have a similar test setup as I have in the rails projects I work on. It is simply not ok to not have sane defaults, like having every test being run in a transaction (to ensure test repeatability and test independence), or setting up so that external calls is forbidden during testing unless explicitly opted into.
I do transactions like this: ```cr it "some db spec" do transaction do |db| # do something with db connection end end ``` Done. Neat and explicit. No indirect interference of some unknown hooks. If you wan't to know how it works, you look up the `transaction` helper.
Instead you get awkward looking for accidentally created crap in your database when you forget to add the transaction block for one of the test, and the content of that then leaked and made some other test fail. No thanks, I want enforced sanity by default.
/u/icy-arctic-fox
The largest test that I've done was around 70-ish tests. There was a bit more overhead than the default spec to get going (compilation and startup), but the tests ran faster. I think this is because of the proc calls that the default spec makes. I feel obligated to present some results, so I will create a large test and get back to you.
That was done to use contexts as mix-ins. The nested contexts can include their parent to propagate everything downward. For instance, in this code: context "foo" do let(some_var) { "A string" } context "bar" do it "does something" do expect(some_var).to_not be_nil end end end `some_var` is defined as a method in the foo context. The bar context should be able to access it, so the bar module includes the foo module. Then the it block includes the bar module. This is quite an elegant solution to nesting. I suppose you could use classes and extend from the parent for all nested contexts. So it is somewhat a style choice. Thanks for bringing that up though! I think I'll play around with that and see if it has any performance benefits.
When I started writing tests in Crystal, before I made this shard, I found myself doing the same thing. Writing a bunch of code to keep my tests clean. Even in the test code for Spectator, I have a lot of boilerplate - helper methods and macros to wrap tests. I personally don't like that and don't want to remember to use that everywhere. In my opinion it adds clutter to the tests. I think the test code should be focused on performing the test, not setup and cleanup. Teammates also have to learn those custom methods you wrote to make sense of your tests. That just my opinion.
Like it. Will give it a try on my next project. Thanks!
That is fair criticism. I totally get where you're coming from. I hate Rails because of the magic it does behind the scenes that is not apparently obvious. Other people love it because it handles a lot of things for you. However, I feel forced into its opinionated style when I use it. That is not something I want Spectator to feel like. There's nothing forcing the usage of the new-fangled features in Spectator. So if someone doesn't want to, or don't feel comfortable using them, that's ok. But they are there if you want them. If you want to change the test style a bit and remove boilerplate, the features are there. The user writing the tests doesn't have to implement their own. I see this as a stylistic choice for the person writing the tests. If you're not interested in using any of the features, why bother dragging in a whole dependency? Just use the built-in spec framework. I found that I wrote a lot of helper code for my tests, and that's due to my style of testing. I prefer test code to focus on the test, not the setup and teardown. I also really missed the features RSpec gave me. I wanted to spend more time writing code, and less time writing tests. So I started working on Spectator, and I'm sharing it for others if they want to use it. I plan to use it for my own projects because I hate boilerplate. TLDR: It's an opinionated style choice left up to the user.
This depends a lot on what the ORM is. In Lucky we've got "Boxes" which handle creating data &amp;#x200B; [https://luckyframework.org/guides/generating-test-data/](https://luckyframework.org/guides/generating-test-data/) &amp;#x200B; It solves the problem of FactoryBot but with classes and regular methods. This means you get compile time safety and \*way\* more flexibility since you can do whatever you want with methods. Like \`Post.with\_tags("tag1", "tag2")\` &amp;#x200B; Still need to implement some different hooks for before/after create but it is already quite feature rich due to using Objects/methods
I personally don't use \`let\` or \`subject\` much, but I do wish that the default Spec implementation had an \`around\` feature and a \`before\` that could apply to just some specs. Really helpful for test cleanup (like db cleanup for example)
&gt;Teammates also have to learn those custom methods you wrote to make sense of your tests. Yes, obviously. But they represent an explicit relationship between setup/teardown code and the actual tests. The structure is clear and easy to understand. When hooks are defined *somewhere* in the spec suite it's much harder to make sense of it. I've experienced this a lot when looking at rspec-suites overusing the available magic features. And it can be really difficult to figure out what is actually going on.
&gt;when you forget to add the transaction block for one of the test Then you would have no database connection at all. So no unsanity could ever manifest itself. \`transaction\` gets a connection from the pool, which is then used for the spec (after starting a transaction).
So your solution to, say, a end to end test of a request, is to pass in a db connection? Sorry, but your approach looks like it fits a \*very\* restricted set of cases (where it would be decently nice), but not at all for many other cases.
I don't think the distinction is between more or less boilerplate. You can write boilerplate-free specs with `spec`. There is a difference in the mechanism used for abstracting recurring tasks though. The general goal should be to make specs simple to write and understand. And I don't think hiding the specific setup and teardown steps of a spec in distant hook system helps in making it understandable. So not having things like `before_each` is actually a feature. And I like it very much, because it helps writing better specs. Using abstraction is fine, obviously. Otherwise, you wouldn't be able to understand the specs anymore. But abstractions should not be hidden but descriptive. Don't abstract everything away that you are only left with plain expectations and no idea what circumstances they're based on. You can structure specs like this: ```cr before_each do setup_foo end it { test1 } it { test2 } it { test3 } ``` In this example context it's easy to follow what is going on. But when there are more and longer specs, maybe separated across different files and the hook defined somewhere in a `spec_helper`, it's not hard to imagine even the author loosing track pretty quickly, let alone readers. I think this alternative style is strictly superior: ```cr def it_foo setup_foo it { block.call } end it_foo { test1 } it_foo { test2 } it_foo { test3 } ``` The setup code requires one more expression here, okay. But that's negligible compared to multiple examples using it. The examples add a few more characters, but they make the difference in a positive sense. All information on what is going on is encoded in every single spec. It's super flexible, too. Single specs can be easily adapted to different setup steps, without having to regroup and figure out which hook should go to which example block.
I was mainly talking about unit tests. But request specs can work like this as well, as long as the request is entirely handled inside the application. But you're right, there is a case for deferred setup/teardown steps, when they're not specific to the example. Resetting the database state needs to happen for any specs that has some kind of database interaction. For this, even \`spec\`'s global hooks would be sufficient, even if they cost a bit performance for non database specs. But there are alternatives, for example placing all such specs in a namespace where global \`it\` is overridden. This can work perfectly without having fine grained hooks.
At first I was going to just throw together a bunch of random tests, then copy-paste, but I realized there was already a large test set to run against. I've modified the Crystal standard library specs slightly to work with Spectator. Just to get a quick test together, I pulled out anything that didn't work syntactically. I could change them to be compatible, but that's not what I'm going for - I want a bunch of tests. I also identified [an issue](https://gitlab.com/arctic-fox/spectator/issues/4) and some items to investigate while preparing this, which is good. Crystal v0.28.0 Pulled source code from crystal's master branch. Nuked my caches (\~/.cache/crystal). %&gt; time crystal spec/std_spec.cr ... Finished in 3.02 seconds 2663 examples, 19 failures, 2 errors, 1 pending ... crystal spec/std_spec.cr 106.18s user 11.11s system 239% cpu 48.981 total I saw about a maximum of 3.5 GB of memory usage during the compilation. The time taken was just over 100 seconds. Running again without wiping the cache produced this result: %&gt; time crystal spec/std_spec.cr ... Finished in 1.87 seconds 2663 examples, 19 failures, 2 errors, 1 pending ... crystal spec/std_spec.cr 57.85s user 7.14s system 171% cpu 37.807 total Took about half the time to compile, and memory was about the same. Repeating these tests produced consistent results. Ignore the failing tests, they're probably from me botching the code. Some might be from differences in 0.28.0 and master. My laptop specs (what I ran these tests on): Linux Mint 19 Cinnamon Linux 4.15.0-47-generic Intel Core i7-6700HQ CPU @ 2.60 GHz x 4 16 GB Ram Changes made to tests are here: [https://github.com/icy-arctic-fox/crystal/commit/fd58f2f563355fd82da6e580efdf415e1d3e6d88](https://github.com/icy-arctic-fox/crystal/commit/fd58f2f563355fd82da6e580efdf415e1d3e6d88)
I think it comes down to the scenario. For example, in the specs for Crystal, there's numerous places that use \`it\_parses\` instead of wrapping with hooks. I think that is a much better solution in that situation, because it clearly expresses what is going on. I agree with you there. Tasks like preparing and cleaning up a database are not the main focus of a test that happens to access the database. So I feel in that scenario, it is better to use hooks to declutter the tests. "Porque no los dos?" Use whichever is easier to understand. I think we can both agree on the philosophy that the specs should be easy to understand. That's really what I'm going for with this shard - making testing easier. If someone creates a complete monster of spaghetti code with hooks everywhere, well, it's on them. Not recommended to do so, since it's hard to follow. But the additional features can be useful in places. It also means the developer doesn't have to write it themselves, possibly adding boilerplate.
Could you run the unmodified std\_spec on your system for comparison?
I don't know how to compile and test all of Crystal locally. So I undid the changes to run Spectator. It should be the same tests, same code, just using the default spec. Fresh run with no cache: %&gt; time crystal spec/std_spec.cr ... Finished in 2.95 seconds 2663 examples, 4 failures, 2 errors, 1 pending ... crystal spec/std_spec.cr 28.84s user 3.35s system 188% cpu 17.105 total And with the cache: %&gt; time crystal spec/std_spec.cr ... Finished in 1.98 seconds 2663 examples, 4 failures, 2 errors, 1 pending ... crystal spec/std_spec.cr 13.51s user 2.69s system 140% cpu 11.546 total Memory usage was about 1 GB. Clearly the default spec is faster to compile, as expected. It has way less code and doesn't use nearly as many types. Personally, I'm ok with waiting a bit longer for a large project. Especially if it will be run with CI, and I can filter tests locally for what I'm working on. But if speed is deal-breaker, might not want to use Spectator yet. Or even Crystal for large projects in general.
Hey icy-arctic-fox, the code is super easy to read, very well organized and documented! I'm always surprised by how much Crystal can do with what we have right now. To be honest, I didn't image all of this was possible (I know there's `spec2` too, which has more or less the same features, but I think less).
Yes, I agree with this. At my workplace there was a recent discussion about some RSpec test suites not being clear because of shared examples, `let`s overriding other lets, etc., and how to make it clearer. One of the preliminary conclusions was to use helper functions, that you explicitly call, to initialize stuff. RSpec has a lot of hidden state and calls (via `let`s, `subject`, `before`, etc.) that makes it really easy to write tests, but hard to read them later (for you and everyone). Crystal's `spec` limitations exist because of language limitations (well, icy-arctic-fox and others have proved that it's actually possible), mainly compilation performance. But after a while I also came to appreciate its simplicity. Invoking a helper function seems tedious when writing, but it's much clearer when reading.
&gt; It is simply not ok to not have sane defaults, like having every test being run in a transaction (to ensure test repeatability and test independence) But you can do that. `Spec` has `Spec.before_each` and `Spec.after_each` which run before/after each every test. However it's not perfect because there's no way to only enable these hooks for a given test suite.
The features RSpec provides can be quite useful and cleanup a lot of code. But, it has to be used properly. I think we can all agree that the misuse of these features that leads unreadable code is the problem, not the tool itself. Though some might argue that the tool promotes those bad practices. However, I don't see excessive use of hooks and subjects a recommendation by the authors.
Thanks! There were some complicated parts in the source. I wanted to make it easy for contributors and others to figure out how it works. Spectator pushes the bounds a bit for what Crystal can currently do. I ran into quite a few oddities and learned a lot about Crystal's internals while working on this. It's cool what Crystal can already do, and will be able to do in the future. Looking forward to it!
For a while now I've been working on an extensive natural language processing library called Cadmium. Over the past few days I've poured hours of work into its development and now I'm proud to announce support for tries (thanks [adoxography](https://github.com/adoxography)), readability, and WordNet support! I've also created a logo for the project, added documentation hosted on [Github pages](https://watzon.github.io/cadmium/), and updated a lot of the internal documentation. The project still has a ways to go, but I'm extremely excited and wanted to share with the community. Happy coding everyone!
Good job! Crystal is awesome for ML projects
Yeah, agreed. And perhaps there is a need to explore other approaches to solving issues like that compared to how it is done in rspec - patterns like setting an instance variable that is then later used in the actual test doesn't transfer, for example.
Thank you! I definitely agree. Crystal is beautiful and easy to use, which definitely helps when doing ML, as well as being very fast and powerful. It's the best of both worlds.
Yes and yes. Crystal is such a great fit for ML. The more ML projects for Crystal out there, the better. If some of that spotlight on ML could turn to Crystal, that would be great exposure for the language.
Awesome!
```cr require "http/client" response = HTTP::Client.get("http://www.example.com") content = response.body.gets_to_end ``` You can read more at https://crystal-lang.org/api/0.28.0/HTTP/Client.html
Yep. probably the easiest way.
&gt;require "http/client" response = HTTP::Client.get("http://www.example.com") content = response.body.gets\_to\_end thank you :)
I'm sorry that I ask here, I'm just banned from StackOverflow because my questions are "not well received by the community"
Use Array#includes?
Yeah, but I want to see at which index the element is.
Would #index(obj) work here?
nevermind, it gives me an error when I do \`\`\`cr require "http/client" def gotosite(q) response = HTTP::Client.get("https://bogdan.bg/rns/db.rad") content = response.body.gets\_to\_end if content.include? "#{q}" content = content.split("\\n") site = content.index(q) puts site end end q = gets gotosite(q) \`\`\` \`\`\` Error in [cobaltium.cr:14](https://cobaltium.cr:14): instantiating 'gotosite((String | Nil))' &amp;#x200B; gotosite(q) \^\~\~\~\~\~\~\~ &amp;#x200B; in [cobaltium.cr:5](https://cobaltium.cr:5): undefined method 'gets\_to\_end' for String &amp;#x200B; content = response.body.gets\_to\_end \^\~\~\~\~\~\~\~\~\~\~ &amp;#x200B; Rerun with --error-trace to show a complete error trace. \`\`\`
You could just use `a.index("blah")` If you want to actually implement it you could do something like this https://play.crystal-lang.org/#/r/6vp0
`a.index("yeet")` \- [link](https://crystal-lang.org/api/0.28.0/Indexable.html#index%28object%2Coffset%3AInt%3D0%29-instance-method)
Yep. Thanks. But how do I use it like foo = a.index("yeet") puts a[foo]
Thanks, but is it possible to use it like foo = a.index("yeet") puts a\[foo\]
You’ll want to wrap the puts statement around something like Unless foo.nil? Puts foo End The #index call returns nil when it can’t find the object, so you have to consider that case as well.
But why is it nil?
Ah, I got it! It's because it looks for an exact match.
you use item not index. why not ``` arr.each {|item| p item if item == "yeet"} ```
Whats the point of getting the index, just to then use the index to get the same item? At that point you could just do a = ["yeet","blah","foo"] a.find &amp;.==("yeet") # =&gt; "yeet"
Why not use the comparison operator?
https://play.crystal-lang.org/#/r/6vvu The method is pretty much just a wrapper of like `string.index("hello") &lt; string.index("cool")` that raises an exception if a value is not in the array.
Done :)
Careful, that way of doing it in Ruby is a security risk. See https://twin.github.io/improving-open-uri/ and https://web.archive.org/web/20171220083539/https://sakurity.com/blog/2015/02/28/openuri.html
Coding overhead aside; Honestly I see huge potential for Ruby optimization's when combined with Sorbet. It only make's sense that something like the JIT engine, is going to eventually take advantage of the known IO for each pertained method it's expected to evaluate. Personally I don't like ad-hoc documentation. But that's just my preference.
…and there's also [https://github.com/opensas/json-mappings-generator](https://github.com/opensas/json-mappings-generator) [https://github.com/z64/api\_mapper](https://github.com/z64/api_mapper) and [https://github.com/watzon/json-to-crystal](https://github.com/watzon/json-to-crystal)
This is so far the most beautiful test / spec variant in Crystal for me!
this is awesome. Really.
As the first answer says: &amp;#x200B; `string.index("cool) &lt; string.index("hot")` &amp;#x200B; Perhaps, if you are not sure if the value is there, you could try: &amp;#x200B; `(string.index("xxx")? || 999) &lt; (string.index("yyyy")? || 999)`
Just prepend `./` to resolve the ambiguity: `puts File.expand_path("./~torrentfile.dat")`
Looks like a bug to me. IMHO you should create an issue for that.
Why should it be ambiguous? IMHO this is a bug. This should work in the shell of your choice &amp;#x200B; $ mkdir \~foo $ cd \~foo &amp;#x200B; or if you have Linux (I don't know what is the \`realpath\` equivalent in other OS) you can try this as well: &amp;#x200B; $ touch \~bar $ realpath \~bar &amp;#x200B; Both should work fine.
It's not a bug it's a feature™. `~foo` maps to the `foo` user home directory. It's a convention used by many softwares, e.g. Apache HTTPD: https://httpd.apache.org/docs/trunk/howto/public_html.html Or Ruby: ``` File.expand_path('~foo/bar') # ArgumentError (user foo doesn't exist) ``` If you don't want this feature, and want `realpath(1)` behaviour instead you can use `File.real_path` in crystal and `File.realpath` in ruby.
What? httpd is a web server, whatever it chooses to do with a tilde is its personal business. The actual OS only expands a tilde to the current $HOME when it is used as a directory name (as in the _whole_ name, not part of one), and programming languages should support the OS behaviour not whatever convention arbitrary software might come up with.
I don't get it: why should the current behaviour be a feature? puts File.expand_path("~torrentfile.dat") still returns /home/crystal/orrentfile.dat And nothing you explained here describes this behaviour.
This is not a one case call, these are generic applications. I would have to check for tilde and append this before calling expand\_path always.
I understand that this is documented. But my point is that a filename like "\~foo.dat" is **valid** in unix, and yes, there is a convention for us to use a tilde, (mostly on the commandline and in shell scripts) as a short cut to hardcoding the home dir. But should a program crash with *valid* data just to honour a convention. &amp;#x200B; Also, it is possible to do **both**. If file exists, then don't expand the tilde, otherwise expand it. &amp;#x200B; `real_path` actually works in this case, but does not in cases where it is "\~/" at the start of a file. So once again I would have to check the filenames and then call either expand\_path or real\_path. Everywhere. In all apps. Forever.
I've currently written a wrapper around `expand_path` to check for starting "\~". Am calling that from everywhere in my app, but dread the idea of having to use this in all generic file related apps in future.
Others did not probably realise that Crystal is lopping off an extra character, so simply checking for "\~/" would solve this problem for both cases. &amp;#x200B; What this means to me is that every ruby or crystal app that uses `expand_path` on file names in the directory could crash if they encounter such a file.
&gt; What? httpd is a web server, whatever it chooses to do with a tilde is its personal business. The actual OS (well, *nix OSes) only expands a tilde to the current $HOME when it is used as a directory name What you are saying would make sense if `expand_path` claimed to be a syscall, but it isn't `real_path` is. `File.expand_path` is an application level function and doesn't rely on the Kernel. Ruby, Crystal and many other applications like HTTPD chose to support that `~username` convention. It's their personal business as you put it.
And you don't see anything disingenuous about trying to lump Ruby, Crystal and httpd in the same category? Lol okay then
&gt; my point is that a filename like "~foo.dat" is valid in unix I never said it wasn't. &gt; But should a program crash with valid data just to honour a convention. It's not crashing, it's not doing what you expect it to do, because the request is ambiguous. (Actually it's buggy as it always assume `~` is followed by `/` without checking for it: https://github.com/crystal-lang/crystal/blob/bbffbe05083802a80f2669ef323c26114afd53fe/src/path.cr#L567-L575, but that's irrelevant in your case because even if it wasn't broken it still wouldn't do what you want). &gt; real_path actually works in this case, but does not in cases where it is "~/" at the start of a file. So once again I would have to check the filenames and then call either expand_path or real_path. What you are asking for is just not possible. `~` is a special character for `expand_path` and that function can't possibly be smart enough to figure you didn't mean it to be handled specially. It would be the same with `glob`. `*` is a perfectly valid file name, but if you don't want it to be expanded by `glob` you have to escape it. The same goes for `~` in `expand_path`. I'm sorry but a function that does what you want simply can't exist, you must disambiguate these cases yourself.
Not at all. All 3 of them are purely applicative code. `~` means nothing to the kernel and file systems. They're only a special character to some shells other types of libraries and applications doing path manipulations. It's not regulated by any kind of spec. Some decided to go farther and support the `~username` convention, others didn't.
/u/roger1981 so I was part wrong, turns out it doesn't appear Crystal tried to support `~username` like ruby. So the behaviour you noticed is mostly a bug, and I submitted a PR to fix it here: https://github.com/crystal-lang/crystal/pull/7768 I do still stand behind what I said about escaping though.
`match_hidden` currently works only with recursive directories: ` Dir.glob("**", match_hidden: false)` should not list hidden files.
This worked! I had to read the MacroId documentation to get the rest working but it works like a charm!
I miss classes ^^
Sorry ? Could you elaborate ? Do you mean I have not properly "OOPified" it ? Could you suggest a class structure ?
This is fun! A great project and an excellent way to learn Crystal. I love that you’re manually writing the characters to build the user interface. So many programmers just dismiss that as magic and never try to understand it. I loved that part when I wrote https://github.com/robacarp/keimeno I’d second /u/bew78 mention that your structure needs revision. This reads like bash, but with Crystal words. A good first pass is to break out your classes into multiple files. A second pass might be to ask the question “what single purpose should this class perform?” Then build additional classes to solve the other problems. For example, I might remove the solution to the question “what key was pressed?” from the code which also answers the question “what should the user interface be doing?” Hopefully that’s useful feedback. I’ve tried to do this with Keimeno as well, so maybe there’s some examples of what I’m talking about in there.
&gt; https://github.com/robacarp/keimeno I'll definitely be studying the code of this. Have just glanced through it and run your demo on my laptop. A lot for me learn in your code!
I've broken up the code into some files based on the most obvious functions. Am continuing with this.
I did auto generate bindings for godot using bindgen. [https://github.com/kalinon/godot-crystal](https://github.com/kalinon/godot-crystal) may not be perfect, but might also be a start.
Yes, but as you said it's still WIP, it'll be better once you start making classes to isolate , otherwise it's just a crytalized bash script but without using crystal at its best ^^
that's pretty great, thanks!
May I ask whether you also plan to implement something like word2vec, too?
I don't see why not, I just need to do some reading up on word2vec. I'll go ahead and add it to the roadmap though.
Best way I can think of is this `string.includes?("cool") &amp;&amp; string.index("cool") &lt; string.index("hello")` If you're going to be doing this a lot make sure to abstract it out into a method for more DRY code. def is_before?(array, a, b) array.includes?(a) &amp;&amp; array.index(a) &lt; array.index(b) end The other benefit to using a method is that it works for any Array, not just a string array. Of course you could also add an `is_before?` method to the Array type, but it's not really necessary.
Unfortunately spec2 seems to be unmaintained at the moment, so this is great news
I have the feeling that [dev0urer](https://www.reddit.com/user/dev0urer/) is [working on it](https://github.com/watzon/crodoc) already. ;)
Probably something we didn't think about. Would you mind creating an issue in the bug tracker? Thank you ！
I think I would rather have discussions around improving the current one instead of making a whole different one. This way there isn't yet another thing to learn/maintain.
[https://github.com/crystal-lang/crystal/issues/5983](https://github.com/crystal-lang/crystal/issues/5983) already is there. But it seems to give a wrong solution. It asks for the destination to be created only if it doesnt exist. I am saying something like (*untested*):: if File.directory?(source) &amp;&amp; File.exists?(target) target = File.join(target, File.basename(source)) end Should I create a new issue, or add this to the existing issue ?
You caught me lol. I created that a few hours after this post. Just a pipe dream right now. Documentation generation is very difficult to accomplish.
That's just plain ugly IMHO
Funny I actually wrote something like this a while back https://github.com/watzon/json-to-crystal
Thanks. I have a couple basic questions. 1. I've compiled my program, run it, and now wish to share it. Do I share the executable only ? Does the other person need to have crystal installed to run the executable ? This assumes the other person is on the same OS. If the OS is different, i guess I have to share the code and the person would have to compile it. 2. What is the `dwarf` file ? How to use it ? 3. Is there something like `rake`? What are others using ? I am using `make` since I have multiple files and wish to avoid unnecessary recompiles.
&gt;Unfortunately, installing binary shards (like you can with &gt; &gt;gem install \[gemname\] &gt; &gt;in Ruby) is not yet supported, but hopefully someday it will be. &amp;#x200B; Why not just use the code of rubygems for shards. I would assume there would only be minor changes ? Or maybe homebrew ?
Unfortunately the changes would be pretty major, and the Ruby ecosystem and the Crystal ecosystem are just different. Hopefully installing binary shards will be possible someday soon though.
1. So as far as how to share your program there are three ways possible so far. You can compile a binary and share it, but the list of targets is small so far I believe. The second way is to have them clone your repo and build a binary themselves. The third and probably best way is to create a docker container with your program running in it. 2. I don't know what you're referring to by a `dwarf` file. 3. There is a project that I know of called [cake](https://github.com/axvm/cake), but the best way to build in my opinion is just using make or a shell script.
/u/roger1981 Some links for you regarding #1. https://github.com/crystal-lang/crystal/wiki/Static-Linking https://forum.crystal-lang.org/t/is-it-currently-possible-to-distribute-pre-built-binaries-of-crystal-applications/491?u=blacksmoke16 https://forum.crystal-lang.org/t/could-crystal-static-build-to-single-binary/561?u=blacksmoke16 tl;dr can statically link your binary (only supported on Alpine linux), which would then be compatible with any other os on the same arch. #2 Dwarf files are files that contain debug data. https://en.wikipedia.org/wiki/DWARF I dont really know much about them myself, but thats the jist.
Crystal runtime depends on a couple of dynamic library (libevent for the green thread, and Boehm GC for the _surprise_ ...GC).
I'm a big weeb, \*err\* MangaDex user, i'll totally help you out. What kind of testing do you need done? Also, post this to the crystal forum as well, [http://forum.crystal.org](http://forum.crystal.org).
1. You know just testing the endpoints like this [one](https://mangadex-api.herokuapp.com/title/30123). List of endpoints can be found in the [index route](https://mangadex-api.herokuapp.com/) (as I would call it). Just testing those for performance reasons so that I could at least optimize them on Heroku. 2. Sure! I'll post them there right away :)
Oh ruby :( Sometimes I love it, other times I want to drown it. This is one of those philosophical things I do appreciate with python. Python can be old fashion and conservative in its choices but rubys throw everything at the wall and see what sticks approach really does generate some absolute wtf bugs sometimes. Sometimes restraint and impliciteness really does win the day over clever and fancy
Keep up the good work! Working with natural languages is fun! I remember having to work with a porter stemmer once in my life :-)
Yeah it is fun, and the library should be useful once people start doing more NLP in Crystal. It's a perfect language for it.
It absolutely is! Again: thank you so much!
If you don't care about the actual type for `MyClass`, you could just set the return type as `MyClass` and it would work as intended (returning a `MyClass(R)` where R is any type). However, if you still need to use the type parameter elsewhere, like in your second example, you have to put `forall R` at the end of the signature: `def myMethod(proc : Proc(T, R)) : MyClass(R) forall R`.
Crystal has this [https://crystal-lang.org/api/0.28.0/Crystal/Macros/Generic.html](https://crystal-lang.org/api/0.28.0/Crystal/Macros/Generic.html)
Thanks for the reply! I actually care for the actual types which is why I used generics here. Your type signature is definitely the closest to what I need.
Thanks for linking the Array API, didn't notice that they are doing something exactly the same as mine.
I think you can add a `forall R` after the return type to do this, like described [here under "Free variables"](https://crystal-lang.org/reference/syntax_and_semantics/type_restrictions.html).
Thank you! Didn't notice it at first, my bad
Maybe you can use channels that return the data and keep expectations on the main thread? Or do you want tests to multiple specs to run in parallel?
I mean, in JS callbacks are needed because how V8 works. In crystal you can wait for a channel and it’ll work perfectly, no callbacks needed.
Yes, the common pattern here is to do: &lt;pre&gt; it "waits" do channel = Channel(Nil).new spawn do channel.send nil end channel.receive end &lt;/pre&gt;
 it "waits" do channel = Channel(Nil).new spawn do channel.send nil end channel.receive end
I totally agree. The current status of the doc generator leaves a lot to be desired. But, it works. And I think it's acceptable for the time being. So working on that is not a high priority right now. But I think we're all in agreement that it needs a major rework at some point. However, the doc generator already provides a generic interface for extracting the API definition in a JSON format. You could simply build a custom generator based on that data. No need to work with the compiler AST. Eventually, we might even separate the doc generator entirely, that the compiler is only responsible for extracting the data and an external tool generates the output. This would easily allow for custom output formats while all building on a common source format.