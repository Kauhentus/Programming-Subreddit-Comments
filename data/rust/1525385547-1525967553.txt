A poor attempt at a joke would be calling it a name collision. 
If I do: console.log(wasm); or console.log(testMe()); I get: Promise { &lt;state&gt;: "pending" }
I think [all of the browsers with wasm support](https://caniuse.com/#feat=wasm) also have [async/await support](https://caniuse.com/#feat=async-functions).
Certainly. My reason for posting this is merely to point out that this tradeoff exists- people often argue for the monomorphization-heavy approach on performance grounds, as it's generally still considered a "zero-cost abstraction."
Whoops, I just tried typing "async" into the dev console and got "async is not defined" so I assumed it wasn't supported. (I expected a syntax error instead.)
https://play.rust-lang.org/?gist=565fc99da255bf84dd4f952e289693f0&amp;version=stable&amp;mode=debug Just return the vector instead of converting to byte array. 
&gt; "zero-cost abstraction." It is worth remarking that zero-cost does not mean zero-overhead. The meaning of zero-cost is that there is no way of doing the exact same thing that is faster/better. The post basically says that it is better to do something different in some cases, which is correct.
Not sure about `wasm-bindgen`, but there is stdweb: https://github.com/koute/stdweb
cool thank you !usernamedottxt
but why? 
I've tried using generic several times but part of the reason I use C++ generics is because I know I'll use it for at least two types but possibly more. In `_Generic` I must know all possible types up front. It's not so much a "generic" as "overloaded".
Well for the CPU the GBA uses I'm sure it is technically possible. But there is a fair amount of computation involved in crypto wallets from my understanding of them, and the CPU used by the GBA is really slow.
… but practically is how everyone treats it. The default type of version matching in NPM/Yarn is now `^`, which is the same.
Brand new rustacean here, never programmed low-level in my life. Spent the last two or three weeks making this app, hope y'all enjoy it! One of the more interesting things that I used was compiling C# into native code so that I can call into it from Rust through `std::ffi`. Once I get Linux compilation sorted out, I might do a more technical writeup on how to bundle .NET code as a cargo crate.
FWIW, RefCell is one of a handful of types whose implementation (at least, a translated version of it) has been statically verified to satisfy its type (which, in Rust, implies lack of undefined behavior, a fact that is also proven in the same formal development). If I recall, `into_inner` is one of the trickier functions to prove correct, so it's probably a good sign that you thought it was suspicious!
Not really; all it needs is the stride: one number that's a function of `item` and `alignment_size`.
It needs the alignment for whenever it calls the allocator \(if you want to allocate a list of SIMD vectors, you'll need higher alignment than malloc gives you\).
What made me nervous about bringing that up was that if anything goes wrong on the Python side, you'd probably get a crash. I had a bit about doing this, but I could not find any way in the `ffi` docs to make it *not* think it owned pointers passed to it.
Happy I could provide some inspiration. Don't hesitate to ask if there's anything else!
Yeah?
Because the function 'owns' the byte array, so the byte array is de-allocated when the function ends. References do not give up ownership. At first thought, you could return ownership of the byte array. However, you'd then have to know the size of it at compile time in order to return it. You could mess with buffer sizes or junk, or just return the vec. If you need the bytes in the calling function just convert them to bytes there. 
Oh geez yeah that's a good point, sometimes you get used to just malloc'ing away without any consideration of alignment!
Ah, I was thinking you could provide the stride as the alignment to the allocator, but that wastes up to one element of space.
Neat! I have a partial implementation of parsing the procfs pseudo-filesystem which I use for a pretty similar purpose (I use it in some alerting infrastructure). It's currently part of a monorepo that also contains ... Too Much ... but if you were interested in using parts of it ([`RunningProcs`](https://docs.rs/tabin-plugins/0.3.1/tabin_plugins/procfs/struct.RunningProcs.html) in particular seems like it might work for your purposes) I'd enjoy collaborating to make it all more useful/modular.
If I put const wasm = WebAssembly.instantiateStreaming(fetch('rust.wasm'), {}) .then(obj =&gt; obj.instance.exports); wasm.then((res) =&gt; console.log(res)) Inside an async function, I get: Promise { &lt;state&gt;: "fulfilled", &lt;value&gt;: undefined } I'm not quite sure how that helps though.
Weeelll... http://github.com/thepowersgang/mrustc As for speed, I think it's about on-par with rustc for total compilation time (while doing less, mostly because there's not a lot of optimization effort put in yet)
I somewhat understand. I'm competent in rust, nowhere near in javascript. I read through the wasm\-bindgen link you pasted, but I don't quite see how to extract what I need out of it to do what I want. Can you be more specific?
At first, I thought you are trolling given how much you want to get at once... but then I realized Three-rs wants to be that kind of library.
That is awesome !!! I will try using it in my project. Also would be more than happy if you would like to open a PR. 
Slow is not a deal breaker. It has button and screen - that's a plus. I'm wondering about availability - do I get it right, that there's a lot of used ones available on the market?
They're pretty expensive, i paid around 35 USD for one recently
Could somebody explain why this simple code give so strange error: ``` fn main() { let al = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]; for &amp;a in al.iter() { if a &gt; 5 { println!("{}", a); } } } ``` Error: ``` Compiling playground v0.0.1 (file:///playground) error[E0308]: mismatched types --&gt; src/main.rs:5:16 | 5 | if a &gt; 5 { | ^ | | | expected reference, found integral variable | help: consider borrowing here: `&amp;5` | = note: expected type `&amp;_` found type `{integer}` ```
Cool project man. Keep up the good work
Do you know if Apple's USB transfer format is documented? I also have an old iPod touch and the only way to put music on it is by using iTunes, which is torture. If your app could upload to devices, it would be a killer feature. As far as I know no free software projects can upload to apple devices.
Well i figure the lack of internet connectivity would be a deal breaker? 
yes ! in my case it is Vec\&lt;Resullt\&lt;\(\),E\&gt;\&gt; into Result\&lt;\(\),Vec\&lt;E\&gt;\&gt; 
[Here](https://play.rust-lang.org/?gist=e82361d8b34dccd20bf6179d3b509f0d&amp;version=stable&amp;mode=debug) is something close. It converts `Vec&lt;Result&lt;(), E&gt;&gt;` into `Vec&lt;E&gt;`. If there are no errors, the `Vec` is empty. Does that do what you need?
the return type is Vec\&lt;Option\&lt;Error\&gt;\&gt; right ? but this is more than sufficient for me thanks!
are there any other ways which you could think off? 
It actually gets you `Vec&lt;Error&gt;`. What `filter_map` does is it takes an iterator giving `Option&lt;T&gt;` and produces an iterator of the unwrapped `T`s.
http://arewegameyet.com/
ah I skipped the \`\`'filter\_map'; I assumed it was 'map' ! thank you !
Because when you iterate over an array, you get references, not values. You're then trying to compare a reference to a non-reference. Do what it says and replace `5` with `&amp;5`.
Not that I know of 
I believe they have an API called IOKit. Not sure what devices it supports but it would be a good place to start. 
Back before the iPhone was a thing, [libgpod](http://gtkpod.org/libgpod/) could read and write music to iPods. Looking at their homepage now, I see "There's also preliminary support for the iPhone and the iPod Touch but they must be jailbroken to work." but pretty much all the links on the page are dead, so that's not promising.
It should be noted that there is actually a difference between optimizing for size, and optimizing for speed. Rust tends to optimize for speed, not size. Still, the two are loosely correlated, because fewer functions means less cache misses while calling functions. But consider this. Suppose you had one, giant generic datastructure that basically ran your whole program, so that its performance is dominated by the performance of the data structure. Let's call this data structure Big\&lt;T\&gt;. Now suppose you had a command\-line option to use either Big\&lt;u32\&gt; or Big\&lt;u64\&gt;. The rust compiler will happily duplicate the functions involved while monomorphising them. Meaning, you have roughly *doubled* the size of your executable. However, your program will generally stick to one half or the other during runtime. Thus, you would see almost no performance loss. Equating size and speed, while roughly true, is nuanced. Counting monomorphisation as true "bloat" is not quite correct \- each individual function called will be very streamlined for its specialized types. So where *should* we care about this extra bloat? We should care when we sacrifice performance for generic code, directly \- THAT is the true concern. So nothing is wrong with having a Big\&lt;u8\&gt;, Big\&lt;u16\&gt;, Big\&lt;u32\&gt;, and a Big\&lt;u64\&gt; at the same time. But is WILL be a problem if you spend a lot of time in, say, Big::do\_bit\_twiddling\(\) trying to keep your code generic over all four sizes. This is where specialization comes to the rescue \- it allows you to have your cake and eat it too, by overriding monomorphisation for performance gains without sacrificing the generic power of your code.
Wouldn't it have to be in hyper? That's where the deref is, so unless you introduce extra copies (which I think would defeat the point of using mmap), that's where the blocking call needs to wrap. I said "optionally" (maybe I should word it more strongly: "selectively") call `blocking`, because I agree you wouldn't want to it for everything. I'd only want to do it for chunks that actually represent mmaped regions. So I think `Payload::Data` would need to be a trait or something that has more than just `AsRef&lt;[u8]&gt;`. iirc, people have asked for a richer chunk type for other reasons. Someone wanted to use `sendfile`, which has a similar performance goal to `mmap` and a similar need for `blocking` but a somewhat different set of caveats: * `sendfile` can't trivially work with TLS. (I think I said once before it can't at all, and someone pointed out that Linux recently got some in-kernel TLS write magic for this purpose.) * `sendfile` is pretty platform-specific iirc (even more so with the TLS stuff I just mentioned). * `mmap` can cause your program to crash with `SIGBUS` if the file you're serving shrinks while you're reading it. (In the program I'm working on now, I have a pretty strong guarantee nothing else touches my files.) * `mmap` can exhaust your address space if you want to send large files on a 32-bit machine. (In my case, I have a pretty strong guarantee each file is small.)
Ooo what's the 3ds project?
Thanks for the invitation! My work hours available for this are pretty limited and probably don't overlap well with anyone else's, though, so I don't think I can do real-time communication so well. In particular, my current main Rust project (moonfire-nvr) I only work on outside standard work hours (blah blah agreement for my employer to release the copyright to me), and most of the rest of my time goes to my two little kids and sleeping. A general-purpose mmap is also somewhat harder than one that suits my needs (as I mentioned in my other reply), maybe too ambitious for me right now.
[Here](https://play.rust-lang.org/?gist=20a6d4a7c655f5b70bd4790a32a75c19&amp;version=stable&amp;mode=debug) is an example that uses fold. It's a little longer, but it grabs both the errors and the successes. [This](https://play.rust-lang.org/?gist=480a13a073970f8117ddd84f42b45755&amp;version=stable&amp;mode=debug) is the error-only version using `fold` instead of `filter_map`.
I really hope you do. That would be very interesting to see. What did you use to compile this to native code? Is it compatible with Windows too?
Ah thank you ! That’s what i was trying to achieve! 
Microsoft has a project called [CoreRT](https://github.com/dotnet/corert) that compiles C# AOT. So far producing libraries *only* works on Windows (and presumably macOS as well, but I haven't tested that). Some simple static libraries can also be compiled on Linux but it fails the linking step in my case.
Can I reuse trait bounds? It seems very annoying to repeat \&lt;T: Zero \+ One \+ Add \+ Sub \+ ...\&gt;, for example
In case you haven't seen it, /u/nikomatsakis also has a flash card software: https://github.com/nikomatsakis/mathema
😂
Continuing contributing to the Rust Stellar SDK. Did some cool deserialization with serde today: https://github.com/kbacha/stellar-sdk/pull/208
There's also https://docs.rs/sysinfo/.
&gt; It is worth remarking that zero-cost does not mean zero-overhead. The meaning of zero-cost is that there is no way of doing the exact same thing in such a way that is faster/better I don't think this is accurate, or at least, it's not a very useful definition. Under that definition, one can make a reasonable argument that Python or Bash (or literally anything else) are languages with zero-cost abstractions: there's no way to get their exact combinations of trade-offs in a faster/better way. If everything is "zero-cost", then there's no point talking about it. "Zero-cost" as a phrase is a bit squishy, but I think one key thing here is that "cost" can have multiple dimensions (code-size, time to compile, runtime performance), and an abstraction that's zero-overhead in one might not be in others. Types like `Vec&lt;T&gt;` and so on are typically zero-cost in the sense of "one can't hand write a monomorphic contiguous storage type that will have better runtime performance", but they likely do impose penalties on other dimensions.
Electron is no longer the only solution, especially on Rust. [web-view](https://github.com/Boscop/web-view) might not be "production ready" but it does work and aims to be leaner then Electron.
This is great stuff! Looking forward to some nice gainz
Note that Gradle does not manage Java toolchains, so you have to install Java manually for ./gradlew build to work. And installing Java is more or less equivalent to the step 3 from the post. Step 6 can be automated today by using toolchain file: https://github.com/rust-lang-nursery/rustup.rs#the-toolchain-file. 
I am not saying that Java land is all pink... There's several reasons why gradle can't install the jdk and none of them apply to rust. Rust can remove this barrier, that's what matters. The toolchain file has no integration with cargo sadly so you ll still have to run rustup. 
Yea, we need Rust on Amiga, Atari, etc. too. But I grew up writing games for the TI-68k calculators (because my parents didn't allow me to have a gaming console) so that's where my heart is.. Unfortunately the TI calc scene is even more dead than the demoscene these days :/ But I still have my two TI-Voyage 200 calcs, and I still use them often instead of Wolframalpha..
[libimobiledevice](https://www.libimobiledevice.org/)
So cargo would install and manage rustup for you ? How do you then get cargo?
Through the wrapper. The whole idea is that only one person needs cargo, to generate the wrapper. 
Hi here, I'm trying to install clippy and got this error (both the version I want and the latest): error[E0463]: can't find crate for `rustc_const_eval` --&gt; C:\Users\Geob\.cargo\registry\src\github.com-1ecc6299db9ec823\clippy_lints-0.0.179\src\lib.rs:40:1 | 40 | extern crate rustc_const_eval; | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't find crate 
If you are working with the num traits, [num::Num](https://docs.rs/num/0.1.42/num/trait.Num.html) or [num::PrimInt](https://docs.rs/num/0.1.42/num/trait.PrimInt.html) might work as a supertrait.
So you want to generate a script or scripts that are small enough to check into source control, but will work on every platform with zero external dependencies? Good luck! Merging at least some of rustup's (and xargo's) functionality into cargo has already been brought up a few times as a good path forward, and I agree with that, but I think you'll always need at least one binary dependency to "bootstrap" the portability of whatever is in source control.
Are you on you period? Seiri (生理) means that. @OP
The main issue I have with web-view though ... &gt; It uses Cocoa/WebKit on macOS, gtk-webkit2 on Linux and MSHTML (IE10/11) on Windows. That's a big deal. Especially for Windows. Do you really want to have to target IE 11?
The term "zero-cost abstractions" comes from the design of many C++ features, and it has a specific meaning. Precisely, it means that for a feature to be considered "zero-cost", it must meet both of the following criteria: 1) If you don't use the language feature, you don't pay any cost for it existing in the language. 2) If you do use the language feature, you could not have manually hand coded the same thing any better if you were not to use the feature. #1 is what discounts things like Python and Bash and Java. Garbage collectors are not zero-cost. A GC language will have the GC running and introducing overhead no matter whether you want to use it or not. Any language that requires a fancy runtime environment is not zero-cost, because you always pay costs for the features that the language provides, no matter if you actually use those features or not. Same with exceptions in C++, those are not zero-cost. Their mere existence requires extra bloat in your executables, regardless of how much you use them. You have to completely disable support for them with a compiler option if you don't want their overhead. On the other hand, something like Rust enums is a zero-cost abstraction. For your enum types, the compiler can generate an optimal binary representation and code to access them. A good optimizing compiler should be able to generate the same or better code as if you were to try to code the same thing in assembly yourself (or try to emulate the same behaviour using other language features). (#2) If you never use any enums in your code, then no code related to enums is ever present in your final program. It's like if the language didn't support them in the first place. (#1) The same is true for Rust Futures, Iterators, ...
How much of that size reduction was really unwind tables? Does the tool associate them with their functions or are they separate symbols?
seiri (整理) also means sorting or arrangement. Given the choice of managing music this makes more sense. I get that because it's not written in kanji, but romanji, the meaning can be ambiguous, but maybe double check they chose a more contextual choice of words.
I'm going to assume the name refers to [整理](https://jisho.org/word/%E6%95%B4%E7%90%86) (sorting; arrangement; organization; putting in order; adjustment; regulation​). Seems much more fitting.
&gt;So you want to generate a script or scripts that are small enough to check into source control, but will work on every platform with zero external dependencies? Good luck! TBH this part is fairly straight forward, gradle wrapper and rustup are doing it already. 
Nice work on rustbud!! I am going to start working on cargo\-wrapper right now to prove you wrong! :\) I guess your tool has a different purpose though, you try to solve a problem of a single developer and how he manage different project. I am trying to solve that AND the problem of multiple developers working on a single project. I'll definitely explore rustbud and steal all the good ideas :\)
 my_iter.map(|r| match r { Ok(ok) =&gt; Err(ok), Err(err) =&gt; Ok(err), }).collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()
Thanks for the writeup. Have you considered using a trait for `ArrayData` with an associated type instead? The pattern-matching would go away and be replaced by type inference. That's the pattern I am using for my columnar datastore. pub trait ArrayData{ type Item; } impl ArrayData for Vec&lt;u8&gt;{ type Item = u8; } struct DataFrame { columns:Vec&lt;Box&lt;ArrayData&gt;&gt; } 
Ok, so the function `WebAssembly.instantiateStreaming` returns a promise. Promises in JS are like futures in rust, to use them you need to do one of three things. const wasm = await WebAssembly.instantiateStreaming(fetch('rust.wasm', {}).then(obj =&gt; obj.instance.exports); In this line you are using the await keyword to wait for the promise to resolve and assign the result to the variable `wasm`. The other option you have is to use the `.then` method to invoke your `testMe` function. let wasm; const wasm = WebAssembly.instantiateStreaming(fetch('rust.wasm'), {}) .then(obj =&gt; { wasm = obj.instance.exports; testMe(); }); In this version you are waiting for the promise to resolve and storing the result in a global variable. Since wasm will be `undefined` until the promise resolves, you would call the entry point from inside the `.then` call. const wasm = WebAssembly.instantiateStreaming(fetch('rust.wasm'), {}) .then(obj =&gt; obj.instance.exports); async function testMe() { wasm.then(mod =&gt; { outputValue = mod.rust_function_name(inputValue); console.log(outputValue); document.getElementById("entryID").value = outputValue; }); }
Please do! :)
&gt; object-based or object-oriented one? Is that something we can get with Rust? I thought it was one of the things that aren't really supported(OOP with inheritance), instead we're meant to compose structs together afaik? Sometimes that's ok other times it'd be nice to extend a struct with some new fields rather than have the new fields or base fields in a child struct(or I guess you could have both groups of fields wrapped in a struct having to access both of them through a parent field name...). [ncollide](http://ncollide.org/) probably does what you want in regards to 3d geometric shapes and polys. There is an example that ties it to a renderer too I think in the docs. There is also the rust wrapper for SDL which is pretty easy to handle basic rendering with, supports Vulkan and OpenGL(can optionally go more low level and do your own opengl calls) rendering. Vulkano is great for writing Vulkan stuff with, they have some examples for rendering meshes and handling textures.
&gt; For GPU offloading, I'm not aware of anything for Rust. ArrayFire perhaps? It's a Rust wrapper to a C++ project that does JIT kernels, performs pretty well.
Hi Alex, very cool implementation. I have some trouble using the interface for the Text type. Is it possible you could supply an example of the usage of the Text crdt?
&gt;so you ll still have to run rustup. Not really I think? If you have a `rust-toolchain` in your repository, then the workflow for the new developer is ``` 1. Install rust from https://rustup.rs/ 2. Install git 3. git clone your-project &amp;&amp; cd your project 4. cargo build ``` Because `cargo` binary is in fact rustup shim, it will download the necessary toolchain automatically. 
Oh that looks nice. It didn't exist when I started on my procfs crate, and we appear to have slightly different philosophies -- I'm trying to provide compatibility with the `nix` crate, but sysinfo appears to be trying to be cross-platform. tabin-procfs is definitely just a thin wrapper around the `/procfs` fs, so it exposes a bit more info, but it's also more annoying to work with. If `sysinfo` had existed when I'd started I definitely would have just used that, and I still *might* move over.
Sodiumoxide was one of the many "high level" bindings I abandoned for their -sys versions. The base libsodium library is very easy to use and there is enough reference and documentation of it out there that any question about its use can be answered easily. Higher level abstractions create their own API which means most existing documentation becomes useless and you are at the mercy of whatever is on docs.rs One thing that got on my nerves a whole lot was their renaming of constants. 
Arguably, tuples are way more common in Python than in Rust. Most of the time you'll probably want to use a struct.
Arrayfire is great. You can use and switch multiple GPUs at runtime and have your code run on CUDA, OPENCL or CPU
Thanks for the suggestion. That works for `ListArrayData&lt;T&gt;` and `BufferArrayData&lt;T&gt;` but cannot be implemented for `StructArrayData` because it can contain multiple `ArrayData` instances with different types.
I've done your global variable recommendation. The promise is now fulfilled. I couldn't do a let and then a const declaration, because it complained about redeclaration, so I just have the global const wasm line: const wasm = WebAssembly.instantiateStreaming(fetch('worthItFunctions.wasm'), {}) .then(obj =&gt; obj.instance.exports) .catch(e =&gt; console.error(e)); Now the issue is when the testMe\(\) function is called, inside the .then\(mod =\&gt; {} closure, I have: const { rust_function_name } = wasm; But the console tells me that: TypeError: rust_function_name is not a function And doing a console.log\(\) inside of the the .then\(\) doesn't print anything.
I thought ArrayFire was good, but its performance is pretty bad unless you can manage to stick everything into one big Array.
You should also take a look at [ndarray](https://docs.rs/ndarray/0.11.2/ndarray/). Its focus differs a bit (multi dimensional indices) but the way it uses generics to handle the backing storage could be interesting for your project.
The reason is that you are still not waiting for the promise to resolve. either you need to have wasm be a `let` assignment that is `undefined` and resolve it in the `.then` block like this. let wasm; WebAssembly.instantiateStreaming(fetch('worthItFunctions.wasm'), {}) .then(obj =&gt; { wasm = obj.instance.exports; testMe(); }) .catch(e =&gt; console.error(e)) or you need to await the promise that is returned by `instantiateStreaming` like this const wasm = await WebAssembly.instantiateStreaming(fetch('worthItFunctions.wasm'), {}) .then(obj =&gt; obj.instance.exports) .catch(e =&gt; console.error(e)); With the second option, I am not sure how await operates in the global scope so that might be the problem. It might make sense to wrap that block in its own function like this. let cached_wasm; async function getWasm() { if (!cached_wasm) { cached_wasm = await WebAssembly.instantiateStreaming(fetch('worthItFunctions.wasm'), {}) .then(obj =&gt; obj.instance.exports); } return cached_wasm; } 
So something like this? https://github.com/sile/hls_wasm 
Not a fan of wrapper scripts at all. In contrast to Java (which is NOT installed or managed by Gradle) the installation of Rust through rustup includes _everything_ that is needed, including cargo. And as there's no pom.xml vs. gradlefile vs. sbt file situation but simply a cargo file I think the situation is just fine. However there could be some smarts included to have cargo trigger a default-toolchain install if nothing is available and send out a warning if a new stable is available since x-time.
I've been playing around with procedural macros myself, and I was wondering about the relationship between `proc_macro` and `proc_macro2`. (My code is 95% `proc_macro` types with a few `proc_macro2` types sprinkled in in places that I need additional functionality. Seemed very fishy!) Just explaining "your custom derive function takes a `proc_macro::TokenStream` and returns a `proc_macro2::TokenStream` is really helpful!
I wrote up a blog post and posted it to Reddit this morning: https://www.reddit.com/r/rust/comments/8gy45t/refactoring_apache_arrow_to_use_traits_and/
Take a look at Gluon (on mobile, sorry for no link). It's like Dyon in that it is suited to fit Rust well, but it is much more like Haskell in syntax and functionality. , It runs in its own thread and has great interoperability with Rust data types and channels. 
Glad you found my post entertaining :) You mentioned that some procedural macro things had changed recently, could you elaborate on that?
Yeah, await has to be in an async function, it can't be declared globally, so your getWasm\(\) function is the correct idea. I forgot to say that I'm using an event listener to trigger function calls, which is why the global scope is what I'm after. This is what I currently have: let cached_wasm; async function getWasm() { if (!cached_wasm) { cached_wasm = await WebAssembly.instantiateStreaming(fetch('rust.wasm'), {}) .then(obj =&gt; obj.instance.exports); } return cached_wasm; } async function testMe() { cached_wasm = await getWasm() cached_wasm.then(mod =&gt; { const { rust_function_name } = await cached_wasm; outputValue = rust_function_name(inputValue); document.getElementById("entryID").value = outputValue; }); } I get an error of: SyntaxError: await is only valid in async functions and async generators In regards to: const { rust_function_name } = await cached_wasm; If I remove the await there, I get: Promise { &lt;state&gt;: "pending" } I'm not sure if it's correct to call getWasm\(\) as I've done either.
so, you want to pretend that `cached_wasm` doesn't exist but instead use `getWasm` as an accessor. In `testMe` change cached_wasm = await getWasm(); to let wasm = await getWasm(); or const { rust_function_name } await getWasm(); This would only download the module when your event fired so you may want to call `getWasm()` in a `window.load` listener to start the process eagerly. 
Okay, I changed it to be: const { rust_function_name } = await getWasm(); It tells me that: SyntaxError: await is only valid in async functions and async generators What do I have to change to get async working in the .then\(\) closure? And the window.load listener is exactly what I'll do to get it loaded.
Check the `gtk` and related crates for an example how it can be managed. They're basically doing exactly what you're saying: features like "v3_10", "v3_12", etc for opt-in of the API of a newer version, and a build.rs that is checking for the correct version of the C library during build-time.
is `trustMe` still marked as async?
Yep
Not much projects are using it yet so if you have feedbacks and/or new stuff you'd like to ask, don't hesitate! :)
I'm not sure about best practices, but here's the way \`inkwell\` has gone about "solving" \(read: working around\) this problem: \* versioned features \(as you mentioned\) \* master branch which is unintended to be used directly, and version branches based on master with the only additional commit setting the default features to that version feature \+ setting the \-sys version requirement. Pro: \* This is nice because each branch is a \(highly unlikely to conflict\) rebase away from getting the latest changes. Maintenance across versions for the author is pretty easy. Con: \* If you want to stick to semver for your crate, you're probably stuck publishing with only the latest feature version enabled, and have to require users to pull your branch from github in their Cargo.toml for earlier versions \(Though I suppose the \[semver metadata\]\(https://semver.org/#spec\-item\-10\) could possibly be used effectively here \- I wonder if Cargo supports this?\) I think one solution would be for Cargo to allow features to specify a dependency's version. Or at least that is \*a\* solution that makes this problem easier, because then you could keep everyone on just one single branch/crate and let the user specify a version feature. TL;DR Features are definitely the way to go for this use case; but that's only the beginning of the problem as it'd be great to have some support from Cargo.
I have \(in the async testMe\(\) function\): let wasm = getWasm(); input = wasm.rust_function_name(inputValue); It says that it's pending if I run testMe\(\). If i use the previous .then\(\) method, I get: TypeError: cached_wasm is undefined And I did add a window load listener to execute getWasm\(\). I verified that it ran with a console.log\(\).
in the async testMe function you need to await the result of getWasm since it is also async.
&gt;As for speed, I think it's about on\-par with rustc for total compilation time \(while doing less, mostly because there's not a lot of optimization effort put in yet\) Oh, I didn't realize that in addition to being written in C\+\+ that transpiles into C \&gt; mrustc works by compiling assumed\-valid rust code \(i.e. without borrow checking\) into a high\-level assembly \(currently using C ...\)
Something you may be missing is that gradle wrapper, and thus presumably cargo wrapper, isn't installing globally, rather it installs to a sub-directory under the project. Effectively it looks like this: 1) clone repo, end up with source and a couple wrapper scripts (plus some helpers in a sub-directory, all of this is part of the repo) 2) run wrapper script. Script checks its configured version of the build tool to see if thats available (either installed the normal way or managed by the wrapper from a previous run), and if so uses it. If the configured version isn't available it downloads it into a sub-directory that's excluded from version control, and then invokes it. The important thing is that each developer after the first one doesn't need to download or have a particular version of the tooling available, the wrapper script deals with all of that. As a bonus it also insures everyone is using the exact same version of the build tool. Ideally the build tool should be wrapper aware as well, and if it sees that a wrapper config exists it should check if its version matches the one configured and if not delegate to the wrapper to continue running so that the proper version is used.
Just reviewing the .then\(\) method: cached_wasm.then(mod =&gt; { const { rust_function_name } = await cached_wasm; outputValue = rust_function_name(inputValue); }); The await cached\_wasm line yields: SyntaxError: await is only valid in async functions and async generators Is there something to change to allow await to be used in the .then\(\) closure?
[removed]
Take a look at `cassowary` and `limn-layout`
Yep, there's several pluggable GUI libraries that do this. The `conrod` crate is the premier example I know of in Rust, though there may be others. `conrod` has several different drawing backends, and [defines an API](https://docs.rs/conrod/0.59.1/conrod/render/index.html) where the GUI library hands the backend a list of drawing commands to be drawn -- rectangles, meshes, images, text, etc.
cached_wasm.then is not an async function so you can't await inside of it, maybe if you put async before mod it would work but if you are using this inside of an event handler it isn't going to help. Using your original code, this would probably be the best approach [gist](https://gist.github.com/FreeMasen/d1e3db8087c66be500037f14aea4593a) I also included a typescript version that is manually performing what the async/await keywords do and includes the type annotations.
There's also [`yoga-rs`](https://github.com/bschwind/yoga-rs/blob/master/README.md) which is an implementation of the Flexbox algorithm. You give it a tree of Nodes and it gives you back positioned rectangles. 
Wasn't this a promise of Glade? Although it represented its elements in XML. https://glade.gnome.org/
I didn't realize you could write your own backend for conrod! I think I'll give this a try first and if I need to, look at yoga or cassowary. Cheers!
Okay, but does that play well with documentation (preferably via docs.rs)? I guess if you by default have a very old API version (3.4), much of the API will not be visible via docs.rs, right?
Thanks, I just read it. I personally don't have hard opinions on it - I have not looked at the other Arrow implementations (C++ for example ). I don't think the code repetition is needed for the operations, adding two arrays in your example, it can be abstracted away - in the gist I posted there is an example exactly for addition that works for all numbers, more precisely for all types that implement std.ops.Add. As your new model, it's generic and unfortunately can't be inferred because the operand types are erased. The inference should work better in your new approach with the statically known arrays. One downside I see is that now you have to implement each ops two times, once for the generic case, once for the dynamically dispatched case. I am afk for the weekend but may come with longer reply Tuesday. 
I’m curious where the were is being thrown. If you put `debugger` on the first line of `testMe` what does the call stack look?
I am also _starting_ to implement layout in [xi-win-ui](https://github.com/google/xi-win/tree/master/xi-win-ui), based on Flutter. However, it's super early, and at the moment tied to winapi. The Flutter ideas are good, the layout protocol is super-efficient and pretty flexible. So not suggesting you use it, but maybe a source of ideas.
Wrong sub. You want /r/playrust.
Yes, only v0.2.1
It only lists testMe
&gt; Ranges like `a..b` [...] exclusive at the top Thank you, although you've kind of shifted my question :D What's the reasoning that ranges in Rust (and Python!) *are* exclusive at the top, or is that too technical to go into? &gt; standard library [...] bad idea Cheers for addressing this as well. Rust so far seems to be quite a nice language, bar `println!` being marginally annoying to type. It's quite a different experience to Python, not that that's necessarily bad.
&gt; Why is the gen_range method "inclusive on the lower bound but exclusive on the upper bound", as they mention? I can't speak to the motivations of the `rand` designers, but half-open ranges are extremely common and have some nice properties, e.g. the number of elements in `[a, b)` is simply `b - a` - no need to adjust by 1. Need to do something 100 times? `for i in 0..100 { ... }`. &gt; It just feels uncomfortable/strange, and non-intuitive to read I agree with that given `gen_range(1, 101)`. I think `gen_range(1, 100 + 1)` or `gen_range(0, 100) + 1` demonstrate the desired effect more clearly. &gt; I'd also be interested in a way to use an inclusive bound for the maximum number if that's possible I think with `rand` you always have to use a `+1` method but I'd have to go through their methods again. For Rust ranges you can use the inclusive range syntax: `1..=100`. &gt; Also, is there a reason why Rust currently requires a crate for the random library, instead of it being built-in? Coming from Python where I barely ever need to use pip, the whole cargo system feels foreign to me. Python is very much "batteries included" while Rust is more "batteries easily obtained". There are tradeoffs to each approach, naturally, but keeping the Rust standard library small helps with maintenance and avoids issues like "we have to keep `urllib`/`urllib2` around for compatibility but, really, just use `requests`". That said, `rand` is in the Rust lang nursery, which means it's eligible to be moved into the Rust standard library eventually. IIRC it'll take an RFC to move it into Rust proper and it'll take an RFC to move it to the "deprecated" state where it'll be maintained but no longer considered for inclusion into Rust.
That should not be possible unless you are calling testMe in the global scope.
Well, thank you for the detailed post. You've certainly added some perspective to the logic behind it I hadn't considered. And thank you for the `gen_range(0, 100) + 1` example :) I've turned a little into a question-babbler at this point, but I never found anything about this from googling. I see the rand crate pulls in fuchsia-zircon among other things - this is Google's Fushsia kernel, right? I'm a little curious to why rand requires it, though I can make a guess that it's involved in the generation of the random number somehow.
It's being executed by an event handler: .addEventListener("keyup", testMe);
Adding a comment here to avoid derailing the issue above. I worry about this part of the philosophy: &gt; to not add primitives and functionality that hasn't been proven secure (or isn't part of the cryptographic literature). An example of this is the key-conversion functionality between curve25519 and ed25519 keys I feel like this inevitably makes the crate feel _incomplete_. Obviously I appreciate being a little bit conservative in implementing crypto primitives, since that's kind of the whole point of NaCl/libsodium in the first place. But second guessing the libsodium devs -- the folks that we're trusting anyway to maintain all this very sensitive implementation code -- seems like it doesn't provide a ton of extra benefit.
Could meet in the middle and hide those behind a feature flag. Not available by default, but around if you make the choice to do it. 
It has a conditional dependency on that crate: [target.'cfg(target_os = "fuchsia")'.dependencies] fuchsia-zircon = { version = "0.3.2", optional = true } This is so that if you are compiling a Rust project to run on the Fuchsia OS with the Zircon kernel then you can use the crate to generate random numbers. There are a number of other conditional dependencies for other OS's. I presume these are used for getting OS-specific entropy and possibly for calling into OS-native random number generation.
When libsodium was young (and sodiumoxide was first written) it was basically a version of NaCl that could be built with ordinary build tools, and could be built as a dynamic library. It had also added a signature primitive (ed25519) that Dan Bernstein had promised would be integrated into the next release of NaCl (a promise that he technically hasn't broken, since he never released another version of NaCl). The code for ed25519 was Bernsteins own code. Since then libsodium has grown immensely, accumulated a lot of useful functionality, but in the process it has also gained some primitives that are easy to do from an implementation perspective, such as the key conversion, but might not be cryptographically secure. I've had a couple of feature requests for the key conversion functionality, but to be honest not one of the requesters had a use-case that couldn't be solved by using separate keys for curve25519 and ed25519 without taking any unnecessary cryptographic risks (also the keys are tiny compared to basically everything else in modern computing, so overhead isn't really an issue here).
Oh, okay then. Thanks!
I haven't forgotten about this. I still really want to try it. I'm thinking of seeing if I can stand on the shoulders of [cargo-script](https://github.com/DanielKeep/cargo-script). Now I just have to figure out how Jupyter kernels work and find sometime to write it. 
Thanks for your work on this, dnaq. I'm using sodiumoxide (although an older version) for my project, Turtl, and it made things much easier. I hope the project finds the maintainer it needs. 
Can you create a gist or repo with your client code? I am pretty baffled at this point.
Nice, I'm glad you wrote this up. It's great to see how the design compares to my own column-based dataframe. I hope to see a lot more of these articles and more discussion to see what will shake out.
Dear ImGui is a specific implementation of the concept of an Immediate Mode GUI (IMGUI). Certainly the most popular, but not the only one.
https://crates.io/crates/rustplotlib
The semantics are that the whole object is literally copied around in memory, but the compiler is free to do less work than that, if it can prove the result is the same. (For example, if a function gets inlined, the moves for passing its arguments will disappear.)
Yeah sure. The library itself did go by IMGUI previously though. Definitely a great library. I think there are rust bindings as well. 
I don't think you can deal with sub-slices without borrows, but you actually can take a field from an object by value and then put it back. As long as you don't use the object in its "partially initialized" state, the compiler is fine with it, as in [this playground example](https://play.rust-lang.org/?gist=ccfe870c5bba6cb2fdc72466098c3b8d&amp;version=stable&amp;mode=debug). (Note that the object can't implement `Drop`, because it wouldn't be safe for its destructor to be called in that state, and an unwinding panic could call destructors at any time.)
Yeah, this works really well in purescript, one of my favorite additions to it over Haskell. ``` getName :: forall a. { name :: String | a } -&gt; String getName { name: x } = x ``` Says that we can take anything with a field 'name' (and maybe other fields) and get a String
I think of it as related to zero-indexing. If you write `vec![xyz; 10]` then you can iterate over it `0..10`, no off-by-one error. 
I was considering trying to write a Rust GUI library based on Flutter concepts at some point. It would be interesting to combine it with the ideas in this post about separating layout and rendering - something like taking a flutter layout and turning it into rectangles.
Of all people that have discussed this issue with me you are the first to give a concrete use-case. I haven't looked into how keybase works, so I don't know if this is of any help at all, but I would probably add the curve25519 key to the public identity. So that the actual identity is something like (PK_sign | [PK_enc | other parts of the identity]) where PK_sign is a public ed25519 key, PK_enc is a public curve25519 key and [contents] is a statement signed with the secret key SK_sign.
&gt; The error in the playground link you gave suggested that the Drop trait makes the value in the struct immovable What's actually happening is that the `Drop` trait makes it illegal to leave the value in a "partially initialized" state. Normally such states don't come up, but that interesting line `f.0 = by_move(f.0)` does create such a state. While the function `by_move` is running, `f` has no valid `.0` member. The interesting part is that the compiler _sometimes_ allows you to get away with this. If the compiler knows that you never look at the `.0` member while it's uninitialized (looking at other members is fine), then there's no problem. But calling any function that takes `&amp;f` or `&amp;mut f` would certainly violate that rule, and because `drop` takes an `&amp;mut self` argument, having a `Drop` implementation at all means that you're always at risk of looking at the bad member. &gt; This Drop trait is not a very general thing that many objects have then? `Drop` is pretty common. `String` for example implements `Drop`, because it owns some memory that it needs to free. In general all the standard collections will implement `Drop`, as well as any type that contains a collection anywhere inside of it. But like we clarified above, `Drop` isn't very limiting in practice. `String`'s fields are all private, so you're not allowed to mess with them anyway. (There limitation I can think of around `Drop` is that a `Drop` type can't be `Copy`.)
I could use some help adding a bit of type safety :) My code would be https://play.rust-lang.org/?gist=a3fe68136298ec931cde5abfd56b9792&amp;version=undefined&amp;mode=undefined I have a struct `LinesIter`, that just encapsulates an iterator that returns `(usize, &amp;str)`, so basically the result of `&amp;Vec&lt;String&gt;.enumerate`. Works. Now, all the methods I'm calling on `LinesIter` now assume that the comment lines (`String`s starting with `#` or `$`) have been filtered out. This isn't hard to do, but I keep forgetting to do it, which results in weird test errors. Also, I want to provide a convenience function, so I can call something like `&amp;Vec&lt;String.enumerate().remove_comments()` and call the methods on the results of this, rather than `LinesIter`. But I can't wrap my head around how to define the type, the function and how to implement that. The attempt I've linked seems to fail because I can't name the return type of the call to `.filter`, but I can't get rid of the type parameter `I` somehow. Thanks for any pointers :)
[removed]
Can you copy and paste the full error message from the console? Reading through the post history it looks like it is related to a promise rejection. 
Can you copy and paste the full error message from the console? Reading through the post history it looks like it is related to a promise rejection. 
If you _really_ need to do it via docs.rs, tell it to build with all features in `Cargo.toml` with: [package.metadata.docs.rs] all-features = true
It's very odd. It's not actually throwing an error. But, if I put a console.log\(\) in the first line of testMe\(\), it'll print to the console. If I put it anywhere after that first line, it doesn't print at all. If I do: const wasm = await getWasm(); console.log('wasm:' + wasm); Nothing happens. If I remove the await: const wasm = getWasm(); console.log('wasm:' + wasm); I get: wasm:[object Promise] So it's something about the await that's causing everything to hang.
Does this really work in all cases? It would seems like the trait object *forces* a covariance of sorts, but that wouldn't be sound. If it is sound, then I'd guess that certain methods which write to the mutable reference with a non-`: 'static` data also still weren't. (It is for these sorts of writes that mutable references are invariant in the first place.) All that speculation aside, sounds like more motivation for existential lifetimes.
I'll give that a try. Does eval() work asynchronously? That would definitely help things.
That’s because the getWasm is failing, so all code stops. What does the error say on the console? One thing to check is that the fetch isn’t failing, on the network tab of your browser dev tools is it 404ing? Another thing that might be happening is your import object may need to have definitions assigned to it. Post the error and that will get us closer
&gt; invariant I never managed to learn what invariant, variant, covariant, ... even mean. The wikipedia and previous posts have been completely unhelpful here. There are even `Vec&lt;T&gt;` tests for covariance in the std library and I don't even know what these tests actually do: https://github.com/rust-lang/rust/blob/master/src/liballoc/tests/vec.rs#L747 Is there a resource that explains this "for dummies" ?
The lifetime creep that this blog tries to help deal with is one of my major problems with this language. I don't like how if I don'f want to use Copyinv od teference counting in certain situations I end up having to write X&lt;'a, 'b, 'c&gt; everywhere in types that contain my abstraction. It makes my program refactoring.a pain in these situations.
I don’t know about resources for variance specifically, but this coursera course does a grear job explaining this and other concepts of programming languages: https://www.coursera.org/learn/programming-languages. I highly recommend it! 
I just heard about `try!` being up for deprecation. :-( I suppose I can create a trivial macro around `?` for when I want it, but `try` is due to be a keyword so I'll need a different name. Thought I'd ask if anybody had any suggestions?
If I add: .catch(e =&gt; console.error(e)) to the end of the exports in getWasm\(\), it gives us: TypeError: wasm is undefined in reference to calling the rust function in testMe\(\). On the network tab it actually shows nothing, which is perplexing.
Excellent discussion of the problem. This issue was the first real stumbling block I hit when learning rust, and unlike most of the other initial difficulties of learning a new language, refuses to go away. Lifetime proliferation is a thorny problem that makes it very difficult to design good API boundaries, particularly for libraries that deal with foreign resources. The workarounds described here can save you in some cases, but it's luck of the draw which patterns will suit any particular given use case you might have, and some are more resistant to workarounds than others. By this point I'm somewhat infamous for constantly banging on about self-referential structs, so I'll refrain from doing so again, except to say that this post describes the motivating problem that they try to solve and why they would be useful. A self-ref struct has the capability to encapsulate, and thereby erase, a lifetime parameter, preventing it from infecting your entire API and the API of your consumers. This is why I believe it to be an important feature.
Here's [a link](https://www.youtube.com/watch?v=fI4RG_uq-WU).
It complains about the return await: SyntaxError: await is only valid in async functions and async generators
Variance is important in languages with subtyping. Imagine these two types: Shape Rectangle (sub-type of Shape) Now, imagine I have a generic type: Foo&lt;T&gt; If `Foo&lt;Rectangle&gt;` is a sub-type of `Foo&lt;Shape&gt;`, then you can say the `Foo` is *covariant* (with respect to T). Covariant means it "varies in the same way" and is the more common case. If `Foo&lt;Shape&gt;` is a sub-type of `Foo&lt;Rectangle&gt;`, then you can say that `Foo` is *contravariant* (with respect to T). If neither is a sub-type of the other, then you can say that `Foo` is *invariant* (with respect to T). Types which only "retrieve" values (like iterators) are usually covariant (ie. you could pass an iterator over `Rectangle` where an iterator over `Shape` is expected). Types to which you can only "store" values (like sinks) are usually contravariant (ie. you could pass a `Shape` sink where a `Rectangle` sink is expected, the opposite way around from an iterator. Types to which you can both store and retrieve values (like a vec) are invariant (if you expect a `Vec&lt;Shape&gt;` you can just pass in a `Vec&lt;Rectangle&gt;` or vice versa). Now, all these examples are slightly different in rust, because it doesn't have this kind of sub-typing: the only sub-typing in rust comes about from lifetimes. However, lifetimes just complicate the explanation of variance unnecessarily. Suffice to say, references with shorter lifetimes can be sub-types of references with longer lifetimes.
I've never missed a `?` but my editor (IDEA with the IntelliJ-Rust plugin) highlights them pretty well. I can even change how they render, add borders or background colors. Compare that to `try!()` which will render like just another macro.
I don't always have the possibility of customisable/customised tool setups in my various environments, so not using them keeps me safer.
It says: ReferenceError: bytes is not defined
Sorry, change bytes to buf 
I loaded this up, pointed it at my [existing music folder](https://github.com/cetra3/rustcloud) and... nothing. Would be good to have a guide!
Oh cool, so facebook's flexbox implementation for React-Native got extracted out into it's own lib for other projects to use too :D When did this happen?
Now it's saying: TypeError: wasm.incomePerDayMaths is not a function I tried it structured and destructured, didn't play either way.
*seiri* doesn't work on existing music folders, I recommend you choose a good location for your music library, then import your files using the Automatically Add to Library feature. This is by design to a. enforce a consolidated library, and b. reduce programmatic filesystem access that could potentially fail.
Aha, I did *not* know that. Thanks for the background info! It does sound similar to my vision for `rustbud`, in that the first time a tool is run, it leaves a marker that can be checked into source-control so that future checkouts will use the same toolchain. I wouldn't mind if a toolchain-manager following the gradle-wrapper-script model gained traction in the Rust community.
This version has 2 new features that make self-referential structs a bit more pleasant to use: covariance and mapping. I'm pretty happy with the API now, and I don't think there's much further I can push it under the current language. Full details in the linked post; feel free to ask questions either here or on the linked thread.
Thanks for doing the subtle work for all of us!
Hey! Nice explanation. Personally I can never fit variance in my head for long enough to stick :) About lifetimes and refenences variance though, isn't it the other way around? You should be able to use a longer lifetime instead of a shorter one... So paradoxically, longer lifeftimes should be subtypes of shorter ones. Or am I too confused? :)
I haven't tried them, but here's a couple more options: - https://github.com/stevedonovan/flot-rs - https://github.com/coder543/dataplotlib
All very well, but it needs to be documented somewhere about appropriate usage!
Here's one option: [playground](https://play.rust-lang.org/?gist=a3fe68136298ec931cde5abfd56b9792&amp;version=undefined&amp;mode=undefined). The idea here is to be similar to iterator adapters from the standard library and to have restrictions only where they're strictly required. In my example you can call `remove_comments()` on anything, but it's only an `Iterator` if it satisfies certain properties. You can of course extend those restrictions as far as you want, e.g. to prevent calling `remove_comments()` on things that are not iterators or that do not yield the type you want.
[They are](https://doc.rust-lang.org/reference/subtyping.html): &gt; Since `'static` "lives longer" than `'a`, `&amp;'static str` is a subtype of `&amp;'a str`.
`text.chars().take(0).map(char::to_uppercase).collect::&lt;String&gt;()` or `text.chars().nth(0).to_uppercase()`
This doesn't work. Also, with `take` I will only get the first character for my output, but I want the whole string, just transform the first one.
How do you access registers in rust? 
First: Thanks! Second: Could you link me your suggested code? You linked back my version (maybe forgot to click the "Share" button?).
For this I was mainly referring to the use of `proc_macro2`: how to set up the conversion between `proc_macro::TokenStream` and `proc_macro2::TokenStream`, and using `syn::parse2` for parsing the `TokenStream`.
I think the [README](https://github.com/alexcrichton/proc-macro2) for `alexcrichton/proc-macro2` and the link in there to the [upcoming richer interface](https://github.com/rust-lang/rust/pull/40939) (which has been merged into `rust-lang/rust`) does a good job of explaining the difference :)
 text.chars().take(1).flat_map(char::to_uppercase).chain(text.chars().skip(1)).collect::&lt;String&gt;()
Whoops! Guess I was on the wrong tab or something. [Here you go](https://play.rust-lang.org/?gist=d4238322bb79bc25b9a7548e56be0f3d&amp;version=stable&amp;mode=debug). Fixed the link before too.
I feel like converting whole text to chars is suboptimal. Maybe something [like this](https://play.rust-lang.org/?gist=2241754c01bea8d38129c4bb502a0425&amp;version=stable&amp;mode=debug) would be faster: let mut result = String::with_capacity(text.len()); if let Some(ch) = text.chars().next() { for u in ch.to_uppercase() { result.push(u); } result.push_str(&amp;text[ch.len_utf8()..]); } result 
There is also a fork of sodiumoxide from maidsafe which I use because it statically links libsodium. I wonder if those projects could be merged. 
Hello! I wanted to try the [rust fast fourier transform](https://www.reddit.com/r/rust/comments/6cyq5z/announcing_rustfft_20_fast_ffts_of_any_size_in/) but it does not compile for me. I am using Intellij IDEA 2018.1 with the rust plugin and I have tried stable and nightly builds of rust (mscv) on Windows 10. Is there something wrong with my set-up? The compiler gives out a bunch of errors starting with error[E0369]: binary operation `*` cannot be applied to type `num_complex::Complex&lt;T&gt;` --&gt; C:\Users\Andrei Mihai\.cargo\registry\src\github.com-1ecc6299db9ec823\rustfft-2.0.0\src\algorithm\mixed_radix.rs:95:24 | 95 | *element = *element * twiddle; | ^^^^^^^^^^^^^^^^^^ | = note: an implementation of `std::ops::Mul` might be missing for `num_complex::Complex&lt;T&gt;`
Because Go was built from ground up to be very fast to parse. Rust with it's borrow checker, probably won't be that fast.
If you mean CPU registers, you usually either leave this to the compiler or write an (unstable, nighty-only) `asm!` part.
It's very WIP but we are working on https://crates.io/crates/plotlib
Hello! I have the following function: ``` fn render_num&lt;T: NumToA&gt;(num: T, buffer: &amp;'a mut [u8; 20]) -&gt; Font6x8&lt;'a&gt; { let n = num.numtoa(10, buffer); let text = from_utf8(&amp;buffer[..n]).unwrap(); Self { pos: (0, 0), text } } ``` and I am getting the error `wrong number of type arguments: expected 1, found 0`, highlighting T: NumToA. `num` needs to be any numeric value that implements NumToA, what is wrong with the way I have written my `render_num` function? Thanks! :)
Well, it straight up says what's wrong: you can't multiply `Complex&lt;T&gt;` with `twiddle`. Now, it is difficult to say what exactly is wrong without seeing any more code, but here is my suggestion: I see that `num_complex` has an `impl&lt;T: Clone + Num&gt; Mul&lt;Complex&lt;T&gt;&gt; for Complex&lt;T&gt;`. If both `*element` and `twiddle` are `Complex&lt;T&gt;`, this would suggest that wherever you declared type parameter `T` you forgot to add those bounds required to have arithmetic operations: `T: Num + Clone`.
Sorry, I'm mean now. The blog post's title could also be "How to make something complicated even more complicated". Is the hack `Push + 'f` even documented in The Book? I don't use Rust, but posts like this are keeping me from using it. I hope, that Rust will be more user friendly some day, because in a company everyone has to deal with the complexity of a language. One or two smart guys who can handle the complexity aren't enough.
Would you please consider going a step further and describing what fold is doing an how it works? I don't have functional programming background and realize I ought to learn folding. 
I have this implementation in my library that I stole from somewhere: https://github.com/despawnerer/truecase/blob/960e7a89058e5e599d3b4671edc64c0ad07c6670/src/lib.rs#L511 fn uppercase_first_letter(s: &amp;str) -&gt; String { let mut c = s.chars(); match c.next() { None =&gt; String::new(), Some(f) =&gt; f.to_uppercase().collect::&lt;String&gt;() + c.as_str(), } }
Does your `NumToA` happen to be generic? Then you'd write it as `T: NumToA&lt;U&gt;` for some appropriate U. On the other hand, you're missing declaration for `'a` (that is, it should be `fn render_num&lt;'a, T: NumToA&gt;`); but that gave me a different error message when I tested on the playground.
Given the wording, you seem to have discovered that a long time ago. Where is the issue you filed about it?
I have good experience with https://crates.io/crates/gnuplot for simple stuff. If things get more complicated, I also serialize the data and read it from disk with python.
NumToA ([defined here](https://github.com/mmstick/numtoa/blob/master/src/lib.rs)) is generic for T, but when I use T: NumToA&lt;T&gt;, I get this error: error[E0308]: mismatched types --&gt; src/fonts/font6x8.rs:33:29 | 33 | let _n = num.numtoa(10, buffer); | ^^ expected type parameter, found integral variable | = note: expected type `T` found type `{integer}` error: aborting due to previous error Thanks so much for your help :)
Nice catch - I've updated my comment.
Note that the post is basically code golf: the real solution would be to just bite the bullet and thread lifetimes everywhere, or to get rid of the references altogether. The syntax for trait object's lifetimes is documented here: https://doc.rust-lang.org/book/second-edition/ch19-02-advanced-lifetimes.html#inference-of-trait-object-lifetimes. As for the general "Rust too complex" issue, I think that most of Rust complexity is essential, because manual memory management is just complicated. &lt;rant&gt; If you don't need manual memory, you don't need Rust and should pick some GC high-level language with reasonable runtime, libraries and build tool, and with type system geared towards simple and correct code (sum types, no nulls, emphasis on static dispatch and minimizing mutability). There are, unfortunately, zero languages that tick all those boxes :( &lt;/rant&gt;
Well, it was reported many times by other people, no need to post it again. Like for example [#41160](https://github.com/rust-lang/rust/issues/41160) [#41831](https://github.com/rust-lang/rust/issues/41831) ( [##45126](https://github.com/rust-lang/rust/issues/45126) and [#36001](https://github.com/rust-lang/rust/issues/36001) are probably related) and recently [#50047](https://github.com/rust-lang/rust/issues/50047) I'm guilty that I didn't report the issue when I found that Option&lt;u64&gt; is returned on stack instead of in registers like in C++, I only complained on IRC, but I see that on nightly it is already fixed (but not on beta, so it is a recent change) and I'm glad that somebody did this work, thank you very much.
Hello, I know there is this site, where you can compile rust to assembly / llvm / ir and view it online, yet I am not able to find it trough google or in reddit search. Does anybody have the link?
https://play.rust-lang.org
I'm not sure what the alternative is. Using unsafe pointers? Having better refactoring tools?
&gt; Read "StableFuture" as "future when stable", not "future which is also stable". Oh, that explains a lot! I didn't know that you had to call `pin()` on it. Now it works - thanks @daboross!
&gt; I think with rand you always have to use a +1 method but I'd have to go through their methods again. For Rust ranges you can use the inclusive range syntax: 1..=100. In the upcoming 0.5 release of Rand,`gen_range` is just a convenient wrapper for `sample(Uniform::new(a, b))`. You can also use `sample(Uniform::new_inclusive(a, b))`. Alternatively, `Uniform::from(a..b)` also works. `Uniform::from(a..=b)` is not supported, probably because of the minimal Rust version required for it.
&gt; bar println! being marginally annoying to type I agree, `println!("{:?}", ...);` is quite a lot of special symbols for the most commonly used print.
For those who are not familiar with this crate: what is it?
Yeah, I've noticed this thing, too. It looks even more weird that rustc prints its version fast and then delays for some time until the last line with the LLVM version.
``` // newtype used to ensure that zero is always written to the reserved slots pub struct Reserved(usize); ``` I wonder how newtype helps here. [Source](https://github.com/japaric/embedonomicon/blame/master/src/exceptions/struct.md#L58)
Yep, a shoutout to gnuplot. The quality of those graphs is stellar and has been for decades. (10 years ago, it was basically the only tool used for producing graphs for Nature).
[removed]
I don't have an example on hand, but I can at least explain the context thing. In general, a future is expected to arrange for the the event loop to be notified when it's ready to be polled again. In futures 0.1, it was done by getting a handle to the current Task through `task::current()`, and somehow ensuring that `notify` got called at the proper time. This suffered from some discoverability problems since it wasn't obvious at all that it needed to occur, and futures that return NotReady but never arrange for notify to be called will never be polled again. `Context` makes that relationship more explicit and also provides a bit more, well, context as to where the future is running. With futures 0.2, `Context` is the "task" that you have to arrange to be notified by calling `ctx.waker().wake()`. If you're writing a future that wraps other futures, it can probably be safely ignored since the underlying io future will handle it for you.
It's not weird, it's expected :-) Loading LLVM takes time. Basically, this line is slow: https://github.com/rust-lang/rust/blob/e471c206cf472b54acee83a231560e16c439ab63/src/librustc_driver/lib.rs#L207, and what that line does is basically calling `libc::dlopen("libllvm", libc::RTLD_GLOBAL | libc::RTLD_NOW)`.
Good question. I looked it up on [crates.io](https://crates.io) and here are the docs: [https://docs.rs/rental/0.5.0/rental/](https://docs.rs/rental/0.5.0/rental/): \&gt; It can sometimes occur in the course of designing an API that it would be convenient, or even necessary, to allow fields within a struct to hold references to other fields within that same struct. Rust's concept of ownership and borrowing is powerful, but can't express such a scenario yet. \&gt; Creating such a struct manually would require unsafe code to erase lifetime parameters from the field types. Accessing the fields directly would be completely unsafe as a result. This library addresses that issue by allowing access to the internal fields only under carefully controlled circumstances, through closures that are bounded by generic lifetimes to prevent infiltration or exfiltration of any data with an incorrect lifetime. In short, while the struct internally uses unsafe code to store the fields, the interface exposed to the consumer of the struct is completely safe. The implementation of this interface is subtle and verbose, hence the macro to automate the process. \&gt; The API of this crate consists of the [rental](https://docs.rs/rental/0.5.0/rental/macro.rental.html) macro that generates safe self\-referential structs, a few example instantiations to demonstrate the API provided by such structs \(see [examples](https://docs.rs/rental/0.5.0/rental/examples/index.html)\), and a module of premade instantiations to cover common use cases \(see [common](https://docs.rs/rental/0.5.0/rental/common/index.html)\).
Quick note about Unicode (just in case). It is indeed possible to upper-case the first *byte* of an ASCII `String` by simply checking whether the byte represents a letter between `a` and `z` (inclusive) and uppercasing it. For Unicode in general, however, dealing with bytes, or `char`, is in general insufficient. For example, to the best of my knowledge, there are Catalan words starting with `ll` which is considered a different letter than `l` and for which the proper capitalization will be `LL` (see https://en.wikipedia.org/wiki/Ll). Uppercasing only the first code point (`char`) would lead to `Ll` which is incorrect.
One could make a good argument that lifetime creep is a fair and correct thing: dangling pointers are abstraction-breaking, in that they can't be concealed no matter what the type does, without paying extra cost. You *have* to be thinking about this or you risk undefined behaviour and Rust is... highlighting the danger here particularly strongly. I definitely agree that the actual process of adding the lifetimes everywhere can be very clunky.
The only field is private, so where it's exposed the user won't be able to overwrite the value. Look how it's used just below the line you linked; it's used to initialize an array with zeroes. Then because the user can't overwrite the value, they can't change the contents of those arrays. This is to ensure correctness because the FFI call that struct is going to be used in requires those arrays to be filled with zeroes. The only way the user would be able to break that is to use unsafe code to change the value or initialize it with something else (or leave it uninitialized with garbage values from whatever was in memory last).
But you're essentially saying that you want high-performance copy free memory management for free (as in the compiler infers it all for you, adds the lifetime bounds for you, and tells you when you're doing something unsolvable), which, in my opinion, is unfair to blame on the language. That's just asking too much. For any language, especially one trying to balance practicality and new ideas (considering that lifetimes were essentially invented by the rust, and so are still being actively proven out mathematically). It may get there eventually, but you still have to realize that you are getting *safe and efficient memory usage tracking without copying*. You do this using lifetimes. If you don't want to deal with lifetimes, then, as you say, clone or use reference counting.
Well, uh, I wouldn't recommend looking at what I was working on the other day. It'd probably cause your eyes to be sucked back into your head and then fired out your ears. Let's just say "needlessly over-engineered" would be a gratuitous understatement. ;)
Better refactoring tools would certainly help. I imagine those will come in time.
This is the only answer here that doesn't involve allocation, it shouldn't be downvoted. The only thing that should be added to use this, is checking that the string is at least 1byte long, and that the first byte is valid ascii.
Adding to this, another (tired?) caveat about uppercasing is that it is dependent on the _language_ of the text. The upper cased version of `i` in English is `I`, while in Turkish it is dotted: `İ` I have no idea how to solve this perfectly, other than to limit the scope of the implementation to only handle, say, English. (It's unclear to me if your example of `ll` is actually an example of the same, or if it is an example of a Unicode problem, as you say. To me it looks like a language problem which is equally valid in simple ASCII)
Or better yet. fn main() { let mut string = String::from("asdf"); string[..1].make_ascii_uppercase(); println!("{}", string); }
Hmm. Not sure if this is the best approach here, but you could try something like this: fn render_num&lt;T: NumToA&lt;T&gt; + From&lt;u8&gt;&gt;(num: T, buffer: &amp;'a mut [u8; 20]) -&gt; Font6x8&lt;'a&gt; { let n = num.numtoa(10.into(), buffer); /* ... */ } I think all primitive integers, minus `i8`, implements `From&lt;u8&gt;`, so this should give you coverage for those.
It is down-voted because it segfaults, and because it is using unsafe code for what you can easily [do with just safe code](https://play.rust-lang.org/?gist=005485fbac286b2269b231437a813553&amp;version=stable&amp;mode=debug): fn ascii_upper_first(text: &amp;mut str) { if text.is_char_boundary(1) { &amp;mut text[..1].make_ascii_uppercase(); } }
I'm afraid it doesn't work. It works fine if I use a specific type eg `&lt;T: NumToA&lt;u32&gt;&gt;` and input `render_num(1234u32, &amp;mut buffer)` or `&lt;T: NumToA&lt;u8&gt;&gt;` and `render_num(12u8, &amp;mut buffer)`. Does that help in any way? 
Panic-free: fn main() { let mut string = String::from("asdf"); string.get_mut(..1).map(str::make_ascii_uppercase); println!("{}", string); }
It is a language problem, in Spanish, `Ll` is the correct capital form AFAIK.
The code you replied to is also panic free, so no real difference here: https://godbolt.org/g/peXtpU 
1. Making a type public makes it so that everyone can _use_ the type, but if it has private fields they still cannot create an instance with struct initialization. Try it from outside the module. Alternatively you can have `fn remove_comments(self) -&gt; impl Iterator&lt;Item=T&gt;`, which is currently only possible with a nightly feature but should be stable in ~5 weeks. This allows you to hide the type completely, and might even be enough to make your original example work. 1. `Sized` only means "has a definite size" and is the default unless you opt out with the very similar `?Sized`. The interaction between the `Sized` and dynamic dispatch comes from trait objects where you cannot take `self` or return `Self` _and_ have dynamic dispatch, because there's no way to know what `Self` actually is at compile time. Adding the `Self: Sized` bound to a trait method in a sense says "`Self` must be fully known to call this method", because you must know exactly what type it is to know its size, and if you fully know the type you no longer need dynamic dispatch. So actually a `Sized` bound helps you get static dispatch!
https://rust.godbolt.org/
Ah, it's about user. I thought it is intended to be, like, self error prone, however I (as an author) still can write `Reserved(42)`. Now I see. Thanks
Have you tried [OsString](https://doc.rust-lang.org/std/ffi/struct.OsString.html) and [to_string_lossy](https://doc.rust-lang.org/std/ffi/struct.OsString.html#method.to_string_lossy) if you don't care about the lost chars?
[Original code - since it's been deleted](https://play.rust-lang.org/?gist=efe5caa1165323f9eb097c197c9c7e4d&amp;version=undefined&amp;mode=undefined) &gt; it segfaults Uh... no it doesn't. It would (might) on a string of length 0 or non ascii string though. Your code is certainly more elegant, I'm glad that grandparent posted just to get you to post that :P
I actually like this a lot. Since there's no overhead, this is exactly what I think of doing, didn't remember/think of chain. No performance lost :) Thanks!
&gt; I think sometimes because rust can achieve such high performance, then we lose sight of what is really acceptable performance. Most of us don't need ludicrous speed. It's ok to sacrifice performance for ease of mind and developer time. +1. Writing Rust, I catch myself thinking, but "But I don't *need* dynamic dispatch here..." or heap allocation or similar, and ignoring that 99% of cases, I also don't need the performance of not having those things if they're easier. 
I believe this is the artifact of the implementation. It is carefully crafted to avoid loading LLVM for `rustc -v` (without `V`), to make it fast. 
Been learning a lot by making a personalized homepage showing all my projects' Todo.txt tasks, reminders for updating project files/journals/etc, and important google calendar deadlines in one place: https://github.com/kevinw/encasa
If someone from maidsafe would reach out about taking maintainership I would be open to it.
Wouldn't you need 2 generic parameters to represent this correctly? Can you provide a playground link with the minimum code to reproduce? 
By default Rust does not buffer I/O, therefore I am afraid that `f.bytes()` may make a system call for *each and every byte*. I recommend trying to wrap the opened file into a [`BufReader`](https://doc.rust-lang.org/std/io/struct.BufReader.html), simply replacing `f.bytes()` by `BufReader::new(f).bytes()`, and then test the performance again. (It would still not be as good than just using the csv crate for this particular example, but may help you in the future)
Small nitpick, as your general point stands, but ll is capitalized as Ll in Catalan. See, for example, https://ca.m.wikipedia.org/wiki/Lleida
Variance is easy. Lets think in terms of Rust. So we are only dealing with traits. First imagine this: trait T1 {...} trait T2 : T1 {...} What this means is all things that are `T2` are also `T1`. It also means you can use a `T2` anywhere you could use a `T1`. I like arrows so I am going to say something like `T1 :&gt; T2`. This basically says that anywhere you have a `T2`, you can "vary" it (make it) a `T1`. Now lets add a new thing. Functions! Lets start first with only the return value. I want a `Fn()-&gt;impl T1` but only have a `Fn()-&gt; impl T2`. In theory it should work, because we can always make a `T2` into a `T1`, so we can just convert the output. So we now could say something like: fn make_t1(f: (Fn()-&gt;impl T1)) -&gt; T1 { f.call() } ... let f2 : impl Fn()-&gt; T2 = ... let t = make_t1(f2) In short Fn()-&gt; impl T1 :&gt; Fn()-&gt; impl T2 where T1 :&gt; T2 Notice an interesting thing. `Fn` traits are abstract, they are composed of other types/traits. The above shows that the arrows of specialization (or variation) of these traits are the same as those of the traits they output. We call this *co*variant because they vary together in the same direction. Now say that we wanted to do the same, but this time in the argument. So we want `Fn(impl T1)`, but only have an `Fn(impl T2)`. Could we just use the latter instead of the former? Well: could we pass in a `T1` that isn't `T2`? Of course we call, all `T2` are `T1` but not all `T1` are guaranteed to be `T2`. This means we could pass something that we shouldn't, and this breaks the rules! We could do it the other way, if a function is `Fn(impl T2)` we could always pass instead an `Fn(impl T1)`, because all the `T2` that we pass would also be a `T1`. This means that Fn(impl T1) &lt;: Fn(impl T2) where T1 :&gt; T2 Notice that the arrows are going the opposite way. So now we call things *contra*variant because the vary in the opposite direction. And that's basically it for variance. It basically talks about how things are more or less specialized versions of the other depending on how more or less specialized are their parts. The tests that you show basically verify that the compiler does the right thing in how it specializes the input and output types correctly (the cast is done by simply returning the value). And what is invariance? Invariance is something were no matter how you change the part, it has no effect on how things are. Basically there's no way to convert between them.
You can still use this trick to protect yourself from yourself by putting the struct in its own module, since privacy is at the module level. 
Except for minimizing mutability, Swift does a good job at ticking those boxes. - Uses automatic reference counting for classes - Has Rust-like enums and `Optional&lt;T&gt;` which is exactly like Rust's `Option` - Good library ecosystem accessible via CocoaPods, SwiftPM, and Carthage Unfortunately, it's pretty tied down to Apple's ecosystem. It supports Linux as a target but I've had poor experience due to inconsistent behavior between Linux and macOS.
That sounds right, but the types accepted are the exact same. I can't get NumToA on the playground, but copy pasting into a new project and `cargo add numtoa` demonstrates the issue. [Link here](https://play.rust-lang.org/?gist=bcf40b5a923062a9550dd1edc4f9a3ee&amp;version=stable&amp;mode=debug) Thanks so much! :)
Haskell?
[Dijkstra of course](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html).
Like a SQLite database? Check out diesel.rs
Actually, it's entirely possible for iterators to have a performance penalty. I don't recall for certain whether `chain` is slower than writing out two loops, but I suspect it might be.
One piece of code where review would be really helpful is the `unsafe` part that calls the Windows API: https://github.com/soc/directories-rs/blob/master/src/win.rs#L84
all-features key seems to be there now.
I think a good comparison point is [Stack](https://docs.haskellstack.org/en/stable/README/), a popular Haskell build tool, which does manage the compiler toolchain as well as library dependencies. It's a bit more elaborate, because it incorporates a concept of [snapshots](https://www.stackage.org/) that collect a compiler release plus a collection of packages in specific versions that have been certified to all compile together. The idea is that you specify a snapshot for your project, say [LTS Haskell 11.7](https://www.stackage.org/lts-11.7), and that fixes a compiler version (in this case 8.2.2) plus a published collection of certified package/version pairs that will be used as your default version when any of the packages in your project asks for any external dependency. (Which you can optionally override by saying your project wants a different package version from what the snapshot specifies, or specify additional packages that are not in the snapshot.) Stack's snapshots might be more complex than what some people prefer, though. Over in Haskell land the concept was motivated by years and year of dependency hell the likes of which I don't believe the Rust world has experienced so far.
You could be referring to more than one kind of database...can i assume you're talking about something like SQLite?
I think this is the right way to go. Maybe try to avoid generating a new `String` when possible? ``` { let mut chars = text.chars(); if let Some(c) = chars.next() { if c.is_lowercase() { let mut result = String::with_capacity(text.len()); result.extend(c.to_uppercase()); result.push_str(chars.as_str()); return result; } } } text ```
Hi, this may seem bike-sheddy, and I have not looked at your issue tracker, but I do not really like the naming in `directories`. I would prefer that the structs be fully name, i.e. `BaseDirectories`, `ProjectDirectories`, `UserDirectories`. Rust tends to prefer fully named types and and variables, so I think that it would be better to fully type out each name, without abbreviation. I think I am more fine with `home_dir` as you will see these functions in the code more often than the Struct name, so maybe I am arguing against my point :) Anyways, this looks super cool, and I hope that 1.0 will be a good stable place for these libraries.
This example is even in the docs :) You can’t solve it without locale information, as you say.
That's funny. :-) I changed all the names to abbreviations [here](https://github.com/soc/directories-rs/issues/11) because people (rightfully) pointed out before that in Rust pretty much everything is abbreviated.
Neither code is exactly "panic-free": `make_ascii_uppercase()` will panic if the user accidentally passes a non-ASCII first character. Should include an `is_ascii()` check to avoid this, probably.
According to https://msdn.microsoft.com/en-us/library/windows/desktop/bb762512.aspx, "Virtual folders are not part of the file system, which is to say that they have no path".
Oh damn, I looked everywhere and didn't find this page (or realize that it was explicitly marked as `VIRTUAL` in https://msdn.microsoft.com/en-us/library/windows/desktop/dd378457.aspx. That clears things up, thanks!
The answer can found on the doc page for [print!](https://doc.rust-lang.org/std/macro.print.html): &gt; Note that stdout is frequently line-buffered by default so it may be necessary to use `io::stdout().flush()` to ensure the output is emitted immediately.
Take a lock on stdout and wrap it in a `BufWriter` let stdout = io::stdout(); let lock = stdout.lock(); let mut w = io::BufWriter::new(lock); and then write to `w`. 
[removed]
One thing I find really valuable about the XDG specification is that it supports a cascade of locations. For example, when my application wants to read its config file, it should check: - `~/.config/myapp/` for settings set by the current user - `/etc/xdg/myapp/` for settings set by the system administrator for every user on the host - `/usr/share/myapp/` for defaults shipped with the software Some applications might want to add even more locations to the list, in the way that `cargo` checks for `.cargo/config` in the current directory each parent directory up to the root. It's not just a Linux thing either; macOS has `~/Library` versus `/Library` versus (if I recall correctly) `/System/Library`, and Windows applications often look for config files and data beside the executable as well as in the usual per-user locations. It would be very welcome if `directories` included functions that returned a prioritised search-path of locations to read from, at least for the "config" and "data" categories.
Many database solutions use that extension. Please specify which one you're using.
Yes, println always flushes. But that can be easily mitigated by storing you text in a string before printing it. You might want to use a logging lib if you're worried about println affecting your application performance.
maybe the limiting factor is also your terminal emulator, try to benchmark both when piping to /dev/null
It is actually a very good comparaison (ignoring the whole cabal thing...). As you mentioned, Stack is actually doing a lot of smart things but they aren't needed in Rust. The snapshot thing is required just because of how dependency are managed in Haskell which I believe is different in Rust ( not 100% sure here). 
You can add strings, as long as the first one is a String. let s = String::from("h") + "ello " + "world"; 
That's true. I have been thinking about adding something like a `SysDirs`, too.
That's partially due to consistency, because the name `[directory](https://crates.io/crates/directory)` was already "helpfully" taken and &gt; This is a dummy package that will never have any content. I registered it because it seemed plausible that people might copy-paste stuff into their terminal and accidentally install this. I don't want them to install malware, therefore I registered it and I will never put any content in it. If you installed this package, you made a mistake.
Why do you want to do the composing at compile time? I assume you create the regexes at runtime using `Regex::new()`, in which case the overhead of also doing the templating at runtime (e.g. `Regex::new(&amp;format!("{}.{}", r0, r1))` should negligible. You can probably get closer to computing the strings (and regexes) at compile time by using the [`laxy_static`](https://docs.rs/lazy_static) crate.
Is there a good tutorial on futures around the interwebs? I can't seem to find any good ones using google alone.
In my experience Rust wraps up the OS pretty well; both from usability perspective, and from a performance perspective. libstd hides most of the platform details for common operations (file-system, networking, etc.), but you still have access to platform-specific modules (which os obviously non-portable). It's technically up to you to decide if the generic API is good enough, but I didn't find any reason yet to not use it. ¯\_(ツ)_/¯ The GUI story on the other hand is non-ideal. Rust has bindings for all sorts of GUI libraries/frameworks (including both [GTK](http://gtk-rs.org/) and [QT](https://github.com/rust-qt) ), but all in all it's not the best experience. QT is as cross platform is it gets. GTK+ is technically cross platform but it doesn't look too good on non-Linux OSs (looks out of place both on windows and mac). iirc the current direction is some kind of lightweight electron framework based on servo. Android can run arbitrary code (though I don't know the limitations). I personally have rustc&amp;cargo installed on my phone.
You dropped this \ *** ^^&amp;#32;To&amp;#32;prevent&amp;#32;anymore&amp;#32;lost&amp;#32;limbs&amp;#32;throughout&amp;#32;Reddit,&amp;#32;correctly&amp;#32;escape&amp;#32;the&amp;#32;arms&amp;#32;and&amp;#32;shoulders&amp;#32;by&amp;#32;typing&amp;#32;the&amp;#32;shrug&amp;#32;as&amp;#32;`¯\\\_(ツ)_/¯`&amp;#32;or&amp;#32;`¯\\\_(ツ)\_/¯` [^^Click&amp;#32;here&amp;#32;to&amp;#32;see&amp;#32;why&amp;#32;this&amp;#32;is&amp;#32;necessary](https://np.reddit.com/r/OutOfTheLoop/comments/3fbrg3/is_there_a_reason_why_the_arm_is_always_missing/ctn5gbf/)
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](http://gtk-rs.org/) - Previous text "GTK" [Here is link number 2](https://github.com/rust-qt) - Previous text "QT" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
Jesus christ what if I wanted shruggie to be fucking rayman
&gt; This obviously points to how Rust deals with system calls [..] I mean, yes and no. When you're writing code against `std`, you're mostly writing it against a portable subset. But that portable subset is implemented by calling the appropriate platform-specific functions. And if what you want isn't supported by `std` or some other crate, then you're going to be calling platform-specific APIs. There's no getting around that: *someone* has to do it. &gt; Is there crossplatform GUI libraries for Rust ? Well, that depends on how you define "crossplatform". Are there UI libraries that will work on multiple platforms that let you show *some* kind of graphical interface? Yes. Are there cross-platform UI libraries that properly integrate with the native environment? No. There's several abandoned ones... turns out Rust doesn't like conventional GUI API design... like, *at all.* The only one I've seen that appears to be vaguely up to snuff is for Gtk. Even then, you're probably in for a *lot* of dynamic borrow checking. If you like Gtk, you're all set. If not... &gt; How does Firefox -from 53.0- works on Android if the latter only supports Java, Kotlin and C++ ? Platforms don't support languages, languages support platforms. Rust can target Android just fine whether or not Google wants it to, because it's known how to target Android with C++.
 These are my thoughts as someone still fairly new to rust \(haven't written much\). If you use pure rust components, cross compiling is easy. The problem is that most nice things \(e.g. GUI libs\) use C/C\+\+ libs and are trickier to build, even more so with cross compilation \(though if you are coming from C/C\+\+ it may be easier to understand what you need to do\). There is bindings for Qt and GTK as well as a few others and at least 1 rust specific GUI.
Wow, Rustaceans reputation checks out what everyone's been talking about. This is one of the few times I've got so fast answers on the internet, thanks for that awesomeness !
The XDG model is that each configuration directory on the search path contains subdirectories named for applications. That's true for `/usr/share` (by existing convention), and true for `~/.config` (by definition), but not true for `/etc`: there's all kinds of stuff in there, including bare files ("shadow", "hosts", "issue", "fstab") and directories that are not application names ("network", "alternatives", "default", "skel"). It's a little bit ugly for the XDG specification to choose `/etc/xdg` be the per-system config directory, but it'd also be ugly if the XDG specification had to maintain a blacklist of application names because on some hosts, in some directories, those names were already taken. One might argue that it's a bit over-cautious for the XDG people to make a whole new directory, because *probably* nobody would name an application "shadow" or "hosts" or "issue" or "network" or "alternatives" or "default", but specification authors tend to assume people will blindly follow their specifications without understanding the consequences; people follow specifications *because* they don't want to know about the consequences: "I followed the specification and my program broke on your system, therefore your system is broken". &gt; Gimp for instance, which adopted XDG quite recently puts its stuff into `/etc/gimp`. My current copy of GIMP predates the project's adoption of XDG conventions, and it still has things in `/etc/gimp`; I suspect the continued existence of `/etc/gimp/` is a backward compatibility thing.
Could you explain a bit further on how you got rust on your phone? I've tried on my phone and tablet and not succeed very well. What targets did you use? (although clang installs fine on my phone) 
The best move about Rust and GUIs is to wait to see how things will settle. &amp;nbsp; /r/Gilnaa talked about an electron outcomes, which is really bad.
Well, both KDE and GNOME have shown favour for Rust, I'm pretty sure rust-qt is an official KDE project, but don't take my word for it. I wouldn't worry about the "electron outcome". The bloat of electron is not tied too hard to the concept of embedded HTML rendering engine. Look at sciter, for example.
(Without reading anything else about your explanation,) please don't ever say "x is easy" (or "simple"). It makes some people feel stupid for not knowing it right away and others feel stupid if they don't understand your explanation. And I also argue it's not easy because it borrows the nomenclature from logic without having a clear analogy from the terminology it is borrowing from.
&gt; I mean, yes and no As long as Rust's `std` can be on par with Java's, I don't see any problem. But that's the question, does Rust ? &gt; Well, that depends on how you define "crossplatform" The best would be a non-native GUI API (like Java's Swing) first, then some native ones (like QT or GTK+) just in case. &amp;nbsp; &gt; Rust can target Android just fine whether or not Google wants it to, because it's known how to target Android with C++ We're so luckiy to have NDK on Android.
I do know it works on Android, but not how it works. Found this though: https://mozilla.github.io/firefox-browser-architecture/experiments/2017-09-21-rust-on-android.html
Given that this looks like a 200s level class in college, I'd expect type variance to not be discussed in it.
I installed archlinux-arm through "Linux deploy" app and then rustup through pacman. Works well.
Pavel Strakhov worked a lot with Qt, but I don't know if he's part of Qt Project. I've took a look on rust-qt's Github, and him being the only one to work on it is a real problem. &amp;nbsp; About electron, some aren't for sure, but I -and lots of people- prefer a proper separation where JavaScript should only stick to what it was meant for: web. JavaScript is kinda Rust's yang, it is a so permissive language for quick and dirty "coding" that a lot of websites and projects are made unmaintainable. I mean, it wasn't uncommon to take care of source codes overloaded by anonymous functions with such major issue... About performance, sciter is moslty used on Security softwares... which still easily shows overhead on decent PCs due to code interpretation and it's still far from C#'s performance.
Well, I didn't mention JavaDcript, and I (personally) hope it won't be involved with Rust GUI whatsoever. IDK about performance, I'm just hoping for the best. All in all, even not considering Rust, cross- platform GUI is not that common. It's a hard problem as it is. Most solutions that I am aware of are either JS-based, above some VM/JIT or are unable to blend in with native toolkitm
I’ve took this course a while ago and it definitely did explaine subtyping and variance. The material might have changed since then, but looks like the topic is still covered in the last week of the third part of the course.
For some reason if I use termux it can't find rust. But I also see it's using it's own repos, so rust is probably not in there for some reason. Although I did manage to install debian on my phone so hopefully that will be easier to get rust going 
I've managed to get debian going, I didn't realise arch would work, as I would have preferred that as I use arch on my desktop. Although debian will do fine for getting rustc going 
Up until last year, now it is ẞ.
Yeah, there's truth in your words. I think the only GUI I ever enjoyed was C#, but both WPF &amp; WinForms are anything but portable. I'm not using Windows anymore, and haven't for a long time, but if there's anything I miss it's C# GUI.
[I seem to find it okay](https://i.imgur.com/hyzxSxb.jpg) I thought that maybe I added a repo or something but I can't seem to find tye command
By design, Rust compiles to native code that can be a drop-in replacement for C if you `extern C` the appropriate external API... just like the C++ that Android supports.
Rust can be very cross-platform friendly. Rust code itself compiles on any supported platform, i.e. if you write functions that just calculate things and don't interact with the OS, it'll work everywhere. In the standard library, you only have filesystem and networking, which are implemented for Windows, Mac &amp; Linux and (I think) a few other operating systems. If you only use the standard library or any library thay only uses the std library, it'll compile fine on at least the Tier-1 platforms: https://forge.rust-lang.org/platform-support.html Now, if you want to call OS-specific behaviour, such as showing a notification... of course every OS does this differently. What rust has are cfg flags, which have a target_os hint. So you can have three functions with the same name, but mark one with `#[cfg(target_os ="windows")]` and the others with `#[cfg(target_os ="macos")]` and so on. Then, at compile time, Rust will select the correct functiom depending on what OS you compile for. It's like `#ifdef` but cleaner, since you don't have an `#endif` anywhere, the attribute always applies to the next block (function, module or struct). Now, many people use this to make "wrapper" crates around system APIs. So for example, there is a crate `winapi`, a crate `dbus` for Linux, a crate `coacoa` for Mac and for Android you have a `jni` crate, to interact with the Java VM. Now people write a wrapper library, lets say `libnotify`. They write four functions that do different things depending on the `target_os` flag. Then they publish it as a "library to send notifications in a cross-platform way". For example, `winit` wraps window handling this way. Now, for C libraries it's a different story - it's technically not different than using a C library from Java. First it depends if the C library is cross-platform and does any OS-specific stuff. If it does you're out of luck, but the same would happen in Java. Then it depends on how the library is packaged. Usually you generate bindings from header files and put them in a seperate crate, but how you include the actual code of the library is different: Rust can either statically or dynamically link extern non-Rust libraries, i.e. either include the library in the final binary or use it from a seperate DLL. Usually statically linking has the advantage of "one binary only", so the user just has to have the .exe an nothing else. Dynamic linking (via DLL / .so) has the advantage that the user can swap out the DLL without recompiling the program. However, this can lead to build issues since the DLL has to be found at compile time. So if the DLL is not available / installed on the target system, then the program wont' compile / won't start. This is necessary to know when linking proprietary DLLs, where you don't have the source code, so you can't do static linking. Usually crates say in their README if they are cross-platform or not and what OS they support. And usuall crates try to be as cross-platform as possible, just ask the maintainer if it doesn't compile. Hope this helps.
Your library appears written with GNU/Linux's conventions as the primary abstraction. Each platform has its own set of conventions which aren't easily abstracted. Consider `config_dir`: * GNU/Linux returns `~/.config`. The app then typically stores its configs in a folder with the same name: `~/.config/foo/*`. * macOS returns `~/Library/Preferences`. Docs: [The Preferences System](https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/UserPreferences.html#//apple_ref/doc/uid/20002092-BCIJBCCF). It basically creates a plist file with the bundle name, and allows loading defaults hierarchically. If you're not using their preferences system, it's better to keep your configs in Application Support, e.g. `~/Library/Application Support/foo/*`. Please use `Application Support` instead of `Preferences` as `config_dir` on macOS. CLI tools commonly use `~/.config`, while native apps are usually the ones with a folder in `~/Library/Application Support`. In practical terms it's probably fine to just use your hardcoded values, but if you really want it to be correct and future-proof on macOS you have to call [NSSearchPathForDirectoriesInDomains](https://developer.apple.com/documentation/foundation/nsfilemanager/1407726-urlsfordirectory?language=objc). Take a look at [macOS Library Directory Details](https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/MacOSXDirectories/MacOSXDirectories.html#//apple_ref/doc/uid/TP40010672-CH10-SW1). You included Fonts, but not others like Logs which would also be useful. I know on macOS you'd typically use `~/Library/Logs/` (user logs), `/Library/Logs/` (global logs), or `/var/log/` (system logs). Some apps don't even bother trying with cross-platform variations and just throw everything into their `Application Support` directory. Some of these features don't seem very useful. When would you realistically see yourself using `executable_dir` or `runtime_dir`? What would you do to handle the other 2 platforms? I'll note that I use `~/.local/bin` for user-specific CLI utilities, but since I'm on macOS your library would just return None. The Trash directory you left commented out is incorrect for case-sensitive file systems, it should be `~/.Trash`. 
But muh zero cost abstractions /s
link isnt working?
How do i make it do anything? I only see a black screen.
I've got myself this nice enum: pub enum Cell { /// A keyword, given by Card.keyword Kw, /// A fixed, non-keyword entry Fixed(&amp;'static str), /// An integer with a given maximum string-length Integer(u8), /// A float with a given maximum string-length Float(u8), /// A given number of blanks Blank(u8), /// A conctinuation character `&amp;` Cont, /// A string of a given maximum length Str(u8), /// A sequence of 0 and 1 Binary(u8), } It shall express the structure of a line by dividing it into cell (i.e. `Integer(8)` means there are 8 chars that form an integer). Now I need a way to express an alternative, something that says e.g. "The following 8 characters either represent an integer, or are all blanks". But I can't put something like `Either((Cell, Cell))` in there, because that would form a cycle and doesn't compile. I could probably define a new enum, with one variant a single `Cell`, and the other Variant two `Cell`s, but that sounds a bit much. Any good ideas how to do that? Bonus points if the length of the alternatives is forced to be the same, e.g. `Either((Integer(8), Float(9)))` should not be allowed. Thanks for any pointers :)
Abbreviations increase the mental cost of reading code while making writing cheaper. Which is a really bad trade off in the long run, because code will be read much more often.
That's not going to work. You're trying to return a reference to a string that's stored on the stack frame of your `read_file` function, which gets dropped as soon as your function returns. You need to either take the buffer string as an argument, or return it as an owned `String` to transfer ownership to the caller.
So there's a problem here: You're returning a reference (really a pointer underneath) to a resource that will be **deallocated** after you return from the function. `file_str.as_str()` is a reference to the internal buffer of `file_str`, which is a String. This buffer will be deallocated once you return from the scope, since `file_str` will no longer be accessible. This will lead to you returning a dangling pointer, if rustc had not caught the bug for you. What you can do to fix it: You can return the string instead as such: fn read_file(path: &amp;str) -&gt; String { let len = file_size(path); let mut file_str: String = String::with_capacity(len); let mut file = File::open(path).unwrap(); file.read_to_string(&amp;mut file_str); file_str } This works since `file_str` won't be deallocated any more, since it escapes the scope. BTW, in the **future** you won't need to write this function yourself, since it will be in the standard library as [`std::fs::read_string`](https://doc.rust-lang.org/std/fs/fn.read_string.html)
Ok I hoped that it would be somehow possible to do it like that, but then Ill just return a String.
[removed]
file_str won't get copied in that case when returning it or?
&gt; fn read_file&lt;'a&gt;(path: &amp;str) -&gt; &amp;'a str{ If you just look at the signature of the function, you can see that you create the lifetime `'a` out of nothing. Lifetimes are in a way dependencies, but your `'a` has nothing to depend on. What you normally do, is to connect the outgoing lifetime with an incoming one. It basically means, that the outgoing data is normally a subset of the incoming one. As an interesting fact, it is possible to "invent" lifetimes in unsafe code, but you have to be very careful with that.
It works for me in firefox nightly on Linux (not in regular firefox though).
Ah, sorry about that, I haven't added any UI to signal that it failed to load (I probably should!). The reason will most likely be that your browser does not support Web assembly; it has to be fairly modern!
Can I ask what version your regular Firefox is? Perhaps support is more limited than caniuse suggests, as I had hoped FF 53 and above would work! 
Does not work for me with FF 59.0.2 on Linux...
Firefox Quantum 60.0b4 (64-bit) Firefox Nightly 61.0a1 (2018-03-31) But just realized that it works once a disable ublock origin. The rule that triggers it is the following on EasyPrivacy list: /.*(\/proxy|\.wasm|\.wsm|\.wa)$/$xmlhttprequest,domain=github.io|rawgit.com|reactor.cc|sickrage.ca|streamplay.to|tubetitties.com|vidfile.net Which blocks the XHR request to https://jsdw.github.io/wasm-fractal/js/wasm_fractal_bg.wasm
I think people are more aiming for a custom UI framework bases on the components from servo, rather than using servo as a whole in an electron-like way. Expect it to be relatively resource efficient.
Thanks, that's interesting to know! I have added a couple of warnings if WASM appears not to be supported, or if there is an issue loading or instantiating the wasm. I doubt that they will catch everything but hopefully it will be a little more obvious that something has gone wrong :)
Interesting, but why KDE decided to fully go their own way instead of helping Pavel Strakhov's rust-qt, especially when only this latter is listed on Qt Project's wiki ?
I was surprised how good relm woorks. If you just need a GTK GUI is quite easy to get in running.
Same issue here (disabling ublock origin fixes it). Your new warnings don't show up in response.
Worrying about flush on console IO always struck me as peak premature optimisations. If it's a problem then you've made a very wrong turn somewhere that has led to you needing to care about something you shouldn't. You see the same stuff in the C++ community where people decry people for using std::endl because it flushes. And no, you shouldn't be using piped command line programs to mutate gigabytes of information.
I've been using Rust at work where all the computers are windows, but prefer to develop on my Linux machine. From what I've seen everything is cross-platform by default, so it all *Just Works*. Cargo is in a totally different league to things like cmake, autotools, or makefiles. The most pain I've had is trying to link to C libraries because the C libraries themselves aren't cross platform or rely on linux-specific tools like autotools or make.
I should probably be testing this stuff.. I spotted an obvious issue, so hopefully now the warnings will show up \(but please let me know if they still don't!\)
I'm not sure, but, given the timing of their releases, it's possible that they both started around the same time and, by the time they were aware of each other, they'd both made so much progress on supporting their respective use cases that they were loathe to throw it away.
I remember arguing with the guy over on users.rust-lang.org and he says he would transfer ownership if he deems it a valid use. Who installed him as lead-crate-naming-messiah I don't know, but it still might be worth giving him a ping and see if he will.
Rather than implementing `length_of_u16_string` yourself, have you tried using `lstrlenW` \(it's in `winapi::um::winbase`\)? Also, you never check that` path_pt`r isn't null.
Totally agree, but that's the decision Rust made, I'm just following the convention.
No, I'll go and check, thanks! &gt; Also, you never check that path_ptr isn't null. Oh, true, I'll need to fix that! Thanks!
Thanks for all the information, this is really helpful. Will go through it over the next few days and think about each point individually! Thanks! &gt; The Trash directory you left commented out is incorrect for case-sensitive file systems, it should be ~/.Trash. I'm backing out of providing Trash altogether, there is no path to return on Windows.
The tooling is getting better, but the packaging/tooling story is lacking compared to Rust. Still love it and it ticks all the other boxes.
Ah it seems like uBlock Origin blocks something. Disabling it makes it work.
Github issue once again I assume...
Ooh, I had some trouble with those keys myself \(oddly, the codes were different on firefox than others for me!\). I have added support for the numpad \+ and \- keys as well \(which I can't test at the mo as my keyboard doesn't have one\). Let me know if you still have issues :\)
Thanks for letting me know! 
From [the documentation](https://doc.rust-lang.org/std/primitive.u8.html#method.make_ascii_uppercase): &gt; ASCII letters 'a' to 'z' are mapped to 'A' to 'Z', but **non-ASCII letters are unchanged**. 
The Linux bits look more like *Unix* bits to me.
plus and minus from the numpad work on firefox 59.0.3 My issue was also that ublock blocked something.
It's not about how it looks, but rather from developper perspective. But "nativeness" must not be a multiplatform program's target, their GUIs needs to looks the same on any possible OSes. &amp;nbsp; I must also say that design should be as timeless as possible, no need to follow a trend that won't last (looking at you flat "design). Same goes for usability.
file_str is 3 pointer-sized things long and contains 3 values: a pointer to a buffer on the heap, the length of the string, and the allocated length of the buffer. Returning file_str means moving that value to the caller. That might mean a memcpy of 24 bytes, it might mean returning it in registers, or most likely since the function is so short it's going to just be inlined and the 3 values created where they are next used. But when passing around "String"s, the entire contents of the string will not be copied unless you intentionally use .clone().
 &gt;I'm backing out of providing Trash altogether, there is no path to return on Windows. It may be possible but with different abstractions. For example, you can think in terms of resources instead of paths and files. Having said that, I'm not sure how often an application needs to access the trash. Maybe a secure file shredder might want to check for old versions of a file in trash perhaps? But most apps shouldn't need it. 
You need to make sure you're not mangling names
Genmesh makes simple geometric shapes
Just jumping in here as a web developer to say that not all JavaScript projects are a mess. The language allows you to write absolute crap, sure, and there are lots of oddities leftover that we can't really remove, but the language itself is good enough to permit quite sane projects. TypeScript is great for this also.
&gt; /r/Gilnaa talked about an electron outcomes, which is really bad. Yeah, because I'm unwilling to compromise on my creations feeling native in my KDE desktop, my approach has been to use `rust-cpython` to turn Python into a QML-alike to glue PyQt/PySide to Rust... but PyQt or PySide makes for a pretty big bundled dependency pack on non-Linux platforms, so that's probably not what you're looking for.
This actually looks pretty good :o
I honestly feel like this should be reported. It feels like gross misuse of the system, and is that special kind of vigilantism that creates more problems than it solves. If somebody should "reserve" common crate names to avoid confusion, it should be the crates.io project itself. Not the average vigilante.
How is [Conrod](https://github.com/PistonDevelopers/conrod) these days?
&gt; it'd also be ugly if the XDG specification had to maintain a blacklist of application names because on some hosts, in some directories, those names were already taken But that's the exact same problem as someone picking an application name that is already used by another application. I'd rather have the developer realize that naming his application "shadow" is a bad idea at development time, than having his users realize that `/etc/shadow` and `/etc/xdg/shadow` are unrelated things after the release. &gt; My current copy of GIMP predates the project's adoption of XDG conventions, and it still has things in /etc/gimp; I suspect the continued existence of /etc/gimp/ is a backward compatibility thing. They could have just changed it in the same version where they switched from `.gimp` to XDG, it's not more or less a compatibility thing than `.gimp`. I think if I ever do the `SysDirs` struct, or provide search paths, I'll go with `/etc` instead of `/etc/xdg`. Applications have pretty much voted with their feet on this, and I don't see the value to go against the grain. Maybe it would make more sense to send a patch to the XDG spec mailing list dropping the `xdg` component instead of trying to make the rest of the world adhere to something that was pretty much rejected.
Works on my phone! (Though sadly can't zoom in without keyboard)
He is certainly not the only person doing something like this. Here is a list from just the three (imho) top offenders that registered crate names without doing anything with them: - audio - binary - book - browser - calc - chat - clock - cloud - cmd - comm - command - compute - crate - crypt - crypto - decode - dependencies - detect - directory - doc - docs - documentation - editor - encode - env - ffi - file - fn - game - help - html - http2 - install - io - js - lib - library - linux - manual - map - math - meta - method - mod - music - net - network - news - option - package - packages - posix - registry - script - search - sort - tab - tcp - thread - tools - tutorial - udp - uninstall - update - utf8 - video - web I wouldn't even blame those people too much – it's inherent in a system without namespaces. I said this right in the beginning: having a single, global library namespace is a really really bad idea, and seeing how other ecosystems ran away from it after trying to make it work for years supports this position.
rust-qt is somewhat dead, there's an issue that prevents it from linking on OSX which has had a fix merged but no release since December. (Issue)[https://github.com/rust-qt/cpp_to_rust/issues/72]
Looks like exactly what I need! Thanks! I'm currently trying to install it but I'm having some trouble. I installed postgres, and I'm running the following command in CMD &gt; cargo install diesel_cli --no-default-features --features postgres but I'm getting "failed to compile 'diesel_cli v1.2.0', intermediate artifiacts can be found at C:\Users\me\AppData\Local\Temp\cargo-install.OFfuWpgE4jzE
I have a networking question: I have built nickel based postresql api, which is working just fine when I connect from localhost, but if I try to access it from outside of local network, it's not answering. My api is listening http://127.0.0.1:6767 and when I enter in browser "http://localhost:6767/raw", it works just fine, but when I try to connect to my external ip from my phone, it says nothing. My api doesn't "hear" the request. I've opened up the port 6767 from my router. I have an Arch linux. I wonder if there is something I'm missing. Should I open something from linux or change the listening address... I've spent one whole day with this, but I can't seem to solve it. All this networking stuff is still very confusing :)
Don't worry - since you already create a `String` inside the function (correctly - the content from the file has to go somewhere), it's not somehow more efficient to return a `&amp;str`.
Should I use `Self` in type signatures instead of the type name, where possible? E.g. struct TypeName; impl TypeName { fn do_something(&amp;self, other: Self) -&gt; Self { // ... } } or struct TypeName; impl TypeName { fn do_something(&amp;self, other: TypeName) -&gt; TypeName { // ... } } 
Have your app listen on 0.0.0.0 instead to expose it on all of your network interfaces :) 
I was able to use the controls with Hacker's Keyboard (Android app, I don't know if there is an iOS equivalent) . 
As somebody quite literally doing the opposite, I must ask: how much math have you done? What are your interests there? I left math because I found the culture a little isolating and elitist, but let me know if you find some counter-examples. 
I'm not a member of Redox myself, but I've been following it avidly, including your own fascinating work on TFS and the like. It's very sad to see you go, but I wish you the best of luck in your future endeavors in mathematics. Thank you for your contributions to Rust and to the surrounding ecosystem.
https://github.com/ticki?tab=repositories. If you're interested in maintanance of any of these projects, please DM me. Also: https://github.com/redox-os/tfs and https://github.com/redox-os/ralloc/tree/skiplist.
Thanks for the libs, and good luck in academia :) I’m willing to help out keep chashmap alive, my work keeps me rather busy but we’ve been using it in prod for a while. 
What's your GitHub? There's also [atomic-hashmap](https://github.com/redox-os/tfs/tree/master/atomic-hashmap/src), which in some way is chashmap's successor based on [conc](https://github.com/redox-os/tfs/tree/master/conc).
If I were you, I'd wait a little longer before releasing an 1.0 version. Right now, I can see at most ~5 projects using these crates so you don't really know whether you're using the right APIs that suit applications. It seems to be based on roughly half a year of experience right now. E.g. [looking into the documentation](https://docs.rs/directories/0.9.0/directories/struct.ProjectDirs.html#method.from), I see you use magic values (the empty string) for declaring that an application has no associated company name – I think a more Rusty way to do it would be by using an `Option&lt;&amp;str&gt;`. Additionally, I'd suggest you to rethink the license. MPL is a copyleft license. Typical Rust projects that are integrated into the ecosystem are dual-licensed under MIT and Apache 2.0, which might make adoption by other crates easier.
I was always impressed by your attention to detail in rfcs and admired your programming work. Was wondering lately what's happening to you and why you disappeared from the Rust community, now I know. Good luck with your math career!
Good luck! And report back in couple of years how it goes. It's hard to move from fields with short "work -&gt; result -&gt; reward" loop like programming into theoretic fields where you can work for months and get no reward at all (unless you are very young maybe?). That's unless you are going into applied math (ML, modeling, etc) which is pretty much the same programming.
But where would that leave me for the other Cell variants? I'd need to use something like `Regular(u8, Cellkind)`, but that would restrict `Cellkind` to the one's that carry a `u8` after all... Thanks for the idea, I'll toy with it a bit.
I should have said simple (as in the opposite of complex, not hard). With simple I don't mean "easy" but that the concept is something that can be explained without too many rules/caveats/exceptions and that it's relatively self-contained. I understand that the logic it builds on adds more complexity (though logic is also simple, not complex), but the reality is that you don't need it to explain to a programmer fully. The question of what is variance and how it works results in a hard concept (when can you convert from one type to the other, and what happens when you compose a type from others) that is relatively simple (there's clear and direct definitions of relationships as compared to the relationships of the parts). Why this matters, or where you use is is a really hard and complex problem, that depends a lot on what is the context you are dealing with. The problem with most explanations is that they use backgrounds that may not be familiar to programmers. I tried to build one here with Rust, it wasn't that good. I've done it before with OO languages with straight inheritance and generics, but Rust may not support this fully.
&gt; I see you use magic values (the empty string) for declaring that an application has no associated company name – I think a more Rusty way to do it would be by using an Option&lt;&amp;str&gt;. I fear that this wouldn't be any less magical – the problem is that `Some`, `Some`, `Some` is fine, but `None`, `None`, `None` wouldn't be. There has already been an obscene amount of attention put into getting this right, and all the alternatives that were tried (or considered) are worse. I have thinking about abstracting this into some `ProjectInfo` struct, but I'm not sure that it would improve things much – it would just mean having explicit functions for each and every combination that is valid. &gt; Additionally, I'd suggest you to rethink the license. MPL is a copyleft license. Typical Rust projects that are integrated into the ecosystem are dual-licensed under MIT and Apache 2.0, which might make adoption by other crates easier. I'm planning to make that change when I come around to the cargo fixes.
I'm more of a rust stalker than developer, but I've always enjoyed your blog posts and presence here! Enjoy math! I've sometimes dreamed of taking an extended break to learn some mathematical concepts that intrigue me, so I really respect you for taking that leap (especially since it's a switch, not a break for you). Best of luck!
Yeah, definitely could use a better name. Glad it's not stable yet! (in the versioning sense) I'm not at all sure what the better name should be though - we don't have many conventions for something which is something else under some condition. Maybe we could start a bikeshedding issue on https://github.com/rust-lang-nursery/futures-rs/?
Best of luck in your future endeavors! Your presence in the Redox and Rust communities will be missed!
Out of curiousity, is there documentation on what the obscure bug was?
No. I never found it. If any skilled debugger is interested in digging, they should be welcome to do so.
Avalonia may be interesting, it seems basically like WPF on .NET Core. I have not tried it yet.
I'd like to try gtk-rs as someone told me that gtk3 is actually good now, but it doesn't compile on the msvc target and that is a dealbreaker for me.
I've been getting strange behaviour on a recent nightly when compiling for the stm32f in debug mode. I don't know that I can be much help in this case, but have you tried running in release mode to see if there's a difference?
It seems like the things you're missing are these things in the standard library: `Rc`, `Arc`, `Cell`, `RefCell`, `Mutex`, `RwLock` https://doc.rust-lang.org/std/rc/index.html https://doc.rust-lang.org/std/cell/index.html `Rc` allows data to have multiple owners. If you need mutability, you use a `Cell` or `RefCell` inside of the `Rc`. `Arc` provides the same thing as `Rc` but it works across threads. If you need mutability inside of an `Arc` across threads, you want to either use a `Mutex` or an `RwLock` inside of the `Arc`. So for example, a multithreaded application can keep it's state inside of a struct `MyState`. And you can wrap that struct with `RwLock` to ensure that only one thing is mutating it, and `Arc` so it can be owned in multiple places. The end type will be `Arc&lt;RwLock&lt;MyState&gt;&gt;`
Ticki has been an inspiration for me, while they might not feel as productive or as rigorous as they wanted, the bar has been raised in the Rust ecosystem from their presence. I am much older than Ticki and I previously went through a similar cycle. Time moves slower for younger people and they get impatient for the lack of progress in their reference frame. In any long endeavor, managing energy (concentration, fatigue, burnout, reward, etc) is the single most important goal. **Ticki**, thanks for everything, including this letter and I wish you the best of luck.
You got it boss!
Not in the offical unicode capitalization rules
I ported a pomodoro app to Rust + GTK recently and had to figure out some application state stuff, you might find it helpful: https://github.com/bitemyapp/boxcar-willie/blob/master/src/main.rs#L83-L97 Basically I had a struct that represented the total application state and I passed around `Rc&lt;RefCell&lt;Tomaty&gt;&gt;`.
I'm all with you about what you said. Until we can do some decent GUIs without any JavaScript shits, C++ and Java developers won't jump on the bandwagon. Especially when they don't have time to learn some JS shit, nor willing to deal with the forever try-hard-to-reinvent-the-wheel "new" frameworks that are rolling out every days because just because it's new. Most of web developers don't know what stability, modularity and stageability means. Worse, they don't even make the difference between "not wasting unused RAM" and what "reclaimable memory" means... &gt; I don't trust myself This ! This way of thinking must be a requirement for all developpers who wants to be considered as a good one.
It may be memory "efficient", but it'll never be CPU efficient. Sciter and Gnome 3 shows that pretty easily.
GTK3 since version 3.22 is what we can consider as "stable", it's as "stable" as an Ubuntu x.0x.0 LTS... &amp;nbsp; I can't believe they used a so fucked up versioning number... Gnome 3.22 should have been Gnome 3.0 at the very most.
Looks like it is, a one-man made project is a very uncertain one.
&gt; My main point is that I think 6 months of trying, and 5 projects that depend on these two crates, is not enough to call the API finished. &gt; Have you maybe tried having different constructors for specifying different sets of parameters? This way, the invalid pairs are caught at compile-time (as you'd have no way of entering them). Yes, had that before. It didn't work too well, because it pretty much encouraged people to skip on providing arguments for the platform they weren't currently using at that moment. Of the three parameters _all_ of them should be supplied, none of them are really optional if you want a project to follow platform conventions. Being able to pass an empty string is more or less a secret handshake that is accepted grudgingly, because people falling back on `ProjectDirs::from_path` is considerably worse.
Please put the output of things in a paste service (Hastebin and such) next time
Tbh, I tried to think about writting something, but nothing comes. That's the sign of a really a good -and extensive- answer, thanks for this one of yours !
Yup, sorry about that, went a little overboard ^^"
No worries! I used to get stressed out about stuff like this all the time... not good for your health in the long run ;)
[removed]
I have been into mathematics since I was 9 or so, reading books about all sorts of pure mathematics subjects. It is no new interest of mine. I have been a student of physics then mathematics for a long time. And it has always been a goal to do research in either mathematics or physics. Now, as for the elitism, I see what you mean, and I agree to some extend, but I do not experience it to the degree where it is impossible to sit through. I guess it really depends on who you talk to, and which university you are at.
Do you know if `Rc&lt;Cell&lt;T&gt;&gt;` can be safely serialized by serde?
Hey, sometimes you've gotta look out for number one. I wish you all the best!
It can be serialized, but when it comes back every `Rc` will point to a different newly constructed `Cell`, even if they pointed to the same `Cell` in the originally serialized structure. [Issue.](https://github.com/serde-rs/serde/issues/194)
Well, you said you wanted to require that both have the same length, and you seemed to be using `u8` for the length, so... yes? If it really can be *any* two variants, then you probably will need something like `Either(Box&lt;Cell&gt;, Box&lt;Cell&gt;)`, and you'll have to enforce the lengths manually.
Mathematics is lucky to have you, Ticki.
It's an experimental file system created by Ticki, inspired by ZFS
This is awesome! I just started implementing a language server for the purposes of creating a vscode extension. I'll be sure to check back for reference. :)
One approach to managing state is to challenge the idea that you have to mutate anything at all. Functions that want to mutate the application state instead return a series of instructions on how to mutate it. Those instructions can then bubble up to the top-level, where it's safe to mutably borrow the whole state. For example, suppose we're making a 2D adventure game, and the player has some items (Zelda-style). The items would really like to mutate the game state, but they're also owned by the game state, making it difficult. Instead of mutating it, they could return something like a `Vec&lt;Instructions&gt;` that describes how to mutate the game state, and then that will bubble up to whatever actually owns the game state. Then the instructions will be carried out. This would result in code like this: ``` fn run_loop(state: &amp;mut State) { //... let changes = state.items.bow.shoot(); state.do(changes); //... } impl Bow { pub fn shoot(&amp;self) -&gt; Vec&lt;Instruction&gt; { vec![ // Get the location of the player and save it as "loc" Instruction::GetPlayerLocation("loc"), // Get the direction of the player and save it as "dir" Instruction::GetPlayerDirection("dir"), // Spawn an arrow at "loc" flying in direction "dir" Instruction::SpawnArrow("loc", "dir"), ] } } ``` There's some advantages and disadvantages to this approach. Pros: - Only one function ever mutates the state, which makes your program easy to reason about. - There's no hidden magic of `Cell`s, so there's no chance of unexpected runtime errors. - It makes debugging easier, because you can print out the list of `Instruction`s before you modify anything. - It's compose-able - chaining, filtering, and other nice properties are easy to work with. - It allows for serializable lambdas - because most of the functions on your state will be implemented as just vectors of `Instruction`s. - Mutation is actually optional - you can instead just store the instructions, and replay them whenever you need the current state. (This is the [replay log](https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying) data structure used in transactional databases, and has nice properties like being 100% thread-safe, supports undo and redo out-of-the-box, and other nice stuff) Cons: - It's lower performance than directly modifying the state of the program. - It requires you to implement a sufficiently general `Instruction` enum. This is difficult, and requires either some careful thought, or a very large enum. - Depending on what you're doing, it can require a lot of allocations/deallocations and/or large allocations.
Officialy TFS stands for TFS File System, but we all know T stands for Ticki \^\_\^.
&gt; But that's the exact same problem as someone picking an application name that is already used by another application. Not exactly the same. As a sometime application author trying to name a new application, I've frequently searched the web for other applications using a candidate name, but very infrequently search for non-application-name uses. &gt; I think if I ever do the SysDirs struct, or provide search paths, I'll go with `/etc` instead of `/etc/xdg`. That would make me sad. As (again) a sometime application author, I'd rather use a slightly-ugly configuration directory and say "follows XDG standards" in my documentation than use a pretty configuration directory and say "follows XDG standards with the following exceptions" in my documentation. I'm also not convinced that "applications have [...] voted with their feet"; admittedly I haven't researched the matter, but I don't recall reading "follows XDG standards with the following exceptions" in any application documentation I've read in the past few years. Then again, system-wide config overrides aren't that widely used these days; perhaps if they were, application authors would have kicked up more of a stink. &gt; Maybe it would make more sense to send a patch to the XDG spec mailing list... That sounds like a great idea. I'll be interested to hear how it goes.
More TWiR, mutagen and perhaps a little bit on rust. That and starting to prepare for RustFest in earnest.
You might want to look at \[rustbox\]\([https://github.com/gchp/rustbox](https://github.com/gchp/rustbox)\) 
Hey /u/_ticki, don't beat yourself up. :) Donating your time to open source is never an obligation, and deciding that you'd be happier pursuing an alternate path is an eminently reasonable decision. Do what's best for you! Thanks for all that you've done up till now (and don't fall into the trap of thinking that you've done nothing of value), and remember that you're welcome to hang out here even if you're not actively coding Rust. :)
Have you taken a look at https://crates.io/crates/ncurses?
[term-table-rs](https://github.com/RyanBluth/term-table-rs) Been slowly poking away at a library for rendering tables in CLI apps. I was hoping for some feedback and suggestions. Is this the sort of thing anyone is interested in?
Reddit doesn't use a full version of markdown, so you need to fix your code snippet by using four-space indentation instead :/
You could look at the list of crates on Cursive's [list of backends](https://github.com/gyscos/Cursive/wiki/Backends).
Is there any consideration for a standard GUI library? Neither GTK nor Qt follows Rust idioms. Conrod is a bit too game oriented. Relm is not production ready and many people aren't familiar with Elm to begin with. Any recent discussions involving the core team on this?
Hopefully gonna get around to adding events to [shared_memory](https://crates.io/crates/shared_memory). In additions to this, I will also work on the new API which will allow users to add as many locks/events as they want to their shared memory. I will also try to add read only memory functionalities so that the creator process can be sure it is the only one that has write access.
I think this is the link you are looking for: https://doc.rust-lang.org/book/first-edition/choosing-your-guarantees.html
&gt; I don't recall reading "follows XDG standards with the following exceptions" in any application documentation I've read in the past few years Just compare the amount of applications that follow XDG conventions for `$HOME` that place their system-level config in `/etc` vs. those who use `/etc/xdg`. I'm pretty convinced I'm not the only one who believes that a) `/etc/xdg` is a historical artifact and/or b) `/etx/xdg` is just plain ugly. &gt; Then again, system-wide config overrides aren't that widely used these days; perhaps if they were, application authors would have kicked up more of a stink. I would love to see more applications that would follow the same consistent rules, but I believe that the approach of specifying search paths without specifying semantics for overrides, having a common configuration formats, or providing a suitable high-level API is the worst of both worlds. In my opinion, one should either have something - low-level, e.g. like a `config:` scheme that could be built into operating systems (like Redox), where reading/writing settings was simply working with URLs; or - high-level, where the operating system comes with sanctioned high-level libraries/APIs for interacting with configuration (like macOS) that are optimized for compliance to the operating system's rules, not optimized for enabling applications to ignore rules as the convenience of application developers.
[tui](https://github.com/fdehau/tui-rs) is another great choice.
Looks like whatever client you are on escaped everything `\[rustbox\]\([https://github.com/gchp/rustbox](https://github.com/gchp/rustbox)\)`
In other words, EventSourcing and cqrs for application state?
Actually, fenced code blocks aren't part of John Gruber's original Markdown. They *are* in [CommonMark](http://commonmark.org/) (I think they originated in [GitHub-Flavored Markdown](https://github.github.com/gfm/)) but Reddit predates CommonMark and doesn't use it.
Ah, interesting, thanks for the info!
Correct, that's one way to look at it! This is also how Elm and Redux manage state. Another related idea is [algebraic effects and handlers](https://github.com/yallop/effects-bibliography).
My version shows fine. I'm on the new look of reddit. I'll fix it to work for the old look too.
I'm working on my GameBoy emulator. I started the project again from scratch, with the goal of having a nice abstraction of the components. It's in very early stage, but here's the code: [https://github.com/drgomesp/oxiboy](https://github.com/drgomesp/oxiboy). The code is inspired by other emulators written in Rust.
Hi, I'm trying to work through some cracking the coding interview questions and want to use doctests to organize things a bit nicer if I want to come back and review them. However, I'm having a lot of trouble getting the doctests to compile. Here is my crate setup (as a `lib` project): ctci-rs lib.rs arrays_strings.rs And a snippet of the documentation over the `is_permutation` function in the `arrays_strings.rs` file: /// ## Example /// /// ``` /// assert!(ctci-rs::arrays_strings::is_permutation("Hello!", "!llheo")); /// `` When I run this I get the error: ---- src\arrays_strings.rs - arrays_strings::is_permutation (line 22) stdout ---- error[E0433]: failed to resolve. Use of undeclared type or module `rs` --&gt; src\arrays_strings.rs:23:14 | 3 | assert!(ctci-rs::arrays_strings::is_permutation("Hello!", "!llheo")); | ^^ Use of undeclared type or module `rs` error[E0425]: cannot find value `ctci` in this scope --&gt; src\arrays_strings.rs:23:9 | 3 | assert!(ctci-rs::arrays_strings::is_permutation("Hello!", "!llheo")); | ^^^^ not found in this scope thread 'src\arrays_strings.rs - arrays_strings::is_permutation (line 22)' panicked at 'couldn't compile the test', librustdoc\test.rs:321:13 note: Run with `RUST_BACKTRACE=1` for a backtrace. I initially assumed that something like this would work (it is much simpler to write instead of having to namespace the function this documentation is for...) /// ## Example /// /// ``` /// assert!(is_permutation("Hello!", "!llheo")); /// `` But it doesn't work. Any ideas on how to namespace this function correctly? Are the dashes in crate names not allowed for doctests? Should I add something like `use super::*` like in normal tests? Also, is there more documentation for the tests? I found the section in the second book about them, but it only has one basic example. Thanks for your help! PS C:\Users\mhauc\ctci\ctci-rs&gt; cargo --version cargo 1.27.0-nightly (af3f1cd29 2018-05-03)
\+
yeah just notice it's the new reddit design that changed to fancy HTML editor
What kind of maths are you into? Pure or applied? Analysis or algebra?...
It's *absolutely* the developer's job to worry about this kind of thing, and calling it premature optimisation is utterly wrong. I've seen critical data loss bugs in the Mozilla email suite that went unfixed for a *decade* because it was too hard to undo all of the line-by-line file writes that were littered throughout the codebase. Nobody worried about it during development because it was "fast enough" for a blank profile, with no data, and with nothing else going on at the same time. If you had a large profile being saved to a mechanical laptop drive, the 10,000+ individual line-by-line I/O operations would trash your disk for an *minutes* to write out a few megabytes. If you don't have the time to think about how your *data* is being read and written by your *data processing application*, you haven't done your job. At all.
You can't use`-` in a namespace, rust sees `ctci-rs::foo` as `(ctci) - (rs::foo)`. Did you perhaps mean `ctci_rs`?
You can probably make it work with `use ctci-rs`, kinda like you were using outside the docs. I don't know if `use super::*` works, never tried it. Some more resources on rust docs: [Rust by example](https://doc.rust-lang.org/rust-by-example/testing/doc_testing.html) and [Rust book 1st edition](https://doc.rust-lang.org/book/first-edition/documentation.html). You can also take a look at how things are done in the [rust std](https://doc.rust-lang.org/src/alloc/vec.rs.html#302-305).
Interesting! I made the project with `cargo new ctci-rs --lib` why does cargo let me make a project with an invalid namespace? I changed the crate name to `ctci_rs` and it is working now, thank you!
True enough. It was originally a personal project, where I wanted to make my own file system (hence "Ticki's file system"), then it died out, and then I resumed it in relation with Redox.
Absolutely, that's a useful thing. Off the top of my head, some comments: - You should publish to crates.io so your documentation shows up on https://docs.rs/ - Sometimes a full table border is too heavy-weight and you just want thin borders, internal borders, or even no borders at all, just spacing - I see you're calculating the width of a cell as the number of characters; it's actually a bit more complex than that, since some characters take no additional space (like U+0308 COMBINING DIAERESIS) and some characters take more than one space (like U+FF21 FULLWIDTH LATIN CAPITAL LETTER A). Instead, you should use the [wcwidth crate](https://crates.io/crates/wcwidth) - Does your crate wrap long lines to fit in the space available? What if a cell contains multiple paragraphs? - I see you've got left, centre and right alignment; another popular addition is character alignment so (for example) numbers like "100.0" and "0.35" can have the "." line up.
I've been working on a literate-programming-style walkthrough of the Rust toolchain libraries I've been working on for [rustbud](https://gitlab.com/Screwtapello/rustbud); hopefully people that aren't interested in Rustbud will be able to use them to solve their toolchain-installation problems for themselves. I was expecting to have it done today, but it turns out that when you develop something on Linux and then test on Windows at the last minute, you find problems. Who'd have thought?
&gt; Well, you said you wanted to require that both have the same length, and you seemed to be using u8 for the length, so... yes? Not sure if I'm expressing myself correctly. My gripe was that if I were to use `Either(u8, CellKind, CellKind)`, than a "Not-Either" cell would also need to a variant that contains a cellkind, something like `Regular(u8, Cellkind)`. But that would not express e.g. what now is `Fixed(&amp;'static str)`, so I'd need `Regular(u8, CellkindForU8)`, and `OtherRegular(&amp;'static str, Fixed)`, and that gets out of hand somewhat. So the problem is expressing exactly the set I need in one enum, not too much and not to less, so that everything it statically check. It can surely be done, but I'm hesitant to add several layers of enums that build up the final one. Anyways, I realized I'm not 100% sure on the requirements of this (e.g. how often I need it, and what I'll really want to do with it), so for now I introduced a new variant `Integer_or_Blank(u8)` and will deal with it when I notice it's a problem :) Thanks again!
You can actually specify the name in your `Cargo.toml` file. Crates that deal with FFI normally have a `foo-sys` dependency, see [`rust-sdl2`](https://github.com/Rust-SDL2/rust-sdl2/blob/master/Cargo.toml) and [`sdl2-sys`](https://github.com/Rust-SDL2/rust-sdl2/blob/master/sdl2-sys/Cargo.toml) examples. [lib] name = "ctci_rs" 
I think they were asking about what the symptoms of the bug are.
You're probably using reddit's redesign. They changed the editor to something WISIWIG, but there should be a link to switch to "raw" input like before.
Actually, `-` is fine in crate names. Cargo/Rust automagically converts `-` into `_`. For example, you can use the crate [`generic-array`](https://crates.io/crates/generic-array) like this: extern crate generic_array; The crate name is actually `generic-array`, but you can import it as `generic_array`. *Bonus*: history time! Back in the days (actually not thaaat long ago), this automatic conversion wasn't in place yet and you had to include crates with `-` in their names like this: extern crate "generic-array" as generic_array;
&gt;Everywhere but GUIs everyone has appropriated/adopted some aspects of functional programming, but (again, other than Nana) everything is still expecting shit like slots and signals rather than passing lambdas around. TBF, if you were working with C++ APIs you were boned until C++11. Things are changing now because of std::function and lambda captures along with everyone (almost) moving to C++11. APIs are ditching broadcast/listener behavior based on inheritance (yuck) in favor of lambdas today, and plenty of people on the ground already have their own frameworks/extensions to their API of choice making use of all that.
Best of luck with your new ventures! Don't feel any guilt, you code and you share, and when you do it well (and don't forget to document some stuff on the way) there aren't really any obligations going with that. Also, to be captious, you can't leave Open Source. It's not a movement, it's just a method for publishing your work.
&gt; Until we can do some decent GUIs without any JavaScript shits, C++ and Java developers won't jump on the bandwagon. I might be wrong, but I think most professional C++ and Java developers are not making UIs in the first place.
I also had an issue with installing diesel for Postgres. I needed to download the Postgres libpq for the linker.
I have to say, this post is very effective at illustrating some of the benefits of Rust's ownership model in conjunction with multi\-threading. Doing the same exercise in C\+\+ would more than likely get you into the position of having to debug spurious race conditions due to, say, accidentally forgetting about the fact that your \` rng\` is not thread\-safe. However, in Rust, this is all detected upfront at compile\-time, saving you the hassle of debugging multi\-threaded code. Cool!
Yep, that's what I meant. Is there a reduced test case?
I'm somewhat sympathetic, but to take the other side, your original concerns were not ill-founded. I think part of the reason the software world is so crappy is because people decide to "get things done" rather than be more patient and get things done *right* - as in, constructing solid abstractions with actual mathematical properties that you can put real weight on, rather than have it constantly break because "you're ~~holding~~ using it wrong." This is IMO something Haskell has done really, *really* well. The core abstractions like `Traversable` are so universal and so well-thought-out, and so, *cough* Applicable &lt;_&lt;. Now, granted, Haskell is targeting a different design space than Rust, but none the less, lots of other languages have targeted Haskell's "use space" (garbage-collected runtime) like Java/C#/etc., and they just do it... wrong. Their abstractions have no proper foundation, stuff doesn't compose, code isn't reusable or reasonable in any formal, mathematical way. I followed Rust closely throughout its beta period, and honestly, it does feel like some stuff was just done kinda sloppily because "we need a solution" more than "we need the *right* solution" - one of the major examples that just came up again in the sub a couple days ago is the inability to actually create non-leaky abstractions due to the inability to properly construct semantic linear contexts in Rust. You just have to keep re-quantifying over more and more lifetimes the more you "abstract". That's a serious design flaw that should have been solved before the language was ever released (and was something that was brought up wayy back then, too), but... not enough people cared, and now, the language will probably be stuck with this problem forever. And it's not an insignificant problem. In any case, best of luck in the Ivory Tower.
True... I just got the impression that it's overkill for what k_x90 wants.
Thanks! That is what I was trying to convey :)
I [finally](https://github.com/iliekturtles/uom/commit/224db4162896ee42e15b8f151de073cb52042237) made some progress on [long](https://github.com/iliekturtles/uom/issues/52) compile times in [`uom`](https://github.com/iliekturtles/uom) (type-safe zero-cost dimensional analysis). `cargo build --all-features` dropped from 1137.24 s down to 28.68 s! The issue is private type aliases (`type V = f32;`) of public types. Making the type alias public fixed the issue. This week I plan to submit a report upstream as well as review PRs from /u/Aehmlo.
I think the silver lining here is that we need people like you working to reform math from the inside. Intuitionism was right all along! Down with the law of excluded middle as an ambient assumption! Down with uncomputable math!
I mean, you're not wrong.
&gt; I would expect applications that fully follow XDG to read their configuration from /usr/share, and not leave any traces in /etc. I'm unsure why you think that configuration would be stored in /usr/share, that's neither expected not done, nor an existing standard. Not even XDG suggests this, otherwise this directory would be listed in `XDG_CONFIG_DIRS`. &gt; Unfortunately, I can't imagine how such a thing would work. https://crates.io/crates/config seems to work reasonably well. &gt; One thing I do know is that every such system will need to start with a list of potential configuration locations, and that's system I can imagine and could build, and it seems like an important first step towards building the rest of the configuration stack. Fact is that we had this for more than a decade, and the rest never came into existence. I think it's fair to conclude that it is a dead end.
Thanks &lt;3! I'd recommend joining the [codespan Gitter](https://gitter.im/codespan-rs/Lobby). We're discussing how to build shared infrastructure for language servers there. The implementation I've put together isn't particularly modular, but I intend to move towards a common codebase as it matures.
I decided that I don't really want to write an all-new CUDA framework for Rust when I could contribute to [accel](https://github.com/termoshtt/accel) instead, so I've filed a couple of pull requests there already. Unfortunately, it looks like it's kind of in that gray zone between being actively maintained and being abandoned, so I might end up having to write my own after all.
as someone doing first year math, dear god yes. Our CS school is about as open, encouraging, inclusive and positive to newbies as it comes. Our math? You feel like they are doing you a massive favor just by turning up to the lecture and reading off the slides.The tutors? Have some sympathy for them, they have to deal with first year students for 45 mins \(after they turn up 10 mins late for class\). Also, any request to be taught it in a way that doesn't assume you already had stellar math background is met with contempt. Math as a field, from my experience, is fucking disgusting. Yes I'm bitter.
I'm sad to see you leaving. Especially since I really want Redox to succeed. TFS was super ambitious project, and I was confused as to why Redox needs it that early, given the already large enough scope of work... I really appreciate your honesty about the flaws in the approach to software building that you had. It strongly reminds me of a particular [law of spacecraft design](http://spacecraft.ssl.umd.edu/akins_laws.html): &gt; 36. Any run-of-the-mill engineer can design something which is elegant. A good engineer designs systems to be efficient. A great engineer designs them to be effective. Good luck in math research, and take care!
IIRC, `chain.fold` is specialised to use two loops, and `collect`/`FromIterator` should be specilalised to use `fold`. Don't trust me on this though since I haven't actually checked the code.
For future reference, you can tell that your code is wrong right here: fn read_file&lt;'a&gt;(path: &amp;str) -&gt; &amp;'a str{ Whenever you return a reference from a function, you'll need to derive that reference from your inputs, so the `'a` lifetime has to be connected to an argument somewhere [1]. Since you didn't put `'a` on your path, you seem to be creating a reference out of nowhere. Probably, it will be invalid by the time the function returns... [1]: Technically, this is not *always* true, as you could be doing something unsafe or referring to globals, etc. But this kind of function signature looks very suspicious.
&gt; "Re-implementing Unix tools is fun and makes me appreciate the nifty tricks [..]" You're using an example of something someone did for fun and education as an argument for obligation. Surely `yes` is not the place to start improving stdout performance?
Been working on integrating steam multiplayer into my game using my bindings https://github.com/Thinkofname/steamworks-rs that i'm working on at the same time. Its been a bit of a challenge due to the way steam uses packed structures on linux but i've managed to work around that, its currently crashing on windows though.
This was landed for Firefox Quantum (57): https://bugzilla.mozilla.org/show_bug.cgi?id=1370613
See https://github.com/rust-lang/rust/issues/40787 for a workaround. Since that says that lldb works, I'm going to say this is a gdb bug, but really it requires someone who knows about OS X to investigate a bit.
&gt; and that it was demonstrated that either trusting mrustc or trusting the rust compiler would demonstrate that the rust compiler was not attacked in this manner. Is this true? Trusting either the rust compiler or mrustc plus a C compiler. mrustc compiles to C and it's theoretically possible for an exploit to be present in a C compiler which would produce the same code as a corresponding rustc exploit when it detects mrustc output. &gt; Would this have detected any similar attacks in past versions, or is it a version by version requirement? Since since a successful Trusting Trust attack on a self-hosting compiler aims to infect future compiler versions, verifying a compiler version should increase confidence in the chain of ancestors that compiled it, but can't verify them since the exploit in an older compiler could have been flawed and failed to inject itself when building a newer one. &gt; Starting from a known as clean rustc binary, why would future versions compiled with the known as clean version of the compiler need to undergo diverse double-compiling as well, couldn't people work their way from exactly the known as clean state forward rather than starting all the way back and going through the seemingly considered to be very impractical compilation process from ocaml onward, particularly considering ocaml is itself self hosted from what I hear. As I understand it, it's more a matter of it quickly becoming prohibitive to build from a known-clean version as the Rust compiler quickly starts to rely on new language features, so you have to compile many times to get from the known good version to the current source without running up against an "I don't recognize this syntax/I can't prove this is safe" error.
&gt; I do have 8 logical cores my understanding is I probably wouldn’t get any extra speed out of these You should get at least some speed. On Cinebench (a path tracing benchmark), an 8-core Ryzen gets over 10x speedup over single thread, so two "free cores". Check with `top`, does your application create more than 4 worker threads?
Thanks for all your work; it matters, whether it feels like you've been successful or not. I wish you the best in the wild wonderlands of mathematics!
That makes me think: what's the theoretical maximum performance benefit of hyperthreading? I suppose it would depend a lot on your specific microarchitecture. Newer ones seem to have lots of execution ports so it's probably possible to create a synthetic program which gets near 100% utilization. https://www.anandtech.com/show/6355/intels-haswell-architecture/8 Something with very few loads/stores, small data size to fit in cache, running very low-ipc instructions to keep the pipelines full, etc. might get you close. Would have to choose instructions very carefully and might still run into problems when the scheduler chooses the "wrong" execution port. I wish I had the time to write a blog post about this, it could be really interesting.
That, and more. "Flow" references the [Quantum Flow](https://wiki.mozilla.org/Quantum/Flow) initiative to find and fix bugs that impact user-perceived responsiveness. "Light" refers to "Photon," the codename for Firefox Quantum's visual redesign. I suspect that the "new raiment" is a reference to the "Mark 57 Power Suit" (seen in the header of [this article](https://www.cnet.com/special-reports/mozilla-firefox-fights-back-against-google-chrome/)" that served as Quantum's mascot.
This is really late, and a bit off-topic, but where do you get your music from? I've recently begun listening to such 同人音 on soundcloud, so I wondered, where do you get yours from?
I've read a little about GeckoView for Android, is there any plan to turn that into a CEF-like embeddable browser?
here’s an [overview](https://d2z6c3c3r6k4bx.cloudfront.net/uploads/event/logo/1054432/509c5c9444e5e0e6dfd1db1271ff271b.jpg) over “Mark 57”, I think you’re spot on!
&gt; And he said unto the great congregation 'Go forth, and carry in your claws and on your backs the spores of Rust into the Flooded Lands, that they might take root and spread. &gt; &gt; 'And know that you shall be feared and shouted down, but what shall those that oppose you do? Can they catch these spores in their hands? Can they still the air that carries them? No! &gt; &gt; 'For they shall multiply and grow strong with deep roots, and the lands that lie barren and cold beneath the harsh salt waters that flooded over them so long ago will bloom anew and a new dawn shall come.' &gt; &gt; -- [The Book of Rust, 10:52](https://www.reddit.com/r/rust/comments/34m7gw/i_wrote_my_bachelors_thesis_about_go_and_rust_in/cqvzej6/) 
This doesn't really answer your question, but you may be interested in the fact that Jan Nieuwenhuizen recently made some [very exciting process](https://twitter.com/JANieuwenhuizen/status/990201775335657472) regarding full source bootstraps (via C compilers of course). The way I see diverse double-compilation it reduces the *likelihood* of a trusting-trust style attack, but doesn't eliminate it (though making it exponentially harder, esp. across language boundaries). Last time I checked `rustc` itself also still had some bit-for-bit-reproducibility issues, but they sounded like minor things. Maybe someone who knows more about that could chip in here.
I looked into it, I think `path_ptr` is guaranteed to be not null if the method returns. I added checks to make sure that the method returns successfully, though. I also replaced `length_of_u16_string` with `lstrlenW` as you suggested. Thanks!
First, don't test 'if crate name is read_line'. That kind of testing is sometime necessary in Python or other languages, but there is no reason for write tests for compilation failures in rust. They could never fail, since they won't run if they don't compile. Secondly, you shouldn't 'expect' in library code unless you're very sure that it should never happen. Otherwise you crash any binary using your library, and the binary may not know why. You should return a 'Result' instead. Lastly, you're not really creating two strings. The allocation should only happen once, so what you're doing is fine.
&gt; 'And know that you shall be feared and shouted down, but what shall those that oppose you do? Can they catch these spores in their hands? Can they still the air that carries them? No! Clearly in reference to the borrow checker. :)
Got it. The given example is a bad one btw. Do you know any idea how to write tests on terminal based apps, ex. mocking inputs? 
https://github.com/assert-rs/assert_cli
Well, [`std::io::Stdin`](https://doc.rust-lang.org/stable/std/io/struct.Stdin.html) implements [`std::io::Read`](https://doc.rust-lang.org/stable/std/io/trait.Read.html), but doesn't implement [`BufRead`](https://doc.rust-lang.org/stable/std/io/trait.BufRead.html) (which provides a [`read_line`](https://doc.rust-lang.org/stable/std/io/trait.BufRead.html#method.read_line) method). Having said that, [`StdinLock`](https://doc.rust-lang.org/stable/std/io/struct.StdinLock.html) implemented `BufRead`! And you can get it with a [`lock`](https://doc.rust-lang.org/stable/std/io/struct.Stdin.html#method.lock) method: lib.rs: ``` use std::io::{BufRead, Error}; pub fn read_line&lt;T: BufRead&gt;(reader: T) -&gt; Result&lt;String&gt; { let mut string = String::new(); reader.read_line(&amp;mut string)?; Ok(string.trim().to_string()) } ``` main.rs: ``` extern crate your_crate_name; use std::io; fn main() { your_crate_name::read_line(io::stdin().lock()).expect("Can't read a line!"); } ```
I've been playing in my spare time with a prototype of GUI written from-scratch in Rust, intended for [xi-win](https://github.com/google/xi-win). My prototype has an Entity-Component-System architecture, and I'm pleased with the way it's turning out; it feels like the code is about as clean as any UI toolkit I've used. I intend to blog about it (especially the way the ECS ideas make it possible to almost entirely avoid `RefCell`), but have been having difficulty juggling time.
Interesting, switching my spheres list from AoS to SoA should improve my cache utilisation so perhaps I'll see a more noticeable difference with and without hyperthreading then.
&gt; The allocation should only happen once, so what you're doing is fine. Is this just a common optimization? Is there something that documents this?
Thank you for the links, I didn't know about those. It seems to me though that those exist to kind of get around the borrow checker, and reference counting/read-write locks are exactly how I'd handle the problem in C++. My issue is that I'm learning Rust in order to not write C++ and to rethink architecture, so I'm curious if there are more idiomatic solutions that don't sidestep the borrow checker, but I could be wrong about that. 
In what ways can I add locking to a rust binary such that only on of the instance can be running at a time... well, such that only one invocation of the binary can hold the lock at a time. Is there a convenience method for that?
Is there a simple way to spawn an orphaned processes? My use case is a git update hook (server side). I'd like to have it return right way, but do some work after exiting. From what I understand, I'd have to fork a process in the background without calling wait... is that right?
Wow that’s unfortunate! At my school I only took a few math classes as part of the computer science curriculum, but I also acted as a TA for a precalculus class (some students’ high school education isn’t that great, and algebra tends to be the hardest part of calculus for students, so the school started offering a precalculus class) and all the teachers I got to know were very nice.
I don't know. I do know that at one point Servo itself made it a goal to be drop-in CEF-compatible, but I don't know how high of a priority it is, to say nothing of the fact that Servo alone is still far from standalone production-readiness.
Nice write-up! Semi-offtopic question: why'd you write your own vector math instead of using an off the shelf crate?
Thanks
Thanks
This is something I've spent a bunch of time on-and-off for the past year and a half scratching a personal itch at work. I'm thrilled to finally be able to release it publicly (thanks to Square for being so supportive in this). Long story short, it's how we implement dual control for `sudo` at Square. If someone `sudo`s to a privileged user or group, this plugin requires them to find another engineer to approve the session. That engineer will then see a live mirror of everything that happens during the privileged session. Technically, it's surprisingly simple: sudo has a plugin mechanism which allows you to log all terminal I/O, and the "meat" of it is basically just copying all I/O to a socket and `socat`ing it on the other end to display to the second engineer. The rest is all just enforcing security constraints, exposing the [`sudo_plugin(8)`](https://www.sudo.ws/man/1.8.22/sudo_plugin.man.html) facility in a Rust-like wrapper, parsing all of the hundred-plus fields of metadata sent to the plugin by `sudo`, and wrapping it up in a bow so I can share it with you guys. Please give me your feedback! This is composed of three separate: crates: `sudo_plugin-sys` (the raw bindgen-generated FFI bindings), `sudo_plugin` (the hopefully-idiomatic Rust wrapper around these bindings to ease the writing of plugins), and `sudo_pair` (the plugin itself). The first two are complete enough to be released as 1.0, but I've left the plugin at an 0.9.0 prerelease—we're happy with it, but I want to solicit feedback from the community and others who want to use it before officially stamping it as 1.0.
A bit more advanced way to mock stdout: https://users.rust-lang.org/t/how-to-send-a-writer-into-a-thread/4965/10 (I think stdin should be even easier)
Currently, I am programming the innards of a filesystem. As of now, my approach is to have a single instance requiring `&amp;mut self` access when, for example, opening or creating a file. The state of files is modelled as a finite state machine, in a manner similar to what /u/formode (aka hoverbear) wrote here: [https://hoverbear.org/2016/10/12/rust-state-machine-pattern/](https://hoverbear.org/2016/10/12/rust-state-machine-pattern/) For linking parts inside my state struct, I resort to `usize` indices into the `VecMap&lt;_&gt;` where the One True Instance lives. This requires manual pointer-chasing but can be replaced by more sophisticated code if found to be problematic later on. Also allows trivial serialisation. So modifying the global state is done only through one instance of my filesystem, locked against concurrency by requiring `&amp;mut self`. Since one often acts on subsets of the global state at a time (like writing to *this particular file*), I plan on handing out Containers linked to the filesystem but able to fulfil necessary functionality on (a thread of) their own. To do this, I would use the appropriate `Arc`s, `Mutex`es etc. inside my `StateSubset` struct. The corresponding elements inside the main state would be put into a state reflecting them being lent out in some way. Due to awesome ownership semantics `StateSubset` could even have a `release(self)` doing this explicitly and by consumption making it a state transition verified to be safe at compile time. Not sure if this is helpful, I was just reminded of some struggles of my own. If you only care for serialisation at runtime (non-persistent), look at [Abomonation](https://github.com/frankmcsherry/abomonation). Just be appropriately careful, it involves black magicks!
Just so you know the rust discord server is actually doing early speculation for a "rusty" gui library. We have a channel with active discussions. I personally am planning on doing some research this summer on how other languages work with GUI, and how that might translate to rust. The nice thing is that there is a lot of basic groundwork, cassowary (AFAIK) is a constraint solver that works, WebRender exists for fast GPU painting. There are tools out there that allow for experimentation. 
Nice! I'll have to play with this, could be useful at work.
As someone who makes systems that push network packets as 8x100Gb/s, I care about every single instruction my compiler emits, and every single micro-op that is emitted by the instruction decoder. However, optimizing stdout is usually premature optimization (applications that use stdout as primary output—not logging!—and is bottle-necked by it being the exception), and your examples of issues only applies to file handling, not stdout. Oh, and awful test practices. Testing should involve absurdly exaggerated data at *every* input vector to shake out issues.
Hopefully this is simple, I'm not even really a rustacean yet, if anything, I'm much more comfortable with C or C++, and I've got this interpreter I'm working on. Memory leaks and other such fun are getting in the way as it continues to grow, so I'm looking at rust as a language to move it to before it gets much more complicated, this is a very small section that I've attempted to translate: use std::rc::Rc; #[derive(Clone)] enum StackCell{ StackStr(Rc&lt;String&gt;), Number(i32), Fnumber(f64), Svar(i32) } struct StackStack{ data:Vec&lt;StackCell&gt; } fn str_concat(s:&amp;mut StackStack){ let y=match s.data.pop(){ Some(x)=&gt;match x{ StackCell::StackStr(r)=&gt;r, _=&gt;panic!("Ack!") }, None=&gt;panic!("No stack element there!!!!") }; let x=match s.data.pop(){ Some(z)=&gt;match z{ StackCell::StackStr(r)=&gt;r, _=&gt;panic!("Ack!") }, None=&gt;panic!("No Stack Element!!!!") }; let f:String=(*x).to_string()+&amp;(*y); s.data.push(StackCell::StackStr(Rc::new(f))); } fn main() { let mut m:StackStack; let mut x:StackCell=StackCell::StackStr(Rc::new("Hi ".to_string())); let mut y:StackCell=StackCell::StackStr(Rc::new("you".to_string())); m.data.append(x.clone()); m.data.append(y.clone()); } 
How do you handle emergency situations? Let's say I'm on-call, and I *need* sudo, right then and there, to do my job. I think I might prefer a combination of shipping execution + sudo logs off of the box ASAP, as well as DUO 2FA for the sudo. This way an alert can be triggered from the logs and the eng *must* auth the escalation. This looks very interesting, and better in regards to insider threat oversite than my proposed solution, but I am curious about those emergency situations and how you'll handle them. Glad to see Square exploring cool approaches like this, as well as the interest in rust.
This was news to me - Thanks!
I'm open sourcing my fledgling MMO game engine. https://github.com/SiegeEngine . I've had to extract my game from the engine, so this has left the API a bit rough around the edges, especially regarding networking. I have yet to add an example 'stub' game and high-level documentation, so it might be a bit early to try to use it. The https://github.com/SiegeEngine/siege-engine-docs/blob/master/FAQ.md has more info.
At Square, we actually allow users to approve their own sessions (this is demonstrated in the gif) and log this event in such a way that an oncall infosec person is paged immediately. Users know not to do this except in case of emergency. The [logic for this](https://github.com/square/sudo_pair/blob/master/sample/bin/sudo_approve#L75) is currently in the approval script. However, I intend to make this a (configurable) [responsibility of the plugin itself](https://github.com/square/sudo_pair/blob/master/sudo_pair/src/lib.rs#L133).
Ah, I glossed right over the gif.
Yep, that'll do it. Thanks.
You can create `Color` as a wrapper struct for `Vec3`, and use a `Deref` implementation, which effectively models inheritance for the use case you're describing. You can read about `Deref` here: https://doc.rust-lang.org/std/ops/trait.Deref.html.
Thanks for the reply. I would like a more general solution. In this case this will work. But suppose that i have complex implementation of a container and i just want two types that only change the getter names, for type safety.
Thanks! Wouldn't then both the x,y,z methods and r,g,b methods be visible?
Yes. If you would like, you can refactor the shared methods into a third type, and then make `Vec3` and `Color` both `Deref` to that type.
What can I do to make the gif more compelling to watch? It really explains almost everything you need to know in about thirty seconds, and is what I envisioned being the thing that catches people's interest.
I share your excitement and enthusiasm for Rust and I'm very interested to hear your experience, especially because I have no experience with enterprise software. But there are some things in this article that feel very off-putting. There are a lot of spelling/grammar mistakes. I'm uncomfortable listing them here because I don't want to seem like an ass, but you should probably take another pass over this for such mistakes (If you're a non-native speaker I'm willing to help out on this). &gt; Among my previous predictions: This sounds like you're just trying to show off. I already want to read what you've written! &gt; It is a compiled low level language that often outperforms C. I am very wary of any claims of performance differences between *languages*. If you've got some benchmark or program you'd like to point to here I'm interested, but this kind of statement will _really_ rub people the wrong way if you're trying to sell Rust as a technology because it's very easy to produce benchmarks to the contrary. You keep referring Rust to a functional (or almost-functional) language. I've no experience with such languages, but I wonder how that sounds to any other commenters who do. I'm a bit disappointed not to hear anything about your personal experiences with Rust. Have you started using Rust at Futurice? Or talked to people there about the technology?
I rarely watch gifs in readmes unless they're just a few seconds long. The problem with gifs, and this gets worse with longer gifs, is that if I miss something... that's it. Gotta wait for the gif to end, and then get back to where I was. I also can't just pause and read, look at the screen, read something else, and come back. So I generally assume the information is duplicated in text and just read that. Looking at the gif now, it's a solid walkthrough.
Copy the text into your readme. It's easier to read text in-browser, especially for those with bad (or no) eyesight
So if I wanted to gain access without the partner knowing could I just paste something in that would run my command and then reset the terminal screen to the prior state? Obviously you have to trust your employees somewhat, but I wonder how much security value this actually has.
&gt; Reading the code, it looks like it's all using a ton of unsafe code. This is kind of unavoidable. The underlying plugin mechanism calls an `extern C` function with a bunch of raw pointers, and fundamentally anything that implements this is going to be unsafe (the code that parses these options is [well-tested](https://github.com/square/sudo_pair/blob/master/sudo_plugin/src/plugin/option_map.rs#L121)). The only part of OptionMap that is unsafe is the `from_raw` call that accepts the raw pointer arrays as passed from sudo. And there's actually not much I can do to ensure safety here: option arrays are NULL-terminated, and there's no other way to determine their length besides walking through and looking for NULLs. From the plugin-implementor side of things, everything should be safe. Note that there's no unsafe code in [the plugin implementation itself](https://github.com/square/sudo_pair/blob/master/sudo_pair/src/lib.rs) (excluding the sockets part which, again, fundamentally has to interact with the OS via calls to `libc`). Even where the plugin implements its own set of options to parse, [there's no need for unsafe code](https://github.com/square/sudo_pair/blob/master/sudo_pair/src/lib.rs#L500), since you're already dealing with a parsed `OptionMap`. Please let me know if I've missed anything. I've tried my best to provide safe interfaces to the underlying functionality, but there's a lot of ways in which my hands are tied here.
As much as I love rust, I can't help but disagree with most of what is said in the article. When I hear "enterprise service" I tend to think "IO bound application," or perhaps as it relates to rust "*not* CPU or memory bound." One of the assertions made is that the compiler does more to enforce correctness, and therefore testing isn't as much a necessity. The problem with this argument is that the truly novel things that Rust's compiler does, which is to guarantee memory safety, aren't relevant in garbage collected languages. It doesn't make rust more correct in any other regard, and it could be argued that the constraints enforced by rust can actually hurt productivity if you're not memory/CPU bound. An ideal language for IO bound services IMO would be something like F#, which has all the goodness of discriminated unions, pattern matching, garbage collection, async/await (and web frameworks that support it top-down), good tooling, debugging, etc. 
Have you considered using [asciinema](https://asciinema.org/) with tmux/screen to show both windows? It's pretty nice to use.
Cool, that sounds all good. Just was glancing at the code.
I’m not the OP but when I was doing a similar thing, I wrote my own vector math as a learning experience. Probably not as good as a public crate but good enough. If I were to continue my project in any serious manner I would convert to one of the public crates for this. 
The gif is fundamentally about an interactive session. I'm not sure that just copy-pasting text really helps convey what's going on.
I'll check it out. Can you tell me a way in which it would be an improvement over the existing gif?
useful != powerful, fwiw - both are very subjective terms though
Agreed, but these features aren't unique to rust. You could make the case that Haskell does more for overall correctness than rust.
&gt; So if I wanted to gain access without the partner knowing could I just paste something in that would run my command and then reset the terminal screen to the prior state? Yes, it's possible. But this raises the level of premeditation for something like that to happen (e.g., discouraging so-called crimes of convenience), and it also does a decent job of stopping someone who's gained *illegitimate* access to an employee's account, since they'd need (in Square's case) to also hijack their Slack account, and even then an outsider is typically going to act very differently than a real employee, simply due to unfamiliarity with the systems they're on. Like most security tools, this is simply meant to make it harder for someone to attack your infrastructure, not to prevent it entirely. It also has non-security benefits in that a pair can monitor what you're doing and interject if they see you're about to do something incorrect. Or if you clear your terminal out of habit during a roll-plan and later wished you still had the output from previous commands. Or if something goes wrong during a roll-plan, and you want to play back the session later to see exactly what happened.
Have you looked at [`std::process::Command::spawn`](https://doc.rust-lang.org/std/process/struct.Command.html#method.spawn)? There are some higher level libraries out there, but there's a good chance that does all you need. Note that if you _never_ wait on the child, you'll leak zombie processes, and eventually your system will run out of PIDs. That matters if the server process you're writing is long running.
Thanks, really appreciate for your feedback. In speed to publish I did not wait for much proofing, but I've edited a bit and hope that addresses the worst of the pain points. Specifically I removed the ego\-statements about "my predictions", added some personal experiences at Futurice, perspective against other languages which are still more popular with our broader audience of consultants and some links to benchmarks. Rust is not "purely functional". My intended audience is more IT managers with enterprise applications and probably not the core of r/rust so I try not to go too far into that rabbit hole. Simply put, your code is functional if you choose that style, and the default style will guide you toward functional extension of traits \(think "Java interfaces"\) over extending objects \(which is not support\) but the language itself is multi\-paradigm and pragmatic about such things.
Maybe use an ASCIIcast instead? Then it's copy pastable
&gt; It's not clear that Rust is even a good choice for GUIs. You could spend years making the best-possible Rust GUI library and still end up with something that's worse than py-qt or Xamarin. What do you think of this project? https://www.vandenoever.info/blog/2017/09/04/rust_qt_binding_generator.html
No, not at all - I really only skimmed and wanted to throw it out there. Your post was thorough, and I appreciate it. At work, so I couldn't really delve into it.
&gt; My issue is that I'm learning Rust in order to not write C++ and to rethink architecture, so I'm curious if there are more idiomatic solutions that don't sidestep the borrow checker, but I could be wrong about that. Personally, I wouldn't think of these as "sidestepping the borrow checker". I consider these safe fundamental tools/patterns provided by the standard library of the language. What rust provides is freedom from data races, null pointers, and use-after-free errors, and others. You're still writing a program at a low level. &gt; Especially when it comes to undo/redo behavior, where managing global mutable state (and some kind of undo/redo-manager) across threads is a nightmare and I'm not just concerned about race conditions. The way that rust might help you here is with a library that someone has written and published on crates.io to manage global state. This wouldn't be something that's part of the standard library. Does such a high quality library already exist? I'm not the right person to ask.
Interestingly, I’ve been having the opposite problem. Debug builds work fine, as do release builds on all targets except thumbv6, where I get a linker error. I’ve just started using an earlier nightly as my default until they stabilise a bit.
Yes it did. These are called reproducible builds, though this overloaded and is also used in the context of cargo to refer to library version pinning. In this context it is forensically reproducible builds I suppose. [https://users.rust\-lang.org/t/testing\-out\-reproducible\-builds/9758](https://users.rust-lang.org/t/testing-out-reproducible-builds/9758) Shows a colored chart of the current progress Rust has made toward forensically reproducible builds, and discusses the matter. 
I just used this and wanted to give you a shout out. Also wanted to mention that the Rust compiler is pretty dope offering relevant suggestions. It's the first time I read a compiler error and didn't have to Google what the heck it means. 
I don't think modern systems are "IO-bound" all that often. IO bandwidth tends to be abundant for typical workloads, especially with the widespread adoption of things like GigE and 10GigE network connections, or fast SSD/Optane storage connected to the PCI bus. By contrast, CPU-memory bandwidth can be a very significant bottleneck, which impacts both "CPU-bound" and "memory-bound" applications.
Rust is certainly partially supporting of the functional paradigm just as it is the object oriented and procedural paradigms at the least. Rust was the first functional language I learned, though not the first language with declarative constructs seeing as I'd used cargo, make, and SQL. Learning functional programming as a paradigm helped me to think in SQL even, but it certainly helped me to think in Rust as Rust supports many of the elements of function programming, including Option\&lt;T\&gt; and Result\&lt;T\&gt;, .map\(\) .filter\(\) and friends, and first class functions and higher order functions, it is clearly quite functional in flavor. However, I do not believe any benchmarks I've seen showed Rust as outperforming C. According to benchmarks I have seen, Rust performs sometimes better than C\+\+ but if it does better than C \(on common compilers of course\) at all it will be very rarely/ This is entirely to be expected given the increased computational cost of some of the Rust run time security checks. Perhaps unsafe Rust would approach C more so. The benchmarks I have seen don't mention whether the implementations used safe or unsafe Rust but unsafe Rust can be notably slower than safe Rust and may be closer to C and further from C\+\+. The benchmarks I have seen left me with the impression that C is both more time and memory efficient than Rust, however Rust may is nearly neck to neck with if not taking the lead from C\+\+ for time efficiency, though it is substantially less memory efficient than C\+\+ \(though this can be substantially configured by people experienced with compile time options, if features of Rust can be sacrificed, and the benchmarks I have seen haven't mentioned how tweaked for benchmarks the programs were\). However, Rust is generally shown as being much more time efficient and notably more memory efficient than Java is, with a memory footprint between C\+\+ and Java \(with a good deal of space separating each\). So in general benchmarks are indeed hard to take seriously, but it is possible I believe for them to give some sense of the matter and to have some empirical data of the performance of applications implemented by users of the languages, presumably who are trying to do fair comparisons and who know each language substantially. Despite this, the assertions this individual made are not in accordance with the benchmarking data I have seen.
There is room to disagree, of course, and that is part of the run of Reddit. I wrote in broad strokes, perhaps too loosely for this audience, but in an attempt to amuse those less interested in hearing the details to take a look at the impact Rust can have in enterprise apps. .."aren't relevant in garbage collected languages." We had an interesting case in Futurice \(I'm from the Helsinki office\). A very experienced team in London was using RX Java on Android made a great app for a client. A huge app with many features. But they faced some performance issues which took months to dig through with the nasty of low level tools most of us have never had to touch and hacks. As I understood the core issue had to do with RX lifetimes mixed with non\-deterministic collection of large media and other objects by the garbage collector. A talented team made mistakes, GC and non\-traced global resource asyc side effects matter at both ends of the scale, and this is just one of many examples. My point is just that garbage collected languages suffer in the real world and the difference can be very relevant. I simple want to inspire an IT manager to take a closer look at Rust, and hopefully they as a team can separate the lower need for testing from the benefits of more deterministic resource handling as appropriate in their context. F# is a fine language in cases where the team prefers that. I chose not to go too deep on async code in Rust as the article is already a bit long as most enterprise apps will use a framework that does that behind the scenes. I added some benchmark links to assist readers new to the point. IO bound is an interesting point, the benchmarks show there are some real world differences. I searched but could not find the nice blog post where a server developer dropped memory use to 1/3 when shifting to Rust\- perhaps someone else remembers and can link that.
Good question. A couple of reasons - * I had a simple math library I'd written for another project * I've tried a couple of off the shelf ones (cgmath and glm) but wasn't entirely happy with the ergonomics or either of them so thought I'd try roll my own and see if I could come up with some I was happy with. glm is inspired by the popular C++ glm library which in turn is inspired by glsl's math. It doesn't seem to be actively maintained. cgmath I'm actively using in another project but there's a few things I personally want to do differently, off the top of my head: * Generic - I'm using 100% f32 so having to type Vector3&lt;f32&gt; in every struct is cumbersome * I like the glm/glsl/hlsl style free functions for things like dot, cross, normalize mul etc. cgmath has a few of these but not all of them * at some point cgmath removed component wise multiplication and division (e.g. vector * vector) which are useful (looks like they got added back again) * It has a proliferation of traits which I think are maybe useful inside cgmath's implementation but are confusing for users of the library (well me anyway) so in short, i have simple requirements so far, I want the flexibility of being able to try different ideas out with my vector math lib and am quite happy to roll my own. 
Because it isn't always invalid, just most of the time for most people.
The way short\-lived data flows through the stack and registers is a subtle point. As others have shown Rust is seldom faster than C, but to be in the same game with so much useful abstraction is a win. See [https://gist.github.com/jFransham/369a86eff00e5f280ed25121454acec1#keep\-as\-much\-as\-possible\-in\-cache](https://gist.github.com/jFransham/369a86eff00e5f280ed25121454acec1#keep-as-much-as-possible-in-cache) *"This is why you may have heard some complaints about Haskell's use of a linked list of characters to represent a string. I'm not going to beat* [*gankro's wonderful rant on the subject*](http://cglab.ca/~abeinges/blah/too-many-lists/book/#an-obligatory-public-service-announcement)*, but suffice to say that this is more\-or\-less the worst possible data structure to choose when each individual element is small and the number of elements is large, because it needs to store a pointer for every element, instead of a single integer for the entire array."* I understand Scala is not much used on Android because the extra layer of indirection and heap orientation inherent in the language drag performance down. High end server CPUs may be able to brute force past much that, but phones get a bit boggy with the extra work.
The lifetime checker and &amp; vs &amp;mut actually do a lot more than most GCed languages do. For example, all the GCed languages I know don't stop you from manipulating the same objects from different threads with no extra annotations. Sure, these manipulations won't lead to memory unsafety, but they could easily cause higher-level data corruption and race conditions. Rust forces you to think about how you want to enable concurrency, either by only sharing read-only references, or using mutexes to share r/w access.
That seems legit to me 👍🏼 Overuse of traits and genetics are what made me do it too. 
May want to leave a comment outlining what you've tried &amp; give context for this code
Do they really have that much common code? I'd imagine `Vec3` would have mostly linear algebra stuff. Are the same functions - with the same names! - useful for `RGB`?
I think only a few enterprise apps /service are cpu or memory bounds, only the critical ones are. In my experience for the very large majority of software developed for internal use (like most Java/c#), they are just an answer to a problem at hand, not the best but just the most practical one (historical reason, developer familiarity ...). I agree with the article that rust can potentially be a game changer here. You really have to think hard at your code before it compiles. In the very large majority of case you end up with a better design, more robust, faster. I agree that I trust very young rust crates a lot more than some much older and widely used packages in, say, nugget. Because it is harder to get it wrong and to compile at the same time.
I'm not sure how to remove it, but I can explain why it's needed: * The trait `Streamer&lt;'a&gt;` requires `Self::Item: 'a`. * `OpWithStateBuilder&lt;'_, T&gt;::push::&lt;_, S&gt;` requires `S: for&lt;'a&gt; Streamer&lt;'a, Item=(&amp;'a [u8], Output, T)&gt;`. This means that `S::Item`, which includes `T`, must outlive *any* lifetime, including `'static`. * Therefore `T` must outlive `'static`.
How do I enforce abstractions in other ways? Can you elaborate?
Don't get me wrong. Some of the staff are actually amazing \(but like i said, im a bit bitter\), but I can only think of one or two that doesn't have that elitist attitude and treat their course like a filter rather than a place to educate. I've come to see that math education in australia is genarally pretty toxic that way.
Indeed, and you can add Elm to that list too. The point here is that when talking about ideal languages for IO bound services, you could say that garbage collected functional languages are a pretty ideal mix of convenience and correctness. 
NLL is implemented and the bugs are being ironed out on nightly. OP's code compiles under `#![feature(nll)]`. Until that progresses you can use my old macro [`unborrow`](https://crates.io/crates/unborrow) for this case. 
Rust should be no less convenient than a garbage collected language, due to the static analyzer managing RAII destructor style frees tied to the scoping system. There are also Arc and Rc types for reference counting, I mean in practice it virtually is garbage collection it is just done with static analysis rather than a run time garbage collector, which is actually superior for performance and allows for use of it in exact timing sensitive or otherwise constrained applications that run time garbage collection is unfit for. 
can u show some code? :)
Any idea how hard it is to port LLVM? Personally I would love to see Xtensa support (esp8266/esp32). But the RISC-V guys seems to take ages to get their stuff into mainline and they where university researchers rather than hobbyists.
Certainly. If you're on Windows, check out [xi-win](https://github.com/google/xi-win), go into the `xi-win-ui` subdir, and do `cargo run --example calc`.
Is your code public? I'd be interested in seeing different approaches :)
I’ll take a look, thanks!
Sure, but gifs also aren't screen reader friendly, either. 
Rust has weak reference counters that can check at run time to ensure a lack of reference cycles. They simply will produce a panic if used incorrectly. A primary issue with Rust may be in how difficult it is to learn it thoroughly enough to see the new ways that familiar concepts were implemented in it. Rust pulls the guts out of things like Java and offers you the ability to make your own performance trade offs. In return for a nasty learning curve and the need to keep track of many things \(to aide static analysis\) that would otherwise not have mattered \(due to it being done dynamically\), you can make a trade off between things like protection from reference cycles and performance. Maybe there are other examples where dynamic garbage collection is capable of doing something static garbage collection can't do, but it is not going to be the reference cycles issue I believe due to WeakRc types that can prevent reference cycles with a run time performance penalty and potential to crash. I suppose that actually avoiding this potential to crash during run time due to neglecting to check return values and unwrapping is a benefit of the 100&amp;#37; automatic dynamic garbage collection. 
Ah, I mis-remembered the `/usr/share` thing, sorry. I'd been having discussions about data-file fallbacks in other venues and just assumed config files did a similar thing—but of course, configuration usually falls back to compiled-in defaults, not a external file on the filesystem. &gt; https://crates.io/crates/config seems to work reasonably well. I can't find any documentation about how merging works, which is annoying. Let's say I wrote an application whose default config included a list of hostnames; how would I write an override config that inserts a new hostname at the beginning of that list? Also, I can't find anything in the source code where it looks for a config file in a list of directories; if you give it a filename it seems [to look only in the current directory](https://github.com/mehcode/config-rs/blob/master/src/file/source/file.rs#L32). If some other library provided a platform-native prioritised list of config paths, it should be easy enough to glue them together.
Why do you not think Box is the best way?
Box is right way to do this kind of thing.
That sounds like a pathological case in the compiler. Is there a rust bug against this?
Or at least allowing it as opt-in. That's what npm does, and that's one of its pros.
Most of the heap\-managing structures in Rust are intended to cover specific use cases for dynamic memory \-\- what use case do you have that \*isn't\* covered so far?
`euclid` may or may not be interesting as a more down-to-earth math crate.
The trait can be generic and handle complex implementation https://play.rust-lang.org/?gist=4788a4d04b13c4aea49091311f0fe792&amp;version=stable&amp;mode=debug 
???? why!?????
In this case the derive_more crate can handle a lot of the boilerplate for you. 
This looks awesome! Not sure if this is a feature I missed in the README, but it would be really nice to have the option for the supervising engineer to approve commands before allowing them to be sent to the sudo session (with a whitelist of definitely-safe things like `cd`). From what I'm reading though it sounds like that would require a major architecture shift though.
That's a higher-rank type bound (HRTB). It basically allows `S` to refer to some arbitrary lifetime that is not relevant to the surrounding type.
Are `Box::new`, `mem::drop`, and `mem::forget` not enough to handle all heap allocations?
Can rust perform well 'naked' on the web? One thing I noticed is that even Go programs are recommended to be behind another web server \(to deal with socket problems\). I know Nginx and Apache are nice, feature\-full and peformant, but I have thought that the problems that other languages have with servers is around concurrency and that these problems can be easily avoided with Rust.
Is there anything stopping someone from quickly running a script that adds an iptables rule to redirect traffic to the paired admin to localhost and just ignore it? Or inject fake logs and make it look like they're inspecting an /etc/ config? I guess if someone really wanted to they could write a script that installs a privileged suid root backdoor or even ring 0 backdoor, then overwrites itself to look benign. Just get the sudo approved, run `./completely_normal_migration.sh` and say "All good! Ran my data migration. I don't need sudo anymore." In the end I don't think this could be anything more than making sure trustworthy people know their sudo activity is monitored so they're just a bit more careful and restrict it to only when they really need it. That's just the nature of the problem, not anything to do with your program or how it works.
Adding to retra's comment, a quote from the [nomicon](https://doc.rust-lang.org/nomicon/hrtb.html) &gt; for&lt;'a&gt; can be read as "for all choices of 'a", and basically produces an infinite list of trait bounds that F must satisfy. Intense. There aren't many places outside of the Fn traits where we encounter HRTBs, and even for those we have a nice magic sugar for the common cases. 
You could just write a script that installs a suid root program and overwrites itself, call it "data_migration.sh" and that's that. There's no added security value when it comes to preventing attackers from abusing root. It's great for monitoring people to make sure they're careful, but there's very little security value if any. You have to trust them.
Dealing with Weak&lt;T&gt; and Rc&lt;T&gt; and whatnot is more difficult than dealing with (a.k.a. ignoring) a stop the world garbage collector. Making sure to follow the rules of ownership and borrowing is harder than letting everything alias without temporal constraints. In that way, Rust is more inconvenient than a stop-the-world garbage collector.
I think everybody realizes this, but just in case: changing the implementation of `foo()` to be let member = self.member; self.bar(member); will make the borrow checker happy until we have fancier machinery.
I have to agree with the other comments. Box is the correct way to do this, given the example provided. If you're regularly dereferencing raw pointers like that you most likely have a design problem with your code, or are [fighting the borrow checker](https://m-decoster.github.io/2017/01/16/fighting-borrowchk/). Do you have a specific use case where this functionality is needed?
This has not been a problem for me, but if you have some C code you are calling that takes a destination buffer pointer, won't that buffer be initialized first by Box::new and then overwritten by the C code?
Good point.
If you have a struct, and you just want a Weak reference to it. (i.e. no ownership) is it ok to make an Rc via Rc::new then downgrade it and finally try_unwrap()ing the Rc? Will that ensure my Weak reference will always be valid as long as the original struct is around. The reason I want this is that I want to refer to a parent struct from a child struct. 
It is not. Proof: The type checker is guaranteed to terminate. Hence it can not simulate all Turing machines.
Thank you for your efforts Ticki. Mathematics is beautiful, I wish you all the best in your future endeavours.
I'm not sure what you're asking here. You get a `Weak` by calling `Rc::downgrade` on an existing `Rc`. If you call `Rc::new`, you get a completely new allocation that has nothing to do with the old one. When you call `Rc::try_unwrap`, it returns the contained value if there is exactly one `Rc`, and invalidates the heap allocation. At that point, all `Weak`s will be invalidated because the thing they were pointing to doesn't exist any more. Just downgrade the `Rc` pointing to the parent and give the result to the child.
Maybe make "Color" a trait which also requires that the "Vec3" trait be implemented on the type?
As far as I understand the article [Rust's Type System is Turing\-Complete](https://sdleffler.github.io/RustTypeSystemTuringComplete/), the only thing that makes it not Turing\-complete *in practice* is the type checker's recursion limit. Is this correct?
There is no documentation link on the cargo page FYI
One that is not covered is transferring ownership across FFI. That is, if you call a C function that allocates memory for you and expects you to use free on it, there is currently no safe way to handle this. Eventually it will be possible to use a Box&lt;T, System&gt; for that (hopefully next week in unstable rust).
[rexpect](https://github.com/philippkeller/rexpect)
Yeah, I don't know why docs.rs hasn't generated it :(
Hey, [seems like it doesn't show the command line flags or something?](https://i.imgur.com/HRT9yU7.png) Which can be bad in a case like this where you're executing whatever you want, could be an arbitrary malicious script that doesn't even show stdout and the approver wouldn't even know what happened. Is that a limitation of a sudo plugin, or something that can be handled? Not that this program can really cover security issues where you approve someone to have root privileges but don't want the person to do *some* root things, but it should still probably show you what the flags are if possible. Also I ran into a segfault after leaving my VMs hanging in a sudo_pair session in the background, so not sure what that was but I'll try to reproduce.
&gt; When you call Rc::try_unwrap, it returns the contained value if there is exactly one Rc, and invalidates the heap allocation. At that point, all Weaks will be invalidated because the thing they were pointing to doesn't exist any more. Ah ok thanks that makes sense now. 
This reminds me of Factorio. In that I'm always trying to create the perfect factory, and sometimes this means not creating a factory at all! Does anyone else suffer from this?
I didn't know you could define associated types recursively depending on other and the same instance of the respective trait. I could swear I tested that sometime. Well, all hope is lost, it's Turing complete after all ^^
I got interested and looked for a bit, you could use https://crates.io/crates/fs2/0.4.3, which contains https://docs.rs/fs2/0.4.3/fs2/trait.FileExt.html#tymethod.try_lock_exclusive.
Thank you for these great explanations, but there is something that I didn’t understand. https://github.com/Kerollmops/fst/blob/a3cd9fdf0efad9d10beea35b26f827992eb1ed94/src/raw/ops.rs#L455-L484 Here, the `OpWithStateBuilder` doesn’t need a `'static` lifetime for `T`, this is probably because it `Box` the `StreamWithState`, can you enlighten me ?
Yes I agree, with Rust it requires programmer attention and can go awry leading to crashes, plus is time consuming as it needs to be done manually. The difference is really between automatic dynamic garbage collection and a more manual variant of dynamic garbage collection, or relying on static garbage collection and needing to learn the static analysis rules regarding it, plus not being able to do some things that would otherwise be done dynamically **and** automatically. 
My goal in sharing this is to note that Rust CoC does often leave bad first impression of Rust to many people. It seems to me, such impressions are often based on misunderstanding of CoC, so we should better publicize what it is. For example, &gt; You literally had to walk on eggshells the whole time, out of fear of accidentally violating the Rust Code of Conduct in some obscure and non-obvious way. While I hold many beliefs I think is unpopular here, I never felt this way, and the poster shouldn't either. Rust CoC is explicit about this: "Moderators will first respond to such remarks with a warning", so there is no instaban. "And if someone takes issue with something you said or did, resist the urge to be defensive. Just stop doing what it was they complained about and apologize." So I never fear accident violation, because I can stop at the first notice. I believe, if we publicize these points better, we will attract more people who will be beneficial to Rust community.
You don't need recursion here at all - you can just use a loop. Also, you can write your `get_name` function a bit cleaner by using the `?` operator. [Here's an example of both](http://play.rust-lang.org/?gist=d6d91029b754d64fb279f31e9e53d4be&amp;version=stable&amp;mode=debug).
Yes. Because Rust cannot make guarantees about the C code and thus must assume the buffer might not be filled at all, yielding uninitialized memory, which is not allowed in safe Rust code.
Is there any reason why `Result` doesn't have a blanket impl for `From`: `impl&lt;T, E, U, F&gt; From&lt;Result&lt;U, F&gt;&gt; for Result&lt;T, E&gt; where T: From&lt;U&gt;, E: From&lt;F&gt;`?
Thanks, That's more cleaner. I haven't tried this way. 
One way is to write pure functions. Usually, whenever you want to update state, you can write the function to do it in two ways: - Take a reference to the state and mutate it (the obvious way that you are suggesting, problematic due to mutable borrows) - Take the old state, produce new state (without mutating the old state), return new state (pure functional style, no side effects, immutable old state) The calling function can overwrite the old object with the new one returned by the function. By doing the latter, you are also giving yourself more architectural flexibility. You can call your function on any state object and get the updated state. It might be useful for certain things to try to speculatively execute. Call the update state function to see what the new state would be like, without modifying the old state, so that you can throw out the updated state if you don't like it. An example of software that works this way is [Salsify](https://snr.stanford.edu/salsify/), a video conferencing system that uses a pure-functional implementation of a video encoder in a novel way. Since the encoder is pure-functional, it does not mutate the old state, so you call it and then "roll back" by simply throwing out the results. It tentatively encodes a new frame, but if the network conditions aren't right to transmit it, it can just drop it and roll back to the old encoder state to encode a new frame (possibly with lower quality settings). This makes it much more adaptable to the network, which results in a better video call experience. One thing to keep in mind is that if you write your programs in this style, you want to make your state fairly granular. You don't want to be passing your big massive game state struct representing the whole level in a video game in and out of every update function. LLVM is fantastic at optimizing this, so it might not actually be a performance problem, but still... it is probably better to keep objects small and make functions that only take the relevant objects as arguments. If you need a function to update multiple objects, you can write a function that takes multiple arguments (shared references to the old objects) and returns a tuple of new objects. The calling function is free to just look at the results and throw them out, or apply them to the application state by mutating the master struct. This way you keep all the mutations at the top level. Your inner code is written in a functional style, with immutable references to old state and constructing new state. The top level applies the new state by mutating.
I have luckily never seen this (apart from my own code when I was first learning rust. ) But it is wrong . Deref means : " somehow this amounts to a pointer and you will probably just want what it points to. newtypes are not pointers. They are new types. Useful to prevent wrong type combinations. In this instance you could make RGB wrap a Vec3 trait. Make it impl 'Into Vec3 for RGB ' and have the Vec3 trait accept T: Into Vec3 in it's functions
Would there not be an exception for simple heap-allocated data types like null-terminated strings? Just curious, this is exactly the sort of thing I hope to learn as I get more brave with FFI. :)
The only common method I can think of is addition. 
Some issues that just works for Java if you have the JVM installed but need to handle yourself if doing Rust and shipping binaries 1) On Windows, users may need to have the MS C++ redistributable components installed or some Rust programs may not run. Usually native Windows programs add this as part of their installer, so your Rust binary may need an installer. 2) On Linux, you need to run on the same or later version of Glibc than was used to compile your program. One solution is to compile on an ancient Glibc, or to compile and statically link in Musl (but might not work with all libs). 3) On Linux, if your program does networking and needs access to OpenSSL, the libs may not exist in the same location everywhere and users may need to specify environment parameters with the location (unless you statically link in OpenSSL during compile, but then you may run into issues locating the right certs on all platforms).
Working on making it public...
I have written a library which parses a data file and stores the results in a map inside a struct. Users might want to save this data and re-import it next time (rather than re-process the source file). If I have derived Serialize/Deserialize on my structs etc, is there a recognised pattern I should follow for implementing an export/import API for my library's struct containing the database so that the user could serialize/deserialize through their choice of format (e.g. JSON, Bincode)? I think what I want my impl to be something like a "pub fn export(&amp;self) -&gt; Serializer" and then the "pub import&lt;T: Deserialize&gt;(data: T) -&gt; MyStructWithDatabase" where the import deserializes? I looked at the serde docs and wasn't sure how to do this.
How to concatenated OsString ? I can't find one. The use case is I want to use `glob` to match files and the patterns are specified by the user. If the pattern doesn't start with a '/', I add a absolute path before the glob rule let total_pattern = if !pattern.starts_with('/') { // TODO Handle OsString -&gt; String conversion error let escaped_project_dir = Pattern::escape(&amp;project_dir clone() .into_os_string() .into_string() .expect("Non UTF-8 project path")); escaped_project_dir + "/" + pattern } else { pattern.to_string() }; let glob = Pattern::new(&amp;total_pattern); 
&gt; or it doesn't adhere to common decency standards and I really don't recommend working with those. It's not just common decency. As Raymond Chen has blogged about on at least one occasion, on Windows, you're not even guaranteed that different versions of the same compiler will link libraries against the same allocator. Neglecting to have the same compilation unit handle both allocation and deallocation of a given resource is a fast-track to "Not a supported use. You're going to have a bad day™" land.
There are indeed two strings being allocated there, one by `String::new` and one by `str::to_string`.
You would think so in theory, but which language right now would clearly be that language? IMO all of the contenders have issues of their own which makes it not as clear-cut as one might expect.
why does `top()` work but `top_mut()` doesn't? trait WidgetState { } pub struct NavigationStack { widgets: Vec&lt;Box&lt;WidgetState&gt;&gt;, } impl NavigationStack { pub fn init() -&gt; Self { NavigationStack { widgets: Vec::new(), } } fn top(&amp;self) -&gt; Option&lt;&amp;WidgetState&gt; { self.widgets.last().map(|s| s.as_ref()) } fn top_mut(&amp;mut self) -&gt; Option&lt;&amp;mut WidgetState&gt; { self.widgets.last_mut().map(|s| s.as_mut()) } } at a glance the only difference between the two is mutability, but it seems `top_mut()` returns `Option&lt;&amp;mut WidgetState + 'static&gt;` which mismatches with the declared return type. I expected either both to fail or both to work.
To be honest, I just made an assumption when making this post. But I just tested it with Valgrind, there are the same number of allocs whether you use a &amp;str or run str.to_string();. I could still be wrong if valgrind doesn't test rust programs correctly, but it looks like it gets optimized away. 
&gt; Did I install this wrong or something? It looks nothing like the demo gif. The prompts (both for the user invoking sudo and the person being asked to pair) are driven by configuration files. You need to drop [sudo.prompt.user](https://github.com/square/sudo_pair/blob/master/sample/etc/sudo.prompt.user) and [sudo.prompt.pair](https://github.com/square/sudo_pair/blob/master/sample/etc/sudo.prompt.pair) into `/etc`. They implement a small [templating language](https://github.com/square/sudo_pair#prompts) so you can customize them to your heart's content. I can add instructions about configuring prompts to the `Installation` section of the README. If those prompts aren't found, it uses the minimal defaults you're seeing. &gt; If any user can execute it, can't just any sudoer approve the session? If I sudo from otherguy or redguy, it asks for a sudo_approve. If I use the other user to approve, it just works. This should be explained in the [security model](https://github.com/square/sudo_pair#security-model) section of the README, but the socket used for approval is owned and writable by the user (or group) you're `sudo`ing to. Only people who can also `sudo` to this user (or group) can approve sessions.
So does this specifically solve the issue where `Box`d things first get allocated on the stack and then moved to the heap? With `BoxExt` they originate on the heap? Does this mean that we can Box things that are larger than what could ever be stack allocated?
Carol Nichols has a great collection of short problems called [rustlings](https://github.com/rustlings/rustlings). You work through them in the browser on [play.rust\-lang.org](https://play.rust-lang.org) and I found them pretty nifty!
There's no guarantee that your allocators are the same as the library's. A library that creates data is responsible for freeing it. And when that library has a C interface that means it must provide destructors for any data it constructs on the heap. 
Thanks for escalating this.
I really wish I could go, but I have still have school then.
I've applied, hope to win. 🙌🏾
That paper claims there is a java implementation, is there any reason the customer can't use that one? Linux supported java last time I checked :-p Why do they want support yor that language anyway? And how much will they pay for it?
We previously had a `PAM` plugin that did something like this. The problem is, a huge portion of the time, an engineer is trying to get access to a Rails console, MySQL console, or just needs to run several commands back-to-back and so wants to invoke `bash`. And there was no way to see what was going on inside those sessions — if someone asked to `bash`, they told you the reason and you just sort of hoped that they didn't mess anything up. This plugin is a huge improvement on that, in that you can see everything that happens in a session. No, you can't approve every newline input, but I can't think of a way that sort of thing could work in a general sense. If you have any ideas, I'm all ears.
Your works are awesome. As an rust game engine developer, it seem to tons of works, and in your [website](https://gnomonicgames.com/) said, you are working alone, how long did you take to implements all these things? 
I'm curious, what does your customer use the Plankalkül language for? :)
Absolutely true
So, I've been trying to implement a compression algorithm in rust and it's been going okay so far, but part of the algorithm involves appending back-references (previously decompressed chunks of data) to the end of the decompressed data vector. I tried something like this at first: let mut a = vec![1,2,3,4,5]; a.extend(&amp;a[0..3]); but rust complains that `a` can't be borrowed as it's already borrowed as mutable, which makes sense. My question is if there's any way to get around this such that `memcpy` is used as with `extend`, or will I have to append the chunk byte-by-byte?
You can use `mem::uninitialized` if you need to.
Okay, found the reason myself, here: https://github.com/skade/rfcs/blob/result-pass/text/0000-result-pass.md#alternatives The reason is that as there exists a blanket impl `impl From&lt;T&gt; for T`, and T, U and E, F *might* overlap so that `Result&lt;T, E&gt;` and `Result&lt;U, F&gt;` are the same type, the implementation needs specialization. I'm hopeful that we'll get this impl as specialization hits stable.
Can’t you just implement your own Box type that handles that? If the C library foo would require that instead of free you would just call foo_free(...) with potentially many parameters Box&lt;T, Alloc&gt; might not be enough to help you, but it is not necessary either since you can write your own type that does that.
u/boscop &amp; /u/thiez: Honestly, I'm not sure what they're using it for.
Your ambitiousness is what you made you special. Thank you for all your contributions!
You can't access data inside the mutex without unlocking it first, so function attribute is unnecessary.
Great offer, thank you so much for this!
If `doSomethingInLock()` only needs access to the members of `AggType` then define it on `AggType` directly (maybe taking `&amp;mut self`). Lock guards auto-deref to their protected variables so you can just write: let guard = self.agg.lock().unwrap(); guard.doSomethingInLock(); If the `doSomethingInLock()` needs access to the other, non-protected variables, then I claim it must only need access immutably, so you could pass those variables by reference into the function as argument?
Sure. Error: ` cargo build Updating registry `https://github.com/rust-lang/crates.io-index` error: failed to load source for a dependency on `rayon` Caused by: Unable to update registry `https://github.com/rust-lang/crates.io-index` Caused by: failed to fetch `https://github.com/rust-lang/crates.io-index` Caused by: object not found - no match for id (64582506224b8d4e08c8adba3baf2339b81bc313); class=Odb (9); code=NotFound (-3)` Cargo.toml: `[package] name = "simhash" version = "0.1.0" authors = ["Name &lt;first.last@email.com&gt;"] [dependencies] rayon = "1.0.1" ` I'm using stable rust and Cargo 0.26.0. This used to work when I first started learning rust (couple months ago), since then I took a break and came back recently. Only thing that changed is that I updated my rust toolchains.
It's the ultimate legacy system.
From what I can see, the `new_with` will *likely* allocate directly on the heap, but it's not guaranteed and would probably not do so in debug mode. Just like the `box` syntax rfc.
This is something that was bugging me last few months. I have several ideas for codegen where this would help a lot. I'd be very happy seeing this resolved somehow.
 Black + Black = Black Grey + Gray = White (sometimes) White + White = ? It may make some sense when you are adding base colors, but in the general case - not that much. At least - not when you call it "addition".
Just to add my ramblings: I am currently creating tomorrow's legacy and technical debt. In Java (Not to say that a Rust implementation would not also be tomorrows legacy!). And I am happy to have managed to get there from Python, so we at least have some compiler checks. But I really struggle with it. I might even go so far as to claim Rust has ruined me for just about any other of the languages I know (concerning non-trivial projects). The way I see it: A step learning curve requires pretty much a one-time investment. But the conceptual and fundamental advantages are there forever. If you save on training cost or mental effort, you might have an easier time at the start, but you'll have to deal with any structural, language-inherent disadvantages forever. Rust *can* (still, no entirely free lunch) help to raise the minimum standard of correctness drastically. Since I got into a Rust mindset, I began to see all the places it unobtrusively has my back when in other languages, I have to put in extra work to ensure simple correctness (or just clean up after my code), which should be the *least* one should strive for, right? I strongly hope Rust will make it, for it might (dare I say it?) make the software world a better place in many areas. End of sermon :)
Ok, but why only for associated types? There are already many ways that associated types are given more capabilities than normal types, e.g. GATs, soon `impl Trait` etc. Shouldn't regular type decls be the same first-class citizens? Maybe we should first close this gap between associated and non-associated types, instead of widening it more? And only introduce more capabilities for associated types when the gap has been closed?
Thanks! I've been working on this for about a year, more than half\-time \(I'm semi\-retired\). There is still a hell of a lot more work to be done, hence the opensourcing and the hope for collaborators.
There is no such thing as white, when dealing with high dynamic range. A paper looks ”white”, but only reflects 65 % of the incoming light. Looking directly at a light bulb is even brighter, but is that ”white”? How about staring at the sun? In this context, adding light absolutely makes sense. To display the rendered image, it must be converted to low dynamic range. That can be done by simply clipping it at some arbitrary value, the white point. But it will look a lot more natural if you implement cross talk between the channels. The Blender/Cycles team have dine a lot of work on this in their rendering pipeline lately. Look up “filmic blender”. 
Once this ICE is fixed, I think it could work like this: https://play.rust-lang.org/?gist=a25e95fe6201b0e3e0aa35ea9bba7ab0&amp;version=nightly&amp;mode=debug
Working on [tarpaulin](https://github.com/xd009642/tarpaulin), last week I completely rewrote the syntax highlighting code using syn. However, it relies on `RUSTFLAGS` to include the code when building so I need to figure out a way to get around this when releasing the next version... I'll be continuing with it this week and maybe doing some work towards HTML reports
I like scopes a lot. Reduced repetition. Nice job.
A few of the issues were already merged, just weren't closed. I just submitted a PR adding the rest!
I've just started using actix-web 0.5 and I must say I absolutely love it. Thanks a lot and keep up the good work! 
Haha good point. I'm to impatient to wait for a high quality render so I need to make it faster first :)
Thank you!
It's not really an ICE, GATs are just not implemented past parsing.
Extending can cause a reallocation when the vec doesn't have enough capacity, so it is good that rust forbids this. If you know in advance how long your output is going to be, you could just prefill the vec with `0`s and then use `split_at_mut` and a little dance to use memcpy.
Is it a feeling or you are trying to mimick golang's libraries api when you can? If so I think it's the right thing to do, golang's has a really cool api to work with.
This looks really interesting and is definitely something I'm interested in. Do you think this would work as a primitive for building more complicated UIs? I've looked at other terminal UI libs, but feel they make a lot of assumptions about the look of elements.
But this is more complex than simple vector addition, so it doesn't make sense to share the implementation with `Vec3`.
Table 4 is the summary. It is impressive Rust comes within 3% of C and significantly outperforms C++.
Cool. Sounds good!
Nice work on 0.6! I see you have preempted my question and included a [Migration guide](https://github.com/actix/actix-web/blob/master/MIGRATION.md) 
Note that Box::new(mem::uninitialized()) copies uninitialized data from the stack to the allocated memory. Shameless plug, with optimizations on, this is a workaround: https://docs.rs/boxext/0.1.1/boxext/trait.BoxExt.html#tymethod.new_with
Nightly has --remap-path-prefix option to fix build path problems, which is the same solution used by GCC (-fdebug-prefix-map).
Nope, uncomputable math is still useful. In AI research! Intuitionism is only right with the assumption that things are like types. If you weaken this assumption then you can speak of things consistently that is believed to be provable to the degree you can imagine a smarter version of yourself being able to prove it. Perhaps a necessary condition for overcoming some major higher order goal reasoning problems in AI (see https://github.com/advancedresearch/path_semantics/blob/master/papers-wip/proof-of-minimal-interference-by-super-intelligent-zen-rational-agents.pdf). That said, I agree about the law of excluded middle.
Is there a good explanation of what "reduced-coordinates approach" means?
Yes, this is correct. The same goes for the macro system, in fact.
There's a beta? I only know about stable and nightly, and I usually use nightly because stable won't let me do what I want.
Beta is like a release candidate for stable; every six weeks, a nightly turns into a beta, and beta turns into stable. Most Rust users compile with it on CI and that’s it.
Setting TravisCI to test beta / nightly can give early warnings here, and it's really simple.
I mostly have experience with golang when it comes to webservices. I guess this is common patterns shared across many libraries in many languages then!
And it's easy to run against beta on CI!
I'm very excited and looking forward to testing this out. 
`buf_redux` has been my little buffered I/O dogfooding project supporting my requirements in [`multipart`](https://github.com/abonander/multipart). I found it was easier to create replacements for `BufReader` *et al* than try to get the necessary APIs added. Primarily, I needed a way to read into the buffer without completely emptying it so I could verify `multipart/form-data` boundaries in the buffer without copying. As my needs grew, so did the API of `buf_redux`. With this release, I've added support for ringbuffers via the [slice-deque](https://crates.io/crates/slice-deque) at the suggestion of the crate's author. Slice-deque uses virtual memory tricks to create a buffer that loops around on itself in memory, so the deque's data is always contiguous and can be represented as a single slice. This is incredibly useful for buffered types as `BufRead::fill_buf()` requires that only one slice be returned, so a buffer that behaves like `std::collections::VecDeque` isn't sufficient. There are some caveats; the implementation is more complex, and requires rounding the capacity up to the next multiple of the page size (and the minimum size on Windows is 64 KiB for [stupid legacy reasons](https://blogs.msdn.microsoft.com/oldnewthing/20031008-00/?p=42223), of course) so it may not be optimal in all cases. Still, it's *really* cool.
Nice! Glad it was helpful. Yeah, I'm pretty sure I was just regular `sudo ls`'ing from two user accounts but I'll double check and let you know when I reboot into linux later
i most cases upgrade to 0.6 is just version update in cargo.toml
Now having a little bit more experience under my belt, I think I can maybe comment more on those two red flags: From the whitepaper on sovrin.org, the token serves one primary purpose: " To provide economic incentives for credential issuers, owners, and verifiers, the Sovrin protocol will incorporate a digital token designed expressly for privacy-preserving value exchange." So a token will be very, very different from the cryptocurrencies we know today. As for the lack of a detailed explanation of why a blockchain is necessary, this may be because the understanding of what will be stored on the distributed ledger is still evolving. However, speaking generally, the main purpose of the ledger is to have a decentralized database that no one entity can own and control by definition. The goal is to give individuals the ability to have complete control over who has access to their personal information and that requires avoiding centralizing, traditional database solutions. If you have more questions, feel free to reach out to the Sovrin community!
If there’s a bypass I *absolutely* want to know about it. And we have a big bounty program. 
As a note, triple backticks doesn't work on Reddit. You need to indent the whole code block to have it properly formatted.
I don't think it is installed through rustup. You can `git clone` and then `cargo build` though
Several people have stated it's easy to test against beta on travis, here's what you put in your .travis.yml: language: rust rust: - stable - beta - nightly matrix: allow_failures: - rust: nightly fast_finish: true
Or some short summary of what this library even does. The ncollide.org page seems to be down.
I think many websites today are larger than 920 kb :D.
I know these are only microbenchmarks and as such should be taken with a grain of salt, but I'm curious about the memory consumption. How come Rust consumes ~50% more memory than Go (which is a GC language)? Is it a lot of overhead from Rc/RefCell, from jemalloc, or something else?
Jemalloc is known to be tuned for larger memory use compared to other allocators/memory managers, so it makes sense that a microbenchmark doesn't exactly show its best side.
Another user following that book posted [their raytracer](https://github.com/ranveeraggarwal/rust-raytracer) a while back. It appears they [kept it simple](https://github.com/ranveeraggarwal/rust-raytracer/blob/master/src/structures/vec3.rs).
To be 100% honest I haven't looked deeply at specs yet. I'm interested in parallelism from at least a theoretical perspective, but there are things about UI programming in particular that tie it to a single thread. I'll read up on specs, but I'm also interested in your perspective. There are a only a few hundred lines of code in the xi-win-ui prototype, but some of the interaction logic is already pretty sophisticated, in particular the layout protocol which allows a container to specify the order of traversal of its children (see Flutter's [Flex](https://docs.flutter.io/flutter/widgets/Flex-class.html) render object for why this is important). Based on your read, do you think the benefit of adopting specs as a dependency is worth it, as opposed to a simple handrolled approach?
It's a 3D and 2D physics engine, built upon ncollide, which in turn is built upon nalgebra.
Wow thanks! That was fast I didn't even managed to get home before your PR. 
Great work! 
Very exciting! I'd be super interested to read a breakdown of the algorithms used. Also, I'd be very interested to learn about the benefits and disadvantages of the reduced coordinate approach compared with modelling constraints in full coordinates. As I understand it, the reduced coordinates encode the constraint into the very definition of the multibody, and hence it cannot break. This sounds great, but I'd be very interested to learn more about what the downsides are. In particular, I can imagine it's harder to integrate with other multibodies or contact/collisions?
Just tested the `calc` example on my machine. Looks promising! Keep up the good work!
Thanks.
I took your suggestion! https://crates.io/crates/rager
Wow, quite the changelog! Can't wait until we get these goodies on stable. FYI, the link `fs::read_to_string` throws a 404.
It seems not ready for interactive use yet...
How would you write trait impls for an anonymous type like that? 
I’ve been wondering about the use of `allow_failures`. Do you regularly go through your Travis\-CI builds to see if there’s any red for Nightly jobs? If not, why run Nightly at all?
Like on Stable, unstable features are not available on Beta.
I did notice the websocket `WsWriter` changes when I was playing around with master a few days back as well. But this appears to be a rather easy adjustment.
Pretty much as i would have expected, except for the efficiency of javascript.
This works: https://play.rust-lang.org/?gist=ae6621e9aed63323ebb1f05e7ccfe09f&amp;version=stable&amp;mode=debug When you need a bound like `&lt;T: Something&gt;` you can do the usual trick of writing `&lt;T: for&lt;'a&gt; T: Something&lt;'a&gt;&gt;` instead (workaround for lack of GATs).
I've been using these math libraries a lot in my spare time, and these are truly awesome ! That being said, I have always found it quite hard to integrate with an ECS (Specs, in my case). Maybe showing a reference implementation of an entity-based contact listener of some sort in the docs would help ? 
This is really interesting! I've tried doing something similar when I was initially doing some Rust + Webrender experiments, see an example [here](https://github.com/RoyJacobs/weld/blob/master/examples/button.rs). The idea being that instead of having the "widget class hiearchy" concept you instead have components that refer to some general application state, instead of holding it. Additionally, you'd implement a Renderer trait for the component. I also looked at Flutter (and libraries like React) with a close eye for this :) I didn't get very far with it because of the usual lack of time and so forth, but the concept worked quite well. I'm glad to see a more experienced Rust developer taking on the same concepts :)
Context-as-a-service: &gt; rustfix is both a library (`rustfix`) and a cargo tool (`cargo-fix`) that automatically apply the suggestions made by rustc.
&gt; Spoiler-as-a-service FTFY ;)
Just a small heads-up, there's a typo on your website (Haskel instead of Haskell)
Hahaha
Great news that you'll have even more time to work on your Rust libraries in the future! I use nalgebra for all of my projects.
I've simply not dealt with "objects" and mutability at all in my GUI library [azul](https://github.com/maps4print/azul). I'm simply re-generating the whole (immutable) DOM on each draw call. Even on large workloads, the time for re-generating and rendering everything is ~2-4 ms total, which is well under my target time. For the layout - the whole DOM is simply an arena (which is very CPU-cache friendly), and the layout simply traverses upwards, reads the maximum constraints and inserts them into a cassowary constraint solver. Then I let that take care of the rest and do caching via hashes, for efficiency. Input is handled via callbacks that only modify the application state, not some kind of graph - so I only have one, large object that I modify and then tell the renderer to re-fetch and re-draw the DOM. And I use CSS for styling, instead of putting the styles directly in the code, which makes it easier to develop themes, custom widgets and layouts, etc. There is a seperate `css_parser.rs` file, which may be useful for xi. I'm personally not a huge fan of mutability in GUIs, since IMO they make dynamic data difficult to handle - as your app grows larger, you get more and more side-effects and interactions between different components, which makes it harder to see where exactly a problem is coming from, which "relationships" in which order are responsible for a problem. If you can avoid these interactions with an ECS, more power to you. I'm dealing with this simply by making it easy to test the data model, so that I can mock various inputs in random order, then test in what way the data model was effected. This doesn't make the issues go away, but it makes problems immediately apparent - if one callback would affect a component that it shouldn't, the tests would fail. That's my approach - a "purely functional" way, without any mutability (at least from the library users perspective). So you have a constant cycle between: DOM -&gt; UI is rendered -&gt; hit tests, calls callbacks -&gt; callbacks modify application state -&gt; application state regenerates DOM. It of course has a slight performance cost, but I take that in exchange for a very simple API. It's cool to see more GUI work, but I'm not entirely sold on the scalability of the ECS approach, i.e. how to prevent many "relationships" from interacting with each other in ways they shouldn't.
I don't see a problem with: impl X for MyType::AssociatedType { } and impl X for MyTrait::AssociatedType { } ?
Sure, I know that is what people would like `Deref` to mean. But in fact this is done pretty inconsistently. Even in Rust's standard library, `Cow` is not just a pointer wrapper, as it can also have ownership of the type, but it still implements `Deref` for `T`, and `ManuallyDrop` and `AssertUnwindSafe` are both newtype wrappers that implement `Deref` and don't even take a lifetime. In Rayon (the first library I bothered to check) `Deref` is used on `Either` to give you dot access to the underlying type if both the left and right sides dereference to the same type, which can't really be justified as being smart pointer like. Again, not saying I like it, but people use it this way because it's convenient. I agree that pretty much all of the other solutions in the thread are better though, and I wish I had recommended one of them instead.
Yeap I have seen the repo. I mentioned my end goal in order to fully explain the context of what I was trying to do. I asked this question, not to get an answer about ray tracing but to better understand Rust's typesystem.
Segfault if I recall correctly.
Ah, okay! Well, there's this interesting question about how derives would behave in the thread, which kind of plays into the same problem.
Yes I do do that once in a while. I see it like an early warning system for any upcoming breaking changes.
Putting Rust in the functional group, but not C++ (Table 2), doesn't seem fair to me. Yes, Rust is expression-oriented, which makes writing some constructs more pleasant and look slightly more functional, but fundamentally, Rust and C++ have pretty much exactly the same support for functional programming: lambda expressions that capture local state either by reference or by value and generic functions that can take other callable constructs as arguments.
By the way, this is an example of a very low-effort, but very valuable contribution to the project. It's hard to do for many project members that have 1000 things to do, it's easy for someone who _just_ tends for that. You can literally do that 5 minutes at a time.
The problem is that linux-musl hasn't moved to Tier 1 support level yet. I don't know why. Once that's fixed, you'll be able to use rustup on Alpine Linux and Void Linux, just like you can on glibc Linux and FreeBSD. This is something that's been requested regularly since rustup became the standard, and I don't know what's blocking it. The ability to create fully static binaries is very useful, and a distro like void or alpine can enable this when linking C libraries, too. This, on top of the smaller static binaries, could be another bullet point when advocating Rust relative to Nim or Go or etc.
It is probably from jemalloc. It is an allocator tuned for large applications, to give the best performance with many allocations. It works by preallocating arenas of different sizes for efficient allocation. However, this wastes memory for small programs. If you are just writing a small CLI tool or a benchmark like in this case, jemalloc is overkill and will increase memory consumption a lot. Fortunately, Rust will soon support using the system default malloc.
I see. Yes, it seems unnecessary
I linked a Rust type, not an explanation on raytracing. Their Vec3 type implements many of std’s operators and traits while keeping a simple interface. There are many other approaches one could take, but as you can see, not everything needs to be overcomplicated to meet a goal, e.g. with inheritance.
The way things are classified in this paper is weird in other places too. For example, their unexplained separation of "VM" and "Interpreted" languages. Unless I'm mistaken, every single one of the "interpreted" languages uses a bytecode VM or a JIT. JRuby runs on the JVM yet they separate it from Java ? A vast majority of programming languages today rely on a VM of some sort. They obviously do not all behave the same, but this paper seemingly doesn't provide consistent criteria for differentiating them.
The problem here is that `toml::from_str` is generic, [docs](https://docs.rs/toml/0.4.6/toml/de/fn.from_str.html). When the compiler reads `toml::from_str(&amp;contents).unwrap_or_else(|e| Err(ConfigLoadError::TomlParse(e)))`, it knows that `toml::from_str(&amp;contents)` has the signature `&amp;str -&gt; Result&lt;T, E&gt;`, but it does not know what type `T` is. It looks at `.unwrap_or_else(|e| Err(ConfigLoadError::TomlParse(e)))` which has the signature `(Result&lt;T, E&gt;, (E -&gt; T2)) -&gt; T2`. It then establishes that `T` must be equal to `T2`, and as `T2` has the type `ConfigLoadError`, type `T` must be the same. The first error is coming from this, as there is no implementation for deserialising the toml input. The second error is from `map_error` having a signature in this context of `Result&lt;Result&lt;_, ConfigLoadError&gt;, io::Error&gt;`. **tl;dr:** The two pieces of code are not functionally equivalent.
/u/raphlinus I don't know if IIUC. I would expect that you have: * an entity component system, like specs, where * systems == widget-types * entities == widgets (entity id == widget id) * a petgraph graph of entity-ids, so that each entity can register their relationships with other entities ...and that's it ?
I wish some framework embraced updating. That is, instead of doing (Events, State) -&gt; State State -&gt; Dom something like Events -&gt; Updates And then have the compiler assemble this method out of trait implementations for the individual components (Updates, Dom, State) -&gt; (Dom, State) 
Yes I saw the code you linked. It does not answer my question as this code still used a single type for both a 3-vector and a colour triplet. I am trying to define two seperate types so that I can benefit from the compiler's type checks but also keep the common implementation details in a single place.
Hey, catragore, just a quick heads-up: **seperate** is actually spelled **separate**. You can remember it by **-par- in the middle**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
So other than GC I don't think Go has anything notable, but OCaml made me think of F# (they are related) which has a few: * Type Providers - https://medium.com/@maximcus/magic-of-f-type-providers-225b1169c7a0 * Active Patterns - https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/active-patterns * Units of Measure - https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/units-of-measure 
Does OCaml or F# have higher kinded polymorphism or higher ranked types?
True^ ^ but imagine my thought process: 1. Click 2. Fuck pdf. Maybe it's text only 3. Taking a while 4. Fuck it's a report, it could have 5mb of images in it. I have 100mb for the whole month 5. Fuck
is `const fn` stable?
Is this good for physics simulations other than real time graphics? (scientific stuff, etc..)
nope. F# has some tentative plans iirc, when/if C# adds typeclasses. 
I don't really follow the attempts at understanding / explaining this error but you're right in that the code is not equivalent. What /u/hardwaresofton is trying to do is not actually a map but a flat map. The right method for that is `and_then`. Just substituting that will fail for another reason, namely that the two errors are not the same type. They have to be unified before and inside the `and_then`. So the correct chain should be f.read_to_string(&amp;mut contents) .map_err(ConfigLoadError::IO) .and_then(|_| toml::from_str(&amp;contents) .map_err(ConfigLoadError::TomlParse) ) Can't check without the full code. Given that the returned value on `Ok(_)` of the first action is dropped anyway, a more idiomatic way would be to use f.read_to_string(&amp;mut contents).map_err(ConfigLoadError::TomlParse)?; toml::from_str(&amp;contents) .map_err(ConfigLoadError::TomlParse) And if ConfigLoadError impls `From&lt;E&gt;` for both the `IoError` and `toml::de::Error` you could simplify that as f.read_to_string(&amp;mut contents)?; Ok(toml::from_str(&amp;contents)?)
The beginnings of cross-language LTO! https://github.com/rust-lang/rust/issues/49879
Hey thanks for tanking a look, and writing a detailed description of what's going wrong. Why does the compiler decide that `T` and `T2` must be the same? I've written code like this in Haskell and have gotten away with a type annotation or two, this feels like a rust-as-it-is-right-now choice, not a categorical impossibility. Is this what you meant by the documentation not being great -- the fact that `unwrap_or_else`'s `op` function must produce a `T` that matches what was in the `Result`? Just to recap/restate what you said to make sure I understand: - `toml::from_str` being generalized (producing a `Result&lt;T, E&gt;`), which forces the compiler to try and figure out what `&lt;T&gt;` can be - In the next breath, the compiler carries the `T` into figuring out the use of `unwrap_or_else`, and assumes that the `T` (`T2`) generated by the or-else operation must be the same `T` as was stored in the Result Is there any way to write it cleaner and avoid the nested `match`?
By adding appropriate `From` impls and using `?` operator, it could just be: f.read_to_string(&amp;mut contents)?; let cfg = toml::from_str(&amp;contents)?; Ok(cfg) ([playground](http://play.integer32.com/?gist=39b0025c0d129667e28cdba3a5c85ea8&amp;version=stable&amp;mode=debug)) You can look at [Recoverable Errors with Result](https://doc.rust-lang.org/book/second-edition/ch09-02-recoverable-errors-with-result.html) for idiomatic error handlings in Rust.
The move is not done on `if let` matching, but on creation of the tuple: `(m, n)` expression moves the `n` into a tuple. You can create a tuple beforehand: let tup = (m, n); if let ... = tup {} Or you can match on references instead: if let (&amp;Foo::A(_), &amp;Foo::A(_)) = (&amp;m, &amp;n) {}
Oh. Of course. Thank you !
Then again, the inconvenience is paid up front when coding, rather than later when having to tune garbage collection to suit a particular application's memory allocation patterns.
I had that in my Travis conf for a long time, but I couldn't cope with the long compile times. I want to support at least three releases backwards, so right now 1.23, 1.24 and 1.25. ... Adding beta and nightly bumps up the compile times even more (takes about 1hr right now for building and testing). For my smaller crates I have these Travis settings, of course.
And once 1.26 comes out, you won't need `&amp;` on matching: writing just `if let (Foo::A(_), Foo::A(_)) = (&amp;m, &amp;n) {}` will do the same.
i missed `WsWriter`, i will make it optional in 0.6.2
Hey thanks for the suggestion (and link to playground)! You're right, it can be reduced a lot, and look a lot better. I didn't think the `From&lt;E&gt;` impls were in stable rust yet, but I was clearly wrong! I also made a [comment summarizing](https://www.reddit.com/r/rust/comments/8hjwvf/hey_rustaceans_got_an_easy_question_ask_here/dyp1508/) for anyone that might come after. I've only read through the first edition of the rust book -- I was trying to read through both editions before starting this project, but decided I didn't want to wait that long -- Looks like I'll need to do some more reading!
The link will be filled once 1.26 is released and doc.rust-lang.org is updated.
I don't understand your motivation, and I don't know whether this solves your problem, but you might look at getopts: https://docs.rs/getopts/0.2.17/getopts/
Mhm... I'm not sure about this because of inconsistencies in Reddit vs various mobile apps. In some, triple backticks work, but in all apps/pages, indentation works.
&gt;I don't understand your motivation My motivation is to reduce executable size. &gt;getopts I thought that it's just a bindings to the C library... Will try it out.
Aha. So I did not try to look at writing the code in the style that /u/hardwaresofton was trying to do, but instead I was looking at the types of the values, as I worked backwards from the error messages specified. It makes more sense that actually what they wanted was to use `and_then`, but the rather unhelpful error message threw me off. 
Go has easy to use cross-compilation, that doesn't require installing sepearte cross-linkers and target os libraries.
The docs problem was a misread on my part, but (IMO) the wording can be improved on the part of the docs. &gt; Why does the compiler decide that T and T2 must be the same? It is because it is part of a method chain, so the return type of each function is the `self` type for the next, so the types along the chain must be known and constant. I'm not a type theorist so I guess other people would be of more help as to explain the behavior of the type system there.
Do you think there is an easy way to channel such things to be more visible to the people?
Woohoo, congrats sebcrozet, and thanks for all your hard work!
Speaking of which - they mostly link to rfcs for stabilizing features, which then link back to the main rfc, which becomes unclear what part of the rfc is being stabilized... So my question is, do they release a nice overview of newly stabilized features?
This looks awesome. Random question: How difficult would it be to support non-euclidean space? I'm specifically thinking about 2D operations on the surface of a sphere / geoid, and being able to use this to do computations on geometries that occur on the surface of a planet (earth in most cases!). 
&gt; My motivation is to reduce the executable size. Have you tried `RUSTFLAGS=-C opt-level=s` and [profile.release] lto = true Together they reduce the size of my structopt/clap-using binary by about 500KB.
&gt; UPD: looks like getopts doesn't support positional args. Isn't `matches.free` all you need for positional args?
+1 for Pyramid - they have the best extension/plugin API story I've seen in Python ecosystem - https://docs.pylonsproject.org/projects/pyramid-cookbook/en/latest/configuration/whirlwind_tour.html#whirlwind-adv-conf
I have heard that your physics system is best kept separate because it needs access to everything and has to store its own global state to be efficient. Basically you forward position changes to it every update and grab any position changes it calculates and feed them back into ECS. As long as you ensure no other system is running when you do this the rest of your ECS works like it normally does.
Not off the shelf, as that would need us to iterate all those cases :). Having an up-to-date showcase is _also_ quite a bit of work. 
What OS are you on?
clap author here. I know you and I have discussed the binary size before, but for others finding this thread I'd like to point out that a custom parser will almost certainly always been smaller than a general purpose parser. Also, Rust doesn't compile the entire lib into a binary, and should be stripping out parts you don't use (with a few exceptions) via the dead code elimination. I've also found that argument parsers in general have *so*. *many*. *edge cases*. that you don't think about when you first set out to write one. Knowing what I know now, I'd almost never say it's worth it to write a custom parser :P Having said all that, like /u/BurntSushi said, there is [`getopts`](https://crates.io/crates/getopts) as well as [`argparse`](https://crates.io/crates/argparse), [`argonaut`](https://crates.io/crates/argonaut), and [`pirate`](https://crates.io/crates/pirate) which may fit your needs and have various levels of features. (IMO only) The time and effort spent maintaining a custom parser isn't worth the few KB saved. Keeping in mind as requirements for the custom parser grows, code size grows too. [Especially when already using things like `strip` and `--opt-level=z`](https://clap.rs/2018/01/15/tuning-your-weight-loss-vs-performance/). As a practical example consider `ripgrep`'s case, which is arguably a large command line application. kevin@kwlin: ~/Projects/ripgrep ➜ tail -n 3 Cargo.toml [profile.release] debug = true opt-level = "z" kevin@kwlin: ~/Projects/ripgrep ➜ cargo bloat --crates --release [.. snip ..] Finished release [optimized + debuginfo] target(s) in 34.18 secs File .text Size Name 2.7% 48.7% 794.7KiB std 0.9% 15.8% 257.9KiB [Unknown] 0.6% 10.0% 164.1KiB regex 0.6% 10.0% 163.8KiB clap &lt;------ look here 0.3% 5.9% 96.9KiB regex_syntax 0.2% 3.4% 55.4KiB ignore 0.1% 1.4% 23.4KiB encoding_rs [.. snip ..] 5.6% 100.0% 1.6MiB .text section size, the file size is 28.6MiB Warning: numbers above are a result of guesswork. They are not 100% correct and never will be. kevin@kwlin: ~/Projects/ripgrep ➜ ls -lh target/release/rg -rwxrwxr-x 2 kevin kevin 29M May 9 10:44 target/release/rg kevin@kwlin: ~/Projects/ripgrep ➜ strip -s target/release/rg kevin@kwlin: ~/Projects/ripgrep ➜ ls -lh target/release/rg -rwxrwxr-x 2 kevin kevin 3.1M May 9 10:45 target/release/rg kevin@kwlin: ~/Projects/ripgrep ➜ upx target/release/rg Ultimate Packer for eXecutables Copyright (C) 1996 - 2017 UPX 3.94 Markus Oberhumer, Laszlo Molnar &amp; John Reiser May 12th 2017 File size Ratio Format Name -------------------- ------ ----------- ----------- 3193816 -&gt; 1075084 33.66% linux/amd64 rg Packed 1 file. kevin@kwlin: ~/Projects/ripgrep ➜ ls -lh target/release/rg -rwxrwxr-x 1 kevin kevin 1.1M May 9 10:45 target/release/rg
I can't use `lto` because I use native libraries and optimization to size doesn't fix the problem at it's core.
Thanks for these comments. I'm definitely not claiming that I have a pure, rigorous implementation of the ECS pattern; I've certainly adapted it to solve my specific problems. In some ways I think it might be a hybrid of ECS and traditional object-widget, especially the dynamic dispatch of widget methods for purely local widget behavior and appearance. In other cases, I probably have my terminology confused. My `UiState` struct has both the storage and the system behavior (the latter of which is generally implemented as static methods). I definitely want to clean up my terminology and avoid any mischaracterizations of ECS in general.
Why didn't they test Rust without jemalloc?
Thanks. Yes, `clap` is a superb library, but when you need to parse three options \- it's an overkill. As soon as my requirements will grow I will switch to clap immediately. It just too big for my needs for now. As for other tricks: * opt-level=s/z is nightly only, sadly. And on nightly I can use system allocator to reduce the exe size even more. * I'm already using strip and the numbers in OP are after strip. * upx is a dirty trick and I don't like it And since I can't use lto I have to reduce the actual code size.
Hi, Trying to learn Rust (coming from Python &amp; some c++ from 10+ years ago). Read the book, doing exercism exercises and thought I was ready (after previous failed attempts) to do a problem that we sometimes give to interviewees (not in Rust though). The problem is to return a possible execution order given a map of {task: [dependencies], ..., task: [dependencies]}. E.g. with input `{a: [b, c], b: [d], c: [d], d: []}` the order should be `[d, c, b, a]` or `[d, b, c, a]`. I was finally able to get it working in Rust - and I would love code review feedback: [Playground link](https://play.rust-lang.org/?gist=b45f8b41817587f8ff95a1feb268a6d8&amp;version=nightly&amp;mode=debug)
No worries, I don't take it personal at all :) I was just expressing my opinion for most cases for others finding this thread. In my unscientific tests LTO actually *increased* the code size with opt levels above s/z. Not specific to your case, but just FYI for others; in the clap 3.x I'm working to actually pull out things like shell completion script generation into sub crates which will reduce code size even more in the general case.
Does anyone else think that using a polyline to connect data points that are unrelated (not a time series) makes the diagrams harder to read? (E.g. figures 3-6) It deceives the eye which has to be constantly reminded to **only** consider the `y` at the discrete `x`s, which is confusing for the eye.
I've been considering adding some functional-style tests to a project of mine, and I'd like to use a mocking framework. Unfortunately, it seems like all the mocking frameworks I've seen so far require nightly. Is it possible to somehow configure the project so that someone running `cargo test` will only run the unit tests if they're on stable and run the functional tests as well if they're on nightly?
the uom and metric crates both provide compile time unit checking in Rust.
Partial function application maps pretty cleanly to returning a boxed closure. It's how most people do it in Javascript these days as well (`bind` seems to have lost favor now that you can avoid explicit `this` binding by using an arrow function).
Win 10
Hm, very odd. I’m on Windows 10 and it works here...
I'm hoping that support for LLD increases and there is less of a need for other linkers. I'm not sure on the status of it, i know LLD is being stabilized for use on the wasm toolchain.
This is an insanely awesome Go feature. Compiling for otherwise tricky targets like macOS and Windows is no work at all with Go.
I've found Japaric's [cross](https://github.com/japaric/cross) is pretty amazing! Sure it's not a Rust standard tool and it's not perfect, but IMHO it does its job well.
yes all of these features can be approximated in any turing complete language. =) 
Well, Dlang has already integrated LLD, but it solves only the cross-linking problem, both Dlang and Rust relies heavely at least on Libc, so we will still need to get prebuilt libraries for a target platform. Golang doesn't rely on Libc and everything is implemented in Go's runtime library and eventually statically linked, so it is much easier on Go's side.
Go has very fast compilation. Also simplicity of the language, really easy to learn. 
On line 29, can't that line be moved later so that the `clone` isn't necessary?
Maybe we will have parametric modules in Rust, too? I think Derek Dreyer is doing research in that area..
My unit tests are currently inline within the module files they test (not sure if this is considered best practice). Also, ideally I'd want to also run the unit tests when on nightly, not just the nightly-only tests. Is there a way to do this (maybe with attributes or something) so that I only have to type `cargo test` or `cargo +nightly test`?
its
Credit to [this thread](https://www.reddit.com/r/rust/comments/836oxt/has_anyone_done_a_rust_rewrite_of_lessmoremost/) and /u/folk_science for the name!
I'd be interested on using it on a torus world (x and y axes wrap around).
I think this is kinda how Condrod works. It has an widget graph that gets updated and redrawn depending on changes. But it feels immediate mode.
An ECS system generally works with several types of components at once, and so doesn't really correspond to anything like a single widget type. I would expect an actual ECS (this isn't, see [this sibling comment](https://www.reddit.com/r/rust/comments/8i1z6d/entitycomponentsystem_architecture_for_ui_in_rust/dyoybv2/) to have systems like "layout," "event propagation," "render," etc. Then, while an entity would correspond to a widget, a component would correspond only to some *aspect* of the widget- position, layout constraints, event handlers, etc. would all be different component types. Such a system would avoid xi-win's relatively heavy use of trait objects and `Any`, in favor of flat, homogeneous arrays of data.
An OCaml functor is essentially a function that takes some modules to another module. One use case is adding functionality generically across modules. For example, let's say you have two modules `Set` and `Vector` which both export an abstract type `t` and a function `to_list : t -&gt; t list`. Then you could make a functor that re-exports `t` and `to_list` and adds a generic `length` function computed as length : t -&gt; int length x = List.length (to_list x) This way you can augment modules that export intersecting signatures with common functionality.
&gt; On line 29, can't that line be moved later so that the clone isn't necessary? Yes - thank you! &gt; Perhaps run Clippy on it and see what Clippy has to say. Thanks for the reminder - Clippy had me change * &amp;Vec&lt;String&gt; to &amp;[String] * Use some of the types I had defined * remove an unneeded iter() * maybe some other stuff that I don't remember :) &gt;There is a filter_map iterator, so use that instead of filter then map? I did this - not sure if it's better or not :). The big benefit for `filter_map()` is when you already have an Option&lt;T&gt;. From the docs: &gt;&gt; If your mapping is already returning an Option&lt;T&gt; and you want to skip over Nones, then filter_map is much, much nicer to use. Thanks very much for your input! [Updated code](https://play.rust-lang.org/?gist=46e5ed2506caa128d73680722368dc00&amp;version=nightly&amp;mode=debug).
I don't think physics engines designed for games are used for scientific stuff: * There is not much research in classical mechanics AFAIK. * In science, you usually solve the differential equations specific to your problem with a general or specialized solver. Collision detection is usually not necessary, and accuracy is more important the performance. * I'm not sure physics engines are flexible enough. Can you use nphysics to simulate for instance the three-body problem?
Cool project, I’ve been working on [something somewhat similar](https://github.com/ruuda/mindec) for the past year or so. Out of curiosity, what are you using for storage and querying?
The error [comes from git](https://github.com/rust-lang/cargo/issues/3561). It was supposedly fixed, but deleting your cargo registry cache should help anyway. 
I'm open to suggestions about how to best describe my prototype; if it's misleading to characterize it as ECS I want to move away from that. In any case I am working with two types of components at the moment, a widget and a listener. (The fact that listeners are components is perhaps hidden by the fact that they don't use the same entity namespace as widgets). Is the use of trait objects a good thing or a bad thing? Maybe it's a failure of imagination just because I'm so much more familiar with traditional widget-object systems. I'm interested in exploring this question more deeply. But because I _do_ use trait objects heavily, maybe I should change my terminology to make it clear it's inspired by ECS rather than anything like a pure implementation of it.
You're looking for const generics - it's not in the language yet, but it's being worked on [here](https://github.com/rust-lang/rust/issues/44580).
Looks like a pager, more or less
I'll excuse myself
I think this fixed it. I managed to get it working by doing fresh install of rustup and cargo (additionally I deleted whole .cargo folder cuz it failed during unistall due to access rights to folder)
He turned me communist /s but seriously: I was a right-wing libertarian and now I'm more of a lefty
I personally never look at build logs unless I get notified of a failure, so it looks like `allow_failures` wouldn’t be useful in my case. \(I do make things build with Nightly and block PRs on it.\)
&gt; All well-known joints have been implemented For a previous game I was using box2d/liquidfun-rust instead of nphysics because it didn't support the kinds of joints I needed.. I want to use nphysics for future projects, but where can I see the types of joints that are supported now? The docs still only show `Fixed` and `BallInSocket`: http://nphysics.org/doc/nphysics2d/detection/joint/joint/trait.Joint.html http://nphysics.org/doc/nphysics2d/detection/joint/joint/trait.Joint.html
I think "rage" would be even better: `dmsg | rage`. A verb just fits better.
I'm not making a judgement call on trait objects; I'm not familiar enough with UI access patterns to do that yet. The alternative I'm talking about splits components with different data into separate arrays. So instead of `Vec&lt;Box&lt;Widget&gt;&gt;`, you might have `Vec&lt;Position&gt;`, `Vec&lt;Rectangle&gt;`, `Vec&lt;Label&gt;`, `Vec&lt;Click&gt;`, etc. where each of those types is a fixed plain-old-data struct, and each entity may or may not have an entry. (Which means you may want something more flexible than simple "an entity is a `usize` indexing the component vectors.") As far as what to call your system, I'm not totally sure. It's got a graph built out of indices instead of pointers, but that's not really unique to ECS, especially in Rust. It's got a separate container in charge of a lot of what individual widgets often do, but ECS tends not to store *any* data outside of components. Really it just feels like a more holistic approach to a widget-object-graph.
&gt; Go has very fast compilation. Indeed! &gt; Also simplicity of the language is a feature — for learning, using, and processing. I am always wary of the simplicity argument. Whitespace is a much simpler language than Go, yet I'd rather not program in Whitespace... ... there's a trade-off between simplicity and expressiveness, and I disagree with Go's choice.
&gt;I don't see much point to this; it increases the complexity of the type-checking algorithm, especially in the presence of incremental compilation, and even when correct and fast, the results (errors or not) may be baffling for the user. I partly agree, at least it definitely isn't appropriate for Rust which already needs faster compilation time. Some people who use F# a lot often note major benefits from it when refactoring things. Like a whole set of functions that operate on some types, change one of the types, and everything works. Don't have to go fix up the function signature in a dozen places. Basically getting you some of the benefits of a dynamic language, while keeping compile time guarantees and runtime performance. 
We're getting further and further away from *language* features here! There's interest in getting rid of the libc dependency, especially in the context of embedded development, however libc provides a lot of functionality that are (1) well-tuned and (2) battle-tested. It will take significant effort to shed the dependency.
It seems that it relies on Docker images, so it won't run on Windows.
Go has recursive function types, which are mostly useless but exist. package main import "fmt" type recursiveFunc func() recursiveFunc func main() { var x recursiveFunc x = func() recursiveFunc { return x } fmt.Println(x()()()()()()()()()()()()) }
In general, accurate integration and simulation on e.g. manifolds is significantly harder than in Euclidean space, and would probably be best left for a specialized library, or even more likely, you would have to come up with a specialized physics engine for this particular application, since applications with these kind of requirements would probably have very different requirements. That said, if very high accuracy/efficiency is not needed, there are a number of workarounds. You could probably model this with a constraint function that requires e.g. centers of mass to lie on a sphere. Thus you're still simulating 3D objects in 3D Euclidean space, but you're just explicitly constraining the movement of your bodies to a particular surface. This is actually pretty easy. Every body would thus have such a constraint. Depending on your requirements, this might actually work rather well, especially since according to the release notes, a non\-linear constraint solver is used, which would likely maintain the spherical constraint without significant drift. I haven't used nphysics, but if it supports custom constraints, this might be a feasible approach.
You do often see conventional physics engines used for robotics prototyping.
General\-purpose rigid body simulators are frequently used in robotics research, for one. In fact, bullet, which is perhaps the most popular open source 3D physics engine, is increasingly being used more and more for robotics. While I'm sure you can simulate a three\-body problem with nphysics, I think that if you're actually doing \*research\* on the three\-body problem, you're more than likely using very specialized methods more suitable for this task \(the chaotic nature of the problem would make general purpose integrators deviate very quickly from the exact solution\).
I am really new to Rust as well but my understanding is that using the tools mentioned forces you to think about what you are doing. By forcing you to use Rc and Mutexes it makes you go "hmm I am using a lot of overhead and checks here..." but because of that you have a better understanding of what your software needs and where it might break. In C++ you might have glossed over that and run into a bug much later. There is nothing wrong with global state and it reduces complexity in many cases and Rust made you think about the pros and cons.
You can define numbers as types recursively with `struct Z;` representing `0` and `struct S&lt;T&gt;` representing number next to `T`.
FYI you can write such impls even today.
Cool, this interface does indeed look a bit nicer than svd2rust one. I have one comment though, I've looked at [ReadWrite struct](https://github.com/tock/tock/blob/bd5b5356bb3f24f9ebc2008f8433e244c90085ac/kernel/src/common/regs/mod.rs#L113) and I see that you are modifying data via shared pointer and that data is not in UnsafeCell. I think this is [considered an Undefined Behavior](https://doc.rust-lang.org/reference/behavior-considered-undefined.html) in Rust. svd2rust code is using [vcell crate](https://docs.rs/vcell/0.1.0/vcell/struct.VolatileCell.html) for this task and it has UnsafeCell inside. 
Thank you for engaging even after so long time! It seems I wasn't clear enough when writing about "purpose of the token". What I meant is why would the token be better than than a (crypto)currency. From the UX point of view, the ideal world for me is one gold-like currency that is accepted by everyone instead of several currencies. Any additional tokens just increase friction. &gt; However, speaking generally, the main purpose of the ledger is to have a decentralized database that no one entity can own and control by definition. You don't need a blockchain to implement a decentralized database. DHT and other technologies already exist. Also "have complete control over who has access to their personal information" seems to be better solved by cryptography and there doesn't need to be any decentralized database at all (of course, few backups would be great).
Derek would be interested to hear that, I think... I'm not aware of any plans to equip Rust with a module system, though people have definitely talked about doing it in the past. I'm actually not sure how well a 1ML-like system would fit with Rust--that sort of system always felt to me like something you'd want to build a language around from the getgo, not shoehorn into an already-established language.
I haven't performance tested it, but I have used it under load in production (I just made it generic to share) and didn't notice any issues. What kind of performance are you interested in? 
Also, on an unrelated note: anyone know why my crate didn't get auto-published to docs.rs? The documentation for crates.io seems to indicate that if you don't give an exclusive documentation URL, it will default to docs.rs
&gt; So if the system where you build has glibc at all, you should be able to run x86_64-unknown-linux-gnu rustc and cross-compile your programs to musl. My home systems don't :( But I can probably get my hands on one that does. &gt; As to making rustc itself use musl, https://github.com/rust-lang/rust/issues/31322 looks relevant. On a `x86_64-unknown-linux-gnu` system, can I build a `x86_64-unknown-linux-musl` build of rust and cargo without a cross compiler?
 let mut udppacket = match MutableUdpPacket::new(&amp;mut udpbuffer) { Some(p) =&gt; p, None =&gt; { return Err(Error::new(ErrorKind::Other, "Couldn't create UDP packet")); } Could be written as let mut udppacket = MutableUdpPacket::new(&amp;mut udpbuffer) .map_err(|_| Err(Error::.....)?; I'd also separate the build packet from the send packet. What if I want to build it, log the exact packet, then send it? Or mutate a certain field of the packet?
I don't use UDP very often, I just know its typically chosen when performance and latency are concerns, and the API for this looks like it could be expensive if you have to do that per packet. I'm really not sure.
Why so? What is the meaning behind this?
Until const generics are added to the language -- which appears to be moving forward albeit slowly -- you can use the typynum crate: https://github.com/paholg/typenum
it keeps up decently enough with a stream of data from another project running on an OLD embedded ARMv5 board. I don't have any hard data, however
Last I heard docs.rs was having some technical difficulties. 
That's definitely possible, and people have formally verified some `unsafe` bits in Rust's standard library before, so we know it's possible with real Rust code that's out there. Building it into the language though is a whole other can of worms - it's fine if a formal proof runs for a few hours, but it's not fine if your program takes a few hours to build.
/r/playrust
I know that I could use map_err, but the truth is that I think it makes it less readable and doesn't impact performance. As for separating the packet from the sending, you can modify CraftedUdp all you want until you want to send it. Further modifications would ruin the attempt to simplify/abstract away from the full pnet crate
You reminded me that its been a while since I've used rust and I'm a bit rusty. Time to redo all the exercismcises. 
Rust community is already pretty civil due to its very strict community rules and CoC. I find it hard you being able to beat what we already have!
Thanks. :)
That is true, but there are other efforts that would work to make Rust produce fully static executables. Either by using Musl libc, which is statically included, or a rust implementation of libc (i believe steed was one such effort?) Either way, LLD is a great first step towards making that possible.
You can define types that represent numbers and use associated const.
Ok. Nice!
I had surprisingly similar problems when working on [mutagen] (https://github.com/llogiq/mutagen), namely that having mixed borrows would trip up borrowck until I split them. Once I did it was smooth sailing.
&gt; Cool, this interface does indeed look a bit nicer than svd2rust one. Thanks! We've been having an informal discussion on how different it actually is and whether it's worth being separate (we'd thought of trying out svd2rust for a while, then someone just did a PR to add a similar, but different tool). We're now fixing some bugs that might clarify if there is indeed advantages one interface has over another, or if maybe we should just try to merge whatever good parts we have with svd2rust. &gt; I have one comment though, I've looked at ReadWrite struct and I see that you are modifying data via shared pointer and that data is not in UnsafeCell. I think this is considered an Undefined Behavior in Rust. That's a good point. I _believe_ under the hood it compiles to the same thing, at the moment. But migrating to using `UnsafeCell` is easy enough that we should just do it. _side note_: The Tock project has so far been hesitant to use external crates even if they are very good because it's difficult, with existing tooling, to reason about what does/doesn't use unsafe and needs to be in the TCB. Plus it adds some flexibility for us to iterate on things easily. But that's not a judgement of other libraries! 
Expect not too good-looking code (or let's say it's beautiful in it's own way) and longer compile times if you do. Still it beats doing nothing.
If I recall correctly, I've seen this paper before, when Rust didn't allow setting the system allocator.
Wow I'm surprised rg is so big before `strip`. Diesel CLI only goes 4.5M -&gt; 3.9M
OCaml also has first-class modules and functors (not the Haskell kind, but functions resulting in modules), as well as row polymorphism, i.e. polymorphic variants (sums) and object types (products). There's also a class system but it's semantically boring, just a way to write constructors of object types. It's not so boring when you consider the sense of despair you can inflict upon Java programmers when you exploit neat features such as class inheritance not implying subtyping :). OCaml's object system feels much more javascriptesque (that is, dynamic) than your usual statically-typed OO language. OTOH, OCaml doesn't have typeclasses/traits and associated features, which makes Rust a Haskell ally in a very old cold war.
I ran into a similar issue and reported it here: https://github.com/rust-lang/rust/issues/50459 I think macros are a bit broken at the moment
I, too, once despised OCaml's syntax. It just didn't feel right... OTOH, I also got used to it pretty quickly and some quirks are quite nice indeed (like `[1,2;3,4]` for a list of tuples). I'm completely at a loss why types use prefix syntax but it's not that bad. I won't ever get comfortable with Rust's angle brackets, though. Oh, and if you want you can use the [ReasonML](https://reasonml.github.io/) syntax. Semantics are exactly the same, it's just a different parser. The syntax is a bit javascripty because the very reason it exists was "we can't throw ocaml syntax at random web developers" but it makes sense on its own. No more "the type of `(1,2)` is `int * int`" and stuff.
Even renders in Firefox mobile! Can't scroll and zoom obviously.
&gt;Oh, and if you want you can use the ReasonML syntax. I just use F#, which gets me pretty similar to ReasonML Syntax, and threads.....I just lose my sweet sweet AOT comipled binaries. 
Doesn’t gnucash have a way to just import a CSV file without going through the hassle of converting it to another format?
You mean like a rust repl like [rusti](https://github.com/murarth/rusti)?
looks like I have been working on something that already exits. lol thanks. 
Thanks! Somehow missed the bit in the docs making reference to this.
I could imagine adding annotations to existing Rust source stating that some things are true, and have some external prover check them. But if you want the proof of correctness to be separate, then won't you have problems linking your proof statements to the source that they belong to? Most ways will be fragile to changes (variable/function names, line numbers, etc).
rusti is incredible!
&gt; &gt; Also simplicity of the language is a feature — for learning, using, and processing. &gt; &gt; I am always wary of the simplicity argument. Whitespace is a much simpler language than Go, yet I'd rather not program in Whitespace... &gt; &gt; ... there's a trade-off between simplicity and expressiveness, and I disagree with Go's choice. Agree - simplicity is only a feature if done right. There is the simplicity of finding a small set of core features that allow you to elegantly build the rest of the language as simple-to-use library code. Let's call it _Lambda Calculus Simplicity_. And then there is the simplicity of making the core as small as small as possible for the sake of making it small, throwing away stuff regardless of what needed to build the library. Let's call it _Turing Machine Simplicity_. Languages like Lisp and Smalltalk are Lambda calculus simple. Go is Turing machine simple.
It 100% maps to returning a boxed closure, but it's a lot easier to write let f x y = x + y in let g = f 10 in g 20 than let f = |x, y| x + y; let g = Box::new(|y| f(10, y)); g(20) Especially when you're doing this in a long chain of compose-y function stuff.
I forgot about polymorphic variants! They're weird. It's like you can duck-type your enums.
It's up now.
&gt;without a cross compiler? I’m not sure what you mean, rustc and LLVM are always cross\-compilers. \(They support many code generation backends unless you specifically configure those out.\) The linked issue has a lot of discussion but I haven’t read it in details. I don’t know what the remaining blockers are.
Maybe it can be used to build a state machine: package main import "fmt" type stateMachineFunc func() stateMachineFunc func x() (stateMachineFunc, error) { func main() { var x recursiveFunc x = func() recursiveFunc { return x } fmt.Println(x()()()()()()()()()()()()) }
They're kinda weird but kinda sensible also, integrals are basically big polymorphic variants, and there are cases where you have enums which overlaps or are subsets of one another and having to define completely separate enums with explicit conversions between their cases is a pain in the ass.
Right now, all I know is that it is possible to make nphysics work on wasm because this has been done on a previous version by Edwin Cheng (see https://github.com/sebcrozet/nphysics/issues/100). I intend to follow his recommendations whithin the next few weeks to ensure wasm support.
&gt; But if you want the proof of correctness to be separate, then won't you have problems linking your proof statements to the source that they belong to? Most ways will be fragile to changes (variable/function names, line numbers, etc). Right. They don't have to be separate in the sense that they sit in different files or different lines within the same file. What I mean is that there could be parts of the code that isn't part of the algorithm to be executed, but is there to guide reasoning about the algorithm. I guess things like type declarations already is an example of that. By the way, there are programming languages in which you can provide proofs for things (beyond merely that the types are correct), right? Where is the proof written in those?
Folding would be a useful feature for me in a pager. I suggested it to the `less` guy once but he wasn't interested. So effectively a mode where it hides all lines indented more than N spaces. Then have a couple of keys that could be used to increase/decrease N. (Optionally, for added convenience, have those keys increase/decrease N to actual indent levels found in the file.) This would be useful for getting an overview and then drilling down to the detail in all kinds of files.
&gt; it's fine if a formal proof runs for a few hours, but it's not fine if your program takes a few hours to build. Oh, does it have to take that long? I would have thought that going through and accepting every step of the proof would be quick. Is it a matter of allowing the author to leave out steps, to save work, and instead have the computer think harder to fill in those gaps? In any case, I would still consider it worthwhile. Proof checks could be cached, and you could opt not to run them with every compilation (just like you might not run the slowest tests all the time).
Interesting indeed. I've started to look at a native win32 widget wrapper and came to a similar conclusion. A flat vec&lt;&gt; as the backing store combined with an event based model to avoid mutable state. I would possibly suggest this is general programming pattern for Rust as I find I use this order/approach time and time again. * read immutable data, * generate events or new data to be added to state * return new data (or fire events) * mutably update state with new data * scope exit Maybe it should be in a beginner's guide or something as I was struggling with the borrow-checker before I understood this pattern. Also as a side note, the problem with some of the existing wrappers (e.g libui) is that they offer the simpler controls, but miss out on what makes Windows(tm) the experience it is, such as Ribbons, splitters, drag-drop etc. 
Only because debug symbols are included in release builds by default.
I intend to provide a more detailed (and illustrated) explanation of "reduced-coordinates" in the future webside dedicated to nphysics but here is a short description. Usually, to simulate a rigid solid in space, you compute the trajectory of its center of mass (with {x, y, z} coordinates) and its changes of orientation (with, for example 3 euler angles. nphysics uses euler parameters instead, but it does not matter for the explanation). So in the end you end up with 6 equations of motions: three for the translations (one per coordinate) and three for the rotations. If you want to constraint the solid to, say, only rotate wrt. a single axis (this is called a revolute joint), you have to apply forces to the solid so that it does not move away from this axis. In this case, you would have to apply three linear forces (one for each translation coordinates) and two torques (to prevent rotation wrt. an axis different from the joint axis). So overall, you end up with 6 equations of motion and 5 constraints. This is the "full-coordinates" or "constraints-based" approach. The "reduced-coordinate" approach encodes the joint constraint directly inside of the equations of motion. So in the example above, the position of the solid will be encoded with only one coordinate: the angle of rotation wrt. the joint axis. So you end up with only 1 equation of motion and no constraint at all because all the variables that could break the constraints (like the coordinates {x, y, z} of the center of mass) don't even appear on the equations of motion! That's how this approach make the joints simulated using reduced-coordinates "unbreakable".
I was thinking of JML and ESC/Java2 (or OpenJML now). The annotations are right there in the Java source. Hopefully someone else will comment on what other approaches might be possible.
I'll probably provide more details on the used algorithms on the user-guide of nphysics but here is a short list (sorry for the jargon, the user-guide will be more pedagogical): - Collision detection: GJK+EPA (for distance and penetration depth) and polyhedral clipping for contact manifold generation. - Integration: GGL time-stepping scheme (with an underlying simplectic Euler integrator). This includes a linearly-implicit integration of the equations of motion at the velocity level, and a non-linear position-based constraints stabilization (though this uses linear approximations of the neighborhood of the shapes at the contact points). - Contact model: either the Signorini model (non-penetration, without friction) or the Signorini-Coulomb model where the friction cone is approximated by a pyramid. - Multibody mass matrices computation: explicit construction of the mass matrix using directly the Euler-Lagrange equations of motion written using reduced-coordinates (i.e. only the coordinates needed to express all the degrees of freedom of each joint). The non-linear (Gyroscopic, Coriolis) terms are linearized in such a way that allows the implicit integration of the linear part of the velocity-dependent terms. I don't include derivatives wrt. the generalized coordinates though since that would have a significant performance impact. The main downsides of the reduced-coordinate approach are: - They are hard to implement. First, there are no reference in the literature that give all the equations explicitly so I had to derive them myself. Most references that approach the subject are based on Screw theory where twists and wrenches are written in the local-space of the multibody links. Those formulations are great for theoretical analysis in robotics, but behave badly in practice (because rotations and translations are always coupled non-linearly). So I had to re-study everything using twists expressed in the local-space of the parent of each multibody link instead to reduce the amount of non-linear coupling. - They cannot represent kinematic loops. Each joint must have a "parent" and a "child". So you can only for a tree-like assembly of multibody links. You can't use only reduced-coordinate joints to simulate, e.g., a chain with both ends attached together. But you can use them to simulate a chain, and use a constraint-based joint to attach the ends together. - There are case where they can behave badly, especially if a sudden, large, change of velocity happens. This is because the non-linear terms of the dynamics can get too large since they are not integrated fully implicitly. Though nphysics performs much better here than, say, Bullet, here since Bullet relies on Featherstone's algorithm which is very numerically unstable (it only allow an explicit integration of the dynamics). Interaction with other multibodies/contacts are actually quite straightforward mathematically speaking. The tricky part is more a question of code structure. 
Thanks! Any help is welcome. It all depends on what you are comfortable working on and what you would like to do. But in any case, creating cool demos using nphysics would help a lot promoting the project. Also, given your significant experience with game frameworks, integrating (is possible) nphysics on something like Unity for example would be amazing!
I don't intend to add an example like this because of lack of time for the moment but I agree that would be quite useful. Any contribution would be welcome here!
Thanks!
This is a flawed study using microbenchmarks. There are a number of factors which invalidate it and which the study does not appear to mention.
Isn't F# a rather serious downgrade, type-inference-wise, from the usual Hindley-Milner system that Rust, OCaml and Haskell all use?
Well if I ever get that platformer game thingy working, I'll be sure to contribute ;)
take a look at `rusti`
That's what dependent types are all about. But you implicitly *can't* separate the type and the value in a dependent type system.
Will something like [borrow regions](https://github.com/rust-lang/rfcs/issues/1215#issuecomment-333316998) help with "state splitting" described in the post?
Yes, but not with the usual tooling workflow. You have to emit bitcode from clang and rustc, then link them together. With the changes Michael's making, rustc will include bitcode in its object file output in a format that the linker understands.
Wow, great :) I see it also has a `Spring`, so it should be possible to make [something](https://i.imgur.com/v9N5Cw9.gifv) [like a](http://blog.wolfire.com/2010/06/Early-Gish-hacking) [Gish](http://cdn.wolfire.com/blog/a/fcgishthumb.png) which contains a lot of diagonal springs to get a bouncy blog? Btw, are there any plans to introduce particles so that it can be used to simulate fluids or particle-based bouncy blobs, like liquidfun? :) (E.g. the "Elastic Particles" example [here](https://google.github.io/liquidfun/).)
[Previous thread about Jupyter kernels](https://www.reddit.com/r/rust/comments/8dd90d/is_there_a_good_rust_kernel_for_jupyter/)
&gt; Is there is an existing parser for this? It's standard Rust syntax, so maybe you can use a crate like [syn](https://github.com/dtolnay/syn). &gt; Where can I find documentation or rules by which this name was created? Again, it's standard Rust syntax, except for the hash at the end, which disambiguates multiple symbols with the same name from different versions of a crate.
Ah, I was thinking something like monitoring tools. But the real time updates is the thing. Still… I can definitely think of uses for this lib :)
Serde is truly utterly amazing.
Something like Jupyter for Rust would be cool :)
As some additional background information, `Scrt1.o` is not just any old library, it's a special file used by the the compiler; it's responsible for doing the initial setup of the C library and calling C's `main()` function. I think Rust programs do a little more setup after that point before they call Rust's `main()` function, so `Scrt1.o` is still important. Since `Scrt1.o` is statically linked (that is, it's physically copied into in your program, not loaded from somewhere else at startup), none of `ldconfig` nor `LD_LIBRARY_PATH` will affect anything (as you discovered). If I had to guess, I would say that Anaconda's `cc` wrapper makes some assumptions which align with how Python uses the C compiler, but which are broken by Rust. It may be worth filing a ticket against Anaconda in case there's some way they can make their wrapper more Rust compatible, or there might be some Anaconda "development" mode you can switch off temporarily so you can use the Python libraries you've already installed, but it doesn't expose things like `cc` used for installing new ones.
Do you think modify() with closures vs. your apporach is mutually exclusive or is there maybe a benefit in implementing both? I tend to believe the latter. Any plans? We recently had a general discussion about register I/O in https://github.com/rust-lang-nursery/embedded-wg/issues/87 I see lots of different projects/people coming up with similar ideas, yet all resulting in different interfaces. I think an approach to come up with a "standardized" interface would be really nice, eg crate(s) defining interfaces. The issue on the embedded-wg did not get a lot of traction until now though.
&gt; Oh, does it have to take that long? I would have thought that going through and accepting every step of the proof would be quick. No, I think you're right, and K900_ is just unfamiliar with tye problem domain. Proof checking is quick enough to be readily usable in almost all reasonable cases; it is only proof *finding* that's potentially slow, and you only have to do that once as you write the code.
&gt; What I mean is that there could be parts of the code that isn't part of the algorithm to be executed, but is there to guide reasoning about the algorithm. I guess things like type declarations already is an example of that. Yes, this is exactly what phantom types are for. Combined with type-level data (which isn't yet a feature in Rust, unfortunately) you could use them to encode just about any proof about your program, even whilst leaving the main semantics of it entirely unaffected.
Rust no longer provides the API it requires: https://github.com/murarth/rusti/issues/86 In that issue, some people suggest building a REPL on top of Miri. I'm not sure what that would require, but it does't seem to have been done.
I can see how that might help in some situations, but what I'm doing is more about just using existing language capabilities fully.
I did something similar while working on my (now defunct) windows GUI library. A single system, named "UI", held the reference to the widgets, the system resources (such as fonts) and the events callbacks. The one particular thing is that the system holds no state, no graph or not data because everything is actually owned/handled by the operating system. 
Why won't it run on Windows?
As far as I can tell, symbolic-demangle only gives the demangled string, it doesn't parse the components of the demangled string.
Yes?
[attributes docs](https://doc.rust-lang.org/reference/attributes.html). I don't think it can be the way you want it to be, but you can hide the tests that require nightly behind a feature flag, and that way you can run `cargo test` `cargo test +nightly --feature mocking`
Maybe you could use the busybox-glibc docker for now? Or find a alpine-glibc?
I'd be tempted to drop the middle version, i.e. 1.24. With beta enabled maybe even 1.24 and 1.25 though not running CI on the current stable might be a bit ballzy. How often does something go `working -&gt; not working -&gt; working` in rust after all... even `working -&gt; not working` is uncommon on stable releases.
I’m hoping to put it into trust-dns soon... and by soon I mean at some point when I have time to focus on the authority again. :) BTW, it’s necessary with this project to say that I had A LOT of help. Please look at the changelog and you’ll see that https://github.com/yjh0502 and https://github.com/rushmorem did most of the heavy lifting. I hope people kick the tires of this. FoundationDB seems to offer some pretty amazing features, I hope it lives up to them.
&gt; PRO Clear syntax &gt; &gt; procedure test(); &gt; begin &gt; DoSomething(); &gt; end; I'm going to have to call "subjective" on that. I started learning Object Pascal as implemented by FPC around the same time I started learning Rust (because Rust can't target my DOS retro PC) and, to be honest, I think I lost about as much time getting used to the unfamiliarity of Pascal's top-level grammar (eg. multi-section blocks (var/begin/etc.)) as I did getting as far as I have with the borrow checker in Rust. That said, observing others has taught me that's more because I seemed to be anomalously good at learning the borrow checker's whims by reading about it before I wrote a single line of code.
Hey, mikedilger, just a quick heads-up: **existance** is actually spelled **existence**. You can remember it by **ends with -ence**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
I really have some high hopes for foundationDB. I hope too that the OSS community will take advantage of it (if it lives up to its reputation) and develop some awesome stuff. I just looked on trust-dns, I'd be interested in hearing your experience with foundationDB if you manage (or fail) to integrate it!
You should look at Microsoft Research's [dafny](https://rise4fun.com/dafny/Hello) for an example of what you're asking for. I've been looking at various kinds of formally verifiable languages, but the degree to which the programmer must hand-hold the compiler seems like it'd be a hindrance.
I bet I can get a blog post out of it. 
I don't think dtolnay created serde, but they are definitely awesome and I am not surprised to see them called out for that.
I have a good plan at the moment, so it should be easy enough. We’ll see, though!
In the `svd2rust` comparison: loop { /* Turn PA1 on a million times in a row */ for _ in 0..1_000_000 { gpioa_regs.bsrr.write(BSRR::BS1::SET); } /* Then turn PA1 off a million times in a row */ for _ in 0..1_000_000 { gpioa_regs.bsrr.write(BSRR::BR1::SET); } } It indicates that it turns it on 1m times, then off 1m times, but the code is the same. is the second supposed to be `BSRR::BR1::UNSET`?
I would _love_ to see partial application in rust. Not a must have though
A profanity matching tool. Back in college a buddy and I used to throw f-bombs and the like in our code. We had a blacklist of regex patterns for dirty words that was read by a script that recursively searched a directory and spat back code that wasn't clean. Sloppy solution. I've grown since then and don't have a need for it, but I apparently wanted to see how big and slow I could make an updated system that "intelligently" returns the word "clASS" four hundred times.
/u/ticki_ you don't know who I am but I wanted to take the time to let you know how much of an inspiration your work has been to me. The meticulous nature of your analysis has always impressed me. From the nature of your article, it seems like you feel like you weren't able to implement anything and get anything done. I am hopeful that your feelings soften over time, as your impact has been tremendous. Thank you for your efforts. I am sure that your future is very bright!
Hey, nice start. Some suggestions: - add more docs; - IPv6 support; - tests.
BSy (y=0..15) is for set and BRy is for reset. (Writing 0 to BSy or BRy has no effect)
Oh yep, I see it now. Thanks.
yes, but right now futures are not at all ergonomic yet. One day, hopefully.
Sorry for the late reply! When reading the source code of xi-win-ui, I struggled a bit to find all the ECS properties. In ECS, your components are pure data and systems provide the code that executes based on an entity's components. I'm a bit skeptical of trait objects, but that's probably because I'm coming from gamedev and we try to avoid those as much as possible. Now, would it be worth adopting Specs here? Hard to say generally. I like the way ECS separates data from logic and I find it much easier to understand, but I think for many people it's the other way around. If you're used to objects, you'll find it harder to think in terms of ECS. The approach you're using is more similar to what is often called "Entity System". It's basically what Unity3D does, where an entity has multiple components / scripts that contain both the behavior and the data.
&gt; complete type inference - even function parameters types can be omitted. Pretty sure Rust uses HM and global type inference was specifically removed from it because relying on it is considered poor form (possibly error message concerns as well). 
I am from Paris. Can I attend for free?
"ergonomics" :-p
&gt;It's standard Rust syntax It's not, really.
It's just a demangler. \&gt;Completely implementation defined I see.
So will 1.26 be released soon? Result in Main will be pretty cool
I have problems using `clippy`. When I follow [the clippy documentation](https://github.com/rust-lang-nursery/rust-clippy#usage) and first install `cargo +nightly install clippy` and then run `cargo +nightly clippy` nothing happens! All I get is `Finished dev [unoptimized + debuginfo] target(s) in 0.09s` and that's it (it's a library crate if that matters). The only thing that works for me is actually adding `[dependencies] clippy = { version = "*", optional = true }` to the `cargo.toml` and adding the `cfg_attr` attributes. What am I doing wrong? 
Go has implicit interfaces /static duck typing although rust may view that as an anti feature 
This kind of thing is why I don't let anaconda touch my systems. Sure, it's convenient, but it adds second, subtly different versions of executables and libraries to paths that can be found by applications. The number of headscratchers decreased significantly when I booted anaconda from my systems for good.
Oh, is this something that currently exists in Rust? I need to learn about it.
Wow! Is it vs code extension feature or rls own one?
You may not know [rls](https://github.com/rust-lang-nursery/rls) has built-in support for clippy. You can enable it with the `clippy_preference` config via your IDE, like atom/ide-rust in the gif, or enable it in source #![allow(unknown_lints)] #![warn(clippy)] This has been available for a little while, and in today's nightly. One caveat is that clippy is broken by nightly changes fairly often, when this happens rls may come *without* clippy. This currently makes the clippy lints a little unreliable from nightly to nightly if you are regularly updating, so keep that in mind.
Looks neaaat indeed ! I’ll give it a try if I find it !
This is a rls feature, the clippy diagnostics come down similarly to the rustc ones and should work with any language server client. For example, the gif is taken from atom ide-rust.
Found it in [Readme](https://github.com/rust-lang-nursery/rls/blob/master/README.md#configuration), thank you! Going to enable it now )))
The latest chapter of [Rust in Action](https://www.manning.com/books/rust-in-action?a_aid=rust&amp;a_bid=0367c58f) has proven to be quite the hydra. It's long (almost 70 pages :|). After lots of drudgery and many late nights, I'm beginning to be really happy with it. Among other things, readers walk through what hashing and balanced trees are while implementing a key-value store. I'm really looking forward to getting it in front of people. 
Wow, that's impressive. Well done for figuring it out.
Would [Idris](https://www.idris-lang.org/) be something in which you could do the same?
I can recommend any but RustFest (because of that weird social pressure that you shouldn't make your own thing stand out ;)). So, there's also Rust Belt Rust, but I don't know what the state this year is. It's usually in autumn. A conference in planning and already soft-announced is Rust Latin America (https://twitter.com/rustlatamconf), but that's going to happen early next year. Next RustFest is in autumn, and it's known that there is an asian conference in planning. AFAIK, I also heard of plans in India and maybe something in London. We are thinking about having a presence at FrosCon. Sooo: a lot "upcoming", when we know more, you will definitely see announcements on our Twitter account and our blog. Please be aware that Rust is not even 3 years old and this is a usual picture at that time :).
How does it make things worse?
In VS Code this requires adding `#![warn(clippy)]` to the source code. `clippy_preference` isn't available yet.
The content-o-tron is a project to help Rustaceans turning their knowledge into blog posts. The goal is (similar to the #rust2018 blogging campaign) to set topics and have people blog about them. The content-o-tron team will also help people who are not used to writing out in getting their articles done.
Yep, we really screwed the pooch on this one
I think you're looking for /r/playrust
I should look into that
I [blogged about it](https://llogiq.github.io/2015/12/12/types.html) in December '15. 
Is your crate somewhere public? Do you use workspaces? Is it a library or binary crate?
How can I use a library that is build on `tokio-reactor v0.1.1` while using `tokio-core v0.1.17`? More concrete: I updated `tokio-serial` from `v0.6` to `v0.8`. So the code changed from let serial = Serial::from_path(tty_path, settings, &amp;handle)?; to let serial = Serial::from_path_with_handle(tty_path, settings, &amp;handle)?; but of course `tokio-serial` expected a `&amp;tokio_reactor::Handle` instead of my `&amp;tokio_core::reactor::Handle` :-\
If you're not going to, I will recommend RustFest! The last two have been absolutely fantastic, and seeing the lineup for Paris is already delightful, I'm confident in saying you'll love it. Full disclosure: I've let myself being shanghaied into emceeing RustFest Paris. I don't make any money out of this.
- I also recommend testing the oldest supported version of Rust - I don't like looking at logs. Instead of allowing failures, I pin the nightly version.
Ipv6 is coming. Integration tests are stored elsewhere, but unit tests are coming too. Thanks!
Try adding `"rust.clippy_preference": "on"` to your user settings.
&gt;I don't see any reason to bake those into the language In fact, I'd consider adding them into the language *wrong*. It is not a fundamental abstraction and it is one that requires a lot of customisation by use-case.
Windows do have Docker. Well, it runs a Linux VM and runs the containers in that, but it does work.
Rust is in better position for this then Go actually, because it builds on the LLVM toolchain, which includes a good C and C\+\+ compiler. AFAIK Go does not. Note you'll still need at least the standard C library for the target, because the C/C\+\+ libraries must be linked against the same standard C library as the Rust ones or all hell will break loose.
&gt;stack vs the heap There is one very ugly wart in this regard though—arrays behave differently to other types.
I am not quite sure why, but the problem seems to be client side. The client only connects over a single socket for all three requests (`netstat -a | grep 50051` shows this). If I run two clients in parallel, they get served concurrently on two server threads.
That's correct, yes, but it actually shows the same problem when I use the Python API on the client side and fire off 3 asynchronous calls using the same `stub`. So I'm wondering whether I'm just totally misunderstanding the way gRPC is supposed to work.
Two things I've always hated about less: 1) absurdly slow searching. I usually grep a file first and then seek to the approximate location with x% before searching in less itself. This whole workflow is faster than searching in a modestly large file in less. 2) scrolling through long lines (1kB or so) is super slow I suspect a rust pager would fix #1 really well (since the regex crate is so fast), so if you fix #2 I'd definitely try this out at some point.
Ugh. It seems to work, but shows up as "Unknown configuration setting" in VS Code. Thanks.
another issue with no types in function signatures is it can make it harder to tell what a function does or needs, however in F# land we have nice tools that can automatically show you the inferred types either as code lens or on hover. so it is kind of neat. I could go either way. 
Also you can't take a pointer to a function's return value, until you bind it to a local variable I think? Definitely a few warts.
 Rust keeps popping up and with so many people discussing how great it is, I got kind of curious. The problem is, I am a noob to programming in general, so I don't know if it would be a bad idea to learn Rust over something more versatile and much more widely used like C#. As for where I'm coming from, I do know a bit of C and quite liked my time with that. I don't have any specific programs in mind that I need to develop, but I would like to keep my options open. I understand Rust has no GUI library, which is a shame, but I believe I could sort of work around that by instead creating say, a web app, with the underlying logic written in Rust? Any thoughts? I do realise I am asking the Rust subreddit, but I figure I might as well ask anyway :p.
Could you say more about the size increase in `regex-syntax`? I don't think I understood your explanation. It almost sounds like you might not have been accounting for the data tables in the crate before?
I saw that comment soon after it was posted, and expected immediate interest from developers and subscribers. But since that didn't happen (yet), I thought I'd bring more attention and exposure to it here.
I saw that comment soon after it was posted, and expected immediate interest from developers and subscribers. But since that didn't happen (yet), I thought I'd bring more attention and exposure to it here.
Could cargo bloat also measure the time taken to build dependencies, both individually (per crate) and transitively (crate + subdeps)? I'm trying to speed up builds and this would be immensely useful. I understand this is not related to the current exe size computation of cargo-bloat, but it would fit perfectly with the crago-bloat name itself, and it would still report on the effect of dependencies on a project.
Keep us update, we really need people who share such experience right now :)
It sounds like a task for a completely different tool. At the moment I don't even know if it possible to get such a data from cargo.
This doesn't seem that serious to me. Yes, it's a bug, but I don't see anything to suggest that it is going to be hard to fix, or have substantial consequences in the meantime. From the title I was expecting a soundness issue or something.
&gt; Oh, does it have to take that long? Well, not hours usually, but the Arc proof definitely takes a while to build..
Does RLS Still crash all the time and require restart? Is it searching the standard library yet? 
You probably want to use a thread-pool implementation ([rayon](https://docs.rs/crate/rayon), [rust-threadpool](https://github.com/rust-threadpool/rust-threadpool), [rust-scoped-pool](http://github.com/reem/rust-scoped-pool), [crossbeam](https://github.com/crossbeam-rs/crossbeam)) to launch and manage your workers. Rayon seems to be the popular choice because of it's ease of use: * [This PDF](http://publications.lib.chalmers.se/records/fulltext/219016/219016.pdf#page=18&amp;zoom=auto,-109,233) shows how threadpools work in various implementations. Section 3.1.2 provides an example of how to use Rayon's pool. * [This post](http://smallcultfollowing.com/babysteps/blog/2015/12/18/rayon-data-parallelism-in-rust/) provides a good overview of Rayon, but doesn't specifically cover how to use the threadpool.
Welcome to Rust! I find a good way to learn is to join existing projects, many of which have easy mentored issues. In practice this means you get to learn while helping the community. [This week in Rust](https://this-week-in-rust.org) has a weekly list.
I thought rustc/cargo could do this already in the unstable options. I could be wrong, and I'm on mobile at the moment so it's hard to find. I'll edit this with a more concrete answer once I get to a computer.
Why panic there at all? Just have your crate return a `Result`.
It's definitely launching multiple threads, because it's handling multiple clients, but each client only gets one thread, or at least each client is somehow blocked. It doesn't seem to be processing multiple commands from a single client asynchronously, though it does process multiple commands from multiple clients in parallel.
If you’re interested, I have written a few posts about my experience learning Rust and building DNS: http://bluejekyll.github.io/blog/
If you’re interested, I have written a few posts about my experience learning Rust and building DNS: http://bluejekyll.github.io/blog/
What worked for me (and this may not work for you just my 2 cents) was to not start out with the goal of "learning C" or "learning Haskell", but instead having a thing I wanted to build. Don't worry about complexity, or difficulty. If you want your desk lamp to be voice controlled then my god, make it so. And in doing so you will learn all about relays, transistors, micro controllers, the Arduino environment, interfacing with a Raspberry Pi, recording audio, making and receiving requests with AWS cloud transcribe. You would never come across all that completing code challenges on Hackerrank or watching C tutorials. Maybe Rust is the best language for that, maybe it's Python. But the knowledge you gain in all those areas will stay with you whatever tools you use. In the words of C. P. Cavafy: "As you set out for Ithaka hope the voyage is a long one, full of adventure, full of discovery."
Imho: Don't `panic` when you don't face an irrecoverable error. Print your message, and exit. Panic messages aren't really suitable to show to your users, if you can avoid it.
&gt; What few GRPC projects exist give me a serious “not quite there” vibe. This is true, for a number of reasons: - grpc (or a wider need for it) is relatively new, so there was no time for it to mature yet - the whole thing is rather monolithic, integrating many parts and technologies making it hard to adapt to your app - Rust implementations are new, so all those issues are magnified so if you want to use it, you will need to become grpc expert and most likely get involved in framework/library development. For now I am experimenting with it to see if benefits are worth the effort.
I don't know that I'm really in a position to say what we use in production, unfortunately. What I will say is that you will probably want to take a look at tower-grpc. This is an active, in progress project - it isn't on crates.io and isn't 1.0. I expect this to be what you'd want in the future when it has stabilized. https://github.com/tower-rs/tower-grpc
The main references I use is "Numerical Methods for Non-Smooth Dynamical Systems" by Acary &amp; Brogliato (https://www.springer.com/fr/book/9783540753919). GGL stands for "Gear, Gupta and Leimkuhler" which is a method for the discretization of differential algebraic equations so it can be extended to obtain a time-stepping scheme.
Cool, thanks!
Isn't it the case that process::exit causes memory leaks if invoked before the thread is unwound? I tend to write a panic hook in main that invokes process::exit once everything has been freed, but until then, *I* still need the panic info to debug the program.
Specialization isn't stable, and there are lots of known bugs. This looks no more serious than any other issue.
There is a reason that new features are under flags: it is likely that they are not working as expected, or that in the course of their implementation surprises appear. This one is surprising, certainly, but it's a rather "mild" issue compared to the previous soundness issues which affected the earlier versions of specialization! That being said, I would rather this is not allowed.
You got a new reader!
You're going deeper with this than I understand, sorry. But doesn't your OS clean up after you once you exited? I also don't see what info you get from a panic you can't get from dealing with the errors for debugging, but maybe I'm missing something :)
Could you show the code in question?
You are amazing. 
There isn't panic info you can't in an error afaik. But I also think there's no point not unwinding the stack before exiting. Dereferencing is a good practice.
Sure, but fair warning, it's long. Flexible opt parsing can be annoying. pub fn map_args(short_opts: &amp;str, long_opts: Vec&lt;&amp;str&gt;, env_args: Vec&lt;String&gt;) -&gt; (Vec&lt;String&gt;, Vec&lt;(String, String)&gt;) { let mut available_short: Vec&lt;char&gt; = Vec::new(); let mut available_long: Vec&lt;String&gt; = Vec::new(); enum Req{ Required, Optional, None } let mut short_req_map: Vec&lt;Req&gt; = Vec::new(); let mut long_req_map: Vec&lt;Req&gt; = Vec::new(); // map short_opts into available_short let mut already_mapped = false; { let short: Vec&lt;char&gt; = short_opts.chars().collect(); for (pos, chr) in short.iter().enumerate() { if already_mapped { already_mapped = false; } else { available_short.push(*chr); if let Some(next) = short.get(pos + 1) { match *next { ':' =&gt; { short_req_map.push(Req::Required); already_mapped = true; }, '?' =&gt; { short_req_map.push(Req::Optional); already_mapped = true; }, _ =&gt; { short_req_map.push(Req::None) } } } else { short_req_map.push(Req::None); } } } } // map long_opts into available_long for long in long_opts.iter() { let chrs: Vec&lt;char&gt; = long.chars().collect(); match chrs[chrs.len() - 1] { ':' =&gt; { available_long.push(long[0..long.len() - 1].to_string()); long_req_map.push(Req::Required); }, '?' =&gt; { available_long.push(long[0..long.len() - 1].to_string()); long_req_map.push(Req::Optional); }, _ =&gt; { available_long.push(long.to_string()); long_req_map.push(Req::None); } } } // now map passed args into positional and opt-arg pairs let mut opt_arg_pairs: Vec&lt;(String, String)&gt; = Vec::new(); let mut positional: Vec&lt;String&gt; = Vec::new(); already_mapped = false; for (arg_pos, argv) in env_args.iter().enumerate() { if already_mapped { already_mapped = false; } else { let chrs: Vec&lt;char&gt; = argv.chars().collect(); if chrs[0] == '-' { if let Some(start) = chrs.get(0..2) { if *start == ['-', '-'] { if let Some(_s) = chrs.get(0..3) { // handle as long let long: String = (chrs[2..]).into_iter().collect(); if let Some(pos) = available_long.iter().position(|_l| _l == &amp;long) { match long_req_map[pos] { Req::Required =&gt; { if let Some(next) = env_args.get(arg_pos + 1) { let n: Vec&lt;char&gt; = next.chars().collect(); if n[0] != '-' { already_mapped = true; opt_arg_pairs.push((long, next.clone())); } else if let Ok(_n) = next[1..].parse::&lt;i32&gt;() { already_mapped = true; opt_arg_pairs.push((long, next.clone())); } else { panic!("Option: {} requires an argument", long); } } else { panic!("Option: {} requires an argument", long); } }, Req::Optional =&gt; { if let Some(next) = env_args.get(arg_pos + 1) { let n: Vec&lt;char&gt; = next.chars().collect(); if n[0] != '-' { already_mapped = true; opt_arg_pairs.push((long, next.clone())); } else if let Ok(_n) = next[1..].parse::&lt;i32&gt;() { already_mapped = true; opt_arg_pairs.push((long, next.clone())); } else { opt_arg_pairs.push((long, "".to_string())); } } else { opt_arg_pairs.push((long, "".to_string())); } }, Req::None =&gt; { opt_arg_pairs.push((long, "".to_string())); } } } else { panic!("Invalid option: {}", argv); } } else { panic!("Invalid option: {}", argv); } } else { // handle as short for c in chrs.get(1..).unwrap() { if let Some(pos) = available_short.iter().position(|_c| _c == c) { match short_req_map[pos] { Req::Required =&gt; { if let Some(next) = env_args.get(arg_pos + 1) { let n: Vec&lt;char&gt; = next.chars().collect(); if n[0] != '-' { already_mapped = true; opt_arg_pairs.push((c.to_string(), next.clone())); } else if let Ok(_n) = next[1..].parse::&lt;i32&gt;() { already_mapped = true; opt_arg_pairs.push((c.to_string(), next.clone())); } else { panic!("Option: {} requires an argument", c); } } else { panic!("Option: {} requires an argument", c); } }, Req::Optional =&gt; { if let Some(next) = env_args.get(arg_pos + 1) { let n: Vec&lt;char&gt; = next.chars().collect(); if n[0] != '-' { already_mapped = true; opt_arg_pairs.push((c.to_string(), next.to_string())); } else if let Ok(_n) = next[1..].parse::&lt;i32&gt;() { already_mapped = true; opt_arg_pairs.push((c.to_string(), next.clone())); } else { opt_arg_pairs.push((c.to_string(), "".to_string())); } } else { opt_arg_pairs.push((c.to_string(), "".to_string())); } }, Req::None =&gt; { opt_arg_pairs.push((c.to_string(), "".to_string())); } } } else { panic!(format!("Invalid option: {}", c)); } } } } else { panic!(format!("Invalid option: {}", argv)); } } else { positional.push(argv.to_string()); } } } return (positional, opt_arg_pairs); }
Well, my main point is not showing panic messages to users, which I'd do quite a bit to avoid. Just my pet peeve, maybe :)
How does Typestate compare to JML or Dafny (that someone mentioned below)? Maybe I'm missing something, but I can't see how it can express the same things.
I meant that part of the code you referred to by saying &gt;Result expects static values, but the values I'm returning on success must be mutable because I don't think that's true.
For sure. I always avoid showing panic info to users, but the only way I know of to do it is with a seperate hook. 
Have a look at https://github.com/KillTheMule/nvimpam/blob/master/src/bin/nvimpam.rs#L56 (ignore the logging stuff for now). It's a common pattern, and there are no resources left that need to be freed when main ends (I think...).