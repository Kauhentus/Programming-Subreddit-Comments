No, just traits in Rust parlance. The fact that you can't have non-ref variables to traits means that it's very verbose and needlessly annoying to e.g. pass incomplete types through functions parameters. Not only is using refs a lot of chatter on its own, you need to jump through hoops to satisfy the borrow checker in cases that are transparently safe to a human reader. Hoops which involve boxes and rc and that's way worse than Java in terms of verbosity.
What is the motivation for this project? Why would I use it over radare2 or for that matter something like Ghidra?
&gt;skip\_serializing\_if excuse me but, isn't this for serializing values? The documentation covers that, my problem was with deserializing. I paused the project btw, but will post it here when I have something. Thx anyway.
&gt;Maybe you're already doing this, though? Ummm nope. However I am reading what you posted. As I said I am a noob Rust developer and kind of new to programming in general (been professionally programming for less than a year). These answers reminded me to unpause the project. Once I have a minimum working program I will post it here for you guys to see :)
Just wondering how I should place the lifetimes on so `inplace_map` will compile (which is basically a `replace_with` inspired map on container types which doesn't require `default` on the items) ``` fn inplace_map&lt; T, TStruct : IntoIterator&lt;Item = T&gt; + Default&gt; (f: impl Fn(T) -&gt; T, mut x: TStruct) -&gt; TStruct where &amp;mut TStruct : IntoIterator&lt;Item = &amp;mut T&gt;, &amp;TStruct : IntoIterator&lt;Item = &amp;T&gt; { let x_ptr: *mut TStruct = &amp;mut x; for item_ref in &amp;mut x { let ptr: *mut T = item_ref; unsafe { let y1: T = std::ptr::read(ptr); let fix_missing_elem = RunOnDrop { f: || { let y: TStruct = std::ptr::read(x_ptr); let mut i = 0; for item_ref in &amp;y { let current_item_ptr: *const T = item_ref; if current_item_ptr == ptr { break; } i += 1; } let mut j = 0; for elem_ref in y { if j == i { std::mem::forget(elem_ref); } j += 1; } std::ptr::write(x_ptr, &lt;TStruct as Default&gt;::default()); }, }; let result = f(y1); std::mem::forget(fix_missing_elem); std::ptr::write(ptr, result); } } x } struct RunOnDrop&lt;F: FnMut()&gt; { f: F, } impl&lt;'a, F: FnMut()&gt; Drop for RunOnDrop&lt;F&gt; { fn drop(&amp;mut self) { (self.f)() } } ```
I mean in Java everything, except primitives, are refs. And the wish for value classes shows that there's a desire for it. It's an inherent problem with how machines work. I do think that Rust abstract class story is very weak still. I personally would have liked that instead is impl they used `@` mostly because I think it should be usable anywhere a type is usable. fn abs_func(stringable: impl IntoStr) -&gt; impl SecretObj impl SomeTrait for impl OtherTrait As you see it gets a bit weird on impl statements. This is where the language will end up IMHO, but they're being slow I'm understanding this. It may not be convenient to make to so easy to hide the complexity and implications of using abstract as it leads to surprising code and other things (the main reason why it isn't like this right now).
Update:Think it’s 7pm cloudflair offices near London eye
Why trait object and not trait, why generic or trait object? Appreciate the explanations, but does it really have to be so... different? Like all the different ways to pass stuff around?
Glad to see that they're using Rust, but I wouldn't trust them with my money. The entire point of a cryptocurrency is that it's decentralized and trustless.
The source control team is using rust for a major project, [https://github.com/facebookexperimental/mononoke](https://github.com/facebookexperimental/mononoke), so with them all aboard the rust train, it's pretty well supported internally.
Yea, TBH I don't get all the nightly hate. I feel the only meaningful argument _against_ nightly is that it could contain exploits not yet found and this put your servers/etc at risk. That could be huge, but I always get the feeling that complaints against nightly having nothing to do with security. In reality, pinning nightly seems like the only sane thing to do in general for builds. And updating frequently helps you maintain compat without falling drastically behind and putting yourself at risk. Those two steps of pinning your builds and updating frequently _(I update my dev environment nightly)_ seem stupid simple and I've not encountered _any_ issues with this. I imagine it could be a mess if you have a large pile of dependencies all having varying degrees of nightly support. Yet, if you're in that scenario your problem isn't really nightly but rather the mess of dependencies on varying versions of nightly. Your problem is more that many libraries depend on nightly only features rather than you using nightly itself. Nightly gets a bad rap, imo.
https://github.com/dabreegster/abstreet/tree/master/map_model/src/pathfind is now using fast_paths. Starting a full day's traffic simulation of 110k agents on one of the maps has gone down from **23s** to **2.8s**. Preparation time is seconds for most maps, and about 5 minutes for the largest map -- but this prep only happens offline on my machine when reimporting map data. When players edit lanes and intersections in the game, preparing the contraction hierarchy again is **subsecond** thanks to reusing the node ordering. I couldn't be more pleased by these results!
1. It is not Java 2. It uses modern algorithms from the recent academic developments on decompilation and program analysis 3. It is an extension on top of radare2, not its substitute.
9 times out of 10 there's no difference between the two when it comes to open source projects, unfortunately.
Unless every single type you implement print for just has 2 fields `x` and `y`, you're not going to be copy-pasting the implementation between them, but making a different one for each, right?
Cargo-vendor seems to be what you’re looking for. https://github.com/alexcrichton/cargo-vendor
Unless I'm misunderstanding your question: Yes. How else would you like to accomplish it? You can, however, rely on some pre-existing traits and derive-Macros, depending on your particular needs: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=8eff098d63080cd1997e6f53239c89dc
Yes, though you can use the recently stabilized proc macros features to create your own custom #[derive()] attribute.
That would be very helpful, thanks!
* Library support * Tooling Other than that, it's great. Love it.
&gt; Is this the same principle in play here? Yes. Temporaries are generally free'd at end of line, so 'iter' would contain a reference that outlives its source.
I work at Facebook. Rust is getting more and more popular here. Lot's of upcoming projects are starting to use it.
Thanks. It could be helpful to your potential users if you included this information in the README.
[removed]
Ben here, I'm the tech lead on the Calibra team. Libra started with a blank slate -- all options were open. Once we made the decision to build our own blockchain infrastructure, the next question was what language to use. The team spent time considering different options, many of which OP listed. As a project where security is a primary focus, the type-safety and memory-safety of Rust were extremely appealing. Over the past year, we've found that even though Rust has a high learning curve, it's an investment that has paid off. Rust has helped us build a clean, principled blockchain implementation. &amp;#x200B; Part of our decision to chose Rust was based on the incredible momentum this community has achieved. We'll need to work together on challenges like tooling, build times, and strengthening the ecosystem of 3rd-party crates needed by security-sensitive projects like ours. We're looking forward to working with the Rust community for years to come. I'd love to hear your thoughts on ways that we can work together to continue building the momentum behind Rust.
Traits are a language mechanism for describing an interface, which in turn can enable two different mechanisms: one is called 'generics' and the other is 'trait objects'. The difference between them is that generics are monomorphized at compile time in order to maximize performance, while trait objects use a layer of indirection to enable dynamic switching at runtime in order to maximize flexibility. So there are really only three 'path's here: 1. struct/enum: used when you care only about data, and offers little code reuse. 2. trait + generics: used when you care about the interface, and it allows you to get code reuse without performance penalties. 3. trait + trait object: used when you care about the interface, and it allows you to get maximum code reuse, but there is a performance penalty. The problem these variations solve is that there seems to be a fundamental trade-off between performance and flexibility in computer programming. These options let you choose your priorities. Since Rust aims to be both a high-performance language and a highly composable language, it must offer some way of making this trade off. OOP languages do the same, and they are no more complex, though they may be more familiar or forgiving in different ways.
Why not a VM in wasm/asm.js? Wouldn't that be much faster?
A lot of blockchains are real-time systems, and need to be heavily optimized for both throughput and latency. The reason is - they need to process a lot of cryptographic data, and act on consensus rules in a timely manner. It's glaringly important in case of PoW mining, when latency can mean orphaned blocks, which leads to network centralization. But even in PoS and other systems it's very important.
The nodejs native nodes are already pretty fast, and sync in browser nodes is quick as well (especially with Nano consensus). I can't wait to see what Rust for the native nodes does to improve performance, and I hope the Rust can be compiled down to WASM as well to bring the same improvements to the browser nodes as well!
Java has many functional features.
awesome, this is incredible, do you have a program for this?
It would also be useful to give some context about what you're exactly looking for, in what way the gtk-rs.org documentation could be "more friendly" :)
Are you hiring?
I'd be more interested in seeing the output of `cargo-geiger` to gauge how much unsafe code there is total, including dependencies. For example, they're using the C library for gRPC.
Yeah the language is more or less evolving in the right direction, that I can't deny. As a side topic though, I personally don't understand the wish for value classes at all. Manipulating medium-sized structures as values is just slow and unnecessary. Why copy 24 bytes when you can copy 8 instead for the same semantic effect? Not to mention that in any but the most trivial programs there will be structures with pointers to structures containing pointers to other structures and so on easily 5 levels deep. If you want to copy that around then either you make a semantically incoherent shallow copy or an excruciatingly slow deep copy. I get that dates, strings and the like can be values in certain circumstances, but that's a very narrow field of application.
Ethereum has already tried that and failed miserably. Last time I checked using WASM instead was all the rage, including contracts written in Rust and compiled to WASM. It's surprising that they went with their own language.
[yes :-)](https://www.facebook.com/careers/jobs/294785947846414/)
Please don’t legitimize facebook’s doings, they are pure evil. Plus their blockchain is just a cash grab and not legit.
The linked cleanup project had nothing to do with Ethereum - the money ended up as fiat anyway, and would have worked just as well with a centralized tracking system which would be way cheaper to boot. I'd love to read about an actually working decentralized exchange though. Care to give me a link or some keywords to google?
It's only a few months until early 2020. When will async/await be stable?
Wrong subreddit, you want r/playrust.
r/playrust
There has also been a lot of work on reducing the size of generators (which, even if you can't construct a them directly yet, are still underlying the implementation of async/await), so if you have code where you make complex generators it would be great to see their size_of to attempt to find real-world cases where the existing size optimizations might not be sufficient. Here's the issue tracking this: https://github.com/rust-lang/rust/issues/52924
True, but it has more features borrowed from functional languages than the average imperative language does
Seems like we have a lot of anonymous cowards just downvoting discussion of money here. Or is it just because they think it is off-topic for /r/rust ???
Why didn't you send a pull request to ripgrep that includes these features? This is not to say that I don't like your project! Just wondering and thinking about it. :-)
Is there any benefit of using Rust over Erlang for a blockchain?
It's a cryptocurrency. It's kind of a cash grab by definition.
Since you started with a blank slate, why didn't you choose to have private transactions? Since your mission as per the github repo is "global currency and financial infrastructure that empowers billions of people", I'm sure you are aware that public transactions are a great danger for today's live and extremely dangerous for authoritative states, while if you had private transactions you could be a way to free these people.
I didn't actually ask, but I doubt burntsushi would want to maintain this, since he's already kind of on guard to not increase the scope of ripgrep too much, and has previously rejected requests to include searching in archives (though not sure if rejected as "don't want to bother building that myself" or "out of scope")
Blockchain doesn't help with it at all.
Not necessarily, the good ones are projects focused on the technology and not about getting rich.
I'm sorry for your loss. Yes family is much more important. I hope it all works out for you in the end.
Rust is a perfect language for cryptofin. I've been repeating that for like 2 years now. :D
 This email-based challenge response doesn’t provide a strong verification, of course. It only checks that a person who can read the verification email (either the user, the email provider, or a machine in the middle) has followed a link. But this protection is already enough to discourage drive-by vandalism, and untargeted attacks. Wouldn't it more effective and convenient to ask the user to reply to the verification email and sign the relpy ?
I've building a scientific tool which uses a lot of powf and some exp functions. Currently the program is spending about 70% of the time just doing these calculations on the larger tests. Does anyone have any arcane knowledge, rust or otherwise that could help speed this system up?
Guess what language those move testcases are written in? Rust! [https://github.com/libra/libra/blob/master/language/functional\_tests/\_old\_move\_ir\_tests/src/tests/publish.rs](https://github.com/libra/libra/blob/master/language/functional_tests/_old_move_ir_tests/src/tests/publish.rs) It reads like it's more about providing a stable VM spec on the network so you can run move scripts. They seem to be making it progressively higher-level, so the intention is this is more a way to declaratively state common Move idioms. Granted I just found out about this language an hour ago so I could be off, but it doesn't sound like Move is a direct competitor to Rust at all.
Ah, I see. Very cool that this did not stop you from extending the project this way!
What are the blocking issues for landing generators in stable?
What's more efficient, returning a struct (in my case,the code at the end of this comment) from a spawned thread or sending it through a channel? I guess this question can be summed up as "are function returns or channels faster in Rust?" &amp;#x200B; `DataPoint{` `time_stamp: i64,` `time_stamp_mili: i64,` `key: String,` `value: String,` `num_value: f64,` `}`
Thank you, the three paths nailed it.
OK, finally time for me to learn Radare2. Been putting it off forever. Thanks for the highly motivating project!
It's about obfuscation. So when you simply compile it to some well known format it's not really obfuscated right? The same technique exists in binary obfuscation. So it's not necessarily about bytecode but rather to have a unique bytecode.
I get the bytecode, I'm wondering why is the VM implemented in JS and not in Rust compiled to asm.js or WASM. That would make the VM much faster at interpreting the bytecode.
Can someone help describe the async/await system for me? What it does and why it's important?
I see, yeah you could probably do it that way. Interesting idea. Definitely something to consider in the future.
Why did you decide to go down the way of the *account-based* abstraction? Isn't the UTXO model the most straightforward form of implementing a *"single-versioned distributed database"*?
When using Rocket, it seems like the default choice has been made that when a `from_form_value` fails, 404 is returned. How do I change that into a 400? Context example below. If I'm doing `curl localhost:8080\?user_id=abcd` I want to retrieve a 400 and let's say a json body containing an error message. #![feature(proc_macro_hygiene, decl_macro)] #![feature(never_type)] #[macro_use] extern crate rocket; #[derive(Debug)] struct UserId(String); use rocket::http::RawStr; use rocket::request::FromFormValue; #[derive(Debug)] enum APIError { InvalidUserId(String), } impl&lt;'a&gt; FromFormValue&lt;'a&gt; for UserId { type Error = APIError; fn from_form_value(v: &amp;'a RawStr) -&gt; Result&lt;UserId, APIError&gt; { let user_id_candidate: String = v.parse::&lt;String&gt;().unwrap(); match user_id_candidate.len() { 3 =&gt; Ok(UserId(user_id_candidate)), n =&gt; Err(APIError::InvalidUserId(format!( "userid must be 3 characters long, not {}", n ))), } } } #[get("/?&lt;user_id&gt;")] fn index(user_id: UserId) -&gt; Result&lt;String, APIError&gt; { Ok(format!("Hello, {}", user_id.0)) } fn main() { rocket::ignite().mount("/", routes![index]).launch(); }
If it helps, this is equivalent to the one-liner which doesn't compile: let mut iter = { let line = line?; line.split(",") };
An accepted design, for one. They only ever had an eRFC, not a real RFC.
The shortest summary I can give is that async/await is important because it allows you to write asynchronous code with the same ease as you write synchronous code.
Ok, I can see that. I appreciate the reply. Thanks!
Are you compiling with --release? Are you using functions from the stdlib? They are probably already optimized algorithm-wise (for an average input), so there's not much to gain there. SIMD would probably help and I have heard good things about [faster](https://crates.io/crates/faster). Parallel calculations can easily be implemented via [rayon](https://crates.io/crates/rayon) in case you aren't using multiple threads already.
[`uom`](https://github.com/iliekturtles/uom) (type-safe zero-cost dimensional analysis) was the crate of the week in [TWiR](https://this-week-in-rust.org/blog/2019/06/11/this-week-in-rust-290/) last week! All the extra traffic brought some new issue submissions and PRs which I've been responding to. I also fixed a [codegen](https://github.com/iliekturtles/uom/pull/144) issue that was creating non-zero cost code (`value` + 0.0 doesn't get optimized to `value` for floating point numbers)! This week I'm planning to get a new release out.
If you only care about performance, rewrite it so it runs on a GPU. If you can't do that, rewrite the program to use SIMD. And for a quick and simple performance boost, use the rayon crate to add threads to the program. If the tool uses a lot of powf, then it obviously will spend a lot of time doing powf. If that shouldn't happen ask yourself how to avoid some of the expensive operations. If that should happen, then you really want to use a GPU.
If you don't mind, see if I get this right? a. This (with `do_stuff` signature) is the naive way to say you don't care what it is, as long as it's an `Iterator` and this way it does not work, Rust says `expected trait std::iter::Iterator, found struct std::iter::FilterMap` as expected. use std::io::{BufReader, BufRead}; use std::fs::File; fn main() { let reader = BufReader::new(File::open("src/main.rs").unwrap()); let lines = reader.lines().filter_map(|x| match x { Err(_e) =&gt; None, Ok(v) =&gt; Some(v) }); do_stuff(lines); } fn do_stuff(iter: Iterator&lt;Item=String&gt;) { iter.take(3).for_each(move |x| { println!("x is {}", x)}); } b. So I have to express this idea via generics syntax? fn do_stuff&lt;T&gt;(iter: T) where T: Iterator&lt;Item=String&gt; { iter.take(3).for_each(move |x| { println!("x is {}", x)}); } changing just the `do_stuff` signature worked. And that makes the call fast because there's no indirection. c. I can try to do the same via trait objects fn do_stuff(iter: impl Iterator&lt;Item=String&gt;) { iter.take(3).for_each(move |x| { println!("x is {}", x)}); } and that also worked! But now there's some kind of indirection for each time this function is called so it's slower. There was something about `Box&lt;dyn Iterator&lt;Item=String&gt;&gt;` as well, in the questions thread. Why would I need to use the boxed version please? Would that be only for struct fields, or for function arguments as well?
&gt;6+ years coding experience in C, C++, Java and/or C# How come there's no mention of Rust?
dunno why this is downvoted really, it might not be a *functional language* but having used a lot of rust and haskell, rust is the closest 'feeling' to haskell as far as a non functional language can be, rust's ADTs are great and feels very haskell-y to me
please don't mistake this as some kind of attack, but a subreddit I took over moderating ages ago /r/bitcoinmemes has been getting flooded with spambots who post one joke to the subreddit and have another post in /r/nimiq, do you have any idea what this is? Examples: https://i.imgur.com/W1AQ3aR.png https://i.imgur.com/w0B3tiL.png
My semi-worthless opinion, as someone without a ton of experience in this area: Go is currently (*currently*) easier and more mature than Rust for web development. Rust is catching up quite rapidly, however. Rust is much better than Go at blockchain-type things: safer and more efficient. Rust's story for networked systems is pretty good — probably fairly comparable to Go's. You should probably learn both and decide for yourself. Go has a much shorter learning curve; Rust is way more fun. :P
If you really want to get into Blockchain, then Rust probably is a good option. I'd personally advise against getting into Blockchain dev though. So far the useful applications seem pretty limited. As a new programmer, you may also be better off sticking with one set of technologies to start with, and learning them in greater depth (if you are interested in pursuing a career in technology, then your first job will be a huge learning experience). That said, it is also important that you are interested in what you are learning.
What kind of projects?
We're running pretty large cass and ES clusters where I work, and (unpredictable) GC pauses are definitely quite an issue for us... We've probably spent quite a few engineering-months on optimizing/debugging/diagnosing them.
Your version C is not using trait objects, it is actually using generics and equivalent to your version B. (Which is why some of us were not thrilled about the language including `impl Trait` in argument position, but apparently some people think the terseness of it has some value.) &gt;There was something about Box&lt;dyn Iterator&lt;Item=String&gt;&gt; as well, in the questions thread. Yes, this is how you actually do trait objects. There are several different forms, depending on how you want to the object to be shared or owned: Shared reference: `&amp;dyn Iterator&lt;Item=String&gt;&gt;` Unique reference: `&amp;mut dyn Iterator&lt;Item=String&gt;&gt;` Owned: `Box&lt;dyn Iterator&lt;Item=String&gt;&gt;` Reference counted: `Rc&lt;dyn Iterator&lt;Item=String&gt;&gt;` These will let you use any iterator, but they all require a pointer deref to access the object. The extra flexibility here is obvious when you want to pack different kinds of iterators into an array or `Vec`, for instance. You can't do that with generics.
I completely understand what you mean by the useful applications being limited. What technologies are you referring to, or what could be some examples? For a self taught Rust developer, would there be much opportunity for me, given that I don’t have a CS degree? Also, thank you for answering
I don't think a CS degree is needed very much in this industry for *most* software development jobs, so don't worry about that. Most jobs require "CS degree or equivalent, so if you can show that you are competent and a good fit, then the degree doesn't matter. Rust is a *fantastic* language, and I think learning it now will be a boon to your career long-term, but right now there are not many jobs that require Rust. Right now learning Go is more likely to net you a job in the present moment.
It sounds like you want to use `Error1` as your error type. This will let you implement `From&lt;postgres::Error&gt;` and also `Responder`. A simple implementation might look like: impl&lt;'r&gt; Responder&lt;'r&gt; for Error1 { fn respond_to(self, req: &amp;Request) -&gt; response::Result&lt;'r&gt; { rocket_contrib::json::Json(self).respond_to(req) } } You would also need to derive `Serialize` (for `Json`) and `Debug` (to use as the error type of `Result` and have that `Result` work as a `Responder`. A smarter implementation would serialize the error as json only if the client wanted json, and HTML or text otherwise.
Understood. So I’ll begin to learn Rust and hopefully build a portfolio of mini programs to demonstrate my understanding. I’d say I’d learn both, which I would like to eventually. But I think as a beginner I might naive to think I could learn both simultaneously with the little knowledge I have now. Are there any specific learning materials you’d suggest, or know where I could find some? Again, thank you for taking time out to reply and give a non-biased opinion
&gt; What technologies are you referring to, or what could be some examples? I was picking up on you saying that you got into web development. It might be better to stick with that rather than jumping into something else. Then again, it can be fun to try new things and fun is important. &gt; For a self taught Rust developer, would there be much opportunity for me, given that I don’t have a CS degree? I don't think that a lack of CS degree will hold you back too much. But lack of experience will. There are currently not many Rust jobs in total (say 1 for every 10000 JavaScript or Java jobs), so you'll probably struggle to find one as a new developer. If you are looking to become employed quickly/easily, then I would recommend focussing on a single popular language. JavaScript, Python, or Java would all be good choices. In the US Ruby is also popular, outside of the US PHP is popular. These languages are also easier than Rust for a beginner. Go is pretty close to joining this list I suppose. I don't wish to put you off learning Rust. It's a great language. My favourite in fact. But as a beginner seeking employment, it's probably not your best option.
Most of the world does not pay their taxes in dollars.
Thank you for replying, I have heard about GO being good for web dev, but Rust being substantially better at distributed systems appeals to me more. This is something I’ll dig into. I’d like to learn both eventually, just trying to narrow my options so I don’t overwhelm myself and end up throwing the towel in haha. Thanks for replying
I don't think I can go in depth because of NDA. Plus I work on the machine learning side which is still python for experimentation, C++ for production. But Libra is a great example. Also portions of hhvm are written in Rust. Small new high-performance applications tend to be written in Rust.
Damn. But, thank you so much. But damn. I mean, no offence to the language team, but to a newcomer this does look convoluted and confusing. Thanks to all the helpful people here I might be able to finally rewrite all my log processing tools in Rust, that's what counts! And then hopefully move onto serious production services. Let me sum up: - If I don't care what the argument is as long as it implements `Iterator`, there are - `where T: Iterator` - `impl Iterator` (same as above) - `Box&lt;dyn Iterator&gt;` - `&amp; dyn Iterator` / `&amp;mut dyn Iterator` - `Box&lt;Iterator&gt;`, `&amp;Iterator`, `&amp;mut Iterator` is same as above but deprecated On top of that, I'm guessing: - If I specify just `Iterator` in the arguments, it will only work as long as the passed type is exactly `Iterator` (which means struct right?)? - `dyn Iterator` is same as above because if I add `dyn` the error message stays the same. I guess the `dyn` syntax here is also new. I wish a table like that was in the Rust tutorial. Or maybe it is and I missed it.
If you want to get into blockchain specifically, you might want to look at [Solidity](https://solidity.readthedocs.io/en/v0.5.9/). Of course you can *only* use that to make apps on the Ethereum blockchain. Go's main advantage over Rust is that it's *much* easier to learn. Rust's main advantages over go: * Safety guarantees. If Rust code compiles it won't have most kinds of runtime errors. If you're implementing your own blockchain/cryptocurrency this can be an important consideration, because you'll have fewer potential exploits. * No GC (garbage collector). Can you afford to have your software occasionally pause for a few milliseconds to clear unused data from memory? The answer to this is probably yes. Unless you're a fairly experienced programmer I would not recommend learning Rust, because it's got a pretty steep learning curve. You could probably learn Go in a few weeks. Mastering Rust will is likely to take months. My advice would be to learn Go first and then maybe look into Rust.
Ok, so those last two... they are both invalid attempts to create a trait object. They're like `Box&lt;Iterator&gt;` and `Box&lt;dyn Iterator&gt;`, but without the `Box`. Trait objects are required to be encapsulated by pointers, because their internal state doesn't have a fixed size. So if you use those last two, you are trying to pass an object of unknown size to a function, and you'll get an error.
For the curious, you Mint coins using the [Faucet](https://developers.libra.org/docs/reference/glossary#faucet) which is only on testnet - where the coins have no real-world value. This does not seem to be a land-rush to begin mining like bitcoin was. See ["My First Transaction"](https://developers.libra.org/docs/my-first-transaction) for more.
If you plan on working with blockchain, maybe it would be better for you to learn how to write Ethereum contracts or something like that. Even if your objective is to create a new cryptocurrency, it's probably easier to implement it as a contract in the Ethereum blockchain than doing the whole thing from scratch in Rust or Go. &amp;#x200B; [https://solidity.readthedocs.io/en/v0.4.24/introduction-to-smart-contracts.html](https://solidity.readthedocs.io/en/v0.4.24/introduction-to-smart-contracts.html)
No it's for deserialising values.
If you got the team to just focus entirely on educational materials, it would be a huge win.
I scrolled around on your demo you have there. It's pretty responsive!
The community needs more educational materials used to onboard experienced programmers with Rust. Tutorials. Documentation. Commented examples. Recipes.
&gt; say 1 for every 10000 JavaScript or Java jobs Probably mildly pessimistic. [These statistics](https://www.statista.com/statistics/793628/worldwide-developer-survey-most-used-languages/) vaguely suggest something better than a 100:1 ratio. However, Rust is on a growth curve right now, while JS and Java are pretty mature: one might expect an excess number of new Rust-related positions as organizations ramp up. I'd guess 50:1 at this point. &gt; These languages are also easier than Rust for a beginner. This is a big factor. Rust is tough even if you know some C/C++ going in: if you're not fluent in any programming language it may be pretty grim. Learning Rust this early is a bit of a gamble: if it grows like it looks like it might you'll be way ahead of the game; if it flattens out you'll know a niche language few care about. (For example: Forth, once; Ada, once; Smalltalk, twice.) I've done the spectrum in my career: early adopter of C (woohoo), early adopter of Java (good call), reasonably early adopter of Haskell (meh), early adopter of ML (doh), reasonably early adopter of Rust (???). I actually regret none of these, because I learned so much from them — but I ended up in academia where I don't have to worry about language trends to eat well.
Hello, everyone! I am porting a Java WebSocket app over to actix-web and I ran into an issue and haven't been able to find a solution in the docs. &amp;#x200B; Many of the messages we send are hundreds of kilobytes, and in actix-web, when trying to receive those message, I am receiving a ws::ProtocolError `[2019-06-18T21:34:54Z ERROR acquisition_server_new::server] Overflow".` &amp;#x200B; The docs ([https://docs.rs/actix-web-actors/1.0.0/actix\_web\_actors/ws/enum.ProtocolError.html](https://docs.rs/actix-web-actors/1.0.0/actix_web_actors/ws/enum.ProtocolError.html)) point out that this error occurs when a payload has reached its size limit. &amp;#x200B; Could someone point me in the right direction for increasing the size limit for WebSocket payloads? Thank you and I look forward to discussing the issue with you.
Why not? I thought a cool thing about blockchain was having a public immutable ledger. That seems useful in this case
/u/Nuc1eoN 's comments on the matter feel very cold given the circumstances. Shame on you. I hope fschutt gets all the support he needs for the future.
&gt; Currently there is no support for modals Hooray! Please don't fix this: modals are a terrible user experience. Our modern machines are all capable of dealing with a dialog at the same time as everything else; our modern users expect them to. Please don't lock my app or worse yet my entire desktop while I try to find where the modal dialog is.
Solidity has a lot of disadvantages, and a lot of projects are actually moving to WASM instead.... which Rust compiles to.
I'd start out getting a good grip on Python. It is easy to code in, has applications almost everywhere and has ready-made libraries to do everything ever. Once you have Python as a basis, branching out into something like Ruby or JavaScript will be dead simple, while Go and Java should also come fairly naturally. On the other hand, Rust is somewhat weird and skills in it are not directly transferable to other languages.
You'll be able to put together a much more comprehensive web application using a dynamic language, such as Python or Ruby, because the language is easier to use and has a vast ecosystem of libraries and utilities to help you get started. Why not start there first, get lots of exposure, and when you're more experienced come back to Rust?
I think you're looking for /r/playrust. This one is for a programming language.
So does Go, to be fair.
&gt; There's probably an even more efficient version of the last one. There [is indeed](https://lemire.me/blog/2016/06/30/fast-random-shuffling/). Here's my Rust implementation, which is minimally tested and probably should not be trusted. pub fn gen_range(&amp;mut self, n1: u32, n2: u32) -&gt; u32 { assert!(n2 &gt; n1); let mut r = self.get_u32() as u64; let n = n2 - n1; let mut m = r * n as u64; if (m as u32) &lt; n { let t = -(n as i32) as u32 % n; while (m as u32) &lt; t { r = self.get_u32() as u64; m = r * n as u64; } } (m &gt;&gt; 32) as u32 + n1 }
Thanks
ay just port rust to all C platforms so nothing need be implemented in unsafe languages again
Solidity is writing smart contracts, not implementing consensus nodes in cryptofin systems. Just saying. Also considering how quickly this space moves, and how immature things are, there's a very small chance that Solidity is still going be around in 2-4 years.
Writing a smart contract and creating a cryptocurrency are completely two different things.
Go is a low stakes choice. It's simple enough to learn it quickly. If you are in mood of learning something quickly and using it right away, Go is the right thing to go (no pun intended) after. Rust is the challenge course: you have to invest a lot of time and effort, but the rewards are higher.
If you really want to work with distributed systems, I'd suggest learning Erlang. If you want to build a distributed, high-availability, soft-realtime system, Erlang is the tool for the job. Discord, IRCcloud and WhatsApp backends are in Erlang. Erlang is a functional language, so unless you've tried something like OCaml before it's worth learning just to expand your horizons. It will make you a better programmer. There is even a really good free book on it: https://learnyousomeerlang.com/
Yes, that's precisely what it does.
Rust is the language tailor made for cryptofin. FB just released Libra, written in Rust, there's a big part of Bitcoin developers doing Rust code, best ETH implementation is in Rust, and there's plenty of other coins (Solanaa, Maidsafe, etc.) implemented in Rust.
&gt;The entire point of a cryptocurrency is that it's decentralized and trustless &amp;#x200B; I would argue that that's the entire point of Bitcoin, but not the entire point of the blockchain. The blockchain is less opinionated, being a log that is append only and where ground truth is formed gradually by consensus between parties writing blocks. &amp;#x200B; Blockchain don't say how many distributed parties there should be, whether or not M out of the N should trust each other, how the consensus is eventually resolved, what the frequency of block writing should be.. It's a very open book.
I wish they would enable unstable flags into beta, and allow stuff to downgrade from beta back to nightly so some stuff could actually move into beta
Ok 6 years of rust experience too
There is a [Rust Secure Code WG](https://github.com/rust-secure-code/wg), actually. They have a bunch of ideas on the issue tracker. And stop by their Zulip to say hi! Oh, and thanks for [MIRAI](https://github.com/facebookexperimental/MIRAI) by the way!
Wow, that's steep for "minimum qualifications". I have that across a bunch of dynamic languages, but none of them are Java or C#.
Really wish more people explained it like this. Others seems to just discuss the speedup you get but that's not true. It definitely can be faster, but has to be designed correctly. This syntax makes it easier to close that gap.
Sounds like someone finally listened!
No.. no. This is really not going to do at all. Start over! This time, get the community involved earlier. Who approved this any way?
Last time I checked Rust's debugging story was not really complete, and [deteriorating](https://internals.rust-lang.org/t/how-to-support-rust-debugging-post-tromey/9207).
We’ll be introducing https://learnlibra.org —it be interesting to find out what other topic angles are necessary to onboard you to Libra.
Take care of yourself and your family, Felix. I've taken inspiration from Azul, it has been one of the pioneering Rust GUI efforts. I hope things work out well for you.
Definitely going to need an in-depth primer for futures and async-await. Runtimes, executors, and futures-- oh my!
Awesome! Sorry if my pedantry was annoying. Again, it was a really great write up!
This is not mutually exclusive to async/await.
Az
 S s
😙😙
Thanks for the kind words. No problem at all. I thought you made valid arguments for avoiding putting them in the same bucket without adding some information on how they differ so I think the change was to the better.
I thought we were called rustaceans
How is Rust not able to be functional?
in 9 weeks
Trying to assign two different structs to the same variable based on them implementing the same trait - `Iterator`. That doesn't work: fn main() { let head = vec!["a", "b", "c"].into_iter(); let tail = "d"; let combined = if tail.is_empty() { head } else { head.chain(std::iter::once(tail)) }; combined.for_each(|x| println!("{}", x)); } I figured this could work: let combined: &amp;dyn Iterator&lt;Item=&amp;str&gt; = if tail.is_empty() { &amp;head } else { &amp;head.chain(std::iter::once(tail)) }; combined.for_each(|x| println!("{}", x)); But now it says `the for_each method cannot be invoked on a trait object`. But... `for_each` is part of the `Iterator`, why would it give that error?
Normally I'd say you want /r/playrust (that's usually where folks who mistakenly post here need to be re-directed to). But honestly, I have no idea where you should have posted that. Not here, that's for sure! :)
No Monad, for starters. So combinators have to be reinvented for every type that they're supposed to work-with. No Functor, even - so every new unordered datastructure has to have its own concept of `(a -&gt; b) -&gt; F a -&gt; F b`. &amp;mut often performs better than moving whenever the type in-question is big on the stack, yet moving is never optimized to &amp;mut. Lack of self-referential structures requires pervasive use of the "pass-in your own &amp;'a mut buffer at the very top level - then our stuff internally will all borrow from 'a, and we'll return &amp;'a data back to you" pattern in order to get good performance. First-party data-structures are mutable rather than copy-on-write. Need I continue?
Would help to look at examples. Not the best code but here's what I have using gtk-rs for my ShareXin Twitter/Mastodon Screenshot App
Want to fucking fight bro
Nah, you specifically are a rustafarian.
A portfolio of mini-programs is great. Even better is if you can make some solid, useful, open-source libraries or tools. When I'm hiring the first thing I look for are open-source projects that are actually being used in the wild. PS, if you're looking for an open-source project to contribute to, I'm looking for co-maintainers for this one: https://github.com/phayes/tallystick
I believe they are writing a new mercurial server in rust as one example
/r/iamverybadass
It works when you use a \`Box\`. let combined: Box&lt;dyn Iterator&lt;Item=&amp;str&gt;&gt; = if tail.is_empty() { Box::new(head) } else { Box::new(head.chain(std::iter::once(tail))) }; combined.for_each(|x| println!("{}", x)); I actually don't know why this is exactly, I am going to investigate more.
Facebook *is* an authoritative state with no interest in free people.
When in doubt, benchmark it
Can OCaml do multicore stuff yet? Last I heard, not so much.
https://i.imgur.com/aZKGe.jpg
Pretty sure it still can't. The OCaml community has been talking about it for what has to be at least two years. At this rate, I'll believe it when I see it.
Putting some work in to a method to read large files, fork chunks of the records off to threads that can async load into a target dB. I’ve got a potential to put 100 billion rows into a table - and so I’m just nerding out on it until I am told “just do it the long way.” :p
You are correct and I have added another paragraph. Sorry if it sounded disrespectful!
Why doesn't slice.swap(0, slice.len() - 1); compile? I understand that the compiler thinks that calling `.swap()` will mutably borrow `slice`, and that you aren't allowed to borrow it again in the `slice.len()`. But how come the compiler can't tell that the return value of `.len()` doesn't use lifetimes or anything else, evaluate it to the `usize` it returns, and then pass it to `swap()`?
This is a problem with borrows being too long. There are fixes in the NLL pipeline hopefully coming soon for this. The workaround is to: let slice_len = slice.len(); slice.swap(0, slice_len - 1);
Ah, thank you. I was wondering if this was an oversight or there was an edge case that it catches. Thank you!
It's more of an issue of intent; how many `DataPoint`s are you intending to compute? Do you spawn a thread with the computation, join on it to get the result and then spawn another one? That's going to be very inefficient compared to communicating using channels. If you're spawning a thread to compute just one instance ever then the difference in overhead between sending the value over a channel versus getting it from `.join()` is going to be dwarfed by the thread spawn itself probably.
Rust doesn't even have tail-call optimization.
I am not familiar with Rocket, but this looks like something you should file an issue for in the Rocket repository.
If your goal is to be a professional developer, you'll probably end up learning 3 or 4 languages over your first 10 years. People have different opinions about what should be first or second, but ultimately you're going to need a broad set of experiences, and the exact order doesn't particularly matter. If you find that some language interests you more or is more enjoyable, I'd run with that, because you'll always be able to practice more when you're practicing something you enjoy.
There's no way Facebook would want to implement a privacy coin, since it goes against their interests.
Easier to bind a Libra account to a Facebook/Insta/etc accounts.
I don't understand why people are so hung up on unsafe blocks. Unless you're doing FFI or implementing some very specific data structure, you aren't likely to need an unsafe block anywhere, as we see here.
The EVM is still going to be supported for the forseeable future. Using eWASM is probably going to still take a while, probably not until sharding is deployed and is usable. And a lot of contracts are still going to be written in Solidity, Vyper, etc.
Except it still has a required runtime and GC so paying the costs for putting that on chain are going to pretty much disqualify it.
It may have more to do with `&amp;mut`. While the iterator methods nominally take `self`, there's an `impl&lt;T&gt; Iterator for &amp;mut T where T: Iterator`. Not sure if that works on trait objects though; it might or might not have `: ?Sized` in the code (I'm on mobile).
Great work, I have been waiting for `rcgen` to support loading certificates so that my [`nosni-proxy`](https://github.com/quininer/nosni-proxy/issues/4) can switch to `rustls` stack. Actually I have a WIP fork, but I haven't had time to finish it.
what comments on the matter? They don't seem to have really made any, unless you mean the one in the post that just says if anyone wants to pick it up?
Your initial points are all very critical and will hopefully be addressed in future language improvements, but there are some things that aren't quite true at the end: &gt;&amp;mut often performs better than moving whenever the type in-question is big on the stack, yet moving is never optimized to &amp;mut. Moving can be optimized to &amp;mut by llvm. Currently the Rust compiler leverages llvm a lot to perform such optimizations. They almost never happen in debug mode, but it can happen in release quite often. &gt;Lack of self-referential structures requires pervasive use of the "pass-in your own &amp;'a mut buffer at the very top level - then our stuff internally will all borrow from 'a, and we'll return &amp;'a data back to you" pattern in order to get good performance. There is no inherent requirement that anything not be self-referential (via graphs, often implemented with indices instead of references), nor that multiple references to immutable data via Rc and Arc not be used. This lifetime behavior is specifically important for the data-race-freedom guarantee of Rust. The only time there is an issue is when you want self-referential data, but Rust complicates the amount of boilerplate or syntax that is needed to have such a system compared to a garbage collected language. Most of the time though these kinds of references are used because they are basic language primitives, they are fast, and they prevent data races. While I would agree if you said that it is not trivial to create said self-referential data, I would agree, but it is possible to do so, just not typical or standard Rust code. It is often moved into libraries that wrap the behavior for you. &gt;First-party data-structures are mutable rather than copy-on-write. This one is true but can be nebulous. Many common and well-formed APIs avoid any specific mention of data structures. This allows users to freely pick data structures from crates.io, some of which (like some trees) allow copy on write behavior. It might be though that due to the lack of HKTs that people avoid mentioning data structures or data structure abstractions in their APIs 🤷.
The dataset that I'm using works out to just under five million datapoints and this function's purpose is to cull through them. I figured channels would be better, but this is only the second non-trivial thing I've written in Rust. Channels it is. Thank you.
Yeah, but I'm lazy. :)
Yep -- it's even open source https://github.com/facebookexperimental/mononoke
i rode the same carousel a year back. i think programming has little to do with the language (in a broad sense). learn python/c syntax along with things like data structures/algorithms. i'd suggest specializing later. maybe a couple years from now, blockchain is a saturated field. rust has a steep learning curve, but you should experiment and choose for yourself ;)
the text select animation is so satisfying
https://rust-lang.org
I feel guilty posting twice this close together, but is there an alternative to chaining `or` statements together in an `if` block? What would be a best-practice case for doing `if foo == 3 || bar == 4 || baz==5 || bla==6{` `yada.yada();` `}` ?
Blockchain is an open book because it's a meaningless word invented by scamy token salesmen so vage it cannot be defined. If the system does not include "decentralized and trustless" then what does it do?
The relevant bit is right at the end: &gt;So, what's the remaining work left to have almost all of the archive built for this architecture? What's left to port, as such? &gt; &gt;The main blockers to get closer to 100% of packages built are basically LLVM and Rust (which, in turn, depends on LLVM). &gt; &gt;Currently there are more than 500 packages from the Rust ecosystem in the archive (which is about 4%), and they cannot be built and used until Rust has support for the architecture. And Rust needs LLVM, there's no Rust compiler based on GCC or other toolchains (as it's the case of Go, for example, in which there's a `gcc-go` compiler in addition to their own `golang-go`), so this is the only alternative. &gt; &gt;Firefox is the main high-level package that depends on Rust, but many packages also depend on `librsvg2` to render SVG images, and this library has been converted to Rust. We're still using the C version for that, but it cannot be sustained in the long term. &gt; &gt;Aside from Rust, other packages directly depend or use LLVM to some extent, and this is not fully working for riscv64 at the moment, but it is expected that during 2019 the support of LLVM for riscv64 will be completed. &gt; &gt;There are other programming language ecosystems that need attention, but they represent a really low percentage (only dozens of packages, of more than 12 thousand; and with no dependencies outside that set). And then, of course, there is long tail of packages that cannot be built due to a missing dependency, lack of support for the architecture or random failures -- together they make a substantial number of the total, but they need to be looked at and solved almost on a case-by-case basis. &gt; &gt;Finally, when the gates of the `unstable` suite open again after the freeze for the stable release of `buster` , we will see tools with better support and patches can be accepted again to support riscv64, so we can hope that things will improve at a faster rate soon :-)
TRPL Rust by example The Rust Nomicon these books in that order should bring you up to speed! read about how the rust update system works, its very different from other languages.
It's only good for made up money. Without the money part the game theory does not work.
Cheese and whiskers. He wrote two sentences, neither of which deserve a ringing of the shame bell.
This isn't really the place to debate design decisions in Libra -- we'd love for you to join us over at [https://community.libra.org](https://community.libra.org/). But I'll give a quick answer since this is an important question. The Libra Blockchain implements a pseudonymity privacy model familiar to end-users of mainstream cryptocurrencies such as Ethereum and Bitcoin. Because the Libra Blockchain is designed to be a long-lasting infrastructure, it will continue to evolve over time -- so the focus so far has been on core components such as Move an LibraBFT. I think it's fair to expect additional mechanisms to provide privacy beyond pseudonymous transactions will be built on top of these components both on-chain (i.e., by using the Move language) and off-chain (e.g., custodial wallets).
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rustinblockchain] [Facebook just picked Rust to implement their new Libre blockchain](https://www.reddit.com/r/RustInBlockchain/comments/c2c0uv/facebook_just_picked_rust_to_implement_their_new/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
https://nim-lang.org
If you're not building in ZKP and privacy from the get go, how can people trust ZuckBux when Facebook consistently violates people's privacy? This is absolutely the place to discuss design decisions considering the work from this community is being used by FB. When companies like Uber, Visa, MasterCard, PayPal, and FB are the validators who see all transactions how can we ever expect to have privacy? Why would anyone want to use this when a bunch of companies of a terrible track record are running it? I'd rather be inconvenienced by cash than trust these companies, which was like the whole point of blockchain tech in the first place.
As far as I can tell, it _is_ intended for /r/playrust, as a real-life parody of something that happens commonly in the Rust game?
Since you have 763-or-so `await`s, any chance of an experience report on how that's been going for you? Any complaints about the syntax change?
Consider nim: https://nim-lang.org
It depends on what you're matching, but if it's a plain data type like your example, then a `match` statement can be quite nice: match foo { 3 | 4 | 5 | 6 =&gt; { yada.yada(); } _ =&gt; {} } Can also be written using `if let`, but this... isn't really that clear: if let 3 | 4 | 5 | 6 = foo { yada.yada(); } For characters or bytes, something like `"3456".contains(char)` is nicer.
Misleading title; LLVM is the blocker so there's no work to do in Rust right now.
I am not sure what's misleading. LLVM was an unimportant leaf package before Rust depended on it.
Rocket forwards the request to the next available handler whenever a guard (like \`FromFormValue\`) fails; since you don't have a handler set up, it goes to 404. You should be able to use \`Result&lt;UserId, APIError&gt;\` as the type of \`user\_id\` in the index function, so that instead of forwarding, it'll pass the result to you.
Other possibilities: just take an `Edge` and make those easy to create. Or take an `impl Into&lt;Edge&gt;` if you want to have a few varieties.
Possibly-dumb question: why does one need to `freeze` the input graph? Why not just do `let input_graph = input_graph;` to have Rust stop you from editing, or rely on it being borrowed to keep it from changing?
The original paper is quite concise, and doesn't say a whole lot about how future implementations should be structured. It's a Merkel Tree, with a set of rules about how new blocks get added, and what data those blocks contain. &amp;#x200B; I'm not at all defending Facebook here, saying we should use Libra, or anything like that. I'm saying that they meet the bar for being a cryptocurrency. It is decentralized, with many parties controlling the record of the ledger. &amp;#x200B; It is not trustless, but a trustless ledger, as we've seen, results in all sorts of problems with cryptocurrencies, that, as far as we know, makes them unworkable compared to cash and credit cards. The transaction costs are exorbitant. The money can be transferred across borders with very little friction for highly unethical and immoral actions, without the possibility of oversight. After the spike in 2016, with all that entailed, I don't think it's unusual that lots of people have withdrawn their trust from trustless systems.
This is a subreddit about the Rust programming language, which apart from the name has nothing in common with the game. I have removed your post to spare you further embarrassment. Next time, read the sidebar before posting.
Not sure if this is an easy question, but this is regarding `lazy_static!` and `RefCell`. I have the following simple code: lazy_static! { static ref WIDGET_REPOSITORY: RefCell&lt;Vec&lt;WidgetContainer&gt;&gt; = RefCell::new(vec![]); } The `WidgetContainer` object contains a `Box` object, and a few other things, but I'm trying to get past the first point of failure, which is: 23 | / lazy_static! { 24 | | static ref WIDGET_REPOSITORY: RefCell&lt;Vec&lt;WidgetContainer&gt;&gt; = RefCell::new(vec![]); 25 | | } | |_^ `std::cell::RefCell&lt;std::vec::Vec&lt;core::widget_store::WidgetContainer&gt;&gt;` cannot be shared between threads safely | = help: the trait `std::marker::Sync` is not implemented for `std::cell::RefCell&lt;std::vec::Vec&lt;core::widget_store::WidgetContainer&gt;&gt;` = note: required by `lazy_static::lazy::Lazy` = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info) So, I'm stumped. If I try doing this with a `Mutex` rather than `RefCell`, I get the following: 20 | / lazy_static! { 21 | | static ref WIDGET_REPOSITORY: Mutex&lt;Vec&lt;WidgetContainer&gt;&gt; = Mutex::new(vec![]); 22 | | } | |_^ `(dyn widget::widget::Widget + 'static)` cannot be sent between threads safely | = help: the trait `std::marker::Send` is not implemented for `(dyn widget::widget::Widget + 'static)` = note: required because of the requirements on the impl of `std::marker::Send` for `std::ptr::Unique&lt;(dyn widget::widget::Widget + 'static)&gt;` = note: required because it appears within the type `std::boxed::Box&lt;(dyn widget::widget::Widget + 'static)&gt;` = note: required because of the requirements on the impl of `std::marker::Send` for `std::cell::RefCell&lt;std::boxed::Box&lt;(dyn widget::widget::Widget + 'static)&gt;&gt;` = note: required because it appears within the type `core::widget_store::WidgetContainer` = note: required because of the requirements on the impl of `std::marker::Send` for `std::ptr::Unique&lt;core::widget_store::WidgetContainer&gt;` = note: required because it appears within the type `alloc::raw_vec::RawVec&lt;core::widget_store::WidgetContainer&gt;` = note: required because it appears within the type `std::vec::Vec&lt;core::widget_store::WidgetContainer&gt;` = note: required because of the requirements on the impl of `std::marker::Sync` for `std::sync::Mutex&lt;std::vec::Vec&lt;core::widget_store::WidgetContainer&gt;&gt;` = note: required by `lazy_static::lazy::Lazy` = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info) Ugh. I hope I can get a hand here.
&gt; = help: the trait `std::marker::Send` is not implemented for `(dyn widget::widget::Widget + 'static)` The problem here is that `dyn widget::widget::Widget` cannot be sent between threads. This is required because global variables, like those declared in `lazy_static`, can be accessed from multple threads. Trait objects, like `dyn Widget`, default to being non-Send. To have it be a `Send`able trait object, use `dyn widget::widget::Widget + Send + 'static` instead of `dyn widget::widget::Widget + 'static`. This requires all things cast into it to be `Send`, and therefor also allows the type itself to be `Send`.
It is a permissioned distributed network.
I have a dream. It goes something like this: Every subreddit has a configurable *public* pass phrase. Before submitting anything, a user would have to read and then type this phrase back. (It's pretty easy to prevent copy+paste.) &gt; "I solemnly swear that this content is related to the programming language called Rust, and not the game with the same name." That should prevent at least... _half_ of these posts, surely!
oh shit man i’m so sorry lmao. i literally was so heated when i typed this i didnt even check out the subreddit. my apologies for sure.
But rust itself is not blocking anything. If firefox/librsvg chose to be only compileable with llvm without using rust the Situation would be the same.
You can only choose one. Use a technology that's only use is permissionless payments with the chaos and freedom that it comes with. It can be used immorally or it can be used by Hong Kong protesters that are too afraid to buy a subway ticket with their credit card because it leaves a papertrail for the Chinese Communist Party supporters to persecute them. Or use a bank controlled by your local friendly (maybe) and competent (maybe) state.
Your apology is appreciated! Most people don't bother.
&gt; Because the Libra Blockchain is designed to be a long-lasting infrastructure Libra uses versioned databases, what are you going to do when 64-bit integer reaches its maximal for versioning?
Thank you, really appreciate it!
Excuse me, you dropped this. [https://en.wikipedia.org/wiki/False\_dilemma](https://en.wikipedia.org/wiki/False_dilemma) &amp;#x200B; There is a long continuum between freedom of payments, and total unfreedom from surveillance. In almost any market I can think of, in order to receive anonymity, you have to trade up liquidity. You, the person who is attached to the benefits you receive only in your own body, as some point must show up to receive the payment, or else put yourself through a massive amount of encumbrance to avoid that notice. Furthermore, as the probability in the modern world of you wanting to interact with any given party (app developers in Serbia, clothing sellers in Vietnam), the cost of avoiding liquidity goes up commensurately. We aren't all asking for 1984, it's just more efficient to be liquid, because it's so damn inefficient to be illiquid. Were the government to regulate that all people must use payment methods on a ledger, or get rid of cash, then I would agree, we've gone too far away from anonymity. This is nowhere near that kind of surveillance.
He means that while Rust created the blocker, the blocker now must be resolved in LLVM to proceed with the debian port, therefore Rust itself has no work currently for this to be done. The title still seems correct to me though.
Welp, I'm at the mercy of using a top level library, Piston. As a result, I'm not sure I can do all of these changes to the library, and still have everything work fluidly. The moment I tried adding any extra traits to the Widget trait, the entire project blew up in a gigantic flame-filled dumpster fire. Until I can figure this out, I'm going to be stuck. I don't know of any other way to create a central cache that can be used by other Widgets, other than passing that cache around by reference. And that's just an absolutely _horrible_ design if I'm forced to do that. The other alternative is to make the `WidgetStore` the "source of truth" for the entire application, and while that's an alternative, it's not one I'm comfortable making. I'd love a second set of eyes on this, but I don't think that's going to happen. I think I'm going to have to rethink this library and rebuild it from the ground up - the right way.
It's not about profit. It's about being able to use it without having to relicense your entire project to GPL as well. A project licensed as MIT would be incompatible with it, too.
When do you expect that to overflow?
Doesn't this say that Rust is not alone responsible for the LLVM support requirement? &gt; Aside from Rust, other packages directly depend or use LLVM to some extent, and this is not fully working for riscv64 at the moment, but it is expected that during 2019 the support of LLVM for riscv64 will be completed.
Idk why it's being spammed here, but I actually just did some grammar fixes for Nim's wiki page, since it was pretty rough
I don't know if, before Rust, anything would have required LLVM, just gcc. Pretty much everything could build with gcc. There might have been one thing here or there, but nothing blocking a release like Firefox.
I think you need r/playrust. This sub is for the Rust programming language.
I thought Rust uses lots of monads, like Option?
That's one case, and I can counter it with an anecdote of my own. My sister is gay and she was accepted my her father. Not being accepted by your parents isn't an exclusively gay thing. It happens to a lot of people. That doesn't make it better, but it does mean it's not an LGBT issue.
Why would anyone use nim? It's got a GC, so it's not suitable for real-time applications. It doesn't appear to have a nice package ecosystem built up like [crates.io](https://crates.io) or npm, so you're gonna be stuck reinventing the wheel. It's also just not as safe as Rust
How about we stop shaming people into behaving the way we want? If it's not alright to shame a woman or a gay person or a trans person, then it's not ok to shame a man either. If you think it is then you're a bigot. End if story.
If the statement gets too unwieldy, consider extracting (some of) the conditions: // imagine the conditions are longer than the names :) let something_finished = foo == 3; let high_priority = bar == 4; let baz_enabled = baz == 5; if something_finished || high_priority || baz_enabled || bla == 6 { : }
my suggestion if you want to adopt rust. read the entire book [https://doc.rust-lang.org/book/](https://doc.rust-lang.org/book/) follow the examples, try them out and get them running. by the end of the book, you will build a basic multi-threaded web server. &amp;#x200B; if after you have done all that, you are not completely annoyed by rust, it's a language for you. it's better to do this before doing any other languages, because coming to rust form another language will increase the probability that you'll find something that annoys you.
I added \`freeze\` so I have a chance to cleanup the input graph, for example I need to sort the edges and remove duplicate edges.
Yes, Rust is not alone, but majority of packages requiring LLVM do so because of Rust.
You probably want /r/playrust
Well … there's always [`Unix.fork ()`](https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/mandelbrot-ocaml-1.html)
I wanted to see some code of this new Libra blockchain i was surprised to find rust code in the source then seeing 97.5% of Rust code in the github language bar :') i feel kinda proud of you
Seems ok! I would probably leave out the `RefCell` there since it's not going to really add much, but besides that, it's good. `Mutex` already does synchronization to guarantee unique access - `RefCell` isn't going to add much _on top of_ that.
Sorry, this is the subreddit for *syntax* errors. You're looking for /r/playrust
Thx
Is tokio ready to work async/await? I see that the futures-preview crate seems to be.
I wish there was a rustc that transpiles to C. That would help a lot in such situations.
You’ve been a great help, thank you. I’ll definitely give the book a read. Not sure how beginner friendly it is, but I’m determined enough that difficulty is a factor I’m not worried about. If things get really tough I’ll even consider getting a tutor maybe (if possible). I’ll also give the project a look and hopefully I can add value, if not now then later. Once again, thank you for your time and help.
 9(who I
LLVM is a lot more than just clang. There are lots of tools for C/C++ development, some GPU drivers use LLVM for shader compilation, as well as some tools that rely on LLVM's IR for various program analysis. It's a pretty largely library with lots of functions beyond a C/C++ compiler.
It would. Unfortunately, neither [the LLVM C backend (llvm-cbe)](https://github.com/JuliaComputing/llvm-cbe) nor the [mrustc transpiler](https://github.com/thepowersgang/mrustc) seem to be in a state where one can just use them to build on any platform supported by a C compiler.
https://github.com/thepowersgang/mrustc Feel free to contribute.
I wish I could but unfortunately not my strength.
Well my point was that the technologys only benifit is it's permissionless property. Any entity gets influence over the database they can censor payments and at that points it is nothing more than an SQL database. If your system is to follow all government regulation then you have the highly efficient payment network of Paypal and such. Why do you need "blockchain"?
I agree that there is no completely free anonymity with inperson interactions. And group interaction will weaken any privacy you have for an identity
&gt;NDA Does it really apply if they don't know your username? It could be anyone.
I think for right now, the go-to solution is to use the runtime crate as a shim: https://github.com/rustasync/runtime it appears to have a lot of things similar to Tokio's `async-await-preview` that's since been removed. Additionally, it allows you to slot the runtime from the one shipped in the crate to Tokio's if you so choose.
Your libra wallet has been suspended for disrespecting lord zuck and questioning our design decisions. Please read our community guidelines https//facebook.com/obey and appeal, we will appoint an officer of discipline and review your appeal. Failure to pass the review we will drain your wallet funds to Facebook Charity Foundation as stated in Terms and conditions during wallet creation.
You want /r/playrust.
This is the Rust programming language thingy. Suggest trying /r/playrust instead.
&gt;Updating to the nightly everyday would be a nightmare. We use nightly in production, our CI uses the most recent nightly always, and every dev is responsible for upgrading their toolchain and tools. The most common type of breakage our devs encounter is that our CI fails for their PRs because we use nightly clippy, and the name of a clippy lint changed, or because we use nightly rustfmt, and their rustfmt produces slightly different formatting that doesn't pass the check. &amp;#x200B; I personally update the nightly toolchain once per week, or every two weeks. We have some devs that update it every day, our build farm updates it every day via a daily cron job as well. &amp;#x200B; But we also have some devs that only upgrade their nightly toolchain when things "break", and this often means every 2-3 months (yeah, that's how often breaking changes to nightly clippy, rustfmt, or rustc / cargo land). For some reason they are particularly proud of that and when someone discusses using a new nightly feature in a meeting, they wear the "I haven't updated the rust toolchain in 2 months" like a badge. As if running \`rustup update\`, which takes 30 seconds, would be a big deal. There are probably many Rust users using stable Rust that update their toolchains more often than them..
these people are firmly in 'not broken? don't fix' camp and there's value there even if I personally prefer to be up to date on dev toolchains.
Sure, like I said, there is value in having such a diversity of people, mindsets, and nightly toolchains. This hasn't happened yet, but were we to start depending on an unstable nightly feature that breaks all the time, these people would let us know that this is not "ok".
If nothing would depend on Rust, Rust would be an unimportant leaf package as well. So technically, the problem is that a lot of packages are using Rust. That's a good problem to have, IMO.
Hi all, Why doesn't this code snippet compile? trait MyTrait { fn my_fn&lt;'a, 'b&gt;(arg_a: &amp;'a [i32], arg_b: &amp;'b [i32]) -&gt; Self where Self: 'b; } impl&lt;'c&gt; MyTrait for &amp;'c [i32] { fn my_fn&lt;'a, 'b&gt;(arg_a: &amp;'a [i32], arg_b: &amp;'b [i32]) -&gt; Self where Self: 'b { &amp;arg_b[..] } } The error is essentially "cannot infer an appropriate lifetime for `&amp;arg_b[..]` because it must outlive both `'b` and `'c`". I would have expected the `Self: 'b` bound on the function to be sufficient to express that `'c` cannot outlive `'b`, so the compiler would choose the `'b` lifetime for `&amp;arg_b[..]`.
My understanding is every time a block is validated (minted) and add to the blockchain, the version number is increased. As Libra will run `forever`, in theory, the number of version will be infinite but I am not sure if a 64-bit int is infinite in rust or any language.
&gt;The most common type of breakage our devs encounter is that our CI fails for their PRs because we use nightly clippy, and the name of a clippy lint changed, or because we use nightly rustfmt, and their rustfmt produces slightly different formatting that doesn't pass the check. This 100%. In our project we used nightly Rust to simplify the migration to Rust 2018, and that sentence sums up the experience. We were planning to use stable as soon as Rust 2018 lands, and that worked well.
I'm a c++ guy. I would choose Rust because: \- stable build system from the same guys that make the compiler. No more FindCMake.txt or meson.build wraps, \- has static reflection. No more manual writing of cout code and serialization code, \- it has some of the best c++ features, RAII, smart pointers, etc. \- does error handling right, and in only one way, which is standard for all libraries, \- has a lot of functional programming features, which is a good stepping stone to get into that world.
I worked on a couple of **Blender** scenes, which can be rendered directly now. See [release notes](https://www.rs-pbrt.org/blog/v0-6-1-release-notes) for more details ...
What you want to do is to return an instance of that trait that is _bound to_ some specific lifetime - to accomplish this you should annotate the `MyTrait` definition with a lifetime: `MyTrait&lt;'a&gt;`. So to make your example work, you should do: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=5a4c7ddd9503c2a05591305b554e93c7
Thanks for your response! In this particular case, I wanted to avoid putting a type parameter on `MyTrait` because, by passing the lifetime up the chain, I eventually reached the point where I had a lifetime bound that couldn't be named. See the edit to my previous post for some more context. Is there any way for me to define `MyTrait` without giving it a lifetime parameter? Or can you think of any way to name the `'a` lifetime in my second example?
Read subreddit description before posting. Do this on every subreddit.
FWIW breakage due to these tools used to be much worse. We were craving for stable clippy and stable rustfmt to land to be able to at least switch to the stable version of these tools, while still using a nightly rustc and cargo. It turns out that when stable clippy and stable rustfmt actually landed, the amount of breakage that their nightly versions have been introduced since then has been minimal. It felt like, in the months prior to stabilizing these tools, breakage actually accelerated, and afterwards it just stopped. Something similar happened with rustc, when the months before 1.0 was released, nightly was breaking pretty much every day.
Not even replying to the correct thread...
I think there are two misunderstandings here: 1. I was not trying to say that LGBT people were never accepted; I was specifically replying to the statement I quoted which mentioned they were not discriminated against by showing one example of discrimination. 2. My step-sister had a good relationship with her father; really good actually. He just systematically refused to acknowledged any of her girl friend roommates as anything more than friends. This suggests that the issue was neither with (1) my step-sister herself nor with (2) a specific girlfriend of hers; especially when coupled with his reluctance to talk about gay relationships in general. I apologize if this was not clear enough in the original comment.
How hard would it be to make the Rust compile emit GIMPLE?
That sounds optimistic, but I hope you are right! :-)
&gt; I imagine it could be a mess if you have a large pile of dependencies all having varying degrees of nightly support. Yet, if you're in that scenario your problem isn't really nightly but rather the mess of dependencies on varying versions of nightly. Your problem is more that many libraries depend on nightly only features rather than you using nightly itself. I think you nailed it. The problem is not so much using nightly as a "final" user, it's delivering libraries requiring nightly because you can easily get your users in a "dependency hell" where one library requires a recent version while another stopped working with recent versions, and now the downstream user is stuck between a rock and a hard place.
One may argue it's one of their properties, but it's not what defines them.
Rust has many instantiations of Monad, but does not have Monad itself.
check the websockets example in [https://github.com/actix/examples/](https://github.com/actix/examples/blob/master/middleware/src/redirect.rs) we are currently doing this exact use case, although i find actix to be very difficult to understand and the documentation can be very misleading due to the pace of updates
Now perhaps my mobile Firefox will be able to load the Iterator page again. Thank you for fixing my mobile (I.e. public transport) dev workflow ♥️
A big thanks to ebarnard who (1) suggested the work-around and (2) followed through and actually implemented it.
What's the difference between `futures-preview` and `runtime`?
Sure, but so is GCC a framework with many language front-ends. It seems, thus, that what we observe here is that prior to now all languages necessary for debian packages had a gcc front-end, and not only is Rust bucking the trend, it's also a significant (4%?) part of the packages.
Is there some issue with the language itself that makes it hard to add Monad?
This is demo page from ebarnard in case one cannot wait for it: https://ebarnard.github.io/2019-06-03-rust-smaller-trait-implementers-docs/std/iter/trait.Iterator.html
At the moment, probably pretty hard. There is work ongoing on integrating a second back-end in rustc: cranelift. This requires more strictly defining the interface between front-end and back-end. Once done, it should be significantly easier to integrate a third back-end, and it is likely that gcc will be that third, simply due to the sheer number of architectures that it would unlock.
Thanks for the info :)
Not just hard. Impossible. Monad is a Higher-Kinded Type - or, a "type constructor". In Rust, given "SomeType&lt;SomeOtherType&gt;", the inner "SomeOtherType" can be factored-out by instantiating a type-variable, but the outer "SomeType" is fixed, and cannot be given via type-variable. Which is to say, Rust has a first-class notion of types, but not also of type constructors. The type-signatures of Monad's two methods, in pseudo-Rust, would be as follows: trait Monad { fn bind&lt;A, B&gt;(f: Fn(A) -&gt; Self&lt;B&gt;, x: Self&lt;A&gt;) -&gt; Self&lt;B&gt; fn return_&lt;A&gt;(x: A) -&gt; Self&lt;A&gt; } ... but I've just explained why that's not possible.
Different goals. `futures-preview` is mainly utilities/extensions to the `Future` trait and additional traits like `Sink`, `Stream` and the read/write traits. It does contain a basic executor and threadpool, but those aren't the main focus. `runtime` provides the things that actually implement the traits from `futures-preview`, like network sockets/streams, along with a way to run them. The only overlap between the two is the executor.
Sorry, I can't answer, because I'm completely unfamiliar with Erlang.
I'm not answering the exact question, but I also came from a mostly self-taught web dev background. If you want to learn Rust, learn C before you learn Rust, it will make the learning curve less steep and show you why Rust is useful (which will keep you motivated). If you've only ever done scripting languages some concepts will be alien to you. Personally, I think learning Rust early is a great idea, since its features help follow good development practice, and the book also *teaches* those practices. It might not be the most optimal use of your time in the short term, but it will pay off in the future, even if you never use Rust. It will also drive home the point that languages are tools, not magical dev requirements. A lot of new devs are scared of learning new languages, but it gets easier once you've learned your first. I'd even go so far as to say you should learn both Go *and* Rust (:
I like this one better.
You are right that 64-bits is not infinite. By definition, it is 64 bits. On the other hand, you are lacking an idea of the order of magnitude that 64 bits is, it seems. The current crop of CPUs is running at, say, 5 GHz (with overclocking). Assuming that 1 transaction is processed with every single CPU cycle (quite a stretch...), the version number would therefore increment by 5 every nanosecond. At this (insane) rhythm, it would take just a bit less than 117 years to overflow an unsigned 64-bits number. 64-bits is just an insanely big container.
What's wrong with git?
I work there too. 👋 I run a mobile podcast there's a lot of interest in that space for Rust, too. Here's just a very brief chat I've had with someone who works on iOS and has built some Rust tooling at FB: [https://pca.st/0qu2#t=36m14s](https://pca.st/0qu2#t=36m14s)
The only sensible values for those two nodes would just be the original function arguments. Example: a graph with 4 nodes and no edges.
Someone PMed me a list of all the projects, it's interesting stuff. Great to see Rust get this kind of traction.
/u/dabreegster are you and the Citybound author sharing interests? this work seems very complimentary..
Awesome!
The changes if anyone was curious: https://github.com/rust-lang/rust/issues/55900#issuecomment-498317251.
Yes! This is *one of* the key reasons why language design on Rust interests me.
Given this omission, how has OCaml managed to leave the realm of "ivory-tower academic curiosity"?
Thanks for this, it’s nice that you come from a similar background. The question I have after reading that is, is important to know how languages interact with tangible components of a computer or is it not worth visiting that rabbit hole? Do I need to understand concurrency and stuff like that. Because I’ve heard that if I just use powerful tools, but don’t understand the fundamentals of these tools then my progression will be limited. Do you recommend any materials in regards to learning C. I’d love to learn both and I’m more excited as opposed to fearful. However, I’m just concerned I don’t understand anything and it’ll be like I’m reading Sanskrit. I shall still give it a go though. I’ve brought up languages like Ruby, Python and C++ in similar questions I’ve asked and people just say Rust and Go are better so it’s quite hard to make a concrete decision.
So it would only take about 1400 nodes to cause an overflow in about a month?
Ironic that they use git for the version control of a mercurial project haha
A privacy coin is also dependent on a third party obfuscating the transaction for you (in most privacy coin schemes, you're implicitly drafted to serve as such an obfuscator by using/mining the coin). Obscuring the origin and destination of a transaction for someone else is very likely illegal.
It was my understanding of a blockchain that even if processing was distributed, the actual blockchain itself was, well, a singly-linked list (chain)? If so, I would expect that it would take more than 1 cycle to synchronize across nodes, and therefore adding more nodes would not allow going faster than 1 increment/cycle.
I'm against cryptocurrency by nature... but if Libra actually doesn't build in privacy from the get go then that is a positive thing for me. I don't think there's an inherent right for financial transactions transactions to be public and cryptocurrencies should not be a way for people to engage in tax avoidance or other shady things. I certainly don't want my efforts to facilitate that. I'm more concerned about the notion of a "reserve" that libra has. It seems to me like they are building a *private* central bank. On the other hand, bitcoin is a deflationary mechanism and that is a bad thing.
No, because it's impossible to produce blocks that fast and since the blockchain is linear adding more computers doesn't increase the speed of block production (they'd have to take turns producing blocks). Even if we took [the length of time that it takes light to travel halfway around the world](https://www.quora.com/How-long-would-it-take-for-light-to-fly-around-the-earth), which is more-or-less the fastest theoretical possible block time for any blockchain that wants to be used worldwide (since any faster block time would mean that it would be impossible for any node too far away to stay in sync), we get 2.3980767x10^(17) seconds, or a bit over 7,604,251,425 years before it overflows. That's assuming that it takes 0 seconds to produce a block, which is impossible. I think 64 bits is just fine.
That's really nice! Having a high level overview of the architecture. I wish they could paint these things in pictures sometimes. Thank you.
Yea, and I _think_ the only thing I'm using that even requires nightly is Rocket. I haven't had the need to add a bunch of libs all requiring nightly. Thankfully
You can use an \[\`Either\` enum\]([https://crates.io/crates/either](https://crates.io/crates/either)) instead of a \`Box\`, this way you don't have to allocate the iterators on the heap. Your code would then be: &amp;#x200B; use either; // 1.5.2 use either::\*; fn main() { let head = vec!\["a", "b", "c"\].into\_iter(); let tail = "d"; let combined = if tail.is\_empty() { Left(head) } else { Right(head.chain(std::iter::once(tail))) }; combined.for\_each(|x| println!("{}", x)); } &amp;#x200B; You could also define your own \`Either\` enum instead of using the crate with something like: enum Either&lt;L, R&gt; { Left(L), Right(R), } use Either::\*; impl&lt;L, R, I&gt; Iterator for Either&lt;L, R&gt; where L: Iterator&lt;Item = I&gt;, R: Iterator&lt;Item = I&gt; { type Item = I; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; { match self { Left(l) =&gt; [l.next](https://l.next)(), Right(r) =&gt; [r.next](https://r.next)(), } } }
I'm looking through the `ggez` crate and noticed this type declaration: pub type GameResult&lt;T = ()&gt; = Result&lt;T, GameError&gt;; This is the first time I'm seeing an = inside a generic, and looking through the book and some examples I can't seem to find an explanation for what this means. Is this like a default type if nothing else is specified? Or is this indicating that T must always be `()`, and we're really only using the Result for the potential error condition?
Nice, thanks!
To my understanding this is not a limitation of the language but a limitation of the Rust compiler. LLVM supports tail call optimizations. And with or without TCO the results would still be the same. Only the runtime would change.
It looks like there are open issues for Rust to support Higher Kinded types though. Once that is incorporated into the language then it would be able to support Monad?
I’ve only dabbled in Ruby and some JS strictly for web development so to be on the conservative side, I’d like to say I’m new to Programming. That being said, with no prior experience in CS and programming, would I be ok just diving into the Rust book? Or do I need fundamental knowledge of how languages actually interact with hardware and stuff. Also, what are the benefits of C, C++ over languages like Rust and Erlang If you don’t mind me asking. Thank you.
idk, they just use mercurial internally. Ask facebook
Hey, I think I found a wrong clippy lint. Could someone confirm that this is indeed wrong, or am I missing something? What I have is this: let mut graphemes = Graphemes::from(x); // = an iterator over Result&lt;String&gt; while let Some(graph) = graphemes.next() {/*...*/} Clippy complains about it and recommends a for loop: this loop could be written as a `for` loop note: #[warn(clippy::while_let_on_iterator)] on by default help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#while_let_on_iterator help: try: `for graph in graphemes { .. }` clippy(clippy::while_let_on_iterator) But `for Ok(graph) in graphemes.next()` is wrong, since "*refutable pattern in `for` loop binding: `Err(_)` not covered*".
I’ve heard that smart contract development should just be an additional skill a dev should have, as opposed to something they solely concentrate on. I do want to get into smart contract development, I think Vyper will be the better option from what I’ve looked at. However, I’d like to work with distributed systems, even if it’s not blockchain. I hope that makes my Goal a little more clearer. I could sound naive due to lack of experience and be piling too much on my plate without understanding what I’m getting myself in for.
Yeah, I started using Rust just over six years ago, between Rust 0.6 and 0.7.
Depends if it fits into your portfolio, my opinion everybody should know a web lang, something like Java or C# and something low level like rust or C(++).
Yes, it's a default type, see https://github.com/nox/rust-rfcs/blob/master/text/0213-defaulted-type-params.md.
Curious, I hadn't heard that Tokio had removed the preview. Is Romio still being developed?
A few projects are moving to WASM. Last time I checked the problem of gas-metering still wasn't solved for WASM, which means that projects adopting it might be inviting a known attack vector into their systems. Even with that solved, adoption in Ethereum mainnet would still be a few years out.
&gt;cryptocurrencies should not be a way for people to engage in tax avoidance Sharing with your countries tax authorities and making it visible to a for-profit company and any random person who wants to see your financial transactions are two completely different things. Nobody needs to know how much I spend on groceries or medication or alcohol or entertainment or porn or games or whatever but me, certainly not Facebook and certainly not a random stranger on the internet. That's separate from having the financial data available to authorities in order to prevent me from evading tax. PS: tax *avoidance* is legal, tax *evasion* is the illegal one
Keep in mind that \`runtime\` requires that your main also be async. Somewhat deeply tying itself into your application.
Cannot comment about diving into Rust book because I've learned Rust using its previous edition, which was much worse than the current one. Benefits of C and C++ over Erlang: they're great for number crunching, while Erlang is not. You can write libraries in C that you can hook up to other languages, in Erlang you cannot. However, Erlang has vastly better usability, reliability and security. Erlang is purpose-built for distributed, high-availability, low-latency, fault-tolerant systems. It is a functional language where all variables are immutable, it has very different approach to error handling (you cannot make code bug-free, so instead learn to deal with it) and features live hot reloading (there are demos of drone firmware upgrade mid-flight). If you're not building something distributed and/or networked, you don't need any of its strengths and it's probably not a good fit. Benefits of C and C++ over Rust: well, Rust is basically designed to be the superior replacement for C and C++, so (as a possibly biased Rust fan) I'd say the only thing going for C and C++ at this point is greater momentum. They've been around for much longer and have more libraries and supported architectures. They also have faster compilation times, but that's because they do very little compile-time validation. Rust seems to be superior in every other way.
Wasn't https://github.com/paritytech/wasmi supposed to solve the gas metering?
Right, right, I forgot about that.
Quite possibly so.
I started to work on a C backend like 3 times already, but always got sidetracked by other things. It should now be much more reasonable to do since the backend interface code was refactored.
Thank you so much for this elaborate explanation. Erlang, Go and Rust it is :). Looks like I’ve got a lot to get on with if I don’t pass out during this endeavour. Do you personally recommend any materials that have helped you? Again, thank you for taking the time out to write such a detailed response. This community is extremely helpful, I’m really surprised.
&gt; Sharing with your countries tax authorities and making it visible to a for-profit company and any random person who wants to see your financial transactions are two completely different things. [...] That's separate from having the financial data available to authorities in order to prevent me from evading tax. Yes, I understand the distinction between disclosure to governments, for-profit corporations and random people. However, it seems to me that the mechanisms that let you hide it from one party can be used for the other unless you propose some way for the authorities to get access to this data on a non-voluntary basis. &gt; Nobody needs to know how much I spend on groceries or medication or alcohol or entertainment or porn or games or whatever but me, certainly not Facebook and certainly not a random stranger on the internet. The distinction is not as easy as one may think on initial inspection. There are things that should be part of the public record for things that individuals and companies do.
With a cursory look (and from what i remember), I don't think there is metering built into wasmi. AFAIK Parity's eWASM efforts forked off into pWASM a long time ago. With Parity's vision of individualized Substrate-based chains, where the client itself runs a set of WASM based routines, and the client authors are responsible for building a unattackable client, metering isn't quite as necessary. After all there are quite a few unmetered operations that happen outside of EVM evaluation during block mining.
Erlang: https://learnyousomeerlang.com/ is great Rust: https://doc.rust-lang.org/book/ is great, I'm told there is also an O'Reilly print book that's very good. For Go, I've been recommended http://tour.golang.org and then https://golang.org/doc/effective_go.html, but after Erlang, Python and a bit of Rust I've mostly skimmed them instead of actually going through them in detail because it didn't have anything I haven't already seen. So cannot really comment.
Not being able to have AMD graphics support would be a major blocker, Rust or otherwise.
Most first- and second- world nations already have a well-defined system of reporting income and assets for tax purposes. Those same mechanisms already work for bank accounts, credit accounts, savings accounts, cheques, stocks and other investments, gambling, employment, etc. Why should a crypto- (or other electronic) currency need to be public in order to fit in?
How does it feel to be a literal enemy of society?
&gt; Most first- and second- world nations already have a well-defined system of reporting income and assets for tax purposes. Yes, it's quite neat. Filing my taxes is Sweden takes about a minute, I don't have to do anything but sign the document as the government has already collected all the information they needed. Notably I did not have to provide this information to the authorities and providing it was not optional either. &gt; Why should a crypto- (or other electronic) currency need to be public in order to fit in? At a minumum, to be a legitimate form of currency in my eyes, cryptocurrencies should not make it harder for governments to tell who the actual physical person (or legal entity) behind a transaction is.
Oh my, this is amazing. The first time I am able to open the Iterator page on my phone without it crashing!
This should absolutely be focus of the 1.37 release announcement.
Very nice! This has the added benefit of showing which types specialize the iterator methods such as `try_fold`/`fold`, which are nice to know when optimizing.
I’m trying to implement safe c-like enum’s for Rust, because I’m hurt by incompatibility between C enum’s and Rust #\[repr(C)\] enum’s. I’m looking for feeback. Here is my PoC. [https://play.rust-lang.org/?gist=6131d0fcadd0bf2bba48a3efe26278f0](https://play.rust-lang.org/?gist=6131d0fcadd0bf2bba48a3efe26278f0)
How would this be used in day-to-day life? Again it doesn't seem to me like it would be an improvement over existing legal and cultural systems
That video is awesome. I remember watching it when I was starting with Rust and it's part of why I'm so heavily invested in Rust now.
I mean, there's *something* we could do without needing to wait for LLVM. Cranelift can already target RISC-V, so if it ever reaches enough maturity to be a fully supported rustc backend, Debian could use that to build for RISC-V.
I'm pretty excited about this (0.2.0) update to Emu. I've simplified the framework to provide just a single macro called `emu!` that accepts a chunk of Emu code and generates Rust functions that can be called to execute computation on the GPU. I've also added decent error reporting and fixed bugs in compilation. ```rust // The "emu!" macro accepts a chunk of Emu code and // generates Rust functions that can be called to perform computation on the GPU emu! { // Multiply any element in given data by given coefficient // Data and coefficient must be floats function multiply(data [f32], coeff f32) { data[..] *= coeff; } // Apply sigmoid function to any element in given data // Data must be floats function sig(data [f32]) { let elem: f32 = data[..]; let res: f32 = 1 / (1 + pow(E, -elem)); data[..] = res; } /// Multiplies each element in given data by given coefficient pub fn multiply(data: &amp;mut Vec&lt;f32&gt;, coeff: &amp;f32); /// Applies sigmoid to each element in given data pub fn sig(data: &amp;mut Vec&lt;f32&gt;); } fn main() { // Vector of data to be operated on let mut my_data = vec![0.9, 3.8, 3.9, 8.2, 2.5]; // Multiply data by 10 and take sigmoid multiply(&amp;mut my_data, &amp;10.0) sig(&amp;mut my_data); } ``` Crate =&gt; https://crates.io/crates/em Repository =&gt; https://github.com/calebwin/emu Book =&gt; https://github.com/calebwin/emu/tree/master/book#table-of-contents
I get really nervous personally when i read posts like that. I mean go through crates and witness that half of them have last commit 4 years ago. Is it that rust never took off, or is this just natural?
Sorry we are really looking for someone in the first 100 language users to become a part of our feature factory team, thank you for your application and continue to grow your experience!
Instead of ranting could you perhaps provide some concrete examples, maybe we can help you.
https://github.com/rust-lang/rust/pull/61505 the pull request
Thanks. Are you doing a browser based game, or would you choose a websocket over a standard tcpstream in any case?
It's a [work-in-progress](https://github.com/tokio-rs/tokio/pull/1120). Most of the main pieces are converted, like reactor, tcp, sync, current_thread, and the runtime... I've used to start updating hyper. There's still need to update the tests and docs of those crates, and others need to be started. If anyone would like to help ;)
In order to understand the thing, you need to understand these things: * What "immutable" even means in the context of blockchains - surely there isn't some magic dust to prevent you from flipping a bit on your disk! * How the data from physical world can enter digital world * How these things interact Let's begin with "immutable". This word in context of blockchains means that you'd have to expend a lot of energy to make a new version of history which other people would accept. There are two basic ways to achieve it - digital signatures and proof of work. By digitally signing a history, you need to expend lot of energy to break the private key of the trusted party who signed it. Except if you are the trusted party or you have guns. Lots of guns. (In other words, if you're the government.) Now obviously you could grant the government the power to decide the history, since it's the most powerful entity and hard to attack (and if other government can force it to do something, you have a bigger problem - war). But if you for some reason don't believe that governments are legitimate, you need something else. (Now, if you believe they are, please don't focus on this - the idea is that there are some people who think gov is illegitimate gang. It's not the point of this explanation to discuss whether they are or not.) Satoshi didn't believe govs are legitimate, so he built a system based on proof of work. PoW ensures that there's no central entity - not even government to bypass the cost of rewriting history. Now in case of Bitcoin, there's no real-world data that we need to feed into it (apart from energy expenditure, which can be done using partial hash collisions). However how do you feed a simple statement like "XY produced a healthy fish with serial number 123"? There's no way you can use cryptography to do that! The only possibility is to have some kind of audit company digitally sign this statement. The moment you have a company signing stuff, the government can use guns to force that company into providing fake data in the first place. Further, if the statement is signed by trusted party, you don't need to protect against that party changing history because you rely on them to prove that the statement is correct in the first place! Therefore you only need the signature and any kind of blockchain is just useless garbage that you don't need. Why would someone from Australia need to concern himself with a fish in Norway? Why it's different with money? Because in case of money, there's so-called double-spending problem: someone could spend the same money more than once, which is equivalent to inflation. This also fits into description about governments - it's a fact that everywhere on Earth govs control money, so if someone finds this illegitimate, he needs to find a way to prevent govs from controlling money. High-quality blockchain is the only technology we now know to be able to achieve this. There are also low-quality blockchains that likely wouldn't withstand government attacks too. Conclusion: blockchain is a useful technology for implementing government-resistant money, but useless for anything else. (FYI, I have no idea why people are downvoting you. I would've guessed because they find the answer obvious but based on them downvoting my own stuff, I guess they're just confused. I didn't downvote you.)
&gt;vim OP you should try out fzf + ripgrep, it's fantastic for huge projects, allowing you to fuzzy find any file in the project and instantly jump to it. Pair vim with tmux and you get a very good IDE.
640K ought to be enough for anyone.
It's natural in any ecosystem. Look at the number of abandoned JavaScript projects, c++ projects etc... Rust isn't an outlier here , but due to the youth of the language, it's more apparent when a repo is abandoned because there just aren't as many established repos yet. It's nothing unique to rust and you're reading too much in to things.
&gt; GIMPLE Not sure of the status of the [front end](https://gcc.gnu.org/wiki/GimpleFrontEnd) but it would be a fun project to convert Wasm -&gt; GIMPLE. The most portable thing right now is Wasm -&gt; C89
It looks like that target is supposed to be [tier 1](https://forge.rust-lang.org/platform-support.html), so it should work reliably. Though that doesn't imply a guarantee that third party crates will support it. Though honestly, looking it up I'm somewhat surprised Windows 10 still has 32 bit x86 support. I don't think they've been making those processors for a while? (Except perhaps for embedded purposes.) But yeah, it's hard to say what the cause is without a more specific description of the issue.
If you're new to programming you'd probably want to stick with your original language for a while. Get really in-depth knowledge of it. If you're itching to learn a new language you should learn something like Lisp. Guessing you're working with JavaScript from web development, learning Lisp would give you a good baseline functional thought process.
I don't really understand. Did the change remove some implementations from the documentation?
my first inclination is to comment about the amount of indentation you have in some locations. I would definitely suggest inverting some conditionals, adding early returns, using some 'continues' or 'breaks' as needed, in order to reduce the indentation. Further, if it is possible to remove index based iteration I would also highly suggest that (though I don't know if it is possible here). Next is the kings\_move and knights\_move functions which shouldn't be public since they should be internal details only. Finally, the last thing that jumped out at me is the kings\_move and knights\_move should probably have comments on the vectors explaining their use (it was the only part I didn't instantly understand while just reading it). Not what you are doing, but why you did it that way and what those collections of numbers mean.
I work with the 64-bit MSVC toolchain on a daily basis, and it's been several years since I had any problems of the nature you are describing. It sounds like you are linking to crates with dependencies on C library (eg. openssl) and haven't set up your linker paths correctly. For crates with C library dependencies it is important to follow the instructions in their READMEs for how to build.
&gt;impl&lt;'r&gt; Responder&lt;'r&gt; for Error1 { fn respond\_to(self, req: &amp;Request) -&gt; response::Result&lt;'r&gt; { rocket\_contrib::json::Json(self).respond\_to(req) } } &amp;#x200B; Thank you, that's exactly what i wanted to know
Thank you, that's exactly what i wanted to know
No. Previously, the page would repeat it's entire documentation for *every single type that implemented a trait*, ballooning page sizes. Now it only documents what those other types actually implement from the trait.(Which is usually just the one required method, `next`)
Before it would repeat all the methods of a trait on every implementor, even if they were default implementations provided by the trait. After the change it will only list methods which are in the impl block (required or overriding the default)
[playground to a version which compiles](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=b9f86ef23b4154d2fd898620ee9da0c4).
Very cool project. I am wondering, assigning a vector to a scalar is a way of hidden iteration? `let elem: f32 = data[..];` If I want to test it in linux, what libraries do I need?
Will this change also remove the workaround-hack with the "loading content" stuff? Now that the page is actually a decent size it shouldn't be needed. Not that it was ever helpful, though, it just forced you to wait for the full page load instead of being able to read docs while the browser struggled to render everything at the end. :(
&gt; why would you just throw 500 influence away, when you can uplift primitives and resettle them straight into extermination camps? &gt; we took those animals and made them people! so they can understand we're gonna exterminate them. /u/H2004 in [/r/Stellaris](https://www.reddit.com/r/Stellaris/comments/bx7j41/this_game_is_making_me_feel_bad_way_too_often/eq8q60a/) you seem like a pleasant guy to be around... like i checked your post history to see if i could maybe help you with your problem since this post does not really contain a lot of detail, and i gotta say i did not really like what i found.
rustc already has a cranelift backend, but it is not in tree and it is not fully complete
"Minimum qualifications" is just a euphemism at this point. Just do a couple projects so you can put the keyword in your resume and you're golden.
I don't think that qualifies as discrimination as though. Your example is just a personal thing between a few people. Everyone experiences things like this in their lives. It sounds like he's just uncomfortable with the idea and would rather not talk or think about it. If that becomes an issue then it needs resolving by the people involved on a personal level.
this has spectacular potential for extremely productive numerical computing w/ gpu! I'm a tad worried the amount of "magic" will lead to very confusing error messages/bugs but excited to check it out! Very cool - thanks for sharing.
Thanks for the explanation, I think it’s helped clear some stuff up. Also, I think I found the project I was referring to if anyone is interested. https://sustainablefoodtrust.org/articles/how-blockchain-could-revolutionise-supply-chain-transparency/ It turns out I was wrong on some accounts. It’s not the government but rather private enterprise that is behind it. And the goal is fair trade not food safety standards. I think this makes sense with regards to your comment since what they are storing is the price at which the commodity, coffee, was sold. I guess this is like proof of work/spending which tracks with blockchain as you explained it. So I think although my initial comment was very incorrect the project itself (the correct one I linked) is still a pretty good example of a block chain application. Does this make sense or am I still misunderstanding?
off the top of my head - glfw, simdeez
i believe the case is simply that people make crates on linux/mac and do not test them with msvc. and msvc is notably fussy, which doesn't help.
read this https://en.wiktionary.org/wiki/sarcasm
aha, now that's useful information. thanks.
They've done multi process workarounds I believe. Then you more recently have ReasonML &amp; Bucklescript, which compiles to JavaScript.
Thanks! Right now, Emu handles most compile-time errors. The way it displays errors will get even better once reporting errors for procedural macros with Span becomes stable. The bigger problem is *run-time* errors. Since I'm using OpenCL behind the scenes, any error messages I get reference the compiled OpenCL code so I need to figure out some clever way of transpiling the OpenCL errors into errors that reference the Emu code.
It'd be easier to provide if you gave us more context. Any purely Rust code works perfectly on the Windows targets. I use it daily.
Would love to help out. How do you coordinate the work?
`data[..]` is a hole, explained [here](https://github.com/calebwin/emu/blob/master/book/holes.md#table-of-contents). Basically, when Emu compiles your Emu function to a Rust function, the generated Rust function essentially calls your Emu function multiple times filling the holes with all possible values. And the only dependency is OpenCL - [https://www.eriksmistad.no/getting-started-with-opencl-and-gpu-computing/](https://www.eriksmistad.no/getting-started-with-opencl-and-gpu-computing/). I am developing Emu from a Linux environment myself so feel free to ask me any questions.
If you prefer chatting first, there's the tokio-rs/dev Gitter room. Or, pick some unit of work and mention as such in that PR I linked.
You are looking for /r/playrust
As long as you do not use any kind of bindings there should be no problems.
well simdeez breaks because i'm on 86 toolchain which i installed because i wasn't smart enough to find 64 one on first try. glfw prolly needs path to system ogl library.
&gt;It is unclear when a parameter is being taken by ref, const ref, or copy, unless a cast is required. This is a problem in C++ that should have been fixed You would need to know whether a type was `Copy` or not to know if a function is taking ownership or making a copy, but refs (`&amp;mut`) and const refs (`&amp;`) are explicitly required of both parameter definitions and passed in arguments.
Yeah. But I think a relatively small number of crates (such as those wrapping C libraries) are really dependent on such details. And the most important of those should have good msvc support.
Link to reddit discussion: [here ;)](https://www.reddit.com/r/rust/comments/c2fi64/-/erk7dd0)
I think that's fine personally, it's handling two different failure cases so there's two unwraps (no argument provided, empty string provided as an argument for the second one). You might want to actually display an error to the user in that second case as `[cmd] --delim ""` could be the result of a bug. If you're fine with that though you could use [and_then](https://doc.rust-lang.org/std/option/enum.Option.html#method.and_then) let delim: u8 = matches.value_of("delim").and_then(|s| s.as_bytes().first().cloned()).unwrap_or(b','); Which isn't that much shorter, so up to you
damn. I need to find another page to benchmark WebRender with :(
It would be nice if we could keep this sub about Rust. There are loads of other subreddits where you can discuss cryptocurrency qua cryptocurrency and Facebook's policies.
I assume this change will apply to all doc pages? If so, this is going to save me from a significant number of browser hangs.
Here's a slightly simpler version: let delim = matches.value_of("delim").unwrap_or(",").as_bytes()[0];
That's false. The two most popular private cryptocurrencies, Monero and Zcash, do not need a third party mixer. Privacy is built in via zero knowledge proofs.
Note that this will panic on an empty string input, which isn't a great way to report to the user that they did something wrong.
Thanks for the input - I appreciate it! I need to review my thought process because I should also take "\t" to mean the literal tab char as bytes, but passing it on the command line does not work, though using bash's CTRL+B/I (I might have that wrong) does.
Yes, it will.
Thanks! I appreciate the help! :)
Crates that bind to C libraries and don't work on Windows has nothing to do with the stability of the msvc toolchain.
There is active research that enables cryptocurrencies where you can have strong privacy while still ensuring selective disclosure and compliance with arbitrary regulations. See https://eprint.iacr.org/2018/962 for an example of such a system.
The projects have some major differences -- Citybound simulates economy and zoning, not just transportation, and it allows creating everything from scratch. A/B Street has the much narrower purpose of exploring the effects of simple road/intersection changes in an existing city. I'm excited to watch Citybound evolve into something very [moddable](https://aeplay.org/citybound-devblog/citybound-as-a-truly-moddable-and-educational-simulation). As for sharing libraries, /u/theanzelm certainly may have a use for fast_paths!
The torch needed to be passed on, does not automatically mean a detoriation.
Right, it would probably need to he officially supported if debian were to pick it up.
The biggest blocker for using async await for me is tokio support, since you have to litter your code with \`.compat()\` or \`.boxed().compat()\` calls everywhere. Tokio migrating to \`std::future\` in the foreseeable future is great news!
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/hackernews] [Facebook picked Rust to implement Libre](https://www.reddit.com/r/hackernews/comments/c2jst5/facebook_picked_rust_to_implement_libre/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Facebook runs a giant mono-repo. At some point they claimed that git neither scaled for their usecase nor did the git community embrace their contributions to help it scale (for giant mono-repos). FWIW, Google has claimed similar and used to use a very optimized Perforce and now uses a fully custom solution. They adopted mercurial instead because the community was more open to contributions that would help giant mono-repos. For example creating a new Mercurial server in Rust.
Sarcasm is a tone used to indicate verbal irony. Using text removes most, if not all, tone from a sentence. Therefore, it can be very difficult to impossible to properly convey sarcasm online. An attempt to convey sarcasm had been developed in the form of special sigils like `\s`.
Can a kernel create two mutable references to the same element ? For example, is this ok: function multiply(data [f32]) { data[..] *= 3; data[0] *= 3; } where all threads in the block / group write to `data[0]` ? If so, that looks unsound (e.g. you could write `threadId`, and the result would be non-deterministic).
This project is backed by Visa, Mastercard, and Paypal -- sworn enemies of cryptocurrency, since it competes with their primary business model which is to profit from the digital exchange of money. Yet, Libra purports to bring all of the benefits of cryptocurrency to the masses. This is ludicrous. The primary benefit of cryptocurrency is control over your own digital money. You control your wallet, and you control who and when you transfer it to. There is no need for a bank to hold your money and profit from it, and no need for an intermediary to charge you for the privilege of transferring money, or monitor or prevent you from doing so. Libra aims to take advantage of the goodwill and hype around cryptocurrency, but deliver none of the primary benefits I have just mentioned. They will control and profit from your money, and they will charge you fees for transmitting it to other parties. But again, this is marketed as a cryptocurrency, supposedly just like other cryptocurrencies. And yet nothing could be further from the truth. The payment processors recognized that cryptocurrency presented a challenge to their business model, and they came up with a clever way to subvert it. Given this context, how do you sleep at night?
I was just having a conversation about this with a few folks last week. It wouldn't be *that* ridiculously hard to make an LLVM backend that emits GIMPLE. It'd likely be even easier to make a Cranelift backend that emits GIMPLE, though then you'd need the Rust cranelift backend to be finished, so that's a tradeoff. The backend wouldn't need to worry too much about optimization; the primary goal would be to make it work at *all*. Either way you'd still need some Rust-specific glue for each architecture so that rustc knows the details of that architecture, but I think this would be a *far* easier path than (say) adding a GCC backend directly to rustc.
Every change breaks someone's workflow?
Will this have much effect on the "installing component 'rust-docs'" step of updating the toolchain?
Oh, did someone step up to maintain it after all?
Interesting. I'd be excited to see how this progresses, I've seen and heard good things about GCC 8's codegen.
It's always there for you: https://doc.rust-lang.org/1.35.0/std/iter/trait.Iterator.html Remember to bookmark it! ;)
Instead of indexing into vectors repeatedly, consider using an iterator: let x_moves = vec![-1, -1, -1, 0, 1, 1, 1, 0]; let y_moves = vec![-1, 0, 1, 1, 1, 0, -1, -1]; for (x_offset, y_offset) in x_moves.into_iter().zip(y_moves) { let dest_row = self.row + x_offset; let dest_col = self.col + y_offset; if dest_row == chess_piece.row &amp;&amp; dest_col == chess_piece.col { return true; } } return false; This avoids repeated bounds checking which the compiler may or may not be able to elide. But I'd go further and pre-zip the array and iterate over that, since the x/y moves are so strongly tied together (it'd be an error for them to have different lengths). const KING_MOVES: [(i8, i8); 8] = [ (-1, -1), (-1, +0), (-1, +1), (+0, -1), (+0, +1), (+1, -1), (+1, +0), (+1, +1), ]; KING_MOVES.iter().any(|(x_offset, y_offset)| { let dest_row = self.row + x_offset; let dest_col = self.col + y_offset; dest_row == chess_piece.row &amp;&amp; dest_col == chess_piece.col }) This avoids any risk of allocating a vector just to loop over it, is more amenable to loop unrolling by the compiler, and it's more readable to boot.
No, I think. The PR will reduce the doc size. But rust-docs component is already compressed. So there would be a very little difference when installing the new rust-docs components.
How does one know that a type implements the default now? If it's not shown (because there is no custom impl) you might not notice that it exists.
Because the type automatically implements every inherent method of the trait.
Actually, Monero and Zcash are **not** the two most popular privacy coins. Dash is the first and most successful of the privacy coins. And is the [largest by fair value](https://www.coinfairvalue.com/). Fair value is a bit different from price in that it attempts to be an **objective measure** of the value stored in blockchains, without relying on exchange data. Exchanges are just websites that trade cryptocurrencies, so their data is not indicative of a particular coin as a whole. Anyway, Monero's privacy was broken from its inception and does not work. A former developer for Monero recently stated that its privacy is not 'fit for purpose' (i.e. it doesn't work): https://www.reddit.com/r/dashpay/comments/bindps/when_the_fud_finally_fails_and_the_ugly_hot_girl/em92sbz/ &gt;&gt;fireice_uk stated in his article, there's really no way to fix it. &gt;I didn't say that. I think it can be fixed, however **_*as is*_**, **Monero's (and all other cryptonotes') privacy is not fit for purpose.** Many researchers have broken Monero's privacy and gotten around its encryption, and as I point out [here, Monero has the smallest anonymity set of all the privacy coins](https://www.reddit.com/r/CryptoTechnology/comments/9ibrh0/cutting_to_the_chase_or_how_to_properly_evaluate/?utm_content=comments&amp;utm_medium=hot&amp;utm_source=reddit&amp;utm_name=CryptoTechnology). https://www.wired.com/story/monero-privacy/ &gt;The researchers also found a second problem in Monero's untraceability system tied to the timing of transactions. In any mix of one real coin and a set of fake coins bundled up in a transaction, **the real one** is very likely to have been **the most recent coin** to have moved prior to that transaction. &gt;Before a recent change from Monero's developers, that timing analysis **correctly identified the real coin more than 90 percent of the time**, virtually **nullifying Monero's privacy safeguards**. After that change to how Monero chooses its mixins, that trick now can spot **the real coin just 45 percent of the time—but still narrows down the real coin to about two possibilities**, far fewer than most Monero users would like. Finally, Dash uses privateSend which is not a third-party mixer, but it kind of is. There are around 5000 masternodes, Dash selects one at random which facilitates the mixing in a trustless and decentralized way. Control of funds never leaves the user.
They claim the mixer is "the protocol", but I guarantee you anti money laundering agents will not see it that way. They will say the miner, which executes the protocol, is.
Wow, I thought Facebook had good engineering. A giant mono-repo? That's crazy. What a mess...
Non blocking gets are now implemented. Feel free to check the new docs for version 3.6
The only tool I think that requires nightly is Miri. Rls, clippy and rustfmt are all available on stable and should work offline. If you use cargo vendor you can work fully offline
Yeah, the empty string should really be an error, and unescaping would ideally be a thing, and Unicode would be good. I'd probably write something like let delim: char = matches.value_of("delim").unwrap_or(",").parse()?;
I like the last one better. Question, do I have to add a plus sign to 0 and 1? (ie: `(+1, +0)`)
...said everybody back in the 1980s...
How is that any bad?
The `Error` associated type comes out wrong and I managed to make it work, but why doesn't https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=5bc68099c402a26b60cd8da3c844c160 compile?
 let delim: u8 = matches.value_of("delim") .into_iter() .chain(Option::Some(",")) .flat_map(|delim| delim.chars().next()) .filter(|delim| delim.is_ascii()) .map(|delim| delim as u32 as u8) .next() .unwrap();
I don't think that will work ([playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c3233f72e850b1bc9cb8e51669b3a78a)).
Is there a way to make an iter like this: `[(0, 0), (1, 0), (2, 0), (0, 1), (1, 1), (2, 1), (0, 2), (1, 2), (2, 2)].iter()`, taking two numbers (x,y) and iterating through all possible combinations of them, in order.
Now perhaps my \*desktop\* Firefox will be able to load the Iterator page again ;)
Plus signs are not required. In the above example they are just there to keep it formatted nicely.
&gt; Given this context, how do you sleep at night? facebook is run by a psycopath, and filled with psycopaths. they don't give a shit.
Does it type-check and borrow-check the GPU code?
Sure, this also comes in handy when iterating through 2D points: let iter = (0 .. 3).flat_map(|y| (0 .. 3).map(move |x| (x, y))); assert_eq!( iter.collect::&lt;Vec&lt;_&gt;&gt;(), vec![ (0, 0), (1, 0), (2, 0), (0, 1), (1, 1), (2, 1), (0, 2), (1, 2), (2, 2) ] )
Thank you very much :).
I "get" that - thank you. I appreciate your reply!
Thanks!
"fair value" LOLOL. This website looks like it was made by someone who is really butthurt they invested in junk cryptocoins. "No, actually the fair value means it was smart of me to invest in these depreciating speculative assets!"
They trust me, the dumb fucks
Hey I'm Brandon, an engineer on the Calibra team. In short, async/await and futures 0.3 have been a great productivity boost over futures 0.1. Being able to write straight line code over using combinators or requiring that you hand-write a state machines makes reasoning about the code much easier. We understand that async/await is still currently a nightly feature but we felt like the feature had really good velocity and was likely to become stable (which I think will happen in the next month or so) so it was worth investing in using it now. There were a couple rough spots we hit when we first started using it, mostly around use of multiple lifetimes and the error messages being quite dense, but the devs driving the implementation of async/await have been doing really great work to improve the whole experience and we've already seen great usability improvements. &amp;#x200B; I do think it would be worth while to write up a more in-depth experience report on our use of Rust and especially async/await. We'll try to do a post on this sometime in the next couple weeks.
Outstanding. Thank you!
It was a joke. There are so many large and heavy sites online that it will be fun to find one :D Glad people focus on docs also. Docs is how people learn and join the community.
How to use a cargo vendor ? Are there any instructions ? please give me some start point from I can learn and do my research
&gt;But again, this is marketed as a cryptocurrency, supposedly just like other cryptocurrencies. how is this true? it's marketed as a convenient payment system targetting the unbanked. I don't see any libertarian crypto rants on the homepage, and the privacy statements on the website make clear that they intent to comply with regulators want to reign in misuse.
Why did you even build it as blockchain? What do the transactors get from being a part of this? It could have just been a centralised database right?
Rust `#[repr(C)]` enum's are incompatible with C enum's, which hurts when Rust code need to interact with real world.
That explains why my browser would threaten to kill itself every time I looked up iterator documentation, but strangely only for the iterator page.
But that means that I cannot see all the methods I can use!?
I tried the \`static mut ...\` approach for a bit now, but came back to Rc+Clone. Wrote another little macro to turn this: gui.register_callback({ let gui = gui.clone(); move || gui.quit() }); into this: gui.register_callback(cb!([gui] || gui.quit())); Macro: macro_rules! cb { ( [$($ident:ident),*] $($cb:tt)+ ) =&gt; { { $( let $ident = $ident.clone(); )* move $($cb)+ } }; }
`HashSet::insert` is safe to call even if there's already an equivalent value in there, so you can skip the `.contains` check entirely.
My guess is because of the planned implementation of smart-contracts. Account based abstractions make much more sense in that context.
I believe this is what you're looking for: [click](https://github.com/alexcrichton/cargo-vendor)
Do you plan to refactor this in the future so that the language itself is separate from the concrete implementation? I have my own not-yet-released crate for GPU programming (currently it allows for more complicated compute graphs than your crate, and uses Vulkan instead of OpenCL, though I do plan to transparently support OpenCL and [Cranelift](https://github.com/CraneStation/cranelift) as backends too), and while I have a DSL-like API for defining kernels I'd really prefer something more ergonomic.
Thank you
I believe there's a bug in the code. If you ask it how many ways to fit 2 Kings (or 2 Knights), and no other pieces, on a 1-by-1 board, it will return 1 instead of 0. This is because you're (unintentionally?) relying on the `attacks` check to deal with 2-pieces-in-the-exact-same-position, but the King/Knight move checks specifically don't look at the (0, 0) offset.
In the case of `solutions` that's correct, I removed the `.contains` and the tests pass. In the case of the `tested_configurations`, removing the `if !tested_configurations.contains(&amp;new_board)` breaks all the tests. Conceptually it should be like you said (HashSets don't have repeated elements), that's why I mentioned the *equals-hashing-mumbo-jumbo* creating bugs.
So I should add the `(0,0)` offset, or I missed the point completely?
That's one option, and it's consistent with how the other `attacks` checks work. The other option is to specifically look for equal-position between pieces as part of `is_safe`. Either one is reasonable. Up to you.
No, they are still there at the top of the page the part that describes the trate.
The `tested_configurations` check is guarding more than just `.insert` (it also stops recursion from happening). Fortunately `insert` returns whether or not it actually inserted anything: if tested_configurations.insert(new_board.clone()) { let next_board_pieces = new_board.used_pieces; let next_board = Board::new(board.m, board.n, next_board_pieces); let tail = Vec::from_iter(pieces[1..pieces.len()].iter().cloned()); solution(next_board, tail, solutions, tested_configurations); }
I don't think so, but there are a large number of changes to rustup that will/are.
This is the correct answer.
They're likely going 256bit like everyone else.
The online book is available in a dead-tree edition. (Note it obviously won't be as up-to-date as the online version, but for learning the fundamentals, it should be fine). https://www.amazon.com/Rust-Programming-Language-Steve-Klabnik/dp/1593278284
[My initial reaction sounded like intro of this RCR episode](https://youtu.be/nEdIuoCus3Q), keep going with the good work
To add: Years of experience is not bound to actual time as well. You can learn double as much as an average dev does in a year, and as such claim 2 years of experience.
&gt; Generator optimization: Overlap locals that never have storage live at the same time. Woot!
Programming Rust by Jim Blandy is excellent!
&gt; I don't think there's an inherent right for financial transactions transactions to be private and cryptocurrencies should not be a way for people to engage in tax avoidance or other shady things. I'm also not big on crypto, but cash is private. The bigger problem I have with it is the dishonestly and god awful track record of the company behind it.
If they change versions once a second it would only take how long to overflow?
Awesome work!
resvg now passes more tests than both librsvg and Inkscape, which makes it the most accurate standalone SVG renderer in existence. Wow! I am equally impressed by the text rendering stack being entirely Rust, save for HarfBuzz. Could you elaborate on which crates made it possible, and whether are any initiatives to replace HarfBuzz in the future? Also I need to take this raqote for a spin. I had a bash script for visual quality comparison somehere.
How do I implement a trait for a wrapper type that targets both a wrapper type and it's internal type. For example: the tuple-struct `Wrapper&lt;T&gt;(T)` wants to implement `PartialOrd&lt;Wrapper&lt;T&gt;&gt;` and `PartialOrd&lt;T&gt;` so that it can be compared with the internal type and itself. Right now, I have this `impl` for `Wrapper&lt;T&gt;` ``` impl&lt;T, F&gt; PartialOrd&lt;F&gt; for Wrapper&lt;T&gt; where T: PartialOrd&lt;F&gt; ``` This `impl` essentially says that if the internal type `T` can be compared with `F`, that so can my wrapper type `Wrapper&lt;T&gt;`. This messes me up, however, because `T` obviously can't be compared with another `Wrapper&lt;T&gt;` because `T` wouldn't have an `impl PartialOrd&lt;Wrapper&lt;T&gt;&gt; for T` where T is a concrete type. I have tried that same block in my crate but the compiler complains that `T` must be used in the same crate (something about blanket implementations, I think). How can I allow my type to be compared with its internal type and itself? also just fyi: - My type is a little more complicated than just a tuple-struct, but it is essentially just a wrapper with some extra metadata. The implementations will not be affected that much. - I'm trying to implement a lot more than just `PartialOrd` on the type. In theory, I want to implement every trait that could be desired by a numeric type (`std::ops::*`?) Any help is appreciated! Thanks!
This looks like an awesome project. I have plans to develop image processing crates, and I have a feeling I’ll need something like this. What was the rationale behind the small differences between emu’s syntax and Rust’s? For example, `function` vs `fn` and `f(x f32` vs `f(x: f32)`. Not that it looks bad. I’m just curious.
Also, now that BIDI is implemented, shouldn't it be removed from the [list of unsupported features](https://github.com/RazrFalcon/resvg/blob/master/docs/unsupported.md)? Or am I missing something?
One of the nice things about Rust right now is that there's a lot of opportunity for making a popular library. If you develop a few useful crates, even if they're wrappers around a C lib, that'll look good assuming that you're in an area with Rust jobs. This may be unpopular in this sub, but Python or something else popular, dynamic, and interpreted may be a better choice, especially for someone who is green.
In case you haven't already, check out [rustfmt](https://github.com/rust-lang/rustfmt) (code formatter) and [clippy](https://github.com/rust-lang/rust-clippy) (code linter). Rustfmt keeps your formatting consistent without you having to focus on it. Clippy is really useful, especially when new to Rust. It will point out any common errors or improvements in your code. I'd probably suggest splitting up `Board` and `Piece` out into their own files, for better organization especially for tests. Since many of your tests are more-so unit tests, such as `test_rook_movements`, those should be moved into a test module within `src/piece.rs`. The `tests` folder is meant for integration tests which test multiple parts of your code working together. It's up to you whether you think the `Board` tests are unit tests for `Board` or integration tests, since they touch all of your code. It can be nice to have tests in every module though. See [the test section of the book](https://doc.rust-lang.org/book/ch11-03-test-organization.html) for more details on that. Also personally, I wouldn't prefix each test with `test_` because you already know it's a test.
`unicode-bidi` attribute is used mainly to control/disable the reordering. Currently, the BIDI reordering is always on. And previously, it did not work at all. As for `flate2`, it was long time ago and I don't remember exact reasons, but if I'm not mistaken, `flate2` could not parse svgz for some reasons.
I know about `rustfmt`, but not about `clippy` (I use VScode for Rust). I tried in earlier versions to put my tests with my code. Then I moved them to a folder inside `src`. Maybe it's because I come from a Java/Scala background, but it's weird for me to see my tests next to my code.
&gt; &gt; PS: tax avoidance is legal, tax evasion is the illegal one ...say the wealthy people who wrote the laws so that they could engage in tax evasion without fear of ~~the guillotine~~ ~~imprisonment~~ ~~debilitating fines~~ ~~nominal fines~~ pressure to donate to down-ballot GOP white supremacists.
&gt;most accurate standalone SVG renderer in existence According to my knowledge - yes. At least in FOSS, crossplatform category. It's actually a tricky comparison, since `resvg` still has a rudimentary CSS support. But if we talking about general SVG features - that yes. &gt;Could you elaborate on which crates made it possible It's mostly manual, see [usvg](https://github.com/RazrFalcon/resvg/tree/master/usvg/src/convert/text). And I'm using my own [ttf-parser](https://github.com/RazrFalcon/ttf-parser) for TrueType querying. &gt;whether are any initiatives to replace HarfBuzz in the future? I'm working on it, but not sure how long it will take. Or if I will be able to do this at all. It's a pretty complex piece of software. &gt;I had a bash script for visual quality comparison somehere. I have [a dedicated tool](https://github.com/RazrFalcon/resvg-test-suite/tree/master/tools/vdiff) for this.
Fantastic! This is really neat stuff. &gt; From now, text will be converted into paths before rendering. So a rendering backend no longer required to support text rendering. Just curious: would it not be good to preserve the option for backends that want to do their own text rendering? I can imagine backends with special text rendering requirements pretty easily, plus it seems like a potential efficiency loss.
Yes, I'm thinking on preserving some information. The problem is that SVG text layout is pretty complex and the only thing I can return is a list of glyph clusters (glyph ids + transform). Not sure if it make any difference. But it will be useful for svg-to-pdf converter, which is planned. &gt;a potential efficiency loss There are no performance differences, since backend should convert text to curves too.
Makes sense — cool. &gt; There are no performance differences, since backend should convert text to curves too. Maybe possibly. A rasterizing backend may be able to use a cached glyph image in a lot of cases. It would have to check that the transforms matched (up to translation), but they often do for runs of text. Keeping translation separate from the other transformations in the glyph cluster would be helpful for this use case, I think?
I highly doubt they're going to accept a 7000-line pull request that implements something that was never discussed _once_ previously in any public forum. There is no way to review or audit this; notwithstanding the size of the pull request, we have no roadmap or RFC to evaluate it against. As a contributor, the best thing you can do is bring it up with the community first. _Don't write any code_ until you get the green light. Otherwise, you'll be putting hours of work into a contribution that we have no idea what to do with.
"Concrete example" as in something that we can actually reproduce. Give us what you've done, down to every detail. Start from a fresh system and make sure you installed it correctly, then run your example again and show the output. Most likely, many people have come before you and used those crates on the msvc targets. Some may have encountered the same problems you're having. But we can't help you if we have no clue what is happening.
I notice the readme mentions Futhark but not the accelerate library? Does it draw any inspiration/lessons from accelerate?
Yep it even crashes the firefox preview using web render on my S8
&gt; fast, zero-copy, no-unsafe parser Is it possible to learn this power?
Link to Cargo PR: https://github.com/rust-lang/cargo/pull/6869
I'm not the author. I just found it and it's something I'm interested in.
The reason I'm asking is that libflate has a rather dubious safety record. Here are just the bugs that I've discovered: https://github.com/sile/libflate/issues/16 https://github.com/sile/libflate/issues/29 https://github.com/sile/libflate/issues/31 Due to the large amount of depent crates I am now (grudgingly) going through the libflate code, reporting and fixing the unsafety I find. But since I'm not a security professional my drive-by audit ain't worth a dime. I'd encourage people to use flate2 with Rust backend because it's both safer and faster than libflate.
I'm sorry for my misdirected comments. I also didn't do much research into the precedents set for new platform support, that was my bad.
Go away shill
I think other responders got most of it. * I would probably choose not to make the `struct`s be `Copy`, and instead explicitly `clone()` when needed. Helps keep a handle on efficiency. * Not a Rust issue *per se*, but I would probably get rid of the fancy `king_moves()` and `knight_moves()` functions and do them inline like the others. ChessPiece::King =&gt; { (self.col - chess_piece.col).abs() &lt;= 1 &amp;&amp; (self.row - chess_piece.row).abs() &lt;= 1 }, ChessPiece::Knight =&gt; { let dcol = (self.col - chess_piece.col).abs(); let drow = (self.row - chess_piece.row).abs(); (dcol == 1 &amp;&amp; drow == 2) || (dcol == 2 &amp;&amp; drow == 1) }, In general, defining `dcol` and `drow` as above atop the match would simplify some of the other code too. * I would definitely specify dimensions / indices as unsigned. No reason not to make them at least `u32`, I think. Optimism. :-) * Making the row and column indices 1-based instead of 0-based is a valid choice, but it isn't what I'd expect in Rust code. * Again, not a Rust issue *per se*, but it looks like it would be easy to rewrite `solution()` to be iterative, and I think the result would be simpler and easier to read. It would be slightly more efficient, since Rust has no tail-call elimination. Would also get rid of the explicit lifetime in `solution()`. You could also replace the extra parameters to `solution()` with locals by removing the recursion. I'd probably use an internal function in `solution()` to do this even if you leave it recursive: would be clearer code and simpler to call. * This let next_board_pieces = new_board.used_pieces.clone(); let next_board = Board::new(board.m, board.n, next_board_pieces); looks like it could just be let next_board = new_board.clone(); `clone()` is deep-copy in Rust. * This let tail = Vec::from_iter(pieces[1..pieces.len()].iter().cloned()); is a symptom. You really want to pull the pieces from the end of the `Vec` rather than the beginning: that should work fine here. The reference to `pieces[0]` above can be replaced with `pieces.last().unwrap()` and this code with let mut tail = pieces.clone(); tail.pop().unwrap(); Better would be some major restructuring to avoid the `clone()` altogether by `pop()`-ing the piece before the loops. Having `pop()` return an `Option` is handy there, because it avoids the separate `is_empty()` check. * Why is the `solutions` local/result a `HashMap` rather than a `Vec`? * In `main()`, call `Board::new()` rather than explicitly building a `struct`. Similarly, define a `Piece::new()` and use that in the lib.
Hmm, could someone in the know explain this? I'm curious if this is the `cargo build --deps` I've been waiting for to ease incremental build pains when building Rust programs inside of Docker.
Blandy and Orendorff's book is what I use to teach Rust. It's really good.
Try adding that file as a module in main.rs
Besides creating the file, did you include it with mod xxx.rs at in main.rs?
https://xkcd.com/1172/
i mean fucking really dude. we've got major psycopaths heading multiple multi-billion dollar platforms. and now you want them to control the fucking currency to? THANK YOU NO.
Yes, I've tried that but it just gives me an error. It tells me that the file is not in the project root.
\[RESOLVED\] I didn't add the mod declaration to the top of the file. Sorry for the beginner error. Its all working now. Thank you guys for the the help.
For those hearing about this for the first time (like me), apparently vxWorks is a proprietary hard-realtime operating system for applications like aerospace, medical and industrial equipment.
Reminds me of this: https://xkcd.com/1172/
So a couple notes I came up with You're doing a lot of `Vec::clone` on relatively small collections. For performance, you might want to look at a crate called [arrayvec](https://docs.rs/arrayvec/0.4.10/arrayvec/struct.ArrayVec.html). I haven't personally used it but I know of it and I think it fits your use case. There is at least one place you can eliminate a clone easily. Your `solution` fn takes a `Vec&lt;ChessPiece&gt;` but only uses it like a slice (and it is not even `mut`). If you change that type to a slice reference (`&amp;[ChessPiece]`) then when you get to the recursive call, you no longer need the clone. As a general rule (I'm not sure if I've heard this elsewhere, but it's something I've noticed in my own code and I feel like it is usually correct), you shouldn't be passing a non-mut `Vec` around. Either it should be mutably owned, or referenced (either mutably or immutably). Otherwise, you can probably make your code a tad more generic (and maybe more performant) by using a slice instead. Obvious exceptions might be if you're passing the vec through as a return (so this fn is just a middle-man in transfer of ownership), or if you explicitly want the vec to be dropped at the end of this fn. As someone else stated, I think it would be valuable to reduce the amount of indentation, particularly in `solution`. I rewrote this fn myself with early returns and continues and was able to get the longest indent down to 3 tabs. I can share it if you want, although I am not 100% sure it is correct (not tested).
My comparison scripts used imagemagick to get a similarity metric between rsvg and various resvg backends to find divergences so I would know which of 3000+ files to compare manually. `compare -verbose -metric MSE` is the gist of it, run through [parallel](https://github.com/mmstick/parallel) for speed.
If you're referring to ttf-parser, it actually says zero _allocations_, which is different from zero _copy_. `csv-core` is another example of a zero allocation, fast and no-unsafe parser, and might be a bit easier to grok. Here's an example: https://docs.rs/csv-core/0.1.5/csv_core/index.html#example-reading-csv And here's the API: https://docs.rs/csv-core/0.1.5/csv_core/struct.Reader.html The basic idea is to require the caller to provide their own mutable buffer for writing the parsed contents to. The main complexity is in making the API resumable. i.e., You need to handle the case when you need to write more data than the space provided by the caller. The fast/no-unsafe aspect of it varies depending on what you're parsing. For csv-core, it uses a DFA. A zero _copy_ parser is a different beast entirely, and there are more techniques required there. For csv in particular, you wouldn't ask the the caller for room to write the parsed contents, but rather, room to write _spans_ corresponding to the parsed fields. The caller would then be responsible for lazily de-escaping fields, if necessary, at a later point. So in this context, a zero-copy parser for csv would be most useful for inspecting a small subset of very large csv data. (But the performance difference is likely pretty small for csv.)
What's up with the bottom of the page, starting with `impl&lt;I: Iterator + ?Sized&gt; Iterator for Box&lt;I&gt;`? It seems to repeat some implementations that are already listed above, but without a link to the source or a collapsible menu. Or am I missing something?
How would you tell `rustfmt` to format the current file?
You'll get better performance out of Piece if you use #\[repr(u8)\] on your ChessPiece enum. I don't think rust does that automatically. I think you should refactor your code so that you add pieces to the board as an outer loop rather than by recursing. Then you will find that you can hold an array of pieces at the loop and don't even need a board class. You can represent board squares using a single u8 from 0..64 where the squares are numbered across each rank and then increase as you move up to the next file. You can store your board as an array of 64 (8x8) bytes where each byte has piece information. This way you can test each byte in the table directly rather than having to do a lookup into a list of pieces. ``` // ; Bit 7 -- Color of the piece // ; 1 -- Black // ; 0 -- White // ; Bit 6 -- Army (This is for 4k1w) // ; 1 -- Horizontal // ; 0 -- Vertical (traditional) // ; Bit 5 -- Not used // ; Bit 4 -- Castle flag for Kings only // ; Bit 3 -- Piece has moved flag // ; Bits 2-0 Piece type // ; 1 -- Pawn // ; 2 -- Knight // ; 3 -- Bishop // ; 4 -- Rook // ; 5 -- Queen // ; 6 -- King // ; 7 -- Off Board (used on corners) // ; 0 -- Empty Square ``` You can simplify your move calculation by using a mailbox (see https://www.chessprogramming.org/10x12_Board) which lets you do "Offset Move Generation" which is pretty cool and amazing actually. See the code. ``` BOOL slide[6] = {FALSE, FALSE, TRUE, TRUE, TRUE, FALSE}; int offsets[6] = {0, 8, 4, 4, 8, 8}; /* knight or ray directions */ int offset[6][8] = { { 0, 0, 0, 0, 0, 0, 0, 0 }, { -21, -19,-12, -8, 8, 12, 19, 21 }, /* KNIGHT */ { -11, -9, 9, 11, 0, 0, 0, 0 }, /* BISHOP */ { -10, -1, 1, 10, 0, 0, 0, 0 }, /* ROOK */ { -11, -10, -9, -1, 1, 9, 10, 11 }, /* QUEEN */ { -11, -10, -9, -1, 1, 9, 10, 11 } /* KING */ }; ``` You should use a bitboard class in your work https://docs.rs/chess/2.0.1/chess/struct.BitBoard.html Using that class, set every square that is currently threatened. Then flip the bits and iterate over the safe squares when adding the next piece. Note of course that after you add the next piece you only have to set the new bits that the new piece threatens and then OR the boards together.
This is really cool, but can you please format code with four spaces before the line, like this? The markdown backticks aren't supported on old reddit.
Yup, I now have the following definition: static ref WIDGET_REPOSITORY: Mutex&lt;Vec&lt;WidgetContainer&gt;&gt; Looking good so far. I'll have to change some of the functionality to support this, but I think this'll work for me.
And as a bonus, here is my piece class. All functions that take a board take a `board: &amp;[BoardSquare; 64]` (In my case it was a ; 256) ``` #[derive(Debug, Default, Copy, Clone, PartialEq, PartialOrd)] pub struct BoardSquare(u8); impl BoardSquare{ #[inline] pub fn new(army : u8, moved : bool, piece : u8) -&gt; BoardSquare { assert_eq!(army, army &amp; MASK_ARMY, "BoardSquare::new( army 0x{2:X}, ...) has bits 0x{0:X} set outside the army mask of 0x{1:X}", army &amp; !MASK_ARMY, MASK_ARMY, army); assert_eq!(piece, piece &amp; MASK_PIECE, "BoardSquare::new( piece 0x{2:X}, ...) has bits 0x{0:X} set outside the piece mask of 0x{1:X}", piece &amp; !MASK_PIECE, MASK_PIECE, piece); BoardSquare ( army &amp; MASK_ARMY | if moved {0x8} else {0x0} | piece &amp; MASK_PIECE ) } #[inline] pub fn empty() -&gt; BoardSquare {BoardSquare(EMPTY)} #[inline] pub fn off_board() -&gt; BoardSquare {BoardSquare(OFF_BOARD)} #[inline] pub fn raw_for_test(raw_val: u8) -&gt; BoardSquare {BoardSquare(raw_val)} #[inline] pub fn is_army(self, army : u8) -&gt; bool { (self.0 &amp; MASK_ARMY) == army } #[inline] pub fn is_color(self, color : u8) -&gt; bool { (self.0 &amp; MASK_COLOR) == color } #[inline] pub fn is_piece(self, piece : u8) -&gt; bool { (self.0 &amp; MASK_PIECE) == piece } #[inline] pub fn is_any_piece(self) -&gt; bool { (self.0 &amp; MASK_PIECE) != EMPTY &amp;&amp; (self.0 &amp; MASK_PIECE) != OFF_BOARD } #[inline] pub fn is_empty(self) -&gt; bool { self.0 == EMPTY } #[inline] pub fn piece(self) -&gt; u8 { self.0 &amp; MASK_PIECE } pub fn color(self) -&gt; u8 { self.0 &amp; MASK_COLOR } pub fn army(self) -&gt; u8 { self.0 &amp; MASK_ARMY } #[inline] pub fn is_army2(self) -&gt; bool { (self.0 &amp; MASK_ARMYBIT) != 0 } pub fn piece_char(self) -&gt; char { match self.0 { OFF_BOARD =&gt; '/', EMPTY =&gt; '.', v if v &amp; MASK_COLOR == COLOR_BLACK =&gt; match v &amp; MASK_PIECE { PAWN =&gt; 'p', KNIGHT =&gt; 'n', BISHOP =&gt; 'b', ROOK =&gt; 'r', QUEEN =&gt; 'q', KING =&gt; 'k', _ =&gt; '?' } v =&gt; match v &amp; MASK_PIECE { PAWN =&gt; 'P', KNIGHT =&gt; 'N', BISHOP =&gt; 'B', ROOK =&gt; 'R', QUEEN =&gt; 'Q', KING =&gt; 'K', _ =&gt; '?' } } } pub fn print(self) -&gt; String { let piece: char = self.piece_char(); if self.0 &amp; MASK_MOVED == MASK_MOVED { format!("[{0}]", piece) } else { format!(" {0} ", piece) } } } ```
True, but still might be nice to show some indication that there other other methods, e.g. "+16 default implementations - see trait definition". At least when exploring docs for unknown traits/structs this indicates there are other methods not shown rather than implying the trait only has the required/overridden methods.
I know this is a little late, but [a section](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#mutable-references) in the references and borrowing section of the Book has a bit on this behavior. This is the example given: ``` let mut s = String::from("hello"); let r1 = &amp;s; // no problem let r2 = &amp;s; // no problem let r3 = &amp;mut s; // BIG PROBLEM println!("{}, {}, and {}", r1, r2, r3); ``` Compiling it in [the Playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20s%20%3D%20String%3A%3Afrom(%22hello%22)%3B%0A%0A%20%20%20%20let%20r1%20%3D%20%26s%3B%20%2F%2F%20no%20problem%0A%20%20%20%20let%20r2%20%3D%20%26s%3B%20%2F%2F%20no%20problem%0A%20%20%20%20let%20r3%20%3D%20%26mut%20s%3B%20%2F%2F%20BIG%20PROBLEM%0A%0A%20%20%20%20println!(%22%7B%7D%2C%20%7B%7D%2C%20and%20%7B%7D%22%2C%20r1%2C%20r2%2C%20r3)%3B%0A%7D%0A) gives this error: ``` error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable --&gt; src/lib.rs:6:10 | 4 | let r1 = &amp;s; // no problem | -- immutable borrow occurs here 5 | let r2 = &amp;s; // no problem 6 | let r3 = &amp;mut s; // BIG PROBLEM | ^^^^^^ mutable borrow occurs here 7 | 8 | println!("{}, {}, and {}", r1, r2, r3); | -- immutable borrow later used here ``` The Book gives this reasoning: ``` Whew! We also cannot have a mutable reference while we have an immutable one. Users of an immutable reference don’t expect the values to suddenly change out from under them! However, multiple immutable references are okay because no one who is just reading the data has the ability to affect anyone else’s reading of the data. ``` That being said, [u/dreamer-engineer's answer](https://www.reddit.com/r/rust/comments/c1lj6f/hey_rustaceans_got_an_easy_question_ask_here/eriu4a8?utm_source=share) mentioned how Non-Lexical Lifetimes will fix this. To you, it is obvious that the mutation of the slice takes place after the immutable borrow in order to find the slice's length. However, if we expand the code into a more qualified syntax, we can see why this happens. ``` slice.swap(0, slice.len() - 1); ``` can become (for slice of example type `&amp;[T]`) ``` &lt;impl&lt;T&gt; [T]&gt;::swap(slice, 0, slice.len() - 1); ``` and then ``` let _0: usize = 0; let _1: usize = slice.len() - 1; &lt;impl&lt;T&gt; [T]&gt;::swap(slice, _0, _1); // swap takes type `&amp;[T]` ``` and then ``` let _0: usize = 0; let _1: usize = &lt;impl&lt;T&gt; [T]&gt;::len(slice) - 1; // len takes type &amp;[T] &lt;impl&lt;T&gt; [T]&gt;::swap(slice, _0, _1); // swap takes type &amp;[T] ``` Now compare this new code to the example in the book. In the example, there are two immutable borrows followed by a mutable one. In the same way, in the above code snippet, the immutable borrow (line 2) is followed by a mutable one (line 3). Furthermore, we can see this behavior in the MIR code generated. Take this example code and generate its MIR in [Playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;code=fn%20main()%20%7B%0A%20%20%20%20let%20ref%20mut%20slice%20%3D%20%5B1%2C%202%2C%203%2C%204%2C%205%5D%3B%0A%20%20%20%20go(slice)%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20slice)%3B%0A%7D%0A%0A%23%5Binline(never)%5D%0Afn%20go(slice%3A%20%26mut%20%5Bi32%5D)%20%7B%0A%20%20%20%20let%20slice_len%20%3D%20slice.len()%3B%0A%20%20%20%20slice.swap(0%2C%20*return1())%3B%0A%7D%0A%0A%23%5Binline(never)%5D%0Afn%20return1%3C%27a%3E()%20-%3E%20%26%27a%20usize%20%7B%0A%20%20%20%20%261%0A%7D) ``` fn main() { let ref mut slice = [1, 2, 3, 4, 5]; go(slice); println!("{:?}", slice); } #[inline(never)] fn go(slice: &amp;mut [i32]) { let slice_len = slice.len(); slice.swap(0, *return1()); } #[inline(never)] fn return1&lt;'a&gt;() -&gt; &amp;'a usize { &amp;1 } ``` In the MIR for this example, the return value of `return1` is `&amp;usize` and is represented by `_7` (which is then dereferenced into `_6`) in the `go` function. Both of these variables are dropped in `bb3`, the last basic block of the function, meaning that the reference of has essentially stayed "alive" until the end of the function, even though it is directly used as a function argument. If we use this code instead ([Playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;code=fn%20main()%20%7B%0A%20%20%20%20let%20ref%20mut%20slice%20%3D%20%5B1%2C%202%2C%203%2C%204%2C%205%5D%3B%0A%20%20%20%20go(slice)%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20slice)%3B%0A%7D%0A%0A%23%5Binline(never)%5D%0Afn%20go(slice%3A%20%26mut%20%5Bi32%5D)%20%7B%0A%20%20%20%20let%20slice_len%20%3D%20slice.len()%3B%0A%20%20%20%20slice.swap(0%2C%20slice_len%20-%201)%3B%0A%7D%0A%0A%23%5Binline(never)%5D%0Afn%20return1%3C%27a%3E()%20-%3E%20%26%27a%20usize%20%7B%0A%20%20%20%20%261%0A%7D)) ``` fn main() { let ref mut slice = [1, 2, 3, 4, 5]; go(slice); println!("{:?}", slice); } #[inline(never)] fn go(slice: &amp;mut [i32]) { let slice_len = slice.len(); slice.swap(0, slice_len - 1); } #[inline(never)] fn return1&lt;'a&gt;() -&gt; &amp;'a usize { &amp;1 } ``` We can see that `slice_len` has its own scope (`scope 2`). The variable `_3` represents the immutable borrow on `_1` (which is the original slice aka `slice` in your example`). `_3` is assigned with `_1`'s value in `bb0`, the first basic block. The `len` call is performed afterward (still in `bb0`). Then, in `bb1`, the first two things that happen are that `_3` is dropped and `_5`, which represents the mutable borrow for `swap` has its lifetime started. In short, the immutable borrow is "killed" before the mutable one is "born", which means there is no conflict between them. This makes sense because the immutable borrow is only needed to calculate `slice_len`, and then it can be discarded. With NLLs, this would be the case for your example as well. Sorry, I know this answer was overkill. Honestly though, writing it helped me learned a little too. Hope this helps, even if just a little bit.
Unfortunately, no. This is a tool for copying your dependencies so that with a checkout of your repo you can build without net access.
Wow! Thank you! That makes a lot more sense, especially with the scoping stuff. I really appreciate it!
You don't need cargo vendor to work offline. At all. Period.
This is the subreddit for the Rust programming language. You're looking for /r/playrust
Mastering Rust: Learn about memory safety, type system, concurrency, and the new features of Rust 2018 edition, 2nd Edition by Rahul Sharma and Vesa Kaihlavirta
Well to be fair, there are a lot of issues that arise in Monero in practice that the devs aren't really open about. But that's a different issue.
What's the behavior you're looking for?
&gt; +16 default implementations - see trait definition That's a great suggestion; could you report a new issue, and link it from this issue?
Have you looked at `pathfinder` as a potential rendering backend?
Ah, darn. Well, a solid addition nonetheless :)
Well, ideally a cargo subcommand that allows breaking the building of a crate/cargo workspace into two steps. One for building dependencies and one for building the project itself. https://github.com/rust-lang/cargo/issues/2644 This is the issue I've been following for a while now. It's not a show-stopper, but it makes me look foolish when I suggest Rust on projects at work :).
Press 'Esc' for a neat trick!
How are strokes mapped to Micro SVG? Are those just passed through as strokes, or are they converted to filled polygons? I'm asking because that's a very difficult process I'm going to have to implement very soon in my code…
Is this just random website prepared by someone? I don't think it's very useful then.
Rust is cross-platforms, the publicly available crates don't have to. As a crate author, I personally don't care about property platforms like Windows at all, so unless someone is willing to do the hard work and submit PRs, I don't care. Who do I go to rant to when software I might want to work with doesn't work on Linux?
Just use the search function on crates.io and do some sorting. There are nice graphs and usage numbers. If you can't find what you want do an online search.
This is exactly what I was planning to make this summer!
In fact, Pathfinder's SVG front-end *is* resvg! So if you check out the Pathfinder demo, you're in fact using a Pathfinder backend for resvg.
Wrong sub. See r/playrust
There's also the [`iproduct`](https://docs.rs/itertools/0.8.0/itertools/macro.iproduct.html) macro in itertools, if you don't mind bringing in another dependency.
Thats awesome! Ive used VxWorks for some time now, and its cool to see Rust and VxWorks mentioned together. It does look like a great amount of work, and Ive having a hard time wrapping my head around it all without some more context.
I don't know that there ARE
I'm not aware of any Rust course that comes with any kind of certificate. It might be partly because Rust is a relatively young language, but I also suspect that the intersection of companies who evaluate candidates based on programming language "certifications" and companies who are interested in hiring for Rust skills would be vanishingly small.
Just a small squibble, but traits have default function/method implementations, not "inherent" function/methods. An inherent method is one that's implemented on a type directly. E.g. `impl YourType { fn inherent_method(self) { } }`
LLVM is written in C++ and is designed for compile-time, link-time, run-time, and "idle-time" optimization. Originally implemented for C and C++, the language-agnostic design of LLVM has since spawned a wide variety of front ends: languages with compilers that use LLVM include ActionScript, Ada, C#,[5][6][7] Common Lisp, Crystal, CUDA, D, Delphi, Dylan, Fortran, Graphical G Programming Language,[8] Halide, Haskell, Java bytecode, Julia, Kotlin, Lua, Objective-C, OpenGL Shading Language, Pony,[9] Python, Ruby,[10] Rust, Scala,[11] Swift, and Xojo.
I started filing the issue and while fleshing out a justification I realized that the reduced documentation is only on the page for the trait itself, which already lists all available methods on the trait. The page for the type displays all methods for the trait. So I had a wrong impression of the change and it turns out all pages contain all the information somewhere. I'm now less convinced the "+n default impls" when you're already on the page showing those default impls is actually useful.
VxWorks costs about 40k$ per license per year according to a co-worker. It's supposed to be excellent, but for that reason, at the space company I work for, we opted to use a lightweight Linux or RTEMS instead.
Like what?
This is the subreddit for the Rust programming language. You're looking for /r/playrust or /r/playrustvideos
You can't use a macro in a \`where\` clause like that; it has to evaluate to a pattern, expression, statement, or item(s).
I found this video super useful. Although I haven’t dived too deep in myself yet. https://youtu.be/317dNavABKo
It's interesting! I think it'd probably be more useful with either more transparency in how choices are made, more trustworthyness by more editors, or perhaps with a particular goal or subset of the ecosystem in mind. Right now, crates.io exists, and crates.rs also does providing a slightly nicer view into the same (entire) ecosystem. Both can be used for searching, and for all crates. There are more lists, and room for more lists, but to be useful it needs to be more than just "a list of crates". One way to make this useful is to look at one particular subset. Like the various arewe*yet: [arewewebyet](https://www.arewewebyet.org/) looks at web-related crates and [arewegameyet](http://arewegameyet.com/) looks at game-development resources/crates,. The other aspect of this is trust. One person's opinion is nice, but rarely trustworthy when constructing a list of an entire ecosystem. One person's opinion is always going to be skewed towards that person's area of interest and what crates they happened upon first. The best way to get around this is to get more opinions - and that's exactly what lists like [stdx](https://github.com/brson/stdx) (a list of the most essential and best crates to use) and [awesome-rust](https://github.com/rust-unofficial/awesome-rust) do by being on GitHub and accepting pull requests. Another way might be to have a team of people, or to use another source control (like a wiki page) to allow editing. Best of luck to your creating this, and finding a niche for it!
I've been starting on their tutorial as well, except is Python. Is there a libtcod library for Rust as well?
I've been finishing up my first emulator! I've written a simple Chip-8 emulator in Rust and SDL, and it's gotten to the point where many of the games are playable. I am curious if anyone here as any experience with WebAssembly. I think it would be fun to have it run in an HTML canvas instead, but I'm not sure how to go about using one rather than SDL. I'm not sure if it would be as simple as replacing the drawing functions or not.
Isn't the inference happening in signatures just syntactic sugar, and not based on the body of the function at all?
Stroking is all done by the backend libraries.
You want /r/playrust.
Do you want to edit this into your post?
Yes after the Cambridge analytical and their general behavior, why the fuck would we support currency with Facebooks name all over it
I don't trust facebook, how can anyone trust facebook, it's all for the shareholders. What makes crypto currency appealing in the first place is non corporate ownership, it's already rooted into our lives given the way advertisers are in our face fucking constantly. This is a marketing move and I wish Facebook would keep their paws out of the cookie jar, theyve done enough damage to the global community already. Fuck them. Good luck on your project I guess.
Other platform support pull requests were accepted (Haiku and CloudABI). So I don’t see a problem with this one.
You're looking for /r/playrust.
I can't open the website. Says the domain is blocked and that the certificate isn't trusted... It wasn't doing that last week... &amp;#x200B; Anyone else getting this?
It's just you. It works like a charm here.
What's the current target for `await` stabilization? Is it still 1.37?
It's true only when SVG has a lot of text, which isn't happening that often.
Classic case is maps. Tons of text, only a few fonts and sizes. Text on many maps is horizontal or vertical. But you're right, it's not a huge deal even there.
It's a theoretical attack but there's situations where if an attacker controls a very large proportion of outputs then they can deanonymize which outputs are from a target. It's also difficult to determine an anonymity set that's secure unless you're running a fully synced full node, which isn't great because it increases the amount of work a client has to do. That being said, I'm not an expert in how the protocol works so I'm not sure if some of these attacks are practical. I still prefer Zcash though as it uses an entirely different technique to obscure the tx graph.
By default, doc comments only work for library crates, not binary crates. You can use `cargo doc --document-private-items` to get the docs built for a binary crate.
Tired. Still Didn’t work
Did you look in `target/docs`? You can build and open the docs with `cargo doc --document-private-items --open`.
I ran the exact same command. With —open In the target/docs is lots of files. By the way I am using rand crate and the rand doc is already there but only not mine !
See my edit above.
oh yea that works now. thank you so much
You're right. I didn't think of them. Anyway, the current backends are still to high-level for this.
Implementing PNG, which means implementing deflate. &amp;#x200B; oof
No Facebook/libra Rust job yet?
Can you share a link?
It looks very advanced. Does it teach Rust, like keywords and stuff, or just explains the concepts and behind-the-scenes?
ahh shit lololol high asl
Who said it has to be bad? It's a consideration and an important one worth mentioning. I don't like building "framework" applications. I don't like building a rails app or a laravel app or a runtime app. IO should be off to the side, easily switchable, serving my needs, serving my architecture, not the other way around. Sometimes I do need to insert myself into a framework. That's the point, a consideration.
Im implementing the final touches currently, I will put the put the link in this post soon 👍
Partial initialization is kind of frowned upon here. After creating a new Foo, you have to assume that nobody else uses q and w while unitialized, and this is kind of a more "implicit" contract between the user of the structure and the structure designer than rustc would like. You could use an Option&lt;Q&gt; and Option&lt;W&gt;, but the problem is is that each of your struct's methods will have to check whether they actually exist before using them, and this may incur a performance penalty. The ideal solution would be to make a FooBuilder structure, maybe a bit more time-consuming, but it's perhaps the best option. That way, FooBuilder looks like this struct FooBuilder&lt;Q, W&gt; { q: Option&lt;Q&gt;, w: Option&lt;W&gt;, i: i32 // set this to Option&lt;i32&gt; if you want the person using the builder to set it before creating Foo } impl&lt;Q, W&gt; FooBuilder&lt;Q, W&gt; { fn new() -&gt; { ... } fn q(self, val: Q) -&gt; Self { self.q = Some(val); self } // repeat for other fields fn build(self) -&gt; Foo { if q is Some, w is Some { give new foo} else { panic or return an Err/None } } }
&gt;It's a theoretical attack but there's situations where if an attacker controls a very large proportion of outputs then they can deanonymize which outputs are from a target. That's obvious to anyone who understands the basics of how it works. I have seen many people talk about it. If you think devs are trying to not be upfront about the basics of how the protocol works then you must have no experience with monero developers at all. Note that as soon as there are several such attackers the attack no longer works, since they must compete with each other to control the vast majority of outputs. Each ring also consists of a weighted distribution of new outputs and some older outputs, so an attack loses its effect quickly if it's not sustained. &gt;It's also difficult to determine an anonymity set that's secure unless you're running a fully synced full node, which isn't great because it increases the amount of work a client has to do. I have no idea what you're talking about. &gt;I still prefer Zcash lol https://twitter.com/zooko/status/863202798883577856
Man, I would really love this. I've implemented the hacky workarounds myself as well, and they kind of suck. I just want a nice stateless Dockerfile solution for builds / CI / dev which doesn't re-download and re-build all dependencies every time if they haven't changed, and doesn't require nasty hacks that depend on the precise layout of the cargo project and the contents of Cargo.toml. It really doesn't seem like it should be so difficult to implement to only download and build dependencies...
Thanks. But this is only for internal usage, and I need something like this: | head | -&gt; | node_1 | -&gt; | node_2 | -&gt; ... | node_n | Head and other nodes are the same structures except the head should be initialized partially, and his uninitialized values will never be used.
My understanding is that on the traits' page you'd first get the trait's documentation (with every public method documented) then for *each and every implementation* you'd get the entire trait being documented again. That's why the Iterator page is humongous: it's a big trait (59 methods) implemented by *lots* of types. And while the documentation for a few dozen methods is fine, a few dozen methods * a few dozen implementors brings the browser to its knees. And this gets worse every time a new impl is added, or a utility method is added to Iterator. The change is that *in the implementors' section* only the method that implementor overrides gets documented, as the rest is functionally redundant.
&gt;Doc comments can't be in an inner scope. Actually, they can. You just have to write `//!` instead of `///`.
`///` documents the following item, whereas `//! ` documents the enclosing item (mirroring `#[]`/`#![]`) . The latter can be used to document a crate/module; for the rest it's preferred to use former.
Yeah, true. But I think it's really unidiomatic Rust: I've never seen it done in the wild.
Have your struct look like this: ```rust struct Foo&lt;Q, W&gt; { i: i32, data: Option&lt;(Q, W)&gt;, } ```
If the head is special, you should consider using a different type for it.
I'm assuming a license covers multiple devices, right? If not, then using it for home routers (like Linksys did with its later iterations on the WRT54G) would have made zero economic sense.
Yes, currently I use Option for values which can be uninitialized. But in all parts of my code, I use 'unwrap()' for access to values of non-head nodes and maybe this is not a good way.
https://users.rust-lang.org/t/cargo-crev-user-guide-differential-reviews-and-0-8-release/29436 (I hope the url says it all)
Some might argue that putting the documentation inside/after item definitions is more readable, but place I really see inner doc comments is at the top of modules.
Yes. I think about this.
All I know is that it's 40k per developer license, which is tied to a single computer. So if a company has ten developers working on vx works, then they need ten developer licenses. I don't know about the licensing costs on the final products.
You are building a linked list? Check out the classic: [Learning Rust With Entirely Too Many Linked Lists](https://cglab.ca/~abeinges/blah/too-many-lists/book/README.html).
Even in JS, I think there are ways to optimize numeric-heavy code by borrowing from [asm.js](http://asmjs.org/spec/latest/). You can, for example, hint that a value `x` is numeric by doing something like `x = +x;`.
The only known "certificate" that could be put on a CV that I know of is a commit in rust-lang/rust with an r+ from Niko himself 😄
Its true but increasingly not worth it. If you wanted to write fast numerical code for the web, js is a terrible choice these days
Your immediate problem could be solved by wrapping the fields in a [`ManuallyDrop`](https://doc.rust-lang.org/beta/std/mem/struct.ManuallyDrop.html). But you should avoid working with uninitialized memory wherever possible.
If I were you, I would stick with JavaScript or Python. I've been programming professionally with JS for the past 2 years or so and am just now learning Rust because I want to branch out into another language that has a separate use case. I'm going through the Rust docs and while they are the best docs I've come across yet in my career, most the the concepts like structs, traits, signed ints, unsigned ints, borrow checking, etc are not anything that JS has so a bit of a learning curve for me. Echoing what others have said, if you intend to become a software engineer as a career and you don't have a CS degree, study a language that will actually get you a first job. When I look on indeed or stack overflow for jobs, Rust developers are few and far between. Also, those jobs are generally looking for someone with a CS degree or some years of experience as the type of programming will be generally more in depth than with many web development jobs. TL/DR: If you want to get a job, learn JS, or Python or even Java. Then, once you are fully comfortable with programming basics, consider learning Rust in your free time and try to transition to a Rust developer position for your second job. However, if this is all just a hobby for you, by all means dive into Rust.
Oh wow, I didn't even realize this was the case. Thanks for explaining it so clearly.
You seem to be using "char" and "byte" to mean the same thing. That's not accurate, as most characters (`char` type in Rust) do not fit into a single byte (`u8` type in Rust). This confusion probably contributes to why the code feels awkward. Your code will break horribly when someone sets `ä` as the delimiter. Also see https://manishearth.github.io/blog/2017/01/14/stop-ascribing-meaning-to-unicode-code-points/ for some more discussion why "character" is a fuzzy concept.
No, not liked list. But more close to skiplist.
You ran into a coherence/orphan rule issue. Essentially, what you're trying to do won't work. You have to find a different approach. As for the rules about when and when not a trait impl is allowed, I'm fuzzy on the details. But I've seen [this talk](https://youtu.be/AI7SLCubTnk?t=2599) being recommended to shed some more light onto coherence rules (including *why* we have these rules).
Coinshits can go get fucked
I'm fairly amazed.
or at least use an enum: enum Foo&lt;Q, W&gt; { Head { i: i32 }, Node { q: Q, w: W, i: i32, } }
Thanks, interesting solution, I will play with it.
Why don't you make it be an two-variant struct-like enum? One for Partially initialized and one that's fully initialized Or two types altogether - maybe put the overlapping functionality in a trait
There are two key design decisions of rust in play here: - First, no two implementations of a trait for a single type should overlap. There should never exist ambiguous trait implementations. - Second, adding a new trait implementation in a new crate should not be a breaking change. With that in mind, I _think_ the issue here with the second implementation is that some other type can write an impl like your first one. In my crate, I can write: struct Foo; impl&lt;T&gt; PartialOrd&lt;T&gt; for Foo where T: PartialOrd&lt;Foo&gt; { ... } Then a third crate, depending on both, could construct `Wrapper&lt;Foo&gt;`. What implementation would be used for `Foo as PartialOrd&lt;Wrapper&lt;Foo&gt;&gt;`? The impl would be ambiguous because it could be satisfied both by `impl PartialOrd&lt;Wrapper&lt;T&gt;&gt; for T` and `impl PartialOrd&lt;T&gt; for Foo where T: PartialOrd&lt;Foo&gt;`. Since I have the ability to add this implementation, and making this implementation would be ambiguous with your second impl, your second impl cannot exist. It's a somewhat restrictive rule, but one which keeps coherence, and makes sure that trait implementations can never be ambiguous. ---- With that said, you've run into a common problem with wrapper types - it's not generally possible to make them interact nicely with everything they wrap. The main solutions I know of are to either make it wrap a specific type rather than being generic, or to only implement `PartialOrd&lt;Wrapper&lt;T&gt;&gt; for Wrapper&lt;T&gt;`: force all unwrapped types to be wrapped first.
Probably not the best solution, as it can represent a list that contains multiple heads. The solution to use a totally different type for the head seems better to me.
Maybe [https://www.ruby-toolbox.com/](https://www.ruby-toolbox.com/) could give you some inspiration for where to take this project. They rank packages based on downloads and Github activity.
Isn't skiplist even more linked than usual linked list? :)
Haha, there is one useful modal: "Unsaved changes; are you sure you want to close?". Of course, with a "yes, don't show me this again" checkbox. I think there are ways of getting around that specific modal, and pressing the close button on a window again should be the same as "I don't care just close the window right now".
How do they ensure that the data entered is correct in the first place? If there's a company/charity/whatever entering them, they need to trust that entity, therefore, they don't need a blockchain. Strangely, the article linked presents some basic misunderstandings of how blockchain works. For instance, it's not encrypted (and I know this for a fact, since I wrote my own blockchain parser in Rust). The "certificate of deposit" isn't "cryptotoken" and "cryptotokens" arent't "lines of code". Further, I think the author of the article doesn't quite understand how prices and market work. Price isn't something objective, but always subjective. As such, it can't be dictated by some external system, but negotiated between the trading parties. It's definitely useful if the parties have some tool to measure the properties of what they're transacting. The blockchain isn't that tool - it's just unnecessary thing on top of something useful (a scale with some kind of detector). Ironically, even if they manage to convince market actors to use their scheme (if someone wants to rip off a farmer, he will just refuse to use such thing) it would very likely lead to the opposite of what they try to achieve - it'd pressure the farmers to provide lowest possible price for same quality, making less efficient farmers to bankrupt sooner. It'd enrich the companies taking care of transferring the coffee even more (since the demand for coffee isn't affected by this system). Blockchain isn't a magical savior of everything and as I said previously, there's only one thing where it makes sense. If someone wants to genuinely help the farmers, he should create their own transport company that is more efficient than the competition and then pay the farmers more.
Runtime failures are a pain, but a runtime failure that simply gives you a message like "You did something wrong when creating element X" or "You need to give this thing a width", and then letting you reload the file in under a second, does not feel like it should be a huge deal even to new users. But I can see where you're coming from and I understand that not everyone wants or needs to change a button 10 times until they're satisfied. You're entitled to you opinion, and I'm glad you took the time to give me some perspective :)
Thank you for responding. I’m more along the way with JS than Python. I was also going to learn Solidity after I felt somewhat competent with JS as then syntax is supposedly similar. I’ve come across some really hateful views on JS so it kinda threw me off. I then sought out GO as an alternative and then Rust came up after digging even deeper. I understand that Rust devs will be needed for more technical stuff, and as a beginner I’d lack experience. However, I’ve found some jobs in my city (London). If I even got to entry level, I wouldn’t mind working for minimal pay, or even as an apprentice (if that’s even possible) just to learn, is even consider working for free if I can learn from it. That being said, would you say that it would still be a bad house to start with Go then transition into Rust? Or purely stick to JS? I’m going on a bootcamp soon to speed the process up (controversial move) and the focus will be further JS, Ruby, RoR and PHP. I did bring this up in other questions I’ve asked outside of Reddit and most seemed to dismiss Ruby, others JS. So that’s when I felt like I had to search for a ‘better’ language
As long as it doesn’t break anything, and it has a couple of people maintaining it.
The more annoying thing is the implicit lifetime bounds that get added. eg. this signature: fn foo&lt;T&gt;(x: T) -&gt; impl Trait { ... } Used like this: let result = foo(&amp;test); drop(test); use(result); // Error Will fail to compile, because the lifetime of the return value gets tied to the lifetime of any generic arguments, and so it will try to make the borrow of "test" last as long as "result" is alive. Even if you add a `'static` bound on the return value, it will still fail.
I mean not simple linked list where head initialized like other nodes. In skiplist head represent the only vector of forwarding node pointers, so in this case for more simpler code design will be good to use for head and for other nodes the same structure. This is good work in C but I think not for Rust .
Maybe. I'll try. Thanks for the idea. :)
Bad phrasing. Sorry. Your answer is great though. Just what I wanted to know.
\&gt; Remember to bookmark it! ;) &amp;#x200B; Just download it and add it to WebRenderer as a standalone test.
Thank you. I was using char because it was passed via command line
(Sharing as a PSA. I didn't know about this behavior before, nor about the lifetime bounds Diggsey mentioned. That certainly explains some confusing type errors.)
You tried to unify the types of both if-branches. But a `&amp;dyn Iterator` is pretty useless. You can only use it to call Iterator methods that take `Self` by reference (`&amp;self`) and not anything else. However, note that `&amp;mut I` is an Iferator if and only if `I` is an iterator. There is a blanket implementation in the standard library for it. And this implementation does not care about whether `I` is sized or not. Yay! :) So, what you could do is this: fn main() { let mut head = vec!["a", "b", "c"].into_iter(); let tail = "d"; let mut tmp; let combined: &amp;mut dyn Iterator&lt;Item=&amp;str&gt; = if tail.is_empty() { &amp;mut head } else { tmp = head.chain(std::iter::once(tail)); &amp;mut tmp }; combined.for_each(|x| println!("{}", x)); } Here, `combined` is itself an iterator that mutably borrows `head` and optionally `tmp`. `tmp` is just there for storing the result of the `chain` so that is has a sufficient lifetime. We can't make &amp;mut head.chain(std::iter::once(tail)); work because `chain` returns some temporary iterator that would expire too quickly at the end of the `if`'s closing curly brace. There are other options. Boxing as well as Either already have been suggested.
If you want to be a blockchain developer you pretty much have to learn C++, as the only really relevant blockchain today is written in C++. However, if you're interested in helping to develop sidechains, then Rust is better choice than Go and C++ becus of it's safety guarantees, which are much needed in such security-critical project. Finally, if you don't want to develop the blockchain but on top of blockchain, you might want to learn Scala/Go/Rust/C and you definitely need to learn [Script](https://en.bitcoin.it/wiki/Script) and later [Tapscript](https://github.com/sipa/bips/blob/bip-schnorr/bip-tapscript.mediawiki)
Is your code available somewhere so we can take a look at it? If I may, the Rust compiler constantly complaining about the issues you mention is often the sign of an impractical design, and finding the right one is pretty hard without more experience IMHO. Rust being disruptive in several ways also impacts how to design things. Coming from an OOP background I used to try generics too often and realized enum+traits made my code more concise and simpler. Also, about your threading model, try to minimize complexity from the beginning. 2 threads MAX. It's easier to add complexity than to remove it.
This thread https://internals.rust-lang.org/t/mrfc-rpit-auto-trait-inference/10370 proposes a potential solution to this issue. It should get more attention.
Thanks for your very constructive comment. I am following progress of Rust since 1.0, but those crate-listings slipped my radar; very helpful to pick the gems. Just AFAICS, wondering why these crate-listings are not linked from [https://www.rust-lang.org/](https://www.rust-lang.org/) neither being linked from [https://en.wikipedia.org/wiki/Rust\_(programming\_language)](https://en.wikipedia.org/wiki/Rust_(programming_language)) (?) My post is referring them now. As for my crate-list, I don't intend to create a complete list of crates for an entire ecosystem, but this is just my personal shortlist. Hopefully, this is reflected by the title?
Why do you use \`&amp;mut Vec&lt;..&gt;\` for arrays instead of \`&amp;mut \[..\]\`? The former is only necessary if you want to push to the vector, it adds an extra indirection and prevents you from using \`Box&lt;\[..\]&gt;\` or \`\[..; N\]\` or any other buffer as your backing storage.
Disclaimer: I am still very much a rust beginner. &amp;#x200B; &gt;Many times I had this feeling of: "*how was I supposed to know about this?*". Maybe half of the times the answer was "*read the book again, paying more attention this time*", but I definitely had this sensation that I knew what I wanted to do, but there was a large amount of implicit knowledge I didn't have and wasn't easily discoverable. I don't want to bash on the official rust book, but I had much the same experience. I did write a comment about this comment a long time ago about some books I liked: [https://www.reddit.com/r/rust/comments/9zs6ra/what\_are\_the\_main\_challenges\_when\_switching\_to/eac3fzb](https://www.reddit.com/r/rust/comments/9zs6ra/what_are_the_main_challenges_when_switching_to/eac3fzb?utm_source=share&amp;utm_medium=web2x) Even with the resources in my link, it probably won't explain the "You can get stuck sometimes if you try to use programming patterns you might commonly use in other languages" (which another user has already somewhat described). I feel like there should be a chapter of the official rust book which should cover just that, as it's what most people will try when writing their first program in Rust - using patterns they are familiar with. They will try to use the pattern, fail in some way, then will think it's their lack of understanding of the language, rather than perhaps the pattern they tried to use (or the way the pattern is implemented). &amp;#x200B; &gt;It might have been irresponsible, but I wrote the code as I imagined it would be. One thing you can try is to write the code as simply as possible - no advanced language features, no performance optimizations (just copy everything/minimize mutability). As you feel comfortable you can then try to port in the advanced language features. To "feel comfortable", you might have to practice/play around on some separate, test programs, which are used just for learning the feature, to isolate sources of confusion. I do think in this case you tried to do too much at once...certainly I would have been confused trying what you did with just a week and a half of rust.
nice!
I tried to reproduce it [here](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=d7716442bd1bc5acf3d45d0b889f0a45) but couldn't. Could you expand on that?
nice! can't wait to test it in firefox/pathfinder!
With rust, it’s like the puzzle of programming is not about getting the compiler to understand what you want to do, but rather, it’s about doing things in a way that fits naturally within the constraints.
if you wanted to establish yourself as solid at rust, contributing to the compiler would be a good way.
That’s because you made `test` variable `Copy` (so `drop(test)` doesn’t really drop it). Change it to eg. `let test = Struct;`, so that `test` realy gets dropped.
Because integers are `Copy`, `drop(test)` is no-op. Change the type to a non-`Copy` type to reproduce [here](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=bc94b4d5e73714fc4d117e816643b625).
I hope you are using the release version with optimizations :')
Rust is difficult to learn, and it will take you months before you start to feel like you are somewhat productive and not constantly searching for solutions to "stuck".
Hi &amp;#x200B; \&gt; rustc -V rustc 1.35.0 (3c235d560 2019-05-20) &amp;#x200B; Using the string method Split\_off I can crash the program. The problem seems to be that split\_off cannot handle UTF8 characters as it works on bytes not whole characters. Which can be a problem if a user inputs one. Is there a way to recover from spiting a UTF8 character in half? &amp;#x200B; Thanks &amp;#x200B; fn main() { // This will split off the first 10 chars as expected let mut test\_string1=String::from("1234567890ABCDEFGHIJ"); let rest1=test\_string1.split\_off(10); println!("Split\_off 10 &gt;{}&lt; ",test\_string1); // Split\_off 10 &gt;1234567890&lt; &amp;#x200B; // because ☺ is not a 1 byte character the results are a little different // we only get 8 characters let mut test\_string2=String::from("☺234567890ABCDEFGHI☺"); let rest2=test\_string2.split\_off(10); println!("Split\_off 10 &gt;{}&lt;",test\_string2); // Split\_off 10 &gt;☺2345678&lt; &amp;#x200B; // because ☺ is not a 1 byte character split will crash the system. Error below let mut test\_string2=String::from("☺☺☺☺☺☺☺☺☺☺☺☺☺☺☺☺☺☺☺☺☺☺☺☺"); let rest2=test\_string2.split\_off(10); println!("Split\_off 10 &gt;{}&lt;",test\_string2); &amp;#x200B; // thread 'main' panicked at 'assertion failed: self.is\_char\_boundary(at)', src/liballoc/string.rs:1425:9 // note: Run with \`RUST\_BACKTRACE=1\` environment variable to display a backtrace. }
I think I've understood what's going on, but... why is that bad? Genuine question, I often read things like "something leaks" through the abstraction and most of the times I can sort of grasp why you wouldn't want that, but not here.
I don't know how seasoned a progammer you are, but you let a lot of hard (albeit fun in their technicalities) constraints in your design. The thing is, if you don't understand each little bricks you use, it's very likely that things won't turn right, and with rust, you hit that wall strait aways, where another more indulgent language will walk you slowly to that wall. With 15 years experience, I did a few thousands lines of ambitious rust project (handlebars parser and expension) in the pre 1 era, it cames with it difficulties, but I've been doing 3 years of JS/front/node stuff since, and JS actually feels harder, because I never know which assomption will fail on me, because the so called indulgence is actually hidden complexity that will bite hard at the worst time. I'm not even mentioning the tech and community incredible low standards. The thing is, if something's hard in rust, the stuff you're trying to do is likely to be hard anyways, and rust helps you navigating this, instead of hide the impasse you're going into.
It has no relationship with firefox, and you can test it pathfinder already.
Great r/lostRedditors
As you realized, this happens because chars != bytes, and split_off works on bytes. If you want to split the string at the 10th character, you first need to find the index: let index_10 = test_string1.char_indices().nth(10).map(|(index, _character)| index); `index_10` will be an `Option&lt;usize&gt;` containing the index, or `None` if the string has less than 10 characters. Note that this operation is relatively expensive, as it must parse the string looking for multi-byte characters.
certainly better than people looking for /r/playrust
Wait, was that 1000s-in-1s result from Rust running via WebAssembly, or natively? Either way it's impressive but if that's wasm, wow, sounds like it's come a long way.
As I don't know the rust _game_, I can't really tell if that post was linked to the game or not
Yeah going to a bootcamp is a great way to jump start the process. I and a number of my coworkers and friends have done the same. As for the hate on JS, don't believe it. It's bullshit. JS and Python are the two languages fighting for supremacy right now in terms of usage and job availability. Some people who come from a strictly typed language like C might balk at JS but it's probably because they don't know enough about the language to make a real judgement. It's really nice to work with and has a strong ecosystem like Python where every library you might need already exists to make building things easier. JS, Python, and Ruby are all fine languages to learn. I suggest doing a job search for "(language) developer" and see the number of results that show up near you with these vs. Rust or Go. Getting your first job is a numbers game and you can weight it in your favor by learning something that is in demand. Rust is so new and used by few companies (though it seems to be growing) but I personally advise against choosing it as your first language if you want to be able to work professionally in a short timeframe. As for starting with Go and moving to Rust, you are thinking way too far ahead. A lot of the people answering in this subreddit are experienced programmers giving you advice as if you are at a similar level I think. Which is all good advice but maybe not if you don't understand the basics yet. As someone without experience, you should pick a single language first and learn it like the back of your hand. Build all kinds of stuff in it. Understand its quirks, etc. Once you do that, then you can branch out based on what you intend to program. But I would initially not try to go too far afield because what will happen is you'll just be a crappy programmer in multiple languages instead of a decent programmer in one language.
You shouldn't need binary crates to get code completion in this case.
I think it's a reference to some in-game content. In the game, there's a \[cargo ship\]([https://rust.fandom.com/wiki/Cargo\_Ship](https://rust.fandom.com/wiki/Cargo_Ship)) that spawns intermittently, presumably with loot on board. Radiation is also an element you have to deal with in the game, so you can wear a \[hazmat suit\]([https://rust.fandom.com/wiki/Hazmat\_Suit](https://rust.fandom.com/wiki/Hazmat_Suit)) to protect against that.
Sounds like wasm to me.
&gt; sounds I see what you did there
I wrote something similar (in C++ using libSDL, not in Rust) and if I remember correctly, it had two threads: SDL's event loop in which I was able to react to keyboard and mouse events and an "audio thread" (created by SDL, too) that regularly invoked a callback of mine so that I could compute the next block of audio samples. Obviously there has to be some kind of communication between the two. And instead reaching into the audio synthesizer's internals from the main event loop, I used a kind of channel for all the events. So, in the main loop I would listen to the interesting SDL events and turn them into Synthesizer events and pushed them into the channel. The audio callback would pull out these events, process them and then generate the next block of audio samples. In my case, I only had one producer (the main event loop) and one consumer (audio callback) which is why I picked a lock-free SPSC queue for the audio events to avoid locking mutexes and such. AFAIK, this is very common among audio software.
cargo you say? I've already heard that somewhere...
wish this subreddit would have been called rustlang and not rust
Thanks I have no idea what you have written. But I am looking to learn. It looks frightfully clever. I solved it by testing for is_char_boundary(count) and then working back until I found a boundary. Then chopping there. while !string_workspace.is_char_boundary(workspace_count) { workspace_count -=1; } I still think it's a bit naughty that a standard method crashes if you use a multi byte character. It should handle it much more gracefully. The code could easily get past testing if they only use standard English and then crash in production when some user starts entering smiley faces or their name in Japanese. Thanks again
&gt;You shouldn't need binary crates to get code completion in this case. I need to use binary crate, for prevent exposing source code
Sorry that I don't have it on github, but if you want to take a look, see the [main](https://pastebin.com/2W7RdiFn), the [parameter](https://pastebin.com/FxzT6MTa) struct (unused), and inside a `wave_generators/` folder I have a [mod](https://pastebin.com/bDDiqXH2) file and a couple generators, like the [sine](https://pastebin.com/dNuwiAF0) generator. This kinda works (as in "*it makes sound*"), but only because I'm not touching generators or parameters from multiple threads. &amp;#x200B; Honestly, the main issue is that I still don't know for sure (though I understand it's *not* possible in safe rust) if I can do what I want, which is mutating an object from one thread, and only reading it from others. Consistency in reads doesn't matter much, only that the reads are proper values (as opposed to corrupted data), and that could be guaranteed with Atomic types as far as I know. Seeing the other comments and the advice about rust in general, maybe I didn't communicate this right, but that previous paragraph is the wall I hit and made me stop trying. It's not a collapse due to not knowing how to orient the design in general (at least I think I know), or problems with generics, or modules, etc. I talked about some of those and pointed out some issues with them, yes, but those are the problems I think I managed to solve already.
As far as I know Rust's support for binary crates is poor. Partly due to the fact that Rust doesn't have a stable abi so your binary crate is only guaranteed to work on the version of the compiler you used. Additionally it would appear for your experience that some of Rust's tooling doesn't play nice with binary crates. If you need to distribute an internal crate within your org you could use git or try setting up a private registry.
That though this was supposed be an analogy to how smooth the cargo build process usually runs
sorry, english is not my first nor second language. when you say let a lot of hard constraints, you mean *let in* or *let out*? I tried to do the design in the only way I know where I wouldn't be giving up performance. See my other comment answering to [moiaussi4213](https://www.reddit.com/user/moiaussi4213/), I added some extra details there.
Rust doesn't have a stable ABI, so no not really. You would have to compile the bulk of your code to a static (staticlib) or dynamic library exposing a C API (cdylib), and write a Rust API which wraps that, linking to it in the build script.
https://www.reddit.com/r/reactjs/comments/afz2c0/arithmusic_make_music_with_math/ This is his prior work in react. Should be a nice juxtaposition.
Hey OP, &amp;#x200B; Thanks for the really honest feedback on how it feels to get started. We probably need more of this! &amp;#x200B; I'll try to touch on one things folks didn't get to yet. Namely, one of the WHATs that made this hard. I can't say definitively w/o looking at code, but I think diving into multithreading was one of the primary reasons this became so complicated. &amp;#x200B; As somebody who wrote highly concurrent systems for my full time job for many years, I failed to write a basic TCP chat server as my first rust application, haha. It's just strange. The guarantees rust gives around multithreading are in that nasty place of being easier to explain than they are to actually write code around. I'm glad you found Channel, I think Channel simplifies things a lot. Even so, it has to work in tandem with some other patterns to really simplify your life. &amp;#x200B; Frequently in rust, I find myself needing to separate EVENTS and DATA MODIFICATION more than I do in any other language. Multithreading makes this doubly true. Instead of trying to update shared data, try sending channel events. &amp;#x200B; This is not perfect, but let me try to give an example using what you described. If you are reading key presses in one thread that should modify state in another, e.g. adding a sound, try turning "SPACEBAR PRESSED" into an "ADD SOUND" message over a channel. The other thread can then sychronously modify the state it owns when receiving the message. This avoids mutexes and Arc&lt;X&lt;Y&lt;Z&gt;&gt;&gt;&gt;. &amp;#x200B; Another, adjacently related multithreading pattern that's (still developing) in my head goes like this: &amp;#x200B; if there is a "read-only" thread for a piece of data, and a "writer" thread, consider "duplicating" that data across the thread using a channel to update it. &amp;#x200B; I put duplicating in quotes because frequently, and in the best cases, this data can either be removed on one side in favor of just pushing channel updates, or it will be more appropriately represented as 2 differently named variables with slightly different purposes on 2 different threads.
Can you provide background on your experience level before trying Rust? E.g. what languages you already were familiar with?
Hi! I am trying to compile this code: ```rust fn my_func&lt;'a, T&gt;() -&gt; T where T: From&lt;&amp;'a [u8]&gt;, { let a = vec![1,2,3,4]; T::from(&amp;a) } ``` This is the error I get: ```rust $ cargo run Compiling check_ref_lifetime v0.1.0 (/home/real/temp/check_ref_lifetime) error[E0597]: `a` does not live long enough --&gt; src/main.rs:7:13 | 2 | fn my_func&lt;'a, T&gt;() -&gt; T | -- lifetime `'a` defined here ... 7 | T::from(&amp;a) | --------^^- | | | | | borrowed value does not live long enough | argument requires that `a` is borrowed for `'a` 8 | } | - `a` dropped here while still borrowed ``` I think that I understand why this happens. `T` might contain a pointer to `a` after the stack frame was closed, and `a` no longer lives. Is there a way to promise the compiler that I'm actually cloning `a`, and not keeping a reference inside `T`? The workaround I thought about was to use `T: From&lt;Vec&lt;u8&gt;&gt;` instead of `T: From&lt;&amp;'a [u8]&gt;`. I was wondering is there is an alternative way. Thank you for your help!
Great explanations, thank you.
[abi\_stable](https://crates.io/crates/abi_stable) might also do the trick
&gt; Honestly, the main issue is that I still don't know for sure (though I understand it's not possible in safe rust) if I can do what I want, which is mutating an object from one thread and reading it from others without locking the threads. Disclaimer: I don't have any experience multithreading in Rust, but I have a decent amount of experience multithreading in C++. This definitely sounds like something that would need to be done in unsafe rust as it stands right now. There's no way to provide ordering guarantees, and I'm guessing safe Rust doesn't like that.
I had a similar experience but am glad I didn't give up. I started out working on something with a poorly-supported crate, when I was used to some mature packages on other languages. My biggest mistake was diving right into Futures, and starting on threads might give you a similar headache. Concepts like borrowing, needing to constantly convert my error types around instead of throwing everything in strings, and Vec vs slice vs array were all unfamiliar at first. I switched gears and wrote a Game Boy recompiler (machine code in, rust code for tetris out), and that helped tremendously. Started to understand more about why I'd care whether or not I have an owned String or a &amp;str, and got used to the Result. Now I look at the exception systems in other languages, and find Result so much simpler. My first attempt was a huge pile of \`Box\`es, and going back to my original project I was able to clean it up and get it running perfectly in an afternoon. Happily have a graphql server running on a unix socket doing async mysql queries. Replaced a PHP server that would take a minimum 300ms with calls now running in &lt;10ms. It's bananas.
While go being easier does help adoption I think the real reason go is more popular is because docker was written in go. Go had already hit 1.0 and rust had still not yet released when they started writing docker. So they went with go over Rust.They even mentioned in their 2013 presentation of why they went with go was because "go is more real than rust". Docker became hugely successful and so golang became the new buzzword. Had Rust been out in 2011 go may have ended up more like dart. Just some google language no one feels like learning.
Sorry, I could have explained it better. The key is to use the [char_indices](https://doc.rust-lang.org/nightly/std/primitive.str.html#method.char_indices) method, which allows us to iterate over the characters of a string, assigning a byte offset to each character. Here I wrote a version without using `nth` and `map`, and with many comments to help you understand what's going on: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=1db9691f55c2228db3cf08d543c569c2
A printed version of [Rust by example](https://doc.rust-lang.org/rust-by-example/) might be a good candidate.
I think it’s a reference to crates.io
Is there any way for the Rust compiler to create the `tmp` automatically and move it to sufficiently “high” scope to satisfy the lifetime?
I'm assuming they meant that you have a lot of constraints in your project requirements that are making your project generally difficult to achieve in any programming language, and safe Rust is simply having you "fail faster" and you would run into problems down the line in other languages anyway. What you seem to be trying to do (mutating an object across threads without locking) requires unsafe Rust because you, the programmer, have to enforce the invariants of thread safety yourself. And by the way, your English is great! No need to apologize.
well. at fb, their is no expectation of privacy right? manipulation IS how they get their money. Same with google. The way they see it, you owe them. ... (and now they want your money too). ANTITRUST. and corporate death (revocation of state charters). then tariffs on "foreign social media &amp; monetized advertising". HEAVY tariffs.
Yeah, I considered using channels and passing information like that (for the notes that's what I do \[added some code in another comment\]), but I felt that for tweaking parameters, keeping track of their state and sharing the info of the processor (params included, as I'd like to have them inside the processor), the message passing would become unwieldy. Admittedly, I don't have a lot of experience with message-passing concurrency, so maybe I'm wrong, but I thought sharing memory directly was more suitable in this case. I could separate parameters from the processors themselves, and that could help if I was using messages, but it wouldn't solve the issue if I was still trying to share memory. And the program structure would become somewhat unergonomic in my opinion. This was a toy, I wanted to make adding new synths and effects easy, just make a file for each one, and add to the array of synths/effects.
&gt; what I want, which is mutating an object from one thread and reading it from others without locking the threads. you very much *cannot* do this in the general case --- I hope I don't have to explain why synchronized access is important, but basically, the Rust compiler will do everything in its power to stop you from writing code which mutates an object from one thread while reading it from another. you can do it with atomics, as long as the data you're representing is/can be expressed as an integer --- see the docs for [std::sync::atomic](https://doc.rust-lang.org/std/sync/atomic/index.html). otherwise, you will have to either (a) use a locking mechanism such as a mutex, or (b) refactor your code to use a channel, like the ones in [std::sync::mpsc](https://doc.rust-lang.org/std/sync/mpsc/index.html).
I didn't realize this! And I think I'm still a little confused. It doesn't *look* like resvg has a Pathfinder backend, but you're saying Pathfinder has an resvg frontend? How do these pieces fit together?
The signature you want is `fn my_func&lt;T&gt;() -&gt; T where T: for&lt;'a&gt; From&lt;&amp;'a [u8]&gt;` - that is, `T` can be converted from a reference with any lifetime.
Thanks. If anyone can confirm or has a general idea of how one would go about implementing this in unsafe rust, that could be helpful. Is this something that could be put in a crate (even if unsafe), or would you need to implement it specifically for your use-case to avoid a relevant performance hit?
I would suggest asking in /r/playrust
It seems like the [`evc`](https://crates.io/crates/evc) crate would solve your problem.
oh ok
I have to agree. I've read the book twice. Once for the 2015 edition, once for the 2018 edition. And yet I feel frustrated, scared even, at the thought of starting a project of my own from nothing. It's exactly the things like `Vec&lt;Box&lt;dyn SoundGenerator + Send&gt;&gt;` that makes me feel I don't even know where to begin, design and get a working program done.
``` #[derive(Default)] struct Foo&lt;Q, W&gt; { q: Q, w: W, i: i32, } impl&lt;Q: Default, W: Default&gt; Foo&lt;Q, W&gt; { fn new(i: i32) -&gt; Self { Foo { i: i, ..Default::default(), } } } ```
&gt;Honestly, the main issue is that I still don't know for sure (though I understand it's *not* possible in safe rust) if I can do what I want, which is mutating an object from one thread and reading it from others without locking the threads. Immediate consistency in reads doesn't matter, only that the reads are proper values (as opposed to corrupted data), and that could be guaranteed with Atomic types as far as I know. Is that object huge or does it manage thread-local resources? I think the only way to do this in safe rust is to maintain a local copy of the object in all the user threads then every time the object is about to be used try\_read from the RwLock and update local copy on success.
F for my potential internet points
Yes this is exactly what I was referring too but I'm an idiot and posted it in the wrong subreddit.
It works! Thank you!
FWIW i gave up on learning rust twice over 6 months. On the third attempt more clicked. I am still struggling borrow checker now and then but less so. It can be extremely frustrating, but also very rewarding. I think I am understanding the issues the borrow checker is protecting me against better, and I have applied these bad coding patterns for all my career 20+ years.
Works for me too. Maybe check your browser and network configuration or CA certificates on your machine?
Moving a doc comment inside might make it more resistant to refactors as the likelihood of moving the code while keeping the doc is lowered.
I think you should ignore the performance aspect while learning. Make it work first, make it fast later.
Sounds like a lot of work. Is this even doable within a years timeframe? I don’t mind sticking to side chains and I know a few projects that are built with Rust.
How big is this object? Maybe you can make all the data in your object atomic types, although this still means you might have partial updates to only some of the atomic variables. You can't really have true atomics for anything larger than the various integer types. One way to solve this is to swap out values, by using atomics on a pointer sized integer, however this makes memory deallocation tricky, since we have no garbage collector. As far as I know, there are two solutions for this: [epochs][1] and [hazard pointers][2]. [1]: https://docs.rs/crossbeam/0.7.1/crossbeam/epoch/index.html [2]: https://docs.rs/conc/0.5.0/conc/
Second. You just need internet for 1 build of your dependencies and then it will automatically use the local cache for everything. Then you'll only need internet everytime you change a dependency. If you knew what dependencies you needs at a beginning of a project you'll only need internet that first build. I do it all the time. I create a cargo.toml file with a bunch of crates I think I'll need. Let it build on an empty main, and then I don't need internet again. I don't believe any of the tools need internet because they all work, but I do use the internet for the docs, but you can build those for m your crate's dependencies and have them locally too.
If you wanted to, you could accept \`Into&lt;T&gt;\` for the desired type. You'd lose the advantage of types by staying backwards compatible though.
It can be a semver compatibility hazard because it exposes the internal details of the method. In practice this is what you want 99% of the time, but it would be nice to be able to make more explicit guarantees especially for library authors.
[https://doc.rust-lang.org/std/sync/struct.RwLock.html](https://doc.rust-lang.org/std/sync/struct.RwLock.html)
No, that error is printed by the Operating System's dynamic linker, your application won't be executed at all if that error happens.
Pretty much the only way to do atomics of larger-than-integer types is to swap pointers using atomic pointer sized integers. There are crates for this, see my other comment.
Indeed, but for clarity, we do already have these hazards. For example, if you introduce a trait object internally but forget to add the `+Send+Sync` bounds, then it can be very easy to overlook breakage. In general, if `Send`/`Sync` is important, it's a good idea to check them on your public types in tests. It's a little crazy to do this for _every_ public type, so it unfortunately takes a bit of judgment. Hopefully rust-semverver will help here in the future.
&gt; Honestly, the main issue is that I still don't know for sure (though I understand it's *not*possible in safe rust) if I can do what I want, which is mutating an object from one thread and reading it from others without locking the threads. Immediate consistency in reads doesn't matter, only that the reads are proper values (as opposed to corrupted data), and that could be guaranteed with Atomic types as far as I know. If your object can be cloned with reasonable cost (moderate size + no thread-local resources), you may keep a local copy of it in all the user threads, wrap the original one in RwLock, try\_read from the RwLock and update on success every time the local copy is about to be used.
If I understood your problem correctly, using a library like [libloading] to load functions from the shared lib could probably solve your problem.
Rust is very hard and sometimes frustrating to get into because some of its aspects are so different from everything you've learned before. I also had days were nothing worked and I cursed the compiler, because it takes time to figure out what kind of software design works and what doesn't. I'm glad I continued because I find the language awesome, but it's definitely a bumpy journey.
It's advanced but not difficult to understand - this is why it is good.
&gt; go is more real than rust Do you know what they meant with this?
&gt; Isn't the inference happening in signatures just syntactic sugar, and not based on the body of the function at all? As far as I know, you are correct. What I am describing is what the compiler *could* do in principle. Sorry for the confusion!
I already made a comment, but I thought I'd say something more. &gt; mutating an object from one thread and reading it from others without locking the threads Please mention any language where this is possible. I can tell you how to do the same in rust.
I already addressed most of that in the original post. also discussed channels more in depth on other comments
JS is a terrible choice in general.
yep, I read your comment, it's very interesting, and I didn't know about those. I've saved the links in case I decide to try again, thanks!
Pathfinder is not an official backend. So the resvg integration is in the Pathfinder repository, not the resvg repository. Pathfinder uses the parsing, DOM, and usvg model from resvg to load SVGs. That's why I refer to resvg as the "front end".
No problem. Fundamentally, the reason you ran into so much trouble trying to figure out how to do it in rust, was because what you were trying to do something that fundamentally cannot be done. This is one of the things I think the language does very well. If you try to do something you can't, it will stop you, instead of letting you do something that looks like it works. To be fair, if you had garbage collection there would be rather easy solutions, since you can just swap pointers without thinking about cleanup.
Sorry, I have another question! So, if you make a struct and everything are atomics inside, you can use the struct like it was an atomic type itself? I would definitely break this on some fields (strings), but they would be immutable. It's a shame if I can't annotate that in any way and I'm forced to do weird things to go around that.
Facebook's new crypto currency is written in Rust. I feel that will bring a lot of attention to the language. However I have to disagree with you as I don't think it matters when the language came out. It's about the feature set it provides in the moment that makes it useful and Rust has a lot of high-level features that Go doesn't provide like Generics for instance.
You can only use them as the first argument of a function in an impl block and they correspond to `self: Self`, `self: &amp;Self`, and `self: &amp;mut Self` where `Self` is the type that the impl is for. It's just sugar.
In many languages, a 'self' parameter usually refers to the receiver of the method, which is the object that the method was called on. So, for instance: struct Foo { x: i32, } impl Foo { fn foo(&amp;self) { println!("x is {}", self.x } } fn main() { let foo = Foo { x: 3 }; foo.foo(); }
When a function takes one of those `self` variants as the first parameters, you can call it like `value.func(other, parameters)`. The difference between those is whether `value` is passed by value, shared reference, or unique reference.
If you have a struct with two atomics, then that's equivalent to two variables with an atomic in each. You can update each variable atomically, and it will work without locks, but you can't update both at once atomically. So if both atomics start out containing a 1, and you want to change both to a 2, other threads reading the values may see one atomic containing a 1 while the other contains a 2. Although note depending on the [ordering][1] you choose for your atomic operations, you can guarantee that the changes will be transferred in the same order. [1]: https://doc.rust-lang.org/std/sync/atomic/enum.Ordering.html
Yes rust was still in Beta or alpha. https://www.slideshare.net/jpetazzo/docker-and-go-why-did-we-decide-to-write-docker-in-go
&gt; I use VScode for Rust You can enable clippy support in `rust-lang.rust` by installing clippy (`rustup component add clippy`) and set `rust.clippy_preference` to either `opt-in` (so you need to annotate your crates with `#![warn(clippy)]` in your `lib.rs` or `main.rs`) or `on` (always enabled) &gt; it's weird for me to see my tests next to my code I think the same as well, that's why I have my tests in their own module under each module that needs to be tested (except for integration tests that are under the `tests` folder). I just need to declare the test module on each file and make a test file with all my tests. You don't see the tests next to your code (in the same file) but they are close if you need them. You can always "inline" modules if you want to keep stuff in one file.
Thank you.
This is the subreddit for the Rust programming language. I believe you're looking for /r/playrust
Oh I can definitely relate. I've been a programmer for twenty years, and I wrote a bunch of (simple) Rust code, I'd get frustrated all the time because the code wouldn't do what I wanted. I would struggle to write code and writing **a single line** would take around an hour before it compiled. I stuck with it for a few days, and eventually something *clicked* and things made much more sense. I can't tell you how or why, everything just fell into place. I think you'll reach that point pretty soon if you keep at it, then you will find writing code much easier.
Oh you’re right haha !
&gt; However I have to disagree with you as I don't think it matters when the language came out. I don't understand what there is to disagree with. go had 5 years to gain market share that rust didn't have. It's a physical law that something can't be used if it doesn't yet exist.
Which structure is this? How does it work? What does it do well/badly? (I am redesigning a Graph object in my project and exploring different designs)
This is almost the famous K&amp;R quote from C (I can't remember which said it, and I don't know how to spell their names :P)
&gt; I tried to do the design in the only way I know where I wouldn't be giving up performance. This is why Rust is giving you such a hard time. Writing high performance multi-threaded code with custom data structures requires understanding every little detail of the language. May I suggest getting a moderate-performance version working first? ("Make it work, make it right, make it fast.") There's a great talk from Bryan Cantrill where he describes how hard it was to get hit first program to compile, how he wrote code that seemed dumb and slow just to get something working, and then it outperformed his original optimized C code: https://youtu.be/HgtRAbE1nBM (start at 41:00)
I'm not an expert on audio, but I believe that your audio processing thread needs to be as real-time as possible, and so a lock-free queue allows it to process events when it wants to. Even for tweaking parameters. Otherwise, you need a way to change state without it being possible for the realtime thread to observe invalid state. This is so hard to do because as soon as you hit UB the compiler may do anything, like re-ordering your code or changing struct layouts, that may randomly screw you, because it is allowwd to assume the situation you have can never exist. You can end up with thing breaking between minor versions, or different optimization setting, or anything else. Message passing isn't that much effort, especially with the awesome rust enums.
Either load it dynamically as mentioned or ship a wrapper executable that checks if the system is okay before executing the actual executbale.
It also took 3 tries for me with the O'Reilly book making it permanent.
So for start you selected something which has a) multithreading b) complex user interface and perhaps few other rather complex elements. Your idea of "simple" program to write in unknown language is very different from mine. I don't think there's anything wrong neither with you nor with Rust. You just should pick up easier target. Start with single threaded application without UI that you just launch and it will do one thing and terminate. Add command line parameters. Increase complexity of what your app does *without* daring into complex jungle of multithreading or complex UI. Then start *different* app, just to try out multithreading. Start yet another app to try out complex UI. Only when you feel very comfortable with some concept try to slowly bring it into your main app. Oh, and use version control, if you don't. Just don't give up.
High level languages are just fancy ASM generators after all. (They produce binary directly, but ASM is just a one-one mapping from machine binary to text.) The function calling convention is known, so you can just wrap ASM and call it from the high level stuff. &amp;#x200B; But yeah, it looks strange.
Just finished reading through the O'Reilly book. It's really good.
Really? Cool, it's solid advice :-)
I think Ill go with this one. The dynamic library seems a bit complicated for my use case.
Thanks for explaining your problems thoroughly. It really goes help the Rust community evolve and improve things!
We may need to work on the documentation. The [Methods section](https://doc.rust-lang.org/beta/book/ch05-03-method-syntax.html) of The Book describes `self`. How did you try to search The Book for it? It doesn't look like there's an index for The Book. The Methods section of Rust By Example is the second return for a Google search on "rust self" for me.
Other languages let you brute force things in pretty much any way you want, but Rust is very restrictive in the way you can accomplish certain tasks. Which, in the end makes for robust code of course. But when you're not yet in that headspace of the compiler, it can be pretty difficult/frustrating/slow.
Emu has different syntax from Rust because Emu is a different language from Rust. It has features such unit annotation and built-in constants and functions in order to make it easier to write custom numerical compute functions in the language. Therefore, tt is neither a subset nor a superset of Rust and has semantics that are closer to OpenCL - as of now - because OpenCL is what it compiles to. You see, the reason why I started working on this was to have a user be able to write custom potential functions for a molecular dynamics simulator. Because of this, I wanted a language with simpler type system and useful features for numerical functions. There are other projects which compile Rust itself to PTX or SPIR-V. This project introduces a simpler language with features that - I hope - make it generally more useful for GPU programming, similar to how languages like Lua are embedded in C to simplify general-purpose programming.
Brian Kernighan and Dennis Ritchie, in case you want to know. :)
There's some discussion about how to distribute libraries without source [here](https://www.reddit.com/r/rust/comments/41v5v1/is_it_possible_to_create_a_proprietary_library_in/). As far as I know there haven't been any major developments on that topic since then.
Thanks 😊
Can you elaborate a bit on where you want the separation? Right now, Emu compiles source code of an OpenCL program and generates Rust functions that have in their body bunches of calls to an OpenCL binding (ocl in this case) to perform the execution on the GPU. So their are crates like ocl that do provide lower-level interface with GPU. Is this what you want? or is their some other level of separation you want?
We're working on new software engineer job listings, but we're essentially always hiring. If you're in NYC (sorry, no remote positions at this time) and you want to work with some Rustaceans/Haskellers, PM me!
You'll get better each time you try, and/or have a look at existing code. I also recommend checking out some of the Rust (live coding) videos.
Emu is still quite limited in the kinds of errors it catches at compile time. It catches errors such as incorrect number of holes, simple parsing, bad data transfer, some other things. But many run-time errors are not yet caught by Emu.
&amp;self -&gt; foo.bar() == Foo::bar(&amp;foo) self -&gt; foo.bar() == Foo::bar(foo)
I really just went with `Vec` because it was simple and it worked. There is definitely a lot of stuff that I am yet to optimize, however, and this is one of them. As you are pointing out, slices that don't get modified by an Emu function don't need to be passed in as mutable; they can be constant. There are other optimizations I want to make as well. A lot of the stuff the generated Rust functions use to run code on the GPU are instances that can be cached and re-used between function calls. This is also something I am working on
Congratulations to the team with the hundredth changelog!
There is a https://cheats.rs site with pdf at the bottom. There are also some links above the pdf link.
Also loved it. However, I do now have the print version, with is not in the Rust theme
Just white paper?
Hey! design question here. Say I have an enum and a bunch of structs. Each variant map to a struct. I want to iterate over different types depending on what enum variant I have. Something like this : ``` enum Things { A, B, C } struct X {} struct Y {} Things::A.for_each(|value| &lt;- should be inferred as X) Things::B.for_each(|value| &lt;- should be inferred as Y) Things::C.for_each(|value| &lt;- should be inferred as X) ``` Is this possible ?
Well, yeah, quite unsurprisingly 😅
Lolz
My understanding of the situation is that Rust is actually less blocked by LLVM than the article suggests. Specifically LLVM is currently capable of generating code for RISC-V, it just has to be run as a cross compiler from a different architecture. In fact, recent builds of rustc can compile for various\``riscv*-unknown-none-elf` bare metal tier 2 targets. At this point, I don't see why the process of porting the standard library couldn't proceed in parallel with any LLVM work.
If calling unwrap() on each access is the problem, you could use something like this: pub enum MustInitialize&lt;T&gt; { Initialized(T), NotInitialized, } impl&lt;T&gt; std::ops::Deref for MustInitialize&lt;T&gt; { type Target = T; fn deref(&amp;self) -&gt; &amp;T { match self { MustInitialize::Initialized(ref r) =&gt; r, MustInitialize::NotInitialized =&gt; { panic!("Whoops! Something that was supposed to have been initialized at this point, wasn't.") } } } }
Just to clarify, do you mean that each variant of the enum owns instances of a struct of a certain type, and want to iterate over these instances based on the variant?
Sorry, my example is a little vague. Use case is an internal ETL tool. \`Things\` is an enum representing the tables available, and the structs represent the columns each table are storing. The API I want should allow the consumer to specify what table should be read and return an \`Iterator&lt;T&gt;\` where T is the appropriate type : \`Table::SomeTable.for\_each(|row| /\* row should inferred, do something with it\*/)\`
Thanks for the detailed answer. I appreciate it.
Yeah, security-critical stuff is hard. I'd suggest you to focus on building on top of blockchain instead of blockchain itself to get understanding of basic concepts (transactions, Lightning Network, contracts, signatures, hashes...) from there you can proceed to more difficult things.
&gt; SQLite is great. All other Rust alternatives I could find don't allow writing from multiple processes. Can you either make one database per worker, then merge them later, or just use the file system as a poor man's database?
No problem! I enjoyed writing it, so it's a win-win :) I noticed something while I was coding today, though. This doesn't compile ``` slice.swap(0, slice.len() - 1); ``` But this does ``` slice.swap(0, { slice.len() } - 1); ``` This is because adding those brackets creates a new scope which causes the referenced to be dropped as soon as the scope ends (before the mutable reference is created). The scope just returns the actual value that was produced by the `len` call and drops all other data that was created in the scope.
I see. Would it be reasonable to break each variant of the enum into individual structs, and implement a trait such as`Table` with an `Item` associated type, and a `columns` method that returns `impl Iterator&lt;Item=Item&gt;`? This would allow for much more flexibility with the behaviours of each type of table.
I actually find Rust slower to compile than Go, I'm not sure why you think it is faster, is there any data to back this up?
This a general advice: put it on the side, do something else and sometime later, go back at it. Sometimes thinking about something else helps in creating new ideas for you to build upon. Also, maybe take a look at Monitors (concurrency model).
It is used by pathfider which will be shipped in Firefox soon.
What is the best version control system for Rust?
It's used as a demo and not as core module.
&amp;self if you're only reading self &amp;mut self if you're changing self self if you're transfering ownership of self
Good idea, it definitely doesn't have to be an enum now that I think of it. Thanks !
&gt; Partially support `include` macro. This one is huge for me, especially with bindgen-like generators.
&gt; Partially support include macro. Now if include macro invocation contains only string literal, all common code insight features (like name resolution, code completion, etc.) will work in both including and included files gif Yes! This is the first step towards dealing with the biggest issue I have - I generate code from protobuf a lot.
Okay cool! Thank you very much Kix
I'd personally say git is best for anything.
You could use libloading in the wrapper not just to check if the file exists, but if it's a valid dll too, without needing to actually use its full features.
But doesn't git have problems with Cargo.lock?
Hi, thanks for the reply. Its reassuring to hear that there are others in the community who come from a bootcamp background. I think JS will help me, especially with Solidity (in the future (so I’ve heard). I’m trying to kind of create a roadmap for myself. I hope to deal with distributes systems and build on top of existing chains (since building one from scratch seems like eternal amounts of learning required). I’ve looked at jobs and must say, GO and Rust are the harder to find ones but definitely pay more (as require more from the dev) which is understandable. I’m also open to working for free under and Rust dev that could pay me in ‘knowledge’, not that I feel I’d be able to find that sort of proposition but as for now I rather accumulate my skills further rather than try and find any job that’s easiest to get into. Do you still suggest something like JS over Rust, even if I can seek help with learning Rust?
Ayu :)
Big +1 here, this is excellent. Prior to this I was going into the targets directory and manually copy pasting the includee into the includer to get OpenGL completions.
They didn't say anything about compiling, presumably they meant faster in performance.
Sounds like you're dealing with an XY Problem where you are trying to do something you probably shouldn't, especially in Rust, and the problem isn't the language but what you're trying to do with it. I do this every time I start using a new language. I learn how to use a hammer and solve problems as if each were a nail.
I don't think there are _any_ version control systems that are better for some languages than others, so just use whatever you know (and if you don't know one yet then `git` probably has the most learning resources available).
I am implementing a binary tree, and I extracted a lot of the repeated operations into helper functions, unfortunately I had to duplicate a lot of code since I needed to have a shared ref and mut ref version for every function, for example `get_node(&amp;self)`, `get_node_mut(&amp;mut self)`, `get_parent(..)`, `get_min(..)`, `get_max(..)` and so on, each of which has basically the same code with a few mut's added in the `&amp;mut` version. Is there a way to avoid this repetition?
IDK. I never heard about it and I never experienced any troubles myself, but that doesn't say much. It's possible I guess.
I assume "faster" as in "faster to execute". Rust compilation time is a well-known problem. Although, writing performant Rust may be not as easy as it might seem. See Ashley Williams talk about introducing Rust to npm.
Oh...
TBH, I gave up multiple times with Rust before it made sense. I've also read that it's somewhat common for new Rust developers to step away in frustration while learning the ropes. But each time you bounce off the language, you learn something new. I had originally read a blog post where one developer described going through this process, which pretty much is exactly what I did; sit down for a weekend to get a project working, walk away frustrated, try again a few weeks later. I still think Rust is the hardest language I've ever tried to learn. It took me about a year of coming back to it over and over before it clicked for me. So, I guess I'm saying you _should_ quit if you're frustrated. Come back to the language when you've had some time away, then read the book again, and write some code. Eventually you'll have an 'ah-ha' moment, and it'll all fall into place.
Honestly, I'm not sure it would actually be good for writing exploits. For that kind of thing you usually need to do a lot of memory-magic, so both the type-safety and memory-safety of rust might become an obstacle.
What advantage would Rust have over C in that case?
Ideally there should be 0 `unsafe` blocks. Are they for FFI?
In my attempts to iterate over either `String` or `&amp;String` with the same iterator, I came up with this workaround: enum OwnedOrRef&lt;'a, T&gt; { Owned(T), Ref(&amp;'a T), } impl&lt;'a, T&gt; OwnedOrRef&lt;'a, T&gt; { fn value(&amp;self) -&gt; &amp;T { match *self { OwnedOrRef::Owned(ref v) =&gt; v, OwnedOrRef::Ref(v) =&gt; v, } } } fn main() { let head = vec!["a", "b", "c"] .into_iter() .map(|x| OwnedOrRef::Owned(x.to_string())); let tail = "d".to_string(); let combined: Box&lt;dyn Iterator&lt;Item=OwnedOrRef&lt;String&gt;&gt;&gt; = if tail.is_empty() { Box::new(head) } else { Box::new(head.chain(std::iter::once(OwnedOrRef::Ref(&amp;tail)))) }; combined.for_each(|x| println!("{}", x.value())); } Feels like reinventing the wheel. Is there an existing enum like that or perhaps another way to do that abstraction?
Too many abstractions, and for things that aren’t deep in memory no reason to not use python. Rust has a lot more promise on the blue team side (quickly analyze lots of data in a reliable way) and on the C2 side (write once, reliable communications on most hosts)
I really do wish some people actually commented on it. I think it's a decent idea that we could see happening, even if it would require an edition break to actually enforce. If you want to see it discussed, go to the thread and add something, whether that's exploring the benefits or in what cases it falls short. A _great_ piece of data would be for someone to explore a crate that heavily uses RPIT and see if that scheme gets auto traits right in what percent of cases. Really, it just needs to have a little discussion to keep it up and let people notice it. Or if someone says it's worth it, I could just open it on the actual RFC repo and "force" discussion.
Thanks for the explanation!
Advice: ask /r/playrust
Oh god thats the wrong community fuck me
Guys thank you for your help and suggestions. :)
&gt; I know where I wouldn't be giving up performance. Well, theres your issue. Programmer Life Pro Tip: You, as the programmer, never know what performance is. The only way to tell where your performance bottleneck is, is to measure it. Whatever you think is "slow", probably isnt. What you think is "fast", probably isnt. *measure measure measure* Modern compilers optimize a lot. Hardware has lots of odd details. The only real way to know how your program will perform, and what parts of your code are holding it back, is to measure it.
[*ayu everywhere*](https://github.com/Cldfire/ayu-rs)
Yeah it is slower to compile for sure. It has faster execution speed, which is what matters to people using the program.
I'd rephrase the last one as "if you're consuming the value of self"
"faster" never means "to compile" unless they literally say "faster to compile" Anything else is talking about the one the matters, runtime performance. Keep in mind, go compiles faster because it does next to no optimizations. It's relatively easy to compile fast when you make the code slow.
This is pretty much the [`Cow` enum in std](https://doc.rust-lang.org/std/borrow/enum.Cow.html). With it your code would be: use std::borrow::Cow; fn main() { let head = vec!["a", "b", "c"] .into_iter() .map(|x| Cow::Owned(x.to_string())); let tail = "d".to_string(); let combined: Box&lt;dyn Iterator&lt;Item=Cow&lt;str&gt;&gt;&gt; = if tail.is_empty() { Box::new(head) } else { Box::new(head.chain(std::iter::once(Cow::Borrowed(&amp;*tail)))) }; combined.for_each(|x| println!("{}", x)); }
No, Cargo.lock is meant to be checked in to git so it's fine
I'm not sure why I've been downvoted. In the work I do, compile time matters a lot more than run time performance. Quick development cycles and iteration are more important than runtime performance.
&gt;graphql server running on a unix socket doing async mysql queries How were you able to run graphql with async?
First suggestion would kind of work, but it would be much more work to implement (at that point I could also just add IPC and have a single "cache server") and considering DB synchronization is (/should be) a solved problem it feels ugly. Using the filesystem is probably the best alternative, and until a while ago I always used the file system for this kind of thing cause it's kind of beautiful in it's simplicity, but it also has problems: Firstly performance: [sqlite vs FS](https://www.sqlite.org/fasterthanfs.html), and that is much worse on e.g. BTRFS and probably even better in LMDB than sqlite. Secondly, If I used a single file for every cached object, the number of files might grow to a really large number which slows down many things (and uses up inodes), e.g. a disk usage analyzer that has to scan through the whole FS, backups that erraneously don't exclude the cache dir, etc. It would also make it harder to prune the DB (though I currently don't do that) because the cache key would have to be something like a hash of (adapter, fname, mtime, ...) so it would be harder or impossible to delete cache entries by factors such as outdated adapters or the last time the cache key was accessed.
I believe actix is not just a web library but also provides an actor framework for asynchronous operations. My understanding is is that a rocket application may use this framework to do stuff like database queries asynchronously.
I generally think.that it would be nice if impl trait could have additional conditional traits. Something like this: fn wrapper&lt;T&gt;(t: T) -&gt; impl Wrapper + (Clone if T: Clone) + (Debug if T: Debug)
I have started porting a lot of my tools from C to Rust. Bindings to your system libraries or syscalls or firmware or whatever low level interface you need to exercise require extra work especially if you want to rustify them. I don’t feel like “memory magic” is the most annoying part. It’s more work than C for sure because of the unsafe blocks and some transmutes but it’s acceptable. I’d say so far I have spent more work trying to get interfaces to other libraries I use than the actual tool’s work. If you make use of intrinsics for stuff like rdtsc, TSX, AVX, etc you can try the std::intrinsics module. I think that if you don’t have a personal interest in the language you will find this task rather boring. The advantages you will get from having a more reliable or efficient tool might get easily outweighed by the overhead of having to adapt to the lack of bindings. Working around the compiler is not likely to be your biggest problem at least for tools.
That old version didn't even generate the right sounds haha. I remade the entire front end and back end, check out the link again now for the new version!
Updated the post with the link!
I started going through violent python, but writing the exercises in rust. It wasn't for anything practical though, just wanted some practice.
I've been writing my fuzzers in Rust with good success, which I guess kind of counts but isn't really anything special. I've been working on a mutator crate for a little while targeted towards structure-aware generational fuzzing that I plan to open-source at some point in the near future. Rust's proc macros have been extremely useful here since I can just `#[derive(Mutatable)]` and implement all of the actual randomization logic for the struct with just that.
Actix web and rocket are backend frameworks (like Express.js, Django, etc) that handle http requests, database connections, template rendering, etc. Yew is a frontend framework (like react, vue) and handles dynamically updating pages, breaking pages into components, and other frontend stuff, but is WASM-based instead of JS like most frontend frameworks.
Yeah, as /u/tehdog said, maintaining something like this is way outside the responsibilities I want to tackle. Writing code that integrates with other software like this is pretty tricky, and, is honestly, an endless pit of frustration in my experience. It's _very nice_ to have, but it's just not what I want to be doing in my free time. I _try_ to be pretty discriminating with stuff that is added to ripgrep, because I want to be capable of maintaining it long-term. Adding too much stuff and complexity makes that harder. Of course, it's hard to take my efforts seriously given the number of features already in ripgrep. But such is life. As the code improves and maintenance gets cheaper, then my budget might expand.
They mysql is, but those need to spawn separate threads from juniper, unfortunately. This issue has finally started picking up steam: [https://github.com/graphql-rust/juniper/issues/2](https://github.com/graphql-rust/juniper/issues/2) So if you're inside of a single resolver in juniper, the mysql calls (or http) will all be on futures and can run concurrently without necessarily spawning a new thread. But each juniper call has its `FieldResult`, which is unfortunately as sync as it gets. My simple queries are much faster now, but it'll be amazing once futures finally gets in on that, and complex queries will scale up automatically and run as much concurrently as possible. Alas it's pretty rare that one resolver would have concurrency inside of itself, so it's not that useful of a feature I've implemented. But at least it'll be a quick update once juniper does have futures.
Awesome, thanks!
There are lots of good answers here but I have a slightly different take on one point. &gt; I knew I would only be modifying atomic types from one thread, and reading from the other. I was confident I could do that safely. But I couldn't manage to explain that to the compiler, and I ended giving up. . .if this is tricky enough that I have to go unsafe, I'd rather stay unsafe all the time but without having to explain things to the compiler I think the mismatch here is you are thinking "data races are fine for me right now" while Rust has a fundamental belief that "data races are unsafe, always". So the way to explain to the compiler that you know what you're doing and opt in to such races _is_ with `unsafe`.
Indeed it was wasm, I haven't tried running it not inside a browser yet
Ooh, that's exciting. I had previously been avoiding codegen libraries like phf but with this I'll have to try them out.
Like I said, this is just step one. It only works with static strings, not arbitrary our directories I imagine. But still.
I would imagine you can rewrite some network tools like nmap or mimikatz, but as people have mentioned, it might be too much of a hassle to write stuff like shellcode/memory-exploits directly in rust. In the other hand, you could write your payload in rust and do a hand down of execution from whatever C trickery you sent to trigger an exploit, to the core logic you want to run once you've captured control. Not exactly experienced with that kinda stuff, but I'd love to see a write-up about it if someone does pull it off!
I agree. Rust doesn’t have what it takes for exploits but has nice potential for payloads.
For exploits, probably at a disadvantage. For payloads, I could see some potential for rust.
I believe they chose it awhile ago actually.....
3+ Years experience in Rust, 5+ preferred? That is asking a lot. Perhaps 1+ year in Rust and 3/5+ in another systems language (C, C++, etc) \--- Full job text (**Remote!**) - [https://iota.bamboohr.com/jobs/view.php?id=90](https://iota.bamboohr.com/jobs/view.php?id=90) Job Description Currently, we are looking for a Senior Software Engineer to join our core Research &amp; Development Team. We are looking for a tech-savvy candidate, with broad experience in legacy back-end systems, especially with microservices &amp; native code in Rust, and who can demonstrate their ability to lead a team of engineers to work towards a common goal using agile development best practices. Job Responsibilities &amp;#x200B; * Take ownership of the technical architecture of a software project * Define the end to end process, including choosing technologies and organizing the team to implement solutions * Manage an agile development team * Work with a product owner to decide on project requirements, timelines, and team standards * Design and develop IOTA software components for PCs or embedded firmware * Integrate and improve current solutions as part of the global IF community * Participate in and help transform cutting-edge research into practical software products * Implement software development best practices and collaborate with other software projects in open source DLT space * Engage with the IOTA community Minimum Job Qualifications &amp;#x200B; * High level of fluency in spoken and written English * 3+ years of experience in Rust * Experience managing a team * Proven profile of excellency * Excellent interpersonal skills and team player * B.Sc. in Computer Science, Electrical Engineering or able to demonstrate significant relevant field experience * Experience developing complex system architectures * Self driven and motivated with passion to research and act where software and cryptography meet Preferred Job Qualifications &amp;#x200B; * 5+ years of experience in Real-Time or Embedded Systems using Rust * Previous RTOS experience (e.g. THREADX / QNX / Nucleus / VxWorks / **embed**ded Linux) * Experience designing architectures for portable, embedded systems is a plus * Proven track record in designing software algorithms and data structures is a plus
Why not `unsafe` where needed?
&gt; no reason to not use python - speed - no need to deal with numerous dependency issues
does it fix it if you wrap it in \`#\[cfg(test)\] mod foo\_tests { }\`? I'm assuming RLS is what's showing it and it may be looking for that specifically.
unfortunately not, already tried, I think it's a bug with the portion of the Test Explorer UI responsible for Rust (it's another extension specific for rust, tried to uninstall and reinstall those too)
&gt; Currently there's no dedicated syntax to loop through streams. &gt; Instead it's recommended to use a while Some loop: while Some(item) in stream.next().await { println!("{:?}", item); } Did you mean [while let][0]? As in: while let Some(item) = stream.next().await { println!("{:?}", item); } [0]: https://doc.rust-lang.org/rust-by-example/flow_control/while_let.html
So you decided to do a multi threaded real time sound mixing terminal app for a first time project learning a new language? &amp;#x200B; You were surprised this was a difficult task? First time, learn the language, programs usually don't include things like multi-threading right out of the box. Audio processing is also a known difficult area in programming. Mixing these together was probably a step too far for a first learning program. I would take a step back and try a simpler project first before thinking it was the language at fault here.
I just wanted to give a brief update. First of all, thanks for all the feedback and enthusiastic comments, they mean a lot. Really. After going through all the feedback and issues, I have now made some updates: **2019-06-18:** New chapter implementing a proper Windows support **2019-06-21:** Rather substantial change and cleanup. An issue was reported that Valgrind reported some troubles with the code and crashed. This is now fixed and there are currently no unsolved issues. In addition, the code now runs on both debug and release and builds without any issues on all platforms. Thanks to everyone for reporting issues they found. Added a paragraph about the stack layout on Linux.
You can use macros, [playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=f50551e6d1bd18575bc94df77059fe4d).
It's almost always used in one context - at the top of a file, to document a module or crate. I've never seen modules documented using `///`, and almost every public crate will use `//!` for documenting lib.rs.
Love the plugin, I've had issues using it with Rider though (creating/opening a cargo project is borked). Is IntelliJ the only supported editor or should I submit a bug report?
Go write it in python, vent some frustration and feel accomplished. Then come back and do it in Rust.
Hey, I'm just a "Iota - community" member who try to support this project by spreading this job offer. Do you have any idea where als I can post this joboffer in hope to find a potential candidate?
You can use macros, something like [this](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=deabf339f49d2acfb206a818d01c6cd9).
&gt;3+ years of experience in Rust and &gt;5+ years of experience in Real-Time or Embedded Systems **using Rust** Emphasis mine. &amp;#x200B; No problem at all. ^(/s) Especially not since the (incomplete) VxWorks Rust port was posted yesterday, so that one's right out.
I've rarely ever used memory-magic on the exploiter side, most of it happens in the exploitee's memory space and is often manipulated over a vulnerable channel like a protocol on a socket or pipe. At least, that's the type of problems that I've ever attempted. Maybe some things like modding games would be more difficult, but it might actually be feasible for some things.
In my mind it's not that Rust doesn't have what it takes, but that it was specifically designed to prevent a class of bugs that are commonly exploited. That said, you can do as much unsafe hackery as you please and Rust does have those tools.
I've actually been thinking about making an analogue to pwntools in Rust, with things like radare2/gdb support, abstract socket/pipe types, disassembly and ROP solving. It certainly won't be as ergonomic as Python is, but it will be a nice learning exercise.
&gt; I feel like there should be a chapter of the official rust book which should cover just that, as it's what most people will try when writing their first program in Rust - using patterns they are familiar with. The problem with "just 1 chapter on this topic" is that it can detract from the book's coherent text as a whole. Perhaps I'm biased as I'm writing my own book on Rust, but I think that it's good to acknowledge that it's impossible for a single resource to be suitable for everyone. I know this doesn't apply to you as your linked comment refers to another resource, but I feel that many people in /r/rust ask too much of TRPL. Maybe another way to approach the problem that experienced programmers come to Rust with their own ingrained patterns would be to implement a small utility in languages a,b,c and then implement it in idiomatic Rust. Each language could have a lengthy discussion about how common patterns apply in each case, esp. Rust v Java, Rust v C#, ...
&gt; Improve performance of marco name resolution. Only Marco? I feel left out!
Currently your code has a race condition so it can break at any moment. If Foo is just an `i16`, you can use an [atomic](https://doc.rust-lang.org/std/sync/atomic/struct.AtomicI16.html). If it isn't, you'll have to use some kind of synchronization, a [Mutex](https://doc.rust-lang.org/std/sync/struct.Mutex.html) or [RwLock](https://doc.rust-lang.org/std/sync/struct.RwLock.html) would be an easy solution.
Oh nice code and four up votes so far. So I am not the only one who appreciates it. I especially like the for (index, character) in s.char_indices() Where you use char_indices() to loop through each character and the index to provide you with the byte count. This idea of having two counters in a tuple and then breaking it out is quite a new toy for me. Thanks! (Not a macro!(Not a macro!)(...!))
Well, there is no race if one is a reader and one is a writer - right?,
You can use macros, something like [this](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=f50551e6d1bd18575bc94df77059fe4d) for example.
I think you chose a great spot!
From the [Rust book](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#mutable-references): &gt;A *data race* \[...\] happens when these three behaviors occur: &gt; &gt; &gt; &gt;Two or more pointers access the same data at the same time. &gt; &gt;At least one of the pointers is being used to write to the data. &gt; &gt;There’s no mechanism being used to synchronize access to the data.
Yes, there's plenty. Most of my projects are both rust and tooling for offensive(-ish) security: [https://github.com/kpcyrd/sn0int](https://github.com/kpcyrd/sn0int) \- the project I spent most of my recent time on, I wasn't fully satisfied with other recon tools and I had some opinions so I started to write my own [https://github.com/kpcyrd/sniffglue](https://github.com/kpcyrd/sniffglue) \- I used tcpdump a lot but thought the output could be a bit friendlier, also wireshark has vulnerabilities quite frequently and tcpdump occasionally has some too [https://github.com/kpcyrd/boxxy-rs](https://github.com/kpcyrd/boxxy-rs) \- this is the closest to actual exploit development I have, I got into an argument with a friend about my sandboxing work in sniffglue and ended up writing a shell that can be compiled into other projects so you can inspect the process/sandbox from the inside. It has some features that other comments claimed would be hard, like executing shell code. [https://github.com/kpcyrd/badtouch](https://github.com/kpcyrd/badtouch) \- this is basically a bruteforce framework and rust is used to abstract concurrency and other boilerplate. During one assessment I could max out an aws outscaling group with this. [https://github.com/kpcyrd/rshijack](https://github.com/kpcyrd/rshijack) \- a rust rewrite of a C tool to hijack tcp connections and I later added additional features [https://github.com/kpcyrd/burritun](https://github.com/kpcyrd/burritun) \- this was a one-of to get a tool to work over openvpn that couldn't deal with tun devices on its own [https://github.com/kpcyrd/progpick](https://github.com/kpcyrd/progpick) \- nothing too exciting, but generates permutations in case you forgot some details in a password In the CTF space: [https://github.com/kpcyrd/defcon26-pow](https://github.com/kpcyrd/defcon26-pow) \- the original script was in single threaded python so I ended up rewriting it in multi-threaded rust, which allowed our team to enter almost every challenge instantly. One of the exploits I wrote for the hitb 2019 ctf is also in rust but I haven't uploaded it to github yet. There's also work by other people, like [https://github.com/Gymmasssorla/anevicon](https://github.com/Gymmasssorla/anevicon) by [u/Gymmasssorla](https://www.reddit.com/user/Gymmasssorla/).
contributing to the compiler ? WOW that's way far from my current knowledge. im just a beginner in Rust, how can i contribute?
I think purely from an ease of getting a job standpoint and ease of learning to program without prior knowledge, I would learn JS first, or python, or ruby etc. That's not to say you can't learn rust in your free time but I think you'll have a hard time finding an entry level job with rust and an even harder time learning it as a beginner. I don't recall ever seeing a junior rust developer position and normal rust jobs aren't plentiful at the moment. So just my opinion though. Ultimately it's up to you
Cargo.lock should not be checked in for libs.
Note that unlike the url "https://bitbucket.org/blog/why-rust" may imply, this is not an official post by bitbucket.
Or rather: Trying to do something in a difficult way.
Rust makes you wrap it in unsafe because it's unsafe. Even in this situation, the read and write can happen at the same time and the read takes part of the data from the old value and the rest from the new. On a simple system, that's all you'd need to worry about, but when caching comes into play, you're no longer working with direct memory and more so the conceptual storage slot. The thread reading has no reason to believe the value's been changed and will just reuse the old value it already had. The thread writing has no reason to believe the value is being read and may not synchronize the changes to a shared cache.
The community has a "mentoring" program for new contributors, meaning a more skilled member will be available to help you if you have questions. Search for the tag `E-mentor` to find issues that are offering this option. For some reference material regarding the compiler itself, the [rustc guide](https://rust-lang.github.io/rustc-guide/) is a good place to start.
UTXO is very inconvenient. It's like throwaway accounts that can be used once.
Out of curiosity, how come Go was not considered? It would seem to fit the criteria better than some of the other languages that was evaluated.
Thanks for pointing this out! I used to have my code in the first case which causes a big crash in my program. It's very easy to make the first scenario mistake because an Option is also iterable!
The lifetime of `c` is determined when you create it, by the signature of `Holder::new` (`&amp;'a str -&gt; Holder&lt;'a&gt;`). Calling `change_ref` does not change that lifetime. What you can do instead is implement `change_ref` like this: fn change_ref(mut self, other: &amp;'a str) -&gt; Holder&lt;'a&gt; { self.some = other; self } [Playground example](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;code=struct%20Holder%3C'a%3E%20%7B%0A%20%20%20%20some%3A%20%26'a%20str%2C%0A%20%20%20%20other_stuff%3A%20i32%2C%0A%7D%0A%0Aimpl%3C'a%3E%20Holder%3C'a%3E%20%7B%0A%20%20%20%20fn%20new(some%3A%20%26'a%20str%2C%20other_stuff%3A%20i32\)%20-%3E%20Holder%3C'a%3E%20%7B%0A%20%20%20%20%20%20%20%20Holder%20%7B%20some%2C%20other_stuff%20%7D%0A%20%20%20%20%7D%0A%20%0A%20%20%20%20fn%20change_ref%3C'b%3E(mut%20self%2C%20other%3A%20%26'b%20str\)%20-%3E%20Holder%3C'b%3E%20%7B%0A%20%20%20%20%20%20%20%20let%20Holder%7B%20other_stuff%2C%20..%20%7D%20%3D%20self%3B%0A%20%20%20%20%20%20%20%20Holder%3A%3Anew(other%2C%20other_stuff\)%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20fn%20print(%26self\)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%20number%20%7B%7D%22%2C%20self.some%2C%20self.other_stuff\)%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main(\)%20%7B%0A%20%20%20%20let%20mut%20b%20%3D%20String%3A%3Afrom(%22hello%22\)%3B%0A%20%20%20%20let%20mut%20c%20%3D%20Holder%3A%3Anew(%26b%2C%201\)%3B%0A%20%20%20%20let%20mut%20e%20%3D%20String%3A%3Afrom(%22bye%22\)%3B%0A%20%20%20%20%0A%20%20%20%20c%20%3D%20c.change_ref(%26e\)%3B%0A%20%20%20%20b.clear(\)%3B%20%2F%2Fthis%20line%20doesnt%20work%20%0A%20%20%20%20c.print(\)%3B%20%0A%20%20%20%20%20%20%20%0A%7D)
Hey /u/est, /u/Shnatsel, /u/oconnor663, and /u/gngeorgiev, wanted to let you know that version 2.0 is up with a save dialog (so you can decrypt to ramdisk) and no Encrypt/Decrypt buttons (detects .cloaker extension and falls back to byte signature). Also ditched the MFC GUI for statically-compiled Qt on Windows. Thanks for the feedback.
If you only have two threads, you can use a channel to create it in one thread and send it to the other thread (if it's `Send`, which most things are).
That reminds me... I still have to open an issue to merge (or at least ask about) the book and docs.rs theming engines. I know the book uses [mdBook]( https://github.com/rust-lang-nursery/mdBook) and docs.rs uses [rustdoc]( https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html) but it drives me crazy needing Stylus for one, dark available on the other. Idk. I want Ayu on _all_ my Rust docs. Or at least the same selection available.
You're right that there's no simple way to do what you're trying to do. The lifetime `'a` is conceptually part of the _type_ of `Holder`, and you can't change the type of something by calling a method on it. Here are a few options off the top of my head: - You could have `change_ref` return the previous contents. That won't help you if you're storing `&amp;str`, but if you switch to storing `&amp;mut String`, you could use the reference returned by `change_ref` to accomplish the `clear`. - You could use `RefCell&lt;String&gt;` and have the `Holder` store `Ref&lt;String&gt;`. Then `b.borrow_mut().clear()` will compile, and if you forget to `change_ref` then it'll lead to a runtime panic. - You could use `Rc&lt;String&gt;` and then try to get the string back out afterwards with `get_mut` or `try_unwrap`, which will again fail at runtime if you forget to `change_ref`. All of these options are a little bit awkward, though. My instinct is that there's probably some refactoring that avoids all of these workarounds, but without knowing more about your problem it's hard to say.
Not even Haskell can do this (yet), which remains one of the main reasons I prefer Rust over Haskell. The fact that Rust is the only mainstream* language with linear or affine types is something that bothers me and makes it hard to go back to pretty much any other language. *There are some more obscure languages like ATS, but they tend to not get as much attention for various reasons.
Wondered the same. If it’s cloud native, you’re usually going to get great bang-for-the-buck with golang. Unless you’re Cloudflare, rust is often overkill.
&gt; This is important, because once async is allowed in traits directly, it seems like it would be possible to simplify the traits significantly. pub trait AsyncRead { async fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; io::Result&lt;usize&gt;; } IIUC, async trait fns must be heap allocated? That doesn't seem great for such a central trait.
ah! okay thanks
As another commenter mentioned, const generics arent stabilized yet, meaning different tensor sizes are either handcoded individually or generated with macros if they are type checked. Either way, if you want to use or implement an unsafe function like `get_unchecked` (which is pretty common for optimization), it is going to be replicated for every generated type.
They don't need to be heap allocated- the return type will be an associated type of the trait.
Sorry, offtopic: what highlighting scheme are you using? It looks great. Similar to gruvbox.
It doesn't necessarily have to be part of the book, just there as part of your "Rust Starter Kit"? Or as part of a "secondary" learning material, similar to Haskell's "Learn You a Haskell for Great Good!" I guess, even though I explicitly said "an extra chapter", I really just mean "make sure rust beginners get this information into their heads somehow".
Love the title!
I'm trying to open a .txt file, loop over each line, split by whitespace, collect it into a vector and then \*do something\* with it but am at loggerheads with the borrow checker and can't quite figure out why. The code: use std::io::prelude::*; use std::fs::File; use std::io::BufReader; use std::io::Result as ioResult; pub fn parse_log(log_path: &amp;str) -&gt; ioResult&lt;()&gt; { let log = File::open(log_path)?; let mut values: Vec&lt;&amp;str&gt; = Vec::new(); for line in BufReader::new(log).lines() { if let Ok(row) = line { let v: Vec&lt;&amp;str&gt; = row.split(",").collect(); values.extend(v); } println!("{:?}", values[0]); } Ok(()) } The compiler complains about \`row\` not living long enough: 12 | let v: Vec&lt;&amp;str&gt; = row.split(",").collect(); | ^^^ borrowed value does not live long enough 13 | values.extend(v); 14 | } | - `row` dropped here while still borrowed 15 | println!("{:?}", values[0]); | ------ borrow later used here How do I make row live long enough to be used each loop or how do I recreate it on each iteration?
&gt;lmao thanks
&gt; We needed a language that was fast enough to allow minimum real-time latency and use limited resources of a SoC device. Maybe they're running on some odd architecture that Go doesn't support? https://github.com/golang/go/wiki/MinimumRequirements https://doc.rust-lang.org/nightly/nightly-rustc/rustc_target/spec/index.html#modules Hard to imagine what it could be, though. Both languages are pretty narrow compared to C's support.
Although I did say "there should be a chapter of the official rust book", I guess I more mean that "beginners should have this information shoved in their heads somehow". On the [current "Learn Rust" page](https://www.rust-lang.org/learn), the only other beginner friendly document is the "Rust by Example" document, and the rustlings course, and I don't think they cover what I was describing. I think what you described in your last paragraph would be a very useful document. You probably would not even need to cover that many languages, just enough examples to get the point across.
thanks dude. Also thats one helluva long playground link
I knew it had somethin' to do with smart pointer, I'll look more into it, thanks a lot man!
I prefer to put the code in the link when it's small enough to fit. That way as long as the comment's text remains you can get the code from it, even if Gist or the Rust Playground site stops working.
Not OP but after writing a bunch of Go, we've started moving to Rust at work because Go is missing algebraic data types which I now consider a critical feature of any programming language and because I don't want to have to worry about dangling pointers which although an infrequent issue is still something I don't want to have to think about. Also what you get out of the box with libraries like Rocket is amazing.
And if you want multiple-consumer broadcast channels there are crates out there for that. The `multiqueue` crate looks promising, although I have not tried it.
Worth noting that for non-String types, [`maybe_owned::MaybeOwned`](https://docs.rs/maybe-owned/0.3/maybe_owned/enum.MaybeOwned.html) is a `T` or `&amp;T` type. (whereas Cow is always `&amp;T` and `T::Owned`).
https://micropython.org/
Which pretty much just means that the thing you're impl-ing won't be available after you run the impl anymore, right?
I'm curious about these benchmark numbers. What was being measured? The "source" link is just a link to an article about rust. I always think it's interesting when someone say C or C++ is faster or slower than rust. With enough work, you can almost always make them compile to the same machine code, right?
Rust's architecture support is rather limited as well, but maybe they’re lucky.
You're collecting references, but the thing you're referencing (`row`) only lasts until the end of an iteration of the loop. You'll either need to read the file into a string as a whole and reference that, or collect into a `Vec&lt;String&gt;` like ``` let mut values: Vec&lt;String&gt; = Vec::new(); for line in BufReader::new(log).lines().filter_map(Result::ok) { let v = row.split(",").map(str::to_string); values.extend(v); } ```
I guess the obvious way to do this is: use std::io::prelude::*; use std::fs::File; use std::io::BufReader; use std::io::Result as ioResult; pub fn parse_log(log_path: &amp;str) -&gt; ioResult&lt;()&gt; { let log = File::open(log_path)?; for line in BufReader::new(log).lines() { if let Ok(row) = line { let values: Vec&lt;&amp;str&gt; = row.split(",").collect(); // Do things println!("{:?}", values[0]); } } Ok(()) } and just do the things within the \`if let\` block. I'm still curious if there's some way to tell Rust to drop and recreate the \`row\` variable each iteration.
I think it's worth emphasizing that these sorts of tricks aren't usually necessary. There's usually a way to refactor things so that it works naturally. But that can be hard to figure out until you have more experience with the language.
Unless you're implementing methods for a Copy type, running a method which takes self by value will cause that value to be dropped unless you return the value from the method.
&gt; 3+ years of experience in Rust Big ask for such a young language
&gt; I knew I would only be modifying atomic types from one thread, and reading from the other. I was confident I could do that safely. This is definitely possible. Maybe you needed to wrap the atomic in Arc? One word of caution would be to trust your instincts a bit less than usual in this particular realm. Overall, sounds like you went big on your first time out, haha! I have a feeling you'll be back. Next time, a triple buffer might be what you're after.
If something is `Send` would it show up here under the trait implementations? [https://ws-rs.org/docs](https://ws-rs.org/docs)
I'm not sure. If you look at the standard library docs, it always shows up. For example, look at the docs for [`std::rc::Rc`](https://doc.rust-lang.org/std/rc/struct.Rc.html#impl-Send), which cannot safely be moved between threads, and see the `!Send` listed under its trait implementations. Compare that to [`std::sync::Arc`](https://doc.rust-lang.org/std/sync/struct.Arc.html#impl-Send), which explicitly implements `Send`, and [`std::vec::Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html#synthetic-implementations), where it shows up as being automatically implemented. In those docs, it isn't mentioned at all. You could always try passing it to a function that requires `Send` and seeing if it compiles.
I think CLion gives the best experience for Rust from what I've read.
There is an impl of [`FromIterator`](https://doc.rust-lang.org/std/iter/trait.FromIterator.html) which lets you collect a `Result&lt;V, E&gt;` from an iterator over `Result&lt;A, E&gt;`s if you can collect a `V` from an iterator over `A`s. It &gt; Takes each element in the `Iterator`: if it is an `Err`, no further elements are taken, and the `Err` is returned. Should no `Err` occur, a container with the values of each `Result` is returned. So you collect a `Result&lt;Vec&lt;i32&gt;, DivisionError&gt;` with division_results.collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()
Great blog! This is one of my favorite patterns in Rust. I love the idea of encoding more API information at the type level. The more invariants we're able to encode in APIs the better, instead of text in the documentation saying "warning calling method X before initialization will cause a panic". Compile-time checked APIs FTW. &amp;#x200B; I'm most familiar with the "state type parameter" pattern. I have been wondering, once const generics land, will we be able to implement this pattern using const generics? Something like (syntax might be slightly off): struct MyType&lt;const STATE: PossibleStates&gt; { // Fields } enum PossibleStates { First , Second } impl MyType&lt;First&gt; { // methods } impl MyType&lt;Second&gt; { } This way, the enum variants represent the states, and `const STATE: PossibleStates` serve the same purpose as the trait bound in the blog example: ensuring the user doesn't use arbitrary types `T` in `MyType&lt;T&gt;` .
Sorry, a bit off topic: I've been trying, as a vim user, to give intellij a serious go because the type inference/suggestion/completion is great. I have spent a significant amount of time failing to replicate one of my core strategies for navigating vim, moving to the left/right/up/down split with ctrl hjkl and to the left/right tab with H/L. Intellij significantly hampers this because a split can have multiple tabs (instead of how I use tabs, as a split context), but does anyone have tips on quickly jumping between files/splits? I wouldn't have thought it'd be this hard! The settings are like in 10 places.
Can you explain `algebraic data types`? Is it just a tagged union aka variant, etc.. or is there more to it?
My team provisions compute clusters for machine learning experiments. This sounds like it could be awesome for unit testing our highly dynamic EC2 "User Data" (instance initialization scripts)
https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.collect You need to click on the [-] on the left to expand the function documentation.
&gt; Problem is, that LPARAM type (type of lParam argument) is alias for isize, and I cannot safely cast between it and raw pointer. fn main() { println!("{:p}", isize_to_ptr(60)); println!("{}", ptr_to_isize(&amp;0)); } fn isize_to_ptr(i: isize) -&gt; *const u8 { i as *const u8 } fn ptr_to_isize(p: *const u8) -&gt; isize { p as isize }
&gt; you’re usually going to get great bang-for-the-buck with golang Can you elaborate on that a bit more? What makes golang better bang for buck here over rust? Is it to do with the language features/productivity(write code faster) or the ecosystem(library/community support) for this space?
&gt; Maybe they're running on some odd architecture that Go doesn't support? It could also be a low end x86 or arm platform that's memory constrained. GC'd languages tend to spend a lot of time performing GC instead of doing work when you're memory constrained and trying to move a lot of data around.
[This](https://en.wikipedia.org/wiki/Algebraic_data_type) article does a good job explaining it. I'm not familiar with that terminology but it may be the same thing. Basically I would just describe them as enums with parameters.
Huh, that works. But I swear I got an error on that conversion yesterday. Will report back as soon as I get home. Anyway, even if my question lost its practical side, I very much interested in pitfalls around raw pointers transmutations. Thanks!
Having some trouble with the site on my phone, but my guess is it’s referring to a section in the the docstring for `collect`, and specifically lines [1362-1364](https://doc.rust-lang.org/stable/src/core/iter/traits/iterator.rs.html#1362-1364) about how a collection of Result can be converted into a single Result using Iterator.collect.
Some comments: &gt; But the key difference is that AsyncRead yields unparsed data. While Stream yields parsed data. Don't think it has anything to do with parsing. AsyncRead/Write are **byte** streams, and operate on borrowed data. Whereas `Stream/Sink` represents Object streams, and operate on owned data. One could model a byte stream as `Stream&lt;u8&gt;`, but that would be very inefficient since only a single byte can be transmitted at a time. Regarding parsing: A byte stream can yield the bytes from a raw socket or file. In that case there is no parsing involved. However it could also yield the bytes inside a HTTP/2 substream, a TLS stream or other encodings. In those cases parsing already happens before the byte stream can provide data. &gt; Sink doesn't bring anything to the table that can't be solved more elegantly and with less ceremony using the 3 standard stream traits. So save yourself some trouble, and don't bother with Sink. That seems wrong. `Sink` is the counterpart of `Stream` and can't be replaced by any of the other traits. The complexity has it's reasons - the whole Stream/Sink design is built around `poll_` function for waiting and nonblocking functions for performing actions. The same is required here in order to enable backpressure. &gt; Its raison d'être is to be a typed counterpart to AsyncWrite. It usually wraps a writer in its constructor, and then serializes types into it. No, that's one special case. Something like a channel is a `Stream` and a `Sink` for objects and has nothing to do with bytes. &gt; In principle the stream traits don't have anything async about them. The only reason why they're async is because they return futures They don't return `Future`s, instead they are more like a sibling to `Future`s (as mentioned earlier in the article). That unfortunately makes their implementation incompatible with `Future`s and `async fn` as described [here](https://gist.github.com/Matthias247/5e5e7430149bbb04eebf18cf31747fe0). &gt; This would be particularly nice because it would mean AsyncRead, AsyncWrite and Stream would be defined the exact same way as std Read, Write, and Iterator with the only difference being the async keyword in front of the methods. There is an already pretty old [issue on futures-rs](https://github.com/rust-lang-nursery/futures-rs/issues/1365) around this. Unfortunately there hasn't caught too much traction.
I agree. Treating data as resources that can be consumed (moved) makes so much sense. I hope one day I can add a constraint to a type or value like "this value must be used/consumed". I think this another side of the coin for linear types?
You can cast from raw pointer to isize in safe code. https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c7cf32fb25f1f50b9c753795b233c94f
I didn’t catch the SoC hardware. Go is certainly not ideal for embedded work.
Especially if it can cause crashes, is this worth a \`clippy\` lint you think?
Is there something wrong with my compiler/Cargo installation? It's taking an average of ~10 seconds to compile "hello world" for me. ``` $ cargo new hello $ cd hello $ cargo build Finished dev [unoptimized + debuginfo] target(s) in 10.31s $ cargo build Finished dev [unoptimized + debuginfo] target(s) in 10.23s $ cargo build Finished dev [unoptimized + debuginfo] target(s) in 10.64s $ cat src/main.rs fn main() { println!("Hello, world!"); } ```
\`Clippy\`-ize it would be a good idea given that people seldom use \`while\` to unpack an Option (correct me if I'm wrong).
What platform are you running on? Asking because there can definitely be issues with cargo and rustup running slowly with antivirus software on Windows. If you are on Windows, it might be worth looking into https://github.com/rust-lang/cargo/issues/5028 and https://github.com/rust-lang/rustup.rs/issues/1540.
Sums and products. Sum types and product types are what you need in order to have algebraic types. And despite the names, there both probably pretty familiar concepts to most programmers. We have product types in most languages, by names like `struct`s, `class`es, tuples. The idea is to combine two or more types `a` and `b` into a third type `a * b`, where the number of inhabitants of the resulting type is the product of the number of inhabitants of the two components. (E.g., `bool * int32` would have 2^33 inhabitants.) In practice, this means your struct must have an `a` and a `b`. Sums are the same idea, but you want the result type to have `a + b` number of inhabitants. In practice this means having an `a`, or a `b` (and you have to be able to tell which it is, unlike with C's union type). For example, rust's `Option&lt;T&gt;` is a type with `1 + T` inhabitants, because it can either be a `None` or any `T` value. Rust's `Result&lt;T, E&gt;` is a type with `T + E` inhabitants, following similar reasoning.
I think we would still need Enum Variant Types to do that. [https://github.com/rust-lang/rfcs/pull/2593](https://github.com/rust-lang/rfcs/pull/2593)
Ah, makes sense, thanks!
I always like something that's not just a `#FFF` background. (I tend to prefer something like `#fff8f1` to silvers/smokes, though.)
Especially for rustc vs clang, they both use LLVM so you can generally just write the C in `unsafe` Rust and get exactly the same output. That said, there are still interesting differences in conventions, and thus how code comes out "by default", like the interesting intrusive-AVL-tree vs external-Btree example in &lt;http://dtrace.org/blogs/bmc/2018/09/28/the-relative-performance-of-c-and-rust/&gt;.
Why do people do things like this? Even when it pops into my head "heh, that would be cute", it's immediately followed by, "Wow, that would be really annoying and perpetually confusing". Oh the arrogance.
&gt;If it’s cloud native, you’re usually going to get great bang-for-the-buck with golang. What a fuckin load of hogwash. I've seen so much (1) shit code, (2) shit Go code, (3) Go code that is shit purely because it is Go. K8s is LITTERED with tens of thousands of lines of auto-generated bullshit because of Go's limitations. They wrote a fucking multi-tiered build system in Bash and Go to build the damn thing. Most CNCF projects are good examples of the fact that Go is productive because of the people writing it and the crappy alternatives that came before it. Not because it's particularly good language for writing microservices in.
What are you comparing against? Not every platform is available "out of the box" or with the same level of support, but Rust can be compiled to any architecture LLVM targets (though there are known issues for some targets, which is why e.g. the AVR fork hasn't been upstreamed into the Rust mainline yet).
One comment regarding the Sink trait: &gt; Oh and also a mandatory internal buffer. I'm pretty sure no buffer is required. A buffer used to be required with the old trait, when `send()` could backpressure and return the item you tried to send. With that version of the `Sink` trait, there was no way to know if a send would succeed without simply attempting one, so you'd need to poll an item from your stream to use in the attempt. If the attempt failed, you'd have an item you now needed to buffer somewhere. With the new `Sink` trait, that's no longer a problem, because you just call `sink.poll_ready()` before polling your stream. If it returns ready, `start_send(item)` is guaranteed to not backpressure, so you don't need to have a buffer at all.
Where do you work?
Python’s standard lib is huge compared to other languages and tbh I haven’t faced a dependency issue yet.
I went through the same experience that you did and coincidentally, I took on the challenge of audio programming. I had to deal with threads and lock free queues from the get go. I offered myself a very challenging task and was frustrated for weeks. &amp;#x200B; Eventually, things started to click. The rules around Rust's Ownership system started to become "natural". As in, I would automatically reason about them without thinking about them, while writing the code. It was like driving a car for miles then suddenly coming to and you cant remember what the last 5 mins of the drive was. You were on autopilot. &amp;#x200B; The type system is the most powerful and complex that I've ever used. At first, the sheer complexity and the combinatorics of the many different ways to solve a problem was overwhelming. This too however started to become "natural". Progressively, after much use of the language I began to see patterns of common ways I've used the type system to solve problems. I would still have to think about what I was designing, you always have to think about design, but now the patterns just came to me. &amp;#x200B; The audio programming I was doing involved pipelining raw input into a chain of function calls where for example an array of PCM bytes can be feed through transformation function calls \`pcm(data).bitrate\_transform(16).16\_bit\_to\_byte\_chunks(1024).map(|| // some other transform)\`. In any other language I would have to make all sorts of runtime assertions that the API was being used with properly aligned types (compiler must statically prevent calling 16\_bit\_to\_byte\_chunks() on arrays not of 16 bitrate audio). For more details on that particular pattern look at the [Type State pattern](http://cliffle.com/blog/rust-typestate/) and Iterators. I could write that constraint in Rust! That is just amazing to me. &amp;#x200B; My advice, no.. Not advice, I IMPLORE you to keep going. Work through the growing pains. It will hurt. You will stumble and think that you will never just understand it. But I can assure you this is wrong. I was wrong when I felt like this, probably more than you. I gave up on Rust and was ready to bury the language. I came back for round 2 and now here I am.
I had no idea about this RFC, thanks! It's super neat. &amp;#x200B; However, if const generics treat enum variants as values, and we're allowed to write impl for types with concrete values e.g: struct Matrix&lt;const N: u32, const M: u32&gt; { // fields } impl Matrix&lt;2, 2&gt; { // methods that only make sense for 2X2 matrix. } I don't see this being too different from my example above.
I try to keep this account anonymous but it's a pretty small company that you're very unlikely to have heard of. I was an early hire so I've been fortunate enough to be able to choose the tech stack we use. Right now our stack is a combination of Ruby, Node, Go (all of which we're moving away from), Haskell, Rust, and Elm (which we're moving towards). Elm for frontend, Rust for APIs, and Haskell for specific problems that involves data analysis.
I remember having the same problem when switching to IntelliJ from Emacs. I haven’t found a way to make the splits behave nicely, like they do in Emacs. However, IntelliJ changed my workflow such that I stopped using splits and tabs altogether. Because of go to class, go to symbol and other navigation features it’s just easier to navigate to the thing you want to see directly, rather then to navigate to tab where the thing is open. https://m.youtube.com/watch?v=eq3KiAH4IBI goes into more details on this, with the central advice of “disable tabs altogether”. For rare cases where I really need to look at two pieces of code side-by-side, I open a new window (I think it’s shift+f4 by default) and use window manager’s shortcuts for switching: it works better than built-in splits.
I may misunderstand, but I think Haskell can do this and much more with liquid Haskell. In Idris this is part of the core of the language.
If I understand the article correctly there are 2 features to this pattern, the second of which makes the pattern stronger in Rust. &amp;#x200B; 1. Different types represent different states of the same object. 2. Rust's ownership system (and of course module accessibility rules) can be used to ensure that the object's old state is no longer accessible. Consumer/Producer relationships can be used to model much real world phenomena and rust has a built it checker for it!
Semantic merge only works in known languages, but I don't know if there are any version control systems with that as a built-in feature.
actix-web’s latest release is not based on actor AFAIK
Data races *are* always unsafe. Opting in to data races is opting in to undefined behavior at every level between LLVM optimization passes and the hardware itself. "Knowing what you're doing" and using `unsafe` code to circumvent Rust's static-analysis guarantees implies that you are confident that your design *will not* permit data races; it does *not* mean that data races are "okay for now" or anything of the sort.
Is your code intentionally private? If not, do you have a specific reason not to just throw it in GitHub or some other cloud-based version control system?
That's awesome. Love your app so far! The symbol for saw is amusing :D Keep up the good work!
I'm so grateful for this. Thank you. I've started to learn Rust, reading the official book, source and example code. This is the very first time I've got the feeling for how to combine Rust specific language features to a coherent powerful design. From my personal experience I can say that, while it's hard to understand the basics of Rust at the beginning, it's even harder to put the pieces together in such a way that they present a meaningful picture.
&gt; Is it just a tagged union aka variant, etc.. or is there more to it? That's pretty much it. Technically algebraic data types are product types + sum types, but everyone has product types (structs / tuples / …) so "doesn't have ADT" usually means "doesn't have sum types" = doesn't have (type-safe and language-supported) tagged unions.
I didn't want to make a different github account. I already have one, but it's personal, and didn't want to put this there. Also, for experiments like this I don't even bother. I made many other small test projects to try out some things and isolate problems, and I'm not gonna keep all that in the cloud. You might also notice I made this account just to share this, so I didn't have this planned. I didn't intend to put the focus on code either.
Using them only once is exactly the main advantage of UTXOs. When you are dealing with units of digital currency or assets, moving them atomically with unique identifiers is normally a good idea for the sake of preventing double spending and other nasty stuff. Also please notice that the "throwaway accounts" effect in chains like Bitcoin is not caused by the UTXOs at all—as they have nothing to do with accounting / addressing. The throwaway thing is a privacy feature better known as "hierarchical deterministic wallets" (BIP32), which is totally opt-in and offers not only a reasonable amount of privacy and deniability but also slightly better UX—because your wallet can tag each receiving address with the name of the counterparts you hand them to. As for the claim someone else did about account-based being more suitable for smart contracts, I think it's rooted mainly on a fixed image of how UTXOs are implemented today in Bitcoin and others. However, that doesn't mean UTXOs hinder the existence of smart contracts but just the opposite, the UTXO model offers some advantages for implementing smart contracts without resorting to convoluted state trees or other paraphernalia. If someone is interested on this, I can do a write-up. I was asking this question not seeking FUD but simply because I've also been in the position of having to choose between account-based or UTXOs for building a new blockchain on Rust. Thus I wanted to know what were their considerations when they chose account-based, as from my own experience UTXOs would have made total sense in this case.
As a developer, only one programming language is not enough, you will learn some language in your career. Start with Go and then learn Rust.
Oh I completely agree. I wasn't trying to suggest that it's actually defined behavior, only that it's my perception of what OP was thinking, and that if you don't care then going into unsafe code is the only option. Trying to represent such code though a safe interface would be completely disingenuous, of course.
Okay. Is that for privacy reasons? If so, I totally understand, but either way, I'd still recommend using version control locally just so you have an easy way to track what you've done and easily revert to a working state if you start making a major change that you then decide to undo. In any case, I think the code is important in this case, because even after reading all your comments, I still can't tell if your design was actually as safe (in the sense of avoiding undefined behavior if you had just implemented it in C) as you thought it was, which seems like an important aspect to understand. Perhaps you could share a zip file or something, or even just `cat` the whole project into pastebin?
Further information: the above snippet is the same as: struct Foo { x: i32, } impl Foo { fn foo(self: &amp;Self) { println!("x is {}", self.x); } } fn main() { let foo = Foo { x: 3 }; foo.foo(); } Here `self` means the same as `this` in other languages (like Javascript), and `Self` means the type you're implementing the method, that is, `Foo`. You can also write `fn foo(self: &amp;Foo) {` See [here in the playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=4d4b9a69e29da0a440776ecd1d11d69b) (click "Run")
Maybe we just disagree on whether it's okay to give what seems like a recommendation of `unsafe` to people who, per our understanding, are predisposed to misuse it!
I'm fairly certain that you can't do the same with liquid Haskell. It's always possible to freely copy/discard values, which the type system doesn't track. This will be possible with the upcoming LinearTypes extension.
I'm not even sure we disagree on that! But I can see how my comment came across as a recommendation when that's not really what I aiming for. I was trying to call out the mismatch in philosophy and describe how you can (not should) assert that you (think you) know what you want. I should have found clearer wording.
Semantics. For example: &gt;C++11 introduced formal support for multithreading, and defined a data race strictly as a race condition between non-atomic variables. This definition means that indeed all data races are unsafe and dangerous. But if you consider atomics to potentially have data races too, maybe you are just talking about race conditions. I can understand Rust trying to prevent data races. I was fine with race conditions, not data races, as I said in other comments (to avoid reading corrupted data), because I would achieve a consistent state pretty fast anyway. It's definitely a tricky topic, so I'm not gonna discuss it in length here, but it is as [zzyzzyxx](https://www.reddit.com/user/zzyzzyxx/) said: what I tried to do is unsafe. Maybe in the future atomics won't be so magic and rust will have more coverage for dealing with things like race conditions. Maybe not. For example, it seems it *had* some way to mark immutable fields in structs in the past, which is something that could potentially help a bit with the kind of issues I was facing, but later it was decided to drop that. These are complicated things, it probably was the right call, maybe it wouldn't solved much by itself anyway. It has been made clear to me that what I was trying to do is *not possible* in safe rust. It's not clear (at least to me) that it *has to be* unsafe in any language. It's clear it's a *very tricky* thing in any case. And I don't mean to start an in-depth technical discussion about a problem in a domain and language I barely know, so I'll stop here...
Hi everyone, The requirements have been updated as per the feedback above. Thanks very much for your input. ___________________ Minimum Job Qualifications High level of fluency in spoken and written English 3-5 years of experience in Rust/C/C++/Java (at least 1 year using Rust in a professional capacity) Experience managing a team Proven profile of excellency Excellent interpersonal skills and team player B.Sc. in Computer Science, Electrical Engineering or able to demonstrate significant relevant field experience Experience developing complex system architectures Self driven and motivated with passion to research and act where software and cryptography meet ___________________ Preferred Job Qualifications 5+ years of experience in Real-Time or Embedded Systems using C/C++/Rust Previous RTOS experience (e.g. THREADX / QNX / Nucleus / VxWorks / embedded Linux) Experience designing architectures for portable, embedded systems is a plus Proven track record in designing software algorithms and data structures is a plus ___________________
Also in this context, there are "duplex" `Stream + Sink` types too, and similar to `AsyncRead + AsyncWrite` they can also be split into their components.
Neither Liquid Haskell nor Idris support linear types, and so neither can do this. Both support refinement types, which is a way of getting the compiler to statically check function predicates (eg that the return value is always between 1 and 31) You can sort of hack the linear typing idea inti these languages using an instance of the ST nomad to track the state all the way through; however it’s very manual and awkward.
Got it!
Can you say a little bit more about how you use the \`include\` macro to alleviate this? I tried adding \`include!("/path/to/bindings.rs")\` at the top of my [main.rs](https://main.rs) file...I get code completion for OpenGL functions, but without the \`gl::\` namespace, so something doesn't seem quite right. In other words, Intellisense recognizes \`ClearColor\` but not \`gl::ClearColor\`
Fair enough. I definitely understand being okay with race conditions.
&gt;Cliff L. Biffle That... that can't be your actual name, can it?
This seems to be a known issue: https://github.com/swellaby/vscode-rust-test-adapter/issues/8
Great work, this reminds me of soa derive or whatever it was called. One thing I'd like to see is keeping names, which can be useful if you have multiple types. I think soa derive allows you to do `soa.positions.iter()` which is very readable.
If you were using references, that would do it. You can cast a reference to a raw pointer just fine normally, but to go the other way requires unsafe, and a dereference rather than a cast: fn ptr_to_ref(p: *const u8) -&gt; &amp;'static u8 { unsafe { &amp;*p } }
Or move it elsewhere.
Ah. I'm kind of going off of [old information here then](https://boats.gitlab.io/blog/post/async-methods-ii/). At the time I assumed this meant that in order to make async fns in traits object safe we'd need to perform this kind of transformation for all async fns in traits. But I guess that is not the case?
Yeah I weighing up the comments I think it would be better to start with something like Go, and then move on to Rust. Thanks for the advice! I hope to be a Rust dev one day
Yeah I definitely can't wait for const generics to get stabilized. But for now, there's no way to bind any Enum variants to fields or parameters, even with const generics. The function you pass the enum variant to still has to do a match expression. With Enum variant types the match gets moved to the compiler phase as a static check on your inputs. One step closer to proper refinement types.
[removed]
How many production-ready orchestration systems, proxy servers, service meshes and other pieces of cloud infrastructure are written in Rust? I'm pretty sure it's 0 at this point. Go gets the job done.
I see now, thank you. Yes, rust was still &lt;1.0 by the time Docker was released. Still "go is more real than rust" isn't really indicative of anything. Oh well.
That's exactly the kind of company I want to work for :P I wish there were a company like that in France...
Other problems I had where because of conflicting extensions, so I tought it would be the same cause, but it seems like it's not based on this post, so I definitely will, thanks anyway.
There’s no support for AVR, Xtensia and riscv64 at the moment. There are more, but those are the annoying ones. I know it’s pretty unfair, but I’m comparing against C.
None of that changes what I said. In fact, you've just lended support to the fact that this is a cargo culted meme. BTW, you might want to check out Conduit and Linkerd2.
Nice. I didn't know this pattern existed. I didn't know that I've been using it all the time either. Great writeup though, it was pretty informative :)
You are welcome, good luck!
Are there any reasons to use empty enums (which require PhantomData) over empty structs?
Hm - I mean it could still be that? But it doesn't seem like many people here have been able to help (myself included), so I figured the maintainer of the plugin might have a better idea.
Yup, will ask a few friend for help, if I still can't solve I'll post a bug submission to the ectension mantainer
&gt; Okay, technically, dereferencing `nullptr` is undefined behavior in C++. But in practice, unless you're on an ancient version of Unix or a very obscure embedded system, it crashes the program. I'd prefer stronger language here. Undefined behavior doesn't just mean it'll crash your program -- it means that the compiler may assume that said behavior will never happen, and optimize based on that assumption. These "optimizations" may include [deleting null checks](https://blog.regehr.org/archives/970) or [calling an unreachable function](https://www.reddit.com/r/cpp/comments/6xeqr3/compiler_undefined_behavior_calls_nevercalled/?utm_source=share&amp;utm_medium=web2x).
Oooh, that's amazing! I've been working on an automated generator of fuzzing harnesses for Rust functions, so we could easily fuzz the entire stdlib or any other lib with tons of functions in it. I've been using QuickCheck's `Arbitrary` to generate structs, but it's clunky and has issues with length. Having a structure-aware fuzzer could be hugely beneficial.
The next version of Idris will have linear types baked into its core language.
I know what it's written in, I was very excited about conduit project (linkerd2 prototype) :). &gt; Oh this ludicrous, unsubstantiated, likely cargo-culted opinion again. Thing is, it's not (in the context of clouds). Especially if you compare Go and Rust - think instrumentation, network libraries, serverless support, etc (I made that research and comparison multiple times in the last couple of months, because at the company I'm at we have couple of services that could use Rust benefits).
We do have upstreamed support for riscv64 now, I believe (at least for bare-metal targets). AVR continues to live on as its own [Rust fork](https://github.com/avr-rust/) for now, and Xtensa support will probably land once the LLVM backend is upstreamed and more mature.
Well, I'm pleased that this article almost literally [quotes my own that was written about a year ago](https://medium.com/paritytech/why-rust-846fd3320d3f). But I still think if one quotes something, proper reference is a must. &amp;#x200B; Interesting article nevertheless.
Exactly. That's what so many people have trouble grasping. If dividing by zero were considered Undefined Behaviour, then a compiler would be perfectly in the right to optimize something like this... if (var != 0) { var = 10 / var } ...to a single `DIV`, `IDIV`, or `FDIV` instruction as appropriate to the data type.
What the hell is wrong with Java?
For instance, consider a function like this. unsigned five_div(unsigned b) { return 5 / b; } The compiler is allowed to assume divison by zero won't occur, and can generate code like this. unsigned five_div(unsigned b) { int results[] = {5, 2, 1, 1, 1}; return b &gt; 5 ? 0 : results[b - 1]; } Which may accesses an array out of bounds which may not crash.
I don't mean standard lib. Every time I deal with Python projects at work there is always some horrible issues about a library being used that needs to be fixed some bizarre way, like me having to explicitly install dependencies of the libraries they are using, or configuring virtual environments, or looking through huge unclear stack traces because of a problem in a dependency, or simply having to use python2 because one dependency can't use python3.
I'd like to share a non-trivial example of this technique. https://github.com/amethyst/rendy/blob/master/command/src/buffer/mod.rs Here vulkan command buffer state is defined at type level.
/r/playrust