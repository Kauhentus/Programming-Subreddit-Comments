I'm waiting for a quality statically typed simple language, compiling down to executable code, for coding fast and small command line tools, something more simple regular and fun than c/c++. Currently toying with ocaml and haskell.
If only libclang exposed more codegen capabilities - then we could have Rust generics instantiate C++ templates.
Have you measured how much time is wasted on the GC? Because if you do not allocate much during the calculations I imagine it doesn't run at all.
Thank you, you formulate this very well. I don't think this is a win for Rust -- two issues * Lifetime relations still exist, but they are "invisible" most of the time. You basically have to do the expansion of the annotations mentally yourself when you are reading * Simpler cases are not annotated in the code, so you will only see lifetime syntax on complicated cases, making it harder to learn. Lifetime syntax hasn't been removed, just shoved into a corner. It's still something the user has to learn, but it is now more obscure.
My background is gamedev; Frustrated by several things in C++ :- - (i) header files - (ii) the lack of extention methods - IMO closed classes work against modularity by drawing in dependancies, but the a.foo(b) call syntax is addictive - (iii) How hard it is to retrofit parallelism with unconstrained mutation/branchy code. - (iv) Lack of reflection making data-driven programming more clunky than it needs to be. Rust interests me as it takes steps forward in these specific areas. The FP languages were all fascinating and inspiring, but none were suitable being GC based. In particular optimising for the last gen of consoles didn't just need parallelism with threads, it needed it for SIMD and loop unrolling.. the 'map'/'filter' mentality of FP seemed perfect for that. Also I think (i) and (ii) make C++ nastier than it needs to be in a team environment. I believe more software should be developed in the open as we move into the future, and C++ makes that harder , IMO. All these frustrations are orthogonal to C++'s core pillars that made it the only viable choice. And perhaps 'a change is as good as a rest..' I like choice. Ive looked at the range of languages available in other domains with envy, being stuck with C/C++ for so long. Some doubt remains.. - (i)traits/bounded generics increase boilerplate in some situations, overloading &amp; conversion operators suit maths code with a wide variety of types for optimised layouts.. (Although indirection traits aren't a complete disaster, and it seems they can be broken up more than I originally thought..) - (ii)and whilst the language seems better, moving from C++ means losing mature IDE's which are a godsend for working with APIs and navigating large source bases.. 'dot' autocompletion - (iii) C++ isn't standing still: - in the time i've been looking at Rust ,polymorphic lambdas have become available in C++1y.. (although going back to C++ now it feels a bit clunkier with the noise of const,auto,'template' all over the place. Concepts &amp; modules on the horizon.) - (iv) I also believe its possible to advance in ways that makes an efficient language more suited to rapid iteration aswell; think of how Lua gets used, imagine if the core language had a subset that suited that role.. - and this all seems to be orthogonal to Rusts' stated goals: There's a drive to minimalism around the demands of one target field, and I don't think 'the perfect language' can be minimalistic. Apple seem to be trying there with swift, but it disappoints without unique ownership and so on. In the time I've been looking at rust its' actually lost a couple of things I'd liked.. do notation (which would have been great for parallelizable internal-iterator based code) and compact sigils that expressed common datatypes compactly - which made it look like you could have something closer to a scripting language embedded as a subset of a systems language. Given some similarities, I hope cross pollination with swift might encourage rust to gain some more sugar (the discussion about `if let` ...etc) Gamedev really does need everything.. (i) The ruthless efficiency &amp; detailed control of systems programming, but also (ii) productivity for rapid experimentation with changing demands, and (iii) conveniences of 'application languages' for working with big,complex APIs.
I *suspect* it's not HKT, but *higher-rank types* (i.e. first-class polymorphism) that would be most impacted by this.
A question I have is , could Rust make a few concessions here and there without losing its pillars &amp; defining character, that would increase the overlap possible with C++. (..like the option of internal vtables, ..and making it easier to overload multiple parameters). I think trying to do some of those things would draw more people into Rust; Imagine being able to insert it into existing C++ projects instead of being an all-or-nothing choice. "you can only use Rust if you start a total rewrite of your source base.." - that is a barrier to adoption for businesses with established C++ products. Just look at how widespread Swift stands to be by virtue of ObjC bindings, and how there is the ability to mix swift/objC using the same interfaces. How close could traits and concepts become? As it stands the level of interop via the FFI is encouraging, its not completely impossible to have a mixed language project. You could have options that were warnings by default,requiring quieting, making it clear they're not the default way of working. Then over time your source base could be rust-ified, whilst still continuously being in use.. existing customers still get improvements.. 
I am saying that a HTTP method is defined as being a *token*, which itself is defined as being restricted to a subset of ASCII characters, and thus an emoji is not a valid HTTP method.
Well, `Vec&lt;&amp;str&gt;` requires an allocation more often than not.
I am interested in Rust because that is the only language I have found which actually makes me excited about systems programming. I came from the dynamic background, playing previously with C++ for systems programming and found that Rust provides many of the nice abstractions found in higher-level languages, while also making the low-level parts *interesting* instead of frustrating. I actually learned more about the inner-workings of computer memory in my last few weeks with Rust than in my entire previous experience and contrary to my initial expectations, it it actually tons of fun!
GC is usually between 1.0% and 3.7% of run time, but the memory profile can be huge. We have tasks with 80GB heap, though I work hard to reduce memory usage for all programs I work on. [Aside: The allocation is mostly due to logging - we use Log4J2, which allocates a lot of LogEvents behind the scenes to keep the actual logging work in its own worker thread. Which is a good thing, because it's faster than every other logging framework we have tested] The problem is that this measurements don't tell the whole story. Caching exacerbate the performance penalty, and measuring the cache misses due to GC having swapped in heap pages for marking or collection while keeping other cache misses out of the measurement would make for a good doctoral thesis.
Would it be nice to have separate functions that expect pure closures vs effect full ones, once those are recovered. ( I'd personally always associated the idea of 'map'/'filter' etc with pure fp)
I've been developing server-side software for nigh on 7 years now, in C++. I have specifically worked on what we dub "Mission Critical Applications": our SLA is 99.99% availability (less than 1 hour of outage a year, in four 15min quarterly outages). And of course, performance is important, more specifically *latency* is important. Our clients want fast answers. Thus the choice of C++ (which was made at least 15 years ago) and I must admit I have come to appreciate the language: you may get a lot of type-safety from C++ thanks to templates/phantom types, and you don't have to go off your way to get good performance, idiomatic C++ performs well out of the box. Unfortunately, I am pretty sure that about everyone here has heard of the woes that plague the C++ programmer. Contrary to popular belief, memory leaks are not an issue (C++ is not C), however dangling pointers/references (memory corruptions/crashes) and data-races are a plague. You can usually detect *most* of them with extensive testing... understanding their cause however is another story entirely. C++11 introduced a lot for efficiency (moves, noexcept, constexpr) and syntactic sugar (for, lambda), but it did not close any existing hole and instead introduced new ones... I've been interested in alternatives for a while, my company also use Java (uh...) and I've checked out D, Go and Nimrod (and left disappointed): - Java: conceived to be a simple language, but a simple language does not equate a simple program. The type system is way too weak for my taste. - D: I was enthusiastic by the premise "C++ without its dark past", but a GC ? really ? There is a lot in D, maybe too much actually, the sheer number of annotations for example is positively staggering. - Go: Weak type system, no generics, GC; it could be useful to get faster scripts, but those are not generally a bottleneck. - Nimrod: Could be interesting, because of the emphasis on a low-latency GC, but multi-threading is still in the box. What I left out, though, is the multi-threading story. Java and D use synchronized objects/statements, which work well, as long as you do not *forget* them. Similarly, Go uses channels, which is a great idea, but the language offers no guarantee that the object passed does not end up being shared. Nimrod is still sorting itself out in that regard, as far as I understand. --- So, what does Rust brings to the table ? - Unparalleled (*) compile-time safety checks: this is not only about performance, I much prefer defects to be caught at compile-time rather than, hopefully, at run-time, if the stars align. - Excellent and Predictable performance Thus, it makes for an excellent language to write *safe*, *low-latency* servers in. *Note: I also dabbled into Haskell, but I must admit I get a hard time wrapping my head about Haskell programs. Lots of goodness for sure, but it is alien... one day I'll take the time...* (*) Compared to the languages alluded to in this post, that is C++, Java, D, Go and Nimrod.
&gt;&gt; traits are explicit, as opposed to interfaces in Go I'd thought it would be useful to have the option of both, to cut down on the noise of single function traits in some situations. (e.g. implementing indirection traits, and the cases where you need a trait to add an extention method)
I'm a roboticist with a fair amount of research and development experience. In robotics, performance is key (you're oftening slamming all of your cores and the caches quite heavily), some pieces of code need to run with near real-time guarantees (such as motor control), and you need a language that can deliver these features. Most languages have some downfall for robotics (Java's GC, C's lack of serious software engineering abstraction, Python's lack of performant execution), thus C++ gets used for 99% of the real-world software scenarios. I like Rust because I think it's about to change all of that, addressing the pitfalls of these other languages, while adding some much newer tools that allow one to write highly parallel code very easily. Furthermore, robotics as a field shares a lot with game engine development, so strong communities should form around high quality libraries.
I agree that this is going to be interesting. The fact that makes me excited about that is that Rust explicitly tracks ownership and lifetimes. Which could make auto-generation of bindings a lot easier.
Looks great!
No, there's little point having separate functions; unless it's for something like `par_map` (for which the important thing is the closure's environment being `Share`, being pure vs. effectful is somewhat orthogonal).
Because I was disappointed by D, and Rust looks like a good contender for the same space: a language usable at very low levels that isn't as painful as C++. Because immutable by default is a really refreshing default position to be thinking from. Because I'm really looking forward to a language that makes a serious attempt at solving memory safety without runtime overhead. Because traits are an interesting inversion of how I normally think about modelling objects. Because it feels like there's serious thought being put into quality-of-life concerns like packages and documentation, as opposed to just kinda hoping that sorts itself out. Because it's interesting to watch it being developed out in the open. I don't have to lurk on IRC or a mailing list to see regular updates on what's happening and *why*. But most importantly of all, because it's the first language I can think of since Visual Basic 5 that lets you take a reference to a temporary. Seriously, half the arguments to these damn Windows API functions aren't even being used! Why do I have to define half a dozen locals with obscure types just to ignore them? :P
&gt;&gt;... Share, being pure vs. effectful is somewhat orthogonal but does that then say that the are actually more cases.. -parallelizable vs non parallelizable -effectful vs non effectual In gamedev on the last gen of consoles we had 2 distinct types of parallelism:- - multithreaded, - *loop unrolling* (ILP) - this needed purity, or at least a guarantee that the effects were not dependant on sequence . It was finer-grain than multithreading - working at the level of inner loops- and yielded the same magnitude of performance improvements. Also similar to SIMD/vectorization. ( in yet another set of cases, data was read into registers and permuted to run 4 iterations of the same algorithm in parallel , the permuted back to write out) 
&gt; GMP bindings it could (...) Have you looked at [rust-gmp](https://github.com/thestinger/rust-gmp) and [rust-bignum](https://github.com/jsanders/rust-bignum)?
I use it for the tiny scripts too, and I've used it once or twice for embedded programming, though getting rustc to compile is painful.
Thanks! I'll post something back once Rust is debuggable
&gt; Because programmers should be protected against themselves [...] This is something I forgot to say in my comment, but it's something I believe in 100%. I am not infallible; I really do appreciate the language asking "are you sure about this?" before I do something stupid.
How can we contribute? Is there a mirror to submit pull requests too?
https://github.com/rust-lang/rust is the main repository (and you can submit PRs there).
I'm interested in Rust because C is error prone and managed languages are difficult to get to perform well. Also I really like shared-nothing, message passing concurrency. At the moment I'm using it for physical computing on the Raspberry Pi. Type-checked safe use of memory makes me feel confident I can twiddle device registers from user space without accidentally corrupting kernel memory. CSP-style concurrency works well for juggling events from different hardare devices. And for the kind of hobbyist stuff I'm building, I'm ok with the language being a moving target. Longer term, I'm hoping Rust means I never have to use C again!
It has some semicolons and curly braces and `::` for scope resolution, and it used to have sigils but I guess you can't have everything!
Is your COM binding generator open source and available somewhere? This is something I'm seriously interested in. I've mentioned here several times that I wanted to do such a thing, but I've had a lot of other things going on and never really made it beyond the proof of concept stage. I'd love to contribute to this effort.
I'm primarily a jvm programmer, but wanted to start playing around with more native and low-level systems. I love C in theory but less so in practice, and C++ was too complex to want to deal with for leisure. Funnily enough, I had to start working with a C++ codebase at work, and my time with Rust went a long way towards making that a much better experience than it would have been otherwise. Having a compiler yell at you for bugs is a tighter feedback loop than waiting for them to surface in production, so the process of writing Rust builds good habits that bleed over to writing C++. 
To be honest I'm probably not in the target audience for Rust. The software I write doesn't need to exploit every ounce of performance out of the machine. What I write could just as easily be written in an interpreted language. This doesn't change the fact that I've really grown to like Rust, and I'm using it for more and more personal projects. My "trail of languages" goes from Java, to Ruby, to Go. (Of course with some small stops along the way.) These days though I've really grown to like Rust. Basically any time I want type checking: I reach for Rust. The language just feels so expressive to me. I've started to think in Rust. I can't tell you how many times I try using `if() statements` as expressions while writing Java during my day job. When I moved from Ruby to Go: there was this overwhelming sense of "wow: most of the mistakes I make are caught before I can even run the program." Moving from Go to Rust just adds even more static guarantees to the table: and I must admit that I'm growing addicted. At the moment I'm writing server side software, namely a high performance network chat that runs over websockets. The high performance comes from sinking about 60FPS worth of positional data from clients. Admittedly though Rust makes it trivial to achieve that sort of performance, which is why writing Rust is a blast. I've even sacrificed tons of performance in the name of using tasks and channels to better organize my program (which of course involves a lot more pass-by-value.) I like that these abstractions are not terribly expensive, and if you needed to optimize them away: you could. 
The first language I used "seriously" was C++. Later on I got to know Haskell which led to several years of continuous brain exploding. From around that time I started daydreaming about a language which took the "good" parts of C++ (basically, templates), got rid of the OO and other cruft, added nice Haskell things like type classes and ADTs, and added existential quantification on type classes (instead of virtual methods) for dynamic dispatch. Rust is that and so much more I never even dreamed of. For example, memory safety is not something I would have thought possible. Everything-is-an-expression while retaining familiar C-like syntax is awesome. Linear types are wicked cool, and the synergy with ownership, aliasing, and mutability tracking is amazing. And the fact that it already one-ups Haskell on correctness and abstraction in some areas, and has the chance to do so in a few more, tickles me silly.
if you have large codebases running on the JVM and you don't need performance, you should check Scala, it has a great std library and very good interaction with existing Java code. You can bash-script it too. I use it for short scripts like log parsing, etc. 
Brilliant! 
I don't mean weakly typed, but indeed the lack of expressiveness. I think it's being improved, but for example I am not terribly impressed by the interface of `HashMap` in [Java7](http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html). Specifically, the methods taking an `Object` as parameters... This leads to a pervasive use of casts, which while better than C's or C++'s (being checked at run-time) still let errors pass. Oh, and of course, `null`... All of this conspires to only provide the most rustic of proofs at compile time, similar to Go's. Given that I need to write code I can be confident in, I really wish for *more* at compile time.
A nice build/packaging system with automatic downloading of dependencies and etc would be such an upgrade from C++. 
While I'm very symapthetic with the goal of making `String` allocation easier, I don't think this would fly. It hides the allocation overhead too well. Personally I wouldn't mind e.g. a `Str!("")` macro.
There's an [RFC](https://github.com/rust-lang/rfcs/pull/143) exactly about this. Personally, I like that non-free operations (`to_string()` allocates, `display()` checks all the bytes contained in a `Path`, etc) are verbose. However, I wish that free operations, like `as_slice()`, were automagic (if I pass `&amp;vec` as an argument, it gets desugared to `vec.as_slice()` iff the function expects a `&amp;[T]` type). I think DST is going to help with this though (`&amp;*vec` becomes possible?).
I think that a much more interesting idea would be to use custom sigils for different string types. This feature is supported in Elixir, and it's clean while being explicit. See [here](http://elixir-lang.org/getting_started/19.html) for the corresponding Elixir entry. doing some like ref"Hello world" seems to me like a much better alternative than having to invoke a method on a literal every time. 
There is some discussion about literals in [RFC PR #143](https://github.com/rust-lang/rfcs/pull/143). I don't personally have an opinion either way, but though the previous considerations on there might help.
Right now, a lot of distributed systems are written in C++. Especially ones where they need low-latency, high-performance. Java is also being used, but for instances where memory and having the JVM aren't huge issues. I find Rust is becoming a good match (albeit still quite early) for these types of systems. Properties of immutability, ownership, and concurrency are all very important. There are many many bugs that appear in the systems that are the result of the language. Some embedded databases, for example, LLMDB are written in C (Some are written in C++), but they are **extremely** cryptic, lots of C macros, super insafe (the codebase is around ~10K, so pretty small). It's hard to trust your data with a piece of software that is written in such a way. However, the resulting system is fast. LMDB, because of it's mmap operations, and cow semantics and the offloading of caching to the kernel results in truly remarkable benchmarks. I think Rust brings safety, zero-cost abstractions to a level where you can *understand* and reason about the code inherently. Rust isn't perfect right now. Networking isn't up to par, but it can be. Also, the fact that Rust is truly open and discussions happen around the community is very welcoming. This is a very rare occurrence.
Since we've been renaming all `str` things to `string` (like `read_to_str()` to `read_to_string()`), that macro should be `String!("")` to stay consistent - but that would be too long to be useful. I'd prefer to use `box "me"` to create a `String`, since the `Box&lt;&amp;'static str&gt;` type is useless (I think).
&gt; a much more interesting idea would be to use custom sigils (Shhh, don't let /u/pcwalton hear you...) Lately, we've been moving away from sigils (`~`, `@`), it seems unlikely that we'll start adding them back. (When I clicked that link, and read the title of the webpage "19 Sigils - Elixir" I immediately thought: "19! `!"foo"`, `@"foo"`, `#"foo"`, `$"foo"`, ... - that's a lot of sigils! How am I supposed to remember what each one does?", but then I realized it was just the chapter number :P)
In the case of boxes, there's a clear victory in readability from removing sigils. I guess that you can get by with alphanumerical sigils exclusively if line noise is an issue. It would increase clarity all around.
If you'd do that, no german would ever use cargo.
I'm not a professional programmer, although I can write code in a few languages and my day job has me dabble in JavaScript every once in a while. I have a degree in math. I like Rust for philosophical reasons. I want a language like it to succeed, and currently Rust is the only language like it. This is a vast improvement over several years ago when there weren't any languages like it. * Humans should do things that humans are good at, machines should do things that machines are good at. Machines are clearly the superior at performing rote tasks thousands of times without variance. So whose responsibility should it be to check that you never dereference a nullable pointer without null-testing? That your stack-allocated variables don't escape? That you didn't miss a case in your discriminated unions? That you didn't double-free? * Along with that: Having a math background, I like formal methods. I think Rust is much more amenable to formal methods than any other language in the systems space. It seems any formal verification tool of C++ spends 95% of its time just parsing the damn grammar, and so much behavior is undefined it's difficult to get anywhere. * Breaking the dichotomy between garbage-collected languages and manual memory management. I think the memory is one of the top driving concerns for programming languages right now, and our mainstream tools are completely inadequate. Rust is the first language in a long-ass time that brings in a new way of describing memory usage. This new path is nearly as expressive as manual pointer arithmetic, while being much more disciplined and verifiable for correctness. * Really a big fan of separating implementations from both objects and interfaces. Seems like a simple idea, but it blew my mind. * Low-level access that's still safe when you need it to be. I never got into C because of my distaste for its sharp edges. Rust seems to go against the conventional knowledge that you need the danger to get the benefits of low-level programming.
That's what I'm currently using. I add it to the pacman.conf file upon startup (if it's not already there). Here's the [Gist](https://gist.githubusercontent.com/jlmartin9/d8a43e45ef9342435264/raw/55cc4ad328ebbbe7a76e0fb04cd4338c5c3c7a79/provision.sh)
Well, if you don't pass the mutability as a separate parameter and instead tie it to the lifetime of the `&amp;var` parameter, then it's basically what he said, just fleshed out a bit in how it would work.
As dbaupp says, all my work is done as pull requests to the main repo. No special magic here. I _do_ have one open PR for API docs, check it: https://github.com/rust-lang/rust/pull/15217 that can hopefully give you an idea.
A Vagrant box might be helpful for development of `rustc`, but the install script should make it the same 'up and running to try out Rust in five minutes,' and play.rust-lang.org should be even faster to just try things.
I love how clean the syntax is, the fact that there are less errors, and no header files.
People used to overuse `~str`, and I suspect they still over-use `String`. Making a `String` should be a bit hard, as it's an allocation.
I'm a video game programmer and Rust is the first language that I know of aside from C++ that embraces the zero-cost abstraction principle. C++ is limited by its retro-compatibility with C. So I feel like Rust is a good candidate for a fresh start with the same goals as C++.
You're allowed to be offtopic as long as you're on a technically interesting topic. :)
The limitation here is if you want to move the value. I've run into this in Servo and haven't found a nice way of dealing with that problem yet.
We're developing a framework for expressive control of multimedia targets. Our primary focus is lighting (moving lights especially) but also video and music production. Our requirements line up quite well with Rust's goals: - Fast: the more animation curves I can render per frame, the more compositional elements I can put into my scene and make things more rich and organic and beautiful. - Safe: you really, really, really do not want your controller to crash during a live performance. - Expressive: since we're building a framework, we want to take care to make things as extensible as we can. Algebraic data types are really, really helpful here.
I'm a Java developer in the center of the continental US, where managed languages rule the roost, and one's best chance for escaping the beige khaki boredom of Java is a lateral move to another sea of cubicles that adopted C# instead. I am (and am surrounded by) [the unseen 99%](http://www.hanselman.com/blog/DarkMatterDevelopersTheUnseen99.aspx). Rust will likely never catch on here because garbage collection and nothing-but-reference-semantics lower the cognitive burden to the point where bean counters can fill chairs with cheap, replaceable cogs. It's pretty dismal. But I believe that the world desperately needs Rust. We have gone on too long with unsafe systems languages that produce things that the elite few get to work on but all of us depend on. The systems layer needs the fruits of the ML family tree of languages. The design priorities behind Rust hit all the right notes for me and my gut tells me that it has a very bright future. 
Right, moving becomes impossible with this, as lifetimes have only meaning in relation to a fixed stack scope, and there is not enough abstraction to say. "This is valid even if moved, because its only reachable through a pointer indirection which makes the address stable".
Yes, the invisible lifetimes where those without connections between two variables right. It's not really the lifetimes that become invisible; it's the lifetime connections that are now implicit. You make a decent point, and I'm sure I'll get used to it that way. I liked the simple syntax change to remove `'` better.
That will make three kinds of strings, `&amp;str`, `Box&lt;str&gt;` and `String` right? If I understand correctly, `Box&lt;str&gt;` will be a pointer + length so it can't store an allocation size like `String` does.
I was really disappointed when I tried to box a &amp;'static str and it didn't work.
No! no passive voice! &gt; Think about relationship between `cargo` and `rustc` like this: `rustc` is a car that either you or an robot chauffeur like `cargo` can drive.
&gt; [*“So avoid using the word ‘very’ because it’s lazy. A man is not very tired, he is exhausted. Don’t use very sad, use morose. Language was invented for one reason, boys - to woo women - and, in that endeavor, laziness will not do. It also won’t do in your essays.”* ~N.H. Kleinbaum](http://writerswrite.co.za/45-ways-to-avoid-using-the-word-very)
&gt; I'm very afraid of a future where only a handful of developers are able to deal with the massive infrastructure that our technology depends on. Yeah, *atrophy* is a real problem, isn't it? If you always go out of your way to make your work easy, you become soft. On the other side of the continuum, you have another enemy in the form of *hypertrophy*, where complacent C/C++ programmers – convinced of their own Herculean abilities to avoid sharp edges on their languages – insist that a safer language is unnecessary. I'm grateful for the gifted minority who blaze the trails.
It's "weakly" typed in terms of parametric polymorphism because in the back-end it's always an array of `Object` that's being dynamically casted... So if you have to write your own data structure, I don't know, a `MinPriorityQueue&lt;Key&gt;` or something like that, you're going to have to do `pq = (Key[]) new Object[initCapacity];` so much for generics, you can't even make a `Key[]` because of erasure
`box` is anything but designed. However, it should be possible to make `box "foo"` work when the expected type is `String`.
&gt; Unless you are C++, you can't really use C++ libraries like Qt Maybe it's not possible to get all the features, but [there are bindings for a lot of languages](http://qt-project.org/wiki/Category:LanguageBindings) for Qt. I don't know if they use some Qt-specific technology though
As a seasoned Java programmer, I am looking at achieving a similar level of productivity and speed, but without the uncertainty of the GC pause. I happen to work a lot on realtime apps, so this is important. Also, I think it is important we have a kick-ass programming language that can scale to the most demanding tasks and isn't under control of one large corporation.
Quite fair, I just wanted to make sure I understood you :)
Yes, brain-the-size-of-a-planet C++ folk, with 90% of that dedicated to understanding the language and avoiding its pitfalls. Just imagine what they could do if some of that processing power were freed up.
&gt; I honestly do not understand why this is something anyone wants. Really? Terse expression of loop conditions - while simultaneously being *safer* than the `while` keyword (which *is* part of Rust) - makes you want to scream and just unnecessarily type more than necessary? I don't discount the use of iterators. They are great. But so are simple `for` loops. So let me help you... explain what is troubling you so much about C loops.
It's like `unsigned` integers in Java. For most purposes it was unnecessary. But for any *serious* programmer the lack of an `unsigned` integer was a *major* impediment to efficient networking code. Iterators are great in Rust. I do not deny that. But the C-style `for` loop has big advantages for a small but important set of problems. It absolutely astounds me that "professionals" don't see this basic truth. Rust is supposed to be an alternative to C - not an alternative to Java.
&gt;for example I am not terribly impressed by the interface of `HashMap` in [Java7](http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html). Specifically, the methods taking an `Object` as parameters... I *think* that's an API issue from before Java had generics. It could be fixed with modern Java but would not be backwards compatible.
Nearly every C style `for` loop translates directly to one of `count`, `range`, `range_inclusive`, `range_step` or `range_step_inclusive`. The iterators are more readable, idiomatic Rust and are useful beyond cases where there's a direct `for` loop. There are *very few* cases left over, and I think `while` handles them fine.
…which is kind of ironic: the language born with a silver @deprecated javadoc tag in its mouth never had the courage to follow through on removing cruft.
&gt; Really? Terse expression of loop conditions - while simultaneously being safer than the while keyword (which is part of Rust) - makes you want to scream and just unnecessarily type more than necessary? Iterators already cover all of the common cases. You're not providing any sample use cases where you think this would be useful.
The C stuff isn't actually defined or implemented as purely ASCII, so glib2 provides a whole set of `ascii` versions of those functions.
&gt; You're not providing any sample use cases where you think this would be useful. How many threads do I have to provide basic examples to? Okay, Can show me a terse iterator for: for ( i = 65535; i &gt;= 0; i &gt;&gt;= 2 ) { .. } 
I totally agree with you! With DST, I see no reason why string literals should be of type `&amp;str`. That `&amp;` in type appearing out of nowhere is surprising. And I like the idea suggested by /u/eddyb – auto coercion from `Box&lt;str&gt;` to `String` seems natural.
I like this. Thank you. We really need a C-style `for` to `iterate().take_while()` pattern clearly documented in the tutorial. Hmm... so does this let me modify `i` in-loop?
&gt; Hmm... so does this let me modify `i` in-loop? You can modify it in the `iterate` closure body but not outside of there. There's also `unfold`, which is like `iterate` but expects `Option&lt;T&gt;` to be returned instead of `T` because it's not an infinite iterator. Iterators encourage chopping up mutation / state into small pieces, rather than having lots of control flow and state everywhere. The cases where that's not appropriate end up using `while`, but there are very few. Having a C-style `for` loop might be useful in *some* of those cases, but it would encourage a style of code that Rust tries to discourage.
Hmmm. Why not `String::from_str()` when you need one, rather than starting off with `String`?
If Joyent's parser is as much of a mess as you say it is, perhaps there's latent demand for a correct standalone parser written in Rust. :)
&gt; display() checks all the bytes contained in a Path FWIW, the real reason for `display` is to explicitly opt-in to (possibly) lossy output, i.e. you can use information when using `Show` with `Path` (due to non-UTF8 byte sequences being legal in paths on some platforms).
The allocation size of `Box&lt;str&gt;` will be the length of the string (i.e. no overallocation).
The question is whether to *discourage* or *eliminate*. I'm always surprised by semi-aggressive responses to the suggestion of inclusion of the C-style loop which implies unease or insecurity about handling that form of code. I think Gosling was outrageous to *eliminate* unsigned integer support in Java. He had an arrogant attitude that nobody understood unsigned arithmetic - which always astounded me having a very natural understanding of binary logic and register use. Is the C-style `for` loop in the same camp? Probably not. We still have `while` after all. But `for` was a much safer replacement for `while` as it was far too easy to forget to add the necessary update condition before any `continue` in a `while` loop. I think as long as `while` remains in Rust the C-style `for` loop should also be on offer - but of course please emphasise the iterative-style in documentation. Ultimately the community should push for safe techniques while allowing developers to hang themselves if they feel it necessary. Languages shouldn't force developers into a particular style of coding. Well not in my opinion anyway.
&gt; If you want to pitch Rust you can now do it with just a few points: Basically, you suggest to tell folks something like that: "Rust is fast, safe and cool. Believe me!" It doesn't work that way. For example, if I'm talking about hashtables, I cannot just say that hastables are O(1) time, and O(N) size, I have to explain, why is that, explain internals. Similarly with Rust: I have to explain how lifetimes are propagated through function calls. Good programmers are not interested in marketing BS nowadays. They believe in something if they understand how it works. &gt; Why do you actually have to explain explicit lifetimes? I have to explain how just lifetimes (and borrow checker etc.) work. &gt; Certainly I've never had any kind of positive reaction to trying to explain explicit lifetimes to people. They generally speaking dislike the verbosity and complexity. I believe (at least some of) those people do not understand the essential difference between Rust and, for example, Go. They think (I guess) that Rust is just verbose Go. So explicit lifetimes looks nothing more than noise to them (noise, that Go is happy without). But Rust is not Go. When you program Go, you have GC, it solves all the problems, rules are simple and code is concise. When you program Rust, you have to understand concept of ownership, borrowing etc. Explicit lifetimes are less complex than implicit. Because, to understand implicit lifetimes, you have to apply elision rules, get explicit lifetimes in your head, and after that understand explicit lifetimes. Explaining lifetimes to C++/Go programmer is like explaining type checker to Python programmer: explicit types in function signatures are boring and too verbose.
Right, I was thinking on the caller side, not the callee side.
Right, that's what I meant with "pointer indirection" - could've probably made myself more clear.
I guess we'll have to agree to disagree. While I completely agree that you have to understand lifetimes to appreciate Rust, *explicit named lifetimes* still seem to me to be a point of finess about the language left for the self discovery of someone who starts actually using it. If you need to bring up explicit named lifetimes to explain hash table performance, I think that's probably a bad thing.
What's the difference between malloc on OpenBSD compared to other kernels?
I'm not sure of the specifics, but due to the OpenBSD's project's focuses, its standard library (and malloc in particular) has many safeguards. For example, the Heartbleed bug only existed because OpenSSL bypassed OpenBSD's malloc -- one of the safeguards would have caught that particular bug.
You need `unsafe_no_drop_flag` now to go back to pointer size.
As [Dr-Emann suggests in the comments](https://gist.github.com/Dr-Emann/93407b11c0ea404ae25a), you can use an `enum` for the `flags` section, and `FromStr` trait is a nice way to handle parsing a string (although, using a slice for the `name` is nice too, which isn't possible with `FromStr`). The below advice works fine if you have a custom parsing method with lifetimes (except for the one place I note below). &gt; Advice on how to handle errors Use [`Option`](http://doc.rust-lang.org/master/std/option/) or [`Result`](http://doc.rust-lang.org/master/std/result/) everywhere. &gt; unwrap()'s are ugly - how best to get rid of them? By propagating the errors, as Dr-Emann did. However, the repetition of the suggestion of `match from_str(...) { Some(x) =&gt; x, None =&gt; return None }` isn't particularly clean. You could flatten the `from_str` `Option` into the one you're matching on, something like: match (parts.next(), parts.next().and_then(from_str), parts.next().and_then(from_str), parts.next().and_then(from_str)) { (Some(name), Some(high), Some(low), Some(postability)) =&gt; { Some(GroupInfo{ name: name.to_string(), high_water_mark: high, low_water_mark: low, postability: postability }) } _ =&gt; None } This could also be written as a macro, similar to [`try!`](http://doc.rust-lang.org/master/std/macros/macro.try!.html) (more docs [here](http://doc.rust-lang.org/master/std/result/index.html#the-try!-macro)): fn from_str(s: &amp;str) -&gt; Option&lt;GroupInfo&gt; { let mut parts = s.words(); macro_rules! try_parse_next { () =&gt; { match parts.next().and_then(from_str) { Some(x) =&gt; x, None =&gt; return None } } } Some(GroupInfo { name: try_parse_next!(), high_water_mark: try_parse_next!(), low_water_mark: try_parse_next!(), postability: try_parse_next!(), }) } This is "abusing" the `FromStr` implementation for `String`, to enable all fields to be handled uniformly; but it means that if you do choose to use a `&amp;str` slice for `name`, you have to parse `name` specially (since there's no way to have `FromStr` for `&amp;str`: the lifetimes don't work): parts.next().map(|name| GroupInfo { name: name, high_water_mark: try_parse_next!(), // ... as before ... }) &gt; not sure if I understand lifetimes correctly - am I doing this right? If the compiler isn't complaining, probably. --- Minor point, but an iterator chain like splits. map( |x| x.trim() ). filter( |x| x.len() &gt; 0). map( |x| GroupInfo::parse(x) ). collect() would conventionally have the `.`s starting the line, i.e. splits .map( |x| x.trim() ) .filter( |x| x.len() &gt; 0) .map( |x| GroupInfo::parse(x) ) .collect() 
I am aware that I won't be able to store naked `str` anywhere and have to use `&amp;"literal"` (or rely on auto-ref) most of the time. I just think that it would be more consistent and less surprising if string literals were just `str` (and I'm almost sure that it will be possible with DST).
Some variant of this could be useful for creating an unmoveable value, e.g. if you are using unsafe code with invariants that would be violated by a move.
Thanks. That's great feedback, exactly what I was looking for
I think the last time this was discussed, some people didn't like the idea that you couldn't write a string literal without qualification (i.e., you need &amp;"..." or box "...." or something). I don't think the design has been finalised yet (there are currently problems around not being able to create values of DST string types, etc.) so it is something we could look at again. From a purely elegance/consistency POV, having string literals have type str makes sense (although that doesn't solve the problem of not having any fixed length string type, which, as the design currently stands, is the problem with DST strings).
In summary, it sounds like OpenBSD's malloc makes buffer-overruns and dangling-pointer dereferences more likely to crash. These are exactly the kinds of memory safety bugs that commonly cause security bugs! It's disconcerting to hear that this makes Firefox crash so frequently as to be unusable. The good news is that developers should be able to reproduce bugs you find on OpenBSD (even if they don't have OpenBSD) by using Address Sanitizer on Linux or Mac. In fact, last month, Gary Kwong decided to do all of his browsing using ASan builds of Firefox Nightly. He's found 3-4 security bugs this way. I wonder if they were the same problems you were hitting when using OpenBSD malloc -- you could try a recent nightly and see if it feels more stable.
The rules are more complicated than before, not less complicated. You will still need to cope with the error messages from the lifetime checking, but they're now invisible in the code. It makes the code look cleaner and it makes writing code quicker, but it reduces readability and will make error messages harder to understand. Lifetimes that previously had an explicit name in the API are now anonymous and will be reported as such in error messages.
Wrong subreddit, you want: /r/playrust this is about a programming language and cylons. PS. When did we introduce cylons? 
Cylons, not cyclons. ;)
I don't know what you are talking about. What's that about editing my post? Why would I do that?
Yet you used a capital 'I' to start your sentences. You also capitalized the 'H' in Haskell. Why is that exactly? Code is meant for humans too not just computers. The more we can do to make understanding the code easier for humans the better.
Cylons o.O 
I found the gist in [this comment](https://pay.reddit.com/r/rust/comments/29teem/an_experiment_in_forkjoin_parallelism_in_rust/cioesci) useful for comparing a few of Rust's concurrency primitives.
Some interesting observations &amp; guidelines about designing APIs with channels that could apply to Rust's APIs. Eg the signals API currently returns a Receiver. Perhaps it should take a Sender or SyncSender.
I've always felt like it would make sense for languages to have first-class support for testing, e.g. allowing tests to replace existing classes with mocks (where such a thing would be disallowed in non-test code.) I wonder if the Rust devs would be interested in trying such a thing.
After some experimentation, I think I have a promising direction for an abstraction for movable, self-referencing structures: [playplen](http://play.rust-lang.org/?code=%2F%2F%20Macro%20to%20create%20a%20%22view%20box%22%2C%20a%20box%20containing%20immutable%20data%0A%2F%2F%20plus%20a%20%22view%22%20struct%20that%20can%20have%20interior%20references%20into%0A%2F%2F%20the%20data.%20%20The%20view%20box%20can%20be%20moved%20around%20as%20an%20atomic%20unit.%0A%2F%2F%20I%20haven%27t%20completely%20convinced%20myself%20this%20is%20memory%20safe%20yet.%0A%2F%2F%20In%20particular%2C%20I%20need%20to%20make%20sure%20dangling%20pointers%20can%27t%20be%0A%2F%2F%20observed%20if%20the%20view%20struct%20implements%20Drop%0A%23![feature%28macro_rules%29]%0A%0Amacro_rules!%20viewbox%28%0A%20%20%20%20%28%24%28%23[%24attr%3Ameta]%29*%20struct%20%24name%3Aident%3C%24d%3Aty%2C%20%24v%3Aident%3E%3B%29%20%3D%3E%20%28%0A%20%20%20%20%20%20%20%20%24%28%23[%24attr]%29*%0A%20%20%20%20%20%20%20%20struct%20%24name%20{%0A%20%20%20%20%20%20%20%20%20%20%20%20data%3A%20Box%3C%24d%3E%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20view%3A%20%24v%3C%27static%3E%0A%20%20%20%20%20%20%20%20}%0A%0A%20%20%20%20%20%20%20%20impl%20%24name%20{%0A%20%20%20%20%20%20%20%20%20%20%20%20fn%20new%28data%3A%20%24d%2C%20f%3A%20%3C%27a%3E|%26%27a%20%24d|%20-%3E%20%24v%3C%27a%3E%29%20-%3E%20%24name%20{%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20mut%20res%20%3D%20%24name%20{%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20data%3A%20box%20data%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20view%3A%20unsafe%20{%20%3A%3Astd%3A%3Amem%3A%3Auninitialized%28%29%20}%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20}%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20unsafe%20{%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3A%3Astd%3A%3Aptr%3A%3Awrite%28%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26mut%20res.view%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3A%3Astd%3A%3Amem%3A%3Atransmute%28f%28%26*res.data%29%29%29%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20}%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20res%0A%20%20%20%20%20%20%20%20%20%20%20%20}%0A%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20fn%20view%3C%27a%3E%28%26%27a%20self%29%20-%3E%20%26%27a%20%24v%3C%27a%3E%20{%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26self.view%0A%20%20%20%20%20%20%20%20%20%20%20%20}%0A%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20fn%20unwrap%28self%29-%3E%20%24d%20{%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20%24name%20{%20data%3A%20box%20data%2C%20..%20}%20%3D%20self%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20data%0A%20%20%20%20%20%20%20%20%20%20%20%20}%0A%20%20%20%20%20%20%20%20}%0A%20%20%20%20%29%0A%29%0A%0A%2F%2F%20Test%20data%20structure%0A%23[deriving%28Show%29]%0Astruct%20TestData%20{%0A%20%20%20%20foo%3A%20i32%2C%0A%20%20%20%20bar%3A%20String%0A}%0A%0A%2F%2F%20View%20structure%20that%20has%20references%20into%20the%20boxed%20data%0A%23[deriving%28Show%29]%0Astruct%20TestView%3C%27a%3E%20{%0A%20%20%20%20x%3A%20%26%27a%20i32%2C%0A%20%20%20%20y%3A%20%26%27a%20str%0A}%0A%0A%2F%2F%20Create%20TestBox%20which%20combines%20TestData%20and%20TestView%0Aviewbox!{%0A%20%20%20%20%23[deriving%28Show%29]%0A%20%20%20%20struct%20TestBox%3CTestData%2CTestView%3E%3B%0A}%0A%0Afn%20main%28%29%20{%0A%20%20%20%20%2F%2F%20Create%20some%20data%0A%20%20%20%20let%20t%20%3D%20TestData%20{%20foo%3A%2042%2C%20bar%3A%20%22Hello%22.to_string%28%29%20}%3B%0A%20%20%20%20%2F%2F%20Move%20it%20into%20box%2C%20creating%20a%20view%20with%20interior%20references%0A%20%20%20%20let%20v%20%3D%20TestBox%3A%3Anew%28t%2C%20|d|%20TestView%20{%20x%3A%20%26d.foo%2C%20y%3A%20d.bar.as_slice%28%29%20}%29%3B%0A%0A%20%20%20%20%2F%2F%20Give%20the%20box%20to%20another%20task%0A%20%20%20%20spawn%28proc%28%29%20{%0A%20%20%20%20%20%20%20%20%2F%2F%20We%20can%20access%20the%20boxed%20data%20via%20the%20view%0A%20%20%20%20%20%20%20%20println!%28%22{}%22%2C%20v.view%28%29%29%3B%0A%20%20%20%20%20%20%20%20%2F%2F%20We%20can%20unwrap%20the%20view%20box%20to%20get%20back%20ownership%20of%20the%20data%0A%20%20%20%20%20%20%20%20println!%28%22{}%22%2C%20v.unwrap%28%29%29%3B%0A%20%20%20%20}%29%0A}%0A) Note that this is almost certainly not memory safe yet. It still needs some more work.
If you reduce dependencies and side effects by pushing inputs and outputs (side effecting method calls, really) upwards, you can test more easily, and have isolation that makes debugging easier. To me, mocks just feel like a poor imitation of the improvement to code quality that provides. For example, instead of: fn foo() { let a = internal_class_a.bar(); let b = internal_class_b.baz(); let c = internal_class_c.quux(); /* perform some useful computation */ internal_class_d.foobar(result); } have: fn foo(a: int, b: &amp;str, c: float) -&gt; MyResult { /* perform useful computation */ internal_class_d.foobar(result) } Some might argue that this just pushes boilerplate upwards, but I found that it makes modularity far easier to achieve, and gives you a clear separation between logic and side effects, which is useful for debugging. Instead of needing mocks for *internal_class_a*, *internal_class_b*, *internal_class_c*, and *internal_class_d*, you can now just create a test which calls *foo()* with some fake parameters, and observe the result. This isn't necessarily something you should always try to do, it can get ugly sometimes. It is a good idea to always be aware (and maybe even document) what the control flow inputs and outputs of any given class/struct/task/component/unit-of-state are, though. I like to consider things like socket listeners as inputs, instead of just methods, and factor them into my interface design accordingly. I do this to great effect (games mostly, which are very side effect-y), but YMMV. 
rust has the #[test] attribute which will only compile to actual code when rustc is invoked with rustc --test main.rs which runs the blocks of code with the test attribute. I'm not sure this is exactly what you want though. rust for rubyists has a section on [testing blocks](http://www.rustforrubyists.com/book/chapter-04.html) 
Yes, you're right. Now that I think about it my problem is a struct where some internal data changes. Just returning a new instance of it would make tests possible without mocks.
If you want to minimize macro usage, then you can also introduce a reader. (I think this is a matter of taste) struct WordReader&lt;'a&gt; { iter: Words&lt;'a&gt; } impl&lt;'a&gt; WordReader&lt;'a&gt; { fn new&lt;'a&gt;(s: &amp;'a str) -&gt; WordReader&lt;'a&gt; { WordReader { iter: s.words() } } fn read&lt;T: FromStr&gt;(&amp; mut self) -&gt; Option&lt;T&gt; { self.iter.next().and_then(|x| from_str(x)) } } /// The following macro behaves like try!, but it works on options /// Stolen from https://gist.github.com/emk/0e12337f64f4580b3af5 macro_rules! try_opt( ($e:expr) =&gt; (match $e { Some(v) =&gt; v, None =&gt; return None }); ) Then you can write impl FromStr for GroupInfo { fn from_str(s: &amp;str) -&gt; Option&lt;GroupInfo&gt; { let mut reader = WordReader::new(s); Some(GroupInfo { name: try_opt!(reader.read()), high_water_mark: try_opt!(reader.read()), low_water_mark: try_opt!(reader.read()), postability: try_opt!(reader.read()) }) } } The benefit from this approach is that you can use `and_then` inside `try_opt!` to do small changes to the values before you store them in the struct, and you can add specialized methods to the reader when needed. Ideally `reader.read()` should return `Result&lt;T,E&gt;` instead of `Option&lt;T&gt;`, so you get a proper error message, but that didn't work so well for me, because` from_str` returns an `Option&lt;T&gt;`. Disclaimer: I am still a newbie.
It doesn't however solve all problems. What if I have an object that returns a new object of that type but also updates some internally held data structure (referencing other objects)? It seems like it would be nice to stub out/inject that stuff without instantiating the exact type in question. Setting up the code to handle it seems like a lot of overhead. But maybe that's just the price you pay for static typing.
This is fantastic!
It's very common that database-driven applications have the database components at the bottom, not the top. Say, http server-&gt;REST handler-&gt;business service-&gt;data access layer-&gt;database (you can sometimes skip a layer if you don't need to support multiple dbs). Inverting it to push IO to the top would probably mean pushing connections, statements, transactions, throughout the whole infrastructure, which can get pretty messy and decrease cohesion. Besides, even if you could pass a connection as a parameter, say you're testing the service layer, you would still need to include a stub for said connection which would behave for components not being tested (i.e. the data access layer). This would make the test more fragile than it had to, as any change to the data-access layer would break a test for a component above it.
What he is suggesting is to use conditional compilation to make the class behave differently from production code. 
Link doesn't work for me :(
For Rust newbies like myself... it looks like this is displaying existing attributes of crates - item.stability.level. It'd be great if someone could explain how this works and how that stability data is chosen!
[Gist here](https://gist.github.com/bkoropoff/f6e87279882ae2cea353)
You can tag things with `#[experimental]` and such. We do need docs for this...
I like how this includes a discussion about accessibility. https://github.com/rust-lang/rust/pull/15586#issuecomment-48759899 This is the best moment for the Rust community to care about such things. If that work is done now, we don't have to change our docs later to be more accessible.
I hope the stability markers on each module or method are improved and shrunk soon. They make the docs so much more cluttered
Hey, It's awesome to see an official documentation effort presence (you) in threads like this, here and elsewhere. Is the list of topics that are severely lacking in docs documented somewhere? It's easy to say "everything needs docs" but it would be much easier for someone who wanted to contribute if there was a list of low hanging fruit to pick from. 
&lt;3. The best place is to find something that doesn't have a runnable example and give it one. This is super crucial and we're missing a lot of it.
Ah, I see. I'll have to explore that.
They aren't really Mozilla products, they're Mozilla research projects. (my flair lends too much weight to this statement, it's just my best guess.)
Right, should be possible to write a general `.make_unmoveable()` method with this. You don't need to actually store a reference in `self` to get the borrowing semantic that powers this code snippet.
They're on the Mozilla Research site instead: http://www.mozilla.org/en-US/research/projects/
type-safety around how a send to a "full channel" behaves would be nice too (type-safety for the slow-receiver problem). Sender vs SyncSender gives you a little bit of this control. but if a function allocates a channel and you just return a Receiver, you have no idea what's on the other side. even if you do allocate a syncsender and pass it in, you have no guarantees around whether the callee will use blocking or non-blocking sends. EDIT: now that I've thought about it more, I think Rust can do this with two traits: BlockingSender and NonBlockingSender. Forgive my lack of understanding Rust's syntax perfectly yet: // in io::signal impl Listener { // guaranteed to get all signals sent to process (if the OS doesn't drop them, of course) pub fn register(signum: Signum, snd: BlockingSender&lt;Signum&gt;) io::IoResult&lt;()&gt; // signals not handled fast enough will be dropped pub fn register(signum: Signum, snd: NonBlockingSender&lt;Signum&gt;) io::IoResult&lt;()&gt; } 
I initially got interested before the 0.1 release because it was coded in OCaml and because it looked like a nice functional language with a pragmatic approach. As months and years went by, it evolved (today, Rust is completely different from the one I got interested in), but the focus on safety, concurrency and performance remain, which is why my interest also remains.
discuss.rust-lang.org isn't showing anything on the page. It's 404ing on the following two GET requests: http://scdn-discourse.r.worldssl.net/cdn_asset/discuss_rust-lang_org/locales/en-27fa1316ff5c5aab9eaccd1c92996c55.js?origin=http%3A%2F%2Fdiscuss.rust-lang.org http://scdn-discourse.r.worldssl.net/cdn_asset/discuss_rust-lang_org/locales/en-27fa1316ff5c5aab9eaccd1c92996c55.js?origin=http%3A%2F%2Fdiscuss.rust-lang.org
sent to /u/cmrx64
Yep that works perfectly, thank you very much :-)
I wonder if here should be Sender, SyncSender and DroppingSender, where the latter drops messages on overflow rather than blocks the calling thread. That way a sending task could indicate by the type signature that it will not allow itself to be blocked by a slow consumer.
Would be cool if there would be compiler warning flag for this.
Eventually, `rustfmt` or something like it will end up reformatting code to largely be in this style. Of course, it can't always do everything...
I do really like this idea. I sometimes feel that if you take away the testability factor, the readability/tooling disadvantages of dependency injection outweigh the advantages.
I don't think you want it coupled like that. A function that sends into a channel probably does not care about whether the channel has a finite buffer or not (it might). I think you want to specify the behavior of how to handle blocking independently of that, so two traits: trait BlockSender&lt;T&gt; { fn send&lt;T: Send&gt;(&amp;self, t: T) } trait NonBlockSender&lt;T&gt; { fn try_send&lt;T: Send&gt;(&amp;self, t: T) -&gt; Result&lt;(), TrySendError&lt;T&gt;&gt; } You'd have to modify Sender to have a try_send method (which would just never return an error since it has an infinite buffer)
Out of curiosity, how pedantic is rustfmt expected to be? If a particular block of code is a lot clearer with odd whitespace (perhaps to align similarities between operations), would it clobber that sort of thing?
Unsure. How 'pedantic' is gofmt in this regard?
The dereferencing of `NodeRefToken` doesn't check if the Ref belongs to the actual tree value you deref it through, so you can "forge" mutability and an extended lifetime. But those methods are marked **unsafe**, so no real hole.
You're totally right. I considered adding tree ids, and even a timestamp of sorts so that tokens couldn't even be derefed *once* if a mutation has occurred since they were created. But then I would have to add a register_mutate hook to the tree and it just seemed like a whole wasteful mess. It's *very* easy to actively produce horribly incorrect results (I am my own parent) even when obeying all of the rules with or without a NodeRefToken. I strived to make it as lean as possible while preventing the most *obvious* errors, which seems in line with the Rust philosophy.
I am working on a generic doubly-linked tree structure in Rust, since this has been coming up a lot. It's an unfinished WIP: https://github.com/pcwalton/rtree The idea is to expose a "cursor", `NodeRef`, to move throughout the tree. There can only be one `NodeRef` available at a time, and you can mutate whatever node is pointed to by the `NodeRef`. Moving to another node consumes the `NodeRef`, enforcing this invariant. Eventually, `NodeRef` will expose iterators that allow you to traverse parents, siblings, and children, and to perform BFS and DFS operations. This should make it easy to do things like get temporary mutable references to the next sibling (`node.siblings_after().next()`), and such. I believe that, when finished, this will allow fairly easy construction of things like red-black trees, B-trees, AVL trees, etc.
Neat! Are you taking contributions? I find it interesting that your implementation is currently all raw pointers. How do you plan to handle allocation and destruction of nodes?
Pretty pedantic (which I like, personally). [This](http://i.imgur.com/9bGc55H.png) is formatted to [this](http://i.imgur.com/doLtpiA.png) with `gofmt` (plus aligned in first but not second img).
By the way, why are you not truly consuming the NodeRefToken (mark it NoCopy and take it by value); that way you can avoid the null check and the `fail!()` case.
 for x in range(0u,5) .flat_map(|x| range(0u,x) .map(|y| (x,y))) { println!("{}",x); } &lt;anon&gt;:4:42: 4:51 error: cannot infer an appropriate lifetime due to conflicting requirements &lt;anon&gt;:4 .map(|y| (x,y))) { ^~~~~~~~~ Oops! for x in range(0u,5) .flat_map(|x| range(0u,x) .map(|y| (x,y)) .collect::&lt;Vec&lt;(uint,uint)&gt;&gt;() .move_iter()) { println!("{}",x); } (1, 0) (2, 0) (2, 1) (3, 0) (3, 1) (3, 2) (4, 0) (4, 1) (4, 2) (4, 3) Program ended. Yay!
What's the argument behind avoiding block comments?
Good idea. Some of the NodeRefToken stuff was done before I fully understood how values get moved. I thought it was easy to copy/clone values (as in basically any other language), but that's not the case.
Hi, Rusty Clippy here! It seems like you are writing a halting function. Here are some alternatives to spicy up your program: 1. `0` 1. `.fold(0, |a, b| 0)` 1. `"".size()` 1. `1+exp(i*pi)`
Ah, just remembered. The token has to be taken by reference to have a lifetime usable by the return value! At least for the non exportable variants.
And why have them at all if they are unidiomatic?
Opening braces on the same line is a massive readability fail. [Allman style](http://www.terminally-incoherent.com/blog/2009/04/10/the-only-correct-indent-style/) is without a doubt the only sensible way to brace. :) 
Better they had gone with Nimrod/Python style indentation and gotten away from the brain-damagedness of braces all together. Look at some nimrod code and how clean it is: https://github.com/Araq/Nimrod/blob/devel/compiler/syntaxes.nim
It's the gofmt way or the highway! But then you rearrange your code so that it looks nice after being gofmt'd. I'd be happy with that. Yes, we could create wonderful ASCII art programs, but rename a variable and it all goes out of line, refactor it and it looks worse still. So it is much better to have a strict standard format that can still look good after some transformations.
For a while now, I've wondered if there'd be any value in making a TeX-inspired formatter. That is, rather than relatively simple binary rules, it instead defines a "badness" score, and attempts to minimise it. For example, instead of blindly wrapping long expressions as close to the line width as possible, it might split them so as to make the lines roughly the same length and avoid splitting subexpressions deep in the expression tree. Any formatting program that requires manual, post-invocation intervention to make the output "pretty" is not fulfilling its purpose. :)
(NB. the latter has allocations and is generally less efficient. The first will work with by-value captures/unboxed closures.)
They are useful when debugging.
Wow, that's some nice looking code! You're right, braces are pretty noisy. However judging by the downvotes, this is a minority opinion :)
i met all your stupid fucking rules. Rules: Respect our code of conduct. Constructive comments only. No memes. When mentioning other languages, keep the discussion civil. No zealotry! Chill out! A programming language is a silly thing to get upset over. Chris Morgan is a cylon Downvotes are for bad information or rudeness, not casual disagreement. Inept use of sarcasm will result in the revocation of your sarcasm privileges does your subreddit get dwarfed by a game that nobody plays? 
I upvoted!
Indentation can be a massive pain when programming however, I'd still opt for braces any day.
I write web applications in C#, hosted on Windows servers. I need something better. I can't get my colleagues to even consider the idea of using Haskell or Clojure. I probably would never get them to consider the idea of using Rust either, but at least I can learn it for myself. It's like my old jobs using C++ - that kind of predictable fast performance - but without C++'s holes and pitfalls (even though I find C++11 really awesome, it's still got all that baggage underneath). The only problem I really have with Rust at the moment is that it's not finished. Booo! I will have to be patient. In the mean time, I get to argue with people who think that it's the same as Go. By the way. Traits? Utterly brilliant. Typeclasses are one of my favourite bits of Haskell, making all sorts of things easier to handle, so to see something like that in a language like Rust is almost too exciting to handle.
The first clone is unnecessary, you shouldn't have to clone the value, push to it, and set it back — mutating it in place is fine. The second time you need to clone -- you're returning and owned string, which needs to be new. http://is.gd/Abe6mP If you want to avoid it completely you'll have to return an `&amp;'a` pointer (changing `&amp;self` to `&amp;'a self` and `Option&lt;String&gt;` to `&amp;'a str` or something).
Thanks! As a beginner, I was fighting that issue for a long time before I came up with a solution that even compiled! For the record, is there (or will there be) a way to specify whether to use by-value or by-ref for a specific variable? Or can all this be inferred from the lifetime of the object/variable?
I use tabs for indents, and spaces for alignment. I find this to be the obvious choice; it lets anyone adjust a project's indent size as they like, each indent is only one character which makes it way easier to navigate and modify, and alignment looks neat when you change tab indent size due to using spaces for alignment. I've thought quite a lot about this, but can't really come up with any pros for indenting with 4 spaces whatsoever. It's harder to modify and navigate, especially in text editors, but also in IDEs which implement various "hacks" to make the experience smoother. You have to actually change every single line in the project to make it suitable to your likings, which breaks it for everyone else. So, I ask, what is the reason 4 spaces are chosen here? EDIT: Note, this isn't intended to be flamebait. I'm genuinely curious as to why four spaces have been chosen, and generally seems to be the default in many text editors and IDEs.
because you get a consistent indent in any editor with any settings for tab width
In the traits section, what is meant meant by derive rather than implement?
[The `#[deriving]` attribute](http://doc.rust-lang.org/master/rust.html#deriving).
Thank you. Link for the lazy: http://doc.rust-lang.org/rust.html#deriving.
Er... my whole comment is a link (that link, in fact).
Strange! For whatever reason BaconReader doesn't display it as a link. I'll check if that is a known bug.
I find it very strange how bikesheddy things (e.g. brace style) are bundled with things which have concrete motivations (e.g. the safety guidelines). As a user of your library, I don't care what indentation style you use or where you place your braces... but I do care how you name your types, what features you use and how (in the public facing API) since they will affect my code. As a user of your application, I don't even care about that... you could avoid indentation entirely. As a contributor to either I'd just learn the 'house' style and format my code accordingly... been doing this whe contributing to C/C++ projects for years without any issue (I think I encountered all the major indent styles and brace styles... I just went with it). In practice, the variation in how language features/APIs are used are a lot harder to adapt to and that is what this guide should emphasize. It'd really be nice if these suggestions had importance levels along those lines, so that when I don't follow some I can cite their relative unimportance.
Configurable tab size interacts poorly with line-length limits. 
&gt; You should not be mandating things which are subjective. ... That is mandating something that is subjective ;)
Because coding is a social activity. You don't only ever look at just your own code.
If you're ending up with types like `Option&lt;Option&lt;Option&lt;Node&gt;&gt;&gt;` have you considered using ~~flat_map~~ `and_then`?
&gt;The Rust Programming Language Not really. But players post in this subreddit alot.
But this way you can't be sure if line is too long because it really is or just because of your tab size settings.
To have per codebase editor configs for the same language seems like a really bad idea. The whole style guide is subjective but it won't make you less productive for following it.
They can lead to confusion when nested.
That works for viewing code, but what about creating code? How many characters do you tell people with an 8-space tab stop to limit their lines to? "Depends on the number of tabs in your line" makes for a poor, difficult to follow style guide. Opt for the path of least surprise. In this case, spaces instead of tabs keep things nice and uniform for everyone. When you're dealing with a large number of programmers, it's a good way to make sure everything works smoothly for everyone. Probably the argument would be different if there were a good standard for tab sizes, but there isn't. In unix, it's eight characters. In windows it's five characters. Most (unix) programmers adapt it to four characters, because eight is just too many, but that's not the standard, so other people use half-tabs (four spaces for an indent, a tab for two indents, a tab plus four spaces for three indents), but that's just ugly, and subject to easy mistakes. Tabs are fiddly; spaces are simple and consistent. When dealing with a community standard, simple is a major virtue. 
Hi. I've been working on the `rustfmt` lately and the only answer I have is: yes. Right now the `Formatter` (the thing that takes a token stream from the lexer and pretty prints it out) is based on linearly interpretting the tokens and making largely context-free decisions about when newlines start (opening braces, semicolons, closing braces, etc).. I've just started adding a little of context around that and I've quickly found that a more holistic, at least statement-level, solution is needed. There's a lot of display optimizations to be had and one particular thing I want to do is enforce the 100-character line width guidelines, if possible. It definitely requires statement level formatting so the tool can make decisions, within a single statement, to split lines/indent on parameters to functions, chains of methods of calls, etc. I also have some other nefarious ideas that came to me in a dream for things a tool could do if we had statement level formatting, but I'll leave that for another time...
Rust support nesting block comments
I find the guidelines for cross-platform code a bit surprising. Cross-platform code by #ifdefs is frowned upon in C, but seems to be recommended for by the style guide. I'd expect the code for each specific platform to be in its own file so that team members developing for different platforms can work independently and avoid merge conflicts. The platform specific file is then selected by the build system. This also means that the compiler isn't spending time parsing code that is ignored.
Awesome! :D Perhaps I can look forward to, one day, getting `overfull hbox, badness 10000` errors from rustfmt. :P
Oh right thanks, I'm not actually a rust programmer so I wasn't sure.
&gt; Explaining lifetimes to C++/Go programmer is like explaining type checker to Python programmer at least C++ programmers will have encountered pointer bugs, so they'll have a sense of a need for lifetimes.
Thanks for the explanation! I'm intrigued, and will take a look at it closer. I'm working on some concurrent data structure code that is giving me hell to debug. Logs are either too verbose, or too sparse. Would be nice to dynamically pull different probe points.
Rust is already quite naggy :-) You get warnings for variables, statics, types or methods with the wrong casing.. It's a bit silly IMO, but it can be turned off. Likewise I'm sure the style guide can be ignored. I think the indentation guideline is a good thing, some people will ask what the general rule is, and we'll have an answer for them that they can use if they want to use the most commonly used style for Rust.
I think the thing is with purely spaces, you can align line continuations and similar with extra spaces without trouble. It's all been tried out before. I think space indents are chosen because of the experience people have with different styles.
Please use tabs, so every one can easily use their favorite size (3, 4 or 8 spaces) and if you are using tabs you don't waste 4 characters for one indentation. Line-length limits are simply not a problem with 2k and 4k screens today.
Pretty easy, i totally hate seeing tabs in a file, every editor has different settings for it and never looks good. With spaces I can open it EVERYWHERE and it will just work and look nice, no need to configure anything and I can start editing code and I know it will not have a mix of tabs and spaces that will look bad and not align. Every editor I know has the simple setting of defining ident style and tab key to 4 spaces. Simple, easy, good. I tried to understand how to configure the crazy tab like you suggest and it's crazy confusing and all editors name the settings different and it's too much overhead trying to understand all the combinations of spaces + tabs + indent, etc. Good for you that you never leave the same editor and that you never change pcs so you can configure everything just the way you like.
&gt; I've seen .unwrap() in other tutorials but havn't been able to find a difference between them or a reason for using one over the other. It's just like /u/Kimundi said. `unwrap` fails with a generic error message, `expect` fails with the given error message. If you're pretty sure it won't fail, `unwrap` saves typing.
It also produces better diffs when you change the function name or change its visibility. I think this is a good enough reason to avoid aligning things in general.
I dislike the documentation rule "prefer full sentences to fragments". Frequently, noun and verb phrases are sufficient for the definition's summary. I especially dislike it when authors feel compelled to write something along the lines of "this function does *x*" or "this method does *y*" simply to provide a subject. For referentially transparent functions, I generally like to use noun phrases because otherwise the majority of summaries end up being "returns *x*" when they could simply be "*x*". At any rate, it may just not be clear to me what "prefer" means, since the example uses sentence fragments appropriately for documenting arguments. Using verb phrases for documentation summaries is possibly the only good diktat in the official Javadoc style guide. However, it might be nice to explicitly avoid the Javadoc standard's awful decision to *mandate* separate documentation for arguments and return values for every method. The majority of the time this results in an author copying the summary into the return field and repeating the name of a parameter for its description. While you could simply blame this on laziness, I would argue that the majority of functions are not complex enough to warrant an extended description of their return value, nor *should* they be. Intentionally absurd example: /// This function returns a copy of the given list with its elements sorted. /// /// # Arguments /// /// * `list` - This is the list to be sorted. /// /// # Return value /// /// Returns a sorted list. 
Yes, that has been my experience as well. Another one of my pet-peeves for that context is not being able to have trailing commas in a list.
Yes, I said "not being able to" :) For example repetitions in macro invocations can't have easy trailing commas, and at least the rustc from 2014-07-04 complains when I have trailing commas in type parameters and arguments. Addition: It also appears the same version doesn't like them at the end of method call arguments, at least on literals.
Ahh, I didn't realize there were places where you couldn't.
Or rather, people should just stop quibbling over minor style differences like that and just tolerate that other people like to put braces differently than them (and respect it while working in other people's codebases).
I was assuming it was intentional :) I run into this all the time because when I break up things into multiple lines I always put trailing commas in.
Shouldn't that be an editor feature instead of a language feature? Most editors can so something like ctrl-shift-c to comment out a selected block.
Not, it should be always format like X (with the help from rustfmt like go), we don't want another python
It's a great thing, you don't want apis all with different naming and casing rules
Why a different convention for static constants, variables&amp;parameters, and enum elements? I find I often start with static constants and change to enums as my code evolves, or vice versa. Ditto for constants and parameters. Different naming conventions would make those an expensive refactor (without tools, which don't exist at the moment). 
C is "cryptic" only if you're new to it. And the LMDB code base is actually much smaller than 10kloc; more like only 6kloc of actual code - the rest is comments. It's *much* more reliable than larger code bases; the small overall size means it's actually feasible to write unit tests giving 100% code coverage. (We're currently at 80% but haven't been focused on it.) And when we get to 100% coverage we will be able to confidently state "yes this code is 100% bug-free" - something you will never be able to say about the larger projects. Productivity as a programmer comes from experience - that's it. My experience began with a simple language (BASIC) and then immediately delved into assembly language. Once you're comfortable with asm, C is a breeze and you can master anything else. But if you've only ever used simple/high level languages, you will view every new challenge as cryptic and incomprehensible.
Different naming conventions help you tell them apart at a glance, since they are different things.
I used to do that too. But in order to allow switching tab size, you must be pretty religious about using tabs only for indentation, then continuing with spaces to align thing like wrapped function call parameters. This is rather hard to get right, unless you get into habit of periodically switching tab size and fixing bad indentation. Even if you set your editor to visualize tabs and spaces, indentation slip-ups still occur. In the end, I'd decided that this is more trouble than it's worth and had been happily using 4-space indentation ever after. As for "why 4?", well, because it's not too much and not too little (and is a power of 2 :).
We've already switched public-by-default to private-by-default. I don't remember a lot of the discussion, but I bet you could find it on rust-dev. I personally prefer private-by-default. Whitelists &gt; blacklists. &gt; Honestly I never felt the necessity of having a public a private distinction, adding __ to tell the reader that function is not supposed to be used it's okay. Won't this cause unintended interface changes? I'm thinking like ABI breakage.
&gt; I don't agree with this either ;) I don't care what order source files are in, I care about what your documentation says. That's what people will use, and that's what really defines an interface. Of course, I have bias here too... and I totally understand this from your `role`, however, that's lead to the good practice of the coder to write proper docs, unfortunately that's not always the case :( That's why most of the time I just use `octotree` and browse the source. Also consider that I do that to learn the code style the idioms etc... &gt; Apparently I'm feeling contrary today. No worries, will be a sad world if we had all the same ideas. You can learn a lot from a different point of view.
&gt; C is "cryptic" only if you're new to it. I shouldn't of been so absolute about it. However, when you end up having a ton of C "macros", it makes it more cryptic than not. Versus a language that contains AST-based macros (like Rust), you can get a clear sense of what's happening. (I actually really like C) &gt; And the LMDB code base is actually much smaller than 10kloc; more like only 6kloc of actual code - the rest is comments Gotcha! I had a feeling it wasn't *that* big, but I thought it was around that ball park. &gt; It's much more reliable than larger code bases; the small overall size means it's actually feasible to write unit tests giving 100% code coverage. Oh absolutely! And that's a massive strength of such a project. Unfortunately, this is quite rare to achieve. LMDB is one project out of many. And many more are being created all the time. The point being, it's hard to trust a new solution created in an unsafe language with your data (heck, while we're talking about databases, it's hard to trust your data with *any* new solution built in *any* language. It's just that safer languages give you less things to worry about).
Adding `__` to a function signature to tell the user that it shouldn't be called in client code might be fine in a "consenting adult" language like Python, but Rust is being designed that so it could potentially be used in integral software, like the Linux kernel. Exposing private APIs in sensitive software like that could be very dangerous, or lead to undefined behavior. Having everything below `#[!private]` might be fine for you in how you organize your code, but you can't say that for everyone. I personally like to keep my public functions near the private ones that they abstract over, to limit jumping up and down in the source file while coding. Related blocks of code are clumped together. I don't think a single three-character keyword makes the language more verbose or harder to read at all. It's useful information. Rust's vocabulary is already very concise.
Is the meaning of the various stability levels documented anywhere? I'm unsure of the difference between unstable and experimental.
One of the design goals of Rust is to not assume anything about the user's editor or require an IDE
Fwiw, passing closures as function arguments is always a bit awkward with indentation for scope.
Yes, that's obvious as a generality. However, I was asking because in *this specific case* the similarities seem much more important than the differences.
To me, braces-on-the-same-line style had always seemed like an attempt to sweep these pesky braces under the rug by a developer who'd rather be coding in Python, but is forced to use C++. If you truly love your braces, you should display them proudly, on a separate line!
The code here is not valid Rust...
From the [docs for std::option](http://doc.rust-lang.org/std/option/) &gt; This usage of Option to create safe nullable pointers is so common that Rust does special optimizations to make the representation of Option&lt;Box&lt;T&gt;&gt; a single pointer. Optional pointers in Rust are stored as efficiently as any other pointer type.
Oh wow, I don't know how I missed that. I'm sorry! Thanks.
I think you're right that the code would be fine without it. I included it because I thought it was a good way to show that the socket could be closed explicitly (it looks like you can only close the read and write channels separately using TcpStream methods). It could be useful if you want close the connection before doing something time-intensive in the same scope. The documentation example also calls drop: http://doc.rust-lang.org/std/io/net/tcp/struct.TcpStream.html#example
Great server, played on it all day yesterday. Absolutely no lag, and the Admins are so friendly!
Even more neat, a patch recently landed that let's `Option&lt;&amp;[T]&gt;` compile down into essentially a `(uint, uint, *T)`, where `None` is represented by the pointer being `NULL`. Not all options are free of course. `Option&lt;int&gt;` compiles down into essentially `(uint, int)`.
Hello all. Wrong rust. You're looking for /r/playrust. 
BTW, [the `try!` macro](http://doc.rust-lang.org/master/std/result/#the-try!-macro) ([definition here](http://doc.rust-lang.org/master/std/macros/macro.try!.html)) is provided to make the sort of short-circuiting matches you are doing as nice as possible, i.e. `fetch` could be written as fn fetch(code: &amp;str) -&gt; IoResult&lt;Vec&lt;u8&gt;&gt; { let mut stream = ...; let data_get = ...; let data_headers = ...; try!(stream.write(data_get.as_bytes())); try!(stream.write(data_headers.as_bytes())); stream.read_to_end() } Similarly, many other common ways to wrangle [`Option`](http://doc.rust-lang.org/master/std/option/type.Option.html) and [`Result`](http://doc.rust-lang.org/master/std/result/type.Result.html) are provided as methods, e.g. one could write `str::from_utf8(v.as_slice()).unwrap_or("")`. (NB. the argument to `unwrap_or` gets evaluated unconditionally, so if it is expensive to compute, `.unwrap_or_else(|| value)` is better: the closure will only be called in the `None` case.)
(Well, for `&amp;[T]` and `Option&lt;&amp;[T]&gt;`, it's just `(uint, *T)`.)
i think your code is ok. I am not a huge fan of the ubiquitous pattern matching (You can replace some of them with functions as dbaupp pointed out). Also `err.detail` is not always available(`Option&lt;~str&gt;`), so might be worth trying `err.desc` instead. 
I was following [BitC](http://www.bitc-lang.org/) for some time and someone at #ocaml at Freenode mentioned the project wouldn't go anywhere, because it wasn't a practical language; it tried to bring unproven research ideas like region typing to low level code. Eventually yes BitC was abandoned. There's a post morten [posted](http://lambda-the-ultimate.org/node/4490) to lambda the ultimate. [At another post](http://www.coyotos.org/pipermail/bitc-dev/2012-May/003469.html) is a bit of discussion, where the creator of the language says &gt; I would really like to see an example where an unsafe escape is required. I know of exactly two such places (..) Every other use of unsafe code that I have seen exists to correct a deficiency of the language design, most commonly in the area of arrays vs. vectors or in the area of low-level I/O. There are known strongly-typed solutions for both cases. Which contrasts with the Rust approach of accepting unsafe blocks occasionally, and letting people wrap them with safe interfaces. Well I think that Rust may be a sweet spot between safeness and practicality, at least for the time being. If it gains momentum it may improve many critical areas of computing. There's already a lot of libraries that perform things I'm interested on so there's an incentive to experiment with it. The other language that tries to produce low level, safe code is [ATS](http://www.ats-lang.org/). It seems pretty mature and I don't know exactly what are its shortcomings (other than the unfamiliar syntax).
&gt;`Option&lt;int&gt;` compiles down into essentially `(uint, int)` Is that for alignment? `Option&lt;u8&gt;` only seems to take up two bytes.
`let &amp;Board(ref mut arr) = self;` Or, you might be better off using a structure with named fields, because then you can access `self.fieldname` directly.
Yes, it's really `(u8, int)` (enum tag sizes default to the smallest type that fits the full range of values, i.e. almost always `u8` in practice), but alignment makes this equivalent to `(uint, int)`.
It seems I was trying too hard to use the tuple struct as a newtype. I'll go back and change the code to use a named field. Thanks for the quick help!
`all_same` could be written cleaner using `match`: fn all_same(a:Option&lt;Player&gt;, b:Option&lt;Player&gt;, c:Option&lt;Player&gt;) -&gt; bool{ match (a, b, c) { (Some(a), Some(b), Some(c)) if (a == b &amp;&amp; b == c) =&gt; true, _ =&gt; false } }
Done. Thanks again!
I think we had discussions like this back when the debate was "structured programming" vs non-. And the final answer is "you can write spaghetti code in any language." Given the relative newness of rust and the immaturity of its ecosystem, my trust in it is far less than anything written in C. A lot of new languages have come along, promising one thing or another, but never living up to that promise. (e.g. Java's "write once run anywhere" is now "write once debug everywhere") And as for unsafe constructs in the language - IMO the correct approach is not "this is unsafe, so we are taking it away from you". The correct approach is "this is unsafe, so learn how to use it with great care." I much prefer tools that give complete access to everything, and leave it to the user to use them correctly, because that means you can get the best possible results - if you use them correctly. The rest is about programming discipline. 40% of the LMDB codebase is comments - everything is documented in depth. You would do the same, in any language. Relying on the tool to prevent you from making mistakes is futile. People will write awful programs in rust, just as much as they do in any other language. In the meantime, putting in a lot of safety mechanisms will just get in the way. (Look at how often java folks resort to off-heap/unsafe memory management now, to escape the unpredictable latency of the GC.) It's like saying "damn, it really hurts when I'm trying to hammer in a nail and I accidentally smash my thumb. I'm going to design a hammer with a foam-padded head so it doesn't hurt any more." - that's great for your thumb, but the hammer won't be much use on nails any more either. Programming requires care and attention to detail. You *should* be worrying about everything, at least once. You keep the list of worries manageable by solving small pieces at a time. Do that, and you can create great code. Rely on your tools to be smarter than you, and you will only ever create mediocre code at best.
But integers are isomorphic to an enum (you could have an enum with finite values: Zero, One, Two, ..., and implement its operations by pattern matching), why would be enums easier to statically check?
Your link says the domain name expired yesterday..
There are a lot of ways for reporting errors in Haskell and apparently everyone does it their own way. Check this article: [8 ways to report errors in Haskell](http://www.randomhacks.net/2007/03/10/haskell-8-ways-to-report-errors/) (also the [update](http://blog.ezyang.com/2011/08/8-ways-to-report-errors-in-haskell-revisited/)). Way 1 are ugly exceptions, that can be called from pure code and have only a string to describe the error. 2 uses Maybe which is like Option, 3 uses Either which is like Result. Number 4 lets the caller decides if they want to treat it as Maybe or Either (and is also compatible with the ugly 1 method) while not being too heavy, so I like it. Number 5 lets you to have custom error types, better than returning an error string. Also see [this](http://www.haskell.org/haskellwiki/Error_vs._Exception), the function "error" from the method 1 can be understood to represents a divergent computation (like an infinite loop) that for convenience just aborts the program with the error message. I think that's the justification to put it on pure code. But you can caught it anyway and use it as an exception handling mechanism. Edit: also in Haskell you can use Maybe to report an error but still bubble the error up like exceptions when you find adequate, because Maybe is a monad. I encountered this problem in OCaml: there's an Option type there that I used for errors, but whenever I needed to use Option types I needed to match against it, and this sucks (like, uh, callback hell sucks in node). A poor's man alternative to do so in Rust (and also OCaml) is to just map over the Option, like this: fn f(x: int) -&gt; int { 2 * x; } fn main() { let y = Some(10); let z = None; println!("The double of y: {}", y.map(f)); println!("The double of z: {}", z.map(f)); } Note that f doesn't handle with the Option directly but abstracts error handling. But instead of receiving a x, f could be calling an additional function g to get the integer; g, for error handling, could be returning an Option. You would like to have f oblivious to whether there was an error or not in g - if there is an error at any point, just collapse everything to None (of course in real code we would like to have Result and return the error of the part that actually contained the error - the code wouldn't change much). So in the end, map doesn't work, but and_then works: fn g(x: int) -&gt; Option&lt;int&gt; { if x &lt;= 0 { None } else { Some(x - 1) } } fn f(x : int) -&gt; Option&lt;int&gt; { g(x).and_then(|y| Some(y * 2)) } fn main() { let y = Some(10); let k = Some(0); let z = None; println!("The double of y-1: {}", y.and_then(f)); println!("The double of k-1: {}", k.and_then(f)); println!("The double of z-1: {}", z.and_then(f)); } (ps: I've been meaning to try it for the past months, but the two above snippets were actually the first time I wrote anything in Rust) Anyway, both approaches are unidiomatic in Rust (and in OCaml). But there's OCaml code that's written in this horribly ugly style because it's very useful to decouple normal code from error-handling code. OCaml has exceptions too but they suck. At this point you start to appreciate how Haskell get this right: you can just use do notation to handle Maybe values disregarding whether they are errors, that basically get converted to something like the second example because and_then [is just monadic bind in disguise](https://mail.mozilla.org/pipermail/rust-dev/2014-February/008798.html). The Haskell version also won't care if the concrete type is Maybe or Either, it works on any monad. Apparently someone [proposed](https://mail.mozilla.org/pipermail/rust-dev/2013-December/007510.html) a syntax to alleviate this.
That was the essentially bit. The size of discriminant is actually unspecified so we can use whatever is efficient. However if you need a c-compatible discriminant you can use `#[repr(C)]`.
Ah, right, thanks. 
Allows for design by contract-style pre- and postconditions on Rust functions. E.g., #[precond="x != 0"] #[postcond="result != 5"] fn foo(x: int) -&gt; int { println!("hello world! {}", x); x+5 } See https://github.com/nick29581/libhoare/blob/master/eg/lexer.rs for a longer, more realistic example. Its pretty early days for this. One of the biggest issues is that it only works on functions, not methods. That needs a fix in rustc, but I think that is in the works. Let me know what you think - PRs and feedback are most welcome.
Why not use 'return' to represent the returned value so there's no possibility of confusion if you use 'result' in the body of a function, as you do in that lexer.rs example in tokenise. EDIT: ok, looking at the implementation it's obvious that would be substantially more fiddly. _result would seem preferable to me though
This is an update due to the change from `crate_id` to `crate_name` that will break all symlinks, because the Rust compiler now outputs the library to a different file. The recommended fix is the following: 0. Replace the Makefile with the new makefile (remember to set DEFAULT = lib) 1. Delete all the symlinks in the 'target/deps/' folder 2. Build with Cargo using `cargo build` (add a -u flag if necessary) 3. Replace the libraries with new symlinks one by one, using `ln -s &lt;from&gt; &lt;to&gt;`. Notice that the paths needs to be absolute. 4. `rm build.sh` 5. `make symlink-build` (which will generate the new build.sh script) A symlink a file that points to another file. By using a symlink build script generated by `make symlink-build`, you rebuild all dependencies locally with the command `./build.sh deps`. This is very useful when working on multiple repositories at once. The ownership is moved to PistonDevelopers, which is an open source organization developing game related Rust libraries, and is the biggest project using Rust-Empty. This will make it easier for other people fix Rust-Empty, because everybody in PistonDevelopers has write access to all the repositories. I will continue to maintain Rust-Empty under PistonDevelopers. Having vacation right now, but will try to check in at least once a week. If you have questions or feedback, I will answer them in this thread (if I'm online).
Yeah, return seemed difficult since it was a keyword, I guess it would still be possible by doing a textual subst of the predicate string before tokenising it. I should probably do that... result will never clash with anything in the body because they are in different scopes, but it does mean if you have an argument called result, then you can't test it in the postcondition, which is a shame.
Yeah, as /u/dbaupp also explained it to me. It's not the sort of parametric polymorphism I've been accustomed to thinking about, but it does seem like it might work.
Is this named after Graydon Hoare?
I think it's a reference to [Hoare logic](http://en.wikipedia.org/wiki/Hoare_logic), but there's probably a wink to Graydon Hoare too. :)
When I saw it I immediately thought of axiomatic semantics, but he taught at my university so it was fairly well drilled into us.
Should I file this as a bug? Anyone have any ideas?
Can it do something like: #[postcond = "self.x=\old(self.x)+1"] fn inc(&amp;mut self) { self.x += 1; } I am really looking forward to a formal specification of the language, I hope we will get static analysis tools.
Why is the tag not added at the end?
&gt; I hope we will get static analysis tools FWIW, we already have them, several of the compiler's lints/warnings do some (slightly) non-trivial static analysis (and many/most do trivial static analysis... but it's still static analysis). This is improved now that rustc offers lint plugins, so users can simply put their own analyses directly into the compiler with all its infrastructure. (Of course, this direct API is highly experimental, subject to change and is unlikely to be stabilised with the 1.0 release, or for a while into the future.)
Any enum isomorphic to `Option` will behave this way (e.g. `Result&lt;T, ()&gt;`): when containing data with nonnullable pointer type, the variant with data is represented as the data directly, and the variant without any data is represented by setting the pointer to NULL.
Why the parentheses around the guard condition? It’s superfluous.
I'm not really sure I like the proliferation of places to keep track of. I'm surprised the forum seems to be aimed at rust-internals type discussion. Usually you'd expect the end user discussions to be moved to a forum with a mailing list kept for dev discussion. It's not at all clear to me when something should go to rust-dev vs discuss.rust-lang.org EDIT to add: in fact, a lot of the discussion currently at discuss.rust-lang.org seems more relevant to "Rust practitioners" than purely rust-internals devs. e.g. discussions of style guides, indentation, rightward drift, column limits and the like.
It doesn't matter, it's just like a struct and `{ int, u8 }` would need padding the same way that `{ u8, int }` does.
You could rewrite `all_filled` this way: fn all_filled(&amp;self) -&gt; bool{ self.board.iter().all(|row| { row.iter().all(|slot| slot.is_some()) } } Additionaly, in `print_board`, you could use pattern matching: match slot { None =&gt; print!("E"), Some(player) =&gt; print!("{}", player) }
Thanks for your answer. Yes I shouldn't have used the first clone() as it made my question more confusing (I wanted to avoid the second clone). What I meant is that I am having this sort of issue whenever (like in this case) the next value in the iteration depends on the previous one and I'm not iterating on Copy types. I want to store the current value as state for the next time I call next() but I can't without cloning it. I tried storing references, but I don't know if that is possible. Or maybe I could not find the right combinations of lifetimes...
The mailing list should go away if this is where discussion is supposed to happen.
Look at "Not all Option are free" from above.
Neat, I did not know that
I tried the [and_then shenanigans](http://www.reddit.com/r/rust/comments/29ywdu/what_you_dont_love_about_rust/civzlk0) and it looks unidiomatic and also unreadable. Nobody will want to write code like this. There's an alternative std library in OCaml, [Core](https://ocaml.janestreet.com/ocaml-core/latest/doc/), that features monads and invites people to write ugly code like this (there is no do notation in OCaml, nor typeclasses). In the OCaml case there's a [macro](http://www.cas.mcmaster.ca/~carette/pa_monad/) to alleviate this, but I don't think that Rust macros are syntactically convenient for writing blocks of code (they all look like function invocations). Perhaps having the option of having macro! { a; b; c } instead of macro!(a, b, c) would be nice.
rust-dev isn't really used for dev discussion, hasn't been for over a year. I expect it go away in favor of a rust-announce or somesuch.
note: The other commands such as 'locate-project' work OK.
It's called `cargo compile` now.
That doesn't seem to match a command either.
To elaborate, I'm using the latest mac nightly.
As someone who reads the mailing list, I really don't see how you can claim that. There are plenty of discussions on there about development of Rust (as in the code in https://github.com/rust-lang/rust).
 let res = { let s = do_generate_string; std::str.lower(s) }; std::stderr.write("{}", s)
No, currently you can't put syntax extensions like this on methods. But I believe jclements is working on it and then adding support here will be very easy. Having something like `\old` is not supported atm, but it could be without too much hassle.
&gt;To me, braces-on-the-same-line style had always seemed like an attempt to sweep these pesky braces under the rug by a developer who'd rather be coding in Python, but is forced to use C++. If you truly love your braces, you should display them proudly, on a separate line! http://c2.com/cgi/wiki?OneTrueBraceStyle We were sticking the brace there before C++ existed. You have no business judging people on the basis of brace position. To me, you seem new and confused. It is fine if you do not like the style of older programmers, but suggesting we cannot handle C++ is a load of crap.
Few to none of the core team or many long-time contributors use it, which is the problem.
Filed issue 2 for this - https://github.com/nick29581/libhoare/issues/2
This works fine for one subexpression, add 5 sequencial declarations plus conditionals, match blocks and error handling and you get a lot of syntactic clutter. I'm using some versions of the macros above for my own software, but having to match closing parenthesis/brackets for each declaration is not only error prone but also waste of time.
Great overview, but unless I've missed some recent change, he seems to have skipped linear types completely. &gt; let r0 = box [1i,2,3]; // r0 has type Rc&lt;Vec&lt;Int&gt;&gt; Surely that should be Box&lt;Vec&lt;int&gt;&gt;, right?
I always have trouble explaining why the 4 points above are good for library design, because it is very subtle. The article did not ended up as well written as I intended, but I hope it gets the point across.
I'd definitely read up on the concept of ownership in Rust. In Rust, everything is "owned" by something else. You can borrow a reference to something that is owned, but from that reference you can't just take ownership of the object. In your example, the WheelTimer's ring Vec owns the Nodes it contains, so the compiler won't let you just take ownership of those Nodes. If we look at the second error: // Get the node at the current tick in the wheel let node = self.ring.get_mut(self.currentTick); // Clear it *node = box Nil; // Return the node that was in that spot return **node; get_mut will return a reference to the Node, but with just a reference to the Node you can't take ownership of it. However, we need ownership of the Node, because the method signature (fn tick(&amp;mut self) -&gt; Node&lt;T&gt;) says you're going to return a Node, not a reference to one. In this case, you want to pull the Node out of the Vec anyways, so we can take ownership of the Node from the Vec. Instead, you can do: let node = std::mem::replace(self.ring.get_mut(self.currentTick), box Nil); // Return the node that was in that spot return *node mem::replace will replace the Node in the Vec with Nil and give you ownership of the Node that was previously there. Now you're the owner so you're free to do what you like with it, so we can return it.
One little known feature about Cargo is that it currently supports multiple **packages** per git repository. Each package has its own library, its own tests, its own binaries and its own dependencies. When someone adds a dependency to a package, only the package itself and its dependencies will be compiled, even if there are other packages in the same git repository. As long as you manage everything through Cargo, there shouldn't any conflict. Obviously you should split packages that are not closely related to each other into multiple repositories, but there is no technical reason that pushes you to do so. 
seems needlessly complicated. Why not just code it straight in Rust code. like Guava Preconditions in Java: https://code.google.com/p/guava-libraries/wiki/PreconditionsExplained No need for macros, you just code it in the first lines of any method. No magic needed, any IDE will probably do code completion (once it is there for Rust), etc. To me this it looks like unnecessary magic vs just straight code, which I thought was the Rust philosophy
It's actually `Box&lt;[int]&gt;` at the moment, and will become `Box&lt;[int, .. 3]&gt;` in future.
No problem! I wish I could recall some good documentation on ownership to link you; hopefully if anyone reading this knows of some they can link you. I replied to myself with some other general feedback, hopefully it's helpful! Let me know if there's anything I can clarify. Good luck learning Rust, I hope you're enjoying it :)
I always prefer 'real' code to macros, but I believe macros are the better choice for two reasons (one hard, one soft) - its the only way I can see to implement postconditions (I considered an RAII object, but couldn't see a way to name the result of the function, or to avoid referencing an argument - which would break any mutable references, which are the only arguments worth checking in a postcondition). Secondly, pre- and postconditions are part of a functions signature and therefore should be part of the declaration, not the body. An assertion at the top of the body is easy to miss and doesn't look like part of the public interface (and is a macros too, of course), whereas a precondition as implemented here is clearly public. That should be useful for tools (some day) as well as human readers.
Nowhere in the article is it mentioned that Rust has not been released yet, which is a big deal when learning a language. Fundamental parts of Rust are still changing (standard library, possibly the syntax too) and it has not yet proven itself in production. 
Err, it's a compiler error when I try to run it with an up to date nightly. &gt; obsolete syntax: `~[T]` is no longer a type` rustc: &gt; rustc --version &gt; rustc 0.12.0-pre-nightly (5d200dd60dabf94323d13b98b6c3d0b88f100b85 2014-07-13 01:16:34 +0000)
Interesting article, although there's a few subtle (and not so subtle) mistakes. &gt; (x, ..z) Tuple with functional update Not a thing in Rust: fn main() { let t = (1, 2, 3); let u = (4, 5, .. t); } tuple-fsu.rs:3:20: 3:22 error: unexpected token: `..` tuple-fsu.rs:3 let u = (4, 5, .. t); ^~ &gt; [x,y,z] [|x;y;z|] Vector expression Actually an array expression: it creates a unboxed fixed-length array `[T, .. 3]`, not a dynamically allocated vector. A vector is created with the `vec![x, y, z]` macro. &gt; [x, y, ..10] Vector expression with fixed padding This only supports a single repeat element, i.e. `[x, .. 10]` will create a fixed-length array `[T, .. 10]`, filled with byte copies of `x` (and it only works with types `T` that are [`Copy`](http://doc.rust-lang.org/master/std/kinds/trait.Copy.html)). &gt; // f : |int,int| -&gt; int &gt; // fact : |int| -&gt; int Those are closure types: as freestanding functions their true types are `fn(int, int) -&gt; int` and `fn(int) -&gt; int`. Sometimes called a "bare function", these are just a function pointer from C/C++; a closure has an environment storing (references to) the variables it captures. There's a bit of a trick here, because direct uses of the `f` and `fact` name as `|int, int| -&gt; int` and `|int| -&gt; int` closures will work directly, as statically resolved uses of a bare function will coerce to a closure (but dynamic uses will not). fn f(x: int) -&gt; int { x + 1 } fn main() { let statik: |int| -&gt; int = f; // coercion OK let bare: fn(int) -&gt; int = f; let dynamic: |int| -&gt; int = bare; // error } fn-coerce.rs:7:37: 7:41 error: cannot coerce non-statically resolved bare fn fn-coerce.rs:7 let dynamic: |int| -&gt; int = bare; // error ^~~~ error: aborting due to previous error (The fix for the failed coercion is easy: write `|x| bare(x)` instead.) &gt; // Rust (0.10) &gt; enum Peano { &gt; Zero, &gt; Succ(@Peano) &gt; }; While not wrong for 0.10, the old `@` pointer is bad, and is now dead. It would be good to avoid it as much as possible. &gt; The for loop uses the special trait std::iter::Iterator, as follows: The expansion is more like for pattern in iterator { body } becomes match &amp;mut iterator { i =&gt; loop { match i.next() { None =&gt; break , Some(mut _value) =&gt; { let pattern = _value; { body } } } } } That is, it's using `loop` and a `match`, no explicit equality checking, and no `unwrap`. The most important semantic point is avoiding the `!= None`, as that constrains the types that can be iterated over to ones that implement `PartialEq` (`==`/`!=` can only be used with `Option&lt;T&gt;` when `T` implements `PartialEq`). &gt; println!("x : {}", x); // invalid! (&amp;int not printable) It is actually. [`&amp;'a T` implements `Show`](http://doc.rust-lang.org/master/std/fmt/trait.Show.html). &gt; x + 3; // invalid! (+ cannot apply to &amp;int) (FWIW, a bug means that that is valid code at the moment, but it's correctly invalid if written as `3 + x`, or if `x` is a `&amp;mut int`.) &gt; x = x + 1; // invalid! (x is immutable) It's actually invalid because of mismatched types, not because of immutability. &gt; inc(&amp;3); // invalid! (3 is immutable) &gt; let v = 3; &gt; inc(&amp;v); // invalid! (v is immutable) &gt; let mut w = 3; &gt; inc(&amp;w); // OK These all fail because the types mismatch: you're trying to pass a `&amp;int` as a `&amp;mut int`, and a shared `&amp;` cannot be directly mutated. The fix is changing them all to `&amp;mut`, in which case the first is valid: temporary r-values (like 3) are allowed to be mutated, this is how the `for` loop works above. &gt; Lifetime and storage, and managed objects This whole section is ignoring the `Box` type, which is the more fundamental pointer type, since a `Box&lt;T&gt;` is semantically equivalent to a `T` (i.e. no sharing except by `&amp;`, inherits mutability from the slot in which it is stored etc.), except it is guaranteed to be pointer sized. This means it interfaces far far better with Rust's type system, as it has the same aliasing/mutability rules as normal values. It is strongly preferred to use unboxed values, or, if a pointer is required (e.g. a recursive data type) to use `Box`. Of course, in some instances, the sharing offered by `Rc` is required. Mutating the interior of an `Rc` or `Gc` is harder, requiring that [a shared mutable container](http://doc.rust-lang.org/master/std/cell/) is used (commonly `RefCell` if mutable references are required, or if a non-`Copy` type like `Vec` is being stored). &gt; As with references to normal objects, Rust forbids mutable aliases &gt; with references to managed objects. Just to clarify: a `&amp;mut Rc&lt;T&gt;` is fine, the problem is just getting a `&amp;mut T` pointing to the interior because it's impossible to guarantee that this will be unaliased (unless using dynamical checking, as offered by `RefCell`). &gt; Rust strongly discourages all uses of the global heap altogether, by &gt; tainting all its interfaces with the unsafe attribute. No. The `Box` and `Vec` types are allocated on "the global heap", and can be passed between tasks. Similarly [the `Arc` type](http://doc.rust-lang.org/master/std/sync/struct.Arc.html), is "managed" and can also be passed between tasks. This is actually one of the powerful parts of Rust's linear types/ownership, as you can safely pass (nearly) arbitrary messages around. &gt; Creating and using managed objects As pointed out by others, this is wrong. `box foo` returns a `Box&lt;T&gt;` and `box(GC) foo` returns a `Gc&lt;T&gt;`. At the moment the `box` placement-new syntax is hardcoded to `Box` and `Gc` (the old `~` and `@` pointers), but will be generalised. Furthermore, the `[1i, 2, 3]` syntax is not creating a `Vec` (see above). &gt; let mut r1 = box [1i,2,3]; // r1 has type mut Rc&lt;Vec&lt;int&gt;&gt; &gt; r1[0] = 42; // OK No (ignoring type errors described in the previous paragraph), `r1` has type `Rc&lt;Vec&lt;int&gt;&gt;` *and* is mutable. Mutability is not part of the type, it's just saying that you can replace the value of `r1` with a new `Rc`, for most types this will be inherited, allowing you to also change the values of the contents of `r1`, but not `Rc`, as that would be breaking the mutability/aliasing rules. Thus, since `Rc` doesn't allow direct mutation of its interior, the assignment is not OK, it needs `Cell` or `RefCell`. When considering it as `Box&lt;[int, .. 3]&gt;` (i.e. the theoretical correct type of `r1`) it works. However, there's a minor hitch: Rust's old dynamic vectors were `~[int]` (constructed like `~[1, 2, 3]`); when they were removed and the `~` operator replaced with `box`, the deprecation error was preserved for `box [...]` expressions, so that code doesn't actually compile. You can force the disambiguation with `box() ([1i, 2, 3]);` (the empty `()` are to say "use the default placement", i.e. `Box`, since writing `box ([...])` would be interpreting the `[...]` as the placement). On a minor point, if interior the type was actually `Vec`, the indexing would not work. We've only recently gained the ability to overload `x[i]` in a nice way. [#15652](https://github.com/rust-lang/rust/pull/15652) adds the overload to `Vec`, but there are still some bugs that may mean it won't land for a little while. &gt; the simple form creates Rc references (box x) and another form &gt; creates Gc references: box(GC) x. For example, if v is an object of &gt; type T: Just to reiterate, `box x` creates a `Box`, `Rc::new(x)` creates an `Rc`. &gt; Note also that `"\'"` is a valid escape in a character or byte literal &gt; but is invalid in a string. Conversely, `"\""` is valid in a string &gt; literal but not in a character literal. No, both are valid in either. This compiles fine: fn main() { '\"'; "\'"; } 
Consider the same question, but in the case of Rust having actual null pointers; would it have a performance penalty? Option&lt;T&gt; would probably have a performance penalty if not for some kind of optimizations, which seems fairly straightforward and effective (see rest of thread). So let's assume no compiler optimizations for the case of null pointers. Rust has to maintain memory safety, which probably means that it can not freely dereference a pointer that might be null, since it could segfault. So the runtime would have to check if the pointer is null every time a pointer is dereferenced, and then throw an 'exception' if it is null, or actually access the memory if it is a *valid* address. You might say, "you could use program flow analysis (or whatever its name) to eliminate a lot of redundant null checks", but remember that we are assuming no optimizations. So it seems that you would have to have null checks for all pointers, even though 'nullable pointer' is probably not used as often as just 'pointer' (pointer that is really never, or should never be, null).
Sorry, I should say "it's actually *trying* to be a `Box&lt;[int]&gt;` at the moment", but the compiler disallows it. `Box&lt;[T]&gt;` aka `~[T]` has been removed; at some point, that error will be removed and we'll be left with the uniform fixed length vector handling.
This looks great!
You should get a blog, so that all your articles are collected into one place. (Even just throwing the markdown files into a basic [Github pages](https://pages.github.com/) blog would be better than the only record being the reddit history. :) )
Oooh, thanks! I'm guessing we should maybe try to set [gfx-rs](https://github.com/bjz/gfx-rs) up with that.
I think I can imagine the noise though when you will have a method with many parameters and you may need many #precond statements before the method signature. Seems cleaner to embed it into the code method. I am afraid a bit with the little Rust code I've seen that macros will become so common than any Rust project will look and behave totally differently than a different one, since anyone can so easily create custom macros. Instead of common libraries, every project will be peppered with custom macros. Not sure if this is the right thing to do in the long run.
Yep, I just found [how to do it](https://github.com/rust-lang/cargo/blob/master/tests/test_cargo_compile_path_deps.rs). 
You only ever need one precond statement (although it should work with multiple ones too). I share the same fear around language divergence with macros. It is nice to be able to do this sort of thing without needing a language change though. I guess there is a trade off there.
Because he wants to compile using local versions of his dependencies. Cargo still doesn't support that. 
Awesome! I read this a while ago: http://brson.github.io/2013/03/10/embedding-rust-in-ruby/ What can you say from your experience about this: &gt; When calling Rust code you will not be executing in a Rust task and will not have access to any runtime services that require task-local resources. Currently this means you can’t use the local heap, nor can you spawn or communicate with tasks, nor call fail!() to unwind the stack. I/O doesn’t work because core::io (unfortunately, and incorrectly) uses @-boxes. Even logging does not work. Calling any code that tries to access the task context will cause the process to abort. Because code is not executing in a task, it does not grow the stack, and instead runs on whatever stack the foreign caller was executing on. Recurse too deep and you will scribble on random memory. Thanks!!!!!!!!!!!
Most of them use qt-smoke. 
Use `path` instead of `git` in the `Cargo.toml`, IIUC, this will do exactly the same thing as a symlink.
What obvious and what is not is very very subjective, I think the `.map`/`.and_then` code is reasonable obvious, not as nice as `do`-notation, but not horrible. *shrug*
rust fills in a gap that nothing has ever filled before: compile time memory safety. before rust we had 2 spectrums: Lisp and C. with lisp we had garbage collection and s-expressions. Code ran slower, but with beautiful expressiveness and importantly, it ran. But all too often we need the speed and control of C. We need to allocate and free memory according to our own decisions. Shortly: in rust we can do this without allowing the mistakes C allows us. That being said, the main thing I hate about C is the tool chain. Some use make, others use visual studio, other IDEs, etc. While we have cmake to tie all of them together, it still sucks. Dependency hell is upon us, and I for one am sick of it. I'm not just excited for the aspects of rust that will let it replace C, but the fact that it can. If rust ends up being a clean C with a clean toolchain, it will bring an extensive amount of clarity to low level software.
 [dependency.whatever] git = "file:/path/to/local/git/repo" works just fine, if I understand correctly what is needed.
Some commands, like `locate-project`, are built into `cargo` itself, but most of the others are located through `PATH`, you can see it in the last `match` arm in the code you have linked to. So, you need to have `cargo-build` binary somewhere in `PATH`. cargo won't work properly without it.
wow... for posterity I had: http://gitbu.com/bjz/gfx-rs
Valid point about the IDEs, I always wondered why we had so much regressions in the past 40(!) years…
It would be hard, possibly very hard. But a good, fun project.
I must admit that I didn't think about this. All I've been doing to test this is println and simple operations, so I didn't try any of this.
To be fair, crates.io till doesn't bother to explain that you can actually do that; I had to dig through the source to find out that you can go: [dependencies.x] path = 'libs/x' ...in fact, the cargo website is just sitting there untended at the moment. https://github.com/wycats/cargo-website/pulls
I have modified the example to use vec!(...) instead. Thanks for this :)
Thanks for updating everything. :) It's not too important, but mentioning `Rc` (and possibly `Arc`) might be a nice idea. At the moment, `Gc` is just a eager/worse version of `Rc`. &gt; Is that new? I think it did not use to work in 0.10. Probably new, yeah. &gt; To be honest the Rust idea that the words “vector” and “array” should refer to different things is not extremely sound C++ has a similar distinction (not exactly the same, but similar). &gt; The first version was actually written without access to a rust 0.11 install, which meant I had to infer understanding from the 0.11 manual, source code and the working 0.10 compiler for test programs. No wonder the box story was mostly wrong :) Ah, trying to publish Rust things without compiler of the version you're writing for isn't such a great idea. &gt; The grammar in the manual[1] says otherwise. The grammar/manual is definitely not authoritative.
Thanks I have added a section on Rc and Arc as suggested.
For example, Rust-Graphics is a pure Rust library, so to test changes you need a graphics back-end, the window back-end and the piston game loop. There is a separate project called Rust-Graphics-Lab that has set up all this. Here is how it the dependencies looks: [dependencies.piston] git = "https://github.com/pistondevelopers/piston/" [dependencies.graphics] git = "https://github.com/pistondevelopers/rust-graphics" [dependencies.sdl2_game_window] git = "https://github.com/pistondevelopers/sdl2_game_window" [dependencies.opengl_graphics] git = "https://github.com/pistondevelopers/opengl_graphics" sdl2_game_window depends on rust-sdl2 and gl-rs, and opengl_graphics depends on gl-rs and rust-image. If I change one of the dependency paths to gl-rs, I need to update all paths. This means I have to remember which project depends on the others in which way. You can't do this every time you need a small test. With Rust-Empty, all I do is typing "./build.sh deps" and it crawls all the directories and rebuilds the project correctly. The only case when this does not work, is when people put multiple libraries in the same repository. Rust-Empty is slower than Cargo, but it saves us hours by not having to do any configuration.
&gt; Recurse too deep and you will scribble on random memory. That's the most worrisome thing. But he was embedding Rust in Ruby (calling a Rust library from a Ruby program). What the OP does, if I understood correctly, is to call Lua from Rust. Would "you will not be executing in a Rust task" still be a concern?
&gt; Just to clarify: a `&amp;mut Rc&lt;T&gt;` is fine, the problem is just getting a `&amp;mut T` pointing to the interior because it's impossible to guarantee that this will be unaliased (unless using dynamical checking, as offered by `RefCell`). I assume you elided this intentionally for brevity, but of course there's also [`make_unique`](http://doc.rust-lang.org/alloc/rc/struct.Rc.html#method.make_unique). (I wonder if there's a particular reason we don't have a `maybe_unique` which returns `Option&lt;&amp;'a mut T&gt;` without the `Clone`?) 
How about double clicking in explorer?
Putting it in the same repository is fine as long as it has no external dependencies.
I didn't elide it intentionally, so, good point: it's not *impossible*, but, in general, one doesn't have unaliased access, so the only way to get a `&amp;mut` is to possibly copy the data, getting a new pointer.
Maybe you could have a "fixed" piston project design, where all relevant libraries are expected to be in a single directory, then each Cargo.toml depends on the other libraries with `path = "../piston"`, `path = "../rust-graphics"` (or `git = "file:../piston"` etc., if that works). You could have a script that sets everything up correctly (i.e. makes directories/clones the various underlying repositories) for you, similar to your `build.sh deps`, except only run once... `cargo build` does the rest.
If you manage to split it up somehow, it will be easier to override the dependencies. One does not need to duplicate the entire project just to override one of the libraries. I am thinking of how to solve the issue with multiple packages per git repository, because there will be exceptional cases anyway. In a large project you want to be able to override all dependencies in the whole stack, because with many people working on many different projects it is a very high probability you need to fix breaking changes or wait for pull requests to be accepted most the time. Cargo is not at the state yet where it completely replaces Rust-Empty, because it does not override dependencies by symlinks. Rust-Empty can resolve dependencies locally for both Cargo projects and other libraries with Makefile. If https://github.com/rust-lang/cargo/issues/194 is solved, then we will be able to use Rust-Empty for resolving dependencies locally and use Cargo for building the individual projects. This requires only one Rust-Empty Makefile at top level.
(Hijacking this comment because I've been procrastinating on a blog since eternity, and have also been prone to "blog on Reddit" like this.) Is there any kind of blog hosting thingie which: * Doesn't require me to learn new things and manually set it up and administrate it (I believe the various Jekyll-like things, including GH pages, are eliminated by this) * Supports Markdown and has decent syntax highlighting (for at least Rust and Haskell, ideally) * Supports comments without requiring separate registration (ideally in Markdown) * Provides an RSS feed * Ideally has tags and per-tag feeds ?
I'm not sure if we're discussing dependencies in the same Git repo as the main project or not, but if we *aren't* then this is probably a bad idea for sharing code with others. I recently fixed (part of) a Cargo build on a package by just [using a filepath in the dependencies manager](https://github.com/BurntSushi/quickcheck/commit/c0946ed974efe53b11edecc42e586544c702f0cb#diff-80398c5faae3c069e4e6aa2ed11b28c0), for a Git repo that had multiple projects in itself. It's still not totally fixed because [Quickcheck needs to link against itself](https://github.com/BurntSushi/quickcheck/blob/92f30bb9cec042a09f608fa0474d33a8699143f5/src/lib.rs#L23) or something crazy like that to build all the tests, but it's a start.
I wonder if we could have interconversion between `Rc` and `Box` at some point, without making a new allocation. E.g. something like, with intentionally awkward names: fn to_box_if_unique&lt;T&gt;(rc: Rc&lt;T&gt;) -&gt; Result&lt;Box&lt;T&gt;, Rc&lt;T&gt;&gt;; fn to_box_make_unique&lt;T: Clone&gt;(rc: Rc&lt;T&gt;) -&gt; (Box&lt;T&gt;, Option&lt;Rc&lt;T&gt;&gt;); fn from_box&lt;T&gt;(b: Box&lt;T&gt;) -&gt; Rc&lt;T&gt;; and then unique vs. shared ownership would be tracked in the types, APIs could explicitly delimit where each one is required, and clients could cheaply translate between them. This is similar to `make_unique`, but a bit more general / powerful. Maybe if/when these gain allocator type parameters, and then we could just require that the input and output have the same allocator?
The problem is that Cargo will not replace all automated tools. Having a one-to-one correspondence between git root and build command makes it easier to write automated scripts.
But he does not want to change the dependency in Cargo.toml! This was discussed in #cargo before. Cargo still needs a `cargo config` command, so the dependency only changes locally without changing the manifest file. This will be eventually implemented. 
`Rc` stores [two extra words](https://github.com/rust-lang/rust/blob/996263a01589c5d2bd2a5ad559abac267296ad71/src/liballoc/rc.rs#L168-L169) in the allocation, so, unless some serious magic is done there's no way to go `Rc&lt;T&gt;` &amp;harr; `Box&lt;T&gt;`. (I guess some version of `RcBox` could be exposed, meaning `Rc&lt;T&gt;` &amp;harr; `Box&lt;RcBox&lt;T&gt;&gt;` would work.) (I think C++ allows the reference counts to be stored in an independent allocation; if we also did that, then `Box&lt;T&gt;` &amp;rarr; `Rc&lt;T&gt;` would be possible; the other direction wouldn't be guaranteed to work on every `Rc&lt;T&gt;`.)
Symlinks are bad from a portability viewpoint (e.g. hard to work with them on windows), and bad from a maintainability viewpoint (you have "random" pointers to all parts of your filesystem). (Also, btw, you keep talking about symlinks but haven't actually described how you're using them at all.)
We tried this strategy, and it quickly became a management hell. We'd rather wait for `cargo config`. 
&gt; Doesn't require me to learn new things and manually set it up and administrate it It's impossible to answer this question without knowing what you know. Also, GH pages doesnt require jekyll. https://github.com/brooklyn-rs/brooklyn-rs.github.io
Oh, right, for some reason I was thinking that those were in `Rc&lt;T&gt;` itself, even though I know they aren't and it can't work that way.
I disagree. By providing a stable standard formatting to work to, your ability to tweak it is limited to inserting newlines or breaking up statements. So that is how you get it looking as you want. But this very limited tweakability is stable over transformations. But Go is a very simple language compared to Rust. For example, there aren't ?: or if/else expression types in Go. We'll have to see whether someone can pull off a reasonable-looking standard output for rustfmt.
I know markdown and how to click buttons. :) (and git, if really necessary) (And yes, as long as I only want a static web page as opposed to a blog with some degree of automation.)
Great! Really good article, btw. I enjoy reading it.
Well, &gt; Supports comments without requiring separate registration (ideally in Markdown) Requires you to have some kind of back-end thing, which needs administration. If you dropped that requirement, GH pages actually supports your case pretty well. Also, comments on blog posts are overrated, IMHO.
How can I only need only one precondition statement if I may have 8 parameters with multiple checks between them? #[precord = "check this &amp;&amp; check that &amp;&amp; check a and b together &amp;&amp; check b &amp;c &amp;&amp; check d &amp;&amp; check e minus c is greater then zero &amp;&amp;...."] That looks like hell. Either multiple #precord statements must be allowed for complex signatures (especially for DTOs in incoming APIs which may be a complex JSON object that needs to be thoroughly checked before being processed) or it is better to do it via code like Guava does it.
That's an awesome news!
Could you give me a link to a more detailed writeup of how this works, or even just a phrase I can google for to find out more about it?
I can briefly see the console window with "Hello, World" and then it disappears.
This is plain awesome! I can’t praise you enough for your work!
What happens when lua code calls rust code with the wrong parameter types?
This is exciting. Since this is a 'bare metal stack' I would expect it not to link to the standard library (which currently has a lot of OS-specific dependencies). The source looks like it does link to std though. Can you describe the architecture some and the environments this is supposed to support, for those of us without arduino experience?
The compile time code (libplatformtree) is a macro plugin for rust, it not only uses libstd, it also has some (legitimate) use for std::gc::Gc :) The runtime depends on libcore only. it initialises the mcu from ground up, configures peripherals (baed on the generated code, provided by libplatformtree) and passes control to user-defined tasks.
Or just to get rid of the overuse of the C preprocessor.
This is about some recent observations by Graydon.
Thank you so much for documenting this. Now I have something to point people to!
Just tested on Ubunty 14.04. Works like a champ. This is a great script for newbies to get started.
Well you only _need_ one. It might look prettier with several and that is your choice. You probably don't want one per check though.
Hi all. This work is very useful for many fields, for example, in the typesetting area. I make a test with LuaTeX: the result was a positive check. This is the LuaLaTeX source that use the Rust lib in the code example on github (the project home): \documentclass{article} \usepackage[T1]{fontenc} \usepackage[utf8]{inputenc} \usepackage[italian]{babel} \begin{document} \directlua{ m = require "mylib" tex.sprint(m.PI) } \end{document} Only one difference: I use a f64 for the PI field, elsewhere, on my Linux amd64 arch the type f32 give a little numeric difference. So. Congrats.
That is correct :)
Nah, unusually enough: the machine it does work on uses Avast. Thanks for the help though. 
I have tried in cmd, cmd with admin rights, a mingw bash and git bash. All with the exact same results. Edit: Also forgot to mention powershell, which is what I was using at the beginning (superior to cmd)
Not necessarily, but having to cram all preconditions into a single statement does not sound like a good idea. The other bad part about this approach is that you cannot specify a custom error message for each of the violated conditions. E.g. if you are testing "condition A &amp;&amp; condition B" you can probably raise a single error like "precondition failed". Vs. If you implemented every check as a separate call, you could specify a custom error message for each of them, which could be logged or propagated back to the caller, e.g. precondition.check(parameterA &gt; 0, "parameterA must be greater than 0") precondition.check(parameterB != null, "parameterB cannot be null") etc. Hence, I still think the Guava approach enforces better practices and crucially, better error reporting. The more I look at this 'cram it all in a single macro' approach, the less I like it. Just my $0.02, hope it is constructive. 
Odd. I tried on my Windows 7 machine: C:\git\inference\rust&gt;hello.exe hello? Looks fine, no problems.
Yeah, custom messages for pre/post conditions would be a definite improvement, should be possible one way or another. We could also probably improve the error reporting by printing values of variables used in the precondition. The killer problem with doing this in code rather than a macro is that you can't do postconditions. Having pre and post conditions implemented differently and defined in different places seems like a non-starter to me.
I have a Teensy 3.1 board. Would you think I could try Zync and add support for this board? Also, is there any step-by-step-copy-and-paste tutorial somewhere?
Well, it reproduces using the same command that Rust-Empty produces: rustc --target "x86_64-apple-darwin" -O --test src/test.rs -o bin/test-external -L "target/deps/" -L "target" Willing to try a different configuration by hand :)
Same error. I'll try to move to Cargo ASAP. Was waiting for it to become semi-usable, but it sounds like it has crossed that point already :)
Thank you so much for this! Updating Rust became trivial with rustup.sh; finally Cargo can benefit from this as well.
BTW. Have you thought about adding support for any of the boards supported by QEMU, so even the people without any hardware could try it?
&gt; "Race conditions are compile-time errors" To be clear, this is a little bit broader than what Rust is offering (don't get your hopes up :( ). Rust only protects against [data races](http://en.wikipedia.org/wiki/Race_condition#C.2B.2B), that is, race conditions between non-atomic variables. It's impossible to avoid general race conditions, because the language has no way to work out that, e.g. a certain ordering of mutex lockings/unlockings isn't the order that you actually wanted. The problem with data races is they can cause memory unsafety, while more general race conditions cannot (assuming all `unsafe` code is written correctly, which is hopefully true for the abstractions in the standard library). As an example of this, imagine we had a shared vector `v: Vec&lt;Type&gt;`, if we could access it concurrently without synchronisation we could have two threads like: | // parent task | let mut v: Vec&lt;Type&gt; = vec![t]; v | // spawn two tasks: / \ / \ /-&lt;-/ \---&gt;--------\ | | | // Task A: | // Task B: | // get a reference | // overwrite v with | // into v | // a longer vector | let x = v.get(6); | v = vec![x, y, z, w, a, b, c]; | println!("{}", *x); | v v where the `|` lines and `&lt;`, `v`, `&gt;` arrows represent the flow of control (excuse the ASCII art...). A `Vec` is three words `(length, capacity, data pointer)`, so the `v = vec![...]` overwrite might progressively set `length = 7`, `capacity = new capacity`, `data pointer = new allocation`. Now, imagine if the `let x = v.get(6);` executes *between* setting `length` and changing `data pointer`: `6 &lt; 7` so the bounds check passes, but the pointer hasn't been updated for the new larger allocation, and the old value of `data pointer` might only be pointing to space for 1 element, and so the `v.get(6);` has run off the end of that allocation... a buffer overflow! This is dangerous, and is why Rust protects against data races (and why Rust requires `unsafe` for anything that could cause a data race). &gt; This error says that the compiler captures x and makes it immutable while in the proc It's slightly subtle; it's not "making" `x` immutable, since a `proc` captures things by-value; that is, the bytes of `x` are copied into the environment of the `proc`, and so the `x` in the `proc` is actually a different piece of memory to the `x` outside the `proc`. The only way to have shared mutation is if all the functions are mutating the same piece of memory, i.e., there needs to be a pointer that they are mutating via. One's first thought might be "let's pass a `&amp;mut` into each thread", something like for num in range(0u, threads) { let x_ref = &amp;mut x; spawn(proc() { for num in range(0u, count) { *x_ref += 1; In that code, `x_ref` points at `x`, so, if it compiled, the `*x_ref += 1` line would be mutating the memory that `x` occupies... exactly what we want! But it doesn't compile, because (a) it's not legal to have multiple `&amp;mut`s pointing at the one piece of data (because that could lead to race conditions), and (b) you can't send a `&amp;mut` reference to another thread, as the data it points to may be deallocated/invalidated by the owning thread (e.g. what if the `main` function finished before the threads did? The `x` variable on the stack would no longer exist, and the `x_ref`s in each task would point to invalid memory). A smaller example: use std::sync::Arc; fn main() { let mut x = 1i; let x_ref = &amp;mut x; spawn(proc() { *x_ref += 1; }) } /* &lt;anon&gt;:8:10: 8:15 error: cannot capture variable of type `&amp;mut int`, which does not fulfill `'static+Send`, in a bounded closure &lt;anon&gt;:8 *x_ref += 1; ^~~~~ &lt;anon&gt;:8:10: 8:15 note: this closure's environment must satisfy `'static+Send` &lt;anon&gt;:8 *x_ref += 1; ^~~~~ */ [playpen][pp2] [pp2]: http://play.rust-lang.org/?run=1&amp;code=use%20std%3A%3Async%3A%3AArc%3B%0A%0Afn%20main%28%29%20{%0A%20%20%20%20let%20mut%20x%20%3D%201i%3B%0A%20%20%20%20%0A%20%20%20%20let%20x_ref%20%3D%20%26mut%20x%3B%0A%20%20%20%20spawn%28proc%28%29%20{%0A%20%20%20%20%20%20%20%20*x_ref%20%2B%3D%201%3B%0A%20%20%20%20}%29%0A} The next thought would be to have `x` be a shared, threadsafe pointer type, like [`Arc`](http://doc.rust-lang.org/master/std/sync/struct.Arc.html). This can be duplicated among threads, all pointing at the same memory, that is, the original code could become: let x = Arc::new(1i); for num in range(0u, threads) { // new copy, pointing at the same memory let x_ = x.clone(); spawn(proc() { for num in range(0u, count) { *x_ += 1; However, you can only access the interior of an `Arc` via `&amp;`, and an `&amp;int` cannot be mutated. A smaller example demonstrating the same problem: use std::sync::Arc; fn main() { let mut x = Arc::new(1i); *x += 1; } /* &lt;anon&gt;:5:5: 5:12 error: cannot assign to immutable dereference of `&amp;`-pointer &lt;anon&gt;:5 *x += 1; ^~~~~~~ */ [playpen][pp1] [pp1]: http://play.rust-lang.org/?run=1&amp;code=use%20std%3A%3Async%3A%3AArc%3B%0A%0Afn%20main%28%29%20{%0A%20%20%20%20let%20mut%20x%20%3D%20Arc%3A%3Anew%281i%29%3B%0A%20%20%20%20*x%20%2B%3D%201%3B%0A} Hence, `Arc` provides half of the puzzle: shared memory, but it's not automatically mutable (because that would be unsafe, and lead to race conditions). The last piece is using a threadsafe version of [`RefCell` or `Cell`](http://doc.rust-lang.org/master/std/cell/index.html), which can be placed inside the `Arc` to give shared, threadsafe mutability. [`Mutex`](http://doc.rust-lang.org/master/std/sync/struct.Mutex.html) is such a type: it stores a `T` and provides access to it, but only after acquiring the lock, guaranteeing that only one thread can access the data at a time. You can see that the compiler is complaining about every attempt that could lead to badness. The safe way to do this with Rust's standard library is to use the `Arc` and `Mutex` abstractions together: use std::sync::{Arc, Mutex}; fn main() { let threads = 100; let count = 500; // put a mutex-protected int inside a atomically reference counted // pointer. let x = Arc::new(Mutex::new(1i)); let (tx, rx) = channel(); for _ in range(0u, threads) { let tx = tx.clone(); // a new handle pointing to the same mutex let x = x.clone(); spawn(proc() { for _ in range(0u, count) { let mut guard = x.lock(); *guard += 1; // could be written as: *x.lock() += 1; } // send a "this thread is done" message tx.send(()); }) } for _ in range(0, threads) { rx.recv(); } println!("{} (expected {})", *x.lock(), threads * count + 1); } (Prints `50001 (expected 50001)`. See below for the reasons for the changes I made.) This is all guaranteed by Rust's type system, of particular note is the [`Send`](http://doc.rust-lang.org/master/std/kinds/trait.Send.html) and [`Share`](http://doc.rust-lang.org/master/std/kinds/trait.Share.html) built-in traits, which allow the compiler/libraries to expose a safe interface, by ensuring they can never be used in a way that would lead to data races. --- However, Rust still allows you to hit the really bad behaviour (i.e. a data race) if you *really* want: fn main() { let threads = 100; let count = 500; let mut x = 1i; // raw pointers are sendable, with no restrictions, unlike &amp;mut // and capturing `x` directly. let ptr = &amp;mut x as *mut int; let (tx, rx) = channel(); for _ in range(0u, threads) { let tx = tx.clone(); spawn(proc() { for _ in range(0u, count) { // oh uh, unsynchronised mutation unsafe { *ptr += 1 } } // send a "this thread is done" message tx.send(()); }) } for _ in range(0, threads) { rx.recv(); } println!("{} (expected {})", x, threads * count + 1); } (Prints things like `46175 (expected 50001)`.) I made a few changes, bumping up the `threads`/`count` variables, and removing the sleep (because it's not needed to reliably demonstrate the problem of race conditions with the larger values for those two variables).
Basic details can be found under the "Basic imports" heading here: http://dlang.org/module.html For a more in-depth look I suggest reading _The D Programming Language_ book. You could also ask for more info on the dlang.org forums (nice people) and play around with the DMD compiler to see how it works in practice.
A very interesting read. I definitely have to check out Julia
Does qemu support any Cortex M[0-4] devices? I thought it only supported larger machines.
I suspect you will get a lot more usage from input validation rather than result. That will be the most common use case IMHO.
Looks like that is only the TI LM3S series at the [moment](https://github.com/qemu/qemu/blob/9540d1f8d9b4b974af2fd359d7c642f09fc6f44d/qemu-doc.texi#L101). Which are end of life and the development boards aren't being produced anymore. Though it is something to keep in mind for automated testing. Thanks.
You could grab vexpress-a9 board, and just let it run with uart driver maybe ... . No need to enable MMU, etc. Just as much to print something on uart maybe. Anyway. I was able to compile zinc for k20, and it doesn't work as is. I'm going through de-assembler output and have a lot of questions. What is the preferred way to communicate with the authors? I'm actually an embedded developer working on ARM architecture and I'm interested in using Rust for embedded work.
BTW. The I'm pretty sure Cortex M{3,4} is supported as a CPU option. The platform however is picked independently, I believe.
Hop onto the mailing list: https://groups.google.com/d/forum/zinc-dev or file an issue on GitHub.
Iron an rust web frameworks are all very new, so I'd doubt that there are any tutorials. The documentation and source is the best I can offer you :)
There will be some basic support of running libzinc code on "native" platform, to allow the unit testing of runtime part. That wouldn't really be enough to showcase the platform though (unless it's not paired with rust-sdl or piston to provide some UI for fake leds to blink).
There are methods for array access without bounds checking: - [`unsafe_ref`](http://doc.rust-lang.org/master/std/slice/trait.ImmutableVector.html#tymethod.unsafe_ref) - [`unsafe_mut_ref`](http://doc.rust-lang.org/master/std/slice/trait.MutableVector.html#tymethod.unsafe_mut_ref) - [`unsafe_set`](http://doc.rust-lang.org/master/std/slice/trait.MutableVector.html#tymethod.unsafe_set) but these are all marked `unsafe`, that is, they can only be called inside an `unsafe` block or function. In other words, just writing `unsafe { ... }` doesn't disable bounds checks, but it does opt-in to being able to call the unchecked functions.
This is great, I've been wanting to experiment with some XML stuff in Rust. Perhaps you could make an issue for the well-formdness checking problems?
Not much to add, other than to check out the [Rust style guide](http://aturon.github.io/) which is still in progress.
Just to nitpick, you definitely _can_ cause the bad behavior without using the word 'unsafe' anywhere, it just requires you to be anti-clever. For example: lock the mutex, grab the value, unlock the mutex, increment the value, lock the mutex, write the value back. I say this because it's the sort of thing that people do when they understand "you need a mutex when you access shared state" but they don't have a clear understanding of why.
Thanks for the answers!
&gt; For example: lock the mutex, grab the value, unlock the mutex, increment the value, lock the mutex, write the value back. Could you provide an example please? Because it seems that you can only read or write once you have the lock grabbed.
He meant grab *a copy* of the value, mutate the copy and write it back. 
The library contains XML parser and XML events writer, though the writer is not finished yet. XML is a rather complex standard, so some of its features (like embedded doctypes) are not supported yet. Also Rust currently does not provide input/output streams with encoding, so there is no support for encodings other than UTF-8. I was writing this library for some time already (the first version was written somewhere around Rust 0.9 release), so there may be (certainly should be, in fact) some non-idiomatic or wrong code present. Reviews and issues are very welcome.
That's interesting, but I'm hoping for something more like Java's [`InputStreamReader`](http://docs.oracle.com/javase/7/docs/api/java/io/InputStreamReader.html)/[`OutputStreamWriter`](http://docs.oracle.com/javase/7/docs/api/java/io/OutputStreamWriter.html) classes which allow to apply encoding to a stream of bytes. There was [an RFC](https://github.com/rust-lang/rfcs/pull/57) on this, but, regretfully, it was postponed. Also I'm not using `Encodable`/`Decodable` infrastructure in my library because it is unsufficient for XML decoding. There are tons of possibilites to match structs with XML schemas, but at present there is no way to define these possibilities in code easily except for `#[deriving(Encodable, Decodable)]`, which is too rigid - for example, you can't tweak how a field will be named in the output document.
Though, it seems, [rust-encoding](https://github.com/lifthrasiir/rust-encoding) now has something like these streams. I'll probably try to make use of it in rust-xml soon.
Thanks! Isn't this the same thing as Rust's glob imports though, only with a different syntax? (i.e. a glob import of the whole module contents is the default, while Rust requires making that explicit with `::*`)
I think something is wrong with the rustup script. I get this error whenever I try to execute rustc after installing it with rustup.sh: &gt;rustc: error while loading shared libraries: librustc-4e7c5e5c.so: cannot open shared object file: No such file or directory Edit: Made a bug report for it: https://github.com/rust-lang/rust/issues/15684
Out of curiosity, why do you want to disable bounds checking?
As a rust-encoding contributor and submitter of that RFC, I’m curious what kind of of streaming API you’d like to have. A "pull" API with a UnicodeReader that wraps a (byte) [Reader](http://doc.rust-lang.org/std/io/trait.Reader.html) (and vice-versa)? A "push" API with a UnicodeWriter that wraps a (byte) [Writer](http://doc.rust-lang.org/std/io/trait.Writer.html) (and vice-versa)? Both? Something else? Why?
Wow, thank you!! This is awesome :) I know there are lots of subtleties in this area that I don't yet understand, and your explanations help a lot :)
I'm not sure why you make firm distinction between "pull" and "push" API. They have different uses and they both are needed - one for input, another for output. For me Java API is the ideal: there are byte streams which allow reading/writing chunks of bytes and there are char streams which wrap byte streams and add encoding, allowing reading/writing chars and strings. Moreover, Java streams are composable: for example, you can add buffering to the existing `Reader` and get just another `Reader`. The latter is possible due to subtyping and interfaces, but in Rust something like this should also be possible through trait objects. Though exact set of types/traits and their hierarchy, if any, are debatable, the basic idea is the same. In short, there are `ByteInputStream` and `ByteOutputStream`, which represent low-level byte source and sink, respectively, and there are `CharInputStream` and `CharOutputStream` which wrap `ByteInputStream` and `ByteOutputStream` and add encoding, which allow reading bytes as characters and vice versa. I guess, current Rust's `Reader` and `Writer` are nice as the low-level byte streams, so we only need wrappers adding encoding to them and providing methods like `read_char()`/`read_string()` and `write_char()`/`write_str()` which perform necessary conversions. I think this is the most important part. Current situation when our `BufferedReader` (a name from Java again) also allow reading characters and strings is not really good - it mixes multiple tasks in the single interface. There is also no separate `BufferedWriter`, which is useful occasionally.
That example was originally in Ruby, actually: http://mislav.uniqpath.com/poignant-guide/dwemthy/
&gt; XML is a rather complex standard, so some of its features (like embedded doctypes) are not supported yet. [Some of these features are unsafe](https://pypi.python.org/pypi/defusedxml/#attack-vectors) I'd suggest either not implementing them at all or making the feature optional and disabled by default (with multiple levels of enablement to allow issues mitigation even if they must be enabled).
Thanks for the link! Definitely a thing worth reading and taking note of.
I just changed the link to defusedxml which provides more information than the previous link, [general recommendations](https://pypi.python.org/pypi/defusedxml/#how-to-avoid-xml-vulnerabilities) and [information on further vulnerabilities or possible vulnerabilities](https://pypi.python.org/pypi/defusedxml/#other-things-to-consider) including those coming from [the ecosystem of standards around XML](https://pypi.python.org/pypi/defusedxml/#xpath)
Wow, thank you very much again!
You're welcome. I was rather dismayed when I discovered all the ways in which most XML libraries can be used to blow up host systems (period or in their default configuration), I'd be absolutely thrilled if that wasn't a problem in Rust's XML stack(s).
&gt;it’s the dynamic versus strong typing duality you are probably already aware of. I had to stop reading. Why is this guy gonna talk about programming languages if he doesn't know the difference between strong/weak and static/dynamic typing. Of course I guess it should just be a typo, but I'm unsure
Don't forget, the author is from Portugal, and English may not be their first language.
Maybe also include DanielFath: https://github.com/rust-lang/rust/wiki/Community-libraries#encoding
Also i wish there was a way to come up with one unified web develpment framework approach: https://github.com/rust-lang/rust/wiki/Community-libraries#web-programming
I was expecting something like that for some time. 😊
Since you example works fine without those `{}`s, due to lifetimes of temporaries being limited to ~~expression~~ statement (I think even [this](https://github.com/rust-lang/rfcs/blob/master/active/0031-better-temporary-lifetimes.md) won't change behaviour of this example); I am wondering, is it just considered good style to write code like this, using redundant brackets?
Note that there is already the same discussion on the front page: http://www.reddit.com/r/rust/comments/2aoxjv/updates_on_the_zincrs_the_embedded_rust_stack/
&gt; If you’ve never heard of it, Rust is a language championed by Mozilla that aims at replacing C++ as the language in which Firefox in written. Uh, no, it is not. 
I think it's fine, people experiment then the community pares that down to a few projects. Python used to have a hundred webdev frameworks, these days there are maybe 4 or 5 "real" options. Not to mention the language itself isn't even done yet, how could the community know the best way to develop systems at this point?
Are you nitpicking? AIUI, part of Rust's purpose is to replace C++ as the language in which the (next) Mozilla browser is written. That's not exactly what the author said, but for anyone who doesn't already know anything about it nor care to look further into the details, it seems like its more than close enough.
I'm not nitpicking. Servo is not the "next" Mozilla browser, it's a research rendering engine that may or may not work out in the end. In fact, I have seen Rust and Servo developers themselves saying that we should not think that Servo is going to replace gecko, or that Servo is the new official engine for the next browser. At the end of the day, not even Servo people are completely sure if the ideas on it will work. They are confident, sure, but they are conscious that it may not be viable at the end of the day.
&gt; They are confident, sure, but they are conscious that it may not be viable at the end of the day. I have worked on Servo for the past summer and that is exactly the point of view of the team.
Very cool. Rust could be very nice to have in embedded applications.
Assuming streams, there are four possible combinations: 1. A Unicode reader that wraps a byte reader, "pull decoding" 2. A byte reader that wraps a Unicode reader, "pull encoding" 3. A Unicode writer that wraps a byte writer, "push encoding" 4. A byte writer that wraps a Unicode writer, "push decoding" As far as I can tell, Java’s InputStreamReader and OutputStreamWriter are 1 and 3, respectively. Do you think 2 and 4 are also valuable?
Rust has both BufferedReader and BuferredWriter: http://doc.rust-lang.org/std/?search=buffered
Ooh, nice, would be good to eventually move [gl-rs](https://github.com/bjz/gl-rs) away from my hackily wrapped [sax-rs](https://github.com/bjz/sax-rs).
Rust is now debuggable on dbgr.cc
For performance critical sections 
Looks neat. It would be nice to see an example of how it works across threads, too.
Ah, thanks, I missed `BufferedWriter`. BTW, this one is good - it is just another struct which also implements `Writer`. `BufferedReader`, on the other hand, also implements `Buffer`. This is the trait I don't like most; I don't think it should be there at all. Its main purpose, as far as I can see, is to provide UTF-8 decoding capabilities, and if we will have separate traits for characters input/output, it won't be needed anymore.
I understand now what you mean, thanks. 2 and 4 are somewhat weird to me. 1 and 3 are natural: they describe stacks of functionality, which grow when you need to work on more abstract level. That is, characters are built over bytes, so it is natural to have a byte source/sink initially and add character-based "view" on it when needed. With 2 and 4 it is in the other way around, which is kind of counterintuitive. I don't know which uses they will have. However, if it is really decided to make up something resembling Java's streams, then it is a question of implementation: you can always implement, say, byte writer over a Unicode writer using the same interfaces as regular byte writer and regular Unicode writer.
Unfortunately it's not going to be thread-safe just because `Rc` isn't thread-safe. You'd have to use `Arc` instead of `Rc` for that
I actually really like the short keywords everywhere.
Good to know!
Windows installation for Cargo is lagging I believe. rustup.sh doesn't work at all on Windows, and since the preferred installation method is the .exe installer, which behaves differently from the unix installer, installing cargo on windows necessarily requires more work.
Wow! That is shockingly cool. Seems useful for newbies especially.
Normally I would not say anything and let others who can give a better answer reply, but since I think you can get a much quicker answer than reading the lifetimes guide (which you should read), and it's a chance to see if someone comes along and clears up a misconception I might have (I'm very likely not being precise enough): `&amp;'a` just means that the variable (or whatever) you're declaring is a reference that has a lifetime of a.
Thanks! Hopefully local/global variables will be working sometime soon-ish. IMO stepping through a program is to printf debugging as a picture is to words.
Ill read the guidelines... But can you explain quickly what is a lifetime?
I want it, too. With a C-style `for` loop. Yes, I really really want it. Bring on the downvotes again!
The time during which you can access a variable, between allocation and freeing. Rust makes sure you can't access a variable once it's no longer safe to do so, and lifetime annotations are part of the mechanism that ensures that.
Thanks man. They really did think in everything
Not an excuse, the author is just not aware of the precise meanings of the terms. English is not my first language either. It's not even my second language.
I know. I'd like to think that it would be there for those who want/need it - and can be left well alone for those who don't. Speaking of which - does Rust have a `goto` keyword?
Please file a bug on discuss this on the mailing list.
&gt; Bring on the downvotes again! I wasn't going to downvote you until this.
[No](https://github.com/rust-lang/rust/blob/master/src/libsyntax/parse/token.rs#L459)
Thanks Steve. I don't mind what you do. I'm just glad you're documenting Rust!
I can't help but feel that Rust is moving in a very academic direction - rather than being a real practical alternative to C. By denying real-world systems programmers to rarely-used but essential-when-you-need-them language features I fear Rust will go the way of Haskell. I strongly object being forced to hack `while` to emulate a `for` condition.
I guess we just disagree on what counts as nitpicking. As I see it... that is an important distinction when discussing the future of Firefox and Servo, but not particularly important when discussing the aims of Rust.
Rust expects C/C++ programmers to learn new tricks. It's not designed to allow C/C++ programmers to program exactly as they do in those languages. 
Treat developers like idiots - they'll just walk away. I'm getting tired of the arrogance that seems to be prevailing in the Rust community. My enthusiasm is quickly waning.
Right, which is why Rust is designed under the assumption that developers aren't afraid of learning new ways of doing things.
I'm very happy to learn! Which is why I'm thrilled Steve is documenting the language again. Already he's made brilliant strides into indexing on the API pages which was lacking just a month ago. I love Perl. Love it. The language is so powerful - and allows expression in C-like style - as well as more modern iterative and object styles. I like flexibility. I hate being shoehorned. That is why I refuse to touch Python. That's why I find Java a chore. Iterators are great. They compile down to highly efficient code in Rust. But if I need a flexible but relatively simple for loop then expressing it as an iterator will look significantly more complex and terse than a C-style loop - and a C-style loop will also permit me to modify the conditional variable in-loop - a feature that has its uses from time to time. Lastly `while` is far more dangerous than a C-style `for` yet is an undisputed part of Rust. You can call me inflexible and afraid all you like. I know who I am, where I've been, and how diverse my programming styles are. As I said - I don't like being **forced** into a single way of doing things. Sorry.
 I think it's safe to say that everyone in the Rust community programs in languages other than Rust. We all have something we are used to in our favorite languages that either Rust doesn't have, or Rust does in an inferior way. Now, one can either accept that and enjoy what Rust *is* better at, go through the proper channels to suggest an addition/change to the language, or come to terms that it's not the language for them. Sure, they could just add missing feature X for every language that new Rust users are coming from, but I don't think a kitchen-sink language is part of the design goal. 
Let's see if we can make 10 readers... There is so much going on in the Rust gamedev community now that we strive to communicate across the projects. I believe this subreddit is going to be entertaining and fun. Will do my best to create hype and start flame wars... ;)
The syntax is stable *enough* to start working on serious projects, as long as you understand that the syntax is *not stable* and can tolerate some amount of churn. A number of people have expressed recently that keeping up with Rust master is a fairly tolerable experience. There are very few significant backwards-incompatible syntax changes in the pipeline. The biggest one is an overhaul of closures, which likely *will* be painful. Beyond that most of remaining changes prior to 1.0 will be fixing soundness holes and improving ergonomics; this is mostly corner cases and/or backwards compatible. Where the most churn happens now is in API's, but we are doing a better and better job of easing the transition pain there. Many changes are done completely backwards-compatibly by deprecating old functions. Parts of the libs are starting to be marked as 'stable', meaning you can count on them not breaking.
http://is.gd/UhkxeM
Let's say I'm searching an IPv4 routing table for the best match. I want to start with a netmask of all ones (32-bit unsigned integer) - then left shift one bit at a time looking for a more generalised netmask. In C I would express this as: for ( mask = 4294967295; mask &gt; 0; mask &lt;&lt;= 1 ) { // does the address and mask match an entry in the routing table? .... } That's very simply expressed. How would you do that using `range`? More importantly - can you type it using less characters than the C-style loop?
 use std::iter::Unfold; fn main() { for mask in Unfold::new(0xFFFFFFFFu32, |mask| if *mask &gt; 0 {*mask &lt;&lt;= 1; Some(*mask)} else {None}) { println!("{:x}", mask); } }
Seriously you can implement a serious and sound C for loop syntax using a macro. It's not even difficult!
That's great it *can* be done with iterators. But do you really think this is a superior method of expressing that simple expression? Sure, it's only, say, 50% more characters... but is it as easy to interpret? I guess I'm not yet convinced. Perhaps the more familiar I become with the pattern the less bothered I'll be about the extra keystrokes...
Make continue and break also macros.
IMO, yes; for things where scope is very important (the region where the mutex is locked/unlocked), I think using explicit `{}` is good.
Looks neat, but Bjarne says: [I hate linked lists!](http://blog.davidecoppola.com/2014/05/20/cpp-benchmarks-vector-vs-list-vs-deque/) Edit: Maybe it's not such a big hit in this case, though, but a ring buffer version might be nice to try.
No, [you can](http://www.reddit.com/r/rust/comments/2957fg/can_i_request_a_c_style_for_loop/cihkh5t).
Let's see if you end up with /r/playrust users there too, ha!
Ah thanks I had missed the successful macro implementation.
Well that was quick. It's already at 27 readers (about an hour after the above post).
This is what I had in mind: macro_rules! cfor( ($init:expr ; $test:expr ; $inc:expr $body:expr ) =&gt; ({ $init; while $test { let mut _b = true; let mut _cont = true; while _b { _b = false; $body; } if _cont { $inc } else { break } } })) macro_rules! ccontinue(() =&gt; (break)) macro_rules! cbreak(() =&gt; ({ _cont = false; break })) However this does not seem to work, any idea how I can refer to the right variable in the cbreak expansion?
I think our iterators need an ergonomics look-see.
http://www.reddit.com/r/rust/comments/29o3u4/rust_0110_released/citvovm
NB, [you need to do more](http://www.reddit.com/r/rust/comments/2957fg/can_i_request_a_c_style_for_loop/cihkh5t) to handle `continue` correctly.
Meh, people keep saying this, but, IMO, they're quite ergonomic most of the time, with a small number of edge cases. FWIW, this one here could actually be written `std::iter::iterate(|x| x &lt;&lt; 1, 0xFFFFFFFFu32).take_while(|x| *x &gt; 0)`.
That's also what they told me in the IRC channel.
 for i in range(0, 32) { let mask = u32::MAX &lt;&lt; i; // A thing }
&gt; Treat developers like idiots Developers (including me and all other Rust programmers) *are* idiots. Have you seen how many bugs there are in any non-trivial piece of software? Rust is a low-level low-overhead language that is trying to reduce the security consequences of this idiocy for systems programming by making it harder/impossible for a program to be vulnerable to the worst/most common problems (the memory safety issues of languages like C/C++).
Cost per entry: from Rc&lt;&gt;: 2 ints, from RefCell&lt;&gt;: 1 int, next pointer 1 int. In an ideal world, the RefCell&lt;&gt; int could optimise away, but I guess that is not easily provable in general. Option&lt;&gt; is free in this case I think. A safe ring buffer version could do away with the Rc&lt;&gt;, and also the RefCell (maybe?) but the Option&lt;&gt; would cost then. An unsafe version could do away with all of Rc/RefCell/Option, I think.
Experimentation and variety is the best possible thing Rust can have now. Rust is young, there's no need to focus on a single approach (or even if there's only one approach, there's no need to focus on a single implementor: different people have different touches that may make all the difference long term).
There's no need for Rc and RefCell, you can just use unsafe code and check when head == tail. Also, see libsync/spsc_queue.rs and libcollections/ringbuf.rs for existing implementations. 
Or maybe they are aware, and are just tired/distracted, so made a mistake (maybe the words "strong" and "static" are similar in Portuguese? I don't know.). It's far better to assume good faith.
Are you accessing the vector sequentially? If so, using an [iterator](http://doc.rust-lang.org/master/std/iter/) would be better. for x in array.iter() { ... } will optimise to something very similar to the equivalent C. (Modulo the bug [#11751](https://github.com/rust-lang/rust/issues/11751) which has had progress made on it.)
I don't think the `.clone` in `take_unwrap().clone()` is necessary, and I don't think the `clone` in `self.tail = Some(new_tail.clone())` is necessary. (In particular, the first is already returning the `Rc` by-value out of the `Option`, and `new_tail` is not used after the second.)
when there's only one item in the queue isn't the only time you have more than one pointer to the same entry. The tail pointer and the second to last entry both point to the last entry in the queue. there's also std::collections::DList which is a doubly linked list. They seem to use raw pointers under the hood. 
I created /r/rust_gamedev a few days ago because I think that game development in rust is significant enough to warrant its own subreddit. I've worked on a few gamedev projects that I would have liked to share, but I felt like it wouldn't have been interesting enough to the wider rust community to post on the main /r/rust subreddit. Please post __anything__ related to game development in rust on this new subreddit! I'll be finishing a few Piston tutorials that will go there as soon as I'm done!
For the clone in if self.is_empty() { self.tail = Some(new_tail.clone()); self.head = Some(new_tail); } ... it should be necessary because i want both head and tail to point to the same place. Maybe I could do something like `self.tail = Some(new_tail)` and then `self.head = self.tail.clone()`, cloning the `Option`. Would that then propagate the clone to the enclosed `Rc`?
Is cloning a pointer really that inefficient? Should be better than copying the whole object right?
[http://www.reddit.com/r/rust/comments/26dd52 /trying_to_write_a_function_that_returns_a/chpywk9](http://www.reddit.com/r/rust/comments/26dd52/trying_to_write_a_function_that_returns_a/chpywk9)
`goto` would completely break every single safety guarantee that Rust aims for. But give me a use-case for `goto` that can't be properly be handled by Rust.
It's perfectly fine, but it's not just copying the pointer, the reference counts are adjusted, so the code will be slightly more efficient if you avoid the clones (this is more important with `Arc` where the `clone`s are atomic, and so cause cache line contention etc). (I never suggested you remove them all, or that they were bad; my original two suggestions were for removing `clone`s that are literally pointless: i.e. the code should still compile after you delete the 8 characters `.clone()`.)
Restricted `goto`s would be possible (e.g. only allowing forward `goto` with the appropriate initialisation/validity tracking, which already exists for cases like `loop { if cond { break } ... } ...`).
10 points for horrible ASCII art.
Phrasing it this way has the likely effect of making it seem even later. I could tell you that its expected release is in 2014. It would be true, but would set unreasonable expectations with people, who might end up hoping for its release tomorrow or next week. I don't think it's a good idea to start off on the wrong foot with users. Every time there's a new Ubuntu release, and it turns out to only be available on the mirrors at the end of my day or even the start of a new one, I get a slight bit annoyed. If you're upgrading, it already can take quite long because the servers used to get absolutely *hammered*. It'd be so much nicer if they'd just advertised the next day and it 'looks' like it's available early. Expectation management is useful. I'd rather have people advertise Q1 2015 and then get all excited when it turns out the real release date is (say) Christmas Eve 2014.
&gt; we are doing a better and better job of easing the transition pain there. Many changes are done completely backwards-compatibly by deprecating old functions As a downstream library maintained I can say that this is a *great* thing, and makes transitions much smoother. We expect to be constantly updating things, but a small grace period gives us time to update with less pain for our users. Understandably this cannot be done for everything though, especially syntax changes. But thanks anyway for the efforts!
Yeah, it looks like two of those clones in the else block were unecessary. I appreciate the feedback
Software is never released on time. An optimistic person should assume that it will be released at the last possible second while still remaining technically true to the deadline. A realistic person should acknowledge that even if the former were true, the servers will be down. A cautiously excited person should give it an extra week for everything to settle down. Everyone else should just assume it's never coming out because it'll be years behind schedule.
Be that as it may, that tells you about users' mindsets, not about developers' mindsets. I argue that the latter should attempt to advertise deadlines strictly later than the projected release date for user satisfaction.
There is a proof-of-concept try here: https://gist.github.com/klutzy/7819231
So, could this be used to make a wrapper for yt? I know someone who only learned Python to use that.
For others' information: yt is probably http://yt-project.org/
Not everyone may be as cunning a linguist as you are. Transcendent mastery of English is not a prerequisite to participation in this community. Please be kind.
I'm dismayed by this uncharitable attitude. There is no reason not to assume good faith here. If at all possible, I would like this community to be a haven from the rampant negativity that pervades online spaces.
I wish you had written this as your original comment instead of merely being dismissive. If you see misinformation, correct it, don't just sneer at it.
What if i'm not accessing the slice in sequential order?
I'm sorry for that, it wasn't my intention to be dismissive. 
It's okay, the other commenters in this thread have just put me on edge. I'd like this subreddit to be a constructive space.
I agree with you. And i hope Rust to be widely adopted. For this the Rust ecosystem needs to be rich and useful, and a complete web framework would be important.
Here is a related issue https://github.com/rust-lang/rust/issues/2235
(And/or `#[no_mangle]` to just disable mangling and use the function's name as the symbol name.)
it great!
FYI, I'm working on something similar, but more of a map-reduce "worker/task" parallelism thing. Going to try to present my solution at the August Seattle meetup. &gt;.&gt;
I'm getting JS errors in FF. ReferenceError: PreloadStore is not defined ReferenceError: PreloadStore is not defined ReferenceError: Discourse is not defined this is because the FF cross-origin policy is blocking the CDN JavaScript files from loading
Assalamualaykum, myself from Delhi.
No, thank you! I'm glad most people are finding it useful.
Thanks!
Nice to meet you! Sawrubh is also from Delhi, you might be able to meet up if there are more of you :D
yes, I went through the documentation, but was hoping to learn Rust whilst learning Iron. And the documentation does not do that for me :/ (not that it should)
I'm not really a rust user yet, but I would be interested in a meetup or session (and could probably get a few friends to join) if it is focused on beginners.
Very impressive, thanks for doing this! From a quick glance at the source I already learned a new trick: the [macroexpand.c](https://github.com/lukemetz/rustpy/blob/master/src/macroexpand.c) file. That's very clever! No more reimplementing C macros in Rust :) For `#define`d constants, you would have used a C global variable?
nickels author here. This was previously named "floor" but I wanted to have a name with a stronger connection to Rust. Just to clarify upcoming questions ;-)
A related question: If I want to write a library that can be called from other languages via FFI, do I need to restrict myself to `#![no_std]`/`libcore`?
I'm seriously worried that we might end up without metal names for libraries. Time to remove the dust from that periodic table.
I also did this a while ago: https://github.com/hannobraun/rum Unfortunately I haven't had time to work on it again.
As long as you like infinite scrolling, anyway.
A "Rust-like language" is not good enough. Don't get me wrong, it's a nice work, and cool thing to do, but as a langage X user, I don't want to work with "a language Y that is almost like X", I want exactly X, **with all the libraries that go with it**. The ecosystem is half part of the language.
looks very promising. Reminds me of all the new Go REST libraries. This goes a long way in making Rust more interesting for many shops.
What's not to like, there are no downsides: * shorter loading times, since only data is fetched, not the whole HTML * always the right URL (copy it and you'll have a link to exactly the comment you were at) Pagination is an ad-hoc workaround to the problem that threads become very long and can't be loaded in one piece, and that, even if the whole thread could be loaded at once, loading the end or another section of the threat should be as fast as the start. That links to thread sections are links to pages is a consequence of this, not the ideal solution. Discourse is IMHO far closer to an ideal solution than a paginated forum. Much simpler: there are only forums, threads, and posts. They all are linkable. /edit: OK, there's one downside: text browsers for blind people suck and partly can't cope with JS, and discourse has no paginated fallback.
I like it. I'm not sure if "as" is absolutely the best possible option, but at least to me it reads a lot better than = does.
You should probably also tick [iron](https://github.com/iron/iron).
As far as I can remember, iron is another web framework's name
The to_string() in request.params.get(&amp;"userid".to_string()) does not look good to me.
Infinite scrolling means that the scrollbars can become very small, which presents its own user interface issues. Apart from that, it's a mostly good enough solution. If the page presents pagination as a fallback (if JS is disabled or the user disables scrolling), I see no problem.
That actually works. The version /r/qrpth provided executed the step before the loop so was broken at the edges.
woah! So many awesome names. I think I have to start a couple of other rust projects.
Oh, this was Floor? Good to know, I like this better than Iron, because it doesnt use arbitrary names like Alloy and Furnace that means nothing to someone using it. Floor was simple and usable and nice :)
You can always use `find_equiv(&amp;"userid")`, since `params` is a `HashMap`
I didn't see a link to the github project in the page, which would be nice since there are a bunch of projects named nickel in github. https://github.com/nickel-org/nickel.rs, right? Edit: ah, the [Star] icon takes you to the project, doesn't just mark it starred
The first thing I noticed was some unusual coding styles. The usual style is: -use a::{ b, c }; +use a::{b, c}; // No space around braces -fn f (...) { +fn f(...) { // No space before the opening paren
Proper UI toolkits (like Qt) have a minimum scrollbar size.
:) I started it thinking that "it'll a cool thing to do" and dreamt of hitting proggit/hn front page and all the glory. I assure you, I do have your point in my mind but I am not sure what the users want (if there are any). aside: I wish people offered feedback like you did instead of showering downvotes. Thank you for the wise advice.
Minor annoyances about all infinite scrolling (not just discourse): The scroll bar is basically useless with infinite scrolling. You can't click and drag it since the size and location will change when more of the page loads and you can't use it as a quick indicator of where you are on the page. Discourse gives you an indicator in terms of what comment number you're at, but if there are a few really large comments this becomes less accurate. Then when you click an external link and use the back button you have to load the top of the page again if you want to scroll up. Also, and I have no idea if Discourse solves this or not, but pagination is much better when searching via Google since the pages index much better and are basically individually queryable (sp?). Side-note: discourse needs to let you search for a particular user within a topic and search on meta text within a topic such as the topics at the bottom. It is pretty annoying they hijack the search functionality and then search a subset of what the browser searches. EDIT: probably unfair to say discourse's search feature searches a subset of what the browser does when in reality it is actually probably more powerful since it can search different topics and such. I was just annoyed it hijacks browser functionality and breaks users' expectations.
Some bikeshedding here: why is the middleware func called `utilize` instead of `use`? Is it too similar to the keyword?
I am guessing that the starting point will be to come up with the DSL or CFG to define the file format (by the way, can I transform macro argument expression to string?). I see projects like [rustlex](https://github.com/LeoTestard/rustlex) which make me believe that it can be done but it looks scary. update: I am able to prototype macro for a simple format but repetitions are getting out of hand. #![feature(macro_rules)] use std::io::extensions::u64_from_be_bytes; macro_rules! parse_binary_data ( ($inp:expr, $a:ident: $($b:ident[$c:expr]) +) =&gt; ({ let mut p = 0; $( let end = p + $c; let $b = $inp.slice(p, end); p += $c; println!("{}", $b); )+ }); ) fn main() { let a = 4; // first 4 items store the size let data = [0, 0, 0, 2, 0x61, 0x62]; // first four item [0, 0, 0, 2] =&gt; 2 bytes body follows parse_binary_data!(data, file: size[a] chunk[u64_from_be_bytes(size, 0, 4) as uint] ); } edit: update
Essalamou 3alaykoum ya husain For me, the best features of Rust are affine types, destructors and the borrow checker. Does Dust support them? Is it low level like Rust? If it only borrows the syntax then i think there are better syntaxes out there. Just check ML or Elm. Ah! I forgot something very important!! Does Dust support threads? Does it solve the callback hell problem ? This is the most painful thing i find in web dev. When i saw your post in r/programming. I said: is this it?
it's not legal to use the keyword `use` as a function name afaik.
I'm sloppy at times. Willing to improve on that though :)
Great you liked floor! To be fair, iron is a bit more mature at this point. I have a limited time budget currently but it will improve step by step. I also hope to find more contributors to help me on the mission :)
Thank you! I'm glad you liked it :)
I really like huonw's suggestion that this eventually be expanded to allow for `pub use foo::{bar as x, baz as y};`.
`next()` does not always make sense for functors though.
What are the philosophical differences between this and [iron](https://github.com/iron/iron)? They look pretty similar (from a first glance).
Even then, with enough content, a pixel-movement in the scrollbar can scroll by a substantial amount.
&gt; you may need to manually start a Rust runtime Is it possible to have multiple Rust runtimes running in the same process (in different OS threads)? For example, a non-Rust application links to two (or more) libraries written in Rust
I'm interested in this as well. There are a few projects out there that all seem to provide the same functionality, but use different names and are at different levels of 'completion' (iron e.g. seems to offer a bunch of middlewares).
&gt; take filter out of Iterator and make it a freestanding function -&gt; fn filter&lt;I : Iterator&gt;(..) Yes, but then you can't call it using method syntax (and also need to import it separately). (I think making it a default method for this reason is gross, but this, as far as I know, is the reason. Anyone who knows better, feel free to correct me.)
You don't have to limit yourself to names of metals. Rust, after all, is an oxide of **iron** alone. So there is little reason to use nickel, but not chlorine, hydrogen or silicon. Just go nuts on the entire periodic table...
internal vs external iteration.. both have complimentary uses,so I think it would be good to have both. The internal iterator style is good for parallelising (that's my interest),whilst the external iterator style seems to allow elegant chaining without allocations 
Could you elaborate on this a little, i.e. what it does, how it works?
Don't functors require HKT? see /u/anasaziwochi's post below/above for what I was getting at.
It's been done for Ruby, so it should be possible for Python.
A keyword is a keyword, I don't think any programming language allows keywords to be redefined which would be confusing both for the lexer and the programmer.
Sure, it'd be great if Rust had a `Functor` trait, but that's currently impossible (your trait is **not** `Functor`) because Rust lacks higher-kinded types. A type `F` is a `Functor` if: * `F` is a type constructor of kind `* -&gt; *`. That is, for any type `A`, `F&lt;A&gt;` is a proper type. `Vec` is such a type. A pair (i.e. `(,)`) is not as it has two type parameters; however a partially applied pair `(A,)` is a `Functor`. (This is why `i32` cannot be a `Functor`) * There is a function `fmap(|A| -&gt; B, F&lt;A&gt;) -&gt; F&lt;B&gt;`. * The following law holds: `fmap(id, x) = x` where `id` is the identity function. * The following law holds: `fmap(compose(g,h), x) = fmap(g, fmap(h x))` where `g` and `h` are arbitrary functions. If Rust did have higher-kinded types, then the `Functor` trait would look something like this: trait Functor { fn fmap&lt;A,B&gt;(&amp;self, f: |&amp;A| -&gt; B) -&gt; Self&lt;B&gt;; } A few things to note here: * `Self` (the `F` from the definition above) is a type parameter parametrized by another type parameter, which means `Self` has kind `* -&gt; *` (the currently impossible part). * The instance of `Functor` **does not depend** on the type parameters `A` and `B`. This is **crucial**. How one maps over a container is completely independent of what's in the container (`A`) and what you're replacing it with (`B`). It only depends on the structure of the container (`Self`). * The laws are not checked by the type system (just as in Haskell). * `Iterator` is a `Functor` with `Iterator::map` as `Functor::fmap`. edit: formatting edit 2: `Iterator` might not actually be a `Functor` because `Iterator::map` is actually more `T&lt;A&gt; -&gt; (Map&lt;T&gt;)&lt;B&gt;`. Iterator *objects* might still be `Functor`s since the container type doesn't change in that case.
Sure, but imagine that piston could compile to javascript with a webgl target, and you could just put your whole game in a webpage like that. Doesn't that sound highly awesome ? ;)
You mean with Ctrl+F?
Is there a reason to call `map` `fmap` aside from repeating Haskell's oddity?
Not really. Haskell called it `map` originally and then decided it would be confusing to newcomers so they replaced it with `fmap` and made `map` just apply to `List`. I would much rather just call it `map`, but it might conflict with already existing things by the time we add HKTs.
That makes sense! I like the new name much better than the previous one.
I saw that is seemed to be using clang, but I had no idea what for. Can you elaborate on the basics of what an AST is and how it relates to creating bindings?
indeeed
So, I can't give a general solution, especially since I basically don't know Rust's ffi, but in OCaml, C bindings (like syscall, in particular) are done through what is called "externals". The js_of_ocaml compiler will see these externals and expect a js implementation (and complain about those missing when generating the js file). You can then provide an alternative implementation (Implementing sockets as websockets, for example, or use js console output for printf, etc). I think llvm's Empscripten works similarly. 
Agreed.
Thanks for the reply, I understand that my fmap for i32 is not a functor and I don't know why I even implemented it. But shouldn't this do exactly the same thing as a Functor in Haskell? impl&lt;A,B&gt; Functor&lt;A,B,Vec&lt;B&gt;&gt; for Vec&lt;A&gt; 
Javascript (ES5+) allows keywords to be used as method names: var obj = { return: function() { return "foo"; } }; obj.return() // =&gt; "foo" It's not really ambiguous though, as the syntax for defining and calling methods is different from the ones for 'freestanding' functions. EDIT: grammar
Aren’t metal oxides or metals that are subject to oxidation more appropriate? Looking forward to *tarnish*, *patina*, *Al_2O_3*, ...
AST means Abstract Syntax Tree. The code you write is transformed by the compiler and represented in memory as a tree. This is useful since it makes it easier to perform checks (e.g. typechecks) and transformations (e.g. optimizations) on the code. I guess rust-bindgen transforms the AST of C to an AST that Rust can understand. I may be wrong, though.
If you ask an astronomer, the "metals" are [a lot more elements](http://en.wikipedia.org/wiki/Metallicity) than that!
Very nice! One nit is that it wasn't immediately clear what the `bool` returned by `Middleware::invoke` meant, and I had to jump to the documentation to find out more; I also bet that in a day or two I'd forget which thing `true` does and which `false` does. It's often helpful to use a two-variant enum rather than bool to make the semantics clear at the type level: enum MiddlewareResult { // &lt;- a purposely bad name for bikeshed Continue, Halt } 
FYI - added rust nightly option too (yes, it updates with the rust-nightly binaries/source daily)
On a completely unrelated note, how does one become an intern at Mozilla? It sounds like a lot of people will be jockeying for the position. Maybe not so much as at Google, but I bet there's still a lot of competition.
&gt; Go was designed for web services, and it's where it shines. I hear that a lot. I'm curious to know what that means. How would that statement be qualified? I've been using Go for about a year and a half. I'm not convinced that development time is shortened because of "simpler syntax", which really just seems to be a euphemism for "fewer features". 
If you can build your web framework so that it's not reliant on garbage collection, you get something that scales further and delivers pages faster to the users. That said, it's probably easier to prototype in another environment such as Node.js or Go where you can get faster turnaround times.
The basic example just kind of works: https://gist.github.com/euphoria/004005c8a6a9cb7f1183 I'm not sure about anything more complicated than that, but presumably it would not be too difficult to figure out.
This is essentially just experimental confirmation that for loops really do desugar into something like some `loop { ... }` code that calls `next()` repeatedly and tries to match the output as either a `Some` pattern or a `None` pattern without regard for where `next()` and `Some` and `None` are actually defined. Does anyone know where in the compiler this transformation happens?
If you run `rustc --pretty=expanded`, you'll actually get the expanded form. From the example on the homepage: match &amp;mut program.chars() { i =&gt; loop { match i.next() { None =&gt; break , Some(mut _value) =&gt; { let token = _value; { match token { '+' =&gt; accumulator += 1, '-' =&gt; accumulator -= 1, '*' =&gt; accumulator *= 2, '/' =&gt; accumulator /= 2, _ =&gt; {/* ignore everything else */ } } } } } } } 
Sorry, I edited my post when I realized it was due to println! stuff. It's much nicer if we try to expand something without that.
I've heard from some students that conducted a Rust workshop at the Indian Institute Technology Bombay. Can give contact info privately.
"Some students" -- do you mean me*? I'm a student of IIT Bombay, and I did contact you before about conducting a workshop -- hasn't happened yet though, the semester is yet to start :) *me = Manish Goregaokar
Thus far, all the web frameworks that I have seen in Rust are boring—they’re humdrum things doing just what you could do in any language, more or less. There are, however, various things that can be done in Rust that you really *couldn’t* do in Go, things its richer type system and syntax extensions permit. Things like the strongly typed headers that rust-http tried and which Teepee improves on. I have various plans in this direction that I will get to eventually; I would like to see more experimentation there, too. As it is, I’m busy with Teepee; when it’s ready I’ll be progressing more to demonstrating why Rust is a better language for web development than Go. I’m speaking about some of these things in September: https://thestrangeloop.com/sessions/fast-secure-safe-the-web-that-can-still-be. For a teaser of some of the sorts of things that can be achieved in Rust, ponder over [Ur/Web](http://impredicative.com/ur/) and its claims.
How does Scala do it? Which feature of Scala that Rust doesn't have allows this to be possible?
Higher-kinded types.
Sorry I'm late to this thread, but I'm very curious what specific issues there are with glob imports if the compiler detects any ambiguities in advance and requires explicit import to resolve them?
&gt; rust-bindgen is basically an ugly tree transformation tool Does this mean that, in theory, someone particularly masochistic could rewrite rust-bindgen in XSLT?
I looked up the definition in scalaz: http://scalaz.github.io/scalaz/scalaz-2.9.0-1-6.0/doc.sxr/scalaz/Functor.scala.html But that still doesn't clear it up. Scalaz and Scala doesn't do much magic at all. They just reuse the Generics mechanism that Java has.
You've played around with two bugs * The for loop accepts anything with a .next() method, not tied to an Iterator trait (presumably the Iterator trait would have a #[lang] tag) * The for loop picks up Some, None from local scope The code lives in [`libsyntax/ext/expand.rs`](http://doc.rust-lang.org/syntax/ext/expand/fn.expand_expr.html)
Ruby Rogues is an excellent podcast. I was a guest once or twice, and we didn't even talk about Ruby.
&gt;... is whether routes can be established statically ... I wonder how that would interact with features such as [sub-routers](http://www.gorillatoolkit.org/pkg/mux#Route.Subrouter), which I've grown to expect from web frameworks. --- It'd be really cool if you could, for example, annotate the functions in a module w/ your proposed route attribute. Then "mount" the module either to the root of the webapp or to a sub router.
Are they really bugs? Do the Rust devs intend to fix this at some point? Are there issues on github for them?
I don't know if the Rust devs would agree with my terminology here, but I'd say the prelude is really part of the language, not the standard library. It's just a part of the language that happens to be implemented as a library under the covers. But as you've seen, parts of the language implicitly assume it's present.
A mistake in my post is that `Iterator` and `Option` are not actually in libstd, but in libcore. There's probably a strong case to be made that libcore is part of the language.
I've actually been working on a middleware system for a (non-HTTP) personal project. The pattern I stumbled across more closely resembles ruby's `rack`, and I've found it to be both simple and surprisingly expressive. Basically the gist is that my stack iterates over the middleware backwards: building a recursive `invocation chain.` All middleware yield a `proc(&amp;Request, &amp;mut Environment) -&gt; Response`. With the exception of the last middleware: each one is invoked with a copy of the `proc():Send` yielded from the middleware before it. Since the heap closure your middleware returns is able to close over this: _your handlers themselves_ get to decide whether or not to invoke the next piece of middleware! So your middleware can either return a response itself (causing the invocation chain to unwind) or it could delegate response generation to the next middleware in the stack. I happen to like this because it lets your middleware do things as the stack unwinds such as: time requests, modify responses, trap exceptional circumstances, etc. I believe the `iron` framework lets you do this, but in a different manner. `iron` requires you to write separate `entry()` and `exit()` handlers. Meaning the flow of control is still in the hands of their middleware stack, not the handlers themselves. As a bonus: because my invocation chain consists of sendable proc()s: they can be easily moved among tasks `^^,`
I wrote about it on my blog: http://hydrocodedesign.com/2014/04/02/higher-kinded-types/ Simplest answer: HKTs are one step beyond simple generics. With generics like `Vec&lt;T&gt;`, you're abstracting over a single type like `int`, `String`, etc... HKTs abstract over things like `Vec&lt;T&gt;`, not just `int`, `String`, etc... (Scalaz is actually pretty magical to overcome some of Scala's type inference limitations)
I think so, though there may be some trickiness with how unions are handled. In particular, their alignment and size needs to be computed. But I'm sure those could be attributes in the XML that clang emits.
I'm holding a talk/workshop in IITB in August-ish. You're welcome to join :)
I would say the first is definitely a feature. Picking up Some and None from local scope is debatable. It makes me queasy, but I can't immediately think of a good reason.
Thank you! I understand this a bit better now. You said that you are working on an RFC to add hkt to Rust. Are there fundamental issues that has to be overcome, or is everything in place already and somebody just have to sit down and implement it? 
Ya I imagine so for constants. Originally I tried to rewrite them in rust to prevent the extra dependency (compile a static lib and so on) but they go super deep so i moved on to this.
Cool library! Sounds just like the use case I was going for except in a different field! You surely could although it would probably be better to add another layer of abstraction on top of this to make the binding generation a little more automated. The main blockers I think would be for numpy. I am waiting for a good BLAS binding / implementation for rust such that one would not have to go to python every time some matrix math is needed although I might hack something quick up just to be able to use numpy or something like armadillo.
Ya np! So far this library only manages calling python from rust. For your use case I imagine you would want to go the other way as well. You could take the direction euphoria posted above, or do something to more directly interact with the interpreter and actually register functions (I have not done this before but it seems doable). 
Oh yes I understand, do you think that it is in the scope of this projext to go from one language to the other and vice versa? I know its not implemented yet, but it might be an amazing addition!
Your welcome! Yes, I am. There are a lot of considerations on many issues when extending a type system. Both [Scala][0] and [Haskell][1] had papers written explaining their formalizations of HKTs in their respective environment. Haskell has an intermediate language for it's type system called [System Fc][4], which is an extension to [System Fw][3] (more complex than [System F][2]) and [System F][2] (a [typed lambda calculus][5] variant). Why something like lambda calculus? Well, it's a formal way to talk about expressions and types. Rust also has some peculiar features like lifetimes and borrowing that can play into such a system. Moreover, there are optimal semantics of such a feature, like kind inference, that need to exist for it to be useful and effective. (I'm almost done another blog post continuing from my previous going more in-depth in how HKTs will have an effect on *end users* of the language, rather than the compiler's codebase) [0]: https://lirias.kuleuven.be/bitstream/123456789/186940/4/tcpoly.pdf [1]: http://dreixel.net/research/pdf/ghp.pdf [2]: http://en.wikipedia.org/wiki/System_F [3]: http://en.wikipedia.org/wiki/System_F#System_F.CF.89 [4]: http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/tldi22-sulzmann-with-appendix.pdf [5]: http://en.wikipedia.org/wiki/Typed_lambda_calculus
Would love to join. If you could provide the date and time in advance, it would be great :)
Not yet decided, but I'll let you know.
You are misinterpreting. That is neither a single-line block nor a struct expression.
Neither of them are features. When properly implemented, `for` will only accept the `Iterator` trait (and therefore will only accept the `Option` enum). This is on my short list of things to fix.
this var obj = { class: 'xxx' } won't work in certain versions of IE because 'class' is a reserved word. a bitch of a bug to find too.
That is what I call "the HKT transform", and we are already using it in some places. It's not the same thing, because one can `impl&lt;A, B&gt; Functor&lt;A, B, Vec&lt;B&gt;&gt; for Option&lt;A&gt;` and there's nothing to stop them.
Shameless plug: I wrote a tool called es3ify which automatically quotes these reserved words for you so that your code works in IE8: https://github.com/spicyj/es3ify
To be precise, I was not actually suggesting that it be expanded, just that it makes doing the generalisation nicer.
that's cool, but i think uglify js already covers this in addition to minification.
You're right, it does. This is useful if you want the unminified source when debugging locally.
Bangalore checking in. I haven't written much Rust so far, but I've been following the language for over a year now. I occasionally solve some Project Euler type problems using Rust just to keep up with all the changes that are happening. I'd love to attend a meetup, and could probably even do a short talk. Anyone else from Bangalore here?
It's just a bug that `for` is "broken" in this manner. Theoretically it should not just be an AST transformation, but actually strongly typed and "hygienic" (i.e. you shouldn't be able to define anything that breaks `for` loop, like this post is doing). This would involve having ["language items"](http://doc.rust-lang.org/master/guide-unsafe.html#lang-items) for each constituent part.
&gt; If we are matching a reference with move semantics, then the first approach is not an option. This is not really a correct statement. This program [compiles and works fine](http://is.gd/4voYln): enum Example { Variant1(Box&lt;int&gt;), Variant2 } fn main() { let x = Variant1(box 10i); try_match(&amp;x); } fn try_match(x: &amp;Example) { match *x { Variant1(..) =&gt; println!("Variant 1"), Variant2 =&gt; println!("Variant 2") } } As well as [this one](http://is.gd/kkUwUs): enum Example { Variant1(Box&lt;int&gt;), Variant2 } fn main() { let x = Variant1(box 10i); try_match(&amp;x); } fn try_match(x: &amp;Example) { match *x { Variant1(ref x) =&gt; println!("Variant 1: {}", x), Variant2 =&gt; println!("Variant 2") } } It is absolutely possible to dereference non-`Copy` enum in `match` statements (that said, it is possible in any pattern, e.g. in `let` binding) as long as there are no bind-by-move patterns. This, for example, [won't compile](http://is.gd/xZZ4Eh): enum Example { Variant1(Box&lt;int&gt;), Variant2 } fn main() { let x = Variant1(box 10i); try_match(&amp;x); } fn try_match(x: &amp;Example) { match *x { Variant1(x) =&gt; println!("Variant 1: {}", x), Variant2 =&gt; println!("Variant 2") } } 
I've since [cleaned it up and published it as a repository](https://github.com/bkoropoff/rust-viewbox). The basic idea is that you have a data type and a view type (usually both structs), where the view type is parameterized over a lifetime parameter 'a. Since Rust doesn't have higher-kinded generics, I use a macro to fake them. The macro produces a "view box" type which combines the data type (wrapped in Box) and the view type. The "view box" type is constructed by first moving the data onto the heap (using the box keyword) so that its address is stable. A closure is then called with a reference to the data, and it returns a view into it. The type of the closure is &lt;'a&gt;|&amp;'a mut DataType| -&gt; ViewType&lt;'a&gt;, so if it captures any references, they must be within the now-boxed data (or static) for the lifetimes to work out. The returned view is then transmuted so that the lifetime becomes 'static, which makes it movable/sendable. The boxed data and view are returned together in a wrapper struct. The wrapper struct only allows access to the data via the view() or mut_view() methods, which return a refererence to the view with the lifetime parameter transmuted to that of the view box itself. The wrapper can be discarded to obtain the original data with unwrap(). To convince yourself that this is sound, imagine that the view box saved the closure instead of calling it immediately (putting aside that this isn't presently possible until unboxed closures land), and the view() and mut_view() worked by calling the closure and returning its result. The lifetimes will all work out. What I've done is merely call the closure once and memoize the result. Since the data has been moved onto the heap and can't move around anymore, the memoized view and its references remain good. Transmuting the view lifetime to 'static allows it to be moved around and prevents references within the view from making the type non-Send. However, if either the data or the view types are non-Send for other reasons, the view box will be non-Send, so this sould also "just work". I'm sure I'm missing something subtle here, but it seems sound to me.
That is pretty much the point of the blog post - I give your first two examples (well, presented slightly differently) as things that do work and the third as something that won't. Could the post be presented better to get this across more clearly? Any ideas how? Perhaps I should clarify the statement you quote.
Yes, I've been meaning to change that to some more descriptive enum. It's on my list. Or if you like, you could send a PR, too.
Completely agree with you. Although I don't want to offend anyone, I'm frankly tired of those inspired-by-Sinatra-or-Express web frameworks, so that I'm keeping my eyes on Teepee and wish it's bright future.
Sorry, but I don't see how you convey the idea of my first two examples. Maybe I'm misunderstanding something, but when I've read your post I had an impression that you mean that matching `*x` when `x` is a reference to move-only type is impossible at all, because you said &gt; If we are matching a reference with move semantics, then the first approach is not an option. That is because `match *x` would move the enum value out of `*x` (rather than copy it). Any other references to the enum value would then be invalid. and gave no examples similar to mine after that. But it is not correct, you *can* match on a dereference of a *reference* to a type with move semantics, you only can't have *patterns* with move semantics. Moreover, as far as I understand, this statement &gt; That is because `match *x` would move the enum value out of `*x` (rather than copy it). also not exactly correct. `match *x` would move the enum value out of `*x` only if any pattern inside it do bind-by-move. If they all have bind-by-reference (or bind-by-copy, for `Copy` types), it won't try to move out of `*x`. Edit: more clarification
You're welcome :) Thanks for writing this series of posts, they're really good!
Bear in mind that the scope of Teepee is the HTTP toolkit, the low-level stuff; the higher-level stuff I have in mind is unlikely, for the most part at least, to fit into the scope of the Teepee project.
I see, I'm a big pan of Spray (will be akka-http soon) which provides type safe, immutable HTTP model as well as an elegant routing DSL. I think Teepee is in the right direction like the former.
Spray’s goals coincide quite a lot with Teepee’s. I haven’t looked at it minutely at any point, but what I have seen I have very distinctly liked.
There is a lot of bits like that, but the interface between language and library seems to be designed so that user code can forego the standard library and plug itself into those "assumedly present" bits via lang item attributes. As pcwalton said in another comment thread, that the for-loop doesn't make use of lang items is a bug (or maybe a consciously postponed layer of polish).
Now updated - corrected as pointed out by /u/dpx-infinity and with a few more details I discovered on the way to fixing it.
Thanks. I think I mostly understand the implementation... but not the motivation, the "why". Why is there a need for separate `FooData` and `FooView` types, with separate references to each of the fields, instead of just `FooData` and `&amp;FooData` for the view (with the latter being internally transmuted to `&amp;'static`)? And (I'm probably being incredibly dense here) what does `FooBox&lt;FooData, FooView&gt;` let you do which `Box&lt;FooData&gt;` doesn't? There's a bunch of gymnastics going on to allow storing references into the `FooData` alongside the `FooData` itself, but as far as I can tell, you could just create those references when necessary anyways. Is the idea that the closure passed to `new()` would be doing some kind of expensive calculation to retrieve the references, which we only want to do once, and thus this is basically useful as a kind of caching? Or to put it another way: is the win here in expressiveness or just performance? I'm guessing this would break if we were to gain the temporarily-moving-out-of-`&amp;mut` capabilities which are vaguely being planned for some point in the future? (And/or if we gain the ability to move out of smart pointers directly.) (I've been thinking about intrusive data structures and non-moveable types lately, and this sounds like it's related, which is why I'm interested.)
Every type in Rust that is used to refer to something (except raw pointers) carries a lifetime parameter with it (at compile-time). I'm talking about referencess, slices and closures. This lifetime parameter is not always visible. In a lot of places you don't need to specify it. But the Rust compiler deals with these all the time and sometimes you have to specify it explicitly as a programmer, for example if you want to return a reference from a function or if you want to store a reference in a struct. This lifetime thingy is just a name, not a keyword. You can think of it as referring to a scope which "owns" your pointee. As long as execution does not leave this scope, your pointee is alive. That's where the word "lifetime" comes from. In Rust these lifetime parameters are used in order to guarantee that no reference outlives its pointee because it would be a dangling reference and we don't want that (memory safety). If you try to create a reference that lives longer than its pointee, you'll get a compile-time error. Isn't that nice? :-)
There is an issue for this https://github.com/PistonDevelopers/piston/issues/418 It seems there are some features in LLVM that Rust uses which are not supported by Emscripten yet. If you know a way to work around this or have a plan for progress in this direction, please post comments on the issue.
Discourse's particular implementation of infinite scrolling is actually even more annoying than that, because it *unloads* posts after you've scrolled past them (but only past some magical horizon distance, same as the magical distance below you where new posts are loaded). I hope you like a jumping scrollbar thumb. This makes Dicsource topics basically impossible to read unless you have an active Internet connection, even if I've already "loaded" them into a tab. (Yes, some parts of the world are not "always on".) They *do* have a perfectly valid paginated view, but it's only available in the &lt;noscript&gt; so you'll have to turn off Javascript. The developers have repeatedly pooh-poohed any notion of making this pagination available as a user preference because "[you're] doing it wrong". Actually that's been the response to several bug reports. I'd continue moaning, but I'd already exceeded my monthly rant quota before I even started this comment. :-)
Not really directly inferable, but anything that has to interact with tasks is likely to require a runtime, including, but not limited to: - most IO (since the implementations are proxied through the task IO handler, e.g. to libuv, or to native APIs) - most synchronisation primitives (since they could block and thus need to return control to the runtime scheduler) - anything using `std::local_data` (often indicated by being labelled as "task local"), such as `std::rand::task_rng` and `HashMap::new` (which uses `task_rng` to randomly seed itself, to try be resistant against DoS attacks).
I just finished installing it today... not sure if it was the same line but I had to do a lot of twiddling. - Install msysgit to get the unix tools set. I worked in the git shell after that. - Check out cargo via the git-shell and tried to make. Of course make is not in msysgit so had to download make and dependencies from gnuwin32 and dropped in the Git\bin folder. - Make now mostly worked, but 'make install' did not (various folder name issues). So I thought I will run install.sh directly. Had to modify install.sh to change the 'install -m644' to a simple 'cp' .Again I could have got install from GNUwin32 but I felt I was getting close. "make -n install" was my friend when it comes to telling what make was doing. - Ended up running install.sh manually and providing the paths on the command line. That finally worked : install.sh puts the cargo.exe in the Rust\bin folder and cargo-&lt;subCommand&gt;.exe's under a Rust\bin\cargo\ subfolder. -When I called "cargo.exe build" from my rust source code folder got an error saying the subCommand did not exist. So for now I have copied cargo-*.exe and put them side by side with cargo.exe. While typing this I realized that I probably just need to add ...\Rust\bin\cargo\ to the PATH. Then cargo.exe may have been able to find it, and if this works for you, this is the preferred approach (matches what the cargo installer is doing). I added an external git dependency to my app and on the next build it pulled it down from github and compiled it without issue. 
Well -- it would be a kind of hidden feature. Isn't it confusing if there are exceptions to the transformation of any code like `for x in iter { ... }` into `for x in iter.filter(..) { .. }` ? That would be true if some `iter` values don't actually implement the `Iterator` trait. That said -- it does enable some things that the Iterator trait doesn't.
If only it loaded cross-domain requests correctly in Firefox... fix your CDN!
it would be good if there was some explanation why this change is being proposed / made. Both syntaxes look fine to me.
Why do you say there was no explanation? I think I gave a very detailed explanation in the RFC. Basically * OCaml, Haskell and Python use `=`. * `:` doesn't fit with the rest of the language - I read `A: B` as "`A` **is a** `B`", and "x is a 3" doesn't work for me. In other words, I expect the more general entity to be on the right of the colon. * It fits with the syntax for keyword arguments used by `println!`.
I completely agree with your proposal. Why the heck did they choose this weird syntax?
I would be even happier with `Point(x=3, y=5)`. The current braces are awkward either way you space them.
Ok, this is probably not going to happen, and is not very important, but just for the sport - please go over to [discuss.rust-lang.org](http://discuss.rust-lang.org/t/replace-point-x-3-y-5-with-point-x-3-y-5/198) and reply with "+1" if you prefer `=` and "-1" if you prefer `:`. I personally think that for bikesheddings like this, newcomers reactions might be more important than those of experienced Rust developers, which have grown accustomed to the current state. Of course this is not a general rule, but some quirks are harder to see once you've become accustomed to them.
&gt; reply with "+1" if you prefer = and "-1" if you prefer :. It would be better to set up a proper poll if that's what you're trying to do.
If you find performance bottlenecks in std please report them, even if you don't want to debug them yourself. This is an important use case.
Glad to see this. Will it integrate into any of the developing 'middleware' stacks like Iron?
&gt; : doesn't fit with the rest of the language It depends on how you look at it. From another perspective, it fits. The rust language tutorial states that the structs must be declare before they are used, and that their syntax is: struct syntax: struct Name { field1: T1, field2: T2 [, ...] } where T1 and T2 are the fields' types. Then, it says that to construct a struct, the same syntax is used, for which they provide the example: Point { x: 1.0, y: 2.0 } In the above example, 1.0 and 2.0 are literals which are used to infer the types assigned to x and y. Hence, the same syntax. In rust, struct fields may be mutable. With type inference, the field may mutate if a variable with a different type is assigned to it. So, if the type of a struct field is supposed to change then it's appropriate to use a syntax which suggests just that. Coherent.
No :p
Actually it is. How do I set up a poll?
Er, actually, I was thinking of Gaurab, who organized the workshop in march, which I just realized *you* conducted. Thanks!
What about `Point{x=3, y=5}`? I actually prefer it. I hope `Point(something)` will someday be made a syntactic sugar for `Point::new(something)`, so I like the distinction.
Someone else? :D I would have known of a Rust workshops in IIT Bombay though, I've sort of been very involved in the programming community here; unless this happened more than two years ago. Sure, contact info would be nice (even a name would work), via PM or email. *confused*
I don't understand. How could the type of a field be changed? Why should the types of `x` and `y` be inferred if they are explicitly stated in the struct definition? 
it looks like JSON, its familiar
Thanks! I'm using Python a lot, which has {'x': 3, 'y': 5}. I think it doesn't feel strange in Python and in Javascript because they don't have "name: type" used everywhere.
You mean `Point { x: 3: int, y: 5: int }`? Yeah, that would be weird.
&gt; I don't understand. How could the type of a field be changed? [From the tutorial:](http://doc.rust-lang.org/tutorial.html#data-structures) &gt; Structs have "inherited mutability", which means that any field of a struct may be mutable, if the struct is in a mutable slot. So, struct fields may be mutable. &gt; Why should the types of x and y be inferred if they are explicitly stated in the struct definition? The struct definition is one thing, but this RFC is about [structure expressions](http://doc.rust-lang.org/rust.html#structure-expressions). Structure expressions don't include explicit type information. And one of the key features of rust is type inference. 
&gt; structs follow the first half of this but not the second. It would be more consistent if they did. In this context, I see this expression: x: 3 as this: x: &lt;!-- the type of that thingie at my right = --&gt; 3 
Yes.
&gt; So, struct fields may be mutable. Struct fields may be mutable, but their type can't change. &gt; Structure expressions don't include explicit type information. I don't think this is type inference. Type inference is when you have `let x = f(y)` and you don't have to specify the type of `x` since the compiler knows the return type of `f`. Even in C, which doesn't have type inference, you don't specify the type when assigning to a field.
If I understand correctly, you see `x: 3` as a short form for `x: int = 3`. But note that you already have let x = 3; as a short form for let x: int = 3; and it uses a `=`, not a `:`.
It's better than `Point { x = 3, y = 5 }` by a lot! (just the spacing style) I just think some gentle unification of enums and structs would be nice, for example all of them having constructors using ()'s.
Think of it this way: in the declaration of a binding/variable, `:` is used to declare the type of the binding. In the declaration of a struct, `:` is used to declare the types of each field. In the initialisation of a binding/variable, `=` is used to declare the value of the binding. In the initialisation of a struct, `:` is used to declare the value of each field. Wait, what? Continuing to use `:` to construct structs would be like changing this: let x: int; x = 1; to let x: int; x: 1; With the proposed change, both `:` and `=` would be consistent—`:` is always followed by a type, and means that the preceding name is of that type. `=` is always assigning a value to something. Perhaps the struct syntax could even be extended to allow type ascriptions while *constructing* a struct: let x = Point { x: f64 = 2.5, y: f64 = 6.2, } This could be useful with generic structs, perhaps, or even just for clarity. And then you *still* have that similarity between the struct declaration and the struct initialisation, but it’s clearer here—the colon means the same thing.
Cool, thanks.
I agree, the syntax is not coherent. 
Which Go REST libraries are you reminded of?
I proposed this the last time around, and I still prefer `=`. But I'm not willing to push on this again. Anyway, the killer argument in support of the status quo (I think) is that initialisation and destructuring _must_ match and if we use `=` in destructuring then the assignment is going the wrong way round, e.g., let Point { x = a, y = b} = p; 'Assign's into `a` and `b` where a reader might expect that we assign into `x` and `y`. I see no way to address this issue in a nice way. My suggestion is to prefer using `@` in this situation: let Point {a @ x, b @ y} = p; Which is currently legal syntax and would presumably remain so if we moved from `:` to `=`. However, `@` bindings are not widely used and this also binds `x` and `y` as local variables to `p.x` and `p.y` which is kind of suprising. And it doesn't really solve the issue of `x = a` assigning into `a`. So all in all, not a great solution.
Oh no, not more 'boo Go, yay Rust' :/ I liked this post except that part.
Sorry, I did not see the RFC details in the commit itself that the link pointed to
Ah, I've seen martini. I didn't think of it as new.
Yes, it's strange. But I think there's some sort of strange reversal in all destructures. In the case of enum variants, `Point(x, y)` usually takes the existing `x` and `y` and produces a point, while `let Point(x, y) = p` takes a point and produces `x` and `y`. `&amp;x` is usually used to create a reference from `x`, but `let &amp;x = r` creates a value from a reference. I'm just saying that coming from Python, all of these need a moment of thought before I realize their meaning. And it's not that `let Point { x: a, y: b}` is much clearer, although it doesn't suggest that `a` is assigned to `x` so hard. Perhaps the solution would be to allow to omit the names, and have let Point {a, b} = p; or just recommend the boring, tiresome, but clear let a = p.x; let b = p.y; 
`rust-http` is being redesigned into [Teepee](http://chrismorgan.info/blog/introducing-teepee.html). Not that it is any reason not to develop your own, just giving context for `rust-http`.
I believe Rust will certainly be the reference language for most systems language of the future. But I wouldn't go as far as to say it is "the" language of the future. I, for one, want a purely functional systems language with linear (instead of affine) types, applicative functors in the module level (making both the module level a lot more powerful and replacing the need for generics and higher kinded traits), strictly evaluated and dependently typed.
The only real downside to Utf-8 is, as you mentioned, the `O(n)` indexing of characters. But when is that really a problem? To me, needing the nth character from a string is a strange operation: Most of the time, you can deal with byte indexing or iteration over the string, both of which are efficient. Chars aren't sufficient for, say, unicode text layout, as they don't correspond to graphemes, so it isn't a useful operation for rendering text either. If you don't care about unicode, you can always do byte indexing and hope your bugs aren't too bad from that. What do you need to index based on characters for?
A more detailed version of some of the other responses here: http://www.utf8everywhere.org/
[This website is nice](http://strawpoll.me)
Go stores all strings internally as arrays of the 'rune' type, which is a typedef of int32 http://blog.golang.org/strings
No, I believe [Go 'strings'](http://blog.golang.org/strings) are arbitrary byte sequences, with the convention that they hold UTF-8 encoded data, e.g. the conclusion of my link just there: &gt; To answer the question posed at the beginning: Strings are built from bytes so indexing them yields bytes, not characters. A string might not even hold characters. In fact, the definition of "character" is ambiguous and it would be a mistake to try to resolve the ambiguity by defining that strings are made of characters. &gt; There's much more to say about Unicode, UTF-8, and the world of multilingual text processing, but it can wait for another post. For now, we hope you have a better understanding of how Go strings behave and that, although they may contain arbitrary bytes, UTF-8 is a central part of their design. (Ken Thompson and Rob Pike invented UTF-8 and both work on Go.)
Can you post any links to papers on the first two topics (linear vs affine type systems, and module level (applicative) functors)?
Hm, that's a good point, the thing I was specifically trying to do was see if the last character of a string was a '/' or not. The obvious example of indexing long strings is when you're handling a file in a text editor and want to jump to specific lines or positions in it (eg. bookmarks or vim's go to character 15 on this line).
hm, looks like I didn't read that post properly. You're right, looks like this is more complicated than I realized.
It's not particularly complicated; just use UTF-8 everywhere. :P
That code-points don't represent individual characters, so much as that you can represent single characters with multiple code points and that you have to normalize utf8 code point sequences to get 'character' sequences, is to be specific, more complicated than I realized. 
That kiiind of sounds like ATS.
Additionally, for a text editor, contiguous *anything* is the wrong representation of text. You want a data structure that makes edits cheap.
Linear and affine type systems are very similar, but linear type systems enforce that you use a variable once, and affine type systems enforce that you use at most once. And [this](http://caml.inria.fr/pub/papers/xleroy-applicative_functors-popl95.pdf) is a paper about module level applicative functors.
omitting names is already allowed.
I didn't find performance bottlenecks, the issue is more a lack of low-level features. For example the fact that it's impossible to call `sendfile` or `select` on a socket. 
Not sure if it makes developing faster for people who already know the language, but certainly Go is easier and faster to fully grasp than Rust due to this simplicity. Also, one shouldn't dismiss the value of lesser cognitive load when it comes to programming, and Go certainly succeeds there.
What /u/Denommus said. What that means in practice is that you can enforce more invariants. Imagine that you've got a `File`. In an affine type system, you'd be allowed to throw it out -- but in a linear type system, you need to do something with it, e.g. call `close_file(File)`.
From my limited exposure and experience with Rust, it's a solid language but I don't think it will ever really dethrone C and C++. It might actually go after the higher level languages like Java and C# instead. But again, total disclaimer, I dont possess a lot of Rust experience.
It certainly can, and e.g. has been used to write some Linux kernel modules. AFAIR, it compiles to C, and can omit some runtime checks if a proof is available. On the other hand, the syntax is repulsive. Yeah, I know, it's a bikeshedding issue.
Consider the rope data structure for that.
Some benchmarking results with the latest commit on my Ubuntu laptop (sorry I don't have anything better that runs on Linux) with a quad core @2.5 Ghz. `ab -n 50000`:`: tiny-http: 17.1 sec - Apache: 15.8 sec - NodeJS: 7.9 sec - rust-http: 14.7 sec `ab -c 16 -n 50000`: tiny-http: 4.6 sec - Apache: 3.4 sec - NodeJS: 6.2 sec - rust-http: 4.9 sec `ab -c 50 -n 50000`: tiny-http: 4.2 sec - Apache: 3.2 sec - NodeJS: 6.6 sec - rust-http: 8.2 sec I'm using the `examples/hello-world.rs` example for tiny-http, and `examples/server/hello_world` for http-rust. Apache is a fresh installation of apache2 and shows the "apache2 ubuntu default page". This puts it at a disadvantage since it serves more data, but I'll ignore this for the moment. NodeJS script is this one: var http = require('http'); http.createServer(function (req, res) { res.writeHead(200, {'Content-Type': 'text/plain'}); res.end("hello world"); }).listen(9615); 
According to what I understand, in the future it will be possible to move another value out of a partially moved struct.
Those figures suggest very strongly to me that you have built without optimisations. Ensure you’re building everything with `-O`, and ideally with `-Z lto`. Rust should be faring *way* better than that. Also, have you tried running the rust-http performance comparisons?
If and when you do this, I would suggest submitting it as a new link to /r/rust, it would get lost in the comments here by that point.
Eh, [strawpoll works fine for this](http://strawpoll.me/2140255); it's supersimple to set up (don't even need to log in), it has realtime results, and there's literally 2 choices, so *any* chart works fine for visualising it.
Editor will use a special data structure for that. I wrote an editor: github.com/nsf/godit. Mine simply uses doubly linked list of lines. It works if you don't have long lines. And by long I mean something like megabytes of data, because actually linear iteration over memory is fast. As for "ends_with". UTF-8 supports both forward and backward traversal. So, you can implement almost O(1) "ends_with" in a UTF-8 encoded string, if you know its length.
Great to see some "competition" for web servers going on here. I noticed there is another one brewing here by Yehuda and Alex. https://github.com/wycats/rust-civet
Anything that you can program in C, you can program in ATS.
Many people long for a C/C++ replacement - I do -, but we all disagree exactly what needs to be changed. So those seeking a replacement end up fragmenting. Its subjective, basically. I like most of Rust, but there are some things in C++ that I genuinely like which Rust declares as misfeatures. So there is still room for something else, or ambiguity as to whether its worth switching, vs waiting for concepts &amp; modules. The appearance of polymorphic lambdas in C+1y keeps it in the running for me.. c++ no longer feels like a lost cause Safety can be retrofitted with a static analyser. C++11 has the same concept of smart pointers. warnings can be enabled as errors. So this alone isn't enough reason for a company to throw away its existing source base, or for a programmer to throw away many years of their own experience/ditch mature tools. It'll come down to everything else.. and there's many ways a language can go 
To extend on that: The problem of counting and indexing characters is only present in natural language texts, in which it is a complex problem. e.g. whats the length of a normalized UTF-8 String vs. a non-normalized if they both display one glyph with a diaritic? A case can be made of 2 as well as for 1. Most of the time, you need the length for rendering. Otherwise, treating the data as binary is the thing you want. http://utf8everywhere.org/#myths https://dev.twitter.com/docs/counting-characters
Many people interested in Rust seem to be unhappy C++ programmers who want a modern alternative.
If car crashes were as common as software crashes, Volvo would have a good chance though.
... car crashes are *pretty common*?
Indexing strings is useless. Use Vec&lt;char&gt; if you need it for some weird reason. 
It's actually just a wrapper so I believe it could be considered as a temporary solution.
Does it offer safety guarantees, though?
i guess self-driving cars might bring the two types of crashes potentially closer.
Yes: http://bluishcoder.co.nz/tags/ats/
Or `Point { x =&gt; 3, y =&gt; 5 }`?
I hear what you're saying, though while I'd certainly not claim to be the most experienced developer, it seems as though there can also be a cognative load in having to express an idea in code using a smaller set of language features.
On the graph, what exactly is Frequency? Frequency of what?
It's all good. Can't change the facts. I'm just sick of answering "How do Rust and Go compare?" questions, since they're for totally different things. Not your fault... exactly ;)
I assume it's the number of times that range of latencies occurred, so the latency for Turbine was approximately 256ns nearly a million times.
It is my belief that precisely three things have resulted in all these Rust vs Go comparisons. They are novelty, being referred to as a "Systems Language," and the presence of channels and\or CSP. My proposal to remedy this is that we rebrand every existing language we can find as Systems _ and implement CSP in it. I will implement Systems Swift. You can do Systems Perl. Sound good? 
One of the great flaws of Unicode (imho) is that it has several representations of "same" "characters". Precomposed characters, overlapping character encodings taken in verbatim, "special" symbols like [Kelvin sign](http://www.fileformat.info/info/unicode/char/212A/index.htm) (it is just the letter 'K'). And then there is the stupid turkish i/I problem which is kinda related too.
Sounds awesome, as I have a Perl tattoo. (more seriously, yes, I agree with you as to reasons)
Can you compare with https://github.com/sruggier/rust-disruptor ?
Yep. Frequency of events that that fell into that particular latency bucket. Although tiny correction: the test was run 100,000 times, not a million. I've done the test at a few million iterations and the results are the same, but excel implodes with that much data when trying to chart it :)
Can someone explain to me why in some contexts a reference is written as `&amp;` and in others as `ref`? In the match statements, if you want to the matched value x to be a reference to the contents of an enum, I'd expect it to be written as `Variant1(&amp; x) =&gt;`, like 'match a value x such that it is a reference to the contents of a Variant1'. `Variant1(ref x) =&gt;` seems more like, 'take a reference to the matched value x which is the contents of a Variant1', which kind of makes it seem that first we potentially take a copy, and only afterwards take the reference..
I can't, unfortunately. I originally wanted to use that project instead of writing my own, but couldn't get it to compile. It's fallen behind the Rust-Nightlies and I didn't understand the code well enough to update it myself. From skimming the source, there are a few major differences: - Rust-Disruptor (RD) uses owned boxes to store Slot data...which I think means the actual data will not be contiguous in memory. The pointers are contiguous, which is the most important part for cache line pre-fetching, but the data itself will be scattered everywhere. Turbine allocates everything in one block. If you are afraid your data is large enough to cause cache-line problems, you can allocate boxes in the Slot yourself. - RD has multiple waiting strategies (spin, yield, block) while Turbine just has spin at the moment - RD is resizable -- Turbine cannot resize it's buffer - I *think* (but could be wrong) that RD only supports "pipeline" dependencies, where A -&gt; B -&gt; C. Turbine supports arbitrarily complex dependency graphs (parallel processing of the same event, dependencies across tree levels, etc) as long as they don't have cycles - The author of RD appears to have more Rust knowledge than me...so it's highly likely Turbine leaks memory like a sieve and has numerous performance flaws that need tuning :)
&gt; Safety can be retrofitted with a static analyser. C++11 has the same concept of smart pointers. But not *inherited mutability*, which is absolutely crucial for Rust's safety to work. A lot of people miss this and think that Rust is C++ plus static analysis. It is not.
There's lots and lots of new code being written in C and C++.
Naw. C will continue to dominate systems programming for several reasons: - The extant base of C systems code is enormous - The skill set for systems programming is focused on C and Assembler - C is a small language and a good fit for embedded/realtime/firmware programming - There is an ecosystem around C (compilers, debuggers, software emulators, in-circuit emulators ... that's difficult to replace, at least quickly. - There is a huge body of practice - libraries, books, algorithms - in C that gives the programmer a fast route to running code.
&gt; But not inherited mutability, sold on that, its one of my favourite pieces of Rust. Usually when I say const in C++ thats' what I really want. but could a static analyser basically assume you meant inherited mutability, and warn you when it isn't? Could someone add it as a nonstandard extention ? I suspect there's enough value in the world in C++ sourcebases to try it. &gt; A lot of people miss this and think that Rust is C++ plus static analysis. It is not. and sure, I realise it isn't. There's a whole list of things in C++ worth changing. I was attracted to Rust for other reasons aswell.
Ah, interesting. I wanted to start tuning performance with cachegrind, but all the testing infrastructure was making the call-graph irritating to read. So I made a skeleton binary which runs a benchmark to profile that. It looks like throughput has jumped from 30m/s to ~200m/s. Does the test harness really have that much of an impact? I need to verify that the compiler isn't nulling out parts of the benchmark as noops too.
Makes more sense in the other direction `Point { x &lt;= 3, y &lt;= 5 }` ;)
In order to get the safety properties that a language like rust provides, you need to write code with the restrictions that the language imposes. I'm convinced that this is the core trick of computer science. A Turing machine can do a lot, but you can't provide many guarantees about programs written for it. The compiler can guarantee all kinds of things for you in a Haskell program, but you'll have to write your program in a very specific way. You can solve the halting problem for an appropriately constrained language (e.g. one that only allows primitive recursion). Unfortunately the requirement for constraints to prove things means that back-applying static analysis to existing unconstrained code bases can only buy you so much. Rust style ownership guarantees, for example, really only apply to code written to enable them. Tools like [splint](http://www.splint.org/) do exist, but when you write good C for splint you're not really writing C anymore. And if you're not writing C anymore, you might as well fix the really blatant warts in the language (e.g. textual includes, backwards type declarations) while you're at it. As long as a language like Rust can call C code, it's good. If it can call C++ code (which *any* language that can call C can through SWIG), then it's really good. 
&gt; "special" symbols like Kelvin sign (it is just the letter 'K') That's because Unicode has a semantic meaning. Besides, you could imagine e.g. making a cursive Kelvin symbol or something, it's always better in that case. The typical purely-semantic doublon is the HYPHEN-MINUS (inherited from typewriters and so from ASCII) and the MINUS (introduced by Unicode in the basic punctuation plane).
C today is in the position that Assembler was in 25 years ago. Most system-level code is written in it, and it owns all the low level interfaces. High level languages are much easier to deal with and the compilers actually generate higher quality code from them, but low level developers who know the details focus on the edge cases where the compilers aren't perfect and still write the low level code because it seems like a good idea. C has already lost out to C++ in many cases. I don't know what language will take the place of assembler in 1989 in 2039, but I'd bet it'll be higher level than Rust. The video going around recently suggesting it will be JavaScript is too scary to be completely impossible.
This is the signature of `iter()`: fn iter&lt;'a&gt;(&amp;'a self) -&gt; Items&lt;'a, T&gt; where impl&lt;'a, T&gt; Iterator&lt;&amp;'a T&gt; for Items&lt;'a, T&gt; That is, `iter()` returns an iterator which yields references into the vector. That's why you need to dereference `*i` explicitly in `filter()` call and that's why `collect()` returns `Vec&lt;&amp;int&gt;`. The iterator returned by `range()`, on the other hand, implements `Iterator&lt;int&gt;`, so calling `collect()` on it results in `Vec&lt;int&gt;`. There are two different ways to fix your problem. If your original vector (`series`) is not needed afterwards, you can use `move_iter()`, which will consume the vector and yield its elements by value, exactly what you need: let even: Vec&lt;int&gt; = series.move_iter().filter(|&amp;i| i % 2 == 0).collect(); Or, alternatively, because `int` is `Copy`, you can just do this: let even: Vec&lt;int&gt; = series.iter().map(|i| *i).filter(|&amp;i| i % 2 == 0).collect(); Here we're dereferencing every element of the iterator, essentially turning it into `Iterator&lt;int&gt;`. I also used `&amp;i` pattern in the function argument because IMO it is cleaner than dereferencing the variable itself. edit: added more explanation
If you let the perfect be the enemy of the good, you'll wait forever for the perfect language. On the other hand, textual includes really do need to die. It's not a question of subjective opinion, it's a question of basic usability. Compile times that are O(n^2 ) in the number of headers simply aren't viable. Personally, I'd prefer that my languages sucked it up, admitted that the compiler is better than the programmer at managing memory, and used OCaml style value semantics. I don't care if it's on the stack or the heap, and I don't want to think about "references" unless the object is mutable. Stack allocation makes sense exactly when copies are cheap and that will be dependent on the specifics of the hardware - it's clearly the compiler's problem. But Rust style ownership is a reasonable compromise, and writing programs with it should work fine (assuming I can map over values in some future release), so I'll use Rust when it gets a bit more stable.
I believe the test runner uses the green scheduler by default, which will have different perf characteristics.
Ohhh, I didn't know that. Makes sense why that would have very different performance characteristics when it comes to concurrent code like this :)
In terms of Rust, it would mean linear types can't be dropped (generics would likely not accept them without an annotation on the type parameter, like DST's "can be unsized"). This property can be trivially enforced once we can track moves better and we know ahead of time what will be dropped when (right now if a variable with drop glue is moved, it still runs that drop glue at the end of the scope - this is why we have drop flags, to avoid double drops). There remains the question of consuming the linear type by an empowered party. The module in which the type is defined could do this, if the type contains private linear components. Example: struct File { fd: u32, marker: marker::LinearType } impl File { fn open(path: Path) -&gt; IoResult&lt;File&gt; { Ok(File { fd: try!(open_file(path)), marker: marker::LinearType }) } fn close(self) -&gt; IoResult&lt;()&gt; { let File {fd, marker} = self; marker.consume(); close_file(fd) } }
The Turkish i/I problem is not stupid. i is just not the lower case of I in Turkish writing. Same with the Kelvin symbol K having no lower case. Unicode does not encode characters. Same goes for the German ß, which has no uppercase form (e.g. Fußball is FUSSBALL in uppercase). Unicode saves your from impossible transformations, there.
You're taking a reasonably common position, but I don't think it's correct. The things that C uniquely lets you control aren't especially interesting, even for low level operating system code. Mostly C gives you strong control over things like symbols, which are important to C toolchains and infrastructure, but not much else. Being able to get a pointer to a specific memory address can be trivially added to any language. Being able to execute specific machine instructions means writing inline assembly, which you can even do in Perl. Abstraction is a very useful tool, and when presented the way it is in C++ should *never* be a bad thing. Even in an operating system kernel, std::vector should be a win over manually managing arrays almost all the time. I don't expect we'll ever see LISP machines beating general machines. General machines and compilers are too flexible and too well understood. Having to get a new chip to add a JVM feature is ridiculous. I expect to see a lot of back and forth between which things are in hardware vs. software though.
This has always been counterintuitive for me, for the aforementioned ": is for types and = for values" thing.
&gt; The Turkish i/I problem is not stupid. i is just not the lower case of I in Turkish writing It is stupid because Unicode decided to recycle U+0069 (LATIN SMALL LETTER I) for Turkish dotted I instead of the sane solution of using separate "character", like eg U+0131 (LATIN SMALL LETTER DOTLESS I) combined with U+0307 (COMBINING DOT ABOVE).
&gt; That's because Unicode has a semantic meaning And I think that is stupid. &gt; The typical purely-semantic doublon is the HYPHEN-MINUS (inherited from typewriters and so from ASCII) and the MINUS (introduced by Unicode in the basic punctuation plane). I indeed dislike the inclusion of ASCII punctuation in Unicode (see "overlapping character encodings taken in verbatim" part in my parent comment).
There will definitely be C and C++ codebases for a long time even with a maximally-successful Rust. But programmers, especially ones skilled at C or C++, won't be throwing away too much experience by switching to Rust. Most of it is very applicable. Tools are another thing, but we've seen very good tool sets built up very quickly with languages like Go, and Rust does seem to be moving in that direction. Also, I'm curious- what sort of things do you like about C++ that Rust declares as misfeatures?
What's the reasoning behind `iter()` yielding a reference? Shouldn't yielding by value be the common case? 
This is an easy thing to be confused about. Generally, when you see something used in a pattern (such as a match arm), it actually means the *opposite* of what it usually means! Take the following program: let foo = |x: &amp;int| 2 + x; // error! can't add a number to a reference let bar = &amp;3; foo(bar); `x` is a reference here, so to get at the value inside we have to dereference it. That's easy enough: let foo = |x: &amp;int| 2 + *x; // A-OK let bar = &amp;3; foo(bar); ...but what if we want to use `x` a lot? let foo = |x: &amp;int| 2 + *x / *x * *x; // super gross! let bar = &amp;3; foo(bar); ...that's pretty ugly. Let's use a pattern instead! let foo = |&amp;x: &amp;int| 2 + x / x * x; // Lovely let bar = &amp;3; foo(bar); Remember that function and closure arguments are also patterns. Here we've changed the closure's argument from `x` to `&amp;x`. This tells the compiler that the argument will look like a reference, and that we want `x` to be whatever is being referred to. We've effectively changed the type of `x` for the purpose of its use within the closure body, without changing the type signature of the closure. So, essentially, using `&amp;` in a pattern is a way to get rid of a reference when one exists. But what about adding a reference where there is none? That's the reason for the `ref` keyword. In a language that didn't care so much about references, this sort of thing probably wouldn't be necessary. Some may ask, why don't we just use `*` in patterns as a general dereference operator? Well, generally, patterns are supposed to mirror the *structure* of their types. For example, if we take our example and pass in a boxed int rather than a reference to an int: let foo = |box x: Box&lt;int&gt;| 2 + x / x * x; // Still works let bar = box 3; foo(bar); See how, in both this case and the prior one, the pattern on `x` mirrors the initialization of `bar`? That's the symmetry that we're talking about. I don't think it would be *impossible* to use `*x` to dereference references in patterns, and then make `&amp;x` take a reference to a reference in a pattern, but it would be somewhat inconsistent (and wouldn't change the fundamental fact that things still generally mean their opposite within patterns; see struct destructuring, for example).
Complete newbie here, but I'm going to guess that `iter()` needs to support cases where copying is expensive as well as cases where it's cheap. Followup question: why is it that I get the following error when I delete the explicit type after `even`: test.rs:3:14: 3:61 error: cannot determine a type for this bounded type parameter: unconstrained type test.rs:3 let even = series.iter().filter(|i| *i % 2 == 0).collect(); ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Rope (data structure)**](https://en.wikipedia.org/wiki/Rope%20%28data%20structure%29): [](#sfw) --- &gt; &gt;In [computer programming](https://en.wikipedia.org/wiki/Computer_programming) a __rope__, or __cord__, is a [data structure](https://en.wikipedia.org/wiki/Data_structure) composed of smaller [strings](https://en.wikipedia.org/wiki/String_(computer_science\)) that is used for efficiently storing and manipulating a very long string. For example, a text editing program may use a rope to represent the text being edited, so that operations such as insertion, deletion, and random access can be done efficiently. &gt;==== &gt;[**Image from article**](https://i.imgur.com/aAkBuFc.png) [^(i)](https://commons.wikimedia.org/wiki/File:Vector_Rope_concat.svg) --- ^Interesting: [^List ^of ^data ^structures](https://en.wikipedia.org/wiki/List_of_data_structures) ^| [^Tagged ^union](https://en.wikipedia.org/wiki/Tagged_union) ^| [^String ^\(computer ^science)](https://en.wikipedia.org/wiki/String_\(computer_science\)) ^| [^Gap ^buffer](https://en.wikipedia.org/wiki/Gap_buffer) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cj16esk) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cj16esk)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
That is true of 0.11, but not of master. On master, all numeric literals have their type inferred as usual.
I'm obligated to mention that Python *does* have the form `name: type` (though the definition of "type" there is left to your own interpretation). It's incredibly rare to encounter, but it's there. http://ceronman.com/2013/03/12/a-powerful-unused-feature-of-python-function-annotations/
won't that take a ridiculous amount of time for, perhaps, little gain?
The jvm is notorious for security vulnerabilities albeit mainly when running untrusted code, could be interesting for a lot of the reasons servo is interesting.
For one thing, if you're using the related `mut_iter()` function, you definitely need references, since otherwise you'd just be mutating a copy of the value instead of the value itself. Also, Rust (like C and C++) tries to keep costs explicit. If iterating over a container involved making a copy of every single element, that's a potentially huge hidden cost if you thought that you were just looking at them. And, like /u/dpx-infinity described, you can turn the ref-to-everything into copy-of-everything pretty easily, but you can't go from copies to references.
If you don't mind me asking, what sort of applications do you typically write using Go? I find myself in situations where generics would be helpful, or the ability to define a default struct field initialization other than the zero-initialization. Embedding into structs can be useful, but it can also seem to come up short in some situations. I find myself emedding some struct type into several others, but then having to put a method on that embedded type that receives an interface value representing that into which it's embedded, and then making those types implement the interface. Lots of repetition. And then the embedded struct having to be represented separately in the composite literal syntax annoys me a bit. So I guess for me it ends up being just a bunch of little things (there are others too) that feel like they could be solved fairly easily on the language level. Unfortunately the main contributors have made it clear that the language is complete. All this has me watching Rust, and even looking at C++ if I can find a good C++14 tutorial.
Got it, thanks. Do you have time for a couple more questions? 1) Is there a good idiomatic way to convert an iterator to a list without having to repeat the contained type? Something like: let series: Vec&lt;?&gt; = range(1i, 10).collect(); or let series = range(1i, 10).toConvenientList(); 2) Why do we need to use an explicit integer type inside of `range`? Shouldn't the compiler inter the type int from the assignment on the left, or even just default to int?
I heard this so often. Can someone explain what makes Rust especially grep-firendly? I now the basics of Rust but I would like to know what exactly is it that makes Rust easy greppable and are there grep receipts for navigating through a Rust code base?
I have heard nothing of a JVM in Rust, but it sounds like an awesome endeavour! Definitely an awesome project idea! 
There is a JVM written in JavaScript, so maybe a Rust implementation isnt as wasteful as you would imagine... I do not think writing a JVM implementation is a waste of time, it is a learning exercise.
In the best case, it will be a slowish JVM with a poor garbage collector. It might be safer but will anyone care? Incidentally, the unsafety of running untrusted applets in a JVM can't be fixed in the runtime -- it is a problem in the Java libraries. Anyway, the OP might want to look at [LadyVM](http://vmkit2.gforge.inria.fr/geoffray08pppj-ladyvm.pdf) which came up in a quick search. Edit: I mean in the best case considering the resources likely to be at the disposal of the OP and a few friends, assuming no massive funding from somewhere.
&gt;JS is a really interesting and well thought through language Javascript was designed in [10 days](https://www.w3.org/community/webed/wiki/A_Short_History_of_JavaScript), it has many huge flaws and is by no means a well designed and thought out language. Also, he is using 2039 because it is used in [this video](https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript) if you have not seen it, it is very good at instilling fear.
acrichto tells me that is not actually true. --test use the native scheduler by default. There needs to be some other explanation.
Yeah, Rust's overloading can be a pain. I'd really enjoy at least named and default arguments (maybe full overloading, but maybe not?).
That would be pretty funny. Java got its reputation as being insecure because it was believed to be secure enough to run untrusted code from unknown sources.
Hmm, I'm getting an extra error, in addition to the one from above, when I try it with `uint` (rustc 0.11.0)... test.rs:2:27: 2:32 error: cannot determine the type of this integer; add a suffix to specify the type explicitly test.rs:2 let series: Vec&lt;uint&gt; = range(0, 10).collect(); ^~~~~ test.rs:2:27: 2:49 error: expected core::iter::FromIterator&lt;int&gt;, but found core::iter::FromIterator&lt;uint&gt; (expected int but found uint) test.rs:2 let series: Vec&lt;uint&gt; = range(0, 10).collect(); ^~~~~~~~~~~~~~~~~~~~~~ Could it be the compiler version?
Very possible, I'm on `rustc 0.12.0-pre-nightly` from 2014-07-18.
The big problem I see with using LadyVM model though is that it relies on LLVM and the Boehm GC library to do JIT and GC respectively. I feel like relying on other software for these pieces wouldn't be as great a test of mettle than if those two pieces were implemented in Rust itself.
I had the same question: What can Rust bring to this kind of a project? Most of the unsafety of a JVM is in the JIT and the GC, and the Rust model does not help make those safe. It does not make external libraries like LLVM or Boehm-GC safe. Yes, for a toy learning project, some other mini-VM like Lisp would be a lot more fun. I wrote a compiler for the I-APL VM on 68000 a long time ago. The I-APL VM was designed as an interpreter to run a single program, the I-APL runtime/editor environment, but I compiled the code instead and effectively eliminated the VM. That was fun to do.
I don't know alot about static vs dynamic libs, but maybe something like this: trait DoThing { fn do_it(&amp;self); } struct Aye; impl DoThing for Aye { fn do_it(&amp;self) { println!("aye"); } } struct Bee; impl DoThing for Bee { fn do_it(&amp;self) { println!("bee"); } } fn main() { let x = get_dothing(); x.do_it(); } fn get_dothing() -&gt; Box&lt;DoThing&gt; { // box Aye as Box&lt;DoThing&gt; //also works here box Bee as Box&lt;DoThing&gt; }
Yep that was it. Works with the nightly. Thanks again!
Yep, I'm an idiot. I was thinking of the 10m and 100m runs that I did and confusing myself. Hurp durp :)
I am also behind this vision for JS as well, actually. Was also lucky enough to see that talk given live.
There is some pretty crazy macro generation for tuple impls in libcore: https://github.com/rust-lang/rust/blob/master/src/libcore/tuple/mod.rs#L72
In a similar vein, the [tuple impls in `core::fmt`](https://github.com/rust-lang/rust/blob/44a71dee377bebd39a45ba3fe0ccc31e59ac2821/src/libcore/fmt/mod.rs#L657-L685) put effort into only writing one `tuple! { ... }` invocation (and similarly in [`serialize::serialize`](https://github.com/rust-lang/rust/blob/44a71dee377bebd39a45ba3fe0ccc31e59ac2821/src/libserialize/serialize.rs#L475-L512)).
My library [rust-encoding](https://github.com/lifthrasiir/rust-encoding) uses a complex [macro](https://github.com/lifthrasiir/rust-encoding/blob/a59eb71/src/encoding/util.rs#L118-L298) to simplify stateful decoders for character encodings like [this](https://github.com/lifthrasiir/rust-encoding/blob/a59eb71/src/encoding/codec/japanese.rs#L83-L158). I've also written a `scanf`-like [utility macro](https://github.com/snrs/sonorous/blob/9c16827/src/util/lex.rs) for parsing textual formats.
This is actually the opposite of what C with a static analyzer. C with static analyzer is what D is trying to do with its safe code - it's marking "unsafe" patterns as they're found. But it doesn't work out as well as it should, you can't cover every kind of mistake. So you're not safe with a static analyzer that subtracts unsafe cases. Rust starts with a verifiably safe subset and keeps adding to it verifiably safe cases. You're always safe in safe code, but you might need to step out into unsafe code if you really need it. In D, you mark things safe, but it's not actually safe (wat?) Those two approaches are the opposite in concept.
&gt; The only real downside to Utf-8 is, as you mentioned, the O(n) indexing *of characters*. Of codepoints. Within a stream of codepoints you then have a O(n) indexing of grapheme clusters (which are generally perceived as characters). When you're dealing with unicode, it's always O(n).
LLVM isn't that good for JIT, at least for the lower optimization levels it's too slow. Using it in a JIT is actually quite some work (generating the LLVM IR, making the LLVM-emitted assembly play with the other code) I had a class in uni before where we wrote a JIT compiler. We basically took those steps in implementing: - Parsing of the bytecode - A slow interpreter - A simple fast compilation function that emits pretty dumb assembly and calls it afterwards. This needs some glue so that the interpreted code and compiled code can call each other - Improved versions that take longer to compile the code but emit better assembly - some optimizations before the compilation like inlining What you'd additionally need for a JVM is garbage collection. If you want to make it a serious one there's lots of fine-tuning necessary. As the library support for most of that stuff is quite dire in rust, you maybe should aim for a smaller goal: Only write a JVM Interpreter in Rust. That should be enough a project on its own.
`=` followed by value, `:` followed by type, we should always keep this consistency. I vote for `Point { x=3, y=5 }`.
&gt; Do I have a point? Not particularly, other than that it is pretty useful to be able to keep semantics of two symbols separate, without forcibly conflating their actual representation. And I think that the semantics should be handled at a separate layer. One obvious reason for this is that a single "character" can have near-infinite semantic meanings. A "K" in DF is different than a K in nethack which is different from Kelvin etc. Trying to encode all those meanings into Unicode is a folly. 
The `close_file` case is usually handled with destructors. Are there cases where linear types work better than destructors? If so, it might make sense to add an alternative to Drop, where instead of providing a destructor, you specify that letting it go out of scope is an error.
By the way, are you going to have something similar to variadic templates in the future Rust? Because all these Tuple1, Tuple2, Tuple42 traits don't look very.. convincing(?).
There may be more operations you want to do that destroy the type than close the file. Can you have different destructors? Not using destructors also makes operations explicit and visible in the code. That can be a disadvantage in terms of verbosity though.
I found [this article](http://blog.burntsushi.net/rust-regex-syntax-extensions) about creating the regex! macro.
That did it, thank you.
Also that, like Rust, Go was originally marketed as a C++ replacement/competitor. And maybe the Google/Mozilla rivalry might also contribute a little bit of it (who both also happen to have their own browser engine (or two now, in Mozilla's case) and web browsers).
From web to an embedded system I'll be writing over the next 6 months. I've started dabbling in games and I'd like to start an IDE project for fun so I've been mapping out components of that in my head. So far the only thing that has bothered me is the dynamic library situation which has caused me to think more about IPC for plugins. I guess personality and personal experiences would play a large part in this as well. I've run into instances where lack of multiple inheritance has bit me and I could use a clean embedding scheme than places where I wanted a generic solution. I've been the route of over-engineered Java for the sake of reuse for something that gets used exactly one way a few too many times I guess. The tradeoff between code duplication and compile time safety just hasn't been enough to bother me. Now someone writing a library they intend to distribute might have more of an issue with this. But so far I haven't seen many complaints. For default struct initialization why not write a "NewMystruct" or "DefaultMyStruct" function that returns an initialized struct? Then you have the option of zero or default initialized. I'm neither here nor there on the composite literal with embedded struct. On one hand its redundant on the other it's clear code. I'm curious though why you run into a lot of embedded structs and need them to access their "container". I get that you're going for method reuse most likely. Just curious on use cases that I maybe have not hit yet.
Most of Rust's non-`Copy` types are *already* linear. Variables are consumed exactly once: if not by the programmer, by moving out of them, then by the destructor which is implicitly inserted by the compiler. The main exception is `&amp;mut`.
I would *really* like to have some statistics on how much code would break if type parameters were required to have explicit `Drop` bounds.
FWIW, "even" Haskell handles things similar to how Rust currently handles it, by manually implementing type classes upto some large arity (64 or some such). There is no concrete plan for variadic generics at the moment, but it has been discussed on IRC (by one person, at least ;P ) and it may end up being the way we handle the function traits/unboxed closures, in the future. Or maybe not.
&gt;&gt; But not inherited mutability, seems you can write a smart pointer that propagates deep const. Stupidly the standard std::unique_ptr&lt;T&gt; doesn't, but its possible to roll your own, or i'm sure someone would do it in boost. http://pastebin.com/qpmF4fxW of course it would get more verbose having to replace any T&amp;'s in classes with ref&lt;T&gt;'s, but you could use that to annotate lifetimes too. ref&lt;T,LifetimeIndex&gt; Not saying 'rust is a waste of time' .. there's many reasons to want to change the language- just saying it would not be impossible to retrofit safety, hence safety alone is not a compelling reason to switch. 
&gt; It's way more than that. When writing systems code, you need to be able to do things like manipulate registers, inspect stacks and queues, and so on. C is best viewed as being a portable assembly lanugage. It gives you enough abstration so you don't have to fiddle with all the mechanics of the instruction set, but it's low level enough that you can when you need to. I know of no other language that does this (as) well, except for Forth and that's not where the center of gravity of this lives. C itself is actually really bad at this. All of this is undefined behaviour in C, and you can run into all kinds of strange issues when you assume otherwise, especially with modern optimising compilers. It just so happens that most compilers mostly do useful stuff here, and a few even define the behaviour explicitly. If you want a language which actually allows you to define stuff like this, look at Ada.
Having some issues in viewing colors myself the comment by [jacius](https://github.com/rust-lang/rust/pull/15586#issuecomment-48760709) really struck home. Honestly, the dashboard seems cool, but I have a hard time identifying at a glance what is stable and what is not :x
I have written a macro for generating lazy initialized static variables: https://github.com/Kimundi/lazy-static.rs
Yielding things by value would mean moving out of the vector in the generic case, which means either the vector would have to end up empty, or be consumed entirely. But many cases of iterating over an container don't require you to actually get ownership to the elements in it, so yielding them by `&amp;T` is fine.
Would you be allowed to pass `int` as a `T: Drop`? Or would it something like `Drop? T` similar to the `Sized? T` bound, just saying that a type is *allowed* to be `Drop`? On first thought, that seems like it would be rather verbose... essentially every generic in the standard library (other than those on `Cell`) would want `Drop?` for maximum flexibility.
&gt; Would you be allowed to pass `int` as a `T: Drop`? Yes. `fn foo&lt;T: Drop&gt;(...)` means "`T` is a type that can be dropped (allowed to fall off the end of a scope)" and "`f` is allowed to drop this type". The first part of that would be true for *all* concrete types which currently exist in Rust, because Rust currently lets everything fall off scope. It wouldn't be true for: * Type variables (parameters) which do not themselves have a `Drop` bound * [`&amp;out`](https://github.com/rust-lang/rfcs/pull/98#issuecomment-44788950) * New user-declared types like /u/eddyb's example, which are not currently possible The second is also true for all current functions (all of which effectively have implicit `Drop` bounds). It wouldn't be true for new functions written without the bound, which is not currently possible. So all in all this feature would be useful for two things: * Allows the programmer to implement abstract types which *can only* be and also *must* be consumed by functions which the programmer herself provides (again, see /u/eddyb's example). (`&amp;out` is a specific case of a hypothetical built-in type which would want the same thing.) * Allows greater restrictions on, and thus static information about, what things functions may or may not do (parametricity). &gt; On first thought, that seems like it would be rather verbose... Basically, you would need `T: Drop` if you want to be able to let a `T` value fall off the end of a scope (or want to call a function which does, etc.). Functions which only use e.g. `&amp;T` would not need it. My feeling is that this would still be quite a lot of functions which would require it, but my confidence in that estimate is very low. (Which is why it would be really nice to have some concrete statistics.)
Ah, but it's not even SML style module/functor system. SML has generative functors. I want applicative functors. Give a look in the paper I gave in one of my comments.
&gt;&gt;This is actually the opposite of what C with a static analyzer. so you say 'all sources in the project must pass the static analyser' unless they contain the #define UNSAFE macro done. 
The fourth tier in FTL stands for the fact that it is actually the fourth and last codegenpath that will be taken. You still need faster codegen that will be used for the majority of the vm code, otherwise JIT is way too slow. FTL was a major undertaking and a simple stupid fast translation from bytecode into assembly is actually quite easy to write
Uh, no. In a linear type system, you have the control over WHEN, exactly, the variable is consumed. E.g. let x = vec![1i]; let y = vec![2i]; Which one will be consumed first? `x` or `y`? Rust's type system fits perfectly into the affine definition.
That person could have opened a pre-RFC-process issue about the feature :P.
Dwarf Fortress's sin wasn't related to Unicode, it was merely a result of a naive mapping that conflated textual glyphs with game devices. And if it were using Unicode, I'd expect it to use the Private Use Areas for its custom glyphs, which were intended for precisely this purpose.
Again, a static analyzer EXCLUDES (you can't have X), while a type checker passes INCLUSIVELY (your code must be Y). It's the exact opposite pattern.
[Try it](http://play.rust-lang.org/) and see what happens. I get the feeling that the compiler's error message will tell you the answer.
&gt; so there is a safe subset, surely that is the same, just annotated differently. No, it's not. It's not possible to retrofit safe semantics on top of C++, even as a lint pass. For example, iterator invalidation.
source: http://www.haskell.org/ghc/docs/7.4.1/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html oh, and the source is fun too: http://www.haskell.org/ghc/docs/7.4.1/html/libraries/ghc-prim-0.2.0.0/src/GHC-Tuple.html
&gt; For example let's say I have a vector of object pointers and during runtime I get some value of i, and decide to send the ith object in the vector to another task. How will the type-system prevent me from using the ith object again? Moving an element out of a vector makes the vector unusable from that point onwards. Where the element is moved to doesn't matter. I think (but am not 100% sure) that if the object being moved implements Copy, the vector would remain usable because it then just copies it. What type of pointer are we talking about here? Box, Arc, and (I believe) raw pointers can be moved across task boundaries. Rc pointers can't. 
Ah, thanks for the heads up!
Offtopic: As a C++/Python coder getting into Rust I want to thank you for your work on the docs. Here's to super awesome guides!
RefCell exists to do that kind of runtime tracking: http://doc.rust-lang.org/std/cell/struct.RefCell.html
I think Option can be used if the value should be moved out of the vector. It has a method called [take](http://doc.rust-lang.org/std/option/type.Option.html#method.take) for that.
Thanks :)
Are you telling me you think its impossible to do this? what specific feature in C++ prevents you using a *safe subset*, and having a tool report where you *strayed* from it ? If static analyser can spot patterns, what is to stop you modifying it to tell you where safe patterns were found , then report it as an error where *no safe pattern was found??* Is there some divine intervention that means only the rust compiler can use this algorithm ? &gt;&gt; "or ownership for PROVING something safe." ownership/move semantics are part of C++11 &amp; its library. It has the same 'unique ownership' idea. The language doesn't do freezing, but an analyser could tell you where you violated it. &gt;&gt; " It doesn't provide things like lifetimes" Some lifetimes could be infered, So you're left needing a way of marking them where they can't be. So make a smart pointer ref&lt;T,N&gt; to do that. use the index 'N' as the lifetime 'name'. Then make the analyser apply the same rules the rust compiler does. And make the analyser report it as an error where you failed to do that. I'm only even looking at Rust in the first place because I'm convinced it IS close enough to what you can represent in C++. Bear in mind existing C++ programs have been through some sort of testing and debugging process - and you can walk into a shop and see shelves full of working C++ software.. - so they can't exactly be completely unsound :) Do you think ALL this software must be thrown away and re-written as the only way to eliminate residual bugs?? the rust compiler itself uses LLVM. it wouldn't work if it wasn't possible to write safe software, in C++. I'm not a fan of the way the C++ standard library iterators work, but you can implement &amp; use the functional stuff more easily now that it has lambdas.
(For people who (sensibly) don't spend all their time on IRC... eddyb is the VG guy.)
However, there are features being considered specifically because servo requires them.
Thanks!
Bear in mind, my FF and Chrome are written in C++ and they crash every day. They "work" until they memory leak or Flash (written in C++ as well) crashes.
Hmm, shouldn't there be a unreachable code warning already?
&gt;&gt;Just of the top of my head: this is a * pointer. well you'd disallow pointer-arithmetic on this. 'this' would behave like references usually.. you assume a 'this' comes from some safe context, and do the error check wherever method calls happen &gt;&gt; I think this would trigger just so often in existing C++ libraries that it would be unusable. you could make a rule that *new* code added to a source base must be safe.. and such a tool would help you increase the reliability of an existing project.. but you could assume some level of reliability based on testing and how recently that source code has changed
&gt; Given the popularity of the Ruby Rogues podcast in the Ruby community, I would expect this to make quite a few rubyists curious about Rust eek, drama llama comes to visit I guess.
Ah, yes, in that sense Servo is a testing playground for new Rust features.
A very easy way to get started without having to learn any of the (rather complex) graphics stuff is to just draw to the terminal -- print an X for the player, and a - for not-a-player. You can use https://github.com/o11c/termkey-rs to get arrow presses. Your game state should include the grid dimensions and the player coordinate. If the player tries to move outside of it, you could either not move the player ("clamping"), or fail, or print "you lose" and quit, etc. I suggest just giving it a try! Also, it's a lot faster to ask questions in the `#rust-gamedev` channel on IRC.
There are 3 ways to write a game loop in Piston, but my favorite is using 'GameIterator'. Here is an example that draws an image on the screen https://github.com/PistonDevelopers/piston-examples/blob/master/image_iter/src/main.rs You can handle key events in the loop by adding more cases to the match statement. Online docs http://www.piston.rs/docs/piston/piston/ This answers 2, 3, 4. To keep a square on the grid, you can write a function that takes a point and a rectangle and returns the closest point inside the rectangle. This will be useful later. Just use global functions in the beginning, return new values instead of mutating them. If you want a greater challenge: Motion gets more interesting if you do physical updates. To prevent objects from moving too fast, you can add a friction to the world, like the objects are moving in water or air. You move objects by setting acceleration in one direction that reaches equilibrium with the friction. See the update function here https://github.com/bvssvni/rust-snake/blob/master/src/object.rs This requires objects to have position, velocity and acceleration. Just put all your objects (including player object) in one Vec and do updates on all of them in a simple loop. It won't matter for performance for small games and having a flat structure makes it easier to add/remove features. 1. Define a winning condition 2. Define a death condition 3. Add more stuff to make the game interesting Create a separate module where you put the fine tuned settings. Alternatively this can be a JSON file. The next level could be another JSON file. You build all the levels around the same engine, by feeding it different data. This is just one way of making a game.
Btw, /r/rust_gamedev is just 4 days old, but I use it often. Questions and news about your progress are welcome.
I have two pretty simple grid-based games using Piston at https://github.com/Arcterus/rust-snake and https://github.com/Arcterus/game-of-life. You could use the grids from them as templates if you'd like. A word of warning: I haven't updated for the latest Rust yet (I last updated them sometime last week), so there may be a lot of warnings (and possibly a few errors). EDIT: actually, I last updated them about two weeks ago. EDIT 2: they are now updated.
The idea looks nice, however does not it imply a heap-allocation at each middleware boundary ? It might not be much of a deal, of course.
It is due to hygiene, the `this` in `let $unit(this)` is "trapped" locally to the macro definition, and doesn't match the `this` used in the `Meter(this / 100f64)` expression. You need to be passing an identifier from the expression's context down into the macro: #![feature(macro_rules)] trait Length { fn to_meters(&amp;self) -&gt; Meter; } macro_rules! length_unit( // an `ident` non-terminal just takes a single identifier, // handling it hygienically ($unit:ident; $this:ident -&gt; $to:expr) =&gt; ( #[deriving(Copy, Clone, PartialEq)] pub struct $unit (f64); impl Length for $unit { fn to_meters(&amp;self) -&gt; Meter { // an identifier is a valid pattern let $unit($this) = *self; // this would be an error, due to hygiene: // println!("{}", this); $to } } ) ) #[deriving(Show)] pub struct Meter(f64); length_unit!( Centimeters; this -&gt; Meter(this / 100f64)) length_unit!( Yards; // can use whatever identifier you like: that -&gt; Meter(that * 0.9144)) fn main() { println!("{}", Centimeters(250.0).to_meters()); println!("{}", Yards(100.0).to_meters()); } [playpen][pp] [pp]: http://play.rust-lang.org/?code=%23![feature%28macro_rules%29]%0A%0Atrait%20Length%20{%20fn%20to_meters%28%26self%29%20-%3E%20Meter%3B%20}%0A%0Amacro_rules!%20length_unit%28%0A%20%20%20%20%2F%2F%20an%20%60ident%60%20non-terminal%20just%20takes%20a%20single%20identifier%2C%0A%20%20%20%20%2F%2F%20handling%20it%20hygienically%0A%20%20%20%20%28%24unit%3Aident%3B%20%24this%3Aident%20-%3E%20%24to%3Aexpr%29%20%3D%3E%20%28%0A%20%20%20%20%20%20%20%20%23[deriving%28Copy%2C%20Clone%2C%20PartialEq%29]%0A%20%20%20%20%20%20%20%20pub%20struct%20%24unit%20%28f64%29%3B%0A%0A%20%20%20%20%20%20%20%20impl%20Length%20for%20%24unit%20{%0A%20%20%20%20%20%20%20%20%20%20%20%20fn%20to_meters%28%26self%29%20-%3E%20Meter%20{%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20an%20identifier%20is%20a%20valid%20pattern%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20%24unit%28%24this%29%20%3D%20*self%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20this%20would%20be%20an%20error%2C%20due%20to%20hygiene%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20println!%28%22{}%22%2C%20this%29%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%24to%0A%20%20%20%20%20%20%20%20%20%20%20%20}%0A%20%20%20%20%20%20%20%20}%0A%20%20%20%20%29%0A%29%0A%0A%23[deriving%28Show%29]%0Apub%20struct%20Meter%28f64%29%3B%0A%0Alength_unit!%28%0A%20%20%20%20Centimeters%3B%0A%20%20%20%20this%20-%3E%20Meter%28this%20%2F%20100f64%29%29%0A%20%20%20%20%0Alength_unit!%28%0A%20%20%20%20Yards%3B%0A%20%20%20%20%2F%2F%20can%20use%20whatever%20identifier%20you%20like%3A%0A%20%20%20%20that%20-%3E%20Meter%28that%20*%200.9144%29%29%0A%20%20%20%20%0Afn%20main%28%29%20{%0A%20%20%20%20println!%28%22{}%22%2C%20Centimeters%28250.0%29.to_meters%28%29%29%3B%0A%20%20%20%20println!%28%22{}%22%2C%20Yards%28100.0%29.to_meters%28%29%29%3B%0A}
Before signing off, I would recommend you *[The Duct Tape Programmer](http://www.joelonsoftware.com/items/2009/09/23.html)*. And also the *actual* [Unicode standard](http://www.unicode.org/versions/Unicode6.3.0/). It is not the easy road; instead, it is close to the hardest road ever imaginable.
Thanks, this will help a lot.
Yeah, tried to install rust-snake and it doesn't compile. Welp, that's what I get for trying to learn a language that's not stable yet. :-) But thanks anyway. General noob question: I downloaded rust-snake using git clone. But if I change something and want to save the new version to my own github account, what should I do? Or should I fork it first? Edit: OK, I made rust-snake work, with help from #rust-gamedev...
A more usual example would be "á" -- it may be a string of either one or two `char` depending on normalization form. If it's two codepoints it would be incorrect to separate them (or naively reverse them and break that character). The new .graphemes() iterator knows this stuff and will partition the string correctly.
The only weird thing I can imagine would be that the expression in the `if` clause mutates something as well as return `false` so that the second call in `else if` would return `true`. if --i &lt; 0 { } else if --i &lt; 0 { } else if --i &lt; 0 { } for an (incorrect) example. However it seems pretty horrendous... do you have better examples in mind ?
You should fork it unless you are going to make something completely non-rust-snake related with the code. In that case, you should create a new repo on GitHub, and then run the following in the directory where you downloaded rust-snake: git remote set-url origin URL_OF_NEW_REPO git push -u origin master 
Thanks.
pcwalton tweets that thanks to this, all lifetimes in function declarations in sprocketnes are now unnecessary: https://twitter.com/pcwalton/status/490926576393924608
You seem to be making two mistakes. But to understand them, you must understand the move semantics. When you "use" the value inside a non-`Copy` variable, that value is effectively *moved* to the other variable. The original variable can't be used any longer. Quick example: let x = vec![1i]; let y = x; println!("{}", x.get(0)); // Compiler error. The value in x was moved to y That's what ownership means in Rust. Every resource has a single owner, and if you don't want the ownership of the resource to be moved, you should be using references. This explains the error "use of moved value: `trie`". But what about "cannot move out of dereference of `&amp;mut`-pointer"? Simple: when you try to use the value in a dereference of a non-`Copy` trait, the move semantics will work out and try to move the value to other ownership. But... a reference does not have the ownership, so that's strictly forbidden. It makes sense, look: let x = vec![1i]; let y = &amp;x; let z = *y; // Compiler error. Cannot move out of the dereference of y (because the owner is x) So there's where you're making mistakes. Rust's borrow checker is a lot more strict than most other languages that you'll use, so you have to take care of all that.
Yes, I actually wrote the borrow checker changes that enable this. However, it needs to be forbidden in the case of structs with destructors, and the codegen for cleanups needs to understand how to perform cleanups on partially initialized structs.
Aha, that makes more sense now. (The trivial example for testing purposes in the repository didn't make this obvious.) I still think it would be nice to potentially have some kind of language support for this (for instance, unmoveable types), for, among other reasons, the one that storing data on the heap in a `Box` may not be sufficient to prevent its being moved in the future, but my ideas for this are still in an early stage.
There's a pull submitted to fix it, you can find the fork [here](https://github.com/ebfe/racer/tree/fix-build-master) I believe this was caused by RFC 33.
In the macros example, macro_rules! pfor ( ($x:ident = $s:expr to $e:expr step $st:expr $body:expr) =&gt; (match $e,$st { e, st =&gt; { let mut $x = $s; loop { $body; $x += st; if $x &gt; $e { break; } } }}); ($x:ident = $s:expr to $e:expr $body:expr) =&gt; (pfor!($x = $s to $e step 1 $body)); ); shouldn't the break line be: if $x &gt; e { break; } i.e. referring to the matched variable e rather than the macro argument $e?
This is unrelated to your question, but you do not need to put parentheses around the conditions in if expressions. Also, you shouldn't have a space between function names and parentheses. To answer your question: you should be able to use a combination of references and cloning (don't clone the trie, though) to get around the issues you are having here. Denommus's answer gives a nice explanation of why what you're doing does not work.
This is a resource that's not Rust specific, but check out http://gameprogrammingpatterns.com/
Speaking of which does anybody have this working with Atom on Windows or OS X? My racer build works fine from the command line, but not at all in Atom.
 if std::rand::random() { } else if std::rand::random() { }
Thanks but I seem to get the same errors. Maybe I gitted (got?) wrong, I ran git clone https://github.com/ebfe/racer.git 
You also have to checkout the right branch. git checkout -t origin/fix-build-master Edit: Fixed the name of the remote tracking branch.
Can `layout` be broken into smaller parts? (I guess this is just a rephrasing of `compositing_layout_shared`.)
Right, although I guess the idea in this case is to abandon tricks like using traits and just minimize the scope of the shared code.
&gt; impl&lt;'a, T&gt; TrieNode&lt;T&gt; That may work, but it's much clearer with `fn find_prefix_trie&lt;'a&gt;(&amp;'a self, bytes: &amp;[u8]) -&gt; (uint, &amp;'a TrieNode&lt;T&gt;)` (i.e. lifetime on the function, not the `impl`). &gt; Read; the code guys, it's pretty obvious the OP understands the basics of move semantics; It's not at all obvious. Not to disparage the OP (since this is a unique corner of Rust compared to other mainstream languages, and there aren't a wide variety of explanations of concepts like this (e.g. there is [my own](http://stackoverflow.com/a/24253573), but that just covers what a move/copy is, it doesn't talk about using references/lifetimes to avoid moves)), but a [change like this](https://github.com/iv597/rust-term/commit/26af49c511b79590451e583dfcd96135fe9de6f5#diff-5bb91a4cecb1606cdf6452fd4809068eR76) is something that someone who 'gets' move semantics would know to avoid. Taking an argument by-value should intuitively feel like a single-use/consuming operation, which is almost certainly wrong for a method like `find`.
I think the static method and the builder ideas have the same fundamental problem - what I'm stuck on is providing some kind of trampoline between the `compositing` and `layout` crates, where the former can say "here's some data; go do whatever you want with it". I guess I'm used to thinking about it in C terms, where if b.c includes a.h, b.c doesn't need to be recompiled if a.c is changed, and that kind of API separation seems much more challenging to accomplish in Rust.
Thanks for following my tutorial! I'm afraid to say that you have done everything correctly and the issue that you are running into is a problem with rust-graphics in that it expects GLSL 3.3 which apparently you macbook's graphics card does not support. It broke my workflow on my virtual machine, but if it also breaks macbooks, this is a much bigger issue than expected. The relevant issue is here: https://github.com/PistonDevelopers/opengl_graphics/issues/29 If you can run `glxinfo | grep "OpenGL"` and paste the output on the issue, that would be really helpful.
I've merged this with racer master now
Fair enough; but the parent comment here still a lot more helpful than the top comment. "Insert generic answer that doesn't address specific situation here" is the sort of thing that earns negative karma on SO. It's not really helpful in solving the OP's question. I think it's kind of lame to upvote answers like 'learn some more rust before you try that' over answers that actually answer the question being asked. 
Thanks for detailed explanation! I'll post in on the issue board.
If you have time, could you please try replacing path for the dependency on PistonDevelopers/opengl_graphics with `https://github.com/TyOverby/opengl_graphics.git`. I have a single commit that *could* fix the issue for you.
Thanks! I'll take a closer look tomorrow with a fresh pair of eyes.
GOOGLE
Awesome work!
&gt;GLFW on Windows &gt;TODO I guess I'll have to check back later
I don't agree that this is a problem. Let's say you actually mean to return a vector from a closure, the easiest way to do that with a macro is `vec!(1u, 2, 3)` without a semi-colon as the last line of your closure Maybe this could be rather solved by some kind of an IDE that lets you view macro expansions?
Well, [this](http://is.gd/vFjxKI) doesn't work, as expected: `vec!(1u, 2, 3) vec!(1u, 2, 3)`. [This](http://is.gd/NJ5Cwj) does: `println!("test") println!("test")`. In my opinion, if the expression isn't used as a return value, e.g. it's followed by other code lines, it must be followed by a semicolon. That's how the language works for non-macros, and this looks like an ugly inconsistency.
I think it's an ambiguity that should be resolved by a style choice instead of enforced in syntax. If you want semicolons after every `writeln!` invocation, then put it in your code style guide. Since the result of the the block in the expansion is `()`, the type system doesn't care whether there's a semicolon or not. It works out the same way in the return position of a function or block. It doesn't bother me personally; coming from a Java background, I have a compulsive habit to end every LOC with a semicolon anyways. I have to catch myself when writing functions that return a value for that exact reason. I see why you're frustrated about the ambiguity, but it would be counter-intuitive and unnecessarily complex to enforce as I believe macros are expanded *prior* to the syntax check. So it appears as a regular `match` block to the parser, and some sort of metadata would have to be inserted to remind the parser that the block of code is an expanded macro. I think if you always assume that macros expand to a block, or if they are assured to always do by the macro expander (which I think they usually do anyways), then the inconsistency resolves itself.
Thanks that worked, although for any other git newbs, cd to the racer directory first. Also a possible note when trying to install rustup.sh doesn't seem to grab source?
I think I was too tired to grasp the full meaning of the code when I wrote my answer, but I though that it would be better to give a clue than none at all. I didn't claim to have the right or the best answer. I just suggested a possible reason and/or issue and I hope it did something good. I would have provided an actual example otherwise.
The traditional Haskell way would be to: 1) create a LayoutTaskCreator trait in a shared crate (potentially create one, if needed) with a single method - create. 2) impl it in compositing. 3) make the relevant functions in compositing parametric over the LayoutTaskCreator.
I also find Rust a great language for coding for the Raspberry Pi. However, I prefer to cross-compile TO the raspberry pi. It's really easy to build the Rust compiler as a cross-compiler with the Raspberry Pi toolchain. I've documented the steps here: https://github.com/npryce/rusty-pi/blob/master/doc/compile-the-compiler.asciidoc
As someone who has never had to use something like this I would like to see some examples of common use cases to make it more clear what this is intended to do.
Hi, You could use the Option methods more, instead of match. pub fn get(&amp;mut self, key: &amp;K) -&gt; Option&lt;Rc&lt;RefCell&lt;R&gt;&gt;&gt; { let mut opt = match self.map.find_mut(key) { Some(loadable) =&gt; loadable.get(), None =&gt; None }; if opt.is_none() { opt = self.get_default(); } opt } Could be written like this (or something similar, I haven't checked if it compiles) pub fn get(&amp;mut self, key: &amp;K) -&gt; Option&lt;Rc&lt;RefCell&lt;R&gt;&gt;&gt; { self.map.find_mut(key) .map(|loadable| loadable.get()) .or_else(|| self.get_default()) } Here as well pub fn get_default(&amp;self) -&gt; Option&lt;Rc&lt;RefCell&lt;R&gt;&gt;&gt; { match self.default { Some(ref resource) =&gt; Some(resource.clone()), None =&gt; None } } Cloning an option will clone its contents as well. pub fn get_default(&amp;self) -&gt; Option&lt;Rc&lt;RefCell&lt;R&gt;&gt;&gt; { self.default.clone() } Whenever you have a `match foo { Some(a) =&gt; Some(b), None =&gt; None }` block you can just use `.map` because that's exactly what it does. 
For posterity, a PR implementing this has been proposed: https://github.com/mozilla/servo/pull/2885
Thanks for the help, I made the changes and it's more readable like that :)
Have you looked at the example with SFML ? https://gitlab.com/Bastacyclop/thorn_sfml/blob/master/examples/simple.rs
I actually read this yesterday and had to sleep on it to fully understand how to make the second part of this work with the code in question. I'm thinking I get it, though. Thanks for the verbose response! I might come back with questions if I get stuck again, if you don't mind, haha
Admittedly, the "self" change was to get the compiler to hush, and as a Python guy, looked about right. I made that change long before looking into the move mechanics (I went with the "it silenced the compiler error the first time so hey, it'll work!" mentality - whoops).
Which seems as horrendous (to me) :)
There's more information on that on the [references and lifetimes guide](http://doc.rust-lang.org/guide-lifetimes.html).
I posted your guide, waiting for moderation. 
I have the same problem on my (2009) iMac. When I use this repository, the sample starts, but I just get a black window followed by a segfault. The output of glxinfo: OpenGL vendor string: NVIDIA Corporation OpenGL renderer string: NVIDIA GeForce 9400 OpenGL Engine OpenGL version string: 2.1 NVIDIA-8.24.15 310.90.9.05f01 OpenGL shading language version string: 1.20 OpenGL extensions:
It sounds like the author is upset that Rust has Python-like strict namespacing for modules (like most non-C++ languages) and strongly typed generics (like most non-C++ languages) instead of ad-hoc polymorphism. Also, the author misunderstands type inference and jumps straight to criticism with "Type of a variable can change after initialization!?" I am also confused by the `using namespace std` criticism. Rust does not glob import everything inside `std` by default. Rather, only the *prelude* is glob imported. This is the kind of thing where I'm happy that Rust made the choices that it made. All of this sounds like "comfort zone" issues.
&gt; &gt; &gt; I agree that having Option/None/Some shadowable breaking for loops is horrible; I really think they need a lang item or something instead of referring to magic names, or at least refer to ::core::option::None explicitly. I'm fixing that right now, as we speak.
Honestly I'll go out on a limb and say removing the ++ operator is a good thing. A surprising number of coders still don't know that +=, -=, *=, ^=, &amp;= exist, and they really should. Removing ++ and -- and seeing += more often in examples may help spread the word. 
I disagree, some of these are actual issues: &gt; // rust-disappointment: this is really bad: mutability can't be &gt; // parameterized so code has to be duplicated. This is even worse than &gt; // in C++ because functions can't be overloaded, but has to be named &gt; // differently, which makes adding parameterized mutability afterwards painful. Is a problem, that has already been brought up a few times elsewhere. This causes code duplication or abuse of transmute resulting in undefined behavior that generally happens to work. &gt; // rust-disappointment: Type of a variable can change after initialization!? &gt; // let mut size= TileVec{x: 0, y: 0}; &gt; // size.x= 5u; &gt; // let map= Map::new(size); &gt; // -&gt; error: mismatched types: expected `Vec2&lt;i32&gt;` but found `Vec2&lt;uint&gt;` This is not good behavior. When TileVec is defined to be Vec2&lt;i32&gt; making a `TileVec{ x: 0, y: 0 }` should make a Vec2&lt;i32&gt; not just a Vec2&lt;T&gt;, the error should be about `size.x = 5u`. I also think this syntax is unreadable, but that is much more subjective: &gt; // rust-disappointment: tedious syntax for such a trivial thing &gt; impl&lt;T: Add&lt;T, T&gt;&gt; Add&lt;Vec2&lt;T&gt;, Vec2&lt;T&gt;&gt; for Vec2&lt;T&gt; {
Will this be recorded? DST are a topic many people will want to hear about.
&gt; Also, the author misunderstands type inference and jumps straight to criticism with "Type of a variable can change after initialization!?" I thought the same at first, but `TileVec` is `Vec&lt;i32&gt;`. But the `i32` there is just ignored. Looks like a bug to me.
You don't have to worry about this changing.
/u/pcwalton and /u/mcpherrinm both said what I'd say, so I'll just go meta: I'm excited to start getting a little bit of hate. It means that we're growing up, and growing out of our immediate circle. Not everyone will love Rust. That's super okay.
&gt; &gt; &gt; This is not good behavior. When TileVec is defined to be Vec2&lt;i32&gt; making a TileVec{ x: 0, y: 0 } should make a Vec2&lt;i32&gt; not just a Vec2&lt;T&gt; Hmm, I wonder if there is a bug whereby type constraints on struct literals are not checked. We should definitely fix that if true! Edit: Yup. Filed https://github.com/rust-lang/rust/issues/15875 &gt; I also think this syntax is unreadable, but that is much more subjective: Eh, I don't see any way to "fix" it other than switching to C++-like templates, which I definitely don't want to do.
&gt; TileVec{ x: 0, y: 0 } does not make a `TileVec&lt;i32&gt;`, it makes a `TileVec&lt; &lt;some-integral-type&gt; &gt;` which later gets deduced to `uint` because an `uint` is assigned to it. To get a`TileVec&lt;i32&gt;` you need to explicitly type one or both of the integers: `TileVec{ x: 0i32, y: 0 }`. At least, that's what I understood of type inference...
&gt; Eh, I don't see any way to "fix" it other than switching to C++-like templates, which I definitely don't want to do. Combining RFC [135](https://github.com/rust-lang/rfcs/pull/135) and the idea of removing brackets on single parameter types (I swear I saw an RFC for this). impl &lt;T&gt; Add&lt;Vec2 T, Vec2 T&gt; for Vec2 T where T: Add Is already a huge improvement.
`TileVec` is a `Vec2&lt;i32&gt;` because of a `type` expression further up in the program, it is *not* a polymorphic type.
In my experience, the predominant use for `++` in C-like languages is for incrementing the index variable in a `for` loop, which Rust doesn't need to worry about. As an additional benefit, the prefix vs. postfix behavior of `++` is endlessly confusing; who can tell me what `x - ++x` is supposed to do? At best you restrict the operator to postfix position, and then make it a statement so that it can't be embedded in expressions, but now you've introduced an entire operator just to avoid typing `+= 1`, saving you all of two characters.
I like the "comfort zone issue" term :) I’ll probably use it again, if you don’t mind.
I adore Rust criticism, but this is fairly feeble. At best, this merely indicates a few places where we need to improve our documentation.
If I may: http://www.reddit.com/r/programming/comments/1x66zv/the_rust_repository_closed_the_second_most_number/cf8mhd9
Ahhh yes. Wonderful.
&gt; it hurts having descriptive names due to increased length. I especially find longer, descriptive names more pleasant to read in snake case.
 rust-delight: range-based for loops are good. \o/ just wait until you get to all the other iterators that can be used with for.
Thanks :)
Especially since it's a concern that should/could be moot with a good IDE.
It led to a good bug report :) https://github.com/rust-lang/rust/issues/15875
&gt;&gt; tedious syntax for such a trivial thing impl&lt;T: Add&lt;T, T&gt;&gt; Add&lt;Vec2&lt;T&gt;, Vec2&lt;T&gt;&gt; for Vec2&lt;T&gt; { ... this partly is why I'm suggesting optional go-like duck-type traits, it would ease 'first impressions' but you could still be more specific if you want to. Also less micromanagement when you want to make super traits , or when you end up needing lots of single function traits. (e.g. indirection traits.) Something else that might be interesting here is reversing Type/Trait e.g. imagine if it was.. // self (Lhs) RHS Result for&lt;T&gt; Vec2&lt;T&gt; impl Add&lt;Vec2&lt;T&gt;,Vec2&lt;T&gt;&gt; { fn add(&amp;self, &amp;Vec2&lt;T&gt;)-&gt;Vec2&lt;T&gt; {..} // self rhs result } // also imagine.. for&lt;T&gt; Vec2&lt;T&gt; impl Add&lt;Self,Self&gt; { fn add(&amp;self, &amp;Self)-&gt;Self {..} // self rhs result } Less shuffling in your head when you read the trait and the function.(lots of shuffling going on with indirection traits) . Also, Maybe they could use defaults.. imagine `trait Add&lt;RHS=Self,Result=Self&gt; { fn add(&amp;self,rhs:&amp;RHS)-&gt;Result` to give a more concise declaration when you have add(Self,Self)-&gt;Self }
&gt;&gt; the prefix vs. postfix behavior of ++ is endlessly confusing; it's clear for those of us who grew up on 68000 asm :) but I agree it isn't essential for Rust. (Its just extremely useful in the minimalistic,low level C)
Are there any plans to implement a lint that lets you know when lifetimes can be elided?
&gt; Eh, I don't see any way to "fix" it other than switching to C++-like templates, which I definitely don't want to do. For this specific case, we could define `Add` with default type parameters as `trait Add&lt;RHS = Self, Result = Self&gt; { ... }`, so the user code in the simple case looks just like `impl&lt;T: Add&gt; Add for Vec2&lt;T&gt;`
&gt; the idea of removing brackets on single parameter types (I swear I saw an RFC for this) Not an RFC, but [discussed here](http://www.reddit.com/r/rust/comments/29egfn/a_suggestion_about_simpler_type_syntax_from/) 
`let`'s not go crazy adding statements to what is an (almost) pure expression language.
I would regard all of the following as invalid as criticisms (of the language), either representing a possible failure of our documentation, bugs, or just the "comfort zone issues" /u/pcwalton describes above. &gt; // rust-disappointment: "using namespace std" on by default &gt; // rust-disappointment: leading :: necessary in this case? &gt; // rust-disappointment: how much value does `::std::vec::` add in respect to `std::` ? &gt; // rust-disappointment: declaring None in enum will break range based for loops: &gt; // rust-disappointment: Type of a variable can change after initialization!? &gt; // rust-disappointment: using {} is mandatory &gt; // rust-disappointment: no ++ operator
I haven't read your code fully yet, but I noticed that your function doesn't declare a return type at all. Anyway, reading, first thoughts: 1. you have to derefernce because `trim()` returns a `&amp;str`, which is a borrowed pointer to a string. 2. You have to call `to_string()` because you've declared the result to be of type `Vec&lt;String&gt;`, and before then, it would be a `Vec&lt;&amp;str&gt;`. Not 100% sure of the last things. It's a similar situation to the first part, but I'm unsure why it demands a `String`. EDIT again: Becuase you're missing the return type, I _bet_ you've declared it as a `HashMap&lt;String, String&gt;`, which is why it would want that. Can't tell without it.
What a weird comment.
&gt; // rust-disappointment: Type of a variable can change after initialization!? This is an [actual bug](https://github.com/rust-lang/rust/issues/15875), the author misunderstood what the problem is, but was correct in thinking it wasn't working properly.
I agree that all of those are not really great criticisms other than "type of a variable can change after initialization", which seems like a bug open closer examination. Actually, even the import criticisms have some truth - we would benefit from making imports more ergonomic. This kind of post is helpful.
&gt; // rust-disappointment: tedious syntax for such a trivial thing impl&lt;T: Add&lt;T, T&gt;&gt; Add&lt;Vec2&lt;T&gt;, Vec2&lt;T&gt;&gt; for Vec2&lt;T&gt; { This sort of thing is aboslutely horrible looking. 
That's just a bug, not a criticism of the language. (It's unfortunate that having bugs like this is the case, but it's part of the deal of using Rust at the moment.)
&gt; I also think this syntax is unreadable, but that is much more subjective: &gt; // rust-disappointment: tedious syntax for such a trivial thing impl&lt;T: Add&lt;T, T&gt;&gt; Add&lt;Vec2&lt;T&gt;, Vec2&lt;T&gt;&gt; for Vec2&lt;T&gt; { Me too, I still don't remember why they switch from `[]` to `&lt;&gt;`, however at least the former was a little bit more easy to read. `impl[T: Add[T, T]] Add[Vec2[T], Vec2[T]] for Vec2[T] {` However, yep, I hope the team will find a way to make it more readable.
Ooooh… you certainly awakened the C99 standard geek in me. And having read up on it `x - ++x` is indeed as I expected undefined behaviour. clang will even nicely warn you about it. The rule here is: You can not read *and* update a value between sequence points. Much more interesting though: How does rust deal with the equivalent `x - (x += 1)`? I personally I was rather surprised to find that `x += 1` actually evaluates to `()`, so this is a type error. As an interesting consequence: let mut x; let mut y; x = y = 3i; ends up with `x = ()` and `y = 3i`, which I honestly find a bit… unsettling.
Two things come to mind, * You can pass down a reference to the scratch vector (used for merging halves), so it doesn't have to be allocated more than once per sort * It's pretty standard to use a simpler sorting algorithm once the halves are split down into small enough chunks (threshold could be 8, 16, 32 elements or so); for example insertion sort. That would be something like this in your match: ` len if len &lt;= 16 =&gt; { insertion_sort(lst); return } `
&gt;Much more interesting though: How does rust deal with the equivalent `x - (x += 1)`? I personally I was rather surprised to find that `x += 1` actually evaluates to `()`, so this is a type error. &gt;As an interesting consequence: let mut x; let mut y; x = y = 3i; &gt;ends up with `x = ()` and `y = 3i`, which I honestly find a bit… unsettling. In practice it doesn't matter though. If you never use `x`, what difference does it make? If you do use `x`, then you'll get a type error. It's a little weird, granted, but unlikely to cause any real issues. 
assignment doesn't return the value being assigned, it returns `()` this is surprising, but not unprecedented
That's a great idea, and can even be done backwards compatibly.
There_was_a_study_about_it_and_it_found_people_could_read_snake _case_much_more_quickly_because_of_their_practice_with_spaces. CamelCaseTakesMorePracticeToReadQuicklyBecausePeopleHaveLess PracticeReadingCamelCaseCodeThanReadingNormalProseWithSpaces.
I think your problems are actually largely unrelated to HOF. Concering your questions: 1. This is required, because `.filter()` passes a reference to the filtered value to the predicate closure, and does not copy the value. It hence becomes a `&amp;&amp;str`, which you can not compare to a `&amp;str` (the type of `""`). A more idiomatic way to can write this may be `.filter(|&amp;l| l != "" )`. 2. You need to call `.to_string()` because you are iterating over string slices (`&amp;str`), but have declared the resulting vector as containing `String`. An alternative woud be making a vector of slices (`Vec&lt;&amp;str&gt;`). 3. Technically you don't actually have to call `.to_string()`. The problem here is not that `a` and `b` aren't `String`s, but they can not be moved out of the `columns` vector. It would be sufficient to call `.clone()` on them. (Side note: `a` and `b` are actually `&amp;String`, since you bound them by reference in the match arm. So a first naive attempt might have been to write `(*a, *b)`, which will tell you that those values can not be moved). The `rest` in this expression is a slice into the `columns` vector containing the rest of the elements. Since you need something owned to put in the `HashMap`, you will likely want to convert this into a vector. That can be done using `Vec::from_slice(rest)`. I made a gist at &lt;https://gist.github.com/Florob/1fb8bd5613db0c80dd72&gt; showing two different ways to solve this problem. The first one tries to keep the sub-strings as slices as long as possible, the second one is closer to yours.
The first answer is technically wrong. `&amp;str` is a string slice and actually can not be dereferenced. `str` on its own is not a "valid" type. `&amp;String` is a borrowed pointer to a string, and rather useless in most cases. The reason is that `.fold()` gives you a `&amp;A`, which is `&amp;&amp;str` in this case.
it's not special casing, the space operator implies nesting A B C = A&lt;B C&gt; = A&lt;B&lt;C&gt;&gt; A B, C = A&lt;B, C&gt; //comma operator, prevents nesting
I disagree, it's fairly accurate in some places, even if just nitpicking (or just stating personal preferences) in others. I upvoted it because it has some value.
Oh, yes, you are correct. It's hard to double check without the compiler...
What's the problem with the lint?
I was exclusively talking about the "I'll probably use it again, if you don't mind" as if you need permission to "borrow" a phrase. Awkward.
Don't get me wrong. I'm not saying this is a bad thing. I'm saying this is rather surprising to C and C++ programmers. And unless well documented I think it's likely that this will create some confusion about "weird" type errors. I do in fact think this is a rather clever solution for a lot of things. One of them is your observation about move semantics, another is that it gets you around the undefined behaviour C has.
&gt; declaring None in enum will break range based for loops: That's pretty unexpected behaviour IMO. 
That bothered me too so I'm excited you're fixing it, but I'm really starting to get worried that you're not going to be able to get all these things ironed out in the next 5 months, before 1.0.
It's still just a bug. /u/pcwalton is [working on it](https://github.com/rust-lang/rust/pull/15809).
&gt; For example, in C++ I know that by doing #include &lt;iostream&gt; I'm slightly increasing the object size (and some initial runtime overhead) due to the static variables that are contained in that header. Not in Rust. Imports are for namespacing *only*. Importing has no side-effects beyond what is visible. &gt; The namespace issue is probably a matter of documentation, yes. But it feels more verbose than necessary, at least without a clear rationale for why it is how it is. More *verbose* than necessary? Seems to me that having a prelude is *less* verbose.
Cool. But I don't think you can fault `crafn` for not knowing which ones are bugs and which ones are intentional.
I'm somewhat surprised that most of the complaints were cosmetic. Nothing about the lack of higher-kinded types or guaranteed tail recursion. 
&gt; You can definitely spot the edges in CamelCase Mostly because caps are taller. Not all of them are though. `l` for example is as tall as a cap. I reckon we'd get faster at spotting the breaks, I just don't know if we'd ever get *as* good. Not sure how easy Russian is to read comparatively.
Modern Russian is easier to read. I edited my post to include a Latin example for you Latin readers to compare.
The `sizeof` keyword has been reserved since time immemorial for just this purpose.
Real hatred is absolutely inevitable. If we can't even begin to prepare ourselves to withstand for the onslaught of viscous bile that is The Internet, then we might as well pack up and go home right now. As for the criticism itself, as someone whose self-appointed job it is to sift through Rust criticism and decide which of it to take seriously, and has done this for going on three years now, the points raised in the link are shallow (with the exception of the bug that was unintentionally unearthed). Uninformed criticisms are a dime a dozen. I want intelligent, worthwhile criticism. I want [Daniel Micay criticsm](https://github.com/rust-lang/rust/issues/14527).
It's a philosophical thing: global type inference has a variety of downsides that Rust wishes to avoid (a small change can cause errors in a completely different place due to the inferred types changing, and avoiding it also allows one to compile a program just looking at the type signatures, no need to look at the definitions). Inferring the types of functions would require global inference, while closures are just normal values and are always inside some other function, i.e. inferring their types is purely local.
That makes sense to me. Haskell was always very confusing when I didn't explicitly type most of my functions.
Here too: http://discuss.rust-lang.org/t/alternatives-to-nested-angle-brackets/164
In addition to the pointed out bug, I would call the duplication of &amp;/&amp;mut-returning functions a valid criticism.
I smell a bad interview question!!!
&gt; at least the former was a little bit more easy to read. Entirely subjective. I personally think it's harder.
I'm not implying that they're invalid, only that they are neither penetrating nor insightful. Concerns about parameterizing over mutability have been raised since at least late 2011. The same was mentioned just last week by /u/Gankro on IRC (who often *is* an insightful critic, though he was beaten to the punch in this case).
But is this hate yet? It says "disappointment" which is not destructive and even mentions "delight" once.
Good luck!
Nah, it's just lazy. It smacks of someone who's taken no more than thirty seconds to learn the language. The complaints within that are worth listening to have already been raised dozens of times, and many have fixes brewing. I demand better of criticism. If we content ourselves with this sort of lazy dismissiveness, then that's all that we're going to get.
It's HashMap&lt;HashMap&lt;int, Vec int, MyHasher&gt;, Arc Mutex Int, MyHasher&gt; You only remove the '&lt;&gt;' on single parameter types.
I'd love to see the std crate redirection feature exposed in stock rustc. In particular, I'm interested in hosting rust in an existing C code base where pulling in the full runtime (libnative/libgreen) is a problem. I'd love to create a stripped-down version of the std facade so I can continue using the std namespace and prelude as much as possible, but use application-specific facilities for threads, I/O, etc.
Wow really? I thought the vertical height and shape of square braces made them objectively easier to parse and see groupings. 
I don't doubt you can get through the current list. I just think some more stuff is going to crop up as soon people start getting their hands on it. But that's kind of a catch-22. A lot of people are waiting for 1.0 before really getting into it, and by then it's mostly too late. I guess that's why you're trying to keep as much stuff as possible *out* of the language and in libraries so that it can be subbed out as necessary.
Stuff has been continually added to the list during that time. I am not worried at all.
It would be nice if I could take ordinary Rust code and host it within my application as long as it uses the subset of libstd that I expose in my custom facade, without having to muck with `#![no_std]`, manually importing the prelude, etc.
Thanks, this was really great!
I don't understand why `++` is missed at all. There are no pointers or iterators to increment anywhere and the C for loop idiom does not apply even for index iteration.
I've made adaptions of `&lt;&gt;` to make them acceptable, in Vim I'm using a conceal script to display them as the more open and tall characters `❮` and `❯`. Selecting a better font for your editor is always an option, but I couldn't find one that I liked. I looked at the font ["Mensch"](http://mir.aculo.us/2010/10/12/the-long-search-for-a-terminal-font-is-over/) (derived from Apple's Menlo and eventually Dejavu Sans Mono), and it has appropriate &lt;&gt; brackets, but some too cute details too I think
I was asked for a password to open the PDF.
This was a very nice presentation. I feel all happy and rusty now. :)
I go to school in Potsdam, NY, USA, which is only 2ish hours away from Ottawa. I've talked with some Canadian friends about the possibility of starting an Ottawa meetup.
Well, shadowing None in range loops seems broken. I also agree with the comment about the add operator having a lot of syntactic ceremony. So many angle brackets... Not a deal breaker, but it looks as bit like boost template code.
&gt; Agree : leading "::" is really disappointing, even if i know there is good reason for that. One almost always just imports the names into scope with `use`, avoiding leading `::std`s and the `::` in `math`. It's *very* unconventional to write `::std::...` for anything.
Here's the repo for my FizzBuzz someone on this forum helped me code: https://bitbucket.org/iopq/fizzbuzz-in-rust I can easily extend it to take an array of tuples and user-specified `String`s and it will work with empty string It doesn't need an `if` in it. I can write it with recursion: fn fizzbuzz_op(i: int, res: Option&lt;String&gt;, List&lt;(String, int)&gt;) ... By the way, does anyone know how to make a List in Rust?
Cool talk! &gt; let combined: String = pairs.iter() .map(|pair| rule(pair, i)) .fold(String::new(), |result, s| result + s); &amp;nbsp; &gt; (Some(s1), Some(s2)) =&gt; Some(s1 + s2), are far more efficient written as `result.append(s)` (and `s1.append(s2)`), since that consumes `result` and adds directly to that allocation (giving amortised-linear time construction, since `String` overallocates exponentially internally, like `Vec`), but `+` has to allocate a whole new `String` and discard both `result` and `s` (even if `s` is empty), which gives quadratic time construction.
What do you want achieve with this "`List`" type? (How does it differ to just `Vec&lt;...&gt;`?)
True. It is not a huge concern for me too, but in most language you don't need prefix.
You don't *need* a prefix in Rust, since you can import the names into the current module with `use`. Most languages require doing some form of import, while Rust allows for both imports and also global (within your compilation unit) paths.