Sure, I can give some arguments if you want. Naturally, the people developing OSs in Rust generally think it's the best choice for the job, and that it makes osdev easier. But of course, everyone thinks their favourite language is the most productive. I guess some hard numbers from controlled studies on productivity of developing an OS in various languages would be nice and have scientific rigour, but I have a feeling that is not available (coming up with a "placebo Rust" is left as an exercise to the reader). As I mentioned in my earlier post, most programming languages (Python, Java, JavaScript, Go, Haskell...) are not really possible/practical to use for low level systems programming, so the competition is automatically restricted to a handful: C, C++, and Rust come to mind of course; I suppose you can add some others like Ada, and of course assembly. The general advantages of Rust largely apply; you can find plenty of discussion of that here and elsewhere. You get all sorts of nice things like match expressions that C/C++ don't provide. You can distinguish the "safe" code from "unsafe". Naturally, you get the automatic memory management Rust is known for. But you still have plenty of low level functionality like inline assembly (an unstable feature). Not that there aren't disadvantages as well; unsafe code is can be a bit more awkward to write in Rust than in C. But then, that's because it's more explicit and hopefully less error prone. And even a kernel, which requires a fair amount of unsafe code, can do a reasonable amount without it. And even if you don't get as much safety as Rust usually offers, you still have the other aspects of its modern feature set. I suppose the ultimate evidence is just to wait and see how much Rust is adopted for these things.
The dream. Monads + do syntax. It is the main thing I wish Rust had support for.
Ah, thanks!
Any patch you send to an open source project may be reverted, if it's determined that that's the right thing to do. This isn't specific to soundness bugs, and it's just part of open source. I can appreciate that that may not feel great, and I'm sorry for that. But it's part and parcel of how the whole thing works. But, in my understanding (but it's been a while since I looked at the details of this bug), the patch is coming back. It's just coming back more slowly, and incrementally. They said that they didn't *need* it, but it would be good, but it's more than that: this change was risky. We were worried about breakage. We didn't find any breakage, so we shipped it, and then found out about the breakage. Is there more breakage out there that wasn't communicated upstream? This behavior has been this way for a long time. We generally chose the conservative option, for the benefit of the most people. That's what I mean. Being conservative is what's likely to cause the least harm.
Actix could consider using hyper internally, focusing on just the higher level framework pieces, and getting performance and bug fixes "for free". Or maybe there is value in having another implementation. In my extremely limited spare time, I occasionally work on my own unannounced web framework. Something taking some inspiration from Akka and Finch. With trait specialization, I think it can really be something. Maybe one day, I'll get enough polish to share it...
I think everyone is waiting for this. It probably won't make sense until async/await is available on nightly though. There is also `tower-http` which would make a good alternate basis for a tokio http framework.
Neither.
Glib itself implements reference counted pointers with interior mutability, so yes, internally it is something like `Rc&lt;RefCell&lt;T&gt;&gt;`. The `&amp;self` object in this case is just a wrapper around the Glib reference counted pointer object, so this is actually done through an FFI call to Gtk.
I'd say implied, when you don't need the type it resolves to and you are specifying a single trait as parameters. Within the generic parameter definition when it's simple and the type is needed. Where for anything else.
reqwest has a great API but it pulls in so many dependencies. It adds 2 minutes of compile time to my project when doing a fresh build.
mio_httpc is probably more lightweight. The sync interface is basically calling a single builder call.
&gt; Actix could consider using hyper internally, focusing on just the higher level framework pieces, and getting performance and bug fixes "for free". Or maybe there is value in having another implementation. Not to detract from your work, but `actix-web` was quite competitive with `hyper` in the TechEmpower benchmarks :-). So I don't see that happening too soon.
Oh I know. 0.12 allowed hyper to make several optimizations, going faster again. And, hyper constantly improves the amount of edge cases in HTTP it can handle, that I'm sure others would prefer to have fixed as well ;)
I considered if several of the features should be cargo features, allowing you to only download what you need. Original feedback was most people probably want most of the features anyways, so that's why it hasn't bothered yet. Still, that compile time doesn't sound so bad, since likely aren't doing fresh builds every few minutes.
Yeah generally it isn't so bad. But I worked with reqwest during a time where rls was bugged and kept busting the compiler's cache, so every compilation was a full build. It was very painful.
I tried to make my webserver in gotham and it just doesn't seem ready. Sure I know it's 0.2, but the hype around it made me think it was a real choice of framework for today. I ended-up having to write everything myself and the only solution was to refactor everything in actix-web, which is way more ready (and actually used in production), I'm very happy with the result. But I really liked gotham's ideas, it's just seem pre-alpha and not ready to be even discussed for some months, or even years, taking into account the speed of development.
do you think actix does not improve edge cases? actix could get fixes "for free" or based on your limited available time it could get fixes for very high price. and then all this performance considerations. i'd prefer to see results instead of mythical improvements. i considered to use hyper when i started the project but had to abandon that idea ;) 
That's the one.
If we ever get HKTs, I imagine the rest would fall into place quite rapidly.
It doesn't seem to be an HTTP framework, though. It's just some helpers.
I'm self-taught like you, and also trying to learn systems programming, and I've found Stanford's [CS140e](http://web.stanford.edu/class/cs140e/) very interesting. I think it's more approachable than Redox, if you haven't dealt with memory management before. And it's on a raspberry pi, so you get to deal right with the bare metal.
I mean, if you are a huge corporation you have ways of dealing with bugs in software, they even have specific people to contribute to specific open source software. It's part of the business, if they really need it they just put someone to work in rust and fix those bugs. You can bet your ass that if a big corporation employee comments on the issue saying they need that fixed and are willing to fix, the rust community will accept and help them the most they can.
&gt;What language would you build an OS with? asm and pascal for the kernel, Lisp for the higher level stuff
I'm totally ignorant when it comes to Rust web frameworks, could you explain the differences between hyper and the implementation actix uses, and why it make sense to have two different implementations of the same http stack ? At first glance, it looks like it's a low-level thing, with lots of technical edge-cases, exactly what I would expect to have a single foundational library for. But since you decided otherwise, I'm wondering what I'm missing.
I couldn’t use hyper for websockets, and in general I had impression that it was in stagnation. Other is personal taste for api design.
Mostly the cursor is left at the end of the filw after the first read so when you try to read it again you just get EOF. There might be a way to seek back to the top of the file then read it again. 
The cursor is at the end of the file after the first `read_to_string`, therefore any further `read_to_string` will start at the end of the file, thus return empty string. You may want to take a look at [`Seek::seek`](https://doc.rust-lang.org/std/io/trait.Seek.html#tymethod.seek) if you want to keep using the same `File`
rustc has a lot of crust within it as the language has changed a fair amount since the compiler was ported from ocaml to rust. I definitely wouldn’t call the more dated portions of the code idiomatic.
I usually use `&lt;T: Trait&gt;` and only `where` for when it's necessary (e.g. `&lt;'a&gt;(..) where 'b: 'a`), and I'd never use `impl Trait` for argument types.
Thank you! Now everything makes sense.
Thank you! Now everything makes sense and works as expected.
rustc is written over a number of years, and Rust \(the language\) has changed in that time. While it's continually being rewritten and refactored, as a whole it's going to be a combination of the old and the new. If you're looking for projects that have good Rust style to learn from, might I suggest something by burntsushi, like: [https://github.com/BurntSushi/ripgrep](https://github.com/BurntSushi/ripgrep)? 
`hyper` itself is not stagnating. And handling the edge-cases of HTTP, client or server side, is not a small feat. OTOH, it could be argued that everything relying on futures is in soft-stagnation right now. But that's an ecosystem problem, not a hyper-specific one.
You could do something like a free monad, where the "interpreter" of the monad waits a few ms before moving on to the next call in the `bind`/`and_then()` chain. If you want to avoid deep nesting, define a module like this for your type and then you can use mdo's do notation: https://github.com/TeXitoi/rust-mdo/blob/master/src/lib.rs#L92-L109
I didn't mean to imply actix doesn't get fixes. I'm writing up a 0.12 release right now, and in my biased assessment of the top frameworks in TechEmpower, the majority ignore many edge cases and leave them up to the user to just not trigger XD
Someone correct me if I'm wrong, but Rocket already uses Hyper. There's an ages old issue (in relative terms, mind you) regarding switching away from it - one comment even proposes just using Rocket as a layer over actix-web, which... I'd be all about. https://github.com/SergioBenitez/Rocket/issues/17 IMO Rocket's biggest appeal is the end user API, could really care less about how it's working underneath that.
It does, but the async issue seems to be stagnating, and Sergio didn't seem convinced he wants to keep using `hyper`. So with that remark I meant a framework that wants to follow `hyper` as it gets updated.
While this doesn't exactly answer OP's question, there are many compilers implemented in rust that might still be useful. Some of the more well known ones include dion and rhai. You might also want to look at cretonne. It's still in its early stages, but it is supposed to be alternative to LLVM written in rust, intended for use by SpiderMonkey and rustc. If you want a more hands on approach to emitting assembly, dynasm-rs fills that niche nicely. If you want to use a nice parsing library, nim combine and lalrpop are all great choices.
From what I can discern from the code, Rocket uses hyper only for parsing the request structures and creating responses. The actual reactors and blah blah is not using hyper.
Wow, that's a really nice macro. I generally try to avoid macros though as the IntelliJ Rust plugin chokes on them, and RLS hasn't felt stable enough to use yet.
I’d be careful with such assumptions. Not only rust has good http implementation and smart people who works on libraries.
Yes, that's the right crate for this, I use that crate a lot (e.g. to talk to my Launchpads, BCR2000 etc.).
Someone else mentioned that to me too! This is what I'm most likely to go with since I recently ordered an RPi :) and it's just plain fun playing with hardware!
 &gt; Any patch you send to an open source project may be reverted, if it's determined that that's the right thing to do. This isn't specific to soundness bugs, and it's just part of open source. I know. I almost reverted a patch to my `dbus` crate not long ago. But I didn't do that right away. I first contacted the person writing the original patch, and gave him more than one chance to explain himself and to help out with the problems the patch caused, to suggest solutions etc. After some discussion, it ended up with a compromise instead of a full revert. I'm not saying I did everything perfectly right when dealing with that issue, but in the end I hope both parties felt being taken care of, or at least not neglected. &gt; We didn't find any breakage, so we shipped it, and then found out about the breakage. Is there more breakage out there that wasn't communicated upstream? To me, stability/breakage arguments don't apply to UB. But I understand your pragmatic point as well. 
I did encounter both the RFC and typenum, but wanted to be certain that there wasn’t another way before I went down that rabbit hole. Thanks!
Definitely! I'm not the most versed in the other implementations, and so handling of edge cases could be in obscure locations in them. But I had done a rather thorough job looking through several.
I think you should examine to Redox OS.
First thing I thought when I saw the title was that this would be some really bizarre joke or injury related to shooting hard drugs. Until after I clicked I noticed it's r/rust. It's very pretty though! Lovable work.
Seconding this recommendation! Specifically, take a look at the [test_forward example](https://github.com/Boddlnagg/midir/blob/master/examples/test_forward.rs). Once you pull the `midir` repo, you should be able to plug in your keyboard, run `cargo run --example test_forward`, select the keyboard as the input, and watch as MIDI events get printed to the terminal. For parsing those raw MIDI messages back into a usable data structure, check out the [wmidi](https://crates.io/crates/wmidi) crate. Check out my project [bam](https://github.com/jswrenn/bam/blob/master/src/main.rs) for a succinct example of how to glue these two crates together.
It seems I can‘t change the title :(
 `main` can now return a `Result`. However it prints using `debug`, which makes using the new `Failure` crate a little annoying (as I'm not getting the pretty messages). Is there a trivial way to have `main` output using the Display trait? Currently my solution is this below. It means I have to do the remapping in a custom error type. To get it to work seamlessly I also need to have this double jump of going via a second `main` function. fn main() -&gt; Result&lt;(), MainError&gt; { main_inner()?; Ok(()) } fn main_inner() -&gt; Result&lt;(), Error&gt; { let foo = do_work()?; let bar = do_more_work( &amp;foo )?; Ok(()) } /// This remaps Debug to Display. #[derive(Fail)] struct MainError { error : Error } impl From&lt;Error&gt; for MainError { fn from( error : Error ) -&gt; Self { Self { error } } } impl fmt::Debug for MainError { fn fmt( &amp;self, f: &amp;mut fmt::Formatter ) -&gt; fmt::Result { std::fmt::Display::fmt(&amp;self.error, f) } } impl fmt::Display for MainError { fn fmt( &amp;self, f: &amp;mut fmt::Formatter ) -&gt; fmt::Result { std::fmt::Display::fmt(&amp;self.error, f) } } I am looking for a simpler alternative. Namely a clean way to remove `main_inner` without having to add a `From` implementation for each of my internal error types.
Oh I at least don't mind, I gain power from dark bizarre jokes.
Consider that for version n+1 of the language, which adds Beautiful Features A and B to the language, the compiler that accepts this version must have its source written in version n (because that's what's available to compile it). By induction, you can then expect the compiler to have any given part written using features much older than the current language version.
Having a newtype for a bounded integer is actually somewhat idiomatic. We already have precedent in the stdlib, in the [`num::NonZero*`](https://doc.rust-lang.org/nightly/std/num/index.html) containers which are used for enum layout optimization. Alternately you could use a builder struct that checks the integer field when the user goes to set it. It could return `Result&lt;Self, SomeError&gt;` so the user has to check if the validation passed before constructing the final type. Otherwise I think `new()` is preferred for non-fallible constructors only, so maybe something like `try_new()` would be a better fit.
[A comment I wrote two weeks ago](https://www.reddit.com/r/programming/comments/8jnb2a/rust_turns_three/dz1ix2g). Are people putting off work waiting in anticipation for at least a rough idea about where things are going with async/futures? Is describing that as soft-stagnation in the ecosystem wrong?
There isn't any desire, and there's a reasonable logic for the evolution of things. If you don't care about the type at all, and only care about it being valid for all the traits, then I think it'd be nice to use impl trait: fn prefix_with(x: impl Borrow&lt;SomeType&gt;, y: impl ToString) -&gt; String { y.to_string() + x.borrow().get_id().into_string() } The nice thing is that to know everything about x you only need to look at one, and only one place, where x is declared. On the other hand an unsugared version: fn prefix_with&lt;B, P&gt;(x: B, y: P) where B: Borrow&lt;SomeType&gt;, P: IntoString { y.to_string() + x.borrow().get_id().into_string() } To know what x is you need to look at three places. First you see it's type "B", then you move back to where type B is declared, and then you move forward to where type B is constrained. Sure better naming can improve things fn prefix_with&lt;BorrowedSomeType, PrefixString&gt;(something: BorrowedSomeType, prefix: PrefixString) where BorrowedSomeType: Borrow&lt;SomeType&gt;, PrefixString: IntoString But I still feel it's not as clear as the one that tries to avoid declaring unnecessary middle types and keeps the definition in one place: fn prefix_with(something: impl Borrow&lt;SomeType&gt;, prefix: impl ToString) -&gt; String The fact that there's three ways of declaring how to do things isn't too much. It's merely a matter of syntax (that is, there being three syntaxes, with pros and cons, for expressing the same thing is a perfectly fine thing). The problem would be if there was huge semantic deviation from all of them, but I don't feel that's the case. You can't access the type when you use impl because it isn't name (and you need a name, which generic parameters give you). With generic parameters you get an existential type, but you also have access to the actual type because you do bind it to a name (but don't know which type it truly is, and can only use it as an existential) but semantics remain the same. Generic and impl types should have the definition in-place when it's a trivial (it's just a straight implementation of traits representing inherent properities with no special constraints) but where should be used when constraints are more complex (requirements on associated types, requirements that are more constraints than inherent properties), where requires access to the type, so it can only be used with generic calls.
Ouch that would have meant a few days worth of torture but ....
That will never happen as compilers need sometimes to use ugly hacks, more than anything. Also it is much more complex task to keep compiler using most recent readability improvements and rewriting old parts can be highly troublesome. 
This generally disqualifies something from being a quine, since the problem then becomes very trivial. See the "Cheating quines" section of [https://en.wikipedia.org/wiki/Quine\_\(computing\)](https://en.wikipedia.org/wiki/Quine_(computing)).
If you actually prefer coding event loops to "async", mio_httpc is built right on top of mio, with nothing in between. It's new, and has some rough edges, but no futures required. 
I've made a \[PR\]\([https://github.com/cmr/this\-week\-in\-rust/pull/650](https://github.com/cmr/this-week-in-rust/pull/650)\) to add the Utah Rust meetup \-\- it's now a go, and I didn't even think to until /u/FenrirW0lf mentioned it on Discord!
Damn. That is some useful material for making an OS in Rust. Much appreciated for pointing that out!
In English I think better choices for the neutral connotation would be "opaque" or "obscure"
Neither is more idiomatic than the other, they both have legitimate uses. And to that effect, it completely depends on what they type of `Self` is and how you want people to use it. 
I suppose these are in a test suite somewhere? It could be great to have a standard suite of functional tests that everyone can use to get their implementation to the same level (if need be), instead of being overly dismissive of other people hard work.
There is a minimal portion of futures being added to std: https://github.com/rust-lang/rfcs/pull/2418
I can't count the number of times I've done this wrong, and I read from files a LOT at work
I feel like remembering something like: #[timeout=60] to enable tests to enforce a timeout. But I'm not even sure it exists. Does anyone knows anything like that?
Yes, but you need a `Box` (or some other pointer-like) so the elements have a constant size: https://play.rust-lang.org/?gist=6bc3bb20cfa2202b997e1357a96e26c4
I'm [pretty sure](https://doc.rust-lang.org/nightly/reference/attributes.html#function-only-attributes) the only attributes for tests are `#[should_panic]` and `#[ignore]`
You must be right, thanks!
I dunno about other people, but if I stumbled across this function while reading some code, I would be somewhat puzzled by the function taking `mut self` rather than borrowing. This is because the most common reason for a function to take `self` directly is when the intent is to *move* `self`, but since your `Board` type is `Copy`, taking `self` causes an *implicit* copy to occur instead. So on every update of the game state you're creating a whole new 2D array and some other stuff instead of just passing around a reference to perfectly reusable state. I guess you're trying to go for a functional thing where you return an entire new state of the `Board` instead of modifying the old `Board`, but that seems kind of excessive since struct member privacy should be sufficient to allow you to mutate `&amp;self` while preventing users from putting things into funny states as long as you present a well-formed API. ...Except that the members of `Board` are marked as `pub` for some reason, so right now anyone else could mess with your interior state *anyway*
An in-depth overview of quine techniques is here: http://www.madore.org/~david/computers/quine.html I was able to write a quine in brainfuck after reading this.
This will also make streaming iterators possible right? That's exciting! I predict they will open up some interesting new aspects of Rust API design.
Damn, that's awesome. I want one now :)
You can use `as_bytes_mut` to get a `&amp;mut [u8]` from the String.
So, `&amp;mut [T]` is a slice, not an array. Arrays are their own thing, related to slices but harder to work with than slices. You can get a String as mutable byte slice reference, but you probably shouldn't unless you're very confident, because if the byte slice ever contains bytes that aren't valid utf8 then you can get Undefined Behavior.
You don't need fixed length arrays here, you work purely with slices. One solution is to convert string to `Vec&lt;char&gt;` which dereferences to `&amp;[T]`: let my_chars = my_str.chars().collect::&lt;Vec&lt;_&gt;&gt;();
&gt; there is always a value in attitude signalling, which this move brilliantly did: it showed "chucklefish we care about you". If a programming language implementation is willing to put bugs, even a soundness bug that could potentially cause security vulnerabilities, back into a compiler, out of love for one specific company...does that not scare everyone else off? 
Well, the Mutex taking two seconds is weird - a mutex only takes a few microseconds to lock / unlock, you're doing something wrong somewhere else. However: As an alternative idea, I wouldn't do this in the Rust program at all, I'd put in a cron job / shell script and run it every 55 minutes (to give some leeway), then write the token to a **file**. Then just read the file from the Rust side on every request, since it's just a small key, it will take a few milliseconds at most. This also has the advantage of keeping the key across server restarts and - if shit goes wrong, you can still update the key manually. I wouldn't waste a constantly-running thread on this.
This worked... Thanks. Weird, I had tried: let mut my_chars: Vec&lt;char&gt; = [].to_vec(); my_chars.extend(reply.chars()); which is the equivalent (I really have problem wrapping my head around the collect notation), but I was running into some problem, not sure what I had missed. let 
No, I want to preserve the unicode chars. The [solution](https://www.reddit.com/r/rust/comments/8nnxjc/reference_to_an_array/dzwy39x/) from /u/newpaviov worked.
&gt; So, &amp;mut [T] is a mutable slice reference I kept going back and forth on this one. Thanks btw to everybody on #rust-beginners who I pestered over my lunch hours + early evening with this. &gt; if the byte slice ever contains bytes that aren't valid utf8 Do you mean chars that are longer than one byte in utf8? That's why I wanted chars, not bytes. 
Ascii characters are 1 byte each (7-bits to be precise), and non-ascii characters are 1-4 bytes each. You can't get string straight into a char slice, you have to parse the bytes.
Damn, I love reading these blog posts. They're just so informative and fun!
So you store a single token in the Mutex? Do you only ever need one because you'll only have the one client? I imagine a scenario where one client performs a request and a bearer token is stored there, then a second comes around and tries to use the bearer token - which is invalid so it is forced to renegotiate a fresh bearer token which gets stored in the Mutex. Then client number one comes around and tries to use client number two's new bearer token which fails and the process continues.
But [Rust's char](https://doc.rust-lang.org/std/primitive.char.html) are "Unicode scalar". &gt; You can't get string straight into a char slice, you have to parse the bytes. let my_str = "Hello, 🌎"; let mut my_chars: Vec&lt;char&gt; = [].to_vec(); my_chars.extend(my_str.chars()); println!("{:?}\n", my_chars); https://play.rust-lang.org/?gist=15d5ac39aebc2014db9104c9a64ea5ce&amp;version=stable&amp;mode=debug
Right... But the chars iteration is parsing the bytes as it goes to produce each character. The main reason to not always work in char is that rust char is always 4 bytes and ascii text (a majority of all text) is only 1 byte per char in utf8.
It looks awesome!! And I just realized ferris look like an empanada 
Thank you! That was definitely the issue. I would have replied earlier, but I wasn't able to work on this yesterday.
AWWWW YISSSSSS
Took me a while to realize you were talking about knitting even after I saw the picture. GG
So this is probably a really dumb question but I don't fully understand how you get languages to work together. I understand with compiled languages that there is linking that can happen at the compiler level to call something like c code in rust and with languages that compile to the same run time like .net languages or java languages. When you use something like rust with python are people compiling python to c and linking them, or just calling python scripts while passing in strings of rust values, or using some networking protocol like http?
where is that?
You are right, I've done a bit more testing and it seems that it's not the locks that are causing the issues, probably something somewhere with my hyper client configuration. 
Thanks! I'll have a look at AtomicPtr, this sounds like a great approach.
Hi. I only need one token. Basically my API acts as a single client which is used to respond to user messages thus it only needs one bearer token no matter whom it responds to.
Like the idea, however, now every request that comes to my API has to do a token read from file, wouldnt this be costly?
It's true that you can seek back to the beginning of the file (unless it's some kind of special file that doesn't support seeking). It's also normally a bit of a question why you'd want to. The more traditional pattern would be to read the file once, processing it however you need to as you go, and storing the results in memory (or in files of processed data if it's too big for memory). There are definitely use cases for "read twice", but they're pretty rare. If you're counting on the two reads returning the same stream, you of course need to be sure that the file won't change under you while you're reading it again. If it does, this can lead to some pretty mysterious bugs. Obviously I don't know your use case — seeking to start may be by far the best plan here. I'd humbly suggest thinking carefully about it, though. There's a lot of gotchas with seeking a file, and reading it a second time will be far from free performance-wise.
It's not great having unconditional stack overflows in debug mode though if \`MyLargeStruct\` is extremely large. Optimizations 100&amp;#37; of the time that are 100&amp;#37; effective would solve most if not all of the use cases for placement new. Unfortunately that's not going to happen, since people do use debug mode and optimization isn't perfect.
Do you have the patterns / description on how to make it?
My wife made it with a crochet hook. It was actually a birthday present. She said she might do it again and that time write down the steps / patterns. It really was the best present ever 😻
Cool! Remind me when she has done it =)
A great piece of art. I shall – permission assumed – print this and hang it next to my desk.
Yep, that's also a trait that requires a GAT! And also (* scary flashlight face *) *monads!*
Thank you for explaining! If you are interested I'll explain my use case: I'm writing a tool to easily controll the backlight brightness on my notebook. And since the brightness is stored in a file by the OS I guess that seeking back is the right way.
Maybe a DisplayToDebug shim newtype?
The turbofish-syntax is only required for type inference. If you just annotate the type of your variable directly, you don't need it: let my_chars: Vec&lt;char&gt; = my_str.chars().collect();
Just wanted to say I'm loving the recent influx of esoteric pieces in being written and posted here! I really didn't think of Rust as a language one would write this kind of thing in. It seems there are no barriers for Rustaceans after all!
Wow! My brain thanks you!
It is possible to workaround and have associated type with lifetime parameter. It requires some boilerplate code to add another `trait AssocFutures&lt;'a&gt; { type FooFuture: Future&lt;Item=i32&gt;; }
It is possible to workaround and have associated type with lifetime parameter. It requires some boilerplate code to add another trait. ``` trait AssocFutures&lt;'a&gt; { type FooFuture: Future&lt;Item=i32&gt;; } trait Foo: for&lt;'a&gt; AssocFutures&lt;'a&gt; { fn foo&lt;'a&gt;(&amp;'a self) -&gt; &lt;Self as AssocFutures&lt;'a&gt;&gt;::FooFuture; ```
IMO no overview of WASM in Rust today is complete without mentioning [stdweb](https://github.com/koute/stdweb). While using `wasm-bindgen` and friends is good, and they are new and nice, `stdweb` has been usable since before `wasm32-unknown-unknown` even existed. It has bindings for many existing web APIs without introducing additional runtime bloat, and often "just works" for interacting with browser APIs and exporting functions via `js!`. Not to mention it all works on stable Rust, with the guarantees that comes with.
While we probably agree that the Rustc codebase is a mixed bag, there is still beauty to be found. The AST and HIR visitors, the Control Flow Graph code and some parts of typeck are really beautiful.
Quick, somebody register www.arewehaskellyet.com!
But if you need to access another associated type that **doesn't** depend on `'a` you have to pull it out into another trait, even if you declare if `: 'static`. E.g. if you have `trait AssocFutures&lt;'a&gt; { type FooFuture: Future&lt;Item=i32&gt;; type Foo: 'static; }` if you use `AssocFutures::&lt;'static&gt;::Foo` the compiler can't unify it with `AssocFutures::&lt;'a&gt;` when `'a` is universally quantified, [even though it should be able to](https://github.com/rust-lang/rust/issues/50166). So you have to pull out `Foo` into another trait that is scoped before the scope that introduces the universally quantified `'a` in `trait AssocFutures&lt;'a&gt;`, like `trait AssocFutures&lt;'a&gt;: FactoredOut { type FooFuture: Future&lt;Item=i32&gt;; } trait FactoredOut { type Foo; }`.
I can't follow, sorry. If some associated types aren't depend on `'a` you just declare them directly in `Foo` trait.
[removed]
There is no `Foo` trait, it should be an associated type in the trait, as described [here](https://github.com/rust-lang/rust/issues/50166).
It's early days for atom-ide debugging there is no rust support yet. The closest package for providing this is [atom-ide-debugger-native-gdb](https://atom.io/packages/atom-ide-debugger-native-gdb) as gdb works for rust. However, I didn't have much luck trying it out this morning.
Wait, what? Re-read my snippet pls.
What would that look like?
Huh, I didn't know you could use `for&lt;'a&gt;` even in supertrait position.
The issue says `placement new`, but the Rust feature was named `box syntax`, `placement in`, `Placer API`, etc. `placement new` is a `operator new` overload in C++, Rust does not have such a thing.
Ahhh, beat me to it (literally). One of my class final projects was creating a solid Raft implementation in Rust. Always room for more I suppose!
It looks prettier on GitHub's display than on the playground. Clearly we need to file a bug with the playground.
Would it also make an `Index` trait that returns a proxy possible?
&gt; I find it is kinda ironic, that the language selfhosted compiler is not written in the most beautiful and idiomatic way. Ironic? More like impossible. You can't use new features in rustc until after the next nightly because the compiler needs to be able to bootstrap itself. 
That's the trick I usually use to return iterators which borrow self from trait's method
Ah yes, I meant `Foo` in my example is an associated type. Your example also decomposes the traits but in the reverse order.. The order doesn't really matter, both ways make it more verbose to impl the trait for a type because it is now split into 2 traits.
When clicken on this post I had no idea what i was in for. Good stuff!
That site is indeed a good resource. Some additional information about this implementation in particular; I used the [midpoint circle algorithm](https://en.wikipedia.org/wiki/Midpoint_circle_algorithm) to create the layout from some given input data. The first version didn't include the actual code in the circle and was just data. To remedy this you can just increase the radius to make space for the code with the data. Doing so changes the amount of space the data takes up, so involved some trial and error. A rougher but easier to read version of the code can be seen [here](https://github.com/kirjavascript/circle-quine/blob/master/src/main_messy.rs)
Pfft, it doesn't even have dependent types
Yes! But I don't know how to make that change in a backwards compatible way.
Judging by how you're applying permutohedron to strings, I think you want to permute a sequence of grapheme clusters, not characters. https://manishearth.github.io/blog/2017/01/14/stop-ascribing-meaning-to-unicode-code-points/ The unicode-segmentation crate will give you the iterator you need to do that. https://github.com/unicode-rs/unicode-segmentation/ extern crate unicode_segmentation; use unicode_segmentation::UnicodeSegmentation; fn main() { let my_str = "Hello, 🌎"; let my_chars: Vec&lt;&amp;str&gt; = my_str.graphemes(true).collect(); println!("{:?}\n", my_chars); } https://play.rust-lang.org/?gist=5e28d2ef44c312728408593e545ebba6&amp;version=stable&amp;mode=debug
I like my way cause it's almost identical to proposed `type Future&lt;'a&gt;: Future&lt;Item = X&gt;` syntax. And it will be easy to switch one stabilized
...or, if you want an advanced debugger UI and don't mind it being separate from the IDE, you could try gdbgui https://gdbgui.com/ Potential points of integration include: * [Support for being launched](https://gdbgui.com/docs.html) (with a command to run to start the debuggee), by another process. * Support for [connecting to an existing gdbserver instance](https://gdbgui.com/docs.html) provided by the IDE. (Should be automatable by generating and passing a GDB script to it via `-x PATH`) * Support for attach to an existing process (Should be automatable by generating and passing a GDB script to it via `-x PATH`)
We could add an `Index2` trait implemented for all types that implement `Index` that uses GAT. Then, with specialization, users can specialize `Index2` for their own types. Too complicated for my taste, but... I don't know how to change `Index` in a backwards compatible way either.
I’ve written one in Java (no support for snapshots or group membership) and idly considered writing one for Rust. It’s not a task to be taken lightly.
It doesn't *have* to be an extension function. It could just be a standalone function. If you want it to be available as a method call, you can define a new trait with your method and implement it for `Vec`: you just need to ensure your trait is in scope wherever you want to call the method. Also, you can do this with less unsafe code: you can use `slice::split_at_mut` to get the two mutable slices. Not sure if there's a safe way to cast that to a fixed size array yet.
[`slice::swap_with_slice`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.swap_with_slice) although unstable is probably what you want.
Ah, there we go. Thank you for the clarification!
`ptr::swap_nonoverlapping` is stabilized in beta (will be stable in 1.27), then you can have this: pub fn swap_range&lt;T&gt;(data: &amp;mut [T], len: usize, a: usize, b: usize) { if len == 0 { return; } let a_end = a.checked_add(len).expect("overflow"); let b_end = b.checked_add(len).expect("overflow"); let _ = (&amp;data[a_end - 1], &amp;data[b_end - 1]); assert!(a &gt;= b_end || b &gt;= a_end, "overlap"); unsafe { ptr::swap_nonoverlapping(&amp;mut data[a], &amp;mut data[b], len); } } 
Not all heroes wear capes &lt;3
Thanks for the feedback!
https://docs.rs/reqwest/0.8.6/reqwest/unstable/index.html
Hmm, if you use `swap_with_slice` as suggested by [simukis](/u/simukis), which is also to be stable in 1.27, you can do without unsafe code. pub fn swap_range&lt;T&gt;(data: &amp;mut [T], len: usize, a: usize, b: usize) { let (first, second) = if a &gt; b { data.split_at_mut(a) } else { data.split_at_mut(b) }; first[..len].swap_with_slice(&amp;mut second[..len]); } 
This is best handled as someone above suggested. You keep track of the state in a wrapper API and only propogate the state to the actual device through a delay. That way, you may change the state multiple times in quick succession, and only after a delay appropriate to the HW is the final state sent to the HW.
Yet :)
No. The file itself will be kept in cache, and you're a network service; the I/O bound there is way bigger than on local fs
For my use case I know that all of the swaps I will call on with this function will be completely safe - I've actually opted to use the initial one you gave but all stripped down. It's also handy that it's so neat because I'm doing the same swap in multiple arrays. #[inline] pub fn swap_range(&amp;mut self, l: usize, a: usize, b: usize) { unsafe { ptr::swap_nonoverlapping(&amp;mut self.crk[a], &amp;mut self.crk[b], l); ptr::swap_nonoverlapping(&amp;mut self.base_idx[a], &amp;mut self.base_idx[b], l); ptr::swap_nonoverlapping(&amp;mut self.run_lengths[a], &amp;mut self.run_lengths[b], l); } }
New post on borrows/ownership in Rust through example
I really thought Pi types would be earlier in rust than GAT's ... really unexpected
Did you write this and, if so, can you increase the size of the frame that contains the code snippets? It's super annoying having to [scroll horizontally to read your code](https://i.imgur.com/RA4NhAy.png).
Cool. One small note; normally if such a function is exposed (and the `pub` modifier kind of implies that), it should be marked as an `unsafe` function. This is because as it stands, it is possible to call this method *in safe code* with something like `x.swap_range(1, 0, 0)` which has overlap leading to undefined behaviour.
Thanks. I see what you mean, I thought char would handle unicode complex graphemes... I look at the unicode_segmentation documentation, there first example is better because it doesn't split as I'd expect it, contrary to my simple "Hello, 🌎". https://play.rust-lang.org/?gist=abeb32715ef3edc898ea564a1191441a&amp;version=stable&amp;mode=debug Interestingly python3 str behaves like rust char: #!/usr/bin/env python3 s = "a̐éö̲\r\n" print(s) c = [ x for x in s ] print(c) 
Been looking forward to a new episode!
Cool. I'm a little confused, though. I assume the read is so you can get the brightness value before the write to set it, or is there something else going on? What operating system are you running?
I'm not a Rust expert, but I think it's better to use **to_owned** here: othervec.push(myvec.get(1).unwrap().to_string()) Since, your intention is to created owned string from borrowed, not to make a string representation.
Yeah. There are two problems with supporting graphemes in the standard library: 1. Rust needs to be usable in restricted environments and the only way to split based on graphemes is to lug around a full set of Unicode tables. 2. You might not want to wait for the next compiler version to update your Unicode tables. (Especially if you're in some kind of enterprise setting where it's much easier to get an update to `unicode-segmentation` OKed than an update to the compiler version they've tested and pinned.)
It's not doing what you think it's doing, I think. https://doc.rust-lang.org/std/string/struct.String.html#method.chars See the second example here. You *probably* need the unicode segmentation crate: https://unicode-rs.github.io/unicode-segmentation/unicode_segmentation/trait.UnicodeSegmentation.html#tymethod.graphemes
&gt; I spent pretty much the whole day banging my head against the wall trying to figure out how ownership and borrowing work in Rust, and finally have a grasp on what’s going on. Heh, I spent the past few days banging my head against re-borrows! If you think you know borrows, just wait until you try reborrows :P They let you bend Rust's rules and (sortof) have two or more mutable references to the same value. Playground: https://play.rust-lang.org/?gist=7e7adfbb067e8b965deec77e805a4a18&amp;version=stable&amp;mode=debug Unfortunately there is very little to no documentation on Re-borrow in Rust, and its related concept of liveness. I've only been able to vaguely understand them thanks to /u/Quxxy's helpful comments the other day and the smattering of references around the web. There used to be a section of the Nomicon that briefly mentions it, but that section is gone. Apparently re-borrows were supposed to be added to the Second Edition of the Book, but I guess that didn't make it in. I have half a mind to post on the Forum about it because there are still massive gaps in my understanding of them, and maybe it'll get all the knowledge in one place rather than scattered across the net and old versions of the books.
You're correct. /u/ssokolow also pointed to unicode-segmentation in [their answer](https://www.reddit.com/r/rust/comments/8nnxjc/reference_to_an_array/dzxl2gf/). Thanks.
Better yet, it should validate the l, a, and b parameters to ensure they are non\-overlapping and in\-range for the vector and panic if they are not. Then, it is a safe function. Don't forget to document the desired contract.
Can somebody explain what this is about? I am not quite sure I followed the link... 
We could always try to rename `#[fundamental]` if there's not enough syntax to argue about. 
Boats is a national treasure 
You don't need two traits for that, because of the way the orphan rules work. You could just do: impl&lt;I, T&gt; Index2&lt;T&gt; for I where I: Index&lt;T&gt; { type Proxy&lt;'a&gt; = &amp;'a T; } Now users can only implement `Index` *or* `Index2`, but not both.
 struct DisplayToDebug&lt;T: Display&gt;(T); impl&lt;T: Display&gt; Debug for DisplayToDebug&lt;T&gt; { fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; std::fmt::Result { self.0.fmt(f) } } Probably won't compile as-is
The linked issue (https://github.com/hyperium/http/issues/73) explains why the `http` crate does not use the `url` crate. &gt; as the http crate does not even provide conversion functions for better ergonomics Also from the linked issue (by me): &gt; I think it would be plausible to provide conversions between http::Uri and the url crate. This is open source. The issue already indicated that a conversion would be fine. The time spent authoring this blog post could have been spent authoring a PR that provided the conversions and the feature released. Instead, we are going to have an argument on the internet...
The shortest possible answer is, when you use a type like `Box&lt;T&gt;` or `Vec&lt;T&gt;`, how is that memory allocated? This feature will let you swap out the default current one (jemalloc) with anything else you'd like.
If you're creating a string, `.to_string()` is the most straightforward way of doing it, and is considered the idiom overall. Some people used to use `.to_owned()` purely because it's faster, but now they're equivalent. As far as I'm personally concerned, unless you're writing `T: ToOwned`, you shouldn't be calling `.to_owned()`.
I haven't tried myself but I think you could just write a custom request guard that checks for the API token? https://api.rocket.rs/rocket/request/trait.FromRequest.html
I think I heard somewhere at RustFest that the default one will change to just the system allocator soonish, is that true? Presumably that was waiting for this API to stabilize first?
I used to use http crate for mio\_httpc but eventually abandoned it. In my opinion http is only useful for servers. First of all it results in too many types. When creating an HTTP request you also need some http call settings like timeout, max response size, max redirects, etc. You are now using at least two builder types. This is ugly and unnecessary. In any non\-trivial app where you need a HTTP client, you will also be constructing your URLs. Correct URLs require percent encoding. Neither http nor url crates help the user with this problem. The only proper solution is for the http client to allow and encourage URL construction piece by piece. Concatenating strings should be avoided and HTTP clients should help the user to avoid it. What resulted is everything being done using a CallBuilder. CallBuilder::get() .https() .host("www.example.com") .auth("user name", "my password") .port(12345) .path_segm("a/") .path_segm("b") .query("spaced key", "123") .query("key", "&lt;&gt;") .get_url();
It’s something people want, and I believe there’s a PR, but I’m not sure the team has signed off on it yet. Yes, this is a requirement, as we didn’t want to remove the ability to stick with the current behavior if desired. Note Windows already uses the system allocator by default, too...
My last function does do validation; but sometimes, when squeezing out performance, you can use some unsafe code carefully. If the swaps are already known to be safe (as stated above) there can be a case for using unsafe code to avoid rechecking in performance-sensitive code. Marking the unsafe code as unsafe will help point that out without incurring any performance cost.
This is cool. Where are you hosting it?
nice! one suggestion. You can use `Result&lt;Json&lt;ServerMessage&gt;, Error&gt;` as return type for you handler. actix-web provides `Responder` for result in form: ```impl&lt;T: Responder, E: Into&lt;Error&gt;&gt; Responder for Result&lt;T, E&gt;``` 
I recommend and prefer `to_owned` as well. [Relevant forum topic.](https://users.rust-lang.org/t/to-string-vs-to-owned-for-string-literals/1441/6?u=dtolnay)
However this is global to the project or to the crate? Would it be possible to make it modular to the mod level? 
For clarity I'd even suggest good ol' `clone`, the intent is quite literally to clone the source string.
Funny enough, about 6 hours ago, I was wishing it was stabilized. But for a bit of context (this might not be answering your question, but I sure think it's both relevant and neat): Here it's declared in [core](https://github.com/rust-lang/rust/blob/master/src/libcore/alloc.rs), from the description &gt; /// A memory allocator that can be registered to be the one backing `std::alloc::Global` &gt; /// though the `#[global_allocator]` attributes. Either way, it doesn't really matter too much, a lot of the important stuff is later, in [liballoc_system](https://github.com/rust-lang/rust/blob/master/src/liballoc_system/lib.rs) - line 54 is where it starts getting called and defined. Basically, it's stabilizing a memory allocator API 
good suggestions, thanks!
It's hosted on heroku. Deploying was dead simple with the buildpack.
Yeah....eventually. Working through how to handle logging in and setting a token at the moment.
i think the argument here is that `.to_owned()` is _semantically_ more logical, not because people thought it's _faster_; in this context, "creating an owned value from a borrowed one" is more accurate and parsable when reading this code, rather than "creating a new string" cf: &gt; Since, your intention is to create owned string from borrowed, not to make a string representation.
thanks fuasthma, I manage to get my code working using split_at_mut # the indices of cell to edit # it must be sorted adjs = [0, 4, 7]; # need a temporary table of mut ref of values to change let mut res: [&amp;mut value; 3] = [Value:default(), Value:default(),Value:default()]; let tail : &amp;mut [Value] = grid; let (head, tail1) = tail.split_at_mut(adjs[0] + 1); tmp[0] = &amp;mut head[adjs[0]]; let (head, tail2) = tail1.split_at_mut(adjs[1] -adjs[0]); tmp[1] = &amp;mut head[adjs[1] -adjs[0] - 1]; tmp[2] = &amp;mut tail19[adjs[2] - adjs[1] - 1]; tmp.par_iter_mut().for_each(|val| { if let Value::MyVariant(ref mut possible_values) = *val { // val or possible_values are mutable here } });
To some, \`to\_string\` may mean "convert something that isn't like a string to a string." To others, \`to\_string\` may mean "convert something that isn't a \`String\` to a \`String\`." I think both are valid perspectives.
`to_string` tells the reader that you're trying to _convert_ something into a string though. If you already have a string, `to_owned` will be more clear. `to_owned` clearly speaks that you're allocating something, and that's all you're doing. It seems much more accurate to describe a `&amp;str -&gt; String` function as "turning something borrowed into something owned" than "turning something into a string".
Using the system allocator, at least on highly popular Linux platform, in very multithreaded very allocation heavy code can have a SEVERE performance impact (I've personally measured 100x slower on production C code). The system allocator is better for short lived single threaded code, like short term CLI tools, where I got at best 2x faster and used megs less memory. There used to be issues with older versions of jemalloc and transparent huge pages the affected some rusteceans, and their opionion of jemalloc but that should be fixed in current Rust versions. Switching allocators with vastly different performance characteristics doesn't seem fit into Rusts promise of stability. Right now the production code I'm working on takes 66% longer to run If I switch to the system allocator. If the default switches I'll have to but a big long explanation on how to use the "fast" allocator, or to not to upgrade Rust past the last version with the jemalloc default.
Would be great if you could provide Heroku deployment section to he user guide
&gt; Also from the linked issue (by me): &gt;&gt;I think it would be plausible to provide conversions between http::Uri and the url crate. &gt; This is open source. The issue already indicated that a conversion would be fine. My inted was it to completely replace http:Uri and just use url::Url. From earlier comments on both hyper and http I got the impression that the core team had already decided not use (or integrate it otherwise) url::Url and did want to discuss this further. Comments like this by @seanmonstar about Url: &gt; My opinion is to just ignore that it exists. &gt; Instead, we are going to have an argument on the internet... Anyways I've created a [PR](https://github.com/hyperium/http/pull/205) for conversions. 
I do think that the `http` crate could benefit from a `uri::Builder`! Would you be interested in helping us flesh out a design and implementation, to help the crate be more useful in client situations?
You will see `SomStructTag`; `SomeStruct` is just an alias which does not survive the compilation phase.
The stability guarantee says nothing about how fast or slow your code will be.
I'd be happy to add it to the end of the article, but for those curious here, i just followed the instructions in the readme [here](https://github.com/emk/heroku-buildpack-rust): 1. `$ heroku create --buildpack https://github.com/emk/heroku-buildpack-rust.git` 2. Put the following in a Procfile and check it into VCS `web: ./target/release/hello` 3. `git push heroku master`
I'd be happy to add it to the end of the article, but for those curious, i just followed the instructions in the readme [here](https://github.com/emk/heroku-buildpack-rust): 1. `$ heroku create --buildpack https://github.com/emk/heroku-buildpack-rust.git` 2. Put the following in a Procfile and check it into VCS `web: ./target/release/hello` 3. `$git push heroku master`
I also don't think that adding your own builders that encapsulate `http`'s builders is bad.
Looks like we won't have to worry about this once NLL is available: [http://play.rust\-lang.org/?gist=5cc812f12256e505b0ef37a7608af342&amp;version=nightly&amp;mode=debug](http://play.rust-lang.org/?gist=5cc812f12256e505b0ef37a7608af342&amp;version=nightly&amp;mode=debug)
You're welcome. Nice to be able to get the news from first source, then have people thank you for it. :-)
Sorry, I didn't mean to imply go away or I don't want to talk about! With that comment, I originally meant that from the context of the `http` crate, it seemed best to me not include `url`. Reading it again now though, I see how it can sound dismissive. ---- I do still feel like conversions aren't that bad. I say this as the maintainer of `reqwest`, where I convert between the two types internally when needed. And I still suspect the downsides outweigh the benefits. But I don't mind hearing why I could have wrong feelings :D
You can also just use the async API in reqwest if you want a non-blocking version. Oh, and calling `json` on the request builder will add a JSON content-type for you automatically!
I like to think of it as "Which property is more fundamental to the reason you need to make the call? Getting ownership or converting type?"
I would be happy to help with the design. 
According to the feature matrix, it seems that Thrift implementation for Rust lacks HTTP transport support: [https://github.com/apache/thrift/blob/master/LANGUAGES.md](https://github.com/apache/thrift/blob/master/LANGUAGES.md)
Would you want to open an issue on the http repo, outlining goals or a proposed API? We can discuss ergonomics and validation there!
Apologies in advance... A few weeks ago, when I was thinking about how to present my "rust gui from scratch" ideas, I envisioned the following dialog: **me:** You never let me do anything I want. **bc:** That's only because you're always trying to do *improper* things. **me:** What do you mean improper? **bc:** You know, like have multiple mutable references. [spoken in a hushed tone of voice, like that's the most horrible thing imaginable] **me:** There's nothing wrong with that, I know the way I use it is fine, you're just not smart enough to understand that. **bc:** But how else would you know for sure your program is safe? There are so many things that can go wrong... use after free, iterator invalidation... **me:** [cutting off bc] I don't have to listen to you, you know. I could just use `Rc&lt;RefCell&lt;T&gt;&gt;` for all my references. **bc:** [somewhat vindictively] You *could,* but it'd make your life miserable. Explicit borrows all over the place, panics if you get it wrong. Memory leaks if you get a cycle... **me:** True. Or... [threateningly] I could just use `unsafe`. **bc:** [lib quivering, voice trembling] You wouldn't. Then the point is that using the techniques in my prototype (Vec to store graph nodes, state splitting, transfer of state by data flow rather than control flow), you don't fight the borrow checker, the code flows naturally. I was thinking of actually staging this as part of the talk, but ultimately it's ending up on the cutting room floor as being too cheesy. I have a feeling people who have wrestled with the borrow checker would relate, and those who haven't would get some idea what it feels like.
I thinking the perception of stability, but I didn't really write that. If upgrading your compiler doubles an already too expensive AWS bill it doesn't appear to be a stable technology platform to the non technical people writing the checks. To be fair I'm unaware of all the reasons to use the system allocator, I should try to hunt down the RFC were this is being discussed. The main arguments I'm aware of, is jemalloc adds a noticeable amount to the executable size and needs a few more megs of memory at start. I would think the platforms with jemalloc, (Linux, OSX), that wouldn't be a major issue. But I could see that being bad on embedded Linux. And I've seen people complain about the large exectuable sizes, though I would think havin g something apply strip to release builds The best default depends on the use case, I tend to focus on long lived(months) heavily multithreaded code on biggish servers, which is ideal for jemalloc. If I was replacing our little utility python scripts instead I would probably prefer the system allocator. SO when this Ironically the reason we switched our C code to Jemalloc from an in house custom allocator (to work around the nightmarish performance of system allocator on our code), was because I was made aware of it when I was looking at Rust in the runup to 1.0. In our C code using jemalloc being able to trace memory leaks in production has been super helpful, for finding issue. So I'm quite happy with jemalloc as a solution. 
It looks like [a fix is incoming](https://github.com/rust-lang/rust/pull/51274).
No you are totally right, there is nothing else going on. I'm running Linux. Sadly I don't get what you are confused about. So if it would really bug you then [here](https://gitlab.com/Marteon27/backlight-interface) is the source.
This is great! Was waiting for this to happen since i stumbled over cpal :)
I imagine one of the main arguments is that Rust being a "systems language" shouldn't necessarily bundle an entire allocation runtime by default rather than relying on whatever the underlying system natively implements. Jemalloc has been a *pretty good* default in the absence of a stable mechanism to change allocators, but now that that's a possibility it makes sense for the default to be "whatever your environment natively provides" since you can always switch right back to Jemalloc if it's desirable for your use case.
congrats!
Does that have any utility beyond having an alternate name for a &amp;mut in an inner scope?
Happy cake day! 
I've only been coding in rust for a few months seriously, and I rarely find that I fight the borrow checker nowadays. If I do get an error, it's always because I've designed a piece of functionality wrong or, more interestingly, it's not the most efficient implementation. Code is typically Input -&gt; Transform -&gt; Output As a design-pattern for Rust I stick to 1. Everything should be immutable at the point of initialisation 2. Read you data first, then finally write to a new structure at the end of a function 3. Return iterators (esp with impl trait) rather than collections. I hope to extend this item further when streaming iterators appear. Obviously this is not a perfect idiom and it breaks down occasionally (input, output and occasionally memoisation), but it's surprisingly effective for a lot of things. You rarely get borrow checker issues and, as a design principle you are never copying data (no allocations).
For my tasks if I had to use the linux libc allocator in Rust, then I wouldn't be able to use Rust, so I'll certainly enable it. I just don't like a silent potentially large decrease in performance when updating the compiler. If the switch was handled with some kind deprecation like mechanism such that people who don't read the full release notes, know it's coming and how to reenable what they previously had. Then that would ok as well, I can't think of a way to do that without requiring explicit allocator selection, which I don't think would be acceptable. If I could check the allocator settings in my crate and have it produce a warning, if the binary's allocator is poorly suited, then that might work for me. Per Crate level allocators could also work, but I doubt the overhead of two allocators would be worth it. In the context of jemalloc I wish if I could tie a crate/module/function's allocations to a particular jemalloc arena. That would give some fine grained memory usage stats that could be used in production, and might help with cache locality in some cases.
You don’t have a String. to_string makes a String.
Sure, I argue it’s a more general semantic and so being mor specific is clearer. I was trying to provide a bit of context for the debate, not suggesting that people are still making speed arguments today.
Well done guys, just updated now!
That's like saying the secret to web development is that it's just programming. That's useful when I can instead recommend resources for specific skills such as JavaScript, react.js, DOM manipulation, styling etc.
Everyone uses re-borrows, they just don't know it. Whenever you call a function passing in an `&amp;mut T` the compiler is automagically inserting a re-borrow for you. Here's why, based on my understanding: `&amp;mut T` does not implement `Copy`. If you could copy a mutable reference you'd be able to have two or more of them and violate Rust's safety rules. So back in Rust's early days there was a problem: let mut_ref = &amp;mut foo; my_func(mut_ref); my_other_func(mut_ref); This wouldn't compile. Since `&amp;mut T` doesn't implement Copy the compiler can only move it. So the first function call would move `mut_ref`, and the compiler would complain abut the second call because `mut_ref` has been moved. So re-borrows were invented and a rule was made that the compiler would desugar function calls like this to: my_func(&amp;mut *mut_ref); i.e. a re-borrow. The re-borrowed reference is what gets moved into the function, thus `mut_ref` doesn't die. The obvious restriction on re-borrows is that you can't use the reference that was re-borrowed while the re-borrow is alive. So basically everyone using Rust is using re-borrows, they just aren't aware of it. I find this topic fascinating because it helps to illuminate Rust's inner workings and demystify its magic. If you were attempting to grok Rust and really thought about function calls you'd probably come to the conclusion that a lot of function calls shouldn't compile. They only compile thanks to the magic of automatic re-borrows. (Warning: This is all based on my rather weak understanding.)
`mem::replace` may be a little more terse than `mem::swap`: *self = D::E2(e, std::mem::replace(e1, A::zero()));
Thank you! I'm actually huge fan of textbooks versus the current trend of "learn this in 1 day!" or "Oh yeah? How about 7 hours?! Buy my book!" I'll see if I can find a copy under $100 😂
^The linked tweet was tweeted by [@chancancode](https://twitter.com/chancancode) on Jun 01, 2018 22:15:20 UTC (0 Retweets | 0 Favorites) ------------------------------------------------- I'll be pairing on [@thejonanshow ](https://twitter.com/thejonanshow ) to write Game of Life in Helix (i.e. Ruby + Rust) today! Join us at [http://twitch.tv/thejonanshow](http://twitch.tv/thejonanshow) (1PM JST / 9PM PST / midnight EST) and wish me luck! \#rubykaigi \#rustlang ------------------------------------------------- ^^• Beep boop I'm a bot • Find out more about me at /r/tweettranscriberbot/ •
Not sure if I should be linking to the tweet or the stream since it hasn't started yet, but here it is: [https://www.twitch.tv/thejonanshow](https://www.twitch.tv/thejonanshow)
Thanks, this at least makes it a lot less verbose. I'm guess there's no way of getting rid of the dummy variable though?
Right, hopefully there will be a widely seen announcement or maybe a deprecation period of some kind when they do go ahead with the switch.
\(Warning: This is all based on my rather weak understanding.\) AFAICT you have a pretty good handle on this, but I would like to point out another way of thinking about it. In the [original blog post](http://smallcultfollowing.com/babysteps/blog/2012/11/18/imagine-never-hearing-the-phrase-aliasable/) that outlined the ownership rules of `&amp;mut T`, it was described as a pointer that takes temporary ownership. For example: // Adds 1 in place then returns the old value fn add_one_in_place(mut n: Box&lt;u64&gt;) -&gt; (u64, Box&lt;u64&gt;) { let rtn = *n; *n += 1; (rtn, n) } fn main() { let box_num = Box::new(5); let (five, box_num) = add_one_in_place(box_num); let (six, box_num) = add_one_in_place(box_num); } In this function the reference is moved into the function then moved back, shadowing the old value with the new. You could imagine `&amp;mut T` doing something similar, taking ownership and then having ownership moved back up to the calling function and automatically bound to the same name. I'm not entirely sure how accurate this description is \(I don't really know how this is actually implemented\), but so far it's been pretty helpful to me in understanding how mutable references in Rust work
Ah, that makes sense. I guess I was thinking of it as yes, a the conversion, but not really a data conversion. Besides ownership, I really think of `&amp;str` and `String` as the same kind of data. Yes, it is a conversion, but isn't it more a kind-of-ownership conversion than anything else?
&gt; lib quivering I see what you did there.
I prefer `to_owned` if I have a `&amp;str`, but in this case I have a `&amp;String` and want a `String`, so I use `clone`. Is that weird?
+1 for Tolkien ref
I love that the HTTP proxy example fits in [a tweet](https://twitter.com/olix0r/status/1002690454691897344)!
[@olix0r's latest tweet](https://i.imgur.com/YLjgHwq.jpg) [@olix0r on Twitter](https://twitter.com/olix0r) - ^I ^am ^a ^bot ^| ^[feedback](https://www.reddit.com/message/compose/?to=twinkiac)
To be fair, there is a bit of upgrade work in the ecosystem that seems to be waiting for futures 0.3 before undertaking the upgrade from futures 0.1...
I don't think Tokio is going to jump immediately on 0.3 either. IMO there is no need to rush things.
I think the worst of it is testing. It gets out of hand quite quickly.
Totally agree, but my guess is that this is where some of the confusion is coming from. I also have no immediate plans to upgrade, but I think this is causing some people to wonder about what's happening with futures and there is a bit of concern from people who are in a wait and see. It's clear to me that a lot of people are very excited for async/await and so may be hesitant to learn the current Futures framework. The upgrade to tokio was quite a bit of work, and futures 0.3++ is probably going to similar.
Systems programming is an incredibly vague term though. What are you wanting to try? Creating a hobby x86 OS? Building a custom Linux kernel module? Contributing to a project like Redox?
Thanks, I didn't know about that NonZero implementation. That's a great example.
I want to learn what any undergrad CS would learn. Sorry if it's vague, many universities have classes called "systems programming" so I assumed it was specific enough, like saying I want to learn "fluid mechanics." 
I have an Auth0-focused example: https://github.com/anxiousmodernman/auth0-rocket-rust-example I used request guards + managed state. You'll need managed state to plumb your certificate into a rocket handler, and request guards to access that state and use it in the context of a request. Some notes: * logout/session destruction not implemented * I verify a jwt, hash it as an opaque session identifier, and store it in a cookie; this is pretty different from API usage, where you'll want to be more stateless, and verify the jwt on every request * I'm not a security expert, so suggestions welcome :)
This is a nice idea!
You're right, the feature matrix is clear.
Most operating systems are written in C, and in order to expose syscalls to applications they tend to define a standard "C" [ABI](https://en.wikipedia.org/wiki/Application_binary_interface). Many language implementations are either written in C, exposing a C API for type conversion and control (common amongst VM/scripting languages, including [Python](https://docs.python.org/3/c-api/index.html)), or they provide the C ABI as an optional compilation target (FFI). Rust does the latter. It doesn't guarantee a stable default ABI, the way structs are laid out for instance has changed a number of times, but it does allow you to specify the target ABI of an item. `extern "C" fn` declares a function that expects to be called with the C calling convention. Rust code can call it just like any other (although perhaps not in the *most* optimal fashion), the difference being that when compiled as part of a `staticlib` or `cdylib`, any language that supports linkage to C object files can call it as if it were written in C. To call C functions from the Rust side you have to write the equivalent of a header file: #[link(name = "somelib")] extern "C" { fn foo(bar: libc::c_int); } Then as long as rustc is aware of the lib (e.g. `println!("rustc-link-search=/path/to/lib/dir")` in your `build.rs`), it will link to it and the function becomes callable from Rust (inside an `unsafe` block). Python can import C DLLs that expose a secific [API](https://docs.python.org/3.6/extending/extending.html) as if they were Python modules. There are libraries like [PyO3](https://github.com/PyO3/pyo3) that generate that API and wrap up unsafe FFI calls.
If I understand correctly, then you shpuld look into "match", or "if let".
&gt; So one nice thing is that most physically based rendering happens on the CPU, so I don't need to worry about GPU support or any of that ugliness. From my understanding PBR isn't CPU bound and isn't implemented vastly different from other rendering models, in most cases it's just a different shader model with assets (metal, roughtness/gloss/microsurface, albedo in addition to the normal/AO maps). Of course implementing a software based renderer could be a good learning experience. It could be PBR, Gouraud, blinn-phong, Phong or even an old-school Wolfenstein 3D /DooM style raster.
Having a String afterwards :P
You could use [std::mem::discriminant](https://doc.rust-lang.org/beta/std/mem/fn.discriminant.html) to get a value that represents the enum variant you want it to search for, then in get_attribute compare it to the discriminant of each value of the list. By the way, it's practically never useful to write &amp;Vec&lt;T&gt;, because &amp;[T] is more flexible, and the only thing that &amp;Vec can do that an immutable slice can't is fetch the capacity, whereas by using a slice you allow people to pass in a slice of an array, or anything else, not forcing them to use Vec to be able to call your function. 
I don't know what you are trying to accomplish, but you are currently heading in the wrong direction. First of all, you are using variants (term level) at the type level: `get_attribute::&lt;Attribute::B&gt;`. `Attribute::B` is not a type but a value of type `fn(i32) -&gt; Attribute`. I think enums aren't the right choice for your problem: If you'd to write concrete functions like `get_attr_a`, `get_attr_b`, what would the return type be? If you want to return an `Option&lt;_&gt;`, what would `_` be? It's totally dependend on the enum variant. Please give me some information on what you want to achieve.
What is this being used for?
&gt; For some, for example, the recent ergonomic match dereferencing has been a pain and they have requested an ability to opt-out. I don't think compiler bugs are relevant to the discussion of ergonomics. I think developers should not have to concern themselves with *typing out* things that should have sane defaults, especially for match ergonomics where there is often only one way to type things that will compile anyways. I believe developer tools should provide additional information inline for people who want to see it, such as how IntelliJ Rust provides type annotations using phantoms inline with the text. I once extended a version of the sublime text LSP/RLS plugin to provide phantoms for all sorts of things, including the types of variables that were being matched on (not the match arms, I just wanted the type of the variable being matched to be visible). Having the option to enable an unergonomic, painful mode would only serve to make the compiler frontend more complex, I would imagine, since I can't imagine many people actually using it, but if someone else wants to maintain that complexity, I don't see the problem with it. I just don't imagine it's a burden anyone is actually going to choose to shoulder.
&gt;By the way, it's practically never useful to write &amp;Vec\&lt;T\&gt;, because &amp;\[T\] is more flexible, and the only thing that &amp;Vec can do that an immutable slice can't is fetch the capacity, whereas by using a slice you allow people to pass in a slice of an array or anything else, and you don't force them to use Vec to be able to call your function. Thank you, that is nice to know. &gt;You could use [std::mem::discriminant](https://doc.rust-lang.org/beta/std/mem/fn.discriminant.html) to get a value that represents the enum variant you want it to search for, then in get\_attribute compare it to the discriminant of each value of the list. Yes I have considered that. But the problem is that T is only a type not an instance, and T might not be default constructable, so I cant create an instance of it. I probably want something like: fn get_attribute&lt;T&gt;(attr_list: &amp;[Attribute]) -&gt; Option&lt;Attribute&gt; { for attr in attr_list { if T == typeof(attr) { return Some(*attr); } } None }
This feels like it would have a lot of disadvantages with few advantages. It would definitely fracture the language, and I think it would kind of dilute Rust's message. Where in the past, we had to choose between languages like C which are fast-but-not-safe and those like Python which are safe-but-not-fast, Rust gives us both safety and speed. We have high level abstractions like iterators, traits, algebraic enums, safety, and speed all in one language. Having a switch to go "more implicit" or "less explicit" would only be versatile because it'd be multiple languages with one compile in one. It would greatly dilute Rust's message of having your cake and eating it too. --- Explicitness isn't just about performance, though. I'd argue the greater advantages are guaranteed correctness, and increased readability. Auto-deref could be just as fast as manually dereferenced code at runtime, but it would mean readers have to guess a lot more about who owns what and what's mutating stuff. Part of why I like using Rust and crates.io is that I can look at any crate's source code, and I can understand what it's doing. Even if I don't have all the exact types, I can see what inputs are being mutated, what is being consumed, where the data is flowing. This is all because of the explicit nature of the code! Having that explicitness means that you have to think about the types, yes, but it also means you then have explicit code. Being able to easily double-checked code for obviously wrong things is an advantage of Rust I don't want to throw away. 
Thanks! That was my general understanding but I really appreciate the explanation. That's a much better answer than I'd seen yet and really understand it a lot better now. I've been curious about how I could call a c or python library if I needed to and know I think I know how it works and what to look for if I needed to.
I have a method where I pass in a reference as a parameter, and then move the reference into a thread and do some operation on it, which won't compile: fn threaded_word_length(s: &amp;str){ let (tx, rx) = mpsc::channel(); let handle = thread::spawn(move || { let i = s.len(); tx.send(i); }); let length = rx.recv().unwrap(); println!("{}", length); handle.join(); } This gives the following error: error[E0621]: explicit lifetime required in the type of `s` --&gt; src/main.rs:13:18 | 11 | fn threaded_word_length(s: &amp;str){ | - consider changing the type of `s` to `&amp;'static str` 12 | let (tx, rx) = mpsc::channel(); 13 | let handle = thread::spawn(move || { | ^^^^^^^^^^^^^ lifetime `'static` required I'd agree with this error if the spawned thread were to be detached, and I didn't have any guarantee on when the thread would execute, but I am explicitly calling handle.join() afterwards here, so the reference variable s should be guaranteed to be valid for the lifetime of the spawned thread, no? Am I missing something, or is Rust not able to infer that the lifetime should be valid here?
- [crates utilizing gimli](https://crates.io/crates/gimli/reverse_dependencies) - [another way to check how a crate is being used](https://github.com/search?q=language%3Arust+extern+crate+gimli&amp;type=Code). note: gh might require one to sign in to see these search results.
Is this the first .2? 
When reading the code I would rather know that I have an operation `T -&gt; String` than I would that I have an operation `&amp;TView -&gt; T` though.
Yay! I'm gonna put it to the test this weekend by ripping Iron out of Ruma and replacing it with plain hyper 0.12. The new APIs are nice.
Yes
Sorry I should have said physically based light transport or simply ray tracing \(I'd like to use techniques like ray tracing, path tracing, volumetric PT/ray marching, etc\). Thanks for the tips! I think I'll end up going with cgmath
Hm, I guess I had the opposite priority. Glad both exist!
/r/playrust
/r/playrust. You might want to be involved with a community before you try to pull people off of it into your own.
I have a JWT solution built into an API using Rocket. Like others have mentioned, I use request guards to handle extracting JWTs from requests and I store the key used for generating and verifying the JWTs in Rocket's managed state. My solution is a little unique in that I attach a Vec of user permissions to the JWT, which allows creation of different guard types for users with different permissions. So I can have routes that will only work for tokens that have Admin permissions attached, while other routes only require that the user be logged in. The code I have for doing this is spread out across multiple files and the code itself is a work in progress, but hopefully this provides an adequate example. Also, please forgive the stupid project name. JWT request guards and utility functions: [https://github.com/hgzimmerman/WeekendAtJoes4/blob/master/backend/src/auth/jwt.rs](https://github.com/hgzimmerman/WeekendAtJoes4/blob/master/backend/src/auth/jwt.rs) JWT definition: [https://github.com/hgzimmerman/WeekendAtJoes4/blob/master/wire/src/user.rs#L42](https://github.com/hgzimmerman/WeekendAtJoes4/blob/master/wire/src/user.rs#L42) Use of request guard in route: [https://github.com/hgzimmerman/WeekendAtJoes4/blob/master/backend/src/routes/thread.rs#L36](https://github.com/hgzimmerman/WeekendAtJoes4/blob/master/backend/src/routes/thread.rs#L36) Login route: [https://github.com/hgzimmerman/WeekendAtJoes4/blob/master/backend/src/routes/auth.rs#L19](https://github.com/hgzimmerman/WeekendAtJoes4/blob/master/backend/src/routes/auth.rs#L19) Login handling and token generation: [https://github.com/hgzimmerman/WeekendAtJoes4/blob/master/backend/src/auth/mod.rs#L68](https://github.com/hgzimmerman/WeekendAtJoes4/blob/master/backend/src/auth/mod.rs#L68)
One step closer to replacing libbacktrace in rustc!
Thank you core team for persisting in quickly addressing these sorts of bugs - even when it means cutting the first `.2` release. Your work is appreciated.
`nalgebra` takes a very math-y approach to its API. You may wish to look at `euclid` as well which takes a very pragmatic, programmer-y approach (and also lets you annotate all your values with units if you want). `cgmath` is somewhere in between. They're all quite good, and roughly equally capable for 2D or 3D vector math. I recommend playing around a little and seeing which one you like best.
Hi, this got caught in our spam filter and as a result nobody had a chance to see it. Please resubmit it and I'll try to catch it if it happens again. :)
The desire to switch to using the system allocator has existed for several years now; the reason why it hasn't happend yet is precisely to accommodate use cases like yours, so that you can get jemalloc back with one line of code (using the jemalloc crate from crates.io). That's why this stabilization is so important, because otherwise people who wanted to do so would need to stop using stable.
Whats wrong with indexing in Rust?
I believe it's because the article uses the definition of `get` to describe what's going on, and wishes to skip having to explain the `Index` trait as well as the other trickery going on.
(having some difficulty with the Internet atm, stay tuned 😬)
If you find a way, I've got a bunch of code like this I'd love to clean up.
Admittedly only because the max length for tweets got increased recently.
One day maybe every crate that uses std depends on gimli: https://github.com/rust-lang/rust/issues/46439
This is what [take_mut](https://crates.io/crates/take_mut) is for, but it has the annoying issue of there being nothing reasonable to do in case of a panic. 
I'm trying to use the new fn main() -&gt; Result&lt;(),Box&lt;error&gt;&gt; { ... result? ... } functionality Is there a way to prevent 'error: process didn't exit successfully: `target\debug\my_app.exe ' and just print the Error on Error ?
Without outright dismissing the concerns, I do feel it's too early to know what weight to give to feedback on recently landed ergonomic initiatives, as resistance to change is natural. As the language evolves, it takes time for some changes to affect our mental model of how the language works. Initially, I strongly disliked `?` operator as a replacement for `try!` for making error handling less obvious and abusing my mental model of safe navigation operators from other languages. Fast forward to today: I'd even support removing `try!` from the 2018 Edition. If it weren't for the near ubiquity of `?` in the community at this point, I'd have to explain both `try!` and `?` to colleagues learning rust. So in agreement with other comments here, I also believe toggling some "explicitness" mode would fracture the language for little gain. Rust is built on striking a compelling balance on goals that often appear opposing: Memory safety vs garbage collection, concurrency without data races, abstraction without overhead, stability without stagnation. 
Off-topic for the article, but I've got a little list. In my highly uninformed and probably wrong opinion: 1. There should be an `IndexAssign` alternative to `IndexMut` for the case of assignment. As it stands, `IndexMut` must return a mutable reference to a valid initialized location to avoid undefined behavior in the case where the reference is not used until later. This is not a problem for arrays, since the array is required to contain valid values anyhow. However, for things like `HashMap` that would like to use array syntax for assignment (a reasonable thing to want) there is in general no way to satisfy this requirement, so you get the cumbersome `insert` syntax as the only alternative. Implementing `IndexAssign` for `HashMap` would allow the value to be inserted in the assignment case. There would likely have to be some compiler magic to decide which trait to apply in a particular case. Specialization is probably a precondition so as to allow a default implementation of `IndexAssign` for things that implement `IndexMut`. 2. There should be an `TryIndex` trait returning an `Option` for things like `HashMap` where the value may not be present in the data structure. One could imagine `TryIndexMut` being useful as well. See the caveats above. 3. Indexing only by `usize` seems sensible on the face of it. Haskell has a better plan, though. It has an [`Ix`](http://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Ix.html) trait (actually typeclass) that can be implemented for types that want to be indices. The associated functions allow computing a `usize` from an index value. This allows, for example, treating a tuple index as an index into a multidimensional array. Allowing indices that satisfy the `Ix` trait, together with a default implementation for `usize`, would ideally give the ability to use all kinds of interesting things as indices without breaking existing code. I haven't worked out the details of this, though; I wouldn't be surprised if this is hard or impossible in Rust. In my implementation of [sparse vectors](http://github.com/BartMassey/sivec) I managed to get past (1) and (2) only by allowing `Index` / `IndexMut` to create a default value in the vector. For the `Index` case this required interior mutability. For the `IndexMut` case this may create a default value that is likely to be immediately overwritten by assignment: if no default value can be created, `Index` and/or `IndexMut` will panic at runtime. Comments, critique, guffaws etc welcome.
Thanks, although I think wrapping this in an unsafe block kind of defeats the purpose of rust.
I hear you, but it goes the other way too. “Why does a systems language not use the system allocator? Why is there this extra stuff in my binary I don’t care about by default?” In some sense, jemalloc isn’t a zero-cost abstraction; you pay for it even if you don’t want to use it. It won’t be a big long explanation; it’s adding the jemalloc_alloc crate to your cargo.toml (and till extern crate goes away, adding it to the crate root.) We would have defaulted to the system allocator originally, but since allocators weren’t stable, and because jemalloc performs so much better in many scenarios, we decided to do it this way. 
IMO a big part of "the purpose of rust" is that the unsafe part can be wrapped up in a function like this, presenting a safe interface. (Though in this case, it's only safe because it aborts the program if you screw up, which is a... limited form of safety.) 
Let's face it: the Linux "system" allocator is not a general-purpose allocator. It's a C allocator in a library called "libc", and has been heavily tuned for performance in single-threaded C code with few small allocations. Rust's normal memory usage pattern seems pretty different to me. `Box`, `Vec` and `String` are everywhere in Rust libraries and programs, and each does dynamic memory allocation. In most C scenarios (and many C++ ones, I think?) most of that is statically allocated, which is limiting and error-prone but there we are. When many small fast allocations and deallocations are needed, it's not uncommon to see C programs implement their own custom allocators on top of `malloc`. I think it will be great to be able to switch out the allocator. However, I'd like to see `jemalloc` remain the default until somebody is ready with a nice performant allocator in Rust tuned to typical Rust use cases. It looks like there are a bunch of crates out there trying to be that now; maybe one of them is ready to be plugged into Rust as the default allocator?
Your middleware to verify the `X-Hub-Signature` header validates the secret by doing a string comparison against the secret. This won't work since the signature, passed via the header has the format `sha1=&lt;hmac over the request body&gt;` You first need to extract the signature itself by stripping the first 5 chars of the string and then calculate the SHA1 HMAC over the body, using your supplied secret. I used the ring crate (https://crates.io/crates/ring) to do the validation, when I implemented a webhook listener a few weeks ago. Here is the official documentation: https://developer.github.com/webhooks/securing/
In some sense `jemalloc` is a negative-cost abstraction: it's typically more performant than the system allocator, and no less performant if you don't use it. :-) For a language like Rust that is focused on performance, I don't think that defaulting the memory allocator for a system to one that will typically impede Rust performance on that system is worth it. I know I am willing to tolerate slightly larger binaries and more mostly-invisible custom code by default if it makes my program run a little faster.
Control is ultimately what’s important, as some need to make the exact opposite tradeoff. :)
First of all, "type" is the wrong term here; you want "enum variant" (variants aren't their own types; the only type involved is the enum itself). As for the actual problem: the cleanest way to do this is to define enum Attribute { A, B(u32), C(String), D, E(MyStruct) } #[deriving(PartialEq,Eq)] enum AttributeTag { A, B, C, D, E, } impl Attribute { fn tag(&amp;self) -&gt; AttributeTag { match { Attribute::A =&gt; AttributeTag::A, Attribute::B(_) =&gt; AttributeTag::B, Attribute::C(_) =&gt; AttributeTag::C, Attribute::D =&gt; AttributeTag::D, Attribute::E(_) =&gt; AttributeTag::E, } } } And then use fn get_attribute(attr_list: &amp;[Attribute], desired_tag: AttributeTag) -&gt; Option&lt;Attribute&gt; { for attr in attr_list { if desired_tag == attr.tag() { return Some(*attr); } } None }
Me too. Maybe we're both weird?
You can solve 3 by implementing index for other integer types.
Looks like there's an RFC on #1 open for three years now: https://github.com/rust-lang/rfcs/issues/997 It seems like #2 could just evaporate into a well implemented #1 by just using an option as the element type? #3 could probably just be a crate. I implemented Ix in Haskell last year not realizing it was already a thing, so . . . I guess I'm qualified . . .
Fairly minor nit, but you take `TRAVIS_URL` from the environment but then you only use it for formatting the response string, but pass a string literal to `travis_request`.
I think many Rust users will be unaware there's a tradeoff to be made. Also, it seems pretty ugly if down the road most crates in the ecosystem start by overriding the default allocator with a well-known common replacement. All in all, choosing a good default allocator seems pretty important to me. My personal opinion is that `jemalloc` should be left in place as the default Rust Linux allocator unless / until something unquestionably better comes along or some bad `jemalloc` problem turns up. `jemalloc` as default Linux allocator doesn't seem broke: I see no reason to fix it.
Most entertaining - did a webhook in actix-web the other day. Very friction-free JSON handling
Thanks much for the comments! I want some array-index syntax for case (2). I'm assuming a trait in `std::ops` is the way to get that. For case (3) you're right that for example what `ndarray` does now is essentially `Ix` for multidimensional arrays. As a proud user of `ndarray` I retract my previous request: existing machinery seems sufficient.
Good info, thanks! Appreciate the pointer to the RFC, which I now need to read and digest carefully along with its comments. Yeah, I already retracted (3): on further consideration I think the existing machinery is good enough. `ndarray` is not a bad solution to multidimensional arrays, for example.
TIL actix_web::client can be async too.
The answer to that question is somewhat more complex than yes or no. You'll find a lot of code people should probably not actively try to mimic. If you want to learn the „good style“, look for smaller things, where it's much easier to keep things tidy. I guess things in rust-lang or rust-lang-nursery github organizations could be generally a good place to look. On the other hand, I'd say it is excellent in the context of the codebase size, amount of people actively working on it, complexity, etc. Comparing to other code bases with similar properties (eg. size), not necessarily in Rust, rustc is actually *readable*, which is basically what matters and why you should strive for idiomatic code in the first place. Something like idiomatic code in the wild real world. So if it's about learning the style, theoretical aestetic properties, then no, start smaller first. If you care more about practice and you already went through the smaller things, then I think there's a lot to be learned from it.
Can't wait for the new reqwest update
In fact, I am also interested in getting Thrift implementation for Rust with HTTP transport. Thrift documentation and general organization seems to be a weak point, yet it doesn't seem like there is anything on par with Thrift in terms of technical details. Would you be interested to join our efforts in researching the topic? I have tried to run the official tutorial and while Rust client talks just fine with Rust server, it seems that I cannot get Rust server / client talk to other language implementations at all \(I have tried Python, NodeJS, C\+\+, and C\). What I observe when I try to connect from other languages clients is a server crash: $ ./target/release/tutorial_server binding to 127.0.0.1:9090 fatal runtime error: allocator memory exhausted fish: “./target/release/tutorial_server” terminated by signal SIGILL (Illegal instruction) C\+\+ is even in the worst state, it cannot talk even to itself \(C\+\+ client cannot talk to C\+\+ server\). This is what I get: $ ./cpp/TutorialServer Starting the server... Incoming connection SocketInfo: &lt;Host: ::1 Port: 52766&gt; PeerHost: localhost.localdomain PeerAddress: ::1 PeerPort: 52766 Thrift: Sat Jun 2 11:22:09 2018 received invalid message type 0 from client $ ./cpp/TutorialClient ERROR: No more data to read. I am yet to understand if that is my fault of some kind or that is a bug :\(
Also see [the post from yesterday](https://www.reddit.com/r/rust/comments/8nr42m/stabilize_globalalloc_and_global_allocator/) for some more discussion.
It sounds like you need to split your one-size-fits-all entity into multiple variants optimized for different use-cases
Nice! Dude you solved it!
I worked through this book on writing a ray tracer in a weekend https://in1weekend.blogspot.com/2016/01/ray-tracing-in-one-weekend.html but in Rust instead of C++. It was a great intro that got straight into getting something working. I blogged a bit about my Rust implementation here https://bitshifter.github.io/blog/2018/04/29/rust-ray-tracer-in-one-weekend/. I'm still working on it, but at the moment I've gone on a tangent optimising the sphere rendering, the later books introduce other shapes, bvhs, etc. which I'll get to at some point. I wrote my own math library, I'm only really using vector 3 anyway.
I don't have something to work it out right now, but I think the answer is going to involve the `Borrow` and/or `AsRef` traits and an explicit borrowed type `KeyARef&lt;'a&gt;(&amp;'a str)`. Then you can easily concert between that borrowed form. I think most of the struggle comes from the difference in type between owned and borrowed strings being now than just `&amp;`.
From what I've read using jemalloc should be a one line change to your `Cargo.toml` (to add `jemallocator` as a dependency) and you need to add one line to your binary somewhere using `#[global_allocator] static MyAlloc: Jemallocator = Jemallocator();` and that's it.
Thanks TimNN, I completely missed this. You are the nicest bot in the world, always helping!
I usually write `enum Error` with required `impl std::convert::From`. use std::io::prelude::*; struct Size { width: u32, height: u32, } fn get_size(args: &amp;Vec&lt;String&gt;) -&gt; Result&lt;Size, Error&gt; { if args.len() &lt;= 1 { return Err(Error::InvalidArguments); } let x = args.get(0) .ok_or(Error::InvalidArguments)? .parse()?; let y = args.get(1) .ok_or(Error::InvalidArguments)? .parse()?; Ok(Size { width: x, height: y }) } fn main() { let args: Vec&lt;String&gt; = std::env::args().skip(1).collect(); let size = match get_size(&amp;args) { Ok(sz) =&gt; sz, Err(er) =&gt; { writeln!(std::io::stderr(), "{}", er).unwrap(); std::process::exit(1); } }; let size = get_size(&amp;args).unwrap(); println!("{} : {}", size.width, size.height); } #[derive(Debug)] enum Error { InvalidArguments } impl std::convert::From&lt;std::num::ParseIntError&gt; for Error{ fn from(_err: std::num::ParseIntError) -&gt; Error { Error::InvalidArguments } } use std::fmt; impl fmt::Display for Error { fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result { write!(f, "Invalid arguments") } }
Here is one possibility: [Link](https://play.rust-lang.org/?gist=8368d41294ac999970d18c9a605b4cd3&amp;version=stable&amp;mode=debug) Note that get_size() now returns a String, instead of a &amp;str, as the error type, but that's unavoidable, since we can't get &amp;str from the errors that parse() produces. This assumes that you're happy to use plain old Strings to represent errors.
Hi Rustanceans! I would like to cast a boxed trait object to its more specific type. While I managed to do that here: https://play.rust-lang.org/?gist=4da90f19c3ebd780f83ae7dbf2bfbff4&amp;version=stable&amp;mode=debug I can not manage to get it working for a referenced box. https://play.rust-lang.org/?gist=4861c8a630895390699faf66bbf2cc74&amp;version=stable&amp;mode=debug I do get a referenced box because I store the boxed in a HashMap. And with HashMap::get I will get back a reference. How can I get example 2 to work? More context: (Why I would like this) I want to have a struct Actor that has a HashMap of components (Transform, Rigid, Psysics etc etc). So the Actor holds all his components. But the tricky part is that every component should be able to contact other components in the same Actor. I'm pretty new to Rust so it might be a noobies question. But I cant seem to figure it out. What I do think to understand is that downcast only exists for Box&lt;Any&gt; while in the second example the function accepts Box&lt;ActorComponent&gt;. Because if I change the argument type to Box&lt;Any&gt; then the compiler again complains that it is receiving a Box&lt;ActorComponent&gt; instead of a Box&lt;Any&gt;. While the compiler seemed fine about it in the first example. Thanks!
If the string is the problem its no problem to substitute it with a [u8;32] actually
Okay, will do. Thanks! :\-\)
We've been using the 0.12 from Github on production since the beginning of the year and at least the last three months it's been running without trouble. Happy to see it finally in crates.io!
Looks like fun! The Rust sample project isn't really commented, but I think I've figured it out enough to work with it. Is there a graphics library lying around for this, or any interest in building one together? I've got some simple DDA line drawing code at this point.
There is a crate that can do some of that for you: [Enum-Kinds](https://crates.io/crates/enum-kinds). With that crate, you can get a working example similar to the OP: #[macro_use] extern crate enum_kinds; #[derive(Debug)] struct MyStruct { a: u32, b: String, } #[derive(Debug,EnumKind)] #[enum_kind(AttributeKind)] enum Attribute { A, B(u32), C(String), D, E(MyStruct), } fn get_attribute(attr_list: &amp;[Attribute], t: AttributeKind) -&gt; Option&lt;&amp;Attribute&gt; { attr_list.iter().filter(|a| AttributeKind::from(*a) == t).next() } fn main() { let attribute_list = vec![ Attribute::A, Attribute::B(100), Attribute::E(MyStruct{a: 500, b: "Hi".into()}) ]; assert!(get_attribute(&amp;attribute_list, AttributeKind::A).is_some()); assert!(get_attribute(&amp;attribute_list, AttributeKind::B).is_some()); assert!(get_attribute(&amp;attribute_list, AttributeKind::E).is_some()); assert!(get_attribute(&amp;attribute_list, AttributeKind::C).is_none()); assert!(get_attribute(&amp;attribute_list, AttributeKind::D).is_none()); } 
I think what was suggested is that instead of carrying around `&amp;'a KeyA { owned_data }` you should carry around `KeyARef&lt;'a&gt; { &amp;'a owned_data }`, essentially moving the reference inside. This way you could easily and cheaply convert between `KeyARef` and `KeyBRef`. --- Also, just to note: as far a I am aware, the pointer cast / transmute solution is technically undefined behavior or something unless both types are `#[repr(C)]` (since the Rust compiler doesn't make any guarantees about the layout of `#[repr(Rust)]` structs. 
[removed]
We’re working on it! I think Ashley is working on a PR with more docs. I’m actually not sure about that! I’ll poke around and ask, and if I find out, let you know.
&gt; I think what was suggested is that instead of carrying around `&amp;'a KeyA { owned_data }` you should carry around `KeyARef&lt;'a&gt; { &amp;'a owned_data }`, essentially moving the reference inside. This way you could easily and cheaply convert between `KeyARef` and `KeyBRef`. You're going to have more difficulty creating and returning such a key though, aren't you?
With both hyper and actix-web performance improvements, I am looking forward to the next round of techempower benchmarks.
This looks nice. We are currently investigating the usefulness of a "push micro service" in our company. We usually use Java for our backends but it got more and more problematic to maintain old Java Stacks (TLS certificates no support for HTTP/2 etc.) with our current Java-push-library that gets more and more in conflict with dependencies as a library. Having just a central server with a (https://company.org/push?apikey=abc&amp;pushids=12,13,14) [post might be better ;P but you get the idea] sounds very appealing in the current state. We've fiddled something with python currently but we're not very happy with the solution. I might give it a try!
seanmonstar not ..ster Avoid typo when saying thank you. (Ça la fout mal. Sorry I'm not able to translate)
Maybe aa would be a better name for a battery included crates? ;-)
Our consumers for pushes are all Rust, and we easily get 3-4 month uptimes if there's no need for deployments. They don't really consume that much resources and are super fast. Some of our work is open-sourced, this crate is one of them and the others are [fcm](https://github.com/panicbit/fcm-rust) and [web-push](https://github.com/pimeys/rust-web-push). We route millions and millions of pushes to many customers every day without any trouble.
Given a `key_a: &amp;'a KeyA { owned_data}`, constructing a `KeyARef` should be as simple as `KeyARef { &amp;key_a.owned_data }`.
Thanks for the suggestion and links, I’m going to update the post
Just a heads up, all your links are hardlinked to the HTTP version of your site but GitHub redirects it to a HTTPS version, so none of your linked content is accessible and breaks your entire site. I recommend you use relative links so that it properly loads the content.
Is there a good way to list all binaries in $PATH? So the answers for [this bash question](https://unix.stackexchange.com/questions/120786/list-all-binaries-from-path), only in rust and platform independent.
Wow, this article needs proofreading.
Which docs are you reading? The stabilization PR also makes a number of doc changes. \(Both additions and corrections.\)
I obviously have not run into this problem at all, but I’ll look into it. The site is generated with pelican for python so I’m sure there’s a setting to play with
I guess what I'm unsure about is, if the key itself doesn't own `owned_data`, then who does?
Thanks, I upgraded this morning and it was mostly painless :\-\) I have two comments/questions: 1\) In the changelog, under "Breaking Changes" there is the following statement: &gt;Removed `Client::get`, since it needed to construct a `Request&lt;B&gt;` with an empty body. Just use `Client::request` instead. However, I still see `Client::get` in the documentation \(and it still seems to do the same thing\). 2\) In my original code I had the following line: let uri = &amp;format!("https://api.tvmaze.com/search/shows?q=\"{}\"", show); let uri = Uri::from_str(uri).chain_err(|| format!("Invalid URI [{}]", uri))?; After upgrading to hyper v0.12 this led to an error: Error: Unable to search for show ["breaking bad"] Caused by: Invalid URI [https://api.tvmaze.com/search/shows?q="breaking bad"] Caused by: invalid uri character After changing the first line to let uri = &amp;format!("https://api.tvmaze.com/search/shows?q=%22{}%22", show); it works.. Is this expected behaviour?
Did you consider to use [actix-web](https://actix.rs). you can easily combine rest and [websockets](https://actix.rs/docs/websockets/). 
You have both structs, `KeyA` and `KeyARef&lt;'a&gt;`. The `KeyA`s would own the data (and be presumably be stored in some data structure). Then, in places where you would normally use `&amp;'a KeyA`, you would instead use `KeyARef&lt;'a&gt;`.
This pretty neatly sums up my growing misgivings over some of the changes being proposed and added to the language. To reiterate something stated in the post: it's not so much any *one* change in isolation, but a growing feeling that the language's trajectory is changing. For me, this is worrying because there really aren't many languages *like* Rust that (seem to?) prioritise readability over writability (I realise that statement is quite vague). If I wanted a language for "Do What I Mean, Not What I Said" and going fast, I'd be using Python, C++, or (after enough therapy) D. Or, to be a bit more glib: after a long search, we've found a unicorn. We're a bit worried about all the people complaining that it doesn't look enough like a horse.
The nightly docs which state on functions that return `Result` things like on error they return `None`.
&gt; A change like this increases the language's surface area, and results *in aggregate* in more complexity to the language. One might argue that there's a sense in which `try fn` is a simplifying change: the body of the above function is shorter and simpler than it was without it. But this is only a *local* simplification: it streamlines the process of writing code by allowing a programmer to ignore some details about the semantics of their program, but those details are still present, they're just not *locally evident*, and instead are expressed as part of a larger context. A programmer who is reading code like this now has to be aware of *more* details of the code in question, as the meaning of an expression like `return 5` can only be resolved by looking at the *entire function definition*. And now there are extra inconsistencies and special cases in the language, which puts a greater burden on the programmer's mental model and introduces more cases to consider in an already large language. This sort of "drifting in a C++-ish direction" scent in the air is why I've made plans to research writing git hooks for refusing commits which use certain language features. (Though, ideally, rustfmt would have something equivalent to the "convert `try!` to `?` option to automate the stripping away of things like `try fn`.) &gt; If `try fn` is implemented in Rust, then my suspicion is that we'll see a whole swath of new Rust developers thinking the same thing here, that `try fn` is a special error-handling construct and not merely sugar for `Result`. This is my other major concern, more for the health of the community than for my own comfort.
I haven't been tracking the various error-related changes proposed too closely, simply because it's too much for me to keep up with. People comment way too frequently, and I know that if I register my skepticism now, it will just get lost. Or at least, it feels that way to me. Moreover, in order to even register my skepticism, I owe it to the people involved in that conversation to get all of the necessary context loaded up into my brain so that I can thoughtfully address the proposal. As a result of these naturally conflicting aspects of reality, I just don't comment. Perhaps I'm not the only one. My intent is to wait until these proposals turn into a serious language changing RFC, at which point, I can hopefully do the hard work of educating myself once and debate the issue. Assuming, of course, that the process of educating myself on the issue doesn't change my mind, which is certainly possible! (My goodness, I hope I haven't been so out of touch as to miss the fact that there is already an RFC, but my last recollection here is that folks are mostly just debating keywords at this point via the RFC process, in order to keep the design space open. I don't have a problem with that.)
What is the context? Does a physical arch exist? Where does it stand? Who will see it? When?
This seems related: https://hacks.mozilla.org/2018/06/babys-first-rustwebassembly-module-say-hi-to-jsconf-eu/
The physical arch is currently at JSConf EU. It may travel to more conferences in the future. I’m standing next to it right now :)
Do people have examples of features they feel this way about that have been accepted? I am interested how much this is just a property of discussions, which I consider fine to be relatively unfiltered, and how much actually affects the language in the end.
seeing 'size, align' as parameters for dealloc is awesome, does realloc need 'old_size' ?
But isn't that the typical outcome when you include everyone and listen to every opinion as part of your process? Software should be built by people who know what they are doing, not by majority vote.
I find it contradictory that the author's background is in Scheme and Haskell, but then praises Rust for its "hit-as-many-birds-with-one-stone" design choices. Rust is nowhere near that level of elegance in language design and it's a blatant lie to claim so. There are, however, very good reasons why Rust cannot achieve a certain level of design elegance as other languages without further research. I think the author is a bit too late with their worries, Rust is already much closer on the spectrum to C++-isms (one feature per use-case) than to Haskell or Scheme.
Thanks for the feedback! &lt;3 1. The `get` method was originally removed when that entry was added, and then later it was able to be added back by requiring the body type implement `Default`, and by then I'd forgotten about that older entry xD 2. Yes. The URI parsing in 0.11 was less thorough. 0.12 now uses the more complete parsing from the `http` crate, which detects that as an illegal character according to RFC7230. There's a new issue on `http` about adding a nice URI builder.
stupid cookie warning that blocks the article
I don't believe modern science has come up with a method that is better than majority vote.
&gt; Software should be built by people who know what they are doing, not by majority vote. I think this is somewhat unfair. To use a strawman: consider a JavaScript programming coming to Rust. They might look at Rust and feel excited by the prospect of a low-level language that won't blow their legs off if they make a mistake. Finally, something to help them get their foot in the proverbial door of systems programming! ... but it could stand to be more accessible and beginner-friendly. I mean, how could that be a bad thing? Making such an awesome language easier to use for more people just means more people are empowered. Have you *seen* how many people know JavaScript? Rust could probably benefit from a few design lessons from it's more widely-used big-broth*cough hack sputter* Sorry, started coughing up blood there for a second. My point is that the above hypothetical person isn't *wrong*, and doesn't "not know what they're doing", they're just coming at things from a very different perspective. They want Rust to be more like languages they're used to, so they can more readily benefit from it. I (and those like me) want the *exact opposite* because what I value in Rust is, in large part, *due to those very differences.* That's the bastard of it all, really. All any of us can really do is continue trying to argue for their perspective, whilst the core team desperately tries to find some local minima where everyone is equally (and hopefully minimally) annoyed at everyone else for "ruining" the language.
Well, I'm not particular for/against it, but I think that "\`impl Trait\` in arguments" probably counts. See the discussion in [https://github.com/rust\-lang/rfcs/pull/2444](https://github.com/rust-lang/rfcs/pull/2444), for example.
Rust is not developed by voting, majority or otherwise.
Hmmmm, really well said! Though I can’t say I’ve seen Rust mature throughout my entire usage of it (save for seeing the addition of a native WASM target, and the nifty scoping/nesting we have in `use` statements now) I can see, and furthermore appreciate, how Rust tries to give you the general toolsets and lets you fix what’d be “solved” by those special cases on your own volition. I never really looked at it that way until reading this, either.
That statement was rather general, that democracy is nice and all, but not when it comes to scientific or engineering work (where facts matter a tad bit more than emotions).
Sure, I just want to be clear. I reject the fact vs emotion dichotomy, personally. 
Thanks for that hint but this does not answer any questions I have :(
Does this mean that future versions of Rust will finally default to the system malloc, with jemalloc available as an option? IIRC, the main blicker for that change was lacking GlobalAllic.
copy vs borrowed vs move? I wish this was more explicit... Is there a document or an easy way to figure out when a variable is copied vs borrowed vs moved. For example I just learned, thanks to rust-beginners again, that the values from within a Vec are moed if you iterate over the Vec directly, but borrowed if you use .iter(). What are the other construct where this might not be obvious? Or where there is a way to make the construct behave differently like th e.iter()?
I absolutely agree with your points from a perspective of: "I feel empowered because using this programming language empowers me". Not so much the: "I feel empowered because I can leave a comment on an RFC that will help make the language easier for JavaScripters like me (however bad such a design decision would be) and now all the JavaScripters coming over will agree with me and leave thumbs-ups and hearts on it and it will get implemented!". Now I'm not saying that this extreme case is happening today, things are still somewhat in balance, but Rust is certainly going in that direction. Eg: the whole impl Trait thing where the team decided: "sorry we're not reverting what seems to be a feature/mistake, 2 days later, that barely anyone is using yet, because we believe in our discourse process"...? Seriously? Is the discourse process already proven to be perfect? Don't bad decisions slip through sometimes? Well apparently not. &gt; That's the bastard of it all, really. All any of us can really do is continue trying to argue for their perspective, whilst the core team desperately tries to find some local minima where everyone is equally (and hopefully minimally) annoyed at everyone else for "ruining" the language. They will end up not pleasing anyone and minimally annoying everyone. I'll personally just use Rust while the balance lasts and dump it when things get out of hand.
Completely agree. Async/await is another example of a bad special case.
I spent the morning trying to update from hyper 0.11 to 0.12.0 and unfortunately I've found it a *very* unpleasant experience. I've given up for now and have decided to use it as an opportunity to explore switching to actix\-web... I doubt this is the kind of story u/seanmonstar wants, so some hopefully constructive feedback: * I haven't followed v0.12's development at all, I was a happy user of 0.11, and 0.12 made huge changes to the API. These changes are often unmotivated, which leads to "why the \*\*\*\* did they remove/change this!?" thoughts while hitting issue after issue while upgrading, especially when a change makes what you're trying to do a whole lot harder. I'm sure there are good reasons for the changes, putting those reasons in the changelog would really help communicate them. Some changelog entries link to issues which do attempt to provide some motivation, but it's inconsistent. * On the subject of the changelog, it's woefully patchy. There are breaking changes that have been completely omitted \(for example, what the heck happened to the `mime` crate exposure?\). This is very frustrating. * A migration guide that lists each breaking change and what the recommended new way of doing the same thing is would be really, really helpful. * The hyper documentation says to check out the guides, but they seem to have lost most of their content, now they only cover the simpler cases. In the absence of a migration guide, my question was "well, OK, how am I supposed to write a stateful server now?". I originally learned how to do so with 0.11 using the guides, so I went there to check again, but there's nothing involving state in there any more. As it is, I'm feeling a bit fed up and will probably jump ship to actix\-web \(which has a lot more documentation and more examples, I'll note\), which isn't a good result. Maybe I'm an outlier and my spaghetti code was particularly unsuitable for a happy upgrade, but the points I've made above are all things that are generally applicable and could save a lot of people a lot of hours and frustration in the long run.
&gt; I don't believe modern science has come up with a method that is better than majority vote. Citation count is a majority vote only by someone doing something relevant in the field. In Rust, you don't ask people to show prior work before being able to leave comments on RFCs.
&gt; Another way of looking at this is that folks are just brainstorming at this point. I really like this description (the whole paragraph!) and wish more people could look at it that way. The huge amounts of discussion are often just people trying to shout each other down as though the outcome were a final irrevocable change to the language, and not a forum thread to gather ideas.
Man I just don't agree with the general sentiment. The outlined try syntax is crap, but the impetus to introduce language constructs to make *extremely* common expressions simpler is just how humans think about the languages they use; they develop shorthands for otherwise elaborate sentiments. I wonder if the macro system was totally done if there'd be any of these kinds of RFCs. Like, would impl trait even have been needed if you could do something like this: #[impl_return] fn produce_iter_static() -&gt; Iterator&lt;Item = u8&gt; PS: concerns about learner overhead are almost always misplaced. Syntax is the easy part of a language. Having semantics without corner cases is what is really important.
Very well put. I share the sentiment of not being able to keep up with all of the discourse threads, blog posts, or GitHub issues. What's important to remember is to trust the process and be objective. This is what has made Rust great so far.
At first blush this feels like a strawman. I've never heard of `try fn` or any bikeshedding regarding it. The fact that the author doesn't link to a discussion increases my skepticism. I don't see anything about it in the RFCs repo. We can't tell whether it's worth getting worked up about a change unless we have a chance to read the details, and see how the language team is reacting to it.
The problem is that one day they are brainstorming and the next day there is a stabilization PR. Like GlobalAlloc is being stabilized and I don’t even know when that actually went through RFC and I can’t even find a single source of truth about what’s concretely being stabilized.
Actually, the screen is a live recording of a html5 web page. You can use any html5 technique.
Aren't "share semantics" usually called "reference semantics"? I've never heard the former term before.
Science is all about democracy. Even in mathematical research scientific truth is collective emerging consensus.
I very much agree with this. There are a couple of factors which make the whole current direction problematic I think: * It is (I feel) a change in direction that's introduced bit-by-bit, so can't easily be discussed as a whole. It currently looks like: `?` implied `catch`, which became `try`, which will auto-wrap, which will imply `throw` to be able to fail as last expression, and `try` will also imply auto-wrapping in `fn`s. * There is a clash of philosophies happening, and part of the discussion is what should be idiomatic and of course what should be discouraged. It is tough when the things you love about Rust might become unidiomatic. I'd hate to see combinators like `map`, `and_then` and such become discouraged. * You can't say you prefer explicit over implicit anymore without it becoming a discussions about what "explicit" means. I might be wrong but I think at some point the community liked that principle. * RFCs are not a popularity contest, but large negative community reaction should still count for something. If a negative comment to an RFC gets a big amount of +1's, that should still count for something. I see this as a "community impact factor". I agree that blanket -1's aren't really helpful, but certainly +1's on criticisms seem important to me. * Discussions and decisions are hard to track. If `try` will auto-wrap its result will be decided in the tracking issue for `?`. And even with a pinned TWIR there's a lot of work to follow what's going on in RFCs. I still believe something like a bot posting RFC links here when they reach FCP:disposition-merge would be helpful. Thanks for putting this article together!
/u/frovlad - I have fixed a couple of bugs related to buffer sizes in the Rust transports. That said, there is a decimal bug in the Rust client that prevents proper interop with the C++ client. All other bugs should be in JIRA; let me know if you find others.
/u/McGradyDa - my apologies, I'm on vacation right now, so delayed in actually looking and responding to messages that need serious, focused thought :) As pointed out, the Rust Thrift implementation does not support HTTP. I was waiting until the Tokio ecosystem stabilized, along with hyper etc.
&gt; The problem is that one day they are brainstorming and the next day there is a stabilization PR. Sorry, but no. This is FUD. This is not how the stabilization process works. &gt; Like GlobalAlloc is being stabilized and I don’t even know when that actually went through RFC and I can’t even find a single source of truth about what’s concretely being stabilized. I agree that this is a problem, but it's definitely not the same problem as "one day they are brainstorming and the next day there is a stabilization PR."
I'm not sure just the RFCs are cutting it I'm afraid. For example: `try` functionality is discussed in the tracking issue for `?`, but the question if it will auto-wrap depends on and influences `throw` and `pass` keywords. If there's no way to `pass` a value as `Ok`, but you can early exit with `throw` it maybe better to auto-wrap, but with explicit `pass` it might be better if it didn't. And what if `try` is decided to be auto-wrapping in the tracking issue prior to that? Will that imply a need for `throw` and or `pass`? Can we even decide that not auto-wrapping and no additional control flow is a better path without considering the big picture? This is why it bothers me that all of these issues are discussed in isolation instead of as a whole. I believe the module and path discussions ended well because they were big picture discussions instead of individual changes. That's the level on which compromise works.
Presumably you heard about the global allocator stabilization from the two posts yesterday linking to this PR: https://github.com/rust-lang/rust/pull/51241 . The first link in that PR is to a comment on the tracking issue that lays out what is being stabilized: https://github.com/rust-lang/rust/issues/49668#issuecomment-393263510 .
I agree that it's a hard problem to solve. Communicating these sorts of ideas is really hard, and pushing for a higher level discussion on the topic might be a good idea. I also agree that the keyword discussion is hard to have, because it is invariably tangled with other issues and can certainly influence later designs. I think aturon has already done a great job handling this though from the things I've skimmed.
Or "double-a" :) 
I love that the article makes this sentence actually makes sense: &gt; Rust language manages to combine the semantic safety of C++ with the efficiency of Python, JavaScript, and Java. :)
Probably because there isn't a single point you can link to. There's the current `try fn` discussion on internals, there's withoutboats' prior pre-RFC about catching functions on internals, there's the current `async` methods discussion on internals, and there's prior discussions with language team members and affiliates on RFC discussions for `?` and `throw` and what have you. The big picture outlined in the post is definitely the direction we're heading in current as far it seems to me. There's lots of discussion on the little details, including some big picture discussions in the relevant RFCs and internals posts. But I certainly do appreciate big picture articles like these because I think we don't have enough of them.
&gt;Yes. The URI parsing in 0.11 was less thorough. 0.12 now uses the more complete parsing from the http crate, which detects that as an illegal character according to RFC7230. There's a new issue on http about adding a nice URI builder. So, what's the difference between a double quote and say a space? To my knowledge, both should be &amp;#37;\-encoded before sending the request. And yet, the above request \(with space in the query\*\) works. Until now I assumed that something behind the scenes in hyper would properly encode the URI before sending the request, but maybe I was mistaken?
It *is* explicit, if you check the API docs: - `fn into_iter(self) -&gt; ..`: - If the type implements `Copy`: copies. - If the type doesn't implement `Copy`: moves. - `fn iter(&amp;self)` immutable borrow - `fn iter_mut(&amp;mut self)` mutable borrow The lack of explicit borrows when calling methods is a concession to ergonomics. Having to write them out explicitly is *probably* on the far side of the "what people are willing to put up with" line.
&gt; Probably because there isn't a single point you can link to. But there is: the `try fn` thread I mentioned above. The fact that the OP doesn't link to it makes it feel as though the OP is deliberately trying to stir up a tempest in a teacup by misrepresenting the "direction" of Rust. In addition the OP doesn't mention anything about any other discussion other than the `try fn` thread, so the assertion that this refers to things like `async` is a stretch. If you have a problem with any of those discussions, then write blog posts talking about why you think they're bad. While you're at it, be sure to actually link to the official discussions so that people have a realistic interpretation of how likely any of them are to end up in Rust.
Notably, those are all internals threads of basically the same nature as the one kibwen described, or else tangential tossed-in comments on other RFCs. There are no relevant RFCs yet, and if/when someone writes one up it will become a single point you can link to. But even then it won't be any sort of "official direction of the language" because that's not what an RFC is.
Democracy by citation count, not by every human on the planet. Also ends up being corrected if proven wrong or undesired. Unlike Rust (see the drama around impl Trait).
&gt; `?` implied `catch`, which became `try`, which will auto-wrap, which will imply `throw` These were all introduced in [the same RFC](https://github.com/rust-lang/rfcs/blob/master/text/0243-trait-based-exception-handling.md), so the idea that it's some insidious gradual directional change is nonsense. The only thing gradual about it is the implementation work and experimentation that's been taking place for literally *years*. &gt; I'd hate to see combinators like `map`, `and_then` and such become discouraged. I have literally never seen any sign of this, even in brainstorming sessions. The idea that they would be discouraged sounds absurd to me. Part of the initial premise for this stuff all the way *back in 2014* was "how do we make error handling nicer while preserving errors-as-values."
** sad trombone **
so, are these two the same thing? for e in my_vec { for e in my_vec.into_iter() { 
The thing being iterated is *always* passed through `IntoIterator::into_iter`, so yes. As an aside, `my_vec.iter()` is just a convenience method that does the same thing as `(&amp;my_vec).into_iter`, which is why you can also write `for e in &amp;my_vec`.
Good point.
I'm interested in the author's thoughts about the *delegation* RFC ;)
There exists no method to determine prior work. You are advocating for person cult, listening to what specific people think.
FWIW, I really don't want this difference become something like a political fight, where people appear to be open and listening for political points but pushing things like an agenda. Rust has been the most loved language for already three years. We have had great momentum building both the language and the community. This is built on trust and openness. Sometimes there can be heated discussion, but people are open, and people really mean what they say. It will be the saddest thing if this is lost. I don't want to see that happen.
Sorry it's roughly the same thing. Democratic consensus within a community. Just like in science in rust some people have more clout merely due to the reputation of their previous work.
Thanks.
FYI `imp Trait` could not be done in a macro as you suggest. It allows returning un-nameable types (e.g.closures) and that has to be handled at a language level. I do agree that once `macros 2.0` arrives a whole slew of new capabilities and idioms are likely to appear.
One small and mostly inconsequential critique: It took this non-native english speaker more reads than he'd care to admit before recognizing the latin in the title. On a more serious note, congratulations on the release, the introduction makes it look quite interesting. Are you currently using it in any production project? Is only Java in scope or are other JVM languages open for consideration?
The less magic, the better. Prefer correctness over comfort. I hate implicitness and ergonomics for that reason. The auto-deref matching stuff as mentioned by others on this thread is, to me, a very wrong idea, as it adds more magic to the language (and remember, magic is bad, because you use a specific case of the compiler that bypasses the general rules, and we like rules). I’m completely okay to have ergonomics that make sense, such as the `?` operator for instance, but implicit crazy ideas just for the sake of people coming from weakly-typed languages is a just a very, very bad excuse to me. So my opinion would be: implicit coercions, implicit behaviors or implicit whatever should be avoided as much as possible. I’d rather type an extra `&amp;` or `ref` when destructuring something rather than relying on some magic internal `rustc` code.
The massive success of C can be partly attributed to how small and compact the language is. Rust, obviously, can't aim to be that small, but it doesn't have to have the same exponential feature creep that plagues other languages. I completely agree with you, and add that large sacrifices seem to made for small returns. Is slightly verbose error handling such a pain it requires all this to fix? What's wrong with extended a smaller language with libraries?
As the author of the latest `try fn` [proposal](https://internals.rust-lang.org/t/pre-rfc-flexible-try-fn/7564) I would like to say that my main intent was to discuss proposal to to make`Try` trait more flexible in the framework of previous `try` proposals (i.e. if those proposals get shot down my pre-rfc can be simply forgotten). I didn't want not to re-iterate discussion on `try fn`, which was already quite extensive in the original boats [proposal](https://internals.rust-lang.org/t/pre-rfc-catching-functions/6505). So yeah, for me it was just an idea to discuss and brainstorm, but the thread ended figuratively speaking in "battle to the death for the future of Rust", which let's say was not fun... It looks like the current trio of github RFC threads+internals+IRC shows its limits more and more, but it's not easy to design and implement an alternative. Some thoughts on how it can look: - Formally define work-flow of brainstorm idea to a full RFC (maybe with 3-4 steps) - Structure discussions under several theme umbrellas with an ability to subscribe to different proposal levels for different umbrellas (so e.g. you'll not get notified for every idea for umbrella you are not interested) - Maybe even define trees of proposals, to better visualize dependency between them. - Limit RFCs reviews by "pros"/"cons" format with an ability to "vote" for reviews to voice support and make good reviews more visible. - Move forum-like discussions into sub-threads for every review. - Implement a page on which active RFCs, FCP RFCs, merged RFCs, implemented RFCs and stabilized RFCs will be displayed and intent to change the status. (with an ability to subscribe to changes in which you are interested)
&gt; Take by value That doesn’t really exist in Rust. You have several ways to _pass things_ in Rust: - By copy (i.e. you pass a value directly, and the type of this value implements `Copy`). - By move (i.e. you pass a value directly and it gets memmoved, which is roughly the same thing as a _by copy_ passing, but you move the ownership instead of duplicating it. Also, some optimizations might just do nothing). - By borrow (i.e. you pass a reference or mutable reference to your value, which is akin to passing a pointer / an address). So for instance, if you move a `Vec&lt;_&gt;`, the cost will always be the same and `O(1)`, because it’s basically just copying three `usize`. So you shouldn’t really concern yourself with such tradeoffs, but more about how you want your design to be modeled. Moving around `Vec&lt;_&gt;` can be perfectly okay if it’s the purpose of your functions. Also, don’t forget that if you do something like: ``` fn foo(mut x: Bidule) -&gt; Thing ``` If `Bidule` implements `Drop`, don’t forget that some code will run, which wouldn’t be the case with a `&amp;mut Bidule`.
No, you don't get an actual reference. The litmus test here is whether you can implement an argswap function: swap(a, b); * With pure value semantics, you can swap neither the bindings nor their contents (assuming the parameters are structs or arrays). * With reference semantics, you can swap the input objects, C++'s references (`T &amp;name`) or languages with "inout"/"ref" parameters allow that. * With share semantics, you can't swap the input objects but you can swap their contents, that's how languages like Python or Java (object types) work. Technically it's call-by-value with all values being pointers, but that's not really helpful. I guess TFA got "share semantics" from CLU, which called it *call by sharing*.
The author is using that combo to make a game. I played around with it a little bit, but using glium instead of vulkano. I'm not sure where that code went... My impression is that it's the smallest thing that works and you'll probably want to make abstractions on top of it. Wish I could be more helpful.
That's true.
&gt; There exists no method to determine prior work. Sorry, what? Published papers, how cited they are, how respected their findings are, for rust, their Github account might be a good source: "oh you have that fancy idea? show us a prototype". &gt; You are advocating for person cult, listening to what specific people think. Person what now? I'm advocating to listen to people who know what they are talking about and have some history in the field, and avoid having to listen (or hear) every passer by's opinion on some matter.
As others have suggested, the right approach is probably to carry around a `Box` of or reference to the key in the structs. If you want a reference, you need to annotate the structs with a lifetime. Here's a [thing](http://play.rust-lang.org/?gist=bbc11f58db4c2e2519d8db59a01845f4). Not sure it's a good thing or a useful thing. But it's definitely a thing.
If it's implemented as a macro though I can't see it being particularly harmful.
That's not happening in this stabilization, but will probably be a follow up. There's some weirdness that needs to be figured out around the compiler being dynamically linked: [https://github.com/rust\-lang/rust/issues/36963](https://github.com/rust-lang/rust/issues/36963)
&gt; The fact that the OP doesn't link to it makes it feel as though the OP is deliberately trying to stir up a tempest in a teacup by misrepresenting the "direction" of Rust. Wow. Coming from a mod no less. If that's okay behavior, I guess I can use some strong language in this comment. OP's example might have not been the best, but it's not hard to find examples that support the theme of his blog. Besides shoving *exceptions* down the language's throat (while carefully not calling them exceptions), my favorite example is actually the delegation RFC. That one is way past *the brainstorming stage*.
It's not the experience I hope for, no, but I do greatly appreciate the feedback! Sorry for the unfun time. If you can remember any points that were missing from the changelog, I can update it. A migration guide is probably a good idea too. 
Like there exiaste don truth? :D You would need an arbitrator over what is right and wrong, and now you are in a person cult.
There exists no measure to see if people know what they are talking about. The only measure for fairness is democratic election.
\&gt; and has been heavily tuned for performance in single\-threaded C code with few small allocations. There appears to be zero performance difference between jemalloc and glibc 2.27 in rustc from at least one anecdotal case: [https://github.com/rust\-lang/rust/issues/36963#issuecomment\-393726994](https://github.com/rust-lang/rust/issues/36963#issuecomment-393726994).
What would that deprecation period look like? Injecting a warning into every single binary crate that doesn't pick a global allocator?
\&gt; Also, it seems pretty ugly if down the road most crates in the ecosystem start by overriding the default allocator with a well\-known common replacement. I would expect roughly the same proportion of Rust\-based binaries to pick a custom global allocator as C\-based binaries.
Hm, I *think* a space is also illegal, since parsers will assume request lines are `method SP uri SP version`. Want to file an issue on the http crate?
Oh come on. We can't draw that sort of conclusion just because there isn't a link. I don't think the OP was made in bad taste.
OK, I think I understand. Now I've played around a bit with this, and while I can write a function that converts `&amp;'a KeyA` into `KeyARef&lt;'a&gt;`, I can't seem to write `impl&lt;'a&gt; Borrow&lt;KeyA&gt; for KeyARef&lt;'a&gt;` because that must return a `&amp;KeyARef&lt;'a&gt;`. Is that possible?
The general case is monads, but after writing Rust for three years it is extremely obvious that async/await is a blocker on the ecosystem evolving to be competitive. I'm not going to wait until 2021 for a stable design to evolve just because it's more conceptually elegant :( 
Pointing out arguments that stem from bad faith is one of my primary duties as a moderator. Your own comment exhibits the same property, by asserting vague concerns without backing them up with anything to substantiate the severity of the concern: what "delegation RFC"? The only one that I've ever heard of was this one from last year, that was closed and appears to have never had a successor: https://github.com/rust-lang/rfcs/pull/1406 . To get worked up regarding the future direction of the language based only on internals threads is unfounded.
You and I traffic in different internet circles. :) I'm from less civilized realms, where this is a common tactic for pushing an agenda. Whether or not the OP intended it, the effect is indistinguishable from FUD.
**1**: Not sure how to do it with a specific rust library, but you can use bearer authentication by adding the access token to the websocket url when initiating the upgrade request. [See here.](https://stackoverflow.com/questions/22383089/is-it-possible-to-use-bearer-authentication-for-websocket-upgrade-requests) **2**: If you use bearer authentication, you should be able to associate client sessions with the auth token. I don't have good answers for the other questions.
`impl Trait` in argument position foreshadows a problem Rust didn't have before, the complexity of introducing multiple interdependent language features. In the older days, questions like "how do you make coherence work for specialization?" weren't important to developers, since specialization was the goal and its interaction with the rest of the language was a technical detail to figure out. Now new features like `catch {...}` can impact the evolution of other new language features, `impl Trait` in return position naturally may beget `impl Trait` in arg position, with an exponential complexity in bikeshedding and features to keep track of. What I don't agree with is that the design for any of these features is broken. Every RFC is debated publicly and painfully scrutinized for how it works with the rest of the language. But developers want to be able to see new feature sets as a coherent deliverable (like Rust 2018), while it's more natural to develop them sequentially (building on top of earlier features, which may be contentious at first introduction). But before `impl Trait`, the last contentious addition to stable I remember was the debate between int/uint and isize/usize. I think it's worth getting us ready for the problem: introduction of many new features simultaneously changing how all developers write and read code. But I think suggesting the process has failed beyond select cases like `impl Trait` is disingenuous, and the OP isn't fairly representing the process at all.
I reject that. We should assume good intent unless there is solid evidence otherwise. Especially in an environment as nice as Rust's.
Maybe you should step aside, or at least refrain from conspiracy accusations, if you don't even know [the RFCs that are being actively discussed](https://github.com/rust-lang/rfcs/pull/2393).
Seems to be working fine on Firefox 60.0.1 on macOS for me, at the time of writing. What browser version and platform are you using? I suspect a caching issue.
The [**`ref-cast`**](https://github.com/dtolnay/ref-cast) crate makes it possible to do these ref to ref conversions using safe code. // [dependencies] // ref-cast = "0.2" #[macro_use] extern crate ref_cast; use ref_cast::RefCast; #[derive(RefCast)] #[repr(C)] struct KeyA { h: String } #[derive(RefCast)] #[repr(C)] struct KeyB { h: String } fn a_to_b(a: KeyA) -&gt; KeyB { KeyB { h: a.h } } fn a_ref_to_b_ref(a: &amp;KeyA) -&gt; &amp;KeyB { KeyB::ref_cast(&amp;a.h) } 
Thanks, will do.
Would it have been so hard to link that the first time? :P And this only demonstrates that this whole thing is overblown: rather than being "way past" brainstorming, it is an RFC that has been open less than a month, written by someone who is not on any Rust team and has never submitted an RFC before, is not in a final comment period, does not appear to have been discussed during a lang team meeting, and the only comments from lang team members (eddyb and scottmcm) seem negative or neutral. If you have problems with the RFC, then leave comments. Otherwise, I'm not sure what you're worried about?
Huh. I did not realize files in `/sys` supported seeking. Today I learned. Thanks for showing me what you are up to.
Ah yes, I got a lot of people ribbing me on that in the other subreddits too :\-\). Also, thank you so much for the kind words! I was rather apprehensive at posting it here, but it looks all good now! I started this primarily because compared to the ease of tools like Cargo, Maven \(and even Gradle\) in Java\-world are literally a nightmare to use. In fact, while this started out purely as an educational exercise \(as can also be seen by the less\-than\-maximally\-efficient code\), being able to bootstrap the project in itself was a great source of pleasure! If enough people start to contribute, this could very well be made into a production\-worthy endeavour. As it stands now though, it is very much far from production quality! Also, it is currently only for Java code \(since I am using the JDK's compiler APIs\). In my estimation, plugging in support for another JVM language would be a substantial \(but not too much\) undertaking. If the JVM languages exposes compilation APIs, that would be even easier, or maybe even use the language\-support in GraalVM \(a consideration for future releases\). Overall, it was a fun exercise, but I also realised the complexity of something like Maven \(since the project depends on Maven repos as an analogue of [crates.io](https://crates.io) for Rust\) when you dig in far enough, but I will wait and see how many \(or if any\) people willing to help out \- who knows, it may become a viable option in the future! :\-\)
It's possible. But like I say, the allocator in `libc` is pretty well-tuned for C programs. So it may be different.
&gt; Do people have examples of features they feel this way about that have been accepted? `match_default_bindings`, which lets you match `&amp;Option&lt;T&gt;` with a pattern like `Some(x)` without writing the matching `&amp;` in the pattern. I wish that had never gone in, and I certainly don't want it extended even further.
So you didn't even CTRL-f "lang team". I have nothing to add at this point.
You're committing the honest mistake of believing that niceness alone is sufficient to create and sustain nice environments. Another necessary ingredient is taking a firm hand toward people acting in bad faith, even if they do so nicely. I'm reminded of this relevant tweet I saw today: https://twitter.com/yonatanzunger/status/1002822761037754369 . I'm happy that so many people think that /r/rust is a nice environment. I think a lot of people don't realize how much hard and not-nice work we have done behind the scenes for the past six years towards that goal. I'm happy that you're being nice to people, and I encourage you to continue. But Reddit at large is a more hostile environment at most, and I'd rather be the one being accused of a lack of niceness than any of our regular users.
From context, I think the closest translation would be faux pas. It's one of those French phrases that snuck their way into English, and may in fact be an exact translation of what you were trying to say.
I think we shouldn't think of threads like that as the only solution as in the only idea that will appear. In reality, a lot of projects are cancelled after a short or rather long period. What is left is something that can actually survive because it has outlived already the majority of projects. Of course this doesn't mean it's going to be perfect, just that it works kind of. Maybe the thought of only one truth should be abondened just like many proposals were declined or abondened in Rust.
No, I didn't. Funny how we could have avoided all this if you would simply spell out your concerns rather than handwaving at bogeymen. :)
Why is the "This week in Rust" now being pinned instead of the old about work in progress? I find it easier to find this week in rust than what have you been working on this week.
These are great observations and ideas! I'd love to talk with you in some more depth about this -- shoot me an email at aturon@mozilla.com?
I'll file an issue about it if I go back for another attempt.
If your evidence of bad faith is only missing the link out then that really isn't solid. You're assuming a lot, based on not a lot at all.
I'm using version: 62.0a1 (2018-06-02) (64-bit)
&gt; All any of us can really do is continue trying to argue for their perspective, whilst the core team desperately tries to find some local minima where everyone is equally (and hopefully minimally) annoyed at everyone else for "ruining" the language. Just want to push back on that last -- that's a kind of design-by-committee pathology that we actively try to avoid. The Core Team (and other teams) are *the keepers of the vision*, and a big part of their responsibility is to look at the big picture and ensure coherence.
Thanks for the link! We have a report of greatly improved `jemalloc` performance in this thread, so apparently it varies depending on the program. The case that interests me is frequent small allocations and frees of varying sizes. I expect this to be the case in a lot of Rust, and a lot less in C. I don't know about C++ so much. I found this great [overview](https://sourceware.org/glibc/wiki/MallocInternals) of `glibc` `malloc`. It is interesting to read it and think about how the implementation matches Rust's use case and what could be changed/improved in a Rust-targeted allocator.
Monads aren't more conceptually elegant in Rust, where they break the usual control flow mechanisms and would require some way to abstract across both traits (Future, Iterator) and type constructors (Option, Result).
Allocation patterns in Rust are not all that different from C, and are even more similar to C\+\+. jemalloc isn't some magic library, it's just the FreeBSD libc general purpose allocator.
Good luck with this. Please let us know if/when you get a git repo up for this.
This is a naive viewpoint. In any matter, the are degrees of stakeholdership. Complete non-stakeholders should have no weight in any vote. We shouldn't ask a child's opinion on climate change. We shouldn't ask a junior developer's opinion on error handling. The difficulty is and always has been that there's no singular obvious and fair way to assess stakeholdership.... But that doesn't mean it didn't exist or isn't important.
If my objections were stronger, then it's safe to assume that I would have used any of the other tools available to me as a moderator. Instead, I left a third-level comment. As to only missing a link, I operate under the assumption that extraordinary proof requires extraordinary evidence. When the author says that they are "dismayed by the current direction of Rust", I expect evidence of "the current direction of Rust" such as a hastily-stabilized feature, or an unclear feature that is in FCP, or an RFC that appears to be being pushed through by official team members over community objections, or something of that sort. A lone internals bikeshedding thread does not qualify. If the link had been there, then it would have been immediately obvious that the fundamental assertion of the blog post is unfounded. I get that there are people in here who are still fuming over `impl Trait` in argument position. I'm not particularly attached to it myself! Likewise I get that people are unclear over what's going to happen with the long-debated `catch` feature, but it's worth pointing out that it's unclear to the developers as well, and I don't know of any action towards that direction. Years ago I felt the exact same way about Rust development, when I reached a point where it felt like I could no longer keep a full handle on what was happening and RFCs that I heavily disagreed with were proceeding apace (I remember my breaking point came when fixed-length array syntax became `[foo; 5]`). I have been in this position, where I was used to the language and I felt like it was perfect and I was worried because in my mind I was extrapolating trajectories that would lead to ultimate failure. But in the long run it turned out my fears were unnecessary and that the checks upon the design process served their duty of keeping things from spiraling out of control. Nowadays I trust in the good taste of the Rust team, which *doesn't* mean that I don't feel the need to participate (I'm not asking people to stop participating entirely, god no! we need that!), but only that if I participate reasonably then ultimately things will work out just fine.
IIRC that was decided to make changes to Rust language more visible - TWiR lists updates to the compiler, RFC status, new RFCs. So now they pin "What's everyone working on" on monday, and after a few days change it to TWiR.
https://hacks.mozilla.org/2018/06/babys-first-rustwebassembly-module-say-hi-to-jsconf-eu/ 
I wonder if maybe brainstorming should just be tagged as such, rather than as pre-RFC. RFC is of course a *Request For Comment*, which initially seems valid, however: - as a matter of fact RFCs are very much 1-vs-N, with the author putting in the work of aggregating everyone else's comments, - RFC being used in "official" channels may indeed sound too official; they have that "it's about the happen" feel, which seem to "close" the discussion. Brainstorming, on the other hand, is often more chaotic. A theme/direction need be defined, or maybe a "root" (what can we build on top of that) or a "problem" (how do we solve this?). I think a forum post could work for brainstorming, as forums are for discussing after all, but that it should be labelled as such. More dynamic venues could also be better, to encourage "rebounding" off others' comments.
Which delegation RFC?
https://github.com/rust-lang/rfcs/pull/2393
Totally agree.
As a sometimes user of this crate, thanks much for your work on it!
Apparently they do. Have a nice day!
I won't get to into the weeds about this, but &gt;if I participate reasonably in the process then ultimately things will work out just fine Quite a few people don't feel the same way. I don't think many people will disagree that RFCs and the comments are very difficult to keep track of for most people. After the recent impl stuff (which the argument position version does seem like a "special case") it's not unreasonable to be concerned about both the language itself and the way new features are introduced. When I read the post I saw it much more as a general talk about not having special cases in languages, with the try fn as a particular example, than trying to rile people up. You seem to be reading it with a lot less charity
Ok that makes sense. Thanks!
I didn't know that crate existed! Cool!
Hum... ... I've got mixed feeling about this. On the one hand, easier delegation would certainly be *nice*. At the moment, forwarding everything is both error-prone and painful. On the other hand, not a fan of `delegate *`: impl PartialEq + PartialOrd + Ord for PackageId { delegate * to self.f; } It could possibly work for those well-known traits, but otherwise it is going to require really good IDE support to figure out where a method comes from... and I'd rather the language did not REQUIRE IDE support for being approachable. In the particular case of often `derive` traits, I think `derive` should simply accept a field name and delegate to it.
Cool, a user! What have you used it for, if I may so inquire?
&gt; You're committing the honest mistake of believing that niceness alone is sufficient to create and sustain nice environments I assure you that I'm not.
In the context of this discussion, the problem with this RFC is that it is introducing language changes for a *special case*. While the sensible solution is to solve this generally using meta programming, maybe with non-special-case help from the language (e.g. the long-postponed [fields-in-traits RFC](https://github.com/rust-lang/rfcs/pull/1546)).
Hey /u/aturon, if you are taking ideas, I had a random shower-thought: The number of humans the Rust teams need to recruit and retain scales in relation to the number of RFCs / discourse which occurs. The number of RFCs / discourse which occurs scales in relation to the number of Rust users. The number of Rust users is growing and ideally growing fast. While Rust needs to improve the RFC process to optimize for "discussing and deciding on RFCs", this does incentivize more structured discourse requiring more moderation (i.e. more humans needed). Today the plan is to recruit more people, and that should continue. But, ideally, Rust should also optimize for "reduce the need for future RFCs". This mental model doesn't seem to exist today, but seems necessary to continue scaling as the number of Rust users grows, potentially exponentially. One (possibly poor) example of "reducing the need for future RFCs": Empowering users to experiment with syntax in their own crates, by writing Babeljs like [syntax plugins](https://babeljs.io/docs/plugins/#syntax-plugins) \(i.e. more powerful macros\). These plugins should be shared by cargo, and like other crates the ecosystem can vote and experiment outside of rustc, with a path through the nursery to become a part of core. While this does create possibly infinite dialects of Rust, they would be crate local, and so should be all about personal preference, similar to how code style can differ. If a library uses obscure, possibly poorly documented, plugins, that is a calculated tradeoff between ergonomics for the current maintainers and acquiring new maintainers (for learnability reasons and such). The benefits are that the majority of these syntax sugar requests would no longer show up as RFCs to rustc, and the compiler teams could focus on more important features and discussions. And yes, there are pain-points with the Javascript ecosystem and how much variability there can be, but it is inarguably the fastest growing/evolving language ecosystem that has ever existed. Perhaps it is a calculated tradeoff that is worth the pain?
Well, the only *legit* use I can remember was for a funny algorithm I built for a sorting-like problem that required extracting from opposite ends into both ends of the underlying array in place. Although I actually can't remember if I ended up with Python or Rust: it was in an algorithms class I was teaching, so probably the former so the students could follow it. Honestly, I mostly just use this crate when I want a min-heap. The hard-wiring of `std::collections::BinaryHeap` as a max-heap can be a bit annoying.
These match patterns could before only be written one way, with tons of line noise dealing with (de)referencing that didn't affect anything. I do agree explicitness trumps readability at some point, but not here. If anything, it seems _less_ magical than deref coercions at callsites or lifetime elision. Removing line noise that contributes nothing (because the behavior is unambiguous) makes it easier to write _and_ read the code IMO.
Off-topic but the shortening of "return" to "ret" doesn't save you anything. The majority of time programming isn't spent typing. Things like this just make the language more cryptic and harder to use.
Is that fix landed into master branch? Rust server from master branch \(88591e32e710a0524327153c8b629d5b461e35e0\) crashes with: "fatal runtime error: allocator memory exhausted" with any non\-Rust client \(Python, Node.js, C\+\+, C\) \- it seems it is related to my incorrect use of transports \(all of those clients use TBufferedTransport, but Rust expects TFramedTransport\), still it should not crash, and when I switch Rust to TBufferedTransport, the clients just simply cannot connect \(ERROR: failed to read 4 bytes \- Success / ERROR: No more data to read.\) BTW, using C server with TFramedTransport I also observe a crash when I try to connect from a TBufferedTransport client. Is this an expected behavior? Looks odd to me.
&gt;&gt; if I participate reasonably in the process then ultimately things will work out just fine &gt; &gt; Quite a few people don't feel the same way. I don't think many people will disagree that RFCs and the comments are very difficult to keep track of for most people. The questions to ask then are: why don't these people feel that way? What specific actions have happened to make them believe that participation has been unreasonably ignored (someone's comments are always going to get ignored; there are always tradeoffs, and making everyone happy isn't possible)? What could the official teams be doing better? What measures could be adopted to make people feel more secure about the design process? For example, recently someone who said they were worried about missing FCP announcements suggested that we sticky TWiR here on the subreddit. [I agreed](https://www.reddit.com/r/rust/comments/8ldh0q/regarding_visibility_of_rfcs/dzfdapb/, and now we have both a new mod on /r/rust and a new ongoing process that benefits people who want to stay abreast of developments. That's an example of a productive step forward, because it began from a concrete position ("RFCs should be more visible to people who only read reddit") and was motivated by a genuine example (impl Trait). In contrast, the blog post here begins from a position of "special cases are bad" (which is more controversial than the author seems to believe, I can think of plenty of justified special cases in Rust that people are happy with), and is then motivated by an example that stems not from the Rust developers, but from an unrelated third party. That's a less-than-great way to begin a discussion that leads to real progress, and I called it out in an effort to prevent this post from serving as an example for others in the future (whether that be from the same author or otherwise). If we can manage to produce some actionable items from the discussion here, then great! But I'm interested in improving Rust-related blog posts in general, and if this should happen to become a recurring theme then I'm going to start considering a rule against sky-is-falling blog posts.
The from one day to another was an hyperbole, but for someone that reads about this stuff once a month I kind of feel like either you ride the wave where changes happen every day (and if you are in the wrong time zone you might miss half of it) or it is a daunting amount of work to catch up and the next time you catch up is when everything has been baked and decided already.
Thanks for the feedback! `stdweb` is genuinely awesome and I think it's really neat, but its aims seem to me to be pretty different, and frankly much broader, than those of `wasm-bindgen` and `wasm-pack`. The ones I covered here are, I think, the ones that make the most sense for the broadest set of use cases. And `wasm-bindgen` is definitely the one I'd go to (and indeed that Alex Crichton and Yehuda Katz *did* go to) for e.g. the work we're doing on the Glimmer.js VM in the browser, and that I've started using for work in the Node context. None of that is in any way a knock on `stdweb`. It's just that *for the specific kinds of things I wanted to talk about*, the ones I mentioned are better fits. I may at some point come back around and talk about stdweb, yew, etc. – the pieces of the wasm ecosystem which are in my opinion both more ambitious and also therefore less mainstream *for today*.
This seems to be exactly what he has...?
lol yeah I'm an idiot
I'd recommend just using the same old mechanism of having main-shim printing manually like ``` fn main() { match main_inner() { Ok(()) =&gt; (), Err(e) =&gt; { eprintln!("{}", e); std::process::exit(1); } } } ``` It's still a shim like you have, but it's cleaner than making a whole new error type just to use the "quick-and-dirty" main error handling. If you want to display good error messages, they way to do that is still to print them out. `fn main() -&gt; Result` is very much meant for prototyping where the format doesn't matter. --- Sidenote: once https://doc.rust-lang.org/std/process/struct.ExitCode.html is stable, we'll be able to do something a bit nicer like ``` fn main() -&gt; ExitCode { match main_inner() { Ok(()) =&gt; ExitCode::SUCCESS, Err(e) =&gt; { eprintln!("{}", e); ExitCode::FAILURE } } }
And old align but for some reason it doesn’t need the new align :/
Yes. The fix is on the master branch. This one looks different. Could you file a JIRA please? I’ll take a look at it when I’m back from vacation.
To reiterate a point I've made elsewhere about this: those aren't noise, they're *signal*. The type system matters. I *want* the compiler ensuring that I can't accidentally mix `T` and `&amp;T`, just as it ensures I can't accidentally mix `u64` and `i16`.
\&gt; naturally may beget impl Trait in arg position, with an exponential complexity in bikeshedding and features to keep track of. I thought \`impl Trait\` in arg position was already accepted?
Most people's opinions on most things are entirely irrelevant - they are not experts, don't know what they are doing, will largely attempt just to represent their own interests and those of people like them, and will rightly get completely ignored, railroaded and steamrollered by those who actually know what's going on. They don't and shouldn't get a vote, ever.
I like rust and wanted to do something with it, and seeing how Rust is often compared to C++ got me thinking about making a renderer in Rust since ray tracing is CPU bound. I did some work with Nori and PBRT, and I like how well designed and extensible they are, and am hoping to create something that will be usable academically and also brings greater visibility to Rust as a language viable for graphics. Part of my motivation is also I hate C++ dependency management and had a lot of memory errors when working with Nori. 
Any object that implements Drop is essentially a context manager. There might be some edge cases in case of panics and `mem::forget` though.
Panics do definitely execute \`Drop::drop\`, with the exception of double\-panics \(panics within \`Drop\` implementations\), which abort the process.
I have that book and I've already read your blog post! \(both are great\). I haven't had the time to implement the basic ray tracer yet, but it's probably the first thing I'll start with. I know for a fact that I will need efficient matrix multiplication for transformation matrices to move between coordinate systems, and I'd rather not roll that out on my own because I know there are other libraries that can do it much better than I.
I was one of the students in this class I definitely recommend it! 
Don't forget that you can write `panic = abort` into the Cargo.toml to make any panic abort immediately.
Exactly, but there is not other way than democracy to decide what is right.
Ah right, there's also that. 
I try to use words like "exploration" or "experiment" in the title of any posts I make about brainstorming.
This is a really well-thought-out and well-written series. Thanks for taking it on.
Thanks! Yeah rolling my own math library is mostly because it's something I wanted to do. I've used cgmath in the past, it does the job although I wasn't entirely happy with the ergonomics of it which is one of the reasons I was experimenting with my own lib.
That's definitely fair, yes.
Ah gotcha. Yeah it's tough because with the math libraries there are a lot of performance considerations at play, and it seems like part of the way cgmath is designed is a result of optimization constraints.
Huh, I run nightly and was looking at the hyper docs just yesterday. Could you link the specific page? Also what OS are you on? 
Well, if you use `os.abort()` in Python context managers won't `__exit__()` either.
I'm not convinced that just because something is a signal that it should be written in the code. Signals can be redundant and hard to parse. If we were to follow explicitness religiously, we would have no inference logic and the language would be unbearable. There's _some_ kind of tradeoff, but I don't see yet what's fundamentally different about the default binding rules. If you have a function `fn foo(&amp;str) { }` and nested pointers and containers like `let bar = Rc::new(Box::new(String::new("hi")));` that you want to pass to it, would you really want to pass `foo(&amp;***bar)`in order to signal to the reader how we're dereferencing to get the `&amp;str`? There's a deterministic and unambiguous path that the deref coercion rules take when the outer value is a reference, so the reader isn't learning anything new from this. If anything, knowing those rules and not asking the reader to map `&amp;***` against intuitive dereferencing logic is better for readability. Match ergonomics is not allowing you to mix `T` and `&amp;T` any more than you could before; it's choosing the only legal interpretation of your pattern match that is possible. The signal before was useless because in order to understand what the pattern match was doing you still needed to know the type anyway, just like with deref coercion logic. Now, if you know the type, you know the binding mode without any noisy symbols in your pattern. The compiler is not guessing what you mean and the reader doesn't have to either. And you can still supply the intended binding modes of all the variables anyway if you really want to convince yourself via compiler errors, just like with type inference! The only difference is that this is the first time (AFAIK) that this kind of inference has been applied to patterns and binding modes. Is there any reason to be more worried about implicitness there than in the remainder of the inference/coercion/elision logic throughout the language?
62.0a1 (2018-06-02) (64-bit) on macOS here. No issues with that page.
&gt; In the particular case of often derive traits, I think derive should simply accept a field name and delegate to it. Thats a slick idea. While its more work (every marcro would have to support it), it puts control of how delegation works in the hands of the derive author.
Cool, hadn't heard of Nori or http://graphics.stanford.edu/papers/veach_thesis/ Yeah I did some C++ years ago and am learning Rust now mainly for graphics programming. Part of the decision to choose Rust over C++ was definitely dependency management, along with header files and lack of modules. C++ may get there someday but it's years away, and Rust just has a nicer type system anyway IMO. Looking forward to your post. 
There will always be a contingent of people who blame some sort of agenda for things not going their way, and yeah, it's obnoxious and doesn't foster a healthy community. That said, there's a history of communities weaponizing CoCs to settle personal scores or otherwise being enforced arbitrarily, so a reflexive distrust isn't unwarranted. If we're talking about listening and trust, it would be nice to hear that acknowledged. It's important to mention, however, that rust leadership has avoided any of these controversies, so kudos to them for reasonable enforcement. I can only assume this is why you don't hear people complaining too much about the code of conduct within the rust community. I think we need to focus less on the dogma surrounding CoCs and more on whether or not they're being enforced fairly. &gt;This is why I feel distraught when I see accusations of bad faith, of the teams having an “agenda” and the “listening” done in the RFC process being a charade to avoid revolt. Or the sense of “luckily enough of us yelled to stop the terrifying original proposal from happening; the moment we stop speaking up, Those People will start pushing in that direction again”. All of these sentiments come from a place of distrust, a zero-sum power-focused framing, with a dose of tribalism to boot. This is spot on, but I wish we applied this thinking more liberally. There is a spectrum of discourse, ranging from Torvalds-esque flaming to sugar-coated, emoji filled pandering that ultimately feel patronizing. Somewhere within this spectrum is a window representing healthy discourse, but even healthy discourse can be interpreted poorly, especially if it involves disagreement. We should try to, as a community, not assume bad faith or an agenda, especially as it relates to exclusion. Part of being part of a community and taking part of these discussions is disagreement, and people disagreeing with you never feels particularly good, no matter how reasonably it's stated.
Either way compiler should remove dead code for you, so both approaches will produce somewhat equivalent executables. If those parts are logically independent from each other, then I would recommend to use separate crates, in addition to other things this will allow parallel compilation, but it will be slightly harder to promote 3 crates instead of one and they'll be a tiny bit harder to maintain.
I think the Rust way of doing that is [features](https://doc.rust-lang.org/cargo/reference/manifest.html#the-features-section) for each of the 3 parts. Then your lib.rs file can be just: ```rust #[cfg(feature = "png")] pub mod png; #[cfg(feature = "gif")] pub mod gif; ``` You can also sprinkle `#[cfg(...)]` all over your code if you want to be a bit more surgical about it.
Although there is a lot of sense in this post, it seems a little one\-sided. It really puts team members on a pedestal and doesn't acknowledge at all that perhaps they, or the processes that they govern, could have anything to do with *why* there is distrust. That's not to condemn them at all - it's very difficult to please some people and not all of the people who have complained recently necessarily should be please - but the post doesn't really talk about it at all.
&gt; Besides shoving exceptions down the language's throat (while carefully not calling them exceptions) I've only followed from afar lately, what are you referring to?
The old size is \`layout.size\(\)\`. We decided that `GlobalAlloc::realloc` would not support changing the alignment, since underlying allocators tend not to support that either. \(That can be done by manually allocating \+ copying \+ deallocating.\)
I’d love to hear more concrete detail about what you feel needs to be addressed! (FWIW, this series is not primarily meant as a response to any events in particular, but rather long term trends/need to articulate cultural values)
Indeed, flipping the switch should be relatively easy. Once #51241 lands, stable users who want to keep using jemalloc can keep doing so. That was the main reason why we hadn’t switched yet. There is also the question on what allocator rustc itself uses: [https://github.com/rust\-lang/rust/issues/51038](https://github.com/rust-lang/rust/issues/51038)
The frustrating thing about this is that there is zero history of these issues in the Rust community, and the team responsible for COC enforcement is required to be disjoint from the core team (to make this impossible). To be clear, I don’t see my post as primarily about COC/moderation issues, but rather the much fuzzier issues of culture.
 &gt;The hard-wiring of `std::collections::BinaryHeap` as a max-heap can be a bit annoying. I've always thought this was a weird choice, because so many classic uses of heaps seem to prefer min-heaps over max-heaps (e.g. lots of graph algorithms).
[1](https://github.com/rust-lang/rfcs/pull/2107) -&gt; [2](https://github.com/rust-lang/rfcs/pull/2388) -&gt; [3](https://github.com/rust-lang/rfcs/pull/2426) -&gt; [4](https://github.com/rust-lang/rfcs/pull/2441)
This is a great piece of writing, on multiple levels. Thank you for writing it. I look forward to folks embracing this. :-)
For reference: https://doc.rust-lang.org/reference/destructors.html Basically the destructor will run at the end of a variable's scope, which you can control by surrounding a block of code with braces. Your code should never *depend* on destructors running to maintain Rust's invariants about such things as lifetimes and aliasing, but you don't have to worry about that if you're not using `unsafe`. It's still true that a panic might kill the process instead of calling any constructors (really, code in your context manager could just kill the process itself if it wanted to), or, in some cases, some other Rust code might decide that it has no choice but to skip running a destructor (usually because it's the only reasonable way to uphold its own invariants). I think such edge cases *mostly* only happen for objects that are nested inside other objects, such as with containers that deal with the potential for panics in awkward places using [leak amplification](https://doc.rust-lang.org/nomicon/leaking.html). If you're using an object directly in a function the way you would use a context manager in Python I think there's little chance of running into that kind of issue. There may be other reasons why code would not call a destructor but I can't think of any.
&gt;This is why I feel distraught when I see accusations of bad faith, of the teams having an “agenda” and the “listening” done in the RFC process being a charade to avoid revolt. Or the sense of “luckily enough of us yelled to stop the terrifying original proposal from happening; the moment we stop speaking up, Those People will start pushing in that direction again”. All of these sentiments come from a place of distrust, a zero-sum power-focused framing, with a dose of tribalism to boot You don't really dig into why people think they need to yell or why they think the team has an agenda. And because you don't dig into it it seems like you're dismissing them completely out of hand. I'm not defending their behaviour but I think it would be useful to examine what leads people to doing this. Even if that's only done to not have anything for them to complain about rather than because you agree with them. That paragraph in particular feels quite us vs them - especially with the use of words such as "humility" elsewhere in the post. It's particular pertinent since in the special cases thread today the writer of the blog post was assumed to be writing in bad faith by a mod. The distrust isn't just on one side.
&gt; The frustrating thing about this is that there is zero history of these issues in the Rust community, and the team responsible for COC enforcement is required to be disjoint from the core team (to make this impossible). I think it's important to recognize this, and I think the teams responsible for moderation deserve a lot of credit. Seriously, I don't want this point to be overlooked among the greater conversation. I also don't want to focus too much on the CoC aspect, because as you point out, this is only one aspect of fostering a healthy culture. What I will say is this: "CoC" has become an almost loaded term. Two people could see the term and associate it with vastly different things. Again, it goes back to your point: Don't assume bad faith or an agenda. I think that's fair here. 
Thanks, I see what you mean now. I’ll keep this is mind as the series continues.
I'm not a Java dev but this looks great! Sorry I don't have more time to dig in. The only suggestion / request I have is to rename `Garvel.gl` to `Garvel.toml` so users and tools correctly know the format (how to de/serialize it). Again this looks awesome, I wish someone would rewrite the `dotnet` CLI tooling to be more Cargo-like. :)
In fact I have opened a ticket for the rename: https://github.com/timmyjose/garvel/issues/16 Of course this is your project so feel free to close it. :)
Not necessarily... E.g. if there was a parse function which accepted an image file and fed it through the appropriate handler, the compiler would have no way of knowing what types of files are valid. 
You missed [RFC 243](https://github.com/rust-lang/rfcs/blob/master/text/0243-trait-based-exception-handling.md), merged *before Rust 1.0*, which included not only `?` but also `try` (later renamed to `catch` and more recently back to `try`) *with* `Ok`-wrapping, and even proposed `throw` as a future expansion. The kicker? It was called "trait-based *exception handling.*" There is no shoving, there is no deception. The RFCs you link are merely moving forward with, experimenting with, or preparing for this merged RFC from 2014.
Got it, waitting for updates to support HTTP.
Have people ever thought about just going "Let's stop and consider things more". C++ finally got C++11 features because they were vetted continuously in Boost for years and years of actual use. Rust doesn't have that "vetting" of "what makes a good feature". You can't actually know that until you use it a ton.
&gt; If you have a function `fn foo(&amp;str) { }` and nested pointers and containers like `let bar = Rc::new(Box::new(String::new("hi")));` that you want to pass to it, would you really want to pass `foo(&amp;***bar)` in order to signal to the reader how we're dereferencing to get the `&amp;str`? First, I'd want to rethink the fundamental structure of my program to figure out why I ended up with an `Rc&lt;Box&lt;String&gt;&gt;` in the first place, and try to eliminate at least one if not two of those layers of boxing and ownership. (I'm *fairly* sure that `Rc&lt;Box&lt;T&gt;&gt;` almost never makes sense, for instance.) Second, if for some reason I decided I *do* need such a construct, I'd probably create a type to contain that particular construct and implement `AsStr` for it. All of which I want to be prompted to think about when the compiler tells me that I've failed to pass the correct type to `foo`. &gt; There's a deterministic and unambiguous path that the deref coercion rules take when the outer value is a reference, so the reader isn't learning anything new from this. Yes, they are: they're learning "wait, I ended up with a strange triply-nested type". I've had code before that accidentally ended up with a `&amp;&amp;&amp;str` or similar before, and I didn't realize that until the compiler said "hey, wait a minute, you can't pass that where I expect a `&amp;str`!". (Fairly easy to have this happen; for instance, if you have a collection of `&amp;str` and then get an iterator over it, that iterator may give you `&amp;&amp;str`, and so on.) If the compiler magically decided to change `&amp;&amp;&amp;str` to `&amp;str` without telling me, I might not have caught that problem at all. &gt; Match ergonomics is not allowing you to mix T and &amp;T any more than you could before; it's choosing the only legal interpretation of your pattern match that is possible. If I write `some_u8 + some_u32`, the compiler could choose a "legal" interpretation, such as promoting the u8 and adding. But I don't want the compiler to choose a legal interpretation, even if it thinks there's only one. Because there's *another* interpretation: "the code is wrong, emit a compiler error". &gt; The signal before was useless because in order to understand what the pattern match was doing you still needed to know the type anyway, just like with deref coercion logic. You have to *think* you know the type. What happens when you *think* you have `Option&lt;T&gt;` and you actually have `&amp;Option&lt;T&gt;`? Or you *think* you have `Option&lt;&amp;T&gt;` and you actually have `&amp;Option&lt;T&gt;`? All the easier when the compiler has encouraged you to rip out useful signals from your code and let it guess what you mean. &gt; And you can still supply the intended binding modes of all the variables anyway if you really want to convince yourself via compiler errors, just like with type inference! No, you can't, because if you get it wrong the compiler no longer gives you an error, it guesses at your meaning and proceeds.
&gt; A code of conduct is not enough. I'm glad to see this put into writing. Codes of conduct are not magic and enforcing them with an iron fist is counterproductive.
`catch` blocks are fine without `Ok`-wrapping. Arguing for auto-wrapping is where things started to go down the rabbit hole, IMHO of course. I'm not the only one who holds such opinions as you know, since you seem to be following RFC discussions closely. **Side note**: I didn't mention or even hint at any deception. You're confusing me with other individuals.
Just want to echo others ITT. I think this is a really terrific articulation of the issues and considerations with engineering communication. Thank you.
That wasn't quite what I was getting at. Even as *The Grand and Resplendent Keepers of the Vision, May Ferris Guide Their Path*, you still need to take both practicality and opinion into account. As in, just because lots of people want something doesn't meant you should add it, but it does suggest an issue that needs resolving. There's also question around bringing new programmers in and expanding the language's influence. Hmm... even if you are beholden to no one but yourself, it's still wise to move out of the way of rocks thrown by a mob. It's also wise to not stand in a river as a torrential downpour starts.
Hey, reddit doesn't support triple backtick formatting, you need to prepend each line with 4 spaces to get code formatting. Good answer also, thanks!
What is the meaning of Result&lt;()&gt; return type, I mean types of Ok and Err values?
You're taking my example too literally. It's common to have several layers of indirection (references, smart pointers, etc.) The added cost of redundant signals is extra boilerplate or expensive refactorings to make those redundant signals consistent with each other. Needless annotation or empty abstractions are not an adequate solution, and that's why deref coercions and other kinds of inference were added. It doesn't sound like the language has *ever* had the level of explicitness you're asking for, long before match ergonomics landed recently.
Yeah it just so happens that the algorithm I'm working on right now needs a max-heap, but I'm usually doing Dijkstra or something and am like "really"?
&gt; The added cost of redundant signals You're assuming the signals are redundant. &gt; It doesn't sound like the language has ever had the level of explicitness you're asking for, long before match ergonomics landed recently. On the contrary, I find match ergonomics one of the few instances of this problem that *has* landed. (`try` doing `Ok`-wrapping of its return value is another. `try fn` is a third, but that fortunately hasn't landed yet.)
&gt; I didn't mention or even hint at any deception I was referring only to your "(while carefully not calling them exceptions)" aside, whatever you meant by that.
&gt; Rust’s culture and design process is engineered to produce such outcomes, by embracing pluralism and positive-sum thinking ... A positive-sum view starts by seeing different perspectives and priorities as legitimate and worthwhile, with a faith that by respecting each other in this way, we can find strictly better solutions than had we optimized solely for one perspective. ... Being “nice” is not enough. We need to take a leap of faith and embrace humility and trust in our discussions. It is my strong belief that doing so will lead to strictly better ideas and decisions, enabling us to find positive-sum outcomes. This, right here, is why I use Rust. Rust is solving problems that communities that follow the "you have to have a thick skin" philosophy have decided simply cannot be solved, and no amount of "what if we try this?" will get past their thickened skins. It is a _consequence_ of this attitude that Rust is a great language to work in.
I second the suggestion that there needs to be a guide on how to store state in a server that is accessed by each request. I figured it out after playing around a bit but it's not obvious. I'd also like to see `service_fn` explained better in the guides. If I hadn't been following hyper and async stuff already, I'd be confused by this: let new_svc = || { // service_fn_ok converts our function into a `Service` service_fn_ok(hello_world) }; I'd think, "What? `hello_world` is already a function from request to response. Why do I need to wrap it in this `service_fn_ok` thing, and then wrap _that_ in a closure?" 
&gt; The outlined try syntax is crap, but the impetus to introduce language constructs to make extremely common expressions simpler is just how humans think about the languages they use; they develop shorthands for otherwise elaborate sentiments. That is absolutely correct. However, because of this natural languages end up being ambiguous, irregular, confusing mess. It's OK for natural languages most of the time, since we trade precision for brevity, and context will fill out the blanks, but it's a dire danger for programming languages. There are roughly two sides here: people that enjoy regularity and precision (originally attracted to the language because of that), and people that enjoy convenience and brevity (mostly converts from JS/Ruby/Python, that find language with type inference and curly braces quite appealing, but these pesky type system details annoy them).
But this function will be in a higher level crate, not on the level of the question (in my understanding). Taking OP's example we already have similar example in the ecosystem, namely `image` crate: it provides `load` function which can consume different formats (which are feature-gated, but enabled by default), but formats themselves handled in separate crates instead of creating a single crate which will handle all supported formats.
I don't agree that it's a "dire danger". The entire game of programming languages balances on finding ways to communicate the intent of machine operations clearly and concisely to a programmer. If we wanted to trade all the brevity and contextuality back for precision, we could be writing in lower level languages that leave exactly zero miscommunication about the operations which would be performed. In fact, I think the idea that concision is in a battle with precision is entirely a false conflict; clear notation describing mathematical operations *depends* on shorthand in specific contexts to describe the desired result and says nothing about the algorithmic method used to reach that result.
Because its absence is not an error condition. Which might seem a little bit weird. I think `env::home_dir()` is (or will be) deprecated though.
I think it's because there are system where the user reasonably doesn't have a home directory? I think this API would have been more appropriate returning \`Result\&lt;Option\&lt;PathBuf\&gt;, io::Error\&gt;\` rather than \`Option\&lt;PathBuf\&gt;\` still, though.
I don't know the specifics for `home_dir()` and `current_exe()`, but Option and Result have different semantics in that Option implies the wrapped thing you want may or may not exist, whereas result implies the thing is expected to exist and something went wrong if it doesn't. In context I would read that there are situations where `home_dir()` may not exist, and that there are situations where `current_exe()` exists but you can't retrieve it. Reading into the documentation for both it seems like my assumptions are mostly correct: `home_dir` is derived from an environment variable which is either set or not set, whereas `current_exe` should exist somewhere but finding it's location can fail for loosely specified reasons.
In [API doc](https://doc.rust-lang.org/std/env/fn.home_dir.html), I can not see it as a deprecated function. But why and what will be the alternative?
&gt; If the compiler magically decided to change &amp;&amp;&amp;str to &amp;str without telling me, I might not have caught that problem at all. The compiler does exactly this kind of conversion in all kinds of contexts: http://play.rust-lang.org/?gist=890792711d583eea9685ea28dce0323c&amp;version=stable&amp;mode=debug Implicit deref for field accesses have been around for a very long time, and generalized deref coercion have been around since 2014: https://github.com/rust-lang/rfcs/blob/master/text/0241-deref-conversions.md.
Got the point. Any idea what is `Result&lt;()&gt;` return type. I mean Ok , Err types?
Sorry if this is somewhat off topic, but potentially this library could work for me. I need a priority queue with deadlines. In other words, items are ordered by priority (like a binary heap), but a lower priority item can jump to the front if its deadline has expired. Is this a data structure that could work for that? If not, is there a term for what I'm trying to do?
Thank you for your kind words! :\-\) .. and I agree with the name change \- I had thought contracting \`Garvel\` into \`gl\` would make for a unique name, but I totally agree that it could potentially be confusing, and \`TOML\` is a well\-known industry standard. I also saw your ticket on Github \- will get down to fixing it. Thank you! :\-\)
That is exactly what I was looking for, thank you very much. 
[*Which* `Result`?](https://doc.rust-lang.org/std/index.html?search=Result)
This comes already close to what I was looking for, but I am looking for a solution that doesn't invoke something like a shadow of the actual enum. But thank you very much anyways, that was still helpful.
For example, * https://doc.rust-lang.org/std/fs/fn.create_dir.html &gt; pub fn create_dir&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; Result&lt;()&gt; this function doesn't have anything noteworthy to "return" if successful as it's essentially an action to the filesystem, whereas it can fail with several different reasons. And the `Result` type shown above is a shorthand for `io::Result` (`Result` on the `create_dir()` signature is a clickable link) &gt; https://doc.rust-lang.org/std/io/type.Result.html which is synonymous for `std::result::Result&lt;(), std::io::Error&gt;` where `std::io::Error` is an enum covering several error causes related to I/O. Now you see this expanded form says exactly the same thing as my first sentence on `create_dir()`. Ah, if you aren't familiar with the "unit type" `()` take a look at https://doc.rust-lang.org/std/primitive.unit.html
`Result&lt;()&gt;` is probably imported from `std::io`, or some other module. If so, that's a type alias for `std::Result&lt;(), io::Error&gt;`. Other modules do similar things, but the one remaining type variable is pretty much always the Ok value. 
This is probably `io::Result`. See https://doc.rust-lang.org/std/io/type.Result.html: it's an alias for `std::result::Result&lt;(), std::io::Error&gt;`.
&gt; You don't really dig into why people think they need to yell or why they think the team has an agenda. A specific behavior that can arouse these feelings is when someone responds in a manner like "I understand what you're saying but I disagree." The writer is trying to assuage some of the negative energy in a thread, but it comes off content-free to the reader. There's an idea in storytelling that you should "show, not tell". When I find myself writing the "content free" sentences like the above, I remind myself that it's not enough to *say* that I understand what someone is saying. I should understand it well enough that I can articulate it, and I should do so or point to where I have articulated it. Often, in doing so, I build a deeper understanding of the idea, in many cases one that changes my mind. Confronting the vulnerability required is a daunting task, and is only made harder when a matter is (or appears) urgent.
I'm on macOS. All the doc.rs pages are broken for me. Not just hyper docs. Even the ones from rustup doc. So, not sure what is happening there
&gt; describing mathematical operations depends on shorthand in specific contexts to describe the desired result and says nothing about the algorithmic method used to reach that result. Exactly. And that is why I often find reading mathematical notations impenetrable, despite having a decent grasp of math. Math notation is a terrible "programming language". It's full of conventions, ad-hoc symbols, "macros", etc. that are understandable only for people deeply involved in the context at hand. Sure it's shorter, but if you don't undstand "the context", then good luck. I like my Rust rigid and mechanical, not mathematical. A code that describes what is going to happen, and not "what the intention of result is". I don't care about clear notation, I want precision, understanding and control. The clarity of what is happening matters to me most. If it takes 20% more code, so be it. For me Rust is just safer and efficient assembler. And it's going to change to be just another JavaScript, I'll have nowhere to go. Most important point of comparing to natural language is: they keep changing to adapt to the needs at hand and social changes. They become more and more irregular and messy. And there is no line drawn anywhere in Rust. Today it's going to be skipping `&amp;`, then `try fn`, tomorrow some other detail, the current core team will change, new people will come, with even bigger "we want something easy for noobs", and in Rust Edition 2050, we will end up with JavaScript with types :D (just kidding). It's not that I don't want Rust to change at all. It's just I feel that it's an Eternal September from now on. We are so trying to appeal to the people coming from concise higher level languages, that there will be more and more of them, and they will demand more and more changes that make the language like they are used to, and it will loose the appeal that "C/C++ fugitives" seen it it. And we wil lend up as these freaks that write in Rust 2015 edition, and post rants on twitter about these damn kids that ruined Rust.
As many others I want to echo that I appreciate this reflection. I would like to add: Please remember that the more subtle/nuanced you require people to be, in order to be able to participate in Rust discussions, the more people you exclude. This is especially true for those of us where English is not the mother tongue - we might have read tons of tutorials on the Internet, but it doesn't help much if what's required is a delicate level of expressing your emotions. I understand that if you have a more delicate vocabulary than I do, I may appear rude or unempathic to you, so I need to try the best I can to be subtle. But I would be more comfortable if we could meet half way - i e, if you can also try your best not to interpret me as being rude or unempathic.
Thanks. `create_dir` is the exact location I noticed this :)
This got answered in https://www.reddit.com/r/rust/comments/8o5rmz/why_envhome_dir_returns_optionpathbuf_instead/e00z750/ :)
I mean [`std::cmp::Reverse`](https://doc.rust-lang.org/std/cmp/struct.Reverse.html) exists for a reason…
I managed to get it fixed. Looks like [decentraleyes](https://decentraleyes.org/) addon for firefox was causing problems with doc.rs I disabled decentraleyes for doc.rs and it fixed all the formatting issues.
and I'll have to use the whole crate actix-web even if I need only the http client alone?
I too value these sentiments immensely. On my phone and in bed, so brief, but... it’s so refreshing to hear thoughts at this level of trying to understand people and the way we interact with each other. I don’t mean to spark any debates here, but I could almost erase “Rust” and replace with “US politics” as these sentiments ring true with me not only at the Rust level or SW development level, but at a much higher (?) level: just people treating others with respect in spite of differences. Very well said. It’s encouraging to see leadership in any circle even discussing these sorts of issues. The Rust community is super fortunate to have leadership such as this. 👍
I'd report it on the Firefox Bugzilla. I had a stylo bug fixed pretty quickly. Especially since there is a difference between it and stable. 
Yes, it is just annoying, not unusable. Wrapping every value going into the heap and unwrapping every value coming out will work, but it's a bit ugly. Or am I [doing it wrong](https://play.rust-lang.org/?gist=e175842ee1274c4feba2a9e1c08c3b69)?
Many of the things that have been controversial lately have been in the works for years. We do have that vetting; that’s what being in nightly is, or being in an external crate.
That's right. I agree it can be annoying, but I've personally found it not actually end up being as annoying as it seems: most algorithms with heaps that I've written end up with approximately two pushes and one pop (in the source code). Specifically, they consist of a loop that keeps popping values off the heap until it is empty (i.e. a single pop at the top of a `while` or `loop`), plus an inner loop that pushes the newly discovered values, and, before all that, the push for the initial state. I know there's lots of algorithms that do more manipulations, but my experience is bookkeeping at pushes/pops doesn't come up much, because those operations don't come up much.
Nah, that's the best way. If it's *really* bugging you, implement a newtype wrapper, like so: https://play.rust-lang.org/?gist=0249bade8eacd548149e1b16c9b43853&amp;version=stable&amp;mode=debug 
&lt;3 It helps trust so much when you hear "The reason I disagree is because ..." rather than just "I understand what you're saying but I disagree." When you can actually see that the person has not only to some shallow degree understood your argument, but thoroughly understood it, and gave it a serious evaluation.
I didn't even think of that. Thanks! 
No, you're right: standard algorithms don't do a ton of heap manipulation per cycle. On the list of annoyances it's pretty low, really.
&gt; [the name of a type in a] signature is a clickable link Great point, and worth reiterating. &gt; if you aren't familiar with the "unit type" () And the `()` is a clickable link too.
Awesome as always. I seem to learn something new every video, super cool!
Yes, thought about the newtype wrapper. In most situations the simple wrapper you gave (thanks!) should work fine. For more complicated use cases the wrapper could be a bit annoying as well, though. The underlying maxheap has about 18 associated functions and 12 trait implementations. Anytime you want one of them on your minheap you have to add it to the wrapper before you can use it, I think. Obviously, on the Big List of Things To Fix In Rust the max-only heap is super, super low. But it's annoying enough that I've tended to use an external heap crate for minheaps instead. I should probably stop adding an extra dependency, but hey it's a really nice crate. :-)
I think Rust is just following the natural trajectory of languages: 1. People create a new language that is simpler and better than the existing ones. 2. People keep adding features until the language implodes under its own complexity. 3. Go to 1. I'd really love to see a language that defies that cycle one day, but it seems like Rust won't be that language.
Yes! I appreciated the point about shouting - if the only way to get noticed is to shout, then eventually it becomes irritating to have to wade through and blank out all the shouting. It degenerates into alpha chimp behavour. However, regarding niceness as a _form of words_ is problematic. It is really much more an attitude and a determination to keep the mind open and listening.
You are so fast
These ideas look very promising and I like them. In hindsight, I think the „battle to death“ had two main reasons (oh, well, maybe three): * Pre-RFC, especially from someone „high in the food chain“ sounds very official and gives a hint to being close to what you intend to propose. You don't have to explain it was not meant to give that expression now, but it did. If it was „brainstorming:“, then it would give a different impression. * There were previous heated discussions about the topic and I don't think they were resolved. So bringing the next step onto the table (without saying it's „conditional“ on the other proposals) sounds strange. * At least for me, the whole error-handling thing is missing clear problem that is being solved. It says that error handling is unergonomic, but how does one verify if the proposed solution helps with that? So, if I could be audacious to suggest, maybe the error-handling research could benefit from a step back. I was thinking about something like trying to gather user stories about what *exactly* they find problematic, try to map the problem area. I thought about doing that myself, but both didn't get to it yet, didn't decide on a good format and didn't want to provoke another possibly heated discussion so soon. 
I think it is important to not only try to satisfy different groups of developers and respect their opinions, but also try to find solutions which are *objectively* better for any human programmer in the long run, even if these solutions has never been used before. Rust is already different enough that it requires a significant amount of learning. This means learning completely novel concepts would be a natural part of the process for most people. Of course, the usual dangers of introducing previously unused concepts into the language apply, so these decisions should not be quick and light, and should require a lot of testing.
I concur this. This applies not only to technical communities, but also to larger communities as well. I am general left-leaning in US sense (maybe not for GMO stance of US left), but it saddens me to see that so many although not all of liberals just tag the right (there are many reasonable people there) to be lower than themselves both morally and intellectually for the reason that many on the right cannot articulate well or be "polished" in the sense of social class. This kind of condescension destroys real understanding just for the sake of feeling superior in an argument. We should avoid doing that in this community.
It sounds like this might work for you? &lt;https://crates.io/crates/priority-queue&gt;
Just wanted to say that I love your videos. It's great seeing how someone experienced in the language solves problems.
Let me preface this by saying that I feel that your heart and head are in the right place and I completely agree with the general message your post is trying to deliver. &gt; Fear and creativity don’t mix. You seem to be missing something extremely important: A code of conduct is an instrument of fear. I fear that by accidentally or deliberately violating the CoC, I might be banned from further participation. The CoC is a finger pointing at you, telling you what not to say, not to do and how to not behave. The principle goes against the idea of free and creative discussion. &gt; A code of conduct is not enough. Being “nice” is not enough. We need to take a leap of faith and embrace humility and trust in our discussions. Neither a CoC nor being nice is a requirement for an environment of humility and trust. They are unrelated concepts. Writing this, I decided to pick apart Rust's CoC a bit. I know that my comments here won't change the CoC, but I still think this discussion is still on-topic in the context of your post. (The following quotes are all from the CoC, not from your post!) &gt; We are committed to providing a friendly, safe and welcoming environment for all, * "friendly" has a different meaning for everyone, thus it has no meaning at all here. I, for example, consider an environment where I am restricted by a CoC to be unfriendly. * "safe" has no meaning at all. You can never be "safe" without giving context about what you want to be "safe" from. Sitting in front of my computer in my living room, I am certainly "safe" from a car accident, but I am not "safe" from an aneurism. None of these relate to the Rust community, and there is no indication what kind of "safety" is desired here. * I do like "welcoming", because it indicates that everyone is allowed to participate. It has actual meaning in this context. &gt; regardless of level of experience, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, nationality, or other similar characteristic. Almost all of these are unrelated to Rust and the surrounding ecosystem. But by mentioning them here, we're extending the discussion to topics that we cannot and should not include in our discussions. As soon as any of these comes up, we stopped discussing Rust and should move the discussion elsewhere. The only aspect that is related to Rust and even worth mentioning in such context is the level of experience, and I agree that it should be made explicit that people with a low level of experience can and should participate, and should be welcome to raise their concerns. &gt; On IRC, please avoid using overtly sexual nicknames or other nicknames that might detract from a friendly, safe and welcoming environment for all. This achieves the opposite of what it is trying to: Instead of focussing on the content of the discussion, it brings nicknames into the focus of discussion. (That said, I am glad that whenever I was on the Rust IRC, nobody ever hijacked the channel for complaining about somebody else's nickname.) &gt; Please be kind and courteous. There’s no need to be mean or rude. While the above is common sense, we are mean or rude sometimes, and we can't avoid it entirely. People need to be able to deal with that (on both ends). &gt; Respect that people have differences of opinion and that every design or implementation choice carries a trade-off and numerous costs. There is seldom a right answer. I actually like this one, but I also feel this should be common sense in a technical environment like Rust's community. If I were forced to write a CoC, this would probably be the first and maybe only thing mentioned there. &gt; Please keep unstructured critique to a minimum. If you have solid ideas you want to experiment with, make a fork and see how it works. I don't like this at all. It often happens that you just know you don't like something, but you don't what the right alternative is. By stating such critique, you might start a discussion that leads to someone else finding a better solution. Or it might even motivate the original author to rethink the solution and come up with something better. Or it might lead to a discussion that eventually leads to help structure the previously unstructured critique. To me, such a rule limits creativity. &gt; We will exclude you from interaction if you insult, demean or harass anyone. That is not welcome behavior. We interpret the term “harassment” as including the definition in the Citizen Code of Conduct; if you have any lack of clarity about what might be included in that concept, please read their definition. In particular, we don’t tolerate behavior that excludes people in socially marginalized groups. So, there we go. A threat. You talked about fear being the enemy of creativity. The above is a clear threat, and threats result in fear. Also, there is yet another Code of Conduct to read to even understand this rule (I didn't read it, and I certainly won't). I am not saying you should insult people. But in the heat of an emotional discussion, it happens to the best of us (I am certainly not one of the best, so it happens to me more often). This should not be a reason to exclude people, but we should be able to look past the insult and return to the actual discussion and find out why it got so heated and emotional that it resulted in insults. Then instead of excluding people, fix what makes people so angry and emotional. Also, again, common sense should be applied, not rules and threat of exclusion. &gt; Private harassment is also unacceptable. What people do privately should not be a concern of the community. All community interactions are public and should be public. &gt; No matter who you are, if you feel you have been or are being harassed or made uncomfortable by a community member, please contact one of the channel ops or any of the Rust moderation team immediately. Whether you’re a regular contributor or a newcomer, we care about making this community a safe place for you and we’ve got your back. So, the moderation team responds to allegations of anyone, which can't be proven since everything happened in private. I can't be the only one who feels that this rule is toxic and dangerous. It opens the door to all kinds of problems, like false accusations and more. Every digital way to communicate, be it IRC, reddit, email, and any other kind of messaging has a feature that lets you ignore another person. If you are harassed, ignore the harasser, which makes it impossible to be harassed by said person. And what does "made uncomfortable" even mean? It is such a subjective statement that the moderation team suddenly becomes the judge of what is socially acceptable and what isn't, a task which they can't possibly fulfill adequately. Such a rule may seem obvious and necessary to some, but to me, it is dangerous to a community. &gt; Likewise any spamming, trolling, flaming, baiting or other attention-stealing behavior is not welcome. Sadly, those things exist in any community, so, a CoC may as well contain such a rule. This post got way longer than I intended, but I still hope people will read it. As a closing statement, I'd like to offer the following perspective, which I strongly believe in: The need of a CoC is admitting that common sense does not work for us as a community. And I think common sense should be enough to cover all the above, without requiring any threats and without limiting the creative process. The last paragraph of your post is so beatiful and inspiring, a CoC is the opposite.
&gt;Therefore, Rust hashmap get function has a slightly more complex signature: &gt; &gt;`pub fn get&lt;Q: ?Sized&gt;(&amp;self, k: &amp;Q) -&gt; Option&lt;&amp;V&gt; where K: Borrow&lt;Q&gt;, Q: Hash + Eq` I'm struggling to understand this signature. Particularly, \`K\` doesn't seem to be used. Should it be \`k: &amp;K\` instead?
Nevermind, I think I got confused when trying out different queries: Spaces in the query DO cause an error, when parsing the URI. Sorry about that...
Both `K` and `V` are type parameters of `HashMap` itself. Since the function signature is in the context of being inside `impl&lt;K, V&gt; HashMap&lt;K, V&gt;`, neither `K` nor `V` need to be taken as type parameters of the function signature (they're already present).
This brings up some feels for me. My [holy `std::borrow::Cow`](https://llogiq.github.io/2015/07/09/cow.htmlhttps://llogiq.github.io/2015/07/09/cow.html) (whose [Redux](https://llogiq.github.io/2015/07/10/cow-redux.html) you linked was the first Rust post on my blog that really took off. Almost three years later, `Cow` is still one of the coolest types in Rust's toolchest, and arguably still underrated. So we may need even more Cow worshipping to reduce heap usage of our code to the point where the memory allocation algorithm becomes negligible for performance considerations.
It could be great to sum up this post in a blogpost, that users could reference on github. There is not reason to a lot of spend energy arguing for or against an RFC if it is officially in the "brainstorming phase". 
You will add a dependency on actix-web but on the parts of the crate that you use wil end up compiled into your final product.
&gt; A code of conduct is an instrument of fear. I fear that by accidentally or deliberately violating the CoC, I might be banned from further participation. I don't get this argument. In any place with mods you can get banned. A CoC merely spells out which kind of behaviours are most likely to make that happen. Compare to places without a CoC, where you don't know what can cause you to get banned. Surely your fear of getting banned should be less when you know the rules? &gt; The principle goes against the idea of free and creative discussion. You can't have any discussion at all, free and creative or otherwise, without some rules. Try discussing something with someone while a third person follows you around screaming. Of course the rule about not screaming and following people around is usually implicit, but it's still there. &gt; Neither a CoC nor being nice is a requirement for an environment of humility and trust. They are unrelated concepts. They aren't. How do you stop people from speaking out of turn, derailing the conversation, advertising "vi4gr4" and otherwise being a nuisance? If you have a community where this works without explicit rules, it is because people are following those rules implicitly. &gt; This achieves the opposite of what it is trying to: Instead of focussing on the content of the discussion, it brings nicknames into the focus of discussion. I don't see how being unable to use nicks such as 'goatfucker69' prevents you from having a free and creative technical discussion. 
Ooooh. I somehow missed that. Thanks!
I think the single thread of discussion is a bottle neck. I was trying to figure out why things are the way the are being stabilized for `GlobalAlloc` the other day, so that I know how to use the feature - I tend to be better able to do this if I know why it works the way it works. It was daunting. The number of threads, the different channels (internals, many rfcs, many tracking issues, many PRs, many IRC longs and meeting logs and ....), ... I am pretty sure that if somebody were to write an RFC right now for that feature, 1) probably nobody would be able to do it, 2) if someone were to try, they would miss a lot of discussion and rationale in one channel or another. I personally like how the memory model and other hard topics have gotten a github repo where they can spread the discussion into different issues all in the same repo and together collaborate in the proposals in the repo (sending PRs and so on).
not exactly, but instead you can do: * Drop, as epic_pork said * multi-line lamdbas: thing.with(|x| { x.foo(); x.bar(); }) the in those cases, the with method takes a FnOnce and, depending on whether you'd use "as x", an argument to it.
I really like this post. And while reading it, I had an idea: we probably need a form of strictly neutral moderation in the context of RFCs. People who moderate only the discussion and do not have any influence on the outcome. In democratic parliaments where debate becomes very heated from time to time such people serve exactly this function. They have no voice in the discussion but can guide it. I really don't know how to implement this but this would free the decision makers from possible accusations of influencing the discussion itself. What do you think?
I find the article nice and indeed contains a lot of deep insight ‒ something of which I sensed from the community for a long time, but this puts it into words. However, I also sense some amount of misunderstanding somewhere (not sure on which side). When I started the [fortifying](https://internals.rust-lang.org/t/fortifying-the-process-against-feature-bloat/) thread, it wasn't about any kind of distrust. I assume the best intentions on all sides. In other words, I trust all sides they do their best to listen, or their best in general. However, I also see some difference between listening and actually *hearing* the arguments. What I worried about ‒ and still worry about ‒ is „is our best enough?“ Assuming other communities also try their best (why wouldn't they), there's a history of failures. C *trusts* the programmer to do memory safety correctly. In general, the programmer does his best, but still makes mistakes. Rust admits humans make mistakes and implements some safeguards to help with not making them. So, there's trust in the sense I trust the leadership they do what they can. There's trust that they do better than leaderships of other communities, because there's ample example of that. But can I trust these leading humans not to make honest mistakes? I don't think I can ‒ in the same way I can't trust even myself not to make mistakes. That's not disrespect. That's not what I understand under distrust. That's simply asking „is there a way to have some more safeguards against these mistakes, because there's a lot at stake“.
TL;DR: Denying "strong feelings" as part of the discussion could just lead to people rationalizing those feelings or using euphemisms or non-participation to express them. There are four points which, I think, this article is not tackling: a) The line between emotion and rational thought is often blurred in our heads and even in our language. One can often be expressed as the other and militating against one may just result in people changing their wording, and, even worst, people "thinking" they are no longer being emotional, because the wording they use seem rational. Take, for example, my statement above, you could replace "I think" with "I believe" or "I feel", it keeps it's meaning within this context, yet it may naively seem to shift on a scale from rational to emotional based on which of those verbs is used. b) Discouraging strong emotions leads of using euphemisms, essentially keeping a layer of strong emotions, but masking it, so that the irrationality of the emotional reaction is hard to point out. c) Rust has has ~2000 contributors, out of which, around 800 seem to be truly active (based on this: https://thanks.rust-lang.org/rust/all-time), and it follows a 20/80 distribution in terms of commit (bottom 80% are less active than top 20%, out of those 20% the bottom 80% have fewer commits than the top 20%.... up until the last 5 devs, where the top 1 seems to have more commits than the bottom 4). Now, commits by no mean represent someone's share of work accurately, but it's all I have to go by, and it does showcase the fact that Rust has a strong "core" of developers and a relatively small dev pool. Compare that to the ~20,000 contributors to linux, and to the way they contribute, which is to say, nobody is a master of everything and the dev poll contributes more evenly. They are both projects of different scales, in terms of time, complexity and contribution patterns, and I'm no claiming that Torvald's practices are the best or that they would fit rust, but to bring the Linux project in as a comparison is comparing apples and oranges. d) Often enough people have an "inner circle" , which they will respect, and "outsiders" to that circles, which are disregarded. This can be seen in many projects, os or not. Imagine these two scenarios: 1. Imagine Graydon Hoare comes back and writes a long, insightful issue about why Rust's thread safety model results in people writing code which is either slow or impossible to read and debug, and suggests some alternative (e.g. removing the native thread API completely and switching to go style coroutines, relaxing the rules on the concurrency safety checks, providing native support for an actor pattern... etc) . 2. Imagine the exact same proposal comes from "Icatduck69" which just made a github account today to post this. Are the tow going to be received equally well ? No, and the reasons why they won't be received equally well, are purely emotional. One is a person which has been trusted with the language for 7 years, another is a complete outsider and there is significantly less anxiety about trusting the guy that is "one of the insiders". So in a sense, how would a "don't bring your feelings into this" policy affect this ? Would it make people act rationally and accept Icatduck69's proposal for what it is ? Or would it just make them rationalize their feelings, and bringing arguments they don't believe in against the proposal ?
Is anyone else getting a 404
As anything, it's a matter of balance I guess. I *prefer* not to have special cases, but I think that *some* very few areas benefit so much from it that the language ends up better by avoiding treating "no special case" as a dogma. For example, I *really* think that error-handling is an area that benefits from special-casing (the `?` operator), simply because every other function needs to deal with errors. If there was an ergonomic way to do so without a special-case, I'd be all for it of course, but in the absence of such a way, I think the special case is warranted. It's a slippery slope, of course, because everyone has a "special feature" which could "really benefit" from being a special case; and if you follow that road you throw everything and the kitchen sink into the language and turn it into an eldritch abomination. It becomes unwieldy, reasoning about it requires decades of practice and a large tome about its lore, etc... A *handful* of special cases for most common scenarios? I think it's worth it. Whereas delegation is special enough... well, that's a debate of its own. I personally haven't felt the pain much, so I tend towards "no, let's explore how to do without" for the moment.
&gt; The idea that discussions can be “purely technical”, i.e. devoid of emotional content, is bogus. This should really be taught as a mantra starting from elementary school. It's such a core truth in all of human dialogue—regardless of the topic—yet it's so easily forgotten by participants in said dialogue.
_Some_ of the stuff from match ergonomics only removes noise, that's true. It does also remove signal however. Here's a (contrived) example: https://play.rust-lang.org/?gist=b441607bd0803d83dc8108f4c1c7e828&amp;version=stable&amp;mode=debug Spot the mistake (should be easy). Note how you can't tell, from the function signature, which of the `x` and `y` is supposed to me mutated. They're just going to be mutable or not mutable implicitly by whether I try to use them that way or not in the function body. More importantly, even if I add `ref mut` to `x`, it'll _still_ make `y` mutable. It doesn't even compile if you write it out explicitly (as you would have before 1.26): https://play.rust-lang.org/?gist=e64f77defa910726dc9a39e4a7e94f54&amp;version=stable&amp;mode=debug Of course you can still write it out like this, but who's going to do that if they're used to the "ergonomic" version.
&gt; If not, is there an alternative that could be used? I stumbled across some post that said lambdas, but that post was from 3 years ago and I'm hoping something better has come out since then. There's no real need for "something better". Context managers were added to Python because 1. not all implementations have deterministic garbage collection, and `__del__` can cause issues even in CPython 2. anonymous functions only support a single expression Rust has both deterministic object destruction and multi-statement lambdas, so depending on the exact situation either can replace context managers. Using destructors (`Drop`) for that is by far the more common case (e.g. mutexes and locks both work on that principle): given Rust's semantics, they're both safer and more flexible than lambdas.
And in Rust the actual use of `return` is also very limited. 
&gt; That's simply asking „is there a way to have some more safeguards against these mistakes, because there's a lot at stake“. I wholeheartedly agree with this. I think the FCP majority-vote-with-no-concern-raised is already pretty good as a safeguard, but I've always been a fan of Defense In Depth :)
C
Or `os._exit`, or sending SIGKILL to oneself. I don't know about any other pure Python possibilities. If there are more, I'd like to learn about them.
Oh, I see. The use of "carefully" there was unfortunate. If there is any deception going on, it's self-deception. No one outside is being deceived, as one can easily deduce from all the (*totally irrelevant*) downvotes. I'll stop myself here before I start pretending to be a psychoanalyst.
First of all, thank you for your comments (I really feared that nobody would reply to this, which would have made my comment pointless). &gt; I don't get this argument. In any place with mods you can get banned. A CoC merely spells out which kind of behaviours are most likely to make that happen. Compare to places without a CoC, where you don't know what can cause you to get banned. Surely your fear of getting banned should be less when you know the rules? Of course, there are implicit rules everywhere. I talked about "common sense" a lot, which is kind of the same thing. The need to spell it out as clearly is what makes me uncomfortable (I only used the term "fear" to connect my point to OPs article, admittedly, it is a rather strong term in this context). The fact that the code says "If you do X, Y or Z, we do not want you here" is discouraging me to participate. Before I participate, the first interaction is not being welcomed, but reading a document telling me a set of rules. I am probably very nitpicky here, but it feels wrong to me. In the end, I probably would not have conflicted with the CoC if I had never read it, which again makes me question its necesity. &gt; You can't have any discussion at all, free and creative or otherwise, without some rules. It's sad that you feel that way. Of course there are rules, but those are the same everywhere - that every project feels the need to write down its own CoC in order to function actually supports my prior conclusion: The need for a CoC is admitting that we cannot rely on common sense within the community. Maybe that is true and I am being idealistic in assuming that people do have common sense. &gt; If you have a community where this works without explicit rules, it is because people are following those rules implicitly. It seems we agree on that. &gt; I don't see how being unable to use nicks such as 'goatfucker69' prevents you from having a free and creative technical discussion. And I don't see how someone using that nickname is a problem to such a discussion. It is just another thing that we care about which IMO we shouldn't have to. A nickname is the same as those "age", "physical appearance", "gender", ... things: It's some form of external appearance, which is not and should not be part of the discussion, since it is unrelated to Rust. I am not arguing whether or not one should use such a nickname. I am arguing whether or not such a rule should be part of a CoC for a technical community (and as you might have noticed, my opinion is that it shouldn't). Maybe I can summarize my central argument differently: One the one hand, a CoC is restrictive and discouraging (my opinion as explained in my initial post). On the other hand, a CoC is insufficient (one of the points in OPs post, which most of this thread, including me, agrees to). As such, a CoC is not useful for a us as a community. (All that said, while I feel I needed to say all this, the statements about humility and trust in OPs article are way more important than whether or not we have a CoC, no matter how strongly I feel against it. Even if we continue this discussion, I want it made clear that none of what I say here is said to disagree with that important message.)
Thanks
* Yes error-handling was the driving force behind `?`. But the solution was somewhat generalized with the `Try` trait. And the improvement over the meta programming solution(`try!`) was clear sugar-wise. * In the case of Delegation, it's a special solution to a very special-case. And the meta programming solutions are actually better, as they are more generic and flexible.
Given that the Scala team lead spoke positively about your article, I wonder what's Rust's/Mozilla's leadership take on harassing people's places of work? Do you have an insight how often leadership decided that harassment was the best way to punish people for disagreeing?
I wouldn't describe that scenario as "purely emotional". There are other things involved, like reputation, commitment, recognition of care, etc. As it happens, we've just seen a very similar scenario begin to play out: Ryan Dahl, who created the node.js project, just returned from a long hiatus to present some new ideas for a JavaScript runtime at JSConf.eu. Why was he granted a speaking slot? Did everyone naturally agree with him? Were his regrets about node shared by the rest of the community? Reputation and camaraderie have an important place in the decision-making process of a community project. I'm enjoying Aaron's posts because they grapple with the very difficult challenges of balancing the efficiency of reputation and camaraderie with thoughtful and inclusive communication with a larger (and growing) community.
I agree with your post and would like to extend on your first point. &gt; Take, for example, my statement above, you could replace "I think" with "I believe" or "I feel", it keeps it's meaning within this context, yet it may seem to shift on a scale from rational to emotional [...] What if you omit "I think" entirely? The statement then is delivered as a fact, but it still remains only an opinion. Compare these four: * This RFC should me merged. * I think this RFC should be merged. * I believe this RFC should be merged. * I feel this RFC should be merged. All of these contribute the same to the discussion, but cause different emotional reactions. While the first is the most direct and as such the one I would always prefer, it is often received negatively by disagreeing parties.
I believe that the frustration on the "against" side is often not really understood from the "in favor" side: the set of people who want to keep the language simple are usually the same set of people, while there are many disjunct and different groups that want to add things to the language. It looks from a group that wants to add thing X to the language as if the "against" camp is unnecessarily harsh to their proposal, but from the perspective of the "against" group they are under a constant barrage of extension proposals they need to defend against.
Definitely not. They are very busy inventing new UBs to put into the language.
Are there examples of behaviour like this from the rust team? This seems like a super loaded question.
Which meta-programming do you have in mind? Something based on macros (derives), or something based on something else?
Interesting, thanks!
&gt; Maybe that is true and I am being idealistic in assuming that people do have common sense. It might not be idealistic assuming that people have common sense, but it would definitely be idealistic to assume that everybody shares the same idea of common sense. For example, I would consider it common sense that using the nick 'goatfucker69' on a programming IRC would be disruptive to technical discussion. There are definitely people who would disagree with this though. Common sense is a good basis, but isn't enough. Trying to figure out what the set of social norms and boundaries are in a group of people is pretty hard. It's especially hard if this group consists of a blob of strangers on the internet. The CoC serves the purpose of laying down the social norms and boundaries explicitly, so that each person does not have to go through and figure it out for themselves. Because of this, the CoC is a very useful tool to avoid friction and general social nonsense that gets in the way of actually doing rust.
\* cough \* [`slice::len`](https://doc.rust-lang.org/std/primitive.slice.html#method.len) \* cough \*
&gt; Something based on macros (derives), Macros, not necessarily tied or limited to derives. The idea is to give the users the choice and flexibility to do whatever they want, and tailor the solutions to their needs. &gt; or something based on something else? Like what?
The hyperbole hints to active malice though, while what you describe is mainly a problem of volume. Everyone is painfully aware of the second, but solutions for that are not easy.
&gt; I was thinking about something like trying to gather user stories about what exactly they find problematic, try to map the problem area. I thought about doing that myself, but both didn't get to it yet, didn't decide on a good format and didn't want to provoke another possibly heated discussion so soon. I'm working on this now. I spent the past week reading as many of the `try` related threads as I could find. This week, I intend to write an article reviewing the "error handling ergonomics" discussion in broad strokes. Over the next few weeks, I plan to dive into each of the leading perspectives ("happy path", "type-based reasoning", and "control flow"), and the last-known approach taken by each. Finally, I'd like to present a fusion of the ideas and concerns of each perspective. My current ideas for that fusion I briefly outlined in the [reserve throw and pass RFC](https://github.com/rust-lang/rfcs/pull/2441#issuecomment-391761135): &gt; The pass/fail syntax could be part of a "dialectical ratchet". Consider a lint that requires any block using fail to require pass. Such blocks cannot use an implicit return. Novices may learn try/? with Option and Result. Intermediate users learn that ? is shorthand for pass/fail, and can override type conversions using Try traits. Advanced users recognize that implicit return is an elision of pass for the most common cases, and create Try impls that leverage the best syntax for their scenario*. I wrote that comment before I'd done research into the internals threads and industry research, and before I'd considered the guidance from articles on explicitness by [withoutboats](https://boats.gitlab.io/blog/post/2017-12-27-things-explicit-is-not/) and [aturon](https://blog.rust-lang.org/2017/03/02/lang-ergonomics.html). As I work through my notes and apply the principles from those articles, the "fusion" idea will evolve. To a degree, this will occur due to the pressures of formalizing the approach. I'm also trying to keep my mind as open as possible, to preserve the idea of improvements from the community (as we saw a few months ago with `Pin`). I'm hoping that approaching "error handling ergonomics" in this fashion will elevate the debate to facilitate the process aturon mentioned in his article on trust: &gt; The common thread here is reconciling oppositions. Not just finding a balance in a tradeoff, but finding ways to reduce or eliminate the tradeoff itself. 
It seems to be an accepted practice in the Scala community, that's why I'm asking what's the situation in Rust.
It is implemented incorrectly on Windows, and a break\-fix was rejected recently. I guess that deprecation is the next best thing?
I have a bunch of server users that are $HOME-less, intentionally. You can't login as them, but they execute tasks. This is a common best practice, AFAIK.
It looks like someone has already put together a whole bunch of collection types that all seem to accept custom comparators. Most types allow more than one way of ordering; it just makes sense to have composable comparator types. [https://github.com/contain\-rs](https://github.com/contain-rs) Seems to include a bidirectional heap implementation: [https://github.com/contain\-rs/interval\-heap](https://github.com/contain-rs/interval-heap)
Thanks! It makes it all worth it to hear that people are finding the videos useful :\)
Thank you! Yes, it looks like it indeed is a bug in the borrow checker! See Niko's reply [here](https://twitter.com/nikomatsakis/status/1003238711881076739).
What's the benefit of this over e.g. \`/dev/null\` or \`/bin/false\`?
Both aren't directories? (I see you probably meant as login shell, but those come with their own sets of problems). Having no home directory means nowhere to write to, which can add to defense-in-depth. Having no login shell won't keep someone from running `/bin/sh`, but having no home dir might at least keep them from writing to disk.
Interesting. In my experience there is usually too much software out there expecting to have a writable `$HOME` that makes having no (or a read-only) `$HOME` impractical.
I didn’t meant to imply malice. For some reason I expect that stabilization means stabilizing stable things. If that’s the case I don’t see why, before stabilizing something, there wouldn’t be an announcement saying “this is what we are going to stabilize in one month, it’s on nightly and try it”. For the GlobalAlloc thing, the PR stabilizing it changes some APIs, that is, it is going to be stabilized at the same time that it is changed, and when something is on beta, changing he design of something is already to late. So IMO if there is one thing that I am accusing people of doing here is that of stabilizing unstable things that are not finished without widely announcing exactly what’s going to be stabilized.
&gt; Communicating these sorts of ideas is really hard, and pushing for a higher level discussion on the topic might be a good idea at some point. It's hard to say when that's appropriate though! One practice that makes this especially difficult is when the RFC process begins before the conversation has concluded. A number of RFCs opened recently, in my opinion, were opened prematurely--when the "Pre-RFC" conversation was still active. My motivation to stop lurking was motivated when I witnessed the process losing that deliberative edge. Feature design is, often, the most exciting part of programming. It's natural to desire turning momentum into action. The danger is when we let our excitement--our emotional investment--drive the process. That the Rust language evolves through a deliberative process has been internalized by much of the community. (As David Foster Wallace would say, [this is water](https://youtu.be/8CrOL-ydFMI).) When people speak of "bad faith" in the rust community, I believe they're reaching for the sentiment that, in our excitement, the community short-circuits deliberation*, but they don't know how to explain it. &gt; I also agree that the keyword discussion is hard to have, because it is invariably tangled with other issues and can certainly influence later designs. I think aturon has already done a great job handling this though from the things I've skimmed. I'm excited for the `#[keywords(...)]` idea, whereby new keywords could be introduced as opt-in constructs, then promoted to universal keywords in a subsequent edition. ----- \* It's important to note that this accusation is rarely leveled at the core developers. The recent accusations, at least recently, occur because the core devs are all focused on Rust 2018. They aren't participating as actively as they otherwise would, because they're executing an urgent priority. It is thus incumbent upon us to rise to the occasion.
Mo offense, but what’s the benefit of `/dev/null` or `/bin/false`?
Concrete question: What is the vision w r t Rust, in the aspect of growing more features? Is the plan to continue growing features as time goes by, or are we approaching Graydon's asymptote any time soon, or...?
&gt; Although I actually can't remember if I ended up with Python or Rust: it was in an algorithms class I was teaching, so probably the former so the students could follow it. Ah, neat. I teach data structures in fake-Python and systems programming in Rust. Good not to get the two confused ;) I think `std::collections::BinaryHeap` assumes you can newtype the elements and reverse `Ord` that way, but I agree that the code overhead could be annoying in some cases.
It sounds like you need an increase-key or decrease-key operation. I'm not sure how hard that would be to add to min-max-heap, as it usually requires maintaining a map from elements to positions on the side. Sounds like https://crates.io/crates/priority-queue might be the crate for you.
Hi! I'm trying to use conrod to display an image, so I basically copied `examples/image.rs` into my examples dir, added `conrod = { version = "0.60", features = ["winit", "glium"] }` into my dependencies, and ran `cargo run --release --example image`. I got the message: "This example requires the `winit` and `glium` features. Try running `cargo run --release --features="winit glium" --example &lt;example_name&gt;`" which I then did and got the error "Package ... does not have these features: `glium, winit`". I'm very new to Rust and have no idea how to handle those "features". Ideas or resources pointers please?
It is and is in stable.
Nope
It is not a macro, async await is going to be a keyword iirc.
In a similar vein, I wonder how many community members actually currently use the `do catch` provided by nightly, and how tested it really is.
Dire danger is obviously hyperbole... Perl managed to be quite useful. But I will agree that moving Rust in that direction would slowly spoil the precise nature that I love it for.
really? wow somebody actually down-voted my link post, even though it has a video of the arch in action. that's pretty lame
I found out the other day that [the unstable book examples](https://doc.rust-lang.org/unstable-book/language-features/catch-expr.html) were written before auto-wrapping was implemented. I just checked and they are still not updated. This may confuse some potential testers.
It also may keep people from testing if the behavior is not communicated widely. I don't really need to test a non-wrapping `try`, since just stopping `?` can already be accomplished by using another function or a closure.
Ok solved, I had to remove basically all the cfg macros and the \-\-features options of the command
That's what Monad is indeed, abstraction over abstraction. If we get enough abstraction power in form of GATs, that would be required for making async methods work, we may not need the syntax sugar at the end. 
Would it be helpful to move to a 12 week release process? 
Is there a way to destructure a tuple with more elements than variables (making one variable a tuple), like in python: &gt;&gt;&gt; a, *b, c = range(5) &gt;&gt;&gt; a 0 &gt;&gt;&gt; b [1, 2, 3] &gt;&gt;&gt; c 4 
Just a friendly suggestion: you might want to actually post something there before advertising it to new users. Either an example of the type of post you'd like to see, or a sticky "welcome to the new sub!" with some general info.
In languages like Java, JavaScript, Python, Smalltalk, variables representing collections are references, and so you can say that they use "reference semantics", while variables representing small integer numbers are values, and so they use "value semantics". But I wrote the central part of the article in a book about Rust, where I was thinking only of C\+\+ and Rust, and then I added the other languages just for this article. In C\+\+ and Rust, variables representing collections are not references; they are objects containing a pointer, so it would have been confusing to speak about "reference semantics". The point of the article is "what should mean to assign to a variable an expression representing a collection"? We have three choices: to share the collection, to copy it, or to move it.
We've (core team) somewhat discussed mitigation strategies to try to catch bugs earlier so we don't have to issue point releases but I don't currently believe that more time would help much -- primarily the issue here is a lack of user testing in nightly/beta, most of these features have been available for testing for weeks/months.
That research much be a huge amount of work and I hope this'll move us somewhere. I find it quite hard to remember and get oriented in all the error-related proposals. I wish you best luck there. However (if I'm not misunderstanding you), I had something different in mind. I was more thinking about walking into the Rust user's forum, or some other place where newbies hang around, and asking „Hey people, we would like to improve the experience around error handling. But we are not 100% sure we know what exactly is broken, because, you know, we use Rust for a long time already and one gets used to things over time. Would you mind sharing your story about what felt painful around it? What you tried and didn't work, how you solved it eventually, what bit of code you have somewhere that feels like it should be possible in simpler way, etc“ and trying to consolidate it somehow afterwards. Because if such kind of research ever happened, it was a long time ago and the situation might have changed. And I'm not yet confident the RFCs that inflamed so much arguing were solving the right problem (maybe they did, but having such data gathered would make it apparent).
I'm curious: what's your opinion on lifetime ellision?
&gt;There is a spectrum of discourse, ranging from Torvalds\-esque flaming to sugar\-coated, emoji filled pandering that ultimately feel patronizing. That's a false dichotomy. How much content your post has, and for that matter how subtle it is, ultimately has nothing to do with how nice it is. You can be nice while still being direct and content\-rich. The only cost associated with writing in a kind way is the time it takes you to think about what you're saying. Surface writing style is also a very ... surface concern. It matters, because it affects how participants feel and it affects Rust's reputation, but if you really want to help you need to go deeper. Like, actually being willing to change your mind deeper. Protip: avoid taking sides, so that changing your mind doesn't feel like *losing*.
&gt; liberals just tag the right to be lower than themselves both morally and intellectually This is a complaint that I see a lot from conservatives, but I don't actually see liberals doing it. In a moral argument each side sees the other as having an immoral position. That's the reason for the disagreement. What I do see is a lot of conservatives act as though not only is the liberal position on an issue immoral, but that because acceptance is a liberal value any argument claiming that a position is immoral is necessarily hypocritical. Also, lack of polish and lack of articulation aren't the general problems I see. It's lack of respect. The rust community guidelines don't require polish and articulation they require respect. Part of that is taking the best reading of someone else's words and part of that is recognizing when the words you've chosen to use are hurtful and changing them. 
I figured out what the problem was. I had the addon "decentraleyes" installed which was causing some problems with doc.rs It wasn't a problem with firefox as I had initially thought.
This is a good objection. The problem is mainly that the rules have changed. Users that expect the old rules won't know what's going on, and will expect the binding mode to be explicitly written for every variable. That's scary for sure. &gt; And there is no mechanism to mark it as immutable. If you bind `y` with `ref` it will make it immutable. &gt; Is this the first case of implicit mutability in Rust? This change is indeed an example of implicit mutability, but I'm not sure it's the first case of it. One other example that comes to mind is that the mutability of the borrows of captured variables in closures is inferred based on how the closure uses the variable. &gt; It doesn't compile if you write it out explicitly (as you would have before 1.26) Before 1.26 you would have to put `ref` or `ref mut` before `y`. (Otherwise match ergonomics would have been backwards incompatible!)
FYI: looking at this again, I strongly agree that this paragraph came out one-sided and accusatory. I've edited the ending to better express that I find these trends concerning, and that I feel we need to head in a different direction -- but without putting the "blame" anywhere in particular. Thanks again for calling this out!
Not sure, but you can try add `#![feature(glium)]` in main.rs or lib.rs
Hey there! I'm learning rust as well. My solution compiles (but crashes on run) and it may not be idiomatic rust. Maybe it can help though. [package] name = "conrod_test" version = "0.1.0" authors = ["lolWatAmIDoingHere"] [dependencies] conrod="0.60.0" image="0.19" find_folder = "0.3.0" rand="0.5" [features] winit = ["conrod/winit"] glium = ["conrod/glium"] Adding the [features] section fixed the errors you were having. However, there were some compiler errors due to other missing dependencies. I added image, find_folder, and rand to fix the errors. Now it compiles, runs, shows a blank window for a fraction of a second, then crashes with error message thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: NotFound', libcore\result.rs:945:5 Sorry I can't be more helpful. Maybe someone else will chime in with a better response. 
&gt;That's a false dichotomy. I was never presenting it as a dichotomy, I was presenting extremes on a broad spectrum. &gt;How much content your post has, and for that matter how subtle it is, ultimately has nothing to do with how nice it is. You can be nice while still being direct and content-rich. The only cost associated with writing in a kind way is the time it takes you to think about what you're saying. This assumes that there's a universal interpretation of "kind." If there were such a thing, this wouldn't be such a difficult problem. This is further complicated by the fact that there are language barriers and cultural differences that influence how we communicate and interpret things. We should take care not to offend people, but we should also try not to take offense. I think the recent stackoverflow fiasco exemplifies this. No matter how nicely you state the point, some people will take offense to the fact that a question doesn't meet community standards, and will feel like they're being excluded. As a result, Joel Spoelsky was accused of *purposefully* excluding certain groups of people. The "don't assume an agenda or ill intent" point is a two-way street.
&gt; If you bind y with ref it will make it immutable. That would turn `y` into a reference even though it's `Copy` and referencing isn't necessary. So it wouldn't be exactly equivalent to the explicit version of the code. &gt; This change is indeed an example of implicit mutability, but I'm not sure it's the first case of it. One other example that comes to mind is that the mutability of the borrows of captured variables in closures is inferred based on how the closure uses the variable. Maybe I'm picky, but I like my mutability to be explicit. I don't like that with the new changes, mutability of bindings becomes invisible (unless you write it 'the old way', or inspect the code that uses the binding). And for what it's worth, I've always found the way closures work with mutable captures to be incredibly confusing. &gt; Before 1.26 you would have to put ref or ref mut before y. (Otherwise match ergonomics would have been backwards incompatible!) Not really since `y` is `Copy` in the example. If I had written the code correctly and used `x` like I'm supposed to, it'd compile without any issues without `ref` or `ref mut` before `y`. It's so weird to me that depending on whether I write out the reference type in the pattern or not, I get different behavior without any signal anywhere what will happen. 1) with `&amp;mut Point { ref mut x, y }` — same old explicit version — `y` is `u32` ([https://play.rust-lang.org/?gist=988c761339cec9d59df1cff5834f98fc&amp;version=stable&amp;mode=debug](playground)) 2) with `Point { x, y }: &amp;mut Point` — with match ergonomics kicking in — `y` is `&amp;mut u32` ([https://play.rust-lang.org/?gist=751fcfc3d7b09571344ff89809ea059c&amp;version=stable&amp;mode=debug](playground)) 
Based on the tone/content of the article I was expecting more examples "the current direction of Rust" when it abruptly ended. The author could have also talked about `?` and `async`/`await` vs some hypothetical more general do-notation, for example. Or `for` vs just calling methods on `Iterator` (not "current direction", but it's a similar kind of special case). Instead they just picked on a single not-even-half-baked-yet brainstorming idea.
&gt; up until the last 5 devs, where the top 1 seems to have more commits than the bottom 4 Where, just where would we be without bors, the geary master of Rust.
All your data are indestructable per default but may be dropped.
Thanks for the pointer! There's some interesting stuff in there.
But is there a secret sauce that one must obtain to become a systems programmer? I must conclude that there isn't.
&gt; The CoC serves the purpose of laying down the social norms and boundaries explicitly Actually, it doesn't. I listed in my original post several points where the CoC simply refers norms that it does not define and that people think of in different ways. I'll repeat them for clarity: * "friendly, safe and welcoming environment" * "overtly sexual nicknames" * "nicknames that might detract from a friendly, safe and welcoming environment" * kind * courteous * mean * rude * insult All of these terms mean entirely different things for different people, especially in different cultural circles (ask an American, a European and an Asian about any of those, and you will get entirely different answers). Yet the CoC simply assumes that everyone has a common understanding of them. So, instead of clarifying the rules, the CoC obscures them further.
Under **Waiting for Merge**: &gt; @ogham documented Vec’s particular IntoIter behaviour, mentionned spec and indented blocks in doctest docs* and l* (Emphasis added) Is that just a missing period or did the sentence get cut off while writing?
&gt; It won’t be a big long explanation; it’s adding the jemalloc_alloc crate to your cargo.toml (and till extern crate goes away, adding it to the crate root.) This should be a (future) chapter in the book then.
No, what I describe is quite a bit more than the standard monad abstraction. Including quite a bit more messy, inelegant, and non-composable.
Great news! I'm interested in how can I start websocket server with hyper, maybe with basic authentication before upgrade
Wait, what is the purpose of `try fn`? I must have missed it in the pre-rfc, I don't get why we would want it.
Good news! Decided to spend a few more minutes on it. Turns out I needed to copy the top-level `assets` folder into the top level of my project as well. It now runs and shows the rust logo. I'd love feedback from a more experienced rustacean on my approach. I'm sure there's a better way I could have done this.
We’ll sort it when the decision gets made; probably!
Maybe... let's leave politics out of r/rust? Especially such US-centric ones :)
As mentioned to parent [here](https://www.reddit.com/r/rust/comments/8o3tmf/aturonlog_listening_and_trust_part_2/e01th2u/): maybe... let's leave politics out of r/rust? Especially such US-centric ones :)
&gt; Exactly. And that is why I often find reading mathematical notations impenetrable, despite having a decent grasp of math. Math notation is a terrible "programming language". It's full of conventions, ad-hoc symbols, "macros", etc. that are understandable only for people deeply involved in the context at hand. Sure it's shorter, but if you don't understand "the context", then good luck. I'm sorry, but what you're describing is that there is a set of mathematical notation that you're *comfortable* with and that you think that notation you're not comfortable with is bad. Notation as short hand is necessary so that experienced practitioners can communicate without screwing up details. For example, I could say that using a plus sign for addition is bad notation and that it is far preferable to refer to addition in terms of the actual meaning of operations on integers: add x y = iszero y id add isneg y pred succ x pred y (of course, maybe you think polish notation is bad notation too :P) But computers *don't* do addition that way. So if I want to be mathematically precise, I have to abandon any notion of using optimized computer operation in the first place (despite the results being identical over the range of the implemented integer values). Or maybe your argument is that of course computers don't add that way, so really, we have accepted that plus signs mean that the computer is doing an opcode addition instruction on two registers. Except we know that the opcode will only be particular for integer values of a particular size on a particular platform. Is that the specific level of imprecision and convention you're ok with and no further? My point in all that isn't that there can't be *bad* shorthand. I'm sure there are lots of areas of mathematics where the shorthand wasn't duly considered and the notation got well and truly out of control. But the idea that you want to or even really can draw a specific line in the sand about what short hand is good and what is bad is very myopic. &gt; Most important point of comparing to natural languages is: they keep changing to adapt to the needs at hand and social changes. They become more and more irregular and messy. And there is no line drawn anywhere in Rust. Today it's going to be skipping &amp;, then try fn, later some other detail, with time the current core team will change, new people will come, with even bigger "we want something easy for noobs", and in Rust Edition 2050, we will end up with JavaScript with types, because that's most convenient for new users :D (just kidding, just kidding! but you get the point, I hope). In 1988, the idea that an array should store its length was controversial, but in 2018's Rust, it was decided that the extra cost is so worthwhile that the notion has been ingrained at the deepest levels of the language. If that isn't an adaptation to social *and* technological change, then I don't know what is. What I see the goal of Rust to do is to make doing correct first and efficient second computation way easier than before, not necessarily to be some crystalized high level expression of intermediate level portable opcodes. You see it as a problem of the language moving towards Javascript 2050, I see it as the entire community figuring out better and better ways to do good programming and the language team responding to that common discovery so that the good way is the easy way while different ways remain possible. I'm not going to respond to the last two paragraphs in particular, because I feel like I've already addressed the main thrusts. Anyway, I think even though we're not really seeing eye to eye on this that you would probably agree that a more complete macro system would allow for an easier time for good notation to fall out. Which is the only thing I'm really firm about.
It's basically a compatibility layer that sits between C and Rust code, should you want to call C code from Rust or expose an API to call Rust from C.
I think it's natural to be "offended" (for lack of a better word) when others argue *against* a feature you wish for, for various reasons: 1. Investment: it takes time to make a proposal, read it, clarify it, etc... so it's hard to accept rejection of one's work and invested time. 2. Incredulity: people do not write proposals "for fun", there generally is a problem that is being solved, a problem which causes *pain* to those who suffer from it. So when someone argues against it, there's first incredulity (don't you want to solve this problem?) and then sadness (just because you are fine with it, why can't you accept it to put an end my suffering!). Been there, felt that. Getting a proposal rejected is *hard*, and it takes a certain level of emotional detachment and long-term vision to accept that (1) is called the sunk-cost fallacy and (2) there may be a better solution in the future. I think this is why it helps when *alternatives* or *work-arounds* are formulated by the "against" camp. At the very least, (2) is turned around somewhat: the problem is acknowledged, and the "against" is working with the proponents to improve their situation (even if this is realized without changing the language).
Let's avoid discussions on CoC on Reddit, please. In the past, trolls have invariably flocked to them like bees to honey :(
Like, would it allow me to declare variable without binding value?
No CoC discussion on r/rust please. In the past, trolls have always flocked to them like bees to honey!
What's your end goal here? Just defining a variable with no value is already possible in vanilla Rust.
`libc` is just a library, and doesn't change the language. What it is, is that if you link to external C code, any C types it uses can be translated into `libc` types to be used in Rust. That said, delayed assignment already works in Rust. let x; if cond() { x = "true"; } else { x = "false"; } But that specific example should instead use `if` as an expression: let x = if cond() { "true" } else { "false" }
yea but we have to have two traits and the one that defines the index operation is not the one called `std::ops::Index;` :-\
I'll [quote `libc` directly here](https://crates.io/crates/libc): &gt; What is libc? &gt; The primary purpose of this crate is to provide all of the definitions necessary to easily interoperate with C code (or "C-like" code) on each of the platforms that Rust supports. This includes type definitions (e.g. `c_int`), constants (e.g. `EINVAL`) as well as function headers (e.g. `malloc`). &gt; This crate does not strive to have any form of compatibility across platforms, but rather it is simply a straight binding to the system libraries on the platform in question. Basically, unless you need to use libc, you shouldn't use libc. Other crates that provide higher-level bindings to system resources (like the standard library, even) are more portable and better quality Rust APIs.
`libc` is a Rust binding to the [C standard library](https://en.wikipedia.org/wiki/C_standard_library) on your machine. The Rust `libc` crate allows you to conveniently make Rust calls into that library. Some of the C library is irrelevant to Rust users, but there are things available through the [POSIX](https://en.wikipedia.org/wiki/POSIX) interface as well as OS-specific things that it can be handy to call. You wouldn't normally call into this library unless you had some special need that wasn't met by Rust [`std` library](https://doc.rust-lang.org/std/index.html) or one of the many [`crates.io`](http://crates.io) crates.
**C standard library** The C standard library or libc is the standard library for the C programming language, as specified in the ANSI C standard. It was developed at the same time as the C library POSIX specification, which is a superset of it. Since ANSI C was adopted by the International Organization for Standardization, the C standard library is also called the ISO C library. The C standard library provides macros, type definitions and functions for tasks such as string handling, mathematical computations, input/output processing, memory management, and several other operating system services. *** **POSIX** The Portable Operating System Interface (POSIX) is a family of standards specified by the IEEE Computer Society for maintaining compatibility between operating systems. POSIX defines the application programming interface (API), along with command line shells and utility interfaces, for software compatibility with variants of Unix and other operating systems. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/rust/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Can't the question "is our best enough?" always be posed, regardless of the measures already taken? It's vaccuous if it doesn't address the specifics of the process already in place. I haven't kept up completely with this recent meta dialogue, but I've followed the relevant threads on /r/rust and seen the RFC to remove impl Trait in arg position. My feeling is that it seems like a reaction to that specific undesired outcome rather than to an understpod shortcoming in the RFC process. If it were otherwise, I would have expected to see an RFC to change the process rather than an RFC to walk back a recent feature, because the latter disrespects the current process rather than trying to make it better.
Oh my god, my download was corrupted and would crash if i declared variable without value. My 1 week of life was a lie.
1. It has typedefs for various C types (`int`, `long, etc.). These are useful for C interop 2. It allows you to call functions which are part of the C runtime library. This is particularly important on systems where libc is the primary API offered by the operating system (typically unixy systems)
So libc allows me to write C-type code in Rust, right?
Libc is just the C standard library plus the C headers of your system. Nothing more, nothing less. For example, if you want to write a function that opens a file in Rust without using the Rust std library, you could do so by using the libc crate and just calling the C standard library functions instead.
Sort of, yes, but correctly calling C functions from Rust is harder than just using C, so you'll usually want to wrap stuff from libc with rust functions that handle the annoying details.
So I shouldn't use it, unless I need to.
A lot of the functions from libc are for making [syscalls](https://en.wikipedia.org/wiki/System_call), so if you were writing something and needed to directly invoke syscalls to do it, you could use the libc crate for that. For instance, if you wanted to use the Epoll syscall to monitor connections. 
**System call** In computing, a system call is the programmatic way in which a computer program requests a service from the kernel of the operating system it is executed on. This may include hardware-related services (for example, accessing a hard disk drive), creation and execution of new processes, and communication with integral kernel services such as process scheduling. System calls provide an essential interface between a process and the operating system. In most systems, system calls can only be made from userspace processes, while in some systems, OS/360 and successors for example, privileged system code also issues system calls. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/rust/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Good point. Thanks for the reminder.
I feel like I'm often fighting just to get some acceptance of my from the RFC motivation differing viewpoint, to the point where I had to develop strategies to try and be visible, be very careful about how to formulate things, and so on. At the point where alternatives might be discussed that fit the principles, I'm already mostly out of energy. Usually at that point it's also all still about different groups trying to win the discussion, rather than finding common ground. The process also isn't really geared towards mitigations, alternatives and exploration: * Things often aren't tested out as stable macros first before they become first-class syntax. If they are, it feels like a hard fight to get there. * A general sentiment seems to be "you don't have to use it", but I'm usually also not allowed to fully opt-out. With the match ergonomics changes for example, in a code review I'd have to review every single pattern (and Rust has lots of them) to make sure nothing slips in. Having `#![forbid(adaptive_match)]` would seem like a nice middle ground. I'm still on the quest to figure out if a custom lint can even detect it with the information rustc gives it, as inconvenient as it would be. I think that if there were a principle for features such as "if it has certain downsides, a crate should be able to opt-out of it". Some of those downsides would be "moves in-code information further away", "removes in-code information completely", "can decrease readability", "has odd corner cases". There were some situations in the past for example, where I would have loved to `#![deny(as_conversion)]`, and only `allow` it in certain functions designated for numeric conversions.
Exactly.
&gt; I think that if there were a principle for features such as "if it has certain downsides, a crate should be able to opt-out of it". I am not keen on seeing opt-outs. Imagine an ecosystem where every single crate has its own set of allowed/disallowed features based on the feeling of its maintainer: putting together pull requests become a challenge in adaptability! The reason gofmt was such a win, was because it paved the way to a uniform style, thereby making it easier to commit to different codebases. A mine-field of opt-outs sounds like going backward. Therefore, much like with style, if a feature makes it into the language I'll accept it whether I like it or not, simply because uniformity makes for an easier time for everyone.
They're common options for the login shell when you want to disable sshing or su-ing to that user. I've never seen them set as $HOME, so I have no opinion on that.
I can't remember ever having a problem running daemons or other code written for servers with no HOME. For user-facing code I agree that this can sometimes be a problem. Of course, you can be part of the solution by returning `Option` 😁
&gt;But I would be more comfortable if we could meet half way - i e, if you can also try your best not to interpret me as being rude or unempathic. As a native English speaker I'm much more generous in my interpretation of comments if I know the writer isn't a native speaker. Perhaps if you're afraid of being misinterpreted you can mention English isn't your first language.
&gt; I am not keen on seeing opt-outs. &gt; &gt; Imagine an ecosystem where every single crate has its own set of allowed/disallowed features based on the feeling of its maintainer: putting together pull requests become a challenge in adaptability! Isn't this just as true with clippy, and with "you don't have to use it"? Give those realities, it feels to me like the main point is social pressure, or making those with different preferences suffer a bit. I'm not using `rustfmt` either in my projects. Its getting really close to readable for me, but there are some very small style issues (things like a separating line at certain points) that won't qualify for an option. And for my own projects I don't have a big drive to use it and decrease readability for me. Finally, given you wrote this higher up: &gt; Incredulity: people do not write proposals "for fun", there generally is a problem that is being solved, a problem which causes pain to those who suffer from it. Don't you think this applies to "suffering" and "pain" like mine as well? Is my preference less valid? 
The remark that English is not one's native language followed immediately by a display of a very good command of the language seems silly to most readers. It's common enough that I see it joked about in response most of the time. Moreover, I think it's beside the point, because it does not matter what the reason for one's lack of proficiency is. The same sympathy ought to be extended to the less eloquent native speakers.
So when will docs.rs finally get a new rustc ;_;
Personally, I think `Ok(())` is beautiful. :)
Bad cut, thanks!
I thought it already did?
No it has some pre-release version of 1.26 and anyone who actually uses 1.26 features has crashes instead of docs. I first noticed this 20 days ago, and it happened repeatedly as recently as yesterday https://github.com/onur/docs.rs/issues/23#issuecomment-389008697
Understandable, I wasn't trying to make a fuss. I'm just commenting that I'm enjoying the more moderate position. I agree with pretty much everything in the post.
Sorry, I would not have made a post in the sub about it, but it seemed appropriate as a comment in the context of the OP (which is partly about the CoC as well, btw). We might as well stop here then.
Thank you for pushing the conversation on this! The corresponding push to make cargo work with `minimal-version` is [hear](https://github.com/rust-lang/cargo/pull/5275) just fyi. ---- &gt; ... rely on this being a community-wide adopted standard practice ... and &gt; ... it's not obvious that "increase the minimum version you specify so that the minimum version actually compiles on modern Rust" is a reasonable pull request ... go together. Iif we decide as a community that "work with `minimal-version`" is a good thing then that is a reasonable pull request. And if we decide that it is *not* a reasonable pull request then it will be hard to get anything to work with `minimal-version`. My personal opinion is that life is a do-ocracy, if we make the PR's and we are polite about it we may slowly make it a community-wide accepted good thing. If we don't do it, or we are rude about it, then it will never happen. ----- &gt; I found the [patch] section which looked like it did what I wanted, but it doesn't appear to cover transitive dependencies. Maybe there's something I missed, here? according to the docs for patch: &gt; [Remember that [patch] is applicable transitively but can only be defined at the top level so we consumers of my-library have to repeat the [patch] section if necessary. Here, though, the new uuid crate applies to both our dependency on uuid and the my-library -&gt; uuid dependency. The uuid crate will be resolved to one version for this entire crate graph, 1.0.1, and it'll be pulled from the git repository.](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#working-with-an-unpublished-minor-version) I think the problem comes as `minimal-version` means that the resolver will pick a smaller semver version if available. and so your patch needs to be smaller than anything on crates.io. I wonder if the [[replace](https://doc.rust-lang.org/cargo/reference/manifest.html#the-replace-section)] section would be easier to use. One of the reasons `minimal-version` is an unstable/`Z` flag is that these corner cases have not yet been figured out.
It seems like syntax experimentation is already available through macros.
I hope this is relatively trivial, but so far I'm stumped. I need to pull a row of which one column is a MySQL arbitrary precision numeric, which apparently bigdecimal is the canonical Rust destination for; I then need to serialize that into JSON and send it elsewhere. This worked just fine for chrono::NaiveDateTime, once I worked out what to enable. I'm getting ``` ^^^^ the trait `diesel::Queryable&lt;diesel::sql_types::Numeric, diesel::mysql::Mysql&gt;` is not implemented for `bigdecimal::BigDecimal` ``` on attempting to `.load::&lt;SubModel&gt;(&amp;connection)` As far as I can see this is true; BigDecimal has FromSql and ToSql but not Queryable. I am, however, at a loss as to why that's necessary for a single field of a struct. Isn't FromSql enough? Am I missing something important? I would attempt to work it out from the Diesel source but it seems to be mostly macros and I really have no idea what's going on in there. Any help, hints, ideas gratefully received. The thread for adding support for BigDecimal at all implied that it was originally only put in place for Postgres; it's not clear if that has changed or if I'm barking up entirely the wrong tree. Cargo.toml bigdecimal = { version = "0.0.12", features = ["serde"] } diesel = { version = "1.0.0", features = ["mysql", "chrono", "128-column-tables", "numeric", "bigdecimal"] } dotenv = "0.9.0" chrono = { version = "0.4.2", features = ["serde"] } serde = "1.0" serde_derive = "1.0" serde_json = { version = "1.0", features = ["arbitrary_precision"] } Relevant line of schema: weighting -&gt; Decimal, Relevant struct: #[derive(Serialize, Queryable, Associations, Identifiable)] #[belongs_to(Model)] pub struct SubModel { pub description: Option&lt;String&gt;, pub weighting: BigDecimal, pub created_at: Option&lt;NaiveDateTime&gt;, pub updated_at: Option&lt;NaiveDateTime&gt;, } 
I would welcome a trend of testing with `-Z minimal-versions` in CI. This would be in addition to testing with newest versions, which is important for catching unintended breakage in dependencies.
SemVer does not have any requirements on pre-1.0 versions, other than to say they may break. https://semver.org/#spec-item-4 The crates the author points out that I saw are all pre-1.0
It's convention in crates.io/rust crates to treat `0.a.b` versions like `a.b.0` ones for the sake of compatibility with changing versions (they are still considered beta quality / not released, though).
I'll speak with docs.rs' maintainer when we have time.
You can start submitting issues with the title: **"[Yank Request] x.x.x breaks -Z minimal-versions"** and let crate authors decide wether that's something they care about or not. My guess is the majority of them will probably like the idea of preventing dependants from using old versions of their crates. Having said that, please don't bring package management ideas from Go people here again, thanks ;)
&gt; You wouldn't normally call into this library unless you had some special need that wasn't met by Rust std library or one of the many crates.io crates. For example, I use it to call `access(2)` as a way to bail out early if I don't have write permissions for the final-stage output directory in tools where I won't know the final filename until the heavy first stage completes.
Sure. But there is no attempt to discuss real world politics itself. Communication, understanding views from different people, accusations of "agenda" are what we are discussing.
I've never understood the appeal of Go's "use `-Z minimal-versions` outside CI" approach. It's always come across as "Minimize the number of security fixes which have made it into production code at any given time" to me.
&gt; **[Yank Request]** Yanking is an extreme, but effective, way to solve this situation. Adding a new release with bumped requirement allows those who care about `minimal-versions` to require that version. &gt; Having said that, please don't bring package management ideas from Go people here again, thanks ;) Some of the "Go people" are active in this subreddit. Russ Cox discussions have been extremely respectful of cargo. (Also complementary; although that is beside the point.) As someone who works on the resolver for cargo the respectful cross pollinations of ideas have been valuable.
Your erroring line does not occur in your snippet? You can get nicer code formatting by indenting with four spaces This line has four leading spaces Leave a blank line between your 'code' and normal text.
Not sure if it's the same issue, I'm running FF dev ed on Win 8.1 and I noticed this glitch: https://prnt.sc/jqept8
I actually thought of an alternative approach: add an "engine" section to the manifest, just like NPM do. This way we can let Cargo to exclude the versions that isn't compatible with the current Rust version.
My point is that we should not dismiss someone's idea simply because of its lack of articulation. And try to look at the meat of the discussion, not feeling superior because the other side's language shows less nuance than the you.
I actually genuinely don't know if ecosystem-wide `-Z minimal-versions` testing is worth the resources. Do you know of any real-world issues, which could be prevented if everyone used this flags on CI? IIRC, the "minimal versions could be a lie" problem was discovered during one thought experiment on a Cargo meeting about public/private dependencies. That is, no one actually complained about this. Now that `-Z minimal-versions` exist, I feat that significantish resources (+ 1 CI job everywhere, and one-time ecosystem wide effort) would be spent to fix this issue, which could actually be benign. Although I like the idea of combining `-Z minimal-versions` with testing the oldest supported `rustc` version as well!
No worries, and thanks very much for listening. I'll be honest, previously I was a bit concerned but your capacity and intention to truly listen to people shines through, so thanks for that :) 
I was going to suggest `mem::uninitialized`, but that only works if you can _absolutely guarantee_ that you will not cause a panic while it's uninitialized. The simple but ugly option is of course to unroll the first iteration of the loop.
Is `crates.io` ever going to remove it's dependency from GitHub? A lot of people will be taking notice now that Microsoft is buying them.
That might be difficult in the near term... You need to use a recent cargo but an older rustc. When the 2018 edition is official, for my (small) number of (small) crates, I plan on making the minimal version the first one with the 2018 edition, for simplicity. Moving into 2019, that seems like it'll be a common smallest rustc for the crates that care to test that kind of thing on, so maybe we can move that way. Not lying about semver seems like something we should at least do better about moving forwards. If your dependency pushes a new patch version to fix the semver specification, you can require that version. And if you have to, you can make transitive dependencies not transitive to update their minimal version.
I used nalgebra for a rasterizer and everything worked fine so that would be my recommendation. 
Or just use `Option&lt;Grid&gt;`. Much safer.
The second half of my comment was more tongue-in-cheek than real zealotry. So "be respectful" advice wasn't really needed.
Understandable. I am sick so my fingers are tired and should have expanded on my previous comment. As Rust matures, it would seem that new features and development will be larger and more complex, something that might be awkward to fit in a 6 week release cycle. On thing that might help is to have people optionally sign up for differential testing in development. Use the RC compiler during dev/test and the truly stable for release. Would it overly complicate things to put RC features behind feature flags? Balancing progress with stability is hard job. Another idea, if Cargo had knowledge of rustup, on an error in a new compiler feature, it could fallback to the previous stable?
Can't you do this? let mut over_relaxation = 1.0; let seed = [4; 32]; for i in 0..11 { over_relaxation += 0.1 * i as f64; watch_headers.push(format!("{}", over_relaxation)); let grid = Grid::new_with_seed(50, 50, &amp;fixed_boxes, &amp;scale, seed); grid.evaluate(0.001, over_relaxation, &amp;watch_point, 1000, &amp;mut watch_data); } watch_data_to_csv(watch_headers.as_slice(), watch_data, "watch.csv").expect("Could not write watch file!"); (if `.evaluate()` accepts `&amp;mut self` you'll have to use `let mut grid`, of course) 
Russ Cox argued for it, and now it's a thing. In case you didn't notice, *appeal to authority* is committed left and right in this industry.
OT: Could a mod please kick this bot out of this subreddit? It's not particularly helpful, and it's pretty noisy.
I'd love to see another implementation or two that have the missing traits needed to implement
I have had real world breakage reported against my libraries resulting from incorrectly specified minimum version requirements. [serde-rs/serde#1230](https://github.com/serde-rs/serde/issues/1230) is one example.
The second half of your comment may have been meant that way, but written out in a text-only medium, it wasn't apparent that you weren't being serious. Though for that matter, even when meant as a joke it's still not particularly respectful.
That's for Rust unstable feature flags, not Cargo features.
There's an interesting fight with the borrow checker starting at 1:46:17, that lasts more than 10 minutes, and he ends up surrendering with unsafe.
Yeahhh we definitely need a `move` keyword to explicitly set that binding mode. I think this was punted on in the match ergonomics RFC.
Couldn't you just fake initialize grid like that: let mut over_relaxation = 1.0; let seed = [4; 32]; let mut grid = Grid::new_with_seed(50, 50, &amp;fixed_boxes, &amp;scale, seed); I guess only `.evaluate` is comutationally expensive... 
Have you tried it with actix-web websockets?
All, or most, features go behind a feature flag and live in nightly usually for 1-2 cycles (or so I think, but this isn't based on any statistics) before being stabilized. So in effect, the 6 week cycle doesn't affect most developers -- hardly anyone needs to care about when the release is; a few people will take care of promoting artifacts and making it happen, otherwise people can just keep developing. &gt; Another idea, if Cargo had knowledge of rustup, on an error in a new compiler feature, it could fallback to the previous stable? I don't think falling back to a previous stable has been considered (but I could be wrong); however, Cargo knowing about rustup is somewhat "planned" to happen to increase ergonomics for trying new target platforms. This could mean that `cargo build --target wasm32-unknown-unknown` will go and fetch the wasm32 standard library and then work without any need to ask rustup to install it yourself.
It's also "minimize the number of potentially breaking changes in production at any given time."
Actually I had to remove all the \`cfg\` in the code
Yep I did that also at the beginning but I didn't want to have "features" for my code, just choose the one some features to use with conrod. That's why I had the `conrod = { version = "0.60", features = ["winit", "glium"] }` in my dependencies. Turns out by removing all the `cfg` macros it works fine! :\)
I'm trying to create a large static sized list of Vec&lt;int32&gt; types. This code: let mut values:[Vec&lt;u32&gt;; 1000] = [Vec::new(); 1000]; Will not compile because it complains that std::vec::Vec&lt;u32&gt; is not copyable. However this code: let mut values:Vec&lt;Vec&lt;u32&gt;&gt; = Vec::new(); values.resize(1000, Vec::new()); ... does compile. What gives?
Really? It's better than using lockfiles? or `=` versioned dependencies?
Nice! Glad you got it working. 
If you need reproducible builds, put your lockfile under version control.
Mostly: [less duplication when libs cite the same dependencies but with different versions](http://doc.crates.io/faq.html#why-do-binaries-have-cargolock-in-version-control-but-not-libraries)
&gt; What gives? Well, they're different types, so I'm not sure why they'd have the same behaviour. If you look at [the documentation for `Vec::resize`](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.resize), you'll note that it has a constraint of `T: Clone` on the `impl`. `resize` is cloning the "seed" value, whilst an array requires the seed to be `Copy`. The only way to initialise an array with non-`Copy` values is to make the necessary number of clones and pass them all into the array constructor at once. There might be a crate that will provide an easier way of doing this for smaller sized arrays, but I'd be surprised if there was one for exactly 1000 elements. It's easier to just use a `Vec`.
No.
What is missing?
&gt; For x86_64 targets rustc enables SSE2 by default. There are a couple of different ways to enable other target features, one is RUSTFLAGS and the other is .cargo/config. The latter was most useful for me as it meant I didn’t need to either set flags globally or remember to set them on every invocation of the compiler. Note that you don't need to set compile time flags at all, and can instead check the CPU support for vector instructions at runtime. This is explained and documented in the std::arch module docs. I'd recommend runtime detection of you can swing it, since it lets optimizations happen seamlessly without additional compile time flags, and permits one to compile portable binaries.
Oh right, I misunderstood and thought you needed to tell the compiler to emit code for that target feature even if you were going to dynamically select it at runtime. I would like to set up the runtime detection, I think the biggest barrier is my `SpheresSoA` struct stores data differently depending on the target feature. This is so I can get my data aligned correctly. Ideally I would like to tell Vec&lt;f32&gt; what alignment to allocate with then I wouldn't need to introduce other types. I'm sure I can work around this but I haven't put much thought into it so far.
Well my question may have been poorly worded. I meant how do I get a static sized array to function. I have to discard statically known information and add an extra heap allocation when using Vec. 
&gt; I have to discard statically known information and add an extra heap allocation when using Vec. Yes. Exactly that. I mean, unless you *want* to write a function that contains: [v.clone(), v.clone(), v.clone(), /* 995 more times */, v.clone(), v]
Appeal to authority is a logical fallacy, but it's useful in arguments that aren't pure logic. We have authorities because they know more than most people about a topic. We can find authorities that we trust and then make informed decisions without a complete in depth knowledge of a topic. Appeals to authority are everywhere and it's frustration when we actually do know and understand a topic and the opposing side just appeals to an authority, but it's useful anyway.
As per this [blog post](https://pingcap.com/blog/implement-raft-in-rust/): &gt; A complete Raft model contains 4 essential parts: &gt; &gt; Consensus Module, the core consensus algorithm module; &gt; &gt; Log, the place to keep the Raft logs; &gt; &gt; State Machine, the place to save the user data; &gt; &gt; Transport, the network layer for communication. &gt; &gt; Our raft-rs implementation includes the core Consensus Module only, not the other parts. The core Consensus Module in raft-rs is customizable, flexible, and resilient. You can directly use raft-rs, but you will need to build your own Log, State Machine and Transport components. 
Hey! Yeah, you're right. It turns out that it's a bug in the borrow checker. It seems to be known \(see one of the Rust developer's comments [here](https://twitter.com/nikomatsakis/status/1003238711881076739)\). I also just [merged a PR](https://github.com/jonhoo/rust-basic-hashmap/pull/1) that removes the unsafe by going through `.position` instead of `.find` that you might find interesting!
I recently went through the Shirley books (well the first two) and used them as a jumping off point for writing a path tracer in Rust. There are some omissions from those books I found, the biggest one being a general approach for rendering polygons. There are plenty of great resources out there to fill in the gaps though.. My exercise is as much to dive deeper into Rust as to write a path tracer. But the result is multi threaded, has a yaml scene description, various noises, transforms, lambertian, metalic, and dialectric brdfs, lazily loaded texture map support, bvhs, a plethora of primitives, etc. Every day I add more, and every day it gets slower :) For transforms, I elected to use nalgebra in lieu of implementing my own matrix class. I looked at the other libraries, but in my fairly limited research, it sounded like folks were leaning that way. I found the experience fairly nice, although its constructor function for building a matrix from euler angles doesn't allow you to specify a rotation order, which is not what one would expect (easy enough to roll your own though). I made use of the image crate for some common image formats. Pretty handy, although we are definitely missing some handy pieces like Openexr, openimageio, and opencolorio. I believe that there is a crate which has started on OpenExr bindings, but I decided quite arbitrarily to avoid any non-rust code in crates. So, I have been toying with writing basic Openexr support. i did run into some idiosyncratic behavior with trait objects, of which I make extensive use. I pass around Material, Texture, Camera, Coord, Hitable, and more as object traits. But that means I couldn't derive PartialEq on implementations... Makes testing a bit of a pain. 
I think there's some code missing. The error-generating line isn't in the snippet provided. Could you put a minimal test case up on the [Playground](https://play.rust-lang.org/)?
It shouldn't compile tho, right?
Could you elaborate on why this is *appeal to authority*? His blog post series seems thorough and well-argued. I'd be curious to know if there are gaps in his arguments that are being ignored due to his status in the Go community. 
Not really related to the argument from authority topic, but I do have a question about [Russ Cox's writeup](https://research.swtch.com/vgo-mvs): &gt; A key feature of minimal version selection is that upgrade do not happen until a developer asks for them to happen. You don't get an untested version of a module unless you asked for that module to be upgraded. This seems, like, kinda sorta true. If I have 100 dependencies that all talk to libfoo, and 1 of them asks for the newest version of libfoo, then the other 99 get that newest version without their developers asking for it. The definition of "you" who's doing the asking here seems to be kind of loose? Is this a useful property?
If you want to be able to distribute Rust programs in Linux distribution repos, then minimum rustc version matters. We aren't all writing custom software where we can specify whatever toolchain we want. Most companies who want to build reproducable infrastructure do so by using existing distro packages. Lots and lots of programmers don't seem to realize this.
Because a compiler bug has never crept into a real rustc release, and rustc has never made a backwards-incompatible change. What rustc version you depend on matters.
Your suggestion with the issues is interesting \-\- I know that the Rust community is already doing PRs against soon\-to\-be\-breaking things, and this doesn't sound too far from that vein. &gt;please don't bring package management ideas from Go people here again, thanks ;\) /u/aturon's [recent blog post](http://aturon.github.io/2018/06/02/listening-part-2/), esp. the content about pluralistic thinking, seems particularly relevant here. Even jokes have an element of the truth, and this isn't an us\-vs.\-them thing...we WANT Go people to come here too! Perhaps you could have pointed to demonstrated problems with Go package management \(which, of course, doesn't represent the language as a whole\) and said, "Let's please not do this \-\- I'm afraid of the consequences."?
Your suggestion with the issues is interesting \-\- I know that the Rust community is already doing PRs against soon\-to\-be\-breaking things, and this doesn't sound too far from that vein. &gt;please don't bring package management ideas from Go people here again, thanks ;\) /[u/aturon](https://www.reddit.com/user/aturon)'s [recent blog post](http://aturon.github.io/2018/06/02/listening-part-2/), esp. the content about pluralistic thinking, seems particularly relevant here. Even jokes have an element of the truth, and this isn't an us\-vs.\-them thing...we WANT Go people to come here too! Perhaps you could have pointed to demonstrated problems with Go package management \(which, of course, doesn't represent the language as a whole\) and said, "Let's please not do this \-\- I'm afraid of the consequences."? 
it is?
I'm having trouble figuring out how to merge vectors that are stored in a hashmap `HashMap&lt;i32, RefCell&lt;Vec&lt;i32&gt;&gt;&gt;`. \(Unsure if RefCel is needed\) The borrow checker is complaining about the hashmap being borrowed twice. The first time as immutable and the second time as mutable. Here is the code: let mut vector1 = hashmap.get(&amp;index1).unwrap().borrow_mut(); let mut vector2 = hashmap.remove(&amp;index2).unwrap().borrow_mut(); vector1.append(&amp;mut vector2);
I'm having trouble figuring out how to merge vectors that are stored in a hashmap `HashMap&lt;i32, RefCell&lt;Vec&lt;i32&gt;&gt;&gt;`. \(Unsure if RefCel is needed\) The borrow checker is complaining about the hashmap being borrowed twice. The first time as immutable and the second time as mutable. Here is the code: let mut vector1 = hashmap.get(&amp;index1).unwrap().borrow_mut(); let mut vector2 = hashmap.remove(&amp;index2).unwrap().borrow_mut(); vector1.append(&amp;mut vector2);
Yes. Because it *is* being borrowed twice. So don't do that: // Remove the second vector from the hashmap. let vector2 = hashmap.remove(&amp;index2).unwrap(); let mut vector2 = vector2.borrow_mut(); // Update the first vector. let mut vector1 = hashmap.get(&amp;index1).unwrap().borrow_mut(); vector1.append(&amp;mut vector2); Also, I don't see any reason to use `RefCell` for this, but I don't know if you need it for something else.
The flag being discussed and this comment thread are about package versions, not compiler versions.
This is so cool!
Sorry, it looks like I removed the relevant line when I shortened the snippet...
Thanks this is exactly what I was searching for. In my case, it should be obvious that the for loop runs and the grid will be initialized. \(now I only need to remember I did this if I ever change something\)
Can you allocate it with high enough alignment for all platforms?
Sadly Grid::new\(\) does work already \(not that the user would notice but still, the allocation alone is unnecessary and it should not be necessary in a language that claims to be fast\)
If I could specify allocation alignment then that would be totally fine. Using a `[repr(align(64))]` struct for example would work, but at the same time it would increase the chunk size to fit the alignment (to not waste space with padding between elements in arrays) which would make dealing with SIMD vectors that were smaller than the chunk size a bit painful. It would work, but I think it would complicate the code a bit and add a little more overhead. I might go back to unaligned loads so I can just use f32 arrays until I come up with something.
Speaking about simd wrappers, have you tried the 'faster' library?
Yes. Rust and cargo uses a version of semver that says this. From the cargo reference on specifying dependencies: &gt; Caret requirements allow SemVer compatible updates to a specified version. An update is allowed if the new version number does not modify the left\-most non\-zero digit in the major, minor, patch grouping. In this case, if we ran cargo update \-p time, cargo should update us to version 0.1.13 if it is the latest 0.1.z release, but would not update us to 0.2.0. If instead we had specified the version string as \^1.0, cargo should update to 1.1 if it is the latest 1.y release, but not 2.0. The version 0.0.x is not considered compatible with any other version. [Specifying dependencies](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html)
How is it possible to get a random value from an enumerator? Let’s say we have an enum Color with some colors in it. How to get a random color? I tried to put all the color variants in a vec then I would do random on the vec. But how could I get the enum variants, the colors?
What a good idea to add the minimum supported Rustc version in Cargo.toml. Unfortunately it sounds like for this case, some library versions should also specify the *maximum* supported Rustc version, and then Cargo should solve minimum dependency versioning with the restriction on the Rustc version in place — but this is impossible to do without being able to retro-actively adjust a release's version specifications. Alternatively maybe all crate versions which require Rustc *older* than 1.0 should be yanked?
You may have a look at the substrate library that's being developed by Parity. It provides common routines for blockchain applications but is generic over actual chain implementation and business logic. Despite being designed for classic blockchain, it theoretically may be used to implement other consensus algorithms. 
What is a 'clean' way to read an input stream from a TCP socket while still being able to stop when something goes wrong? What would be a criterion to stop trying to read more bytes (e.g. when the sender has disconnected and not when some segments are just delayed or something)?
I hadn't come across that before, looks interesting!
Your question sounds accusatory, because it is overly specific and you don't provide any context. Rust's CoC clearly states that any kind of harassment is unacceptable.
Except that got deprecated a long time ago in the NPM world.
You can use the rand_derive crate, found here: https://crates.io/crates/rand_derive That's the easiest way I think
First of all, the word is "enumeration". This matters because "enumerator" is used in some languages to mean what Rust would call an "iterator". Which led to me being *really* confused as to what you were asking. Second: you don't. You either manually create a const array that contains every variant, manually write a function that returns them as an array or iterator, or you find a crate that does that for you. Maybe something like [`enum-iterator-derive`](https://crates.io/crates/enum-iterator-derive).
I'll be watching over my PRs to ndarray while trying to dig deeper in its code base to have a better understanding of its architecture and design. Hopefully that should empower me to contribute solving issues and building features closer to the core of the library.
Sorry for the confusion. And thank you for the explanation. 
Maybe rustfix could transform all implementations of `Index` into ones using `GAT`s for the target type.
Thank you for pointing me to this crate. 
Maybe a bit strange but... what order/grouping do you use for use statements? I'm trying to settle on something like: * use super:: * use external_crate:: * use std:: * use own_crate:: Is there any 'standard' people use?
Good luck turning every zero-sum game into a positive-sum game! I'm not sure this is always possible, but in such cases the result is usually less important (e.g. "what to name `usize`"), though some of the time may have more consequences (e.g. to split a crate into multiple sub-crates). A couple of other things I wanted to say: - the more people involved, the harder it is to make a decision - I have seen plenty of comments by people who clearly hadn't understood something already said in the thread, no doubt because they were trying to comment on things without sufficient time to engage with the issue (exactly what I am guilty of with this comment!) I believe sometimes trust has to go another way: to *trust that other people can sufficiently well handle an issue that I don't need to get involved*.
Would be interesting to compare the performance of the native implementation and that written using faster. Also keep in mind, that this library automatically selects best implementation and lane with based on available resources and even falls back to scalar implementation if nothing suitable was found.
I would use `clone()` here. IMO `to_owned()` is overkill for cases where we want a fresh `T` from a `&amp;T`. I'd use it for generic code where the owning and referenced type may not be the same, and for non-generic code where I know they aren't.
Personally, I do: #[macro_use] extern crate ..; extern crate ..; #[macro_use] mod ..; pub mod ..; pub use ..; mod ..; use std::..; use extern_crate::..; use local::..; use super::..; use self::..;
Really cool and a very missed feature! Great work!
&gt; Most companies who want to build reproducable infrastructure do so by using existing distro packages. [citation needed]
You can use `__m256` with SSE4.1 though by splitting it into two `__m128` using an union.
Seems like the official repo is gitlab: https://gitlab.gnome.org/GNOME/librsvg But it doesn't include the language statistics that github does.
Also I'd like to cite an example provided in the Programming Rust book which, for me, is quite interesting, because it solves one pretty common issue in a very elegant way: ``` use std::path::PathBuf; use std::borrow::Cow; fn describe(error: &amp;Error) -&gt; Cow&lt;'static, str&gt; { match *error { Error::OutOfMemory =&gt; "out of memory".into(), Error::StackOverflow =&gt; "stack overflow".into(), Error::MachineOnFire =&gt; "machine on fire".into(), Error::Unfathomable =&gt; "machine bewildered".into(), Error::FileNotFound(ref path) =&gt; { format!("file not found: {}", path.display()).into() } } } ``` The most important thing is that since `Cow&lt;'static, str&gt;` derefs to `&amp;str` it may act as a drop-in replacement everywhere, where `&amp;str` was used. So, if last enum variant was added to an already existing code base, all would just work without any major refactoring. In other languages like C++ you'd probably have to decide, ether to return allocating version like std::string everywhere or get rid of the details and suffer from poor ergonomics everywhere where you'd need to use such method. Even worse, error entry with extra details may be very rare and yet, you'd need to make everything allocate just to stick it all in. Rust provides a solution that is zero cost for cases where extra details are not needed. It's a brilliant example of "pay only for what you use" principle in action.
Welcome to Reddit. Before posting to a subreddit/forum/community, you should check to see what that subreddit is for. This includes reading the sidebar and the rules. You should also pay attention to warnings that you're posting to the wrong subreddit. Check /r/playrust.
Maybe it would be on-topic on https://internals.rust-lang.org/ ?
The thing I'm worried about if storing chunks as `__m256` or larger is I'd need an inner loop if using SSE ``` for (((centre_x, centre_y), centre_z), radius_sq) in self .centre_x .iter() .zip(self.centre_y.iter()) .zip(self.centre_z.iter()) .zip(self.radius_sq.iter()) { // iterating in chunks of 8 floats, so need an inner loop or branching code for __m128 } ```
It's absolutely not obvious. `format!` allocates and thus may panic. `watch_headers.push` might allocate and thus panic. I'm guessing `Grid::new_with_seed` also allocates and thus may panic. If these things panic on the first iteration, `grid` will still be uninitialized, yet its `drop` will be called. (Or its member `drop`s.)
Gitlab does, it just requires a few clicks to get to it: https://gitlab.gnome.org/GNOME/librsvg/graphs/master/charts
I am still porting my SW Renderer from C/C\+\+ into Rust. Sometimes its very frustrating about Rusts Lifetimes, yes of course there are great know how issues in my mind. But, i hope it will be better in the furture. Currently i am going crazy with Things like Structs with references to other Struct Types and Function references. The Reason behind this was the usage of polynominal function pointer for Julia Fractal and Color interpolation based on results. Further i was wondering that there is no default Complex support inside of Rust. So i include the crate num\-complex. But maybe i will replace this with the only need complex mathematics based on my Vec2 lib. Anyway...i will rust in peace. Happy coding :\) DONE: * 2D and 3D Vector\(some Traits for comparision, and simple mathematics\) * Matrix 2x2\(some Traits for comparision, and simple mathematics\) * Matrix\(3x3 and 4x4\) TODO: * Rendering Engine\(Rasterizer\) using this features: * Camera for Projection * Tranformation from World to Raster, checking Pixel with Barycentric Coords and and and... * MSAA * Texture Mapping * Drawing 3D Primitives\(Point, Line, Triangle\) * 3D Objects Builder for Quads, Cube, Cylinder, Cone and some others * Distortion Function to transform amore Multisegment Cylinder into Tree Branches and Sphere Distortion for Leafsimulation * Noise Generator\(Diamond Square and Midpointdisplacement\) with different average and reduce functions on each steps * Noise to Heighmap Conversion using whole FrameBuffer or Stamp Like cutting a Gauss Circle or regular one * Some Texture synthesis Tests for Mandelbrot and Julia Fractals and Coloring with very simple linear Interpolation. EXTENSIONS * Voronoi Diagramm * Rendering Polygone based on Triangulation * Voronoi Like Heighmap Cutting Stamp Creation for a more controllable fancy Island Creation Routine. * Compine some Noise Algorithm for comparing Results. * Replacement Basic Mathematics with SIMD
I'd like it to see other crates that implements other functionality. Not one crates that implements everything.
This is great news since it shows that you don't have to rewrite your whole project in rust and that it's possible to start using rust for parts of your code without total commitment to such a new language.
On SSE you just split the chunk of 8 floats into 2 chunks of 4 floats, no need for an inner loop AFAICT.
Ah good point.
Thanks for the great example! I really like using `Cow&lt;'static, str&gt;` like this! I should probably add it to the Cows in the Wild section. Can I quote your comment?
Or using [`tokei`](https://github.com/Aaronepower/tokei) (which is written in Rust) $ tokei --sort lines ------------------------------------------------------------------------------- Language Files Lines Code Comments Blanks ------------------------------------------------------------------------------- SVG 741 62087 57910 2707 1470 Rust 50 17876 14049 1056 2771 C 44 14200 9679 1949 2572 C Header 19 2154 1131 578 445 Markdown 6 1272 1272 0 0 Shell 2 690 559 54 77 Makefile 5 400 266 69 65 Python 3 272 191 40 41 XML 2 247 209 9 29 Autoconf 7 195 140 35 20 Plain Text 3 183 183 0 0 MSBuild 2 95 95 0 0 TOML 2 72 38 24 10 Vala 1 37 34 0 3 CSS 1 4 4 0 0 ------------------------------------------------------------------------------- Total 888 99784 85760 6521 7503 -------------------------------------------------------------------------------
Sure, go ahead. Still, I'd rather refer to the book, to respect original authors.
[retro-pixel](https://github.com/Lokathor/retro-pixel-rs) has a 0.3 version piblished, and it's _meme fast_ (well, as fast as a single-threaded CPU rendering lib can be, but it uses custom crafted sse2 or avx2 when available). As part of an impromptu game jam that I declared yesterday on the Rust Community Discord, I'm now working on "the sort of game you might build with tcod". Our game jam goal is to have enough tech and experimentation done at the end of the month to make a reasonable 0.1 version of a pure-rust alternative to the C++ tcod library. __Others are invited to join the jam!__ The jam rules are that you have something to show by July 3rd, and that it be a cross platform program that's as easy as `git clone REPO &amp;&amp; cd FOLDER &amp;&amp; cargo run` (no weird FFI-lib setup steps unless your build.rs can automate it all on all three major platforms). So far I've got an FOV lib going with an interactive demo, and others are also making significant progress in just the one day so far (don't want to out them before they're ready to show off, so they can do their own announcement when they're set, but it's gonna be good). Some of the stuff that tcod does is already covered by existing crates (eg, `rand`, `image`, etc), but there's still a good deal of space to fill in.
Thanks, I already solved the problem thanks to vitalyd on https://users.rust-lang.org/t/how-do-i-deal-with-multiple-errors-in-function/17827 However it is good to se others approach.
I agree, but it is not really "news" given that Firefox is a higher-profile project where this has been done successfully.
I think the difference is that Firefox has always been a huge project which employed multiple languages in different parts. And even then afaik Firefox rewrote a huge blog and then switched it out. With this library it seems like they took smaller steps which seems a lot more feasible for most foss projects.
&gt;IIRC, the "minimal versions could be a lie" problem was discovered during one thought experiment on a Cargo meeting about public/private dependencies. That is, no one actually complained about this. There has been multiple times where Servo encountered this issue, where we forgot to bump a dependency in some Cargo.toml and the final Cargo.lock in the Servo project would make the issue apparent.
Week 10 of \[datrs\]\([https://github.com/datrs](https://github.com/datrs)\), secure p2p file sharing. [https://github.com/yoshuawuyts/okf\-updates/blob/master/week10.md](https://github.com/yoshuawuyts/okf-updates/blob/master/week10.md)
Thank you! Add this section: https://deterministic.space/secret-life-of-cows.html#mixed-static-and-dynamic-strings
I believe rustfmt orders them alphabetically. I’m not sure that’s the best ordering, but I’d call that the ‘standard’
You're welcome :) P.S.: Updated my comment to reflect your edits. Sorry for my poor English, it's not my native language.
I'll try my best to help and explain myself along the way: * Don't use ```*mut``` T use ```Box&lt;T&gt;``` unless you have a __really good__ reason too need a pointer. A brief expansion of the```Box``` type: under the hood it is just a pointer to your T on the heap but it manages that memory so that when the ```Box``` goes out of scope it makes sure to call the destructor of the T value before it goes. * Your errors about can't move out of a borrow: In Rust when you pass something ByVal you Move it even you pass something ByRef you Borrow it. When you Borrow something you cannot Move any of its fields because that is just a shallow copy meaning that any pointers in the field etc just get copied and now you have undefined behaviour. To stop this from happening if you Move something in Rust, the original variable is deinitialised and unusable until you initialise it again. To fix this either return values ByRef or use the Clone/Copy trait which let you make a safe Deep Copy of your value instead of Moving it and return that. 
You are absolutely right I spoke way to soon. \(I just skimmed over the documentation\). This is also way uglier than unwinding... \(I didn't initially realize that mem::uninitialized would force me to write to a raw pointer..\) I probably should just use Option\&lt;Grid\&gt;, but its a bit annoying as it adds code complexity that is not really necessary. 
It does, but only if you don't have empty lines in between.
Totally true, but the interesting difference here is that librsvg is a single project (with a stable API/ABI to maintain), progressively and seamlessly ported to Rust. Firefox's adoption is closer to that of replacing underlying libraries or components.
Hello, I'm a new rustacean. I'm currently working on an AI program (basically tree exploration) for a game. I usually use go for these tasks, but the tree here is very big so I needed more speed than possible with go. I could have used C++ there, but it's a good way to experiment my recent knowledge of rust. This is a niche where both speed and flexibility are paramount, and I think rust really fits here. It lets me go very close to the bare metal, while still letting me modify/improve my data structures without the fear of shooting myself in the foot (it would have happened if I had used C++, since rustc found bugs in my code gcc or clang would never have found).
I'm wanting to return a slice of the first 3 chars in a string, but finding that handling it in a 'safe' way is quite difficult. Essentially I want to do this: fn returns_a_str(my_string: &amp;str) -&gt; &amp;str { &amp;my_string[0..3] } But I noticed some answers to this sort of question on stackoverflow say that this is unsafe as indexing in to a string might not return what you think with non ascii characters. I can use chars() or char_indices() iterator; however, I can not seem to find a way to return a &amp;str, only create a new String and return that. Is there a way I can simply locate the byte index of the end of the 3rd char and then return a slice using indexing to make sure I'm indexing in to the first 3 chars? Something like: fn returns_a_str(my_string: &amp;str) -&gt; &amp;str { let index_of_char = my_string.char_index_of_nth(4); &amp;my_string[0..index_of_char] } Thanks
I didn't know tokei! Thanks, it's way faster than cloc I was using until now.
What were the numbers before the Rust porting work started? (Would be interesting to see how many lines of C code were removed.)
Almost all of that makefile code is templates and auto-generated code, though. The amount you need to write yourself is orders of magnitude less.
Desugaring down to a loop to prove that at least one iteration will occur is the [usual solution](https://play.rust-lang.org/?gist=cabdaacfd9471993daa6ad40902c07d6&amp;version=stable&amp;mode=debug).
I am really sorry if this question comes up everytime. I'm not a frequent reader of this subreddit. Which IDE/code editor(with plugins) works best for rust and can be used without problems on windows and linux? Thanks in advance.
Not sure how I'd split the union while iterating them?
I also really don't like `try fn`/`throws`. Why is it such a bad thing to return `Ok(())` explicitly? If you don't like manual ok-wrapping of the return value at the end, why not use a `do catch`-block? Like this: https://play.rust-lang.org/?gist=fb4a59d1d2379c8340f83f2fbea6511e&amp;version=nightly&amp;mode=debug
Firefox is nowhere close to being mostly Rust however.
Is Firefox using libsvg?
Yes. But it's not Mozilla porting it, the Gnome foundation also does notable work.
Does the LLD linker that now ships with Rust help with cross-compiling?
This isn't really a Rust question, so this isn't really a Rust answer, though I'll make reference to Rust APIs. [`Read::read`](http://doc.rust-lang.org/1.26.1/std/io/trait.Read.html) will read bytes into a buffer that you give it, returning `std::io::Result&lt;usize&gt;`. If there's an error, that `Result` will let you know. When the other side disconnects, there will be no more bytes for you to read, so after you've read them all, the next read will return `Ok(0)`.
I put the `use`s most specific to that module first: - use super:: - use own_crate:: - use external_create:: - use std:: There's no good reason for this in Rust, but I am used to doing it that way from C++, where there may be a good reason.
Thank you for the answer, I didn't realize that Ok(0) guaranteed that the EoF was reached, but it makes sense. :)
I've been very happy with JetBrains IntelliJ Rust plugin. I run it on CLion, but you could also run it on IntelliJ IDEA Community Edition, I believe. It should be quite portable.
Why can't I set flair for this subreddit? Clicking "Set your user flair" does nothing. Clicking the checkbox next to "Show my flair on this subreddit" reloads the page.
Note that when using read, you may also need to check for [`EINTR`](http://doc.rust-lang.org/1.26.1/std/io/enum.ErrorKind.html#variant.Interrupted). If you don't like that, but also don't care about performance too much, you could get a [`Bytes`](http://doc.rust-lang.org/1.26.1/std/io/trait.Read.html#method.bytes) iterator instead, which will clearly let you know when you're out of bytes. If you want to speed that up, you might want to wrap your socket in a [`BufReader`](http://doc.rust-lang.org/1.26.1/std/io/struct.BufReader.html) first.
You have the right idea with `char_indices()`. That will give you the index you need to slice at. [Here](https://play.rust-lang.org/?gist=eb9255dad8ae0147031c33f0f200388d&amp;version=stable&amp;mode=debug).
Your example is interesting, but imho it's no more error prone that the `Copy` trait (which nobody criticize as a bad ergonomic decision) consider this example : https://play.rust-lang.org/?gist=edc8bf17da404d0d83a53afebd3e6889&amp;version=stable&amp;mode=debug The `Copy` trait has a much bigger footgun potential IMHO, but the ergonomic cost of not having it is just too high compared to the low risk. And while the ergonomic benefit of `match_default_bindings` is lower, the risk has also been judged smaller than the benefit (and I agree with that arbitrage). Also, this isn't true : &gt; And there is no mechanism to mark it as immutable. This works as it used to : https://play.rust-lang.org/?gist=aabca9c9f022bf1ace2a95f450009948&amp;version=stable&amp;mode=debug 
The problem is that this is the only Gnome project with rust code at the moment, and only 7 open issues about it, which I don't think are easy or available for newcomers. I wanted to start contributing to Gnome since I use it daily, but I have no desire to re-learn C again (or Vala). I'm not even a rust developer yet but I thought it would be a nice chance to learn and contribute at the same time. So now I will probably just focus on my own Rust project.
Thanks. I had searched around but didn't find it.
Florian has given the answer already, i didn't know that. But [Wikimedia uses librsvg to render SVG images](https://en.wikipedia.org/wiki/Librsvg).
Have you seen https://gitlab.gnome.org/federico/gnome-class/ ?
Based on a previous discussion on typed keys, I have this: https://play.rust-lang.org/?gist=07cf6535de18a873f9cb8955c9c9487f&amp;version=stable&amp;mode=debug Basically I'm trying to have a typed key into a hashmap, without having to clone strings, so the idea is that the hashmap would own `KeyA`s, and access would be done using `KeyARef`s. First, is my `Borrow` implementation correct? I think `where KeyA: 'a` guarantees that lifetimes are correct, but I'm not 100% sure. Second, how can I insert a `KeyA` into a `HashMap` and get a `KeyARef` back (whose lifetime would be at most that of the HashMap, obviously)?
I'm working on my handwritten parser for [yarn](https://github.com/thesecretlab/YarnSpinner/blob/master/README.md) this week. I'm hoping that I'll be able to start working on the evaluation engine, which should be a fun project.
&gt; I get different behavior without any signal anywhere what will happen. But there **is** a signal: - in `1)`, you have `&amp;mut` both sides of the colon. - in `2)` you don't. That's the signal. `1)` still works BTW and which you can still use if need be in your specific scenario!
c3c80d25 (last commit to master before the rustification branch is merged) ------------------------------------------------------------------------------- Language Files Lines Code Comments Blanks ------------------------------------------------------------------------------- C 37 20368 15030 2035 3303 SVG 118 14354 13917 179 258 C Header 25 2267 1254 576 437 Shell 2 690 559 54 77 Makefile 4 340 217 69 54 Plain Text 4 247 247 0 0 XML 1 156 131 8 17 MSBuild 3 135 135 0 0 Autoconf 5 118 63 35 20 Markdown 1 74 74 0 0 Vala 1 37 34 0 3 ------------------------------------------------------------------------------- Total 201 38786 31661 2956 4169 ------------------------------------------------------------------------------- 2.40.20 (last rust-less release) ------------------------------------------------------------------------------- Language Files Lines Code Comments Blanks ------------------------------------------------------------------------------- C 39 20904 15386 2100 3418 SVG 132 15299 14734 300 265 C Header 25 2299 1274 579 446 Shell 2 690 559 54 77 Markdown 2 346 346 0 0 Makefile 4 342 219 69 54 Autoconf 8 292 237 35 20 Python 3 272 191 40 41 Plain Text 4 247 247 0 0 XML 1 156 131 8 17 MSBuild 2 92 92 0 0 Vala 1 37 34 0 3 ------------------------------------------------------------------------------- Total 223 40976 33450 3185 4341 ------------------------------------------------------------------------------- 
I think I saw it (I searched the whole Gnome gitlab in the weekend and starred some projects I might be interested in) but then I thought it was a personal project to be honest. I will give it a better look in the evening, thanks!
I haven't tried it yet, and I'm not very familiar with it, but I suspect that specifically for cross-compiling for Windows, the answer is "not much": I think for the GCC toolchain, and definitely for the MSVC toolchain, you also need a bunch of Windowsy platform definitions (headers, library prototypes, etc.) in addition to the linker. For the same reason, cross-compiling from Linux to macOS isn't practical: even with a linker that understands the MachO file-format, you'd need copies of all the system libraries to link against.
Have you investigated SAM and SAM local integration? I messed with Serverless.js a while ago and even did a draft of a [serverless rust plugin](https://github.com/dobrite/serverless-rust). At my work, we moved over to SAM/SAM local, since that seems to be the way forward, even though Serverless.js (at the time) was way ahead. SAM seems to have progressed since then, although I haven't kept tabs on it lately. Anyway, super cool project!
I just released 0.3.1 of my binary analysis framework, [Falcon](https://github.com/falconre/falcon), yesterday. First release in 4 months. I've been working on Falcon for over a year now. It's definitely helped me learn Rust, which I use for a variety of different projects now.
 (centre_x_0, centre_x_1) = centre_x.split();
There is also https://wiki.gnome.org/Apps/Fractal
I've seen and starred Fractal, but this also looks like a non-Gnome project: https://gitlab.gnome.org/World/fractal 
Last week I got basic function calls working in lldb. This week I'll be debugging the remaining cases that don't work yet.
I don't know the precise role of this project TBH. I only know that NIko worked on it: https://github.com/nikomatsakis/gnome-class and that Frederico is one of the Gnome founders and current librsvg developers.
IntelliJ works well, but it suddenly stopped working for me one day, and I couldn’t fix it regardless of how many reinstalls I went through. I switched to VSCode + RLS extension and it’s worked nicely for me. Plus I get all the sexy VSCode stuff.
What's news is that this is not happening only at Mozilla, who are kind of in the dogfood column :)
Looks nice. However, it'll be really good if layout of `Option&lt;SpamIdx&gt;` can be optimized somehow.
I don't see anything on the npm docs about engines being deprecated. https://docs.npmjs.com/files/package.json#engines
As I read it, know one knows but he thinks it is worth a try.
i wouldn't recommend dealing with ffi as a way to learn rust. i also wouldn't do an incremental rewrite of a c project in rust unless there were distinct subsystems that i could port all in one shot. it seems like you're trying to integrate the two languages, which is possible, but probably a lot more work than you need to do and not a good way to learn idiomatic rust. &gt;I can not come up with a proper type for the `vals` field what is accessing this field? i'm not at all clear about this. is all the logic in rust? is some in both c and rust? &gt; I have a problem with ownership. I often hit "cannot move out of borrowed content" when I access the field. this is very hard to diagnose without looking at your code&amp;mdash;there are a lot of things that could be causing this. a main culprit is using functions that consume `self` when all you have is a borrow. &gt;the C code uses type casting liberally ... this is symptomatic of a fundamental incompatibility in the way you wrote your c code with idiomatic rust. you *can* port c very literally to rust, but you'll be missing almost all of the value of the language if you do. type casting is heavily discouraged in rust&amp;mdash;it's a huge red flag. use `Option`, or have two separate struct types and build the one with the map from the other when you need to (or use a trait and dispatch dynamically). if you absolutely need to do casting, use `std::mem::transmute`. &gt; ... I'm still getting "cannot move out of borrowed content" when accessing the `vals` field and I can not figure out the character soup I need to get a mutable hash map out of it. the problem isn't mutability, it's that you just have a borrow when you need an owned value (probably `&amp;mut self` when you need `self`, but i'm not sure what function you're calling). i think you're missing some intuition about how ownership works&amp;mdash;i'd highly recommend that you write pure rust code until you have more of a handle on it. &gt;How does owhership interacts with raw pointers? it doesn't. the borrow checker doesn't look at them. &gt; I wonder why can't we have a nice type mapping for FFI? For example, `&amp;Option&lt;MyThing&gt;` for a nullable `MyThing*` at least in the `extern C` context. because that would be unintuitive, unsafe, and implicit. when you pass a value to/from c, the compiler doesn't do any conversion for you (except using the standard function call abi for the target system). the bits are the exact same on both sides of the boundary. that's why you need `#[repr(C)]` for ffi structs. wrt `&amp;Option`, `Option`s are enums, the compiler would have to do a magical implicit conversion, which would both require you to know about it and prevent you from passing `Option` across the ffi boundary without hacking an exception.
That is too bad... Thanks.
I have an API wrapper for a popular service I'm working on implementing in hyper &amp; async, I'll publish to github when it's more feature complete. It's been a lot of fun so far and a good learning experience for macros, since many APIs are repetative.
One problem with `Cow` is that unless LLVM does something really smart, for the most-common case of `Cow&lt;str&gt;` and `Cow&lt;[T]&gt;` you need to check the tag for every conversion to `&amp;str`/`&amp;[T]`. I wrote a version of it for slices/strings that avoids this problem and so should be faster. https://github.com/Vurich/cowvec
How serious of a problem is this that a breaking change is worth it? My understanding was that breaking changes are almost exclusively for bugs/ soundness issues. Is it really worth it? I have never used that feature myself, but I worry about those who have and who have also stopped maintaining their crates. Is this something that could just wait for 2018 edition?
Great preso with lots of interesting digressions into Rust advantages and features. I'll link this in future when people ask if there's a good reason to write operating system code in Rust. :-)
Heh, the increase in SVG test cases is awesome too. :-)
I find the current implementation of the RFC process has the following problems: * The github comment section is very bad at facilitating discussion, as it is difficult to track conversations. This makes it difficult to hear everyone, and for everyone to feel heard. In contrast Reddit was built for this specifically, and how its comments section works reflects this. * As /u/newpavlov said, any RFC sounds "official" for various reasons. This is counter-productive for any RFC which is mainly interested in comments, and does not reflect a (semi-)final proposal. "Requests For Comments" should ideally only be used to get comments, and another name be given to the proposal once it is accepted. E.g., today, an approved RFC is actually an "Intent To Change" (ITC), and the current RFC repo should reflect this. Therefore, I have the following idea of how the RFC process could function: * We change the name of approved RFCs to "Intent To Change" (ITC). This reflects that this functionality has been approved and will be implemented at some point. This name change removes the "official" feel of RFCs, since the approved ones get another name (ITC). * A subreddit is created and moderated by the rust team called "r/rust-rfc". Todays RFC proposals are published on this subreddit with a link to github with the actual text. Discussion takes place on the thread and ratings can be used to reflect how people feel about it. Editing an RFC should be discouraged, instead a new RFC should be posted, that accounts for the previous RFCs discussions. The new RFC should also link to the old thread, such that we can track their evolution, and the evolution of the discussions. * When an RFC is well received and the rust team wants to merge it, a PR is created in the ITC repo and the "Final Comment Period" starts. This should also be reflected in r/rust-rfc where a pinned comment designates it as in the FCP phase. When the FCP is over, the PR is merged and the proposal gets its official ITC designation and numbering. The RFC is then flagged with a (pinned) comment that links to the ITC it created. * RFCs that are not to be merged can either be ignored by the rust team, or dispositions can be given through pinned comments with accompanying FCPs, without any PRs being created. The lack of a PR and disposition (or a disposition other than "Merge") should signal to the community that the rust team is not anywhere close to approving this RFC. This way we have a better platform for discussion (reddit), and a clear separation between idle discussion (RFC) and serious-and-close-to-being-accepted proposals (PR/FCP, and ITC-repo). r/rust-rfc should be somewhat heavily moderated to only contain RFC discussions. RFCs are therefore identified by their reddit thread, and ITCs use today's numbering system. This also negates the need for "pre-RFC" as a regular reddit-rfc does not have the same official feel.
I tried to do the same thing and I had trouble opening raw sockets so I gave up, are you open sourcing this project? Would love to read the code
I'm not familiar with this language item myself, but it looks like it's not stable yet: https://doc.rust-lang.org/core/panicking/fn.panic_fmt.html
It seems like this is a breaking change for a feature available only on nightly (granted, it's a widely used feature that has been around for a while). Communicating this is a "breaking change" is a bit confusing, as it sounds like it affects `stable`.
Thank you!
This is only a breaking change for nightly users in no-std environments, which currently has stability guarentres. No one on stable will be effected by this. This announcement is mainly as a warning for people who are working in these environments that this has changed. The whole reason for this change is so we can stabilize this so embedded/no std environments can be 1 step closer to be viably programmed on a stable compiler.
The link to r/rust is a self link to the blog post. Nice one by the way! :) One question though: once `impl ops::Index&lt;FooIdx&gt; for Vec&lt;Foo&gt;` is defined nothing stops a user of a `Vec&lt;Foo&gt;` to index it with a `usize`, right?
LLD is one way, another is to use virtual machines: https://github.com/mcandre/tonixxx/tree/master/examples/bronze
A recursive `include_str!` won't compile.
Yeah, that's [true](https://play.rust-lang.org/?gist=0d6634bb5149eb6cf54a6dd5114f3bae&amp;version=stable&amp;mode=debug). Would be interesting to see if we can get some specialized optimization for Cows in the compiler. For `Cow&lt;str&gt;` and `Cow&lt;[T]&gt;` it migth be possible to detect that one variant is `(ptr, len)`, while the other is `(ptr, len, cap)`, and then shift the first variant it so that it is `(0x0, ptr, len)`.
&gt; This is only a breaking change for nightly users in no-std environments, which currently has no stability guarentres. Ah, great. I didn't see that this was nightly only and I've never used it before. Break away.
It would require annotations or whole-program optimisation. There's really no way to know that `ptr` and `len` are special. You could conceivably do it based on types and make `cap` a newtype just to enable this optimisation.
No -- you can use the knowledge that the pointer fields can't be null to differentiate the variants!
Correct me if I'm wrong, but shouldn't only approved RFCs get implemented in nightly? If that is the case, then the vetting must be done before the RFC is approved. It seems backwards to me that to vet a feature we need to get it to nightly, but to do so means we need to approve an RFC before its feature is vetted. This is not a critique of the process for which `impl Trait` was standardized. I'm just theorizing around how to vet stuff in the best way. Maybe we need a dedicated way to vet features without getting them into nightly. Maybe through more channels; for every feature the rust team wants the community to try out, create a channel specifically for it that people can try out? (I don't know whether this overloads the channel infrastructure) 
But that would be mutually exclusive with omitting the check when converting to `&amp;str`/`&amp;[T]`
I'm not sure I follow? Building the fat pointer shouldn't be a special case. The compiler needs to know where the pointer and the length fields are in the struct anyway, because struct layout is not guaranteed.
Awesome!
&gt; The link to r/rust is a self link to the blog post. This perfectly illustrates the point that creating A and B which reference each other is tricky :-) &gt;nothing stops a user of a Vec&lt;Foo&gt; to index it with a usize, right? Yes, that is correct. The [slab_typesafe](https://docs.rs/crate/slab_typesafe/0.1.2) crate handles that though!
I'm writing a Windows service using [ceviche-rs](https://github.com/wayk/ceviche-rs/). I'm also preparing a blog post on how we use rust code in a cmake build.
^The linked tweet was tweeted by [@gitlab](https://twitter.com/gitlab) on Jun 03, 2018 22:55:22 UTC (2193 Retweets | 2847 Favorites) ------------------------------------------------- We're seeing 10x the normal daily amount of repositories \#movingtogitlab [https://www.dropbox.com/s/uzg9vc5oljr8lin/Screenshot%202018-06-03%2015.52.52.png?dl=0](https://www.dropbox.com/s/uzg9vc5oljr8lin/Screenshot%202018-06-03%2015.52.52.png?dl=0) We're scaling our fleet to try to stay up. Follow the progress on [https://monitor.gitlab.net/dashboard/db/github-importer?orgId=1](https://monitor.gitlab.net/dashboard/db/github-importer?orgId=1) and [@movingtogitlab](https://twitter.com/movingtogitlab) ------------------------------------------------- ^^• Beep boop I'm a bot • Find out more about me at /r/tweettranscriberbot/ •
Have you ever used \`cargo doc \-\-open\`? I've found this to be immensely helpful when understanding my dependency tree, and you can search for items in the crates listed in your \`Cargo.toml\`.
RFCs are for consensus building. They’re not a spec. An RFC is approved, then implemented in nightly, then changes may be made, then stabilization happens. Nightly is specifically for vetting features. It’s not clear to me why a build of rust is easier than tossing a feature flag in your code; could you say more maybe?
To be clear nohing is clearly wrong. But this could renew the interest in _independant_ versioning systems 
It will compile because there are no ownership rules implied by raw pointer.
Very nice work!
Total safety would require a newtype wrapper around the Vec also, with Index\&lt;FooIdx\&gt; implemented on the wrapper. Then you'd need to re\-expose all the other Vec functionality. This is the big pain\-point of newtype in Rust. Defining a mapping from functions on an inner type to functions on an outer type is what Monads are for, so its probably not a coincidence the author of this blog post says they started off trying to explain Monads. \(They're like burritos.\)
But is it unsafe? Because if not it shouldn't happen.
While I don’t think we’ll be leaving git (or github) any time soon for open source projects looking for contributors, pijul is *super* interesting.
Of course, the project is open source but right now i only have the cmd argument parser and Tcp full scan functionality. 
That was mainly my goal while sharing this. Just talking about principles and efficiency of code versioning.
No worries, I am just wary as the mere mention of politics can quickly spiral out of control :)
Yeah, it's just annoying that it opens it in a browser, I just want to know where the src is stored so I can programmatically parse it to write editor plugins. I just found Racer though, which apparently operates on the source \(I thought racer was more tied to RLS &amp; integrated into the compiler\), so i'll be having a look at that.
To other readers: **I am not answering this question completely**. I know I tend to skip over questions that have a response so I want to avoid that :) &gt; First, is my Borrow implementation correct? I think where KeyA: 'a guarantees that lifetimes are correct, but I'm not 100% sure. I do believe that is correct, though I'm not expert enough to say definitively. Technically those structs should be `#[repr(C)]` (or better, `#[repr(Transparent)]`), but I don't *think* that matters for single-element structs. &gt;Second, how can I insert a KeyA into a HashMap and get a KeyARef back (whose lifetime would be at most that of the HashMap, obviously)? I don't believe this is possible (without manually converting after getting the value from the map). All the HashMap methods return values based on `K` or `V`. You may have to create a custom HashMap or a wrapper which deals in your handle types. An easy route to consider is to use `Rc` to give cheap immutable clones of your string key: https://play.rust-lang.org/?gist=bcf8107591fe199c7e49fbafbbd417a2 
&gt; Don't you think this applies to "suffering" and "pain" like mine as well? Of course! &gt; Is my preference less valid? No, of course not. 
No worries :)
I prefer branded indexing (as in indexing.rs) since you can eliminate bounds checks and it statically guarantees that your indices are in bounds (as opposed to just making it harder to screw up). But this approach is much lighter weight.
Apparently pijul's webui is not open source; I wonder why. https://nest.pijul.com/pijul_org/nest
FWIW there's also [loc](https://github.com/cgag/loc) which IIRC is even faster but is [less precise/correct in its classification](https://github.com/cgag/loc#known-issues). I prefer tokei but you know, just so you know.
What do you need help with? 
I used this with libpcap to actually get the packets . That might work for you 
Cases where the Option is *definitely* Some are exactly what unwrap is for.
&gt; RFCs are for consensus building. They’re not a spec. An RFC is approved, then implemented in nightly, then changes may be made, then stabilization happens. Would you happen to know if that's written down somewhere? Because in recent RFC discussions I have been told differently. E.g. "`?`/`catch` was accepted so `try` can't be relitigated" even though that original RFC was quite a while ago. Minimizing these kinds of mixed signals could go a long way towards reducing frustrations.
Its only unsafe to dereference raw pointers, because that's where the undefined behavior happens. Creating raw pointers is always safe (even if you immediately drop the referant).
Please leave a comment explaining what relevancy this has for readers of /r/rust .
Yeah, this does not have anything to do with git, just using a centralized service not under your control for essential workflow steps. The ideal world for me would be a federation protocol so users on Github could find and use my repo there, while it is also hosted on [Gitlab.com](https://Gitlab.com) and my private Gitlab instance, with seamless integration of issues, PRs and reviews between all of them.
Ah, okay, I thinking of this from a Rust user's perspective and not necessarily that of a plugin writer. :\) I hope you get the answer \-\- I'd love to see more happen in the dev tools ecosystem!
Seems like every Rust developer eventually struggles with (or enjoys) building cyclic data structure. :) What I did is I created a smart "reference" struct which keeps both reference to the data vector and index, so you can use it in a "object-oriented" way, like: root_ref.navigate("path1").navigate("path2").check_some_property, where "navigate" transitions from one node in tree to another (in my case, it was going down the type information tree). This struct Deref's to the "NodeInfo" structure and also provides a function "navigate" (both of which uses data vector to resolve next state). 
Very informative. I'm going to have to use this guide the next time I am deploying to windows \(which will be within a month or so hopefully\). I like the idea of using Wine as a "good enough MVP" to check that things *roughly* work :\)
No, that's not true. Almost all of the Makefile-related code in the repo is the pre-expansion, pre-autogeneration code - configure.ac, Makefile.am, etc. The Makefile.in and Makefile contents aren't stored in the repo, and that's good, because the number would be WAY higher than 3% (and note another 2.5% of the code is m4, which is only ever really used for autotools these days).
It's basically been a "stable" feature for a large swathe of the embedded/no_std group
Honestly, that's not something which bothers me. GitHub isn't open source either, yet tons of people \(including myself\) use it. They say they *might* open source Nest at some point, which is better than GitHub's plan to never open source their website. Maybe Microsoft will change that now, but either way, it's no*t wor*se than the status quo, at least.
How did you get these statistics?
https://github.com/rust-lang/rfcs#what-the-process-is
This is what i ended up doing it is ever so slightly more efficent than going the Option\&lt;\&gt; route. Compiler output of both variants \(dummy code\): \([https://godbolt.org/g/MTxDbJ](https://godbolt.org/g/MTxDbJ)\) 
`tokei`
Thanks! &gt; I mean, they could be re-litigated, but if the team isn't interested in doing so, then there's not much point. you know? Well, sure, but if there's discussion about "if there's no consensus maybe wait?" and that's shut down by the lang-team-affiliated author of the RFC via "other RFC $X was accepted so that's done" that's very discouraging.
What happens if you only want to raytrace one sphere and one plane (for example)? Or in other words, why did you use simd to intersect one ray with multiple spheres, instead of multiple rays with one sphere?
Yes sadly it is not obvious to LLVM \([https://godbolt.org/g/WwB9rd](https://godbolt.org/g/WwB9rd)\) but the cost should be minimal.
This week I'll be releasing the next version of [tarpaulin](https://github.com/xd009642/tarpaulin). I just need to figure out some parts of deploying it do a few more stability tests and then I'm ready to go. Also, I might use this chance to get back to some of my rust embedded stuff I'm working on as I've let that slide recently.
Cloned the repository, checked out the relevant revisions and ran Tokei.
The next step would be to implement the Syn scan type. So with a normal tcp connection you have the three\-way\-handshake with syn, syn\-ack, ack. I achieved the normal connection with std::net but now i would like to send the syn packet to a port and wait if i receive the syn\-ack and then drop the connection. I can not implement this with the std::net. If i got this right it should be possible with the libpnet library. 
So what you're saying is that the idea I was working on would basically just be reimplementing rust's async/await? I need to experiment some more with that. Do you know if async can be used without await, like if your send a request but don't actually need the result?
Very cool! Thx!!!
Thx and Github doesn't offer these statistics?
You know, stability guarantees might be nice when working with embedded and bare metal. Too bad stability is only available for people with an OS. It really sucks that a large portion of people using nightly don't care at all about the unstable features and only want no\_std. When you're forced into using nightly though, you just tend to use features like nll just for convenience more than anything.
It will probably never be stable, because unless you're writing no\_std executable or c library code, you really have no reason to use it. For those of use who are, it's impossible to *not* use it.
I got tired of my slow prompt so I wrote this one. It was a lot of fun and it's already faster than what I had before. I'm already using it and I'm very happy with it. I know the code isn't the best there, but I just wanted to get something out that I could use. I'd appreciate any feedback.
I think I you need to create a tcp channel. And use the sender. Then create a tcp packet and set the flag to syn. Then send it on the sender channel. Then read from the receiver 
/u/phil-opp is there a video by any chance?
As far as I'm aware, `lang_start` doesn't do any magic other than marking itself as the entry point for code execution. So the only bits of the runtime that it sets up are the ones that you explicitly see it setting up in the code. 
Fun fact: this is [exactly how petgraph works](https://github.com/bluss/petgraph/blob/7efabcac0a1d6bc6ae7322f26501988a47e290d4/src/graph_impl/mod.rs#L89)
The whole point of this change is to create a stable mechanism for #![no_std] folks.
Learning to use `ggez` to make a game
It will very definitely not be stable because #[panic_implementation] is what will be stabilized in its place.
The software is on a hosted gitlab, not github. That aside, both Github and Gitlab provide code statistics, but they're very rough (just percentage): * [on github](https://github.com/GNOME/librsvg) you can click the colored bar (between the description &amp; buttons) to get a breakdown * [on gitlab](https://gitlab.gnome.org/GNOME/librsvg/graphs/master/charts)
I really like the idea, but I can't risk it because I use git integration but specifically chose *only* to display the branch name in the prompt for performance reasons and, as you wrote: &gt; Since it checks for untracked files, it might be slow in big repositories. All placeholders are precalculated when the integration is triggered, regardless of being used.
In Kotlin you can have abstract fields in interfaces that must be overridden by implementers: ``` interface Foo { val count: Int } class Bar(override val count: Int) : Foo ``` Has there been any effort to add similar funcionality to Rust traits? e.g. ``` trait Foo { count: u64; } struct Bar; impl Foo for Bar { count: 500 } ``` I find myself often emulating this using functions: ``` trait Foo { fn count() -&gt; u64; } struct Bar; impl Foo for Bar { fn count() -&gt; u64 { 500 } } ``` This isn't a huge deal on its own, but when your trait has ten different properties it becomes painful and feels redundant.
I have a struct Foo that is usually behind Rc and RefCell. From one function I want to return a HashSet. I have custom Hash and PartialEq functions (I don't use the derive macro). impl Hash for Foo { fn hash&lt;H: Hasher&gt;(&amp;self, state: &amp;mut H) { self.id.hash(state); .... } } impl PartialEq for Foo { fn eq(&amp;self, other: &amp;Foo) -&gt; bool { self.id == other.id .... } } When I try to declare my return variable with the line let ret: FnvHashSet&lt;Rc&lt;RefCell&lt;Foo&gt;&gt;&gt; = FnvHashSet::default(); I get the error: The trait `std::hash::Hash` is not implemented for `std::cell::RefCell&lt;Foo&gt;` I've tried a few things. I tried to implement `Hash` for `AsRef&lt;Foo&gt;` but ran into the issue that I can't implement traits I haven't defined for types I haven't defined. I also tried `impl&lt;'a&gt; Hash for &amp;'a Foo`. What impl am I missing?
&gt; Honestly, I would advocate reverse-engineering what it sounds like is a disaster of a library that you're trying to bind. And reverse engineering may actually be surprisingly simple for this. Just watch what it's doing in wireshark, and it may be a fairly simple USB HID protocol.
Cool, thx! :)
Though, to be more honest, he would have compared the amount of bugs per kloc in Linux to the amount of bugs in [Redox-os](https://github.com/redox-os/redox/issues/1136).
Hmm, I swore I saw warning messages about it being ignored at some point in the past...
&gt; i wouldn't recommend dealing with ffi as a way to learn rust I don't disagree. I was at the point of Project Euler becoming boring and decided to try something else. &gt; i also wouldn't do an incremental rewrite of a c project in rust unless there were distinct subsystems that i could port all in one shot. This is sort of the case. There's a set of functions accessing this field (init/free, check key presence, get a value, insert a value, etc). I want to port (well, rewrite to use Rust's `HashMap`) them all at once. &gt; &gt;I can not come up with a proper type for the vals field &gt; &gt; what is accessing this field? i'm not at all clear about this. is all the logic in rust? is some in both c and rust? A set of functions that I want to port to Rust. 
That works for me, thanks for your help. 
A good place to keep up with embedded stability is the working group's repo. One of the issues is titled ["embedded development on stable"](https://github.com/rust-lang-nursery/embedded-wg/issues/42), which lists current goals and progress (including ``#[panic_implementation]``).
Somehow the need to resort to integer indexed data structures to avoid cycles feels like a weakness of Rust's type system or stdlib. Essentially this is providing a sort of weak reference that won't count as creating a cycle. The integer index is analogous to a traditional Rust reference which provides an index into a memory region. By being constructed dynamically the possibility of the reference becoming invalid is introduced---we now have the possibility of a "use-after-free"ish situation, except that the backing `Vec` will panic when you try to make an invalid "dereference". But with regular references such a possibility never exists---the problem will be identified at compile-time. let mut x: Vec&lt;u32&gt; = vec![ 5, 6, 7 ]; let a_idx = 0; let b_idx = 1; let c_idx = 2; x.remove(2); let a = x[a_idx]; let b = x[b_idx]; let c = x[c_idx];//Oops, invalid "reference" println!("{}", a); println!("{}", b); println!("{}", c); Could a non-reference-counted weak reference be introduced into the type system that would obviate the need for these sorts of workarounds? let weak ref a = 5; let weak ref b = 6; let weak ref c = 7; println!("{}", a); println!("{}", b); println!("{}", c);
Let me spin it into a more concrete question. To be clear, The C code initially is not my. I just picked it to try and convert some code. Consider this function: ``` pub extern fn my_hash_set(hash: my_value, key: my_value, val: my_value) {} ``` `my_value` looks like this in C (don't ask why): ``` typedef struct my_value { union { void *p; my_int i; } value; enum my_vtype tt; } my_value; ``` Or like this in Rust: ``` pub union PackedValue { pub p: *const libc::c_void, pub i: my_int, } pub struct my_value { pub value: PackedValue, pub tt: my_type, } ``` So `my_value` is a wrapper that is passed around by value. It can represent different things but for whatever reason original authors decided it's a good way to represent a few different things. The API function gets this by value and inside of it there's a pointer to a struct (`p` field). Behind that pointer is `MyHash` struct with a `values` pointer field. How do I unwrap this all into a mutable reference to a HashMap so that I could insert into it?
The slide 18 mutex example is bit disingenuous considering that the whole RAII idiom comes from C++. While I'm not going to pretend that writing thread-safe C++ is as easy as Rust, it can be lot better that what shown here.
Even if you do protect your data with a mutex in C++, it cannot prevent the pointer in the mutex from living past the point where the guard is destroyed.
The point of these slides wasn't that Rust leads to fewer bugs, but that vulnerabilities caused by memory safety violations are still common, even in hardened projects such as Linux. 
I mean I hate cpp, but you can bypass the RAII and leak memory too in rust.
Why not just use Weak?
The talk was recorded, but the video is not ready yet. However, the talk was in German, so I'm not sure if it is useful to you.
is the `HashMap` in `values`? is it also a `*const c_void`? if so, it should be approximately: let mut hash_map = unsafe { let my_hash = (hash.p as *mut MyHash).as_mut().expect("p ptr was null"); (my_hash.values as *mut HashMap&lt;T, U&gt;).as_mut().expect("values ptr was null") }; let _ = hash_map.insert(a, b); 
Because the spheres are constant but the rays are bounced randomly off surfaces when there's a collision. The rays are kind of serially generated right now.
Ok but that is more instructions than what I currently have and right now I'm optimising for speed. If I can allocate my float arrays 32 byte aligned then I can just use a chunk iterator based on the simd width and I know the input data has the correct alignment, so that seems like the simplest solution right now, should be able to do that with the unstable allocator API.
Hi thanks for your questions! I'll take this over to PM/email.
Do I still use `Box` to put HashMap into `values`? ``` my_hash.values = Box::into_raw(Box::new(HashMap::new())) ```
To be fair you must compare the same thing. Leaking memory is harder to take and less danger in rust than accessing invalid memory in cpp.
Can a moderator tag this as not affecting stable rust? I see I'm not the only one that was confused and worried.
Ah too bad, I don't speak German unfortunately.
Take a look at this post: https://exyr.org/2018/rust-arenas-vs-dropck/, it explains how to create cycles using only references. So, no, looks like we don't need any additional language features :) &gt;Somehow the need to resort to integer indexed data structures to avoid cycles feels like a weakness of Rust's type system or stdlib. At least in my experience, cyclic data structures are hard in any language, and I often find it convenient to use indexes even in Java. A interesting real-world example of problems with direct references is, for example, JSON. When designing API payloads, one often starts with a natural tree-structure representation of objects. And when that tree structure suddenly turns into a DAG, things get weird because you just can't express that in JSON at all (and don't even mention backwards compatibility requirements of API)! That I think why http://jsonapi.org/ suggest using a flat lists of objects with indices instead of direct embedding. 
Still not helpful.
If you are GREAT with at least one of those languages, as in people come to you for help with them, then go ahead and try rust. It's really intimidating at first, but I'm doing fine so far. Take it slow.
I'm not sure if I understood you correctly, but you could spawn the future via the executor so that it runs independently.
Thanks so much!