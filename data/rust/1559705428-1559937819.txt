A followed standard is always better than no standard.
follow github of big company like Alibaba, Alipay, Baidu, Tencent etc... and their cloud services: Aliyun, Tecent Cloud, Baidu Cloud... is a good start can also start reading Chinese tech community with google translate: - https://www.oschina.net/ - https://gitee.com/explore -&gt; their own github Things to note: - Chinese tech culture has been vastly different than the west: instead of wide spread of users data centers, Chinese have concentrated population density with a monolithic culture. This leads to extreme high user concurrent peak since the very early days of the internet. "Viral" is a different scope, different number when it come to China. - A lot heavy emphasis on Java eco system due to all tech giant Alibaba, Tencent, Baidu use it. They also have their own flavor vs the West such as Mybatis is used in favor of Hibernates... - RPC api is popular, but not Thrift or gRPC but Dubbo. I can go on but this is not the appropriate thread to discuss this
when we compile wasmbingen programs with cargo it takes very long time, but with its webpack tool the same things compile at super speeds, i was banned by Mozilla from their github group for mentioning this. what could be the reason for such epic speed differences ?
I think they largely boiled down to: 1. This wouldn't work for multiple producers or consumers 2. This structure could be cache-unfriendly Regarding point 1: It is a SPSC queue, and both implementations use Rust's ownership system to enforce that through ownership of the Producer and Consumer halves. Regarding point 2: I have no idea, my implementation (BBQueue) is intended for use with embedded systems (bare metal microcontrollers), which do not typically have CPU cache, and even when they do, it tends to be less costly than IPC synchronization on multicore systems. Andrea would have to comment regarding the impact on high performance systems elsewhere.
Are you looking for `&lt;back::Backend as gfx_hal::Backend&gt;::ShaderModule`?
&gt; It's simple, maybe a bit inefficient (if you keep polling this, assuming you have no other work to do). Constantly polling is _very_ inefficient; its a massive waste of CPU resources. The main idea of async is to relinquish control of a thread, potentially putting it to sleep, until your async operation may actually be complete. Rust futures model this very closely. A future itself is the means of checking the state of some operation, while wakers are used to control the "event" side of things. The interesting aspect about Rust futures is that it reverses the model of a traditional event loop. For example, in Node.js there's _the_ event loop (powered by libuv) which is responsible for _all_ events. In it, there's a central loop that runs, polling for state changes, then going to sleep until an interesting event wakes it up. With futures, the state is stored in the futures themselves, and wakers abstract away the "wake me up later" part of an event loop. Why do this? Well for one, it means that you don't need one event loop to rule them all. Since Rust has great thread support, you can create 1 thread for a timer loop, 1 thread for an I/O loop, and so on. Each of those threads only have to worry about multiplexing one kind of event, but futures for any kind of event can be chained together. Or you could go with a single threaded master loop, it's up to you. Either way, the efficiency of async usually comes from the ability to multiplex N logical "tasks" of some sort using M threads, where M may be 1, or at least M &lt; N. &gt; This means that you essentially have to spawn a new thread just to get a simple timer future Not necessarily, you could write a single-threaded executor that knows how to manage N timers, and then run it forever on the main thread. That's the nice thing about wakers, is that its up to you.
Hey! I did know about Dragonfly and Pocket and some of the things around that section of the ecosystem, but that's only because I went really deep into Container Runtimes. And I actually found the same, that there was a TON of Kubernetes/Docker-adjacent tech that none of my contemporaries had heard of. Anyway, this is excellent. I think if you were to write up something and publish it, you could get a ton of attention on HN and Reddit. I think that many American developers are ignorant, but at least in my case, it was unintentional. Thank you for taking the time to share some pointers about how to stay informed!!
Digital can mean any currency , even gold certificates, not just crypto.
it's importing: #[cfg(feature = "vulkan")] extern crate gfx_backend_vulkan as back; so I assume the full type name is gfx_backend_vulkan::resource::ShaderModule (or whatever feature I used when building it)
Right, but `back::resource` doesn't exist as far as I can tell. If you want a `ShaderModule` type, use the associated type from `back::Backend`, or just make your function generic over different backends.
https://dci.mit.edu in case anyone as I wandered
Good question! You are right, normally it should be dropped at the end of scope and thereby not necessary. However the function is marked as inline. Maybe that means no scope is introduced and the value would only be dropped at the end of the parent functions scope without an explicit drop, which would be unexpected? Might be something to investigate.
Oh I see what you posted was actual syntax (that worked). what confused me then is how did you figure that out? the error message I got as about back::resource::ShaderModule being the returned type which there seems to be no public documentation on
I see what you posted was actual syntax (that worked). what confused me then is how did you figure that out? the error message I got as about back::resource::ShaderModule being the returned type which there seems to be no public documentation on Is there some documentation for that syntax? It seems like you're casting a module somehow? Trying out a few different forms to see how that syntax works and it's not obvious, I can't return a type gfx_hal::Backend::ShaderModule directly and cast it inside.
Yep, futures make it easier for users to maximize their system performance, but not necessarily their thread's performance.
FYI, Here is a little helper that integrates the generation of Rust code from FlatBuffers schema (flatc execution) into the build step: https://github.com/frol/flatc-rust
That's super cool. I will read more into it : ) Still a bit of a newbie to rust myself but this kind of thing makes it more attractive by the day.
Can someone with experience with both rocket and actix-web give a quick breakdown of the advantages of each framework?
Yeah, the error messages for that kind of thing can be sort of confusing. It's pretty safe to assume that a library like gfx doesn't have any permission typos, so if you're getting an error about importing a private module, you're probably importing the wrong thing. The way I figured it out: 1. Finding the [complete code](https://github.com/gfx-rs/gfx/blob/master/examples/quad/main.rs) for the example you're talking about 2. Go to the [crate documentation](https://docs.rs/gfx-hal/0.2.0/gfx_hal/) and [look up](https://docs.rs/gfx-hal/0.2.0/gfx_hal/?search=ShaderModule) the type in question, `ShaderModule` 3. See that `ShaderModule` is an associated type for the trait `gfx_hal::Backend`, which means we'll need to find some type which implements that trait 4. Figuring out which module `back` was (in this case, it's one of many modules, which all have a `Backend` enum visible in the root module, you can see this by looking at the docs, [1](https://docs.rs/gfx-backend-empty) [2](https://docs.rs/gfx-backend-vulkan/0.2.1/gfx_backend_vulkan/) [3](https://docs.rs/gfx-backend-gl/0.2.0/gfx_backend_gl/)) 5. Use the associated type `ShaderModule` of the enum `back::Backend`, which implements the trait `gfx_hal::Backend` `ShaderModule` is an associated type, that is, it's not really a type, it's more like a type variable that is set depending on what kind of backend you're talking about. So `gfx_hal::Backend::ShaderModule` isn't a type, it's a spot for you to specify a type when you're implementing `gfx_hal::Backend`. If you want to talk about a specific type, you also need to be talking about a specific backend, or be generic over all backends. Normally you would just be able to use `back::Backend::ShaderModule`, however, because `back::Backend` is an enum, we have to be explicit that we want the associated type from the `gfx_hal::Backend` impl.
ProtocolBuffers is likely the most widely used.
https://www.reddit.com/r/rust/comments/ai6xra/actixweb_vs_rocket/
What bothers me alot in current flatbuffers implementation for Rust is the absence of any error processing. I've tried to read the code some time ago and I've re-read parts of it today. Sill I could not see any kind of tries to handle any incomplete/incorrect data, like wrong sizes(i.e. put intentionally by some evil side). There's some unsafe code, mostly about pointer conversions (they scare me as well), and some asserts, but zero Result types used. I wasn't very deep in the flatbuffers spec itself, but I guess there will be mostly panics in any incorrect data provided for decoding, which may be inapliccable in many real-life cases and code, that wants to be safe. I'd d be happy to be wrong here, and will be much happier if someone proved me I'm wrong. But as of now, I'm really scared about using this library in any way.
I've found rocket \_much\_ easier to use. Actix makes me feel stupid and frustrated every time I try to extend the example code.
check out https://github.com/sofastack/ if you are interested in service mesh
Code node 18th june: https://www.meetup.com/Rust-London-User-Group/events/262000795/?joinRsvpYes=true
A long time coming! I'll need to update my [blog article](https://cetra3.github.io/blog/face-detection-with-actix-web/) to reflect the official release. Very happy with actix web so far. `0.7` has been rock solid [in production](https://www.schoolbench.com.au/)
The developer removed the CSRF middleware in the readme file. Is it not needed anymore?
Personally I really enjoy working with the FlatBuffers schema, much better schema than Protobuff imo... However the eco system for flatbuffers is just way too limited. I assume this is because most usages are within FAANG's internal low level infrastructure and cannot be open-sourced.
See https://gist.github.com/Matthias247/ffc0f189742abf6aa41a226fe07398a8. &gt; the IOCP model kind of demands that you give it ownership of some buffer In the readiness model, you express interest in reading something from a socket, block for a while, then the OS wakes you and says that yes, now you can read from that socket. So when you read, you can do so with a mutably borrowed buffer. In the completion model (IOCP, but not only), you tell the OS "read me some data here", go to sleep, and you find your data in the buffer when you wake. That means you can't touch the buffer needs to be valid during your sleep.
You want r/playrust buddy. This is the Rust Programming Language subreddit.
Sure, but the point would be to allow the underlying Piston library implementation to override and filter those events. This way, this functionality could be _transparently_ added to the library without needing to access the window specifically. Since Piston emits the events, it can filter them, too. :)
Sorry about that
I'm having a blast writing this library, and I'm not going to stop any time soon! I have plans for a GUI editor and possibly a way for the GUI editor to be used inside IntelliJ and other editors as a companion to Rust apps. This is going to be great!!!
\&gt; easier for users to maximize their system performance, but not necessarily their thread's performance. what impact will this have on mobile devices ?
Rocket is undeniably much easier to use and I find the it's examples in the page easier to understand. That being said, the fact that actix works on rust-stable is great on the maintainability side. I've had a lot of trouble dealing with updates of rust nightly when I used rocket (about 2 years ago, things might have changed). Also, actix-web being async ready means that it's impressively quick if you expect a high workload.
&gt; I've had a lot of trouble dealing with updates of rust nightly when I used rocket (about 2 years ago, things might have changed). They did, Rocket users should now encounter practically zero breakage on toolchain updates.
Is there a porting guide? It seems the application factory function is not needed anymore: [https://github.com/actix/examples/blob/master/state/src/main.rs](https://github.com/actix/examples/blob/master/state/src/main.rs)
Great! Do you know when the documentation (here: [https://actix.rs/docs/getting-started/](https://actix.rs/docs/getting-started/)) will be updated according to the new API?
I've looked at this project over and over again and find the current state of documentation and the attitude in general to documentation very frustrating. Since other people find the project "approachable" i consider that the problem is not just them, i don't know.
A niggle I would personally have is that if status.is_err() { Is more readable than if !status().is_success() { Which can make a difference in comprehension when quickly scanning over the code, as the ! is easy to miss.
Probably similar to the situation on desktop? Both threads will sleep, and that's pretty efficient compared to constant polling.
Huh! Can't believe after an hours of trying every signature I could think of this one didn't cross my mind. Thank you!
Yes thank you!
Agreed on dropping the : after the arg name. However, [f32] is really a float*, not a slice, even though it looks and acts more like one than a pointer in Rust, which can not be indexed. So with a new / different paradigm comes a new syntax. Global and local args could be declared with a keyword, ie myfunc(global y [f32], local tmp f32). I would assume the author chose this as the simpler solution. I wish, had hoped that this would be a way to write Rust code that can also run on gpu / parallel but it's more like a simplified flavor of opencl that just looks more like Rust.
It's not clear what you mean here. The Rust compiler includes LLVM for code generation, and on some platforms linking. It's built into the compiler. Are you thinking of building the `rustc` compiler against an older version of LLVM? This is unlikely to work, because LLVM APIs and IR is not compatible across major versions. Furthermore, I believe the version of LLVM included in `rustc` is a [light fork](https://github.com/rust-lang/llvm-project) of LLVM with minor modifications (potentially). Perhaps it would help to know what you are trying to achieve?
I'd think the documentation would be part of the 1.0 release.
Even without any panic, running `Drop::drop` on a generic type can run arbitrary code and give it a reference to the inside of a `Cell`, which breaks `Cell`’s invariant. (The code could call `Cell::set` through a `Rc` cycle for example, and invalidate the reference.) So it is important to use `replace` and drop the old value after it was moved outside of the cell, rather than the simpler `unsafe { *self.get() = val; }` which would drop the old value in place. This is what this explicit `drop` call is trying to convey.
No sorry, I don't know of any such resource. I've no CS background, but I've dabbled in quite some programming languages before rust (I'm not _that_ young...), so I did not need an introduction into programming concepts. I have a nagging thing in my head that says that at some point in the past, someone wrote a book (as in mdbook) with exactly that in mind, that it was well received, but sort of vanished later on (maybe it was taken off the net and deadtree'd?). I can't find it anymore, but if you ask in a larger context, maybe make a new post on r/rust, maybe someone else remembers. Sorry, that's all I got for this!
And where's the proof?
There is [migration.md](https://migration.md) in root of repo.
Good news everyone! :)
The main challenge is getting comfortable with futures. As long as grasp the Tokio/futures stack actix is pretty sensible and you can figure out what to do. But otherwise I agree. There are very few examples both in the examples directory and in the doc comments. Also publishing 1.0 without updating the book is quite a weird choice IMO. Rocket has much, much better documentation., But runs on a ancient version of hyper and is nightly only. I'm mostl using actix for now, but once rocket switches over to the tokio stack and is on stable, I'll use rocket for new projects again.
Thank you.
Seems like an artificial limitation. I’m sure if this were a priority price macros would be relatively easy to make work in the same file.
how long will you fight us, our win is imminent, since INCOMPETENCE HAS NO PLACE in software development.
See the discussion in https://gist.github.com/Matthias247/ffc0f189742abf6aa41a226fe07398a8.
We've been using rocket since August 2018, but active development is going since the last month only. Till now we still have 0 breakage. And we update creates almost every day. So, from our prospective it looks stable
I wonder how this would compare against a concurrent SliceDeque implementation, like the one shown here: [https://www.mikeash.com/pyblog/friday-qa-2012-02-17-ring-buffers-and-mirrored-memory-part-ii.html](https://www.mikeash.com/pyblog/friday-qa-2012-02-17-ring-buffers-and-mirrored-memory-part-ii.html) It only needs relaxed atomics for correctness.
The big change was the Rocket 0.4 release, which dropped the compiler plugin feature.
I used to think that \`Cell\` was only for types that implement \`Copy\`, but then I looked into the docs and saw that only \`Cell::get\` and \`Cell::update\` require the \`Copy\` bound. Interesting.
The Travis-CI config for `rust-lang/rust` has a job named [`x86_64-gnu-llvm-6.0`](https://github.com/rust-lang/rust/blob/1.35.0/.travis.yml#L23-L25) that runs the test suite, so it looks like PR cannot land if they break something with LLVM 6. So 7 is likely fine? IIRC this scenario is somewhat supported because some distributions want to use their existing LLVM packaging rather than ship another one.
\&gt; Is this possible? &amp;#x200B; This is possible. Most Linux distributions do this. &amp;#x200B; \&gt; Would there be regressions? &amp;#x200B; Yes. Rust releases are only really fully tested against the bundled LLVM version. There are a couple of build jobs that test the "minimum supported LLVM version" (LLVM 6 or 7 at this point), but basically all test for the language and the library that require newer LLVM versions are not run in those build jobs. If you try to use some of those features, in some cases you get a workaround for older LLVM versions, in others a proper error, but in most cases rustc or LLVM will just crash. That compilation fails is not really tested, so there might be cases were you just get incorrect code generation. LLVM continuously fixes code generation bugs, e.g., LLVM 8 fixed a bug where the \`llvm.minnum\` intrinsic returned the maximum instead of the minimum... no errors were produced there...
I was supposed to write one for the last.... few years. Sigh. Always so much to do.
Good to know! Once they have a better async story I might take a look again!
&gt; The safe thing to do here is to always choose Ordering::SeqCst, "sequential consistency", which provides the strongest guarantees. On x86, due to the hardware design, anything other than Ordering::Relaxed is equivalent to SeqCst. On ARMv7/v8, things get more complicated. This is correct -- however, without context it is dangerous advise. While on x86, "Relaxed" and "Release"/"Acquire" are the same, that does *not* mean that when compiling Rust code to x86, they are the same! Before generating assembly, the Rust code gets optimized by the compiler, and there, the modes still do make a difference, for any target architecture. So, Rust code that argues based on "we are compiling to x86, hence we can use this mode" is just wrong. Similarly, Rust code that argues "we are compiling to x86, hence we can do unaligned accesses" is wrong -- every memory access through a `*mut i32` must be 4-byte aligned on any platform, and violating this is UB, because the optimizer relies on this. When arguing about Rust code, you have to argue based on the Rust semantics, which is unfortunately [a lot weirder](https://www.ralfj.de/blog/2018/07/24/pointers-and-bytes.html) than the semantics of the actual hardware. That is the price we pay for getting our code optimized.
That's [on the roadmap](https://rocket.rs/v0.4/news/2018-12-08-version-0.4/#whats-next).
Oh hey, you wrote the ruby one didn't you?
The problem with changing this is that success here is not the opposite of error. Http status code have 5 categories: informational, success, client error, server error, and redirect. A method `is_err()` could only reasonably apply to server error and client error. If the code were saying `!is_ok()`, I would agree with you, but in this context "success" is not synonymous with "not error"; it also means not a redirect and not informational. In my opinion, `!is_success()` is about as succinct and clear as you can get.
`notify` could be written out as: pub fn notify&lt;T: Summary&gt;(item: T) { println!("Breaking news! {}", item.summarize()); } That is - the argument type is any type `T` that implements `Summary`. So if you call `notify(breaking_news)`, then `T` is `NewsArticle` - it implements `Summary`, and also the value is moved into the function. If you call `notify(&amp;breaking_news)`, then `T` is `&amp;NewsArticle` - this type doesn't implement `Summary`, and that's what the compiler error says. If you want the function to borrow the value instead of moving it, then declare it like that: pub fn notify(item: &amp;impl Summary) { println!("Breaking news! {}", item.summarize()); }
Thank you Do you thinks it is a good idea to rewrite routine csv handling code from python to rust?
Thanks a lot for your answer and the useful link
Trying to port code from 0.7, I'm getting: unresolved imports `actix_web::middleware::Middleware`, `actix_web::middleware::Response` Middleware link in migration guide leads to 404: https://actix.rs/actix-web/actix_web/middleware/trait.Middleware.html
During the past month I was doing a project with Actix beta then RC, and the only “documentation” was here: [https://github.com/actix/examples/tree/master/](https://github.com/actix/examples/tree/master/) Very helpful.
I don't recognize this Reddit account as the author of Actix, who should have made the announcement rather than some rando. You're selling short the changes made since 0.7.
I still personally prefer rocket but any crate hitting 1.0 is a case for celebration 🥳
&gt; Rocket is undeniably much easier to use I'd say It's really a matter of personal preference, personally when I tried rocket I had issues to grasp how everything went together, whereas with actix everything clicked instantly. YMMV
Fair enough. My opinion is mostly from someone used to deal with Spring in Java, to be clear.
Over time, I've come to the conclusion that documentation quality is a really subjective thing and it looks like this is what's happening here. When I tried rocket, I found the documentation really verbose and convoluted, and I had much troubles grasping how things worked together. On the other hand, I loved the actix doc and the depth of the [example directory](https://github.com/actix/examples) with real world examples (how do you work with reddis or diesel, how do you handle CORS, how do you deal with websockets) all of this being non-existent in the Rocket documentation or examples. I guess it's really hard to make a documentation that makes everybody happy.
\[co-author here\] That's a good point, thanks for your comment. I can see how one can interpret that sentence and think we mean "semantically equivalent", where what I meant was "the different levels can't be expressed by x86 and are equivalent at the hardware level". You're absolutely right the optimiser can make use of this information. I'll edit that sentence to clarify. &gt; When arguing about Rust code, you have to argue based on the Rust semantics, which is unfortunately [a lot weirder](https://www.ralfj.de/blog/2018/07/24/pointers-and-bytes.html) than the semantics of the actual hardware. That is the price we pay for getting our code optimized. I'm going to print this out and frame it.
Nightly compiler = no go for production. The breakdown ends here.
Yep!
I can't comment on any organisational reasons that you may have not to (for instance, not many people knowing Rust). But from a technical perspective: absolutely. /u/burntsushi's `csv` library is a joy to work with, and this a task that is quite easy to achieve in Rust (you're unlikely to trip over any difficult ownership issues), so you more or less get Rust's excellent performance for free).
\[Andrea (co-author) here\] &gt; Regarding point 1: It is a SPSC queue, and both implementations use Rust's ownership system to enforce that through ownership of the Producer and Consumer halves. Yes, and this code would certainly break if there were multiple producers: we're relying on the fact this is spsc to simplify things a bit and benefit from the lock-freedom. Writing a lock-free mspc is a more complex problem that may not outperform a lock-based implementation, depending on the workload. &gt; Regarding point 2: I have no idea, my implementation (BBQueue) is intended for use with embedded systems (bare metal microcontrollers), which do not typically have CPU cache, and even when they do, it tends to be less costly than IPC synchronization on multicore systems. Andrea would have to comment regarding the impact on high performance systems elsewhere. At least one of the two implementations, `spsc-bip-buffer` (https://github.com/utaal/spsc-bip-buffer/blob/master/src/lib.rs#L8-L10) has cache-aligned, non-aliased "atomics": ```rust struct BipBuffer { buf: *mut u8, len: usize, read: CacheAligned&lt;AtomicUsize&gt;, write: CacheAligned&lt;AtomicUsize&gt;, last: CacheAligned&lt;AtomicUsize&gt;, } ``` I did leave `CacheAligned` out because it didn't feel super-important for the purpose of the post. I'll consider adding a note that the benefit of each thread having exclusive write access to a coordination variable may be lost or reduced if multiple `AtomicUsize`s are on the same cache line. The performance implications of cache alignment/cache friendliness are not exactly cut and dry: it seems generally true that you'd want to keep the three "atomics" on different lines but I've run a few basic experiments on a 4-yo Xeon and (unsurprisingly) things are different depending on where your threads are running (same physical core with SMT/HyperThreading, two cores sharing an L2 (often same numa node), two cores on different nodes (not sharing a cache)). I'm a bit short on time this week but I may try to put together some numbers.
Btw, `&amp;Summary` / `&amp;dyn Summary` is enough - no need for an `impl` there (since all pointers to all traits are always of the same size).
Swift structures are copy-on-write types, which are allocated on the stack(usually, if it does not store class references). All SwiftUI types are structs conforming to View protocol(trait). So it’s much like React but without need to trigger global reducer, because of structs logic(methods that modify the instance are marked as mutating and can only be called on mutable structs(var or let mut) which trigger the observables. So I think that these patterns can be applied to some GUI framework written in Rust.
\[co-author here\] polyfractal's numbers were my benchmark for [https://github.com/utaal/spsc-bip-buffer](https://github.com/utaal/spsc-bip-buffer). bounded-spsc-queue has around 3x the (message) throughput of spsc-bip-buffer (they do 50m, I've measured \~15m on a 4-year-old Xeon, \~20m on a Core i7). The reason I believe this is independently useful is that bounded-spsc-queue shines for fixed size (small?) messages, but we often encounter variable length byte slices (both in embedded and data processing), and being able to reuse the same allocation relieves the pressure on malloc and may have better locality. More importantly, it's often important to have a stable allocation for dma purposes. To clarify: my understanding is that you'd need to enqueue/dequeu owned heap memory (Vec, or equivalent) to support variable length messages in bounded-spsc-queue (there's probably efficient ways to do this). As mentioned elsewhere, if I have the time I'll publish more detailed perf numbers.
CSRF is not a problem anymore, use samesite cookie attribute.
`? ` is an exit point of the function, you have to look for it anyway
interested, got any idiomatic example usecases code you can add to the readme or docs?
Certainly, it was a point I was hinting at, but Linus has a lot of sway and while it's very desirable I don't think it's going to happen. Developer energy being so fragmented isn't a good thing but unavoidable sometimes due to design decisions.
Any words on if they plan to add an ORM with migrations?
Is it possible to edit FlatBuffer documents in vim or another gui?
There's a lot of places in my code where it doesn't deal with errors such as api typo in table names, i just let it panic and plan to do it later. I've used rocket and hyper for these and if there is indeed a typo in the calling the api, your server side application just goes down. I tried to use actix-web, I'm surprised that panics are handled very well. If a thread panics, i think it just spawn another one. Now, I don't have to deal with very edge case scenario in the app where it doesn't know what to do with the args and just let it panic.
Yes, it’s likely that Rust would yield fewer mistakes. But that doesn’t diminish his point that the ‘big problems’ of OS dev aren’t solved in any way by choosing a different programming language.
&gt; I'll edit that sentence to clarify. Thanks a lot. :) &gt; I'm going to print this out and frame it. &lt;3
What do you mean by "dynamic dispatch" exactly?
I am currently working on implementing a JSON API and have been developing it on the beta and then the 1.0.0-rc version of actix-web. When it came to the middleware that I wrote, I based my work off of https://github.com/actix/examples/blob/master/middleware/src/redirect.rs. I recommend having a look at that -- it might help you.
Fear is the path to the dark side…fear leads to anger…anger leads to hate…hate leads to suffering.”
Very good points here. Vectorization is going to be a very big deal for xR
Take a look at migration.md on the repo. Middlewares are now registered using `.wrap()` instead and some have been moved to other crates.
In theory, nightly is generally safe for use in production. With rustup you can lock your project to a specific version of the nightly toolchain that you know works. In practice, it's hard to convince the "powers that be" in your company that nightly is safe.
They have good examples on how to use it with diesel. Its pretty straightforward and I couldn't imaging wanted a deeper integration than that.
&gt; With rustup you can lock your project to a specific version of the nightly toolchain that you know works. But then you wind up also pinning dependencies that only work on a specific version of nightly too. So when it comes time to add a new dependency or do an upgrade, you're playing tetris to figure out how all the pieces fit together. Hell, I sometimes get PRs or issues from people complaining that such and such doesn't work on some specific version of Rust nightly. Rust nightly is a fine thing to use with good judgment. I would not build an entire application on it. There's no way I'd ever be okay with using something like Rocket at work because nightly isn't required to build a good web framework in Rust.
It's an interesting one. We can only initialize `static` variables by calling `const fn`s, and as far as I can tell, there just aren't any `const fn`s in the standard library which are capable of doing what you ask. (It's especially frustrating because `AtomicUsize` explicitly has the same in-memory representation as a `usize` \- all we want is a zero-initialised array of pointer-sized ints! But `mem::zeroed` isn't a `const fn` for some reason, and `mem::transmute` is feature-gated in this context.) I tried to write a macro to transform, say, `[foo(); 5]` into `[foo(), foo(), foo(), foo(), foo()]`, but I don't think that Rust's macros are capable of repeating something a number of times specified by an integer literal. I tried to work around the `mem::transmute` restriction using unions, but unions with non-\`Copy\` fields are apparently unstable. I'm not sure this problem currently has a solution, other than waiting for the `const_transmute` feature flag to be ungated. The tracking issue is [here](https://github.com/rust-lang/rust/issues/53605).
I've worked on the actix (not actix web) documentation quite a bit. The main maintainer of Actix has largely taken the approach that he simply doesn't have the time to document a library that might change anyways. As long as that attitude hasn't changed, documentation will improve now that actix web is at 1.0 and thus the ecosystem is more stable. Actix web 1.0 in particular was not being documented and that was especially frustrating as people would come into the gitter complaining about the lack of documentation on a prerelease. The issue I've encountered with actix web is to properly understand it, you need to understand actix itself. Actix is an actor framework and holds a lot of benefits in and of itself for use in asynchronous systems, not just web servers. I use it for other things, but it will probably always be harder to learn Actix web than it will be to learn Rocket. That's just a guess though.
I've been looking out for a London meet! See you there :)
A macro would work to reduce amount of code, but probably not make it more understandable (since macros can't count, you need to do some ad hoc encoding of 100 in terms of macro matching...)
Sounds like you might want to generate those entire implementations with a macro instead.
See https://github.com/Peternator7/strum#EnumString.
I'm no expert on low-level details but, given that it uses stack unwinding, backtraces should show anything that creates stack frames as long as your `unsafe` code doesn't corrupt the stack.
I'm using actix-web in my work and am familiar with the project, so I'll try to summarize for everyone why this release is so significant. This is a major milestone for the entire Rust community because we now have the first web framework written in stable Rust with an architecture that a credible author has deemed worthy of maintaining backwards compatibility for and a code base mature enough to have earned a 1.0 designation. The architecture of actix-web 1.0 is very different from that of 0.7. In many respects, it was a rewrite that began last Summer. The architecture is no longer based on an actor paradigm but rather one of Services, largely inspired by [Eriksen et al's finagle work](https://monkey.org/~marius/funsrv.pdf) adopted at Twitter. This service architecture is accessible through a library known as [actix-net](https://github.com/actix/actix-net). Essentially, actix-web is a web-based actix-net server. If actix-web were bitcoin, actix-net would be its blockchain. Because of this, actix-net may be even more significant to the broader Rust community. The actor models can still be imported and used but no longer act as the default mechanisms driving the server. Regarding performance, according to the Tech Empower benchmarks that evaluate hundreds of web frameworks across all major languages, [actix-web is top-ranking and](https://www.techempower.com/benchmarks/#section=test&amp;runid=52587667-bee1-4b9b-b34d-929b616d5e4c). The last benchmark represents a beta version of actix-web from last month and results may have slightly improved with 1.0. actix-web is very modular, allowing programmers to only use what is needed and no more. In terms of usability, actix-web 1.0 api is far easier to approach than 0.7. Running blocking calls against a database effortlessly flows within combinators now where as before one had to implement a lot of SyncActor boilerplate. Endpoint resource registration can now either be explicitly registered within an App instance or with a new set of proc macros, but routes still need to be registered manually. The new testing api is far easier to work with for unit or integration tests. A single person wrote two entirely difference platforms in order to get to where it is today. I believe that future progress requires community participation at all levels. This is a great time for system programmers to take a deep dive and learn, from the network-level up, how to build a high-performing, flexible server. Thanks, Nikolay, for your hard work and sacrifice.
No, this is unrelated to specialization. What OP wants can already be achieved by not using the `impl Trait` syntax, without the need for specialization. This is merely a limit in what `impl Trait` can do.
I have been working on my first published Rust crate ([https://crates.io/crates/sarchive](https://crates.io/crates/sarchive)): a tool for archiving user's job scripts and their environments on a Slurm controller (an HPC job scheduler). &amp;#x200B; The code can likely be cleaner and more idiomatic, but it has been running for a bit now and is doing a fine job without issues so far :) One of the things I have been struggling with is to support similar tasks and splitting common code and scheduler-specific code, but after a few hours of poking, I decided that it's probably not worth the effort and it is much easier (and less error prone) to make a new version for the Torque resource manager.
Not sure, but could you leverage Github's semantic ([https://github.com/github/semantic](https://github.com/github/semantic)) for this?
Not related at all to the topic, but your website is quiet slow to display. You might be able to gain make easy improvements on your website rendering time with some simple optimizations. For example reducing the number of assets used or bundling them could help :) Cf: You can take a look at Google PageSpeed to see some more https://developers.google.com/speed/pagespeed/insights/?url=https%3A%2F%2Fwww.schoolbench.com.au%2F
This is wonderful. Rocket was much easier to get started compared to actix.
actix-web doesn't use actix (the actor framework) any more.
let \_: \[Vec&lt;String&gt;; 33\] = arr!\[Vec::new(); 33\]; [https://github.com/JoshMcguigan/arr\_macro](https://github.com/JoshMcguigan/arr_macro)
Its not fear, its not depending on other things that might have broken in the interim. If your documentation says: this requires features that aren't stable and only available in the nightly compiler, a lot of people will just go well obviously its a toy or experiment. Lets find something that doesn't depend on every new whizzbang feature. I'm in that category too, and its exactly why Rocket got as far as: requires nightly experimental stuff? pass.
In addition to that, I've been using Rocket across several projects and so far I've got zero complaints. I've not had any breakages on nightly updates and in general Rocket has been an absolute joy to use. Not the fastest of course, but I viewed Rocket as a very good default for my company. In the words of a coworker: &gt; Wow, this looks just like our [Python] Bottle.py code This imo is *huge*. Rust has a learning curve, and I'm trying to keep everything as simple as possible. If I don't need absolute performance than using Rocket for dev simplicity is a massive boon. The last thing I want is someone not choosing Rust because they think it is always confusing :)
That is documented, but since I am writing my own middlewares, I didn't have a chance to even get to that error. Removal of Middleware trait is not documented at all (if it has been removed).
This is amazing. Thank you for summarizing.
Try https://docs.rs/itertools/0.8.0/itertools/macro.iproduct.html or https://docs.rs/itertools/0.8.0/itertools/trait.Itertools.html#method.tuple_combinations.
I prefer the [`snafu`](https://docs.rs/snafu/) crate, which fixes some of the paint points I had with `failure`. But others will tell you to define an `enum` and implement the conversions manually.
or check the Origin header
What does "async ready" mean in this case? As in, what did it take for actix to be async ready, and does that mean it will automatically use the postfix async operator when it's stabilized?
You are probably aware of this. For those following along, the examples are in their own repo: https://github.com/actix/examples
A different argument can be made for using `?` only when _propagating_ errors from other functions. If the error is within the concerns of the function you are writing, it should be `return`ed (the invariant is checked by the function, and should be documented as such). If the invariant is subsidiary to the concerns of the current function, `?` is appropriate, since it is not a part of the preconditions checked by your function. This approach might be useful to anyone maintaining the code. It makes it clear where an error originates versus where it is propagated. (And this is just my attempt at formulating a semi-useful rule, and should not be taken as me expressing any strong opinion.)
Would it make sense to build a UI toolkit directly around Pathfinder as opposed to using Webrender?
How does the program's performance compare to the sequential read speed of your hard drive?
Don't make a vector. Take the iterator from split and call next().unwrap().to_string() for key and value in the map. Making a vector internally calls malloc and malloc is slow. You could also map from lines to (key, value) tupple and then collect into the hashmap
Is it possible to get the actual discriminant number out of the discriminant? I thought it meant to be an opaque type.
If you're not completely averse to crates then you can do this: use arrayvec::ArrayVec; use lazy_static::lazy_static; use std::sync::atomic::AtomicUsize; lazy_static! { static ref COUNTERS: ArrayVec::&lt;[AtomicUsize; 256]&gt; = std::iter::repeat_with(|| AtomicUsize::new(0)).take(256).collect(); } fn main() { println!("{:#?}", &amp;COUNTERS[..]); }
I have found no document stating that it has been removed, but I think it has. Every `Middleware` implementation has been removed and I can only find `Transform` and `Service` implementations, so I think that they have replaced the old `Middleware` trait. The implementations are now much longer than they used to be.
I feel like we are still mid-way through exploring the efficient rendering techniques of 2D vector graphics on the GPUs, and Pathfinder v3 is quite far from optimal. The interest in this area is growing though, and new approaches gets explored, like [piet-metal](https://github.com/linebender/piet-metal) by Raph. I'm sure we'll see rapid evolution of these algorithms in the following months/years, although this shouldn't block our integration with WebRender.
How would you compare the actor approach of actix 0.7 with this new approach 1.0? I was of the impression that an actor model is a good approach to concurrency and utilizing a server's resources without the globally shared state footgun
This is a welcome addition: [When encountering move error on an Option, suggest using as_ref](https://github.com/rust-lang/rust/pull/61147) It took me a while to discover the very useful [as_ref()](https://doc.rust-lang.org/std/option/enum.Option.html#method.as_ref) when I was starting out.
This thread from last week gives a pretty good overview of the [current state of Error libraries in Rust:](https://old.reddit.com/r/rust/comments/bubtu8/which_error_crate_are_going_to_use_in_2019/)
If you are okay with dynamic dispatch, that is.
The user guide still [appears](https://actix.rs/docs/installation/) to describe 0.7.
I'm trying to check that my implementation of \`Eq\` and \`Hash\` is correct for a datatype. These implementations should only compare certain bytes of the struct depending on what data is in it. What I'd like to do is the following: 1. Initialize the struct 2. Modify the underlying data in the stack to be all \`0xFF\` for some large amount of memory 3. Initialize an identical struct 4. Test equality and hashing of these two structs &amp;#x200B; The reason for this is that the structs are initialized by an underlying C lib that doesn't touch all the bytes, so equality between two structs needs to properly ignore the "junk" data in it. I could implement this manually, but then I don't feel like I'm testing too much, and it'll be a pain to code. Anyone know of a way to cleanly test things in this situation?
That's not just "one good reason", it's **the** key reason to avoid implementation inheritance and prefer composition and delegation instead. Because *the whole point of inheritance* as opposed to these is that it involves "open recursion" - that is, a "tying the knot" pattern where method calls defined in a *base* object have to go through a dispatch step any time they're calling self-methods that may have been redefined in a *derived* object. That's precisely what "composition" doesn't give you, and what in turn leads to the "base class problem" if the semantics that the base-object methods are reliant on aren't properly followed in the derived object!
With this pivot to a Finagle-like services approach, can anyone comment on how this compares to [Warp](https://github.com/seanmonstar/warp)?
This depends on whether your project is a library or an executable program. By convention, cargo looks for `src/lib.rs` if your project is a library, and looks for `src/main.rs` if your project is a library. In any case, it is just a convention, and you can configure it using the `path` key in your `Cargo.toml`, see the [cargo reference](https://doc.rust-lang.org/cargo/reference/manifest.html) for more details.
Totally agreed. Pathfinder of course has its own advantages, such as compatibility with a much wider range of GPU capabilities (as piet-metal relies on compute) and having warping for VR built-in. I have a feeling the next few months will be very exciting.
The way I would personally layer this is to build the UI toolkit around [piet](https://github.com/linebender/piet), then build back-ends that could either be software rendering, WebRender, Pathfinder, or something else. But that's just my opinion. (Note: some of this work is in progress, but it's early days)
That video demonstration looked beautiful! I didn't see any frame drops or aliasing on any of the graphics as the headset panned around and zoomed in.
So the C library leaves some fields uninitialized? It's UB to observe uninitialized memory (which is just as true in C as it is in Rust btw). Or are you talking about padding bytes?
Regarding the https://github.com/rust-lang/rust/pull/61157 PR, it doesn't seem to remove any `discard_buffer` call.
Ah, yes, that's right. I think it moved to actix-rt which I believe is very different but still an underlying conceptual dependency. Sorry for the confusion. I'd forgotten about this change.
Lol that linked kubernetes talk is amazing. I would watch it even if you're not into kubernetes.
They could keep the entire string in memory and store only `&amp;str` in the hashmap.
In practice, nightly is not safe. That's why it isn't called 'stable'.
Dropbox gave a talk at the Rust Bay Area meetup a while ago about how their new sync engine uses futures extensively and how it made testing easier. Would recommend listening, unfortunately I don't have the link.
Not sure about the operators. It just easy to write async responders since you just need to return a future from your endpoint handler.
The pattern that I've used a few times for this is: let mut parts = line.split(","); let mut next = || { parts.next()?.parse::&lt;Thing&gt;().ok()? }; if let (Some(key), Some(value)) = (next(), next()) { use(key, value); } It's robust against malformed data, doesn't repeat the parsing code, and doesn't allocate or parse any more than it needs.
Thanks for linking the implementation :) --- &gt; struct BipBuffer { &gt; buf: *mut u8, &gt; len: usize, &gt; read: CacheAligned&lt;AtomicUsize&gt;, &gt; write: CacheAligned&lt;AtomicUsize&gt;, &gt; last: CacheAligned&lt;AtomicUsize&gt;, &gt; } Is there a reason why `write` and `last` do not share the same cache line? &gt; pub struct BipBufferWriter { &gt; buffer: Arc&lt;BipBuffer&gt;, &gt; write: usize, &gt; last: usize, &gt; } Have you tried "caching" `read` in a `priv_read` variable here? If your reader is lagging behind, it seems it could be worthwhile. --- I must admit I myself generally go for simplicity in bounded queues, by using an `i64` for reader/writer position which never wraps, and simply doing a `% size`. Your design is more flexible, accommodating non power-of-2 sizes.
&gt;because nightly isn't required to build a good web framework in Rust \^ this
The primary stakeholders here are: - The language team for everything about the grammar as well as static and dynamic semantics of the language. - Grammar: This specification effort is primarily delegated to [the grammar WG](https://github.com/rust-lang-nursery/wg-grammar/). - Static semantics: This involves the type system, NLL, traits, etc. WG-NLL, WG-polonius, and WG-traits are some parties involved. - Dynamic semantics: This is primarily being discussed in the [WG-UCG](https://github.com/rust-rfcs/unsafe-code-guidelines). - The library team: Everything involving semantics of standard library types except for special types with compiler support and intrinsics which the language team is also a stakeholder in. - The compiler team: Flags and things the language team have decided are implementation defined. - The release team: Release cadence and channels. As for the core team, I don't think they are a stakeholder other in the sense that they might facilitate coordination. As for your idea about "Sealed Rust", I would suggest that you participate in the various WGs and help out with: - [The `rustc` guide](https://rust-lang.github.io/rustc-guide) and also to document parts of the compiler. - [The reference](https://github.com/rust-lang-nursery/reference/), which is intended as our specification-in-progress. - The standard library by improving the docs and specify any guarantees missing. As for sealing parts of the language for a long time, that seems unlikely to me because it would require the language team and others to not work on that for some time and 18 months is a really long time and substantially longer than the proposed LTS channels in a previous RFC. It would be better to build up a baseline of specification in various parts and then require that any changes to the language come with amendments to said specification. I would also caution that any sort of stable ABI for `repr(Rust)` is, in my view, a non-starter. &gt; This specification will be in the style of other language specification documents, such as ISO/IEC 9899:2018 for the C programming language, or ISO/IEC 14882:2017 for the C++ programming language. I'm not excited about that. I think C / C++ do not pass muster in terms of formal specification as they are frequently ambiguous and I think we would want something more akin to how WASM, Standard ML, and Haskell are specified.
Moderately hacky solution: make a build script that writes `[AtomicUsize::new(0), AtomicUsize::new(0),...]` the correct number of times into a file, and then use `include!` on that file.
I’d use “unstable” not “not safe”, since “safety” has a very specific meaning in rust.
Yeah, we ended up just using box and vec when porting miniz (for DEFLATE/zlib) and not bothering with full allocator support. Granted that was before the rust memory allocation api was stabilized, maybe it would be more doable nowadays.
Declarative macros can't, but procedural macros probably could. &amp;#x200B; [https://docs.rs/syn/0.15.34/syn/struct.LitInt.html#method.value](https://docs.rs/syn/0.15.34/syn/struct.LitInt.html#method.value)
I remember that Gallois was participating into the Verification WG; they may be interested in this initiative.
It sounds like what you mean by an error "within the concerns of the function you are writing" is that the error is due to the caller not satisfying preconditions. Is that accurate?
&gt; I would also caution that any sort of stable ABI for `repr(Rust)` is, in my view, a non-starter. Can you expand on this point?
In brief, a stable ABI would, in my view: 1. Substantially reduce the compiler team's ability to encode past and future optimizations, 2. Adversely impact the language team's ability to design the language in the future because of past stability guarantees. Basically, a stable ABI represents a high level of commitment about the dynamic semantics of the language and therefore the language team has been historically reluctant to specify such aspects and has instead preferred to provide explicit opt-in `#[repr(..)]` attributes.
Look forward to seeing you there :)
You're right! I completely forgot about the difference between dispatching :-)
A few things about idiomatics: - You don't need to pass `&amp;filename` to `File::open`. `filename` is already a reference, so `File::open(filename)` will do. - You can directly use `line?.split(",")` instead of shadowing a variable, if you prefer. - `load_data` will panic if the line doesn't contain a comma. It's up to you if you want to handle that explicitly. As for performance, the standard question is "are you running on release mode?"
&gt; Constantly polling is very inefficient; its a massive waste of CPU resources. The main idea of async is to relinquish control of a thread, potentially putting it to sleep, until your async operation may actually be complete. It depends on the use case, if you're in an active enough system, active polling might save on time and resources by keeping on CPU always on you can get improved responsiveness while keeping sleep-wake costs down. Most systems won't be in this case, but allowing async with a solid default case while also allowing setup of different scheduling schemes is a nice thing to preserve.
I feel like a lot of this comment misses the point. The Ferrous folks certainly know about all of the existing groups. They’re involved in many of them. Additionally, none of this requires the Lang team stopping its work, nor are the ISO folks going to say “well you want a formal spec so of course you can change the format.”
&gt; As for sealing parts of the language for a long time, that seems unlikely to me because it would require the language team and others to not work on that for some time I don't see how that follows. "Sealed Rust" would be a separate offering from "normal" Rust, in the same way that the existence of ISO 26262 qualified C compilers don't affect the development of Clang or GCC. &gt; 18 months is a really long time and substantially longer than the proposed LTS channels in a previous RFC. I think you may have misunderstood; the "18 months" mentioned are the *delay* during which the "Sealed" variant of a new edition would be developed. So e.g. if the next edition were released in December of 2021, a compiler supporting only the "Sealed" subset of Rust 2021 would be released in June of 2023.
Isn't a web browser already quite security critical software?
I kind of disagree. I would be surprised if you can do a lot better than Pathfinder 3 *given its constraints*: namely, old GPU support (GL 3), support for complex SVG, and high quality anti-aliasing. At least I haven't been able to do better over the last two years of work in this area. And it's remarkable that Massively Parallel Vector Graphics and Pathfinder have converged on broadly similar approaches (with the details differing a lot, of course). I see the continued work as primarily refinements of the broader technique. Probably the biggest question is whether to adopt the GPU fixed function rasterizer or to throw it out entirely (pure fragment shader approaches like Dobbie and Slug could be classified either way). I generally lean toward using the hardware rasterizer, but that may just be bias coming from my focus on broad hardware support.
Yes! I think using Pathfinder directly may be more appropriate if you have a lot of irregular shapes, such as game UI/HUDs frequently do, while using WebRender may be more appropriate for traditional UIs that do a lot of scrolling of axis aligned boxes. But I'm not sure.
Here's a somewhat hacky but working way to do it: for i in 0..ps.len() { let (before, nonbefore) = ps.split_at_mut(i); let (sp, after) = nonbefore.split_first_mut().unwrap(); let mut a_x = 0.0; let mut a_y = 0.0; for p in before.iter().chain(after.iter()) { let dist = distance(sp.x, p.x, sp.y, p.y); a_x += p.mass * (sp.x - p.x) / dist; a_y += p.mass * (sp.y - p.y) / dist; } sp.x += a_x * dt; sp.y += a_y * dt; } The key here is the `split_at_mut` and `split_first_mut` functions, which decompose mutable slices. They use unsafe code internally because they can't prove to the compiler that the slices they return don't overlap.
Is it realistic to certify the existing compiler? I'm not an expert but for most strict classes (most critical applications), a dedicated compiler extremely well verified (maybe in some cases mathematically proven in some dimensions) seems necessary. Codegen bugs are rare nowadays, but they do occur occasionally with general purpose compilers, and even when they don't it is difficult to "prove" that it won't happen. It is my understanding that some applications (e.g. fully unattended metro) need a quite hard proof for compilers, or manual checking of the generated binaries. For less strict classes, you can very probably already use Rust, or pretty much "anything" you want (hm within reason...) So maybe it is for intermediate safety levels?
Yes, it is. Clang is certified on top of LLVM on part of the current ARM toolchains. We have spoken to a couple of folks involved in such projects and it's feasible. _Verified compilers_ are even more fringe, and this is not what we are talking about, this is a different class.
A web browser doesn't have moving parts or could hurt anyone physically :). The domains we're talking about in this blog have a different view of security. WebVR might change that though ;).
Fair enough, perhaps I was overstating a little. There's certainly situations where active polling is worth the trade offs. Even spin loops come to mind as an example of where active polling of a lock offers certain benefits. Another example might be when you are working on a real-time system with a timing-sensitive application.
Mmm no.
That's not hacky, that's great. I was working [on the same thing](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=c96700d17cb31271b461925bfd31ea79) :D
Cool. How does Render compare to something like DigitalOcean? The hardware appears to be a lot more expensive at Render, do you get anything more for this cost?
&gt; At least as far as I understand it, to create a thread you have to use system calls, and this can also hurt performance, especially on spectre-mitigated systems. Just a nitpick: even if you actively poll a timer future in the current thread, how will you determine `elapsed &gt; timer`? Querying the system or CPU clock is also a system call on most systems anyway, so your concern about system calls seems out of place. In fact, actively polling this would *increase* the number of syscalls you make.
&gt; I don't see how that follows. As I understand it, "Sealed Rust" would be a separate offering from "normal" Rust, in the same way that the existence of ISO 26262 qualified C compilers don't affect the development of Clang or GCC. The language team and the community at large would need to be involved in whatever sealing process exists and sign off on the specification and guarantees. We don't have an infinite amount of time so if we devote more time to specification we can do less language development. However, in the years to come we do want to focus on specification. &gt; I think you may have misunderstood; the "18 months" mentioned are the delay during which the "Sealed" variant of a new edition would be developed. So e.g. if the next edition were released in December of 2021, a compiler supporting only the "Sealed" subset of Rust 2021 would be released in June of 2023. No I understand this perfectly but: 1. It is unlikely that a whole separate compiler will be developed. 2. We would need to backport fixes for those 18 months just as with the other releases. This places a high burden on the teams. 2. Starting from no specification at all, it is difficult to seal of specific components of the language.
&gt; The Ferrous folks certainly know about all of the existing groups. I'm sure they do; I am giving an overview of the current specification effort and I don't think a completely separate effort should be started. It is not feasible to duplicate the work and so Ferrous should participate in the WGs that exist. &gt; They’re involved in many of them. Not substantially to my knowledge as the lead of one of those WGs and participant in most of the others. &gt; Additionally, none of this requires the Lang team stopping its work, [...] Please elaborate. The language team will need to sign off on whatever specification documents are produced and participate in the specification work itself to ensure that it is in line with our plans. &gt; [...], nor are the ISO folks going to say “well you want a formal spec so of course you can change the format.” The language team is the body that decides what the language is. It is frankly not for ISO to dictate terms to us nor to dictate by which process a standard is developed. We decide this and we have existing processes. I also note that neither Standard ML nor WASM are standardized with ISO. However, I don't see why ISO would be opposed to a better quality of specification than the C and C++ standards offer and why we would unable to use a formal grammar, typing rules, and operational semantics.
I had checked the TechEmpower benchmarks on the first read, but it's actually really impressive. TechEmpower runs 6 benchmarks: JSON serialization, Single Query, Multiple Queries, Fortunes, Data updates and Plaintext. In the latest [round of tests](https://www.techempower.com/benchmarks/#section=test&amp;runid=5cc1a314-4e0c-4294-b8f1-cb607e0a5440&amp;hw=ph&amp;test=plaintext), Actix is first in **5 out of 6** benchmarks, only losing by 1.1% in the JSON serialization benchmarks to ulib-json (C++) and libreactor (C). Actually, its score in the Fortunes is so much higher that I am led to wonder if there's a benchmark issue: +------------------+---------------+-----------------------+-----------------------+ | Benchmark | actix Score | Contender Score (%) | Contender | +------------------+---------------+-----------------------+-----------------------+ | Plaintext | 7,006,639 tps | 7,000,808 tps (99.9%) | ulib (C++) | +------------------+---------------+-----------------------+-----------------------+ | Multiple queries | 46,939 tps | 46,048 tps (98.1%) | greenlightning (Java) | +------------------+---------------+-----------------------+-----------------------+ | Single query | 886,993 tps | 866,929 tps (97.7%) | wizzardo-http (Java) | +------------------+---------------+-----------------------+-----------------------+ | Data updates | 25,672 tps | 22,001 tps (85.7%) | wizzardo-http (Java) | +------------------+---------------+-----------------------+-----------------------+ | Fortunes | 704,354 tps | 455,284 tps (64.6%) | h2o (C) | +------------------+---------------+-----------------------+-----------------------+ And unsurprisingly, it tends to do well in terms of average latency, though I wish we could see the tail latencies.
You're proposing a change to how. open-source project is run, this "sealed" stability guarantee. And to justify the effort and inconvenience and other costs incurred by others, you talk about how it will benefit your prospective customers. So far that's not exactly convincing, but at least it's neutral. But then you talk about propreitary derived works which are enclosed for the exclusive benefit of Ferrous Systems. Ouch. If you want a proprietary fork, the MIT license allows you to have it. You're free to invest your own efforts and to commercialize them in a space where regulations aren't in agreement with open source mores. Fair enough. What's not fair is expecting open-source to bend to your exclusive needs, even an inch. If you want to sell this idea, "sealed", you ought to demonstrate it's benefits to everyone - not only but especially to your prospective competition. *That* is sharing alike. If you don't want to share alike, many open source projects would deny you the right to distribute your derivative work at all - copyleft. Be grateful that the Rust team is even more generous than the FSF or Linus! But it's inconsiderate to ask for even more of your work to be done for you. Saying "we're want to capture government funding, and if not we're going to enclose your commons" *is a threat*, whether or not you understand or intended it that way.
Has anyone tried Slug in comparison?
Your front page mentions a "serverless" technology, but I can't find any information on it, is there some place I can learn more about it?
Original announcement: https://people.gnome.org/~federico/blog/maintaining-bzip2.html Article about oxydizing bzip2: https://people.gnome.org/~federico/blog/bzip2-in-rust-basic-infra.html Federico has been oxydizing librsvg, with the latest announcement on the topic being: https://people.gnome.org/~federico/blog/librsvg-gobject-in-rust.html
Render is fully-managed hosting: we build and deploy your code automatically on every push to your GitHub repo. As long as you have a `Cargo.toml`, you don't have to worry about anything else like installing Rust, VM security updates, load balancing, SSL certificates, custom domains and every other chore that accompanies deploying an app on something like DO.
I think we're on the same page, but it's important to express it clearly - definitely Pathfinder does very well given its constraints, but if you look at the bigger picture where compute is available, then I think it *is* possible to do better. Also people should know that piet-metal is very inspired by Pathfinder 3 and in fact if you look at the exact area calculation for line/pixel interaction it's almost the same code. In fact, I PR'ed one of my experimental techniques into PF so Patrick could evaluate the compute/LUT tradeoff. If there's a future extension of PF to do tiling on the GPU I expect it to look like piet-metal and of course am happy to have any of my ideas or code adapted.
Sorry, I added it long time ago, but forgotten to remove it. For the moment, the only *serverless* thing is Phaser: the security scanner
&gt;I tried to write a macro to transform, say, &gt; &gt;\[foo(); 5\] &gt; &gt; into &gt; &gt;\[foo(), foo(), foo(), foo(), foo()\] &gt; &gt;, but I don't think that Rust's macros are capable of repeating something a number of times specified by an integer literal I think you can do that with proc macro
&gt; The language team and the community at large would need to be involved in whatever sealing process exists and sign off on the specification and guarantees. ...why, though? "Sealed Rust" is only of interest to developers in safety-critical domains. The developers invested in the existence of Sealed Rust (and working on the specification and implementation) would be the ones making the guarantees. &gt; We would need to backport fixes for those 18 months just as with the other releases. This places a high burden on the teams. If there are critical fixes to features included in the Sealed subset, then the developers working on Sealed Rust would do the backporting. The burden is *only* on the maintainers of Sealed Rust (though of course they would be probably benefit from Stable Rust's backport patches, possibly even by copying them as-is in some cases). &gt; Starting from no specification at all, it is difficult to seal of specific components of the language. That's *why* there would be an 18 month delay, and it's a problem that any team hoping to develop a version of Rust suitable for safety-critical and highly-regulated domains would need to deal with. You could even say it's the primary problem.
&gt; What's not fair is expecting open-source to bend to your exclusive needs, even an inch. That's not their needs, but the industries needs. If Rust wants to be a realistic alternative in the mentioned domains (which all have a huge overlap with embedded, which is a Rust focus-area), those specification / standardization efforts need to be done by *someone*. This is also the start of a conversation, and there are no demands. It's not impossible that this ends with the conclusion that this effort is currently unfeasible and/or the Rust project needs to be forked for this.
Is there any plan for a search engine?
The important thing missing from the README is what it uses as a source of randomness. Since formatting bytes into a UUID is typically not a particularly computationally expensive task, this may well be bottlenecked by the RNG - and there could be valid reasons why the RNG used in the Python implementation is slow.
&gt; ...why, though? "Sealed Rust" is only of interest to developers in safety-critical domains. The developers invested in the existence of Sealed Rust (and working on the specification and implementation) would be the ones making the guarantees. This is how a fork of the language begins and with it all the portability hazards. I don't want to see separate implementations implementing a different language and using guarantees that the language team has not provided and which we may want to change at any point. What happens when 18 months is up and an update is needed? What do the folks needing a "Sealed Rust" do when guarantees they specified are no longer provided by `rustc`? Do they split the language? Do they force the language team to make those specifications by the sheer amount of code that would be declared unsound otherwise? &gt; If there are critical fixes to features included in the Sealed subset, then the developers working on Sealed Rust would do the backporting. The burden is only on the maintainers of Sealed Rust (though of course they would be probably benefit from Stable Rust's backport patches, possibly even by copying them as-is in some cases). It's already non-trivial to bisect and backport changes for 12 weeks let alone 18 months. If sealed Rust is to have the aura of officialdom then it needs a certain quality as well. Moreover, an LTS version of Rust that offers 18 months of support will substantially stagnate libraries that will seek to be compatible with this LTS version. &gt; That's why there would be an 18 month delay, and it's a problem that any team hoping to develop a version of Rust suitable for safety-critical and highly-regulated domains would need to deal with. You could even say it's the primary problem. Yes, and we (the WGs + the language team) are doing the work already, but we are doing it with small resources and we are under-staffed. I think the first focus is to produce a formal pre-expansion grammar and then work towards giving static and dynamic semantics to it.
Okey, then I understand your pricing structure a bit more, thanks. It's basically more similar to Heroku (which I've never used, so I'm just guessing) than DigitalOcean. I guess these services are more geared toward low traffic APIs and so on? Because of the low bandwidth cap. Nothing wrong with that though, I'm just trying to figure out in which scenarios I'd use your services. Also, I'm wondering about how much storage you get as well for services. I couldn't find it anywhere, which leads me to believe that there no cap. But I might be wrong.
&gt; It is frankly not for ISO to dictate terms to us nor to dictate by which process a standard is developed You cannot produce and sell software for \*safety critical contexts\* to customers unless you're conforming to the ISO standards that govern these contexts. Your pessimism is rather alarming to me.
Yea, that's what I thought this was at first haha. A self hosted search engine for privacy. I like the idea tbh haha.
&gt; Basically, a stable ABI represents a high degree of commitment about the dynamic semantics of the language Yes! Good. A Sealed Rust variant would just be locking that down for applications designed for a very specific context. I fail to see how this would somehow hinder the language team when developing the language.
I agree with the proposal. I think Rust needs this, especially since it focuses on safety and performance in constrained environments.
This is awesome for so many reasons. Will absolutely take a look at it this weekend.
&gt; self hosted With self hosted indexing of the web too ? This sounds... dispendious.
&gt; You cannot produce and sell software for *safety critical contexts* to customers unless you're conforming to the ISO standards that govern these contexts. Since you seem to be more familiar with safety critical software contexts, could you please elaborate on whether the ISO standards that govern these contexts require that the language specification also be provided by ISO or whether they would e.g. accept a e.g. a W3C specification or ECMA specification? If they require an ISO specification, that would be unfortunate and we would need to work with that. What I won't accept is a separate standards body decide what the Rust language is where the consensus process is not based on the language team's approval.
Yes, I tested in release mode (rustc -O). I tried not shadowing with `let vec: Vec&lt;&amp;str&gt; = line?.split(",").collect();` but got `temporary value does not live long enough.`
About 30% of wall time is spent just reading the file in my benchmark (rust version).
Is this similar to Heroku?
&gt; A Sealed Rust variant would just be locking that down for applications designed for a very specific context. Or you can use the existing `repr(C)` and other layout attributes that the language already provides rather than relying on undefined behavior or trying to make it implementation defined. &gt; I fail to see how this would somehow hinder the language team when developing the language. This is essentially forking the language, splitting the effort, and creating portability hazards that grow over time as the compiler or the language team exploits various non-specified ABI details in a different way than the "Sealed Rust" folks decided.
Thanks for the pointer, I will test this!
&gt;They have g My understanding is Diesel requires you to hand-write a migration whenever you change the schema.
Actually I've debated implementing this before _(it's low on my priorities though, really low)_, but my intention was to index sites I care about. As DuckDuckGo shows, my searches are frequently on a small subset of sites and the matching backend does not need to be extremely complex for those sites. Like, really small set of sites. If I ever had a problem with DDG I'd likely self host as an experiment.
It is the gateway to most people's financial jewels. I rate it quite highly.
Even small parts of the web are huge today. Even Stack Overflow is big enough to scare your HD (I know it: I had a service based on a permanent fetching of their QA... and I had to scrap it because of the size it took on my server).
Yes, but much more flexible and less expensive.
Maybe we're not that far. Isn't control software is 'restful' too, like most other things, I doubt dev buzz words have exception from that realm. I've only mentioned the browser until now, the FastCGI interface, and the browser guts can be rust. I don't think it is that much of a stretch to see the control being the browser.
It's using Rust's rand library. https://github.com/rust-random/rand
&gt;I guess these services are more geared toward low traffic APIs and so on? Because of the low bandwidth cap an steep pricing. Nothing wrong with that though, I'm just trying to figure out in which scenarios I'd use your services. &amp;#x200B; We don't have bandwidth caps; we just charge $0.10/GB for bandwidth over 100GB. I wouldn't call the pricing steep if you put a value on your time, and even more so if it helps you avoid hiring a sysadmin. &amp;#x200B; &gt;Also, I'm wondering about how much storage you get as well for services. I couldn't find it anywhere, which leads me to believe that there no cap. But I might be wrong. &amp;#x200B; All storage on Render is ephemeral unless you use our hosted PostgreSQL; persistent disk storage is in the works. What kind of data are you looking to store on disk?
Hi, currently not, because as mentioned in other comment, it requires too much resources for self hosting, I think we currently have great option for all the spectrum (From Google search to DuckDuckGo), and because an open source search engine will be tricked by all kind of nasty `SEO Experts` and it will be very hard to premote actually good Content. I dared the Google comparison thinking about it's productivity suit, and because they have an app for all the need of our life. At an extraordinary price, even if it cost noting. Productivity is the current foundation, but you can think having a Bloom open source tractor in come years :)
Somehow we are talking past each other. The Rust team is not "doing the work already" to make a version of Rust suitable for these domains. This is a specific need that does in fact have specific associated challenges, but the whole point of the top-level post is that there's a group wanting to take on those challenges. Without this work, Rust *cannot* be used in certain domains, period. But these domains are *highly unusual* and exist largely separate from the rest of the software engineering community. So, for instance, the fact that "libraries that will seek to be compatible with this LTS version" will "substantially stagnate" is a non-issue. And, yes, this would be a fork. I don't see how that's avoidable. &gt; What happens when 18 months is up and an update is needed? Again, 18 months is not the support term; in fact it's totally unrelated to how long the Sealed Rust team would support a particular version. &gt; What do the folks needing a "Sealed Rust" do when guarantees they specified are no longer provided by rustc? Continue to use whatever version of Sealed Rust they're already using. The next version of Sealed Rust would be based on the next Rust edition, and maybe it would drop some specific guarantees if rustc dropped them; maybe not. Either way, new releases of Sealed Rust wouldn't affect anyone using the old version, just as new releases of rustc don't affect people using older versions.
What happened to websocket support? I was using actix-web for a WIP project with websocket based RPC, where any serverside websocket connection is an actor that talks with the rest of the server using actix' actors protocol. I tried to check if I can still do that now that actix-web no longer uses actix, but the only websocket-related thing I found in the docs is creating a websocket client with [awc](https://crates.io/crates/awc), which only seems to implement a client, not a server... Is websocket support officially dropped?
Which RNG out of Rand? It has like 20 of them.
I just want to preface this with saying that I'm not trying to bash on your service. I think it's awesome to have more alternatives, and I might try it out in the future. &gt;We don't have bandwidth caps; we just charge $0.10/GB for bandwidth over 100GB. Yes, sorry for my bad wording. I just meant the amount that was included in the initial cost. &gt;I wouldn't call the pricing steep if you put a value on your time, and even more so if it helps you avoid hiring a sysadmin. Well, I was mainly referring to the hardware you get for the money, which would mean that scaling up might be costly compared to another unmanaged service. But I totally understand that the additional features you offer adds value. Just as an example, if you boost up the available GB/mo to 5TB as it is on DigitalOcean, then you're looking at a service that is about $100 more expensive for the same hardware and GB transfer. &gt;All storage on Render is ephemeral unless you use our hosted PostgreSQL; persistent disk storage is in the works. What kind of data are you looking to store on disk? I guess files for logging and so on. But I understand if that's difficult when you're building from scratch when deploying to Git repositories. Other than that I was just curious to know. :)
Yes please! 🎉 I long for the day where I can leave C &amp; C++ behind... But: it is a bit weird to see this while automotive companies start to use GCC (and argue that it's safe to use because it's "proven in practice").
The default. https://github.com/uuid-rs/uuid/blob/master/src/v4.rs#L29
&gt; The Rust team is not "doing the work already" to make a version of Rust suitable for these domains. We are working on specifying the language but it is going slowly. I interpret Sealed Rust as a specification effort. The best way forward is to funnel those efforts through the existing channels and beef those up in terms of staffing. &gt; Without this work, Rust cannot be used in certain domains, period. I am also interested in specification of the language -- I don't know what gave you a different impression. &gt; And, yes, this would be a fork. I don't see how that's avoidable. It is avoidable by *not relying* on ABI details and dynamic semantics not specified in the ordinary language. If you need guarantees, either 1) ask for them from the language team, 2) ask for opt-in attributes. If Sealed Rust produces a separate standard before normal Rust then I think there will be pressure for normal Rust to align itself with Sealed Rust. To spell it out in more explicit terms, I think this is partly about power: "Who decides about Rust the language?". &gt; just as new releases of rustc don't affect people using older versions. New releases of Rust, including new editions, do not change the dynamic semantics of the language or at least not intentionally so.
Maybe so, but noone cares about certifications etc. for browsers. The stuff you have to fulfill to become e.g. ISO26262 ASIL-D certified are nontrivial and in my opinion are not comparable to regular software engineering.
I like to highlight that the section "Funding" contains the following option: &gt; We are able to take funding from companies and public funding grants, and are able to deliver the items described above as a fully open source contributions to the Rust project. And later go on to make it clear that this is our preferred option.
I think an ideal toolkit should be able offer both a simple drawing interface and a way to efficiently fall back to something far more performant, e.g. Vulkan or just render separately into a texture. I have to say don't exactly know how low level webrender is. So using Pathfinder without caching for e.g. scrolling might turn out to be not quite fast enough or too expensive?
There is a difference between an ISO language standard and an ISO standard for the production of hardware or software. In the case of ISO26262 it'd depend on what ASIL level you're shooting for that would determine how strict the requirements are on the compiler. I believe though that in order to be certified for the highest possible level you have to use a certified compiler, and the only languages I'm aware of being certified all have ISO language standards (C, C++, ADA). Linux is a fair example. It's not possible to certify Linux currently for any ASIL-D level application. Afaik any use of Linux in todays vehicles are running as a guest, or communicating via a safety certified gateway to critical systems. Personally, I believe a fork of the language \*if that is what is required here\* so that we'd have an ISO standard variant of Rust is just an enormous benefit to humanity.
30 gigabytes of free storage. If you don't mind me asking, how are you funding this?
Disclaimer: this is my perspective as someone who has never produced safety-critical software. This is my (subjective) opinion and I am not an expert here. Here are two reasons why Rust as-is is not good enough for safety-critical code: 1. Rust is designed for *security*, and *safety* is a different (but related) problem space. 2. The bar is set far-higher for safety-critical applications than for the typical web browser/web server. **Security vs. Safety** Rust is designed to prevent memory safety issues: this improves security against code execution and data leak-style vulnerabilities. However, preventing crashes and logic bugs has always been a "nice to have": `panic!()` has always been considered safe, for instance, and minimizing security issues has always taken priority over minimizing other types of bugs in the standard library. Safety-critical systems need to also be reliable (`panic!()` is really scary here) and free of logic bugs (if it all possible). Rust's standard library was developed with memory safety and security in mind, but correctness has received lower priority. Safety-critical systems demand correctness from all forms of bugs (to the extent possible). **Higher Bar** Damage done when a safety-critical system fails is generally considered more severe than a security vulnerability. Consider what happens if any of the following fail: * A car's airbag controller * An airliner's flight controls * Radiation therapy machine (Therac-25 one one such bad machine) * Pacemakers Nowadays, the software of all of these is developed very slowly and carefully to extremely high standards because the cost of failure is very high.
Security-critical systems do not rely on web browsers. Some of them may be accessed indirectly through a web browser, but if the web browser fails it should not result in a dangerous situation.
Hi, Currently, storage is backed by S3 (with encryption enabled), so it's cheap and as we do not expect to reach Google scale during the next month it'il not cost much. Also we have some AWS credits :)
I think we are talking past each other. &gt; In the case of ISO26262 it'd depend on what ASIL level you're shooting for that would determine how strict the requirements are on the compiler. To be clear, my criticism of isocpp as a standard is that it is too ambiguous and *not strict enough*. I would like to see an actual formal specification using the typical tools one uses in PLT: 1. BNF and a formal grammar (wg-grammar). 2. Typing rules with a machine checked proof of soundness (wg-traits, wg-nll, wg-polonious). 3. Formal operational semantics that are also machine checked. (Ralf Jung and the UCG is working towards this with miri and stacked borrows) Or at least I think we should work towards this goal by increasing degrees of specificity over time. There is &gt; I believe though that in order to be certified for the highest possible level you have to use a certified compiler, I have no issues with compiler certification or ideas like compcert. It sounds like a great idea to me. miri should already be able to find many cases of UB. &gt; Personally, I believe a fork of the language *if that is what is required here* so that we'd have an ISO standard variant of Rust is just an enormous benefit to humanity. I don't want to see a fork. I think this will fragment the language, put control over the future of the language in the hands of commercial interests. I want to see a specification, but I think it should be done in one concerted effort under the supervision of the language team.
&gt;If Sealed Rust produces a separate standard before normal Rust then I think there will be pressure for normal Rust to align itself with Sealed Rust. &amp;#x200B; As a user of non-sealed rust, it's not obvious to me that this would be the case. Do you envision that this pressure will be internal (coming from within the rust team itself)? Or external (coming from users of normal rust)? As as user of normal non-sealed rust of today, I am: * Already satisfied with the guarantees and semantics of normal rust * Not interested in targeting customers or applications that operate under ISO safety standards &amp;#x200B; Obviously I am only speaking for myself, but I don't feel particularly unusual, so my gut feeling is that many users of normal rust wouldn't be that impacted by Sealed Rust
&gt; But: it is a bit weird to see this while automotive companies start to use GCC (and argue that it's safe to use because it's "proven in practice"). The current ARM compiler for that space (6) is LLVM based. https://developer.arm.com/tools-and-software/embedded/arm-compiler/safety https://developer.arm.com/docs/dui0741/latest/overview-of-the-arm-compiler-6-toolchain/clang-and-llvm-documentation What you pay for is the long term support and the certification manuals, which, IMHO, is a nice deal.
&gt;I guess files for logging and so on. But I understand if that's difficult when you're building from scratch when deploying to Git repositories. Other than that I was just curious to know. :) &amp;#x200B; Logging integrations are coming soon! But persistence would solve that problem for you also. Thanks for the feedback :)
&gt; Do you envision that this pressure will be internal (coming from within the rust team itself)? Or external (coming from users of normal rust)? Both. Parts of the language team and other teams will argue that there exists code that we would render unsound with our changes. *This is already the case*, see https://github.com/rust-lang/rfcs/pull/2582 and https://github.com/rust-lang/rust/issues/58794. I expect the compiler team not to take advantage of certain UB as well. &gt; Not interested in targeting customers or applications that operate under ISO safety standards Can you elaborate as to whether you feel you: + would be interested in tools like miri that can detect UB in your code dynamically, + would like to understand the semantics of Rust better. A specification of normal Rust is also important for the language team because it allows us to make changes more easily by understanding the thing we are changing.
Thank you for bringing this up. I'd love to see rust succeed in this space (if for no other reason than I want to see rust succeed everywhere), but I think you're right that there is a cost here, and that the cost could easily be borne by people who don't have a stake in this effort, and who haven't asked for it.
Requiring a fork in order to produce and ISO language standard is not something I'd prefer. But if that is the only way, then I'm just saying we're better off having that instead of never having a version of Rust able to be used in the higher ASIL contexts. I don't know for sure whether the language standard matters at all as long as there is \*some\* formal specification that can be used for certifying a compiler. I'm not an expert in these matters and really only build software that communicates to the certified systems over the canbus. One thing for sure though is that, as we start to move more code away from Linux and onto MCUs we definitely want to be able to say we're conforming to some level of certification while continuing to use Rust.
&gt; Safety-critical systems need to also be reliable (panic!() is really scary here) and free of logic bugs (if it all possible). Rust's standard library was developed with memory safety and security in mind, but correctness has received lower priority. Safety-critical systems demand correctness from all forms of bugs (to the extent possible). Overall you are right. However, I do think we can improve. For example, `const fn` should help in reducing side-effects and make evaluation deterministic. Const generics offers an amount of dependent typing, this should also help with preventing logic bugs. A restriction `!panic fn` (strawman syntax) could also help. Finally, if we want to take this to formal proofs, we could have `total fn`. Of course, these come with their complexities and we'll have to judge whether those are justified as compared to the benefits.
&gt; I interpret Sealed Rust as a specification effort. That may be the disconnect! Sealed Rust would be several things, only one of which is a specification. It is a language that is not Rust but a *very small subset* of Rust; an implementation of that language; and a formal specification of *that language*. &gt; If Sealed Rust produces a separate standard before normal Rust then I think there will be pressure for normal Rust to align itself with Sealed Rust. I don't think so. Are you familiar with MISRA? It is a set of *extremely* restrictive guidelines for C. It does not permit *any* heap allocation. Sealed Rust would be analogous. No one who isn't in need of such a narrowly defined sub-language for their specific domain would have any reason to think that the Sealed Rust specification would be of any value to them.
What's the deal with defining constants in functions? I see in a lot of rust code defining constants this way. What are the benefits/drawbacks of doing this. Thanks
Sounds nice, but I still don't know of any OEM using clang - it's all GCC (either directly or for e.g. QNX or PikeOS) or ICC.
&gt; Requiring a fork in order to produce and ISO language standard is not something I'd prefer. But if that is the only way, then I'm just saying we're better off having that instead of never having a version of Rust able to be used in the higher ASIL contexts. I don't want to create antagonisms here where none may be needed and where we can act in common interests, so let's at least try to specify things primarily in one "document" that the language team can vet and agree to. If conforming to ISO's way of laying out a document (bibtex references, headings, etc.) smooths things then let's also do that.
It's the regulations that matters not your, or mine, opinion.
Why did they not call this "Stainless Steel"?
&gt; I don't think so. Are you familiar with MISRA? I am. &gt; Sealed Rust would be analogous. This is not how I interpreted the blog post; I read the subset part as a staging mechanism: working towards specification component by component but towards full eventual coverage. &gt; No one who isn't in need of such a narrowly defined sub-language for their specific domain would have any reason to think that the Sealed Rust specification would be of any value to them. What I am concerned about is Sealed Rust (SR) specifying things that are UB rendering them implementation defined (not based on hardware but based on compiler). I am not concerned about SR forming a *true subset*. This seems necessary due to panics, heap allocation, etc. I am concerned about SR not forming a subset but to have SR's and normal Rust's intersection be non-empty.
&gt;I don't think that Rust's macros are capable of repeating something a number of times specified by an integer literal. I don't think anything in principle stops a proc macro parsing the integer literal as a proper integer and then iterating based on that value.
"actix-diesel" is consistently ranked very low down. Is Diesel really that slow compared to the rest?
That includes OS overhead, hard drive latency, and things like that. What I'm wondering is how the time the program takes compares to the actual maximum speed of data transfer from your hard drive. For example, mine (WD Black 7200 RPM) can sustain 150 MB/s, so if your 10M lines file is 1 GB there's no way to bring the processing time under 6 seconds. If your Python program takes 10 seconds and your Rust one takes 8, that means that the Rust one is actually a lot faster.
About panic: You can differentiate between fail-safe (where panic is okay) and fail-operational (where it is not). And honestly: Currently C &amp; C++ are widely used - they are neither designed for safety nor security.
I am interested in both of those things that you mentioned. My rudimentary understanding is that both of those things require a well-defined specification for rust. I think what happens today is that someone discovered a soundness problem in rust and the language team decides how to fix it (and then makes the fix). In the process of doing this, the specification for rust is evolved , and matured, and better understood. Is one of your concerns about what to do if the sealed rust team discovered a soundness problem, fixes it in their own fork, before the rust language team has a chance to react? Are you thinking that the rust team could find themselves pressured to simply take the solution from the sealed rust team? Or about the conflict that would arise if the rust team and the sealed rust team come to different conclusions? (And maybe the rust team would feel like they wouldn't have time to undertake their own analysis?)
It remains to be seen. I'm not sure how expensive Pathfinder will be for scrolling static content. We can do a lot more to cache individual rendered coverage tiles.
&gt; Moreover, an LTS version of Rust that offers 18 months of support will substantially stagnate libraries that will seek to be compatible with this LTS version. This is probably a good thing for core libraries that have reached maturity. `byteorder` still supports Rust 1.12. `serde` still supports Rust 1.13 (and `serde_derive` still supports Rust 1.15). `regex` still supports Rust 1.24. So this is already happening, even in the absence of LTS.
They are used with restrictive guidelines (e.g. MISRA) and, often, specialized compilers.
I wasn't. That's much more comprehensive indeed, I just checked the main repo!
This one is a blocker for me. We get too much of our rich interactivity from pushing events of interest to subscribed webclients. Falling back to polling has a noticeable impact on the experience.
&gt; My rudimentary understanding is that both of those things require a well-defined specification for rust. Yes, absolutely. But notice that it's possible to have UB in a well-defined specification. What do you is to explicitly denote that your [definitional](http://casperbp.net/papers/intrinsicallytyped.html) [interpreter](http://www.cse.chalmers.se/~nad/publications/danielsson-definitional-interpreters-looping.pdf) is "stuck" given certain inputs (including starting state and contexts). At its simplest: ``` data ValueOrUB = Value | UndefinedBehavior eval : Expr -&gt; ValueOrUB eval UBCase = UndefinedBehavior eval .. = .. ``` &gt; Is one of your concerns about what to do if the sealed rust team discovered a soundness problem, fixes it in their own fork, before the rust language team has a chance to react? Soundness holes are typically reported to Rust upstream and are not as swiftly fixed as you may imagine. See the [I-unsound](https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+label%3A%22I-unsound+%F0%9F%92%A5%22 ) label for examples. I'm not concerned about those. &gt; Are you thinking that the rust team could find themselves pressured to simply take the solution from the sealed rust team? Or about the conflict that would arise if the rust team and the sealed rust team come to different conclusions? (And maybe the rust team would feel like they wouldn't have time to undertake their own analysis?) Soundness is with respect to a claim you make. My concerns are not about that. What I am concerned about is Sealed Rust making decisions about *unspecified* parts of the language and providing guarantees about those and that conflicts would arise or to be pressured to take SR's solution and guarantees.
Hey there /u/etareduce, thank you for sharing your concerns, I apologize that this is the first time our plan has reached you, we did share this with the core team a few weeks ago, but it seems that information did not propagate as we hoped. I'm still catching up on the many threads of conversation here, however there are a couple points I'd like to make: 1. We aim to collaborate with the existing teams and efforts as much as possible. We do have a specific end-state in mind (usability of Rust in safety critical domains), however we have no interest in making competing or conflicting versions of the language, the compiler, or the efforts that are already in progress. We hope to take funding to put money TOWARDS Rust, similar to how Mozilla currently funds the project - by paying existing contributors as well as new developers to work full time towards the project, the specification, the verification, and the validation. 2. We do not want to fork the project, and hope to keep "sealed rust" as much of a strict subset of the greater language as much as possible. We hope to discuss with the teams you mentioned the most effective way to do this. 3. We do hope to offer LTS versions of Sealed Rust, because this is a requirement of the industries that would need it. This development, maintenance, and backporting cost would be borne by ourselves, or other service providers, paid by customers. We don't expect this from the unpaid contributors of the project 4. With regards to an ISO standard, I am proposing that the Rust community specifies the language, with a level of formality expected of an ISO standard. Even if it never becomes an ISO, IEC, or ANSI standard, having an official language specification, even if it is only formalized by a tagged commit, is necessary for use in these domains. 5. We state in the article that we aim this post to be part of a "Pre-RFC", seeking to find exactly these concerns to find a solution that meets consensus within the project. We hope to collaborate with you, and the teams you have listed, to improve the Rust project for all users involved, as well as bring Rust to new users that are unable to benefit from Rust's offerings. We would love to address your concerns in a format perhaps more productive than a Reddit comment thread. I am currently in US Central Time, and we can coordinate a voice or video call if you'd like, or even a more interactive format such as a room on Discord or Zulip. We're happy to chat publicly or privately, at your preference. Please feel free to reach out to me at `james.munns at ferrous-systems.com`, or `sealed-rust at ferrous-systems.com`. Looking forward to chatting more with you. - James from Ferrous Systems
Well, if you interpret the blog post as merely "here's a path toward a specification", then I must say you interpret it wildly differently than I do. From the second paragraph: &gt;...use of a programming language and compiler within projects that have safety critical demands, such as Automotive, Industrial, or Avionics, requires a higher bar of entry than the Rust compiler can offer today. This typically includes "certification" of a compiler, which is difficult, if not impossible to do with today's versions of Rust. The entire point of the effort is to bring Rust to ASIL (ISO 26262) domains. That is the goal, not a stepping-stone toward C++ style ISO specification of the full language.
diesel is not async iirc, all the top performers in the database hitting benchmarks use an asynchronous database driver
I love this. Do you happen to have any minimum supported Rust version policy? If not, would you be willing to add one? (`lazy_static` is a core crate that very infrequently bumps its MSRV. If I am to use it---or `once_cell`---in other core crates, then I'd definitely prefer a similarly conservative policy.)
&gt; byteorder still supports Rust 1.12. serde still supports Rust 1.13 (and serde_derive still supports Rust 1.15). regex still supports Rust 1.24. This is not my idea of a good thing. This is my idea of libraries being substantially more conservative than most users are and therefore these libraries don't take advantage of improvements to the language. The worst offender here is `libc` that probably has soundness holes as a result. Now, I might agree to an LTS of Rust spanning 4 releases as boats suggested, but 18 months is quite another thing. [I have also proposed `#[cfg(version(..))]` and `#[cfg(accessible(..))]` to facilitate taking advantage of new language features](https://github.com/rust-lang/rfcs/pull/2523).
I don't know how special compilers improve the language? I must say that I haven't noticed much diagnostics of embedded compilers over those issued by GCC/Clang/VC. MISRA-C sure improves things (especially something like no heap allocation). But honestly that's only a patch because of the many holes that the language has (and most of those rules should not be necessary for Rust - neither directly nor in spirit).
&gt; specifying things that are UB rendering them implementation defined (not based on hardware but based on compiler This is fairly standard behaviour for other languages. What would be bad about that? &gt; I am concerned about SR not forming a subset but to have SR's and normal Rust's intersection be non-empty. I do not understand what you mean. Would you mind providing an example?
Thanks for the explanations. I now have a better understanding about your concerns
Thanks for the hints, esp. pointing me to the forum ! There's several open-source implementations of partitioned convolution already, i.e. in SuperCollider or the JUCE framework, so I assume that wouldn't be an issue. I've had a look at IPP, and there's also FFTW bindings that i've found, but i'd prefer pure Rust to be honest. I always wanted to take on the challenge of implementing PartConv, so let's see if i can find the time :)
Well it's not just the blog post, but also the discussion and how Steve suggested ISO standardization itself as a necessity.
Good point! I was only thinking of `macro_rules!`\-based macros. A custom proc macro would be a bit heavyhanded for this use-case, though, and I can't find one that's already been implemented elsewhere (the `array_macro` crate builds its array dynamically, so it can't be called in a `const fn` context).
I didn't say anything about soundness holes. That changes the equation, and if a library I maintain had a soundness hole and required a MSRV bump to fix it, then that's definitely something I'd consider. But that's a pretty fringe criticism of the policy. Otherwise, users of these crates generally aren't going to care whether a crate internally takes advantage of new Rust language features. You're honestly taking a pretty extreme interpretation here. Just because I think it's generally a good idea for mature core libraries to be conservative with their MSRV doesn't mean it must be done _at all costs_.
&gt; This is fairly standard behaviour for other languages. What would be bad about that? This is standard behavior for languages such as C++ and C. I see those as examples of what to avoid due to the portability hazards that exist and how e.g. linux uses `-fno-strict-aliasing` to essentially use a different language than standard C. &gt; I do not understand what you mean. Would you mind providing an example? Sure. As a strawman example, SR might say that the layout of the tuple `(A, B, C)` is the same as `struct Foo(A, B, C);` whereas standard Rust would the layout is the same as `(A, (B, C))`. These may be incompatible and so code written for SR may have UB when compiled with normal `rustc` or vice versa.
&gt; But that's a pretty fringe criticism of the policy. I did say that this was the worst offender and so not a general criticism of the policy. :) &gt; Just because I think it's generally a good idea for mature core libraries to be conservative with their MSRV doesn't mean it must be done at all costs. I think you are putting words in my mouth, ^---.
&gt; Cool. I undid my commit and added a test that fails without that line. I looks like the `discard_buffer` [was in fact needed](https://github.com/rust-lang/rust/pull/61157#issuecomment-495932676), so the commit was reverted and the only thing in this branch is a test case that ensure this behavior is correct (so the next time somebody wonders about it, it will fail tests if it's removed).
Resistance if futile. Your software will be oxidized.
Please reconsider the discussion in light of the original misunderstanding.
For those unfamiliar with the distinction: as I understand it, certifying software is more of a bureaucratic/best-effort process. It gives companies clear documentation of work done to reasonably ensure they're building on a solid foundation. This can include things that are fairly adhoc compared to what people consider *verification*. Like: hey we looked at the assembly the compiler produces and it seems reasonable... so this exact version we looked at is Good For Safety-Critical Things. It's a matter of ensuring companies aren't considered liable for using rust in production.
The point is that your comparison to C and C++ isn't really apt. The purpose of a certified compiler isn't diagnostics, or even, really, "improvement" of the language. The point is to mitigate hazards, where "hazards" are rigorously defined as ASIL levels in ISO 26262.
&gt; we did share this with the core team a few weeks ago, but it seems that information did not propagate as we hoped. This potentially is concerning; I'll take it up with folks from the core team. &gt; I'm still catching up on the many threads of conversation here, however there are a couple points I'd like to make: Thanks! These are mostly perfect points assuaging many of my concerns. &gt; I am currently in US Central Time I am in Central European Time (CET), Stockholm/Paris. &gt; [...], and we can coordinate a voice or video call if you'd like, or even a more interactive format such as a room on Discord or Zulip. We're happy to chat publicly or privately, at your preference. I have put your blog post/this reddit link on the language team agenda. Feel free to attend our meetings if you like and/or reach out on `#design` on the discord channel.
Sure; u/jahmez's elaboration here assuaged many of my concerns.
Wow, PGO is close to stabilization? That's cool. How big is the performance impact of using it? For example, has anyone tried compiling `rustc` with PGO and benchmarking it?
Woooo! Rust all the things!
The current MSRV is 1.31.1 (2018 edition). I haven’t thought a lot about the policy, but I think I can commit to not bumping MSRV in the foreseeable future. The possible caveat here is that I (optionally) depend on parking_lot, so that might change MSRV with the feature enabled. The whole parking_lot/std story is an unknown at the moment as well, but I don’t think that any outcome should change anything for once_cell. Unrelated, but you’ll love it: parking_lot is dropping dependency on rand, which should prune it’s dependency tree. I’ll think about it more and add a formallish policy to readme tomorrow.
Why shouldn't it be? My point was that you can coax C &amp; C++ into something which is used for safety critical systems. And this without being about safety or security. So why shouldn't it be possible for Rust? I understand what you are saying about compilers, but this doesn't have to do anything with the programming language per se, does it?
None that have any active members, that I know of.
I'm skeptical that there's much real conflict here. For this specific example, if Sealed Rust is intended to be an extremely conservative subset of the language, then of course it should require `#[repr(C)]` for any cases where ABI is significant (e.g. interoperating with C or assembly, or linking multiple programs together), not go off and do its own thing. I don't know /u/_photex_ and am not involved in this effort, but I speculate that they would agree with that. But if Sealed Rust decides to specify some random minor detail, for a specific Rust version which will never be upgraded, and the language team eventually decides to specify it a different way... That's definitely a situation we should try to avoid, especially because of the risk of creating a mismatch between the spec and what the compiler actually does (even the old version of it); but I don't think it's the end of the world if it happens. The kinds of applications Sealed Rust is targeting are highly domain-specific, bespoke, and walled off from the rest of the world; I don't see a realistic chance that 'Sealed Rust idioms' are going to start spreading through the community and create confusion. As you've mentioned, conflict with existing *code* making assumptions based on the current implementation is an ongoing problem. I expect it will continue to be one, but I don't think Sealed Rust will make much impact one way or the other. More broadly, I think your general reaction is overly hostile. People are coming on board, able to spend paid time on helping specify Rust: that's a good thing! We should look forward to working with them! It will be better for the Rust project the more they integrate their efforts with existing processes, but that's a reason to reach out to them, not to treat them like invaders. Even if coordination between them and existing team members costs some of the latter's time, they will add more bandwidth to the project overall. And their efforts will improve Rust for a use case which, while quite specific, is well within the scope of what Rust hopes to accomplish, and lines up extremely well with the ethos of software safety.
It is illegal to use Rust if you break the CoC, part of the license agreement.
Yeah, to be honest, if I were to use `once_cell` I'd probably just disable the `parking_lot` dep altogether, unless I could really measure a significant perf improvement with it. (It looks like `lock_api` is only used with `parking_lot`, but it's a distinct feature? So I'd probably disable that too.) &gt; Unrelated, but you’ll love it: parking_lot is dropping dependency on rand, which should prune it’s dependency tree. Oh yes, that would be great!
The reason I recommend IPP is because it pays to use the fastest FFT you can find, and it has a liberal license. It's going to be your bottleneck and while there are pure rust FFT libs, they probably are way too slow compared to IPP or FFTW. The problem with FFTW is the licensing, but API wise IPP is similar and beats it in most benchmarks. I cannot recommend against naive FFT implementations strong enough. Don't use them, it's bad for you and bad for your users. FFTW and IPP are battle tested and trusted, and it will he a long time time before anyone beats them in meaningful benchmarks.
You were responding to a comment about Rust's unsuitability in these domains "as-is", so I don't see how a comparison to such "coaxing" makes much sense. And, yes, MISRA *is* "about safety". And of course similar "coaxing" is possible for Rust; that's the point of this blog post.
*citation needed*
Are you suggesting you haven't read the license and CoC? :O
&gt; [...] not go off and do its own thing. I hope everyone agrees with this. &gt; But if Sealed Rust decides to specify some random minor detail, for a specific Rust version which will never be upgraded, and the language team eventually decides to specify it a different way... That's definitely a situation we should try to avoid, [...] What is a minor detail and not might not be clear. A minor detail might notably conflict with a new language feature or some important optimization. E.g. the `&amp;raw p.f` discussion would not be minor. I would hope that we avoid this situation by SR not specifying the random minor detail. &gt; More broadly, I think your general reaction is overly hostile. People are coming on board, able to spend paid time on helping specify Rust: that's a good thing! We should look forward to working with them! It will be better for the Rust project the more they integrate their efforts with existing processes, but that's a reason to reach out to them, not to treat them like invaders. I agree that this is a good thing, but I think you are reading too much into what I'm saying. In my original post, I am providing my concerns up-front to say in what direction I do not think we should take this. u/jahmez has already elaborated and assuaged many of my concerns. &gt; Even if coordination between them and existing team members costs some of the latter's time, they will add more bandwidth to the project overall. And their efforts will improve Rust for a use case which, while quite specific, is well within the scope of what Rust hopes to accomplish, and lines up extremely well with the ethos of software safety. Certainly; Software safety is a particular interest of mine. I am excited to work with Ferrous in the specification effort.
Dammit. Too slow again!
Wrong sub. This sub talks about the rust programming language, not the rust game.
Performance wise, std is just as fast: in both cases hot path is just a single atomic acquire load. The main benefit of parking_lot is that it’s small (one byte instead of a heap allocation), so, if you create once_cell per-object, you can save space. Another benefit is that it enables get_or_try_init API, which isn’t available with std However for static Lazy use case, both of the benefits are completely irrelevant, and disabling default feature is a good idea.
Oh my bad
t.me/rustlang_ru t.me/rustlang_en *hides*
&gt; I agree that this is a good thing, but I think you are reading too much into what I'm saying. In my original post, I am providing my concerns up-front to say in what direction I do not think we should take this. u/jahmez has already elaborated and assuaged many of my concerns. I apologize if I read too much into your posts, and I'm glad to see that things have taken a more friendly tack. :)
:)
Actually, I wonder if my claims about memory usage are true... Once::new is const, so it has to be stack allocated as well. I’ll need to check that more thoroughly.
I wonder if they are planning on making it async. Do you know?
Heh, I've considered learning Mandarin so I can participate in the Chinese Rust community. Perhaps I should add Russian to that list. A language barrier can be useful.
I know that Rust is dual-licensed under Apache/MIT, and I have read the CoC but I don't remember following the CoC being a prerequisite for using Rust.
I'm prettttty sure it was a joke.
I have a hard time seeing that kind of stuff :/
You should! Russian Internet community is extremely hostile to all forms of censorship of any kind. CoC, political persecution, you name it - all of them are ridiculed and shunned. So there you have it, the largest European Rust chat room with free speech policy.
I can't say I've seen that very often, but it's just like defining a constant in a module except that its visibility is scoped to the function.
&gt; *the whole point of inheritance* as opposed to these is that it involves "open recursion" - that is, a "tying the knot" pattern where method calls defined in a *base* object have to go through a dispatch step any time they're calling self-methods that may have been redefined in a *derived* object. You are correct, and in my opinion OOP is overused. Also in my opinion functional programming are more versatile and flexible than OPP; I had played a bit with Common LISP about 20 years ago, and nowadays Racket look interesting.
Considering most of the crates on crates.io are 0. releases and the std itself is barely out of the womb this seems unrealistic and perhaps rust is the wrong tool for that job.
I was doing the conversions manually, and then I found the derive-more crate (https://crates.io/crates/derive_more) which has a `derive(From)` that allowed me to delete all that code.
If someone knows potential customer for a half baked self hosted search engine I am interested and can deliver
That sounds great. Despite the claims that CoCs protect people like me, I feel a lot more comfortable in lightly-moderated spaces. Thank you for the suggestion.
Stack overflow can be index on a desktop without any problem.
Once upon a hypothetical time there was a town growing up around a lush pasture. This pasture wasn't owned by anyone, but just about everyone let their livestock graze there, goats and guineas, a few cows and even bunnies. Likewise the townfolk shared responsibility for keeping the pasture. They brought in manure and interesting seeds and if anyone noticed a noxious weed they, for the most part, either pulled it up or at least marked it and sought the attention of their neighbors for help getting rid of it. Sometimes people from the big city (where everything is owned by someone or more often by some *thing*, golems made out of paperwork and animated by laws) would visit the town and sneer at their anarchy and communalism. Who could make a fortune here? But it was 2019, and communal villages had proven quite successful. Some, like the Duchy of Torvalds, had grown to rival even cities. Most were quite tolerant of the better-behaved golems - in fact the village in our story had first been carved out by the kaiju *Mozilla*. The villagers were fond of immigrants. There was plenty of room for the pasture to grow into, plenty of work to be done, and on the plane of Soft Wares the fundamental laws of reality were not inclined to subject the villagers to scarcity. One day a villager brought a new golem to the village. The name doesn't matter (this parable doesn't need to get personal) but they came riding a golem named Lanate Systems and an idea rode with them. You see, there was a terrible need for organic, hypoallergenic bunny-wool blankets for immunocompromised babies. And the villager had worked the pasture and saw that it was a perfect place for hypoallergenic wool bunnies. At least, almost perfect. Such bunnies were *notoriously* picky eaters. And the pasture was only about 95% in compliance with the rules required for the label "organic". Some changes would be necessary for this idea to come to fruition. And so a fence was needed for Lanate Systems to be successful. Within the fence the pasture must be carefully weeded, so that the bunnies wouldn't hurt their tummies. And within the fence the pasture would be officially certificated by a foreign golem of officialness as to its organicality and wholesomeness. Another villager raised her eyebrow at this. A fence in the pasture? It wouldn't be the first one, but fences always made her uneasy. It's so much easier to end up on the outside of a fence than in. The keeper of Lanate Systems explained that grooming the fenced part of the paddock would take a lot of work, but the new golem was up to the challenge. A dragon would come and drop fat sacks of Legal Tender, which would empower the golem to undertake this task. Why, it wouldn't even be necessary to charge for the use of the organic, wholesome bunny forage! At this point the second villager spoke up. First of all, Lanate Systems was welcome to the genetic wealth of the villages pasture. Seeds, pollen, rhizomes were free for the taking and could be transplanted elsewhere. Lanate Systems could work its own land (on the plane of Soft Ware, undeveloped land is free) and fence everyone else out and make all the hypoallergenic blankets it wants. Wouldn't hurt her. Or Lanate Systems could make an argument for a new organic bunny-friendly part of the commons. A fence would be necessary to keep the bunnies in. It may be an inconvenience for others, but as long as the community agreed and this part was still common property and suitable for others to use *especially in competition with* Lanate Systems, they could make an argument for that fence. And Lanate Systems spoke again. *As long as the dragon delivers, there will be no need to charge any kind of rent.* --- So let me be clear: If Ferrous Systems expects others to to contribute and debug, it shall have *no right* to exclude its competition from the fruits of that common labor. If Ferrous Systems needs special treatment, that special treatment *must* generalize to benefit not just them, but their competition as well, and it shouldn't be an undue burden on Rust for non-critical applications Talk of subsidies and proprietary licensing (but don't worry that's only plan B) is evidence of missing the communal spirit of open source software. OSS is a wellspring of value. It's not *your privatized* wellspring. If a monopoly can put warm-fuzzies on the market, a competitive industry will put them on the market better and cheaper. Not only that, an attempt to monopolize will deeply wound Rust as a community. Therefore it is better for Rust to never break into the critical software space than for it to break in at the cost of its freedom. Anyone has the freedom to attempt a proprietary fork, that comes with the MIT license. But don't expect anyone to help, especially not for free.
Yet plan B is a propreitary fork, after you have solicited volunteer contributions with the understanding that the result would be free. While that's legal (a liberal-free vs copyleft distinction) it certainly strikes me as deeply contrary to the community mores. You're gonna have backlash. Better to fork now and be honest.
That's safety critical, not security critical
&gt; Federico Mena-Quintero is working on cleaning up Bzip2 and establishing a Git repository for it as it hadn't even been under a formal source control repository until now and also no bug tracker That's a major yikes, though I'm glad to hear the situation is improving
I think this very unlikely. Maybe there will be some popular tools and services written in Rust, but in general I would expect GC'd languages to be fast enough, and those already have more developer familiarity, and are easier in general. An experienced programmer can defeat any compiler by handcoding assembly, but there is a very good reason that very few do.
I'm trying to create a small game using glium and specs, I decided to create a Mesh component that stores the data needed to draw it, like so: #[derive(Component, Debug)] #[storage(VecStorage)] struct Mesh{ vertices: VertexBuffer&lt;Vertex&gt;, indices: IndexBuffer&lt;u32&gt;, } But then I got some errors, which are: error[E0277]: `std::rc::Rc&lt;glium::backend::Context&gt;` cannot be shared between threads safely --&gt; src\game\ecs\components.rs:7:10 | 7 | #[derive(Component, Debug)] | ^^^^^^^^^ `std::rc::Rc&lt;glium::backend::Context&gt;` cannot be shared between threads safely | = help: within `game::ecs::components::Mesh`, the trait `std::marker::Sync` is not implemented for `std::rc::Rc&lt;glium::backend::Context&gt;` = note: required because it appears within the type `glium::buffer::alloc::Alloc` = note: required because it appears within the type `std::option::Option&lt;glium::buffer::alloc::Alloc&gt;` = note: required because it appears within the type `glium::buffer::Buffer&lt;[u32]&gt;` = note: required because it appears within the type `glium::IndexBuffer&lt;u32&gt;` = note: required because it appears within the type `game::ecs::components::Mesh` = note: required because of the requirements on the impl of `std::marker::Sync` for `std::ptr::Unique&lt;game::ecs::components::Mesh&gt;` = note: required because it appears within the type `alloc::raw_vec::RawVec&lt;game::ecs::components::Mesh&gt;` = note: required because it appears within the type `std::vec::Vec&lt;game::ecs::components::Mesh&gt;` = note: required because it appears within the type `specs::VecStorage&lt;game::ecs::components::Mesh&gt;` So then, my question is: Can I somehow make this work? Can I implement the Sync trait, or could it be simpler to trade it off by making a `Vec&lt;Vertex&gt;` instead and building the `VertexBuffer` when drawing the mesh (if it isn't somehow slow to do)?
Great job! I think I can now deprecate [double_checked_cell](https://crates.io/crates/double-checked-cell) in favor of this. What are your current thoughts on a `LazyTransform&lt;T, U&gt;` primitive?
In this case the return type will contain closures and be unspellable, but that's useful for most scenarios. Thanks for the tip!
That would require `T` implement `Trait2` in all cases, while I'd like for it to be optional and only add more information about the return type when it's present.
This is an unfair characterisation and plan B is not a proprietary fork. It's just that if we are self-funding, we will have to capitalize on more of the documents that we write. I like y'all, but I'm not going to take a loan of this size for this project.
Based on reading your code, it seems like every single particle will get updated every time through, so cloning the whole vector probably isn't as inefficient as you think it will. You are also doing the whole process in an exponential way, so at the end of the day a linear re-allocation probably will not noticeably affect performance. That being said, your code also seems to be a bit wrong. If you update the positions of the particles one at a time like this you will get different results depending on the order you iterate through them. The gravitation effect on particle 2 is dependent on the position of particle 1, but if you update particle 1 before updating particle 2 then you will get the wrong answer, because particle 2's new position should depend on the \_old\_ position of particle 1. \`\`\` let new\_particles = self.particles.clone(); for mut sp in &amp;mut new\_particles { let mut a\_x = 0.0; let mut a\_y = 0.0; for p in &amp;self.particles { // ... } // ... } this.particles = new\_particles; \`\`\`
I think there are plans long term. But it doesn't seem to be particularly high on their priority list. In the meantime `tokio-postgres` is available and async.
Also, I personally would love to see something like this in the standard library. (I've previously lobbied to get `lazy_static!` into std, but there were issues with it that I unfortunately can't remember.)
There is a websocket example (using 1.0-beta4) here: https://github.com/actix/examples/tree/master/websocket/
&gt; tl;dr we let you focus on your app instead of dealing with infrastructure. And you offer static sites hosting for free. That's nice.
I realized that Pathfinder could do something very similar to piet-metal without using compute shader and filed an issue: https://github.com/servo/pathfinder/issues/185
Ah yep, looks like our marketing dept have bloated it somewhat. Thanks for that!
I'm doing precisely what you describe here with 1.0, you need [actix-web-actors](https://crates.io/crates/actix-web-actors) to get a ws working.
The certifications are for the language itself, not the 3rd party crates
I just tried using the macro and it works great, thanks!
Yay!
I think of certification as forming a human and organizational chain of trust between language designers and developers, as opposed to the mathematically verifiable chain of trust/authenticity/validity a verified toolchain can give you.
Yep. This way you can host everything in one place.
I noticed that you offer static sites but you don't have the most popular rust one, [Zola](https://www.getzola.org/). That would be a nice addition.
&gt; An experienced programmer can defeat any compiler by handcoding assembly, but there is a very good reason that very few do. I don't think this is possible anymore, given that any significant application would take 10 million lines of asm at minimum (for a ~40 MB app which is tiny, most apps now are in gigabytes, so it would be in the billions of lines of asm). No one person could do that, even over a lifetime.
This sub is actually for the programming language rust and not the game rust! I think r/rust_game is the right place! Still a funny encounter tho!
&gt;How to improve the global standard of living without continuing to accelerate our self-destruction? &amp;#x200B; FDD – Fearmongering Driven Development
Good to know! We'll add official support for it soon.
Doesn't seem to remember me.
I am not at all related to the rust core team nor any of the other languages mentioned in the blog post. Nevertheless, I think I speak aligned with e.g. Stroustrup with regards to an ISO standard: a specification comparable to what we have for C++ is really an anti-thesis for a good language. It is not testable, nor enforceable except for manual checking. This should not be the path for rust. Your blog post makes it seem as if that was one of the goals. If that is not so, you may want to clarify. I don't recall the exact requirements for ASIL certification, but a language specification for rust should, in my eyes, be written in a more formal language to avoid the blunders of C++. That is, it should be machine checkable and formally verified. I do not know if that would be sufficient or meaningful for acquiring a certification, but boy do I wish it would be.
I see... so as far as a user should be concerned, this is a reorg where the crate's functionality was split to multiple crates and if I'm missing something I just need to find the new crate it went to?
[removed]
Haha, Being a little bit more moderate I would call it SDD - Sustainability Driven Development
Yes, yes, yes, PLEASE YES!!! I work on spacecraft flight software and dealing with C all the time is very frustrating. We just spent three days trying to find a memory leak ...
It's interesting to note that a huge amount of MISRA C is "wow C is kinda a mess, here's how to avoid it", and Rust just eliminates those problems outright. MISRA Rust would be *much* shorter. Here's a quick skim through most of MISRA-C 2004, section 6 (~50% of the document): * 1.5: have a defined floating-point standard (rust uses IEEE-754) * 2.3-2.4: c does not support the nesting of comments, making `/* */` dangerous (rust does) * 3.2: use a defined character set (rust guarantees utf8) * 3.3: define how integer division works * 6.3: use uint32_t and friends, and not int and friends * 9.1: variables must be assigned before they are used * [a huge section on integer promotion, while rust never converts integers implicitly] * 12.9: don't negate unsigned integers * 12.10: don't use the comma operator * 12.13: don't write complicated expressions with the magic of ++ and -- * 13.1: don't do assignment in boolean exprs ((x = y) == z) * 13.2: do `if (x != 0)`, and not just `if (x)` * 13.5: don't write wild `for(x;y;z)` expressions * 13.6: don't mutate the loop counter in the body of the loop (`for i in 0..x` doesn't let you) * 14.4: don't use goto * 14.8-14.9: braces are mandatory on all blocks * 15.2: don't use switch fallthrough * 15.3: a switch must be exhaustive Now, granted there are several things that *do* apply to Rust, such as: don't recurse, don't shadow, don't `continue`, only `break` in one place, only `return` in one place, and so on. It's not The Perfect MISRA language, but it's *much* better.
I think you could do the same as above and manually create the closure, by storing whatever environment in the struct and then either just having a calling method or using nightly and implementing `Fn`.
[removed]
Spring itself isn't even a web framework though. Were you using Spring MVC or Spring WebFlux? Did you configure everything with annotations, with XML, or programmatically? Spring WebFlux with prommatic configuration is more similar to Actix than to Rocket. MVC is legacy.
Yes, I definitively prefer Actix documentation.
How extravagant? Is this being done on a custom server or...
Not super extravagant as the team will mostly be sophomores with a freshman and junior and most won't start out being super comfortable using Rust.
Well, with the proper designs you should be ok. If you are working on this over the summer, I suppose you should create an actual blueprint first. Midevil castles are always really cool, probably the best looking thing on rust to be honest, but if you are looking to do something cool maybe a whole city? Village?
I think you might be looking for /r/playrust, this sub is for the programming language named rust.
Any users of `proptest` have any tips for improving compile times? I love `proptest` as it is finding errors in my code, but my `cargo test` compile time has ballooned from seconds to multiple minutes, even when changing just a single function's tests. Is there some pattern of writing and combining strategies that leads to IR bloat or too much monomorphization that I can avoid?
It's interesting, but the verbosity makes me implicitly want to question the utility of the `Blanket` trait. It seems to be a trade-off in verbosity at the call-site vs verbosity in the definition, which would make it "user" vs "library writer" (unless you're both, in which case it doesn't make a different). If the point is to have a method like `fn&lt;B: Blanket&gt; blanket(b: B)`, then there might be a better way to do so to optimize for minimizing callsite verbosity, which would be like the `Iterator` implementors, i.e. creating a struct wrapper for each type which implements `Blanket`. Well, I tried to see if I was right, and I couldn't. Anyone else care to suggest something? [How far I got](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Astruct%20Wrapper%3CT%3E(Vec%3CT%3E)%3B%0Aimpl%3CT%3E%20Into%3CVec%3CT%3E%3E%20for%20Wrapper%3CT%3E%20%7B%0A%20%20%20%20fn%20into(self)%20-%3E%20Vec%3CT%3E%20%7B%0A%20%20%20%20%20%20%20%20self.0%0A%20%20%20%20%7D%0A%7D%0A%7D). In the end, I needed to qualify the callsite anyway (I purposely left `blanket(123)` incomplete. You'd need to add `blanket::&lt;CloneBlanket, _&gt;(123)`).
I was wondering what they meant with castles and such! I am talking about the programming language.
Maybe just create rustnomod on matrix or similar and have at it? It might be awful, it might not. Hard to predict, but I think I would prefer chat without moderation on principle.
Hey all, I thought I'd share some info on a book I bought recently. I occasionally keep an eye out for more intermediate level Rust content, and this caught my eye the other month. It's a good book that assumes you know a bit about Rust, but isn't overwhelming if you've worked with the basic data structures a bit. This book quite honestly was a great refresher on data structures in general! I learned a few details on some tree variants and vector structures I've never encountered. I think one good thing about this book is giving a very clear picture of what safe rust looks like when applied to data structures most of us are used to from other languages. I think that makes for a great context for learning about Rust because you go in with a set of questions already in your mind and see what aspect of the language was used to solve it. This book does not really go that deep on lifetimes or some of the complex things like PhantomData, but it does give a very solid and structured way at looking at more complex bits of Rust code. I know the Rust book ecosystem is small, but I'm curious if anyone else has any book suggestions! &amp;#x200B; Another book I'd recommend while I'm here is Data Oriented Design by Richard Fabian. &amp;#x200B; Have fun out there!
This is a new newsletter from Aimee at Cryptape about the Rust blockchain scene. There are many companies using Rust for blockchain projects. It's one of the industries Rust has had the most success in. I am hopeful this newsletter will bring more attention to it.
This seems very similar to what I get with my Firefox account and co
Yeah, I think that Rust is an obvious long-term choice for ASIL domains. (I agree that C is in some ways a mess, and I strongly believe Rust is a huge improvement over the previous state of the art, but to be fair, there are legitimate historical reasons for most of its shortcomings in that list. Also, doesn't C now also use IEEE-754?)
Blockchain is one of the industries to adopt Rust early and eagerly. And Rust is a great tool for this domain. There are so many companies and projects doing interesting stuff here. There are least 14 such projects, most of them backed by companies. &amp;#x200B; I hope this newsletter brings more attention to this space.
MISRA C prevents some foot-guns, but from what I've seen, standard (safe) Rust's guarantees are far stronger than MISRA C.
/r/playrust
&gt; rustc -O Note that `rustc -O` is equivalent to `-C opt-level=2`, whereas release mode[(as done from cargo)](https://doc.rust-lang.org/cargo/reference/manifest.html#the-profile-sections) uses `-C opt-level=3`
I recommend the [arr\_macro crate](https://crates.io/crates/arr_macro) referenced in one of your links. It lets you write clear and concise code that literally just expands to the super verbose 256 calls to AtomicUsize::new(0) that you considered. Plus the entire crate is only \~50 lines of code. &amp;#x200B; \`\`\` static COUNTERS: \[AtomicUsize; 256\] = arr!\[AtomicUsize::new(0); 256\]; \`\`\`
I mean, we saw the document, it seemed fine, and it's explicitly setting the stage for the actual collaboration, so at least I personally felt that it would be fine published as is. Any discussions about it could be had in the open, which is precisely what's happening now. They could have listed stakeholders with more granularity but imo it's totally fine to say you intend to work with the rust project (which they did!) and then building those relationships once the post is out, using the post as a way to do that.
Not at the moment, but I plan to add some to the docs soon. Here's an untested snippet that gives the general idea: let (reader, writer) = sluice::pipe::pipe(); // Could also be the same thread, different task. let producer = thread::spawn(move || block_on(async { // Could be reading from network. let random_buf = [4; 1440]; // Send 9 packets for _ in 0..9 { writer.write_all(&amp;random_buf).await?; } println!("producer all done!"); })); block_on(async { // A silly example. let mut number_of_zeros = 0; let mut buf = [0; 4096]; loop { match reader.read(&amp;mut buf).await? { 0 =&gt; break, len =&gt; { for i in 0..len { if buf[i] == 0 { number_of_zeros += 1; } } } } } println!("numebr of zeros: {}", number_of_zeros); });
Thanks for the ideas. I will definitely revisit these ideas when I come to optimise the algorithm.
That's a very good point, thanks! All calculations should be based from an identical set of particles, not a half updated set.
That's very neat ,thanks. This save me from having to to the self check too.
Awesome! Looking good. If you want to visualise the output, this may help you: [https://github.com/ackhia/n-body-simulator-rs/blob/master/src/main.rs](https://github.com/ackhia/n-body-simulator-rs/blob/master/src/main.rs)
That's not really the point, but also, I'm not really convinced either is "stronger" than the other; for instance, MISRA guidelines prohibit allocating heap memory, which is strictly "safer" than safe Rust, but isn't really a generalizable safety guideline for non-embedded systems.
r/lostredditors
oftc.net has its own community, its a bit small though.
I wish each of the rewrite in Rust efforts came with a “make Java//Python/C#/Node/Ruby bindings too” aspect.
I've found DI with manual construction to be extremely valuable, especially when fancy-pants reflection based containers blow up across different project types (common in .NET). &amp;#x200B; Thanks for this - so helpful!
Why not start a thread on 4chan?
&gt; Why do this? Well for one, it means that you don't need one event loop to rule them all. Since Rust has great thread support, you can create 1 thread for a timer loop, 1 thread for an I/O loop, and so on. Each of those threads only have to worry about multiplexing one kind of event, but futures for any kind of event can be chained together. Or you could go with a single threaded master loop, it's up to you. Either way, the efficiency of async usually comes from the ability to multiplex N logical "tasks" of some sort using M threads, where M may be 1, or at least M &lt; N. In the kernel world of interrupts, you can technically wake a future from a non-thread.
What kind of black magic is going on in the Fortunes benchmark? Round 17 came out October of 2018 and 400k was the number to beat. Now actix almost doubled that number. That's absolutely insane.
True, I didn't read carefully enough...
I seem to remember they upgraded their hardware. I can't remember when, but it might explain the bump in perceived performance.
You are misunderstanding parent's point. First I should say that I welcome your contributions, anything that can displace google in even the smallest niche is a very positive development in my estimation. &gt;Being a little bit more moderate I would call it SDD - Sustainability Driven Development You really really shouldn't. The last thing I want in my technology is someone's personal politics. Even if you are right it looks like rambling. Even if you are right it screams that you don't know that you should keep it to yourself. I could go for hours ranting about Google (this is an anonymous account and I just might if you goad me into it), but I wouldn't go on tirades against Google and the ~~illuminati~~ the 1% if I were in your shoes and had to sign my name under it. People who care already understand it, people who don't think you are like Jehovah's knocking at 6 am. Also, to recycle this comment, people get confused when you say 'Google' but actually mean 'Google services', justifiably so as the word in its verb form is a neologism that means using their search engine and not other services.
Could you add one line explaining what is once_cell ?
I was responding to the claim that Rust is currently unsuitable because the language is designed for security and not safety (e.g. because panics are evil). We don't have to argue about the state of the compiler and standard lib not having a high enough trusted tool level to e.g. fulfill ASIL-D requirements. Maybe we should not mix Rust and rustc? Oh and sure, while we are at it: We would also need a tool that restricts the language to that hypothetical MISRA-Rust, we need a coverage tool that measures (M)CDC, probably more static analysis tools than clippy, etc.
One of the examples I give often is `rayon`, which wanted to support Rust 1.13. This made it impossible for them to upgrade their `crossbeam-deque` dependency, staying on a very old version that missed correctness fixes and performance improvements, and increasing build times and code size for their users.
i don't think this will happen. i personally wouldn't switch to a different etcd-rust just because it is slightly faster. normal etcd has a huge community that will help for bugfixing, new functionalities, guides&amp;tutorials, doc for ops.
It would be really helpful if the MISRA-C standard (or also MISRA-C++/AUTOSAR-C++) would be separated into "make C sane" and the safety part. How does Rust fare on my personal favorite rule "the result must be the same under every order of evaluation" (or something like that)?
I miss mp3tag on Linux although there is puddletag (Python + PyQt). For short it's an audio metadata editing GUI software with table view at its core. Just a project idea that's on my mind, nothing else really. Relevant links: http://www.mp3tag.de/en/ https://github.com/keithgg/puddletag
I personally am dying for a library to provide me with thread-safe data structures of all types. Circular Buffers, AVL Trees, Suffix trees and Huffman Trees. No I'm not a professor, I'm just realizing the actual use cases of these data structures when trying to optimize for performance with Rust.
Do you have a fdroid repository for the android app, for people not having gapps installed on their phone?
Eh, kinda. Unless you're writing a kernel and the future exists in kernel space, then the future has to be polled from _some_ thread in userspace. The kernel can do the waking, but re-polling the future is done by a thread. Or maybe I'm just trying to give you a hard time...
Looks like it's just using the default cached per-thread rng: - https://github.com/thedrow/fastuuid/blob/3c8eba1c9de669f6ad5da3fe5c4d1cfc325f0796/src/lib.rs#L419 - https://github.com/uuid-rs/uuid/blob/ccbdf051a066683611161c1442d20261dbb7a98c/src/v4.rs#L29
Subsets of C and C++ are used, MISRA-C or C++ for example, and that subset is designed for safety. Then there are static verifiers used to make sure you stick to the subset and out of most UB.
This is good, and I really wish LZ4 can be rewritten in Rust as well.
I open sourced a repository I've been tinkering with - [Alchemy, an experimental GUI framework](https://github.com/ryanmcgrath/alchemy). The idea is basically to port the React Native API to Rust. It's still very early/experimental, but things like CSS parsing, layout, components and so on are implemented. The current demo only runs on Mac, but if you're a GTK fan and looking for a project to mess with... :) Would be curious on thoughts from people.
Of course it is. Write your application in a normal language first, compile to assembly, and make a single improvement. You've now handcoded something better than the compiler could produce. Now keep going. Of course this isn't cost effective for all but the hottest of loops, and even then in most situations it's not worth it. Which is my point; just because something has higher performance doesn't make it cheaper, as OP suggested. They have reduced the choice to a single metric, while actually many qualities are relevant. Rust *will* be used for some things in the cloud, but I don't expect it to become the leader any time soon.
Is there a way to pass a build flag through cargo's command line? Doing it through rustc is [simple](https://doc.rust-lang.org/1.19.0/book/first-edition/conditional-compilation.html). The thing is that I frequently profile my code, [profiling](https://github.com/AtheMathmo/cpuprofiler) should be done in release mode, and removing the code for a "real release" build is annoying. So I want to do something like `cargo build --release --DO_BENCHMARK=1`.
If you can create devices via RawFd would open using this on Android (would require Java to get the open device) and would play nice with tokio-udev as a means to get devices as they are plugged in.
Just like with libsvg the public API will remain the same, so existing bindings should remain functional.
I am trying to implement merge sort, in the merge function I had to use a lot of unsafe, is there a less unsafe way of implementing it. [playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=40c3414c8d3a011dfc8eec6c35143fb6)
We considered so many puns, and Sealed Rust seemed to fit the bill the best :)
I wouldn’t like the acronym that much.
it's not too late
I believe Rust has a defined order of evaluation.
Doesn't a rust rewrite make that easier though? You still need to keep a C interface so you'll probably create the C header files with cbindgen. Then you get headers that are easy for SWIG to parse and from there it is easy for other language users to make idiomatic bindings in their language.
I know - I work in the field. But you could probably derive such a subset for Rust in a couple of days (from C/C++/Ada style guides + some unsafe rules). Some of those rules are also already in clippy. And those static analyzers catch some style violations, but it's not a silver bullet, because some rules cannot be automatic and many of them are really hard to analyze.
Sadly it was made too late in 1925
I wouldn't know unfortunately, I only started using it recently.
Thanks for this, I'll have to check this out!
After searching around a bit it turns out *Data Oriented Design* was made available available from the author [here](http://www.dataorienteddesign.com/dodmain/) should anyone want to check it out. It looks like it focuses on C++, though.
I mean, most of the time, I *am* writing a kernel. :P That said, I am curious if there are any system calls that take a callback address to create something like a micro-thread.
Are there any ORMs that have good automatic migrations? I've only really worked with MS SQL Server there we had old, hand coded schemas. We bought some tool that was considered the best for making migrations, but we still had to tweak its results. Then again our schemas were more advanced than most and we always worked with replications that further complicated things.
I've been working on a [command line client](https://github.com/daboross/srvc) for an open source MMO game I've played in the past. It's been a fun experience working both with the cursive TUI library, and with the new `async/await` syntax on the networking side of things. My last attempt at a client failed due to my lack of graphical programming knowledge, but working on a terminal interface instead has been pretty great.
Create Rust bindings to the Halide language. You might get some inspiration from the python bindings that use PyBind
By comparison, the standard library's uuid4() goes straight for the system's csprng (getentropy(3) / getrandom(3) / CryptGenRandom / /dev/urandom).
&gt; Making a vector internally calls malloc and malloc is slow. TBF every to_string calls also allocates so this is a rediction in allocations but not a removal of all of them. Loading the entire thing in memory and just storing references as /u/thiez suggests would be a much better way of saving allocs.
Hi, Currently no, because it seemed too much effort before launching the beta, but it's on the roadmap: [https://gitlab.com/bloom42/app-Android/issues/1](https://gitlab.com/bloom42/app-Android/issues/1) Also, if you have the technical skills, you can build it yourself as the code is on GitLab: [https://gitlab.com/bloom42/app-Android](https://gitlab.com/bloom42/app-Android/issues/1)
Hi, I think you also miss my point. Please refer to this video: [https://www.youtube.com/watch?v=u4ZoJKF\_VuA](https://www.youtube.com/watch?v=u4ZoJKF_VuA) to understand why I started with **why** and not **what**. &amp;#x200B; Even if the blog post is not crystal-clear, I'm talking about facts, problems and solutions. Nothing but the Google vs Huawei justify a free and open source world.
ooh, I was just wondering about a book like this, thanks!
You can have a look at this MR: [https://github.com/diesel-rs/diesel/issues/399](https://github.com/diesel-rs/diesel/issues/399)
Thanks, I measured a 20% speedup from opt-level 2 to 3 (excluding IO time).
You could probably just do it like this: https://f-droid.org/en/docs/Publishing_Nightly_Builds/
They talk about restricting this to #[no_std] and libcore as if that makes the subset of the language smaller, but actually #[no_std] and the features required to make that useful are “extra features” that the language originally did not had. So what is it? Do they want to focus on #[no_std] or do they want to focus on a smaller subset of the language? AFAICT those are incompatible.
Why does `cargo build --release --features benchmarking` with `benchmarking = []` in Cargo.toml and `#[cfg(feature = "benchmarking")]` inside *.rs not work for you? This procedure is literally documented at the link _simple_ you provided… what am I missing?
Adding `mut` to a `let` binding does two things: * It lets you reassign the name to another value with the `=` operator, and * It lets you take a `&amp;mut _` mutable/exclusive borrow of the value. Your `apple_iterator` example relies on the latter, but it sounds like with “change it to an other iterator” you’re only thinking about the former. Note however that a function that receives a `foo: &amp;mut T` mutable borrow can also re-assign the entire value with code like `*foo = bar();`, so these two things are not fundamentally that different.
libc is also special, it is linked with the standard library, so bumping its version would probably break the world.
Immutable iterator wouldn't make much sense. Consider the following. struct Range { low: i32, high: i32, } impl Iterator for Range { type Item = i32; fn next(&amp;mut self) -&gt; Option&lt;i32&gt; { let Self { low, high } = self; if *low &lt; *high { let current_low = *low; *low += 1; Some(current_low) } else { None } } } `self` needs to be mutable in order to allow for modifications of `self.low`. In most cases, you want a mutability of some sort, without mutability you would be pretty much able to only implement `iter::empty` or `iter::repeat`. If your iterator makes use of interior mutability and doesn't need mutability, you can implement `Iterator` for `&amp;YourStruct`.
Another way to think about this: let’s say that the iterator type is a `struct` and the implementation of `next` needs to reassign one of the fields to a new value: `self.foo = bar();`. There is no `mut` keyword on the declaration of struct fields. Instead, Rust has what we call “inherited mutability”: the fields of a struct are mutable if the struct value itself is mutable. So even if you don’t reassign the whole iterator, `let mut` is necessary to allow `next` to reassign a struct field.
Only infinite iterators always returning the same item can be immutable, so I don't think it makes sense to have a separate trait for them.
You don’t need an ISO standard specifying Rust to be able to use Rust in domains that need certification. What you need is a certified toolchain and process. You can just pick a commit of the Rust toolchain, and pay a consultancy to certify it for some application. Every time you need a new toolchain, you can just repeat that. Certification involves things like making sure bugs are documented, that the toolchain is properly tested on the actual hardware (unlikely to happen in the open because of NDAs), etc. Many things are already in place, and other are so specific to each application that unless the vendor of the hardware provides you a certified Rust toolchain, each application is going to have to go through the certification process anyways.
Dupe: https://www.reddit.com/r/rust/comments/bx5ajg/bloom_a_free_and_open_source_google_in_rust/
Is their a shared database instance for the free version like heroku does?
Every time you call `next()`, you _are changing apple iterator_. Each call advances the iterator one item! Imagine I have this code: let mut apple_iterator = [1, 2, 3].iter(); apple_iterator.next(); println!("{}", apple_iterator.next()); If I run this, it prints 2. But if I remove the second line, it prints "1" instead. This second line _is_ acting mutably. apple_iterator _isn't_ the same iterator after the second line - the original iterator would have returned "1" from `next()`, but the new iterator returns "2" instead.
macro free lazy_static is the best one-line description I came up with :) The docs are pretty extensive and cover a number of patterns of usage: https://docs.rs/once_cell/0.2.1/once_cell/
Congrats! I tried the beta a few days ago and really enjoyed it. Can't wait to get back at it :)
I don't have a clear understanding of how something like `OnceSwapCell&lt;T, U&gt;` should fit into the picture. Basing `OnceCell&lt;T&gt;` on top of `OnceSwapCell&lt;(), T&gt;` seems neat, but: * it's not too straightforward, because `OnceSwapCell` needs a third state for when the initial value is taken, but the final value is not yet emplaced. I guess, with `MaybeUninit` we can implement this without creating additional states * `OnceSwapCell` seems very marginal, in comparison with `OnceCell`, and it's not clear if there are really benefits to not treating `OnceCell` as a primitive. That said, I certainly already use [`SwapCell`](https://github.com/rust-analyzer/rowan/blob/50587e0de7b5318aec7a835a67eedd1a4945a813/src/swap_cell.rs#L15-L18) in rowan, so it's not too marginal. I guess I'll start with publishing a completely separate `once_swap_cell`, just to see how the API feels like.
Yeah, I also feel that this should really be in std. Java and C++ even have this built into the language! I am not sure what is the correct API for this though, but I think that `OnceCell&lt;T&gt; / Lazy&lt;T&gt;` is a good combo. Unfortunately, just `Lazy&lt;T&gt;` won't be enough, because that won't work for fields (you really need to supply lambda at a call site in this case). The two not clear cut things with the current API are * an `F = fn() -&gt; T` default parameter. It makes the syntax work nicely with `static`'s, but it does feel like a hack for cuteness, and not like something essential. * I am not sure whether `OnceCell&lt;T&gt;` is primitive enough. `OnceSwapCell&lt;U, V&gt;` which applies `U -&gt; V` once is in theory more expressive, but clearly much more marginal.
Oh, and thanks a lot for making `double_checked_cell`! The current implementation is basically it :-)
Cool project, but calling it "a Google" and not having the one thing everyone associates with Google is a bit of a blunder.
Thanks ! thats a really good start.. at the moment i'm actually working on the analysis stage myself..
A *lot* of common unix software is like this. It was written long ago and released as tarballs, and now lives on as forks in each distro's repositories, with patches occasionally exchanged between them but no formal upstream.
For majority of apps you have it needs to be able to directly integrated with mobile and/or desktop environments to be useful.
We genuinely do want 256 elements, and 256 is a power of two, so perhaps all i need is a macro `twice!` which repeats its argument separated by a comma, and the write: ``` static COUNTERS: [AtomicUsize; 256] = [twice!(twice!(twice!(twice!(twice!(twice!(twice!(twice!(AtomicUsize::new(0)))))))))]; ```
If you CSV only has the two relevant columns, I would try reading the whole string into one big String and then create a Cursor on the string and use a HashMap&lt;&amp;str, &amp;str&gt;. That will mean 1) less I/O switching, 2) less cloning. Of course, if you need to unescape the strings, this won't do.
That's very unlikely to happen and performance alone is not enough. On a larger scale, it would require some large and influential organization to adopt Rust (Microsoft). On technical side it will require good story for async, and that's very far from being usable.
Indeed, pure powers are the easiest case here. And to make it a little less verbose, it could even look like `multiply!(2*2*2*2 * 2*2*2*2, AtomicUsize::new(0))` :)
Not that I know of. You could search for crates that seem likely to have been split at some time in the past e.g. by looking for patterns (`&lt;crate&gt;-core`, …). There is `num` (now a _supercrate_ as I call it). [Initial GitHub issue](https://github.com/rust-num/num/issues/102) with [respective PR](https://github.com/rust-num/num/pull/164). I guess you plan on letting the original `pushrod` just re-export from `pushrod-core` and `pushrod-widget`. Somehow, you need to verify that the surface API has not changed. Doing it meticulously, you first might want to copy all items from `pushrod` to the new crates, then in a second step, replace item definitions in the original crate with `pub use`s to the subcrates and finally, simplify those, e.g. via `*`. For me, this looks similar to breaking up a file into several file-`mod`s, just at a larger scale. There might be articles about this on the internet.
When do I use `println!`, `eprintln!` and especially `info!` compared to the other two? What about `write!`?
When do I use `println!`, `eprintln!` and especially `info!` compared to the other two? What about `write!`?
I'd say that it is to mark a variable explicitly as a constant. Non-mutable variables can be shadowed, constants can't
Is there any documentation on the technical architecture? You talk about encryption, does that mean end-to-end encryption? How are the keys managed? You seem to have invented your own configuration file format. Why?
Immutable iterators just means that you would have to change `next` to `fn next(self) -&gt; (Self, Option&lt;Self::Item&gt;)`
&gt; (Manga Guide) what /u/steveklabnik1?
Claus Matzinger is, by the way, a member of the Rust Community Team.
Thanks for taking the time to review this. And also naturally Claus M for taking the time to write it!
It’s a weird bug in amazon, I dunno. I told no starch about it.
And now it's also listing you as Steve Klabnik Klabnik.
&gt;tokio-udev How did I not find this crate? Seriously, this is going to make my life so much easier. Thank you for mentioning it.
Do I really need to make my key be a Vec? Isn't the Borrow trait used to fix these kind of issues?
I did think that was a bit wierd but left it in becuase reasons? any way, fixed!
Here's why I never tried Tox chat - it was developed by a bunch of obnoxious anons with everything around them screaming amateur hour even if the idea was brilliant. Similarly never bothered installing Notepad++ because the author packed it with politics. It's *not* because I don't agree with their politics, it's because of their inattentiveness to details which I fear will lead to other issues with software. &gt;I'm talking about facts, problems and solutions. My knee-jerk reaction when I saw 0.7% was to stop reading. I really don't have patience and it taints everything. That's a problem Bernie Sanders can solve, not a piece of software, however revolutionary it is. Your message will be better received on Reddit, on this sub because it's Rust, elsewhere because it's filled with progressives. Half of HN on the other hand will be instantly turned off because they are plugged in Google Borg one way or the other and the other half with libertarian views and their 0.7% aspirations will clash against your political side of your software. &gt;it's because I'm talking about the **why** Hating on Google isn't anything new, "why" in the context of owning ones data has been mulled over since forever, starting with Stallman. It still doesn't change the fact that everyone is filling their living rooms with cloud connected assistants. As I said, I like that you are trying to steal Google's pie, I wouldn't even bother replying if I didn't want only best wishes and success, but you are hurting yourself unnecessarily.
It's the opposite way - your key type must be `Borrow&lt;T&gt;` where T is your range type. So you can have a map of `&amp;[_]` and use `range` on it with a range of `Vec&lt;_&gt;`, but you're doing it the other way around.
Yes, but it is often in this way that the types coexists. The longest livings are in a map in a struct and axternal users asks for data using short living types like a slice. Isn't there any way to request a range using a slice on this map of Vec?
The signature of the BtreeMap::range method implies that I must found a `K: Borrow&lt;T&gt;` where `T` is the range type and `K` is the key of the BTreeMap. In my case `K` is a `Vec&lt;i32&gt;` and I want `T` to be a `&amp;[i32]`. This is not compiling because the only implementation of `Borrow` for `Vec&lt;i32&gt;` is `Borrow&lt;[i32]&gt;` and I have `Borrow&lt;&amp;[i32]&gt;`. I can not deref my `&amp;[i32]` because a type on the stack must be sized...
Java also has some security certifications for critical deployments, e.g. IBM, PTC and Aicas offerings based on Real Time Java.
It doesn't work, because `u32` doesn't implement `Into&lt;B: Blanket&gt;`. In order to make it work we need impl&lt;T: Clone&gt; From&lt;T&gt; for CloneBlanket&lt;T&gt; { fn from(t: T) -&gt; CloneBlanket&lt;T&gt; { CloneBlanket(t) } } Unfortunately the compiler still requires annotation for `blanket(123)`. It refuses to decide into which struct implementing `Blanket` `u32` should be converted even though there currently is obviously only one.
you are totally right, offline first is planed for Q3 2019 :) [https://www.kerkour.fr/blog/bloom-a-free-and-open-source-google/#in-summary](https://www.kerkour.fr/blog/bloom-a-free-and-open-source-google/#in-summary)
Work in progress. end-to-end encryption is planned for Q4 2019, currently all the data is stored on an S3 with encryption activated. Regarding SANE, you can learn more here: [https://gitlab.com/bloom42/sane/tree/master/pages](https://gitlab.com/bloom42/sane/tree/master/pages) :)
That's a good summary! Both go hand in hand in the ideal case.
I'm don't think it's too much politics, it's practical reasons. I'm totally not in the **free vs open source war**. &gt;Bloom conciliate the best of the **Startuplaland religion**: *radical execution rather than bureaucracy, scalability, flawless user experience, strong product culture, iterative process*, and **open source**: *a mode of development that has proven its superiority, open governance, an unmatched sustainability and a perfect symbiosis between the interests of developers and those of users*.
Nice idea. Good Luck.
new version [http://www.dataorienteddesign.com/dodbook/](http://www.dataorienteddesign.com/dodbook/)
Yes, an MSRV policy competes with other things. For example, it can be difficult to uphold an MSRV policy if your dependencies don't. In that case, I'd weigh the negatives of hanging on to a no-longer-maintained version of a dependency vs updating the MSRV vs dropping the dependency entirely.
&gt;I'm totally not in the **free vs open source war**. It wasn't my intent to imply that. &gt;I'm don't think it's too much politics &gt; &gt;"How is the world's wealth shared amongst its population?" That's what everyone thinks about their political views, that they are perfectly reasonable and not at all over the top. I'm not criticizing your views mind you, merely saying that they are, in my view, redundant to the product and detrimental its adoption. Anywho, I added my 50 cents, you do you, and I wish you all the success.
Another one here https://github.com/CodeChain-io/codechain
Thank you very much for your honest feedback. We will take care to learn from it when things will slow down :)
Thank you!
Very interesting project. There are a few mentions of the whole thing running on rpi. Is there any image or document on how to set this up? Will it run on a lone host or network behind an air gap?
Is there a way to parse the Result of a function with if-else instead of match?
I could get this work by using the `(Bound, Bound)` impl of `RangeBounds` instead of `RangeFrom`: use std::ops::Bound; let mut iter = map.range::&lt;[i32], _&gt;((Bound::Included(key), Bound::Unbounded)); The underlying issue is [RangeBounds impl](https://doc.rust-lang.org/std/ops/trait.RangeBounds.html#impl-RangeBounds%3CT%3E-1) having an implicit `Sized` bound on the generic parameter. I think this bound (and for related impls) can be relaxed without any problem.
Hi, Thank you for the kind words. I've mot yet tested, but it should compiles on a RPI. An issue is open regarding Providing ARM docker image to ease self hosting : [https://gitlab.com/bloom42/bloom/issues/4](https://gitlab.com/bloom42/bloom/issues/4) It's just a matter of time :)
Awesome! Here is the fix you found! https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=5919ea0c72feda3e904e1360d76ec8b1 Hummm, you are probably right about the fact that RangeBounds could accept unsized types as generic parameter. I do not know why SimonSapin [only specified `?Sized` for some but not all RangeBounds impls](https://github.com/rust-lang/rust/issues/30877#issuecomment-377552775). Thank you, anyway!
Can you elaborate on your point about `#![no_std]`? That flag does nothing else than remove `std` from the automatic prelude, so it doesn't require any additional language features. As for the "extra features making" it useful I assume that you mean things like proc-macros, which I guess can be separated into a non-specified AST producing macro step and the specified AST-consuming compilation step?
by Dethroning of NodeJS i.e. also Javascript.
I would like to create a series of crates that provide a common interface (trait) for some data structures, starting with trees. This basically has two intentions: improve interoperability and reduce implementation cost, because, just like Iterator they would provide some default implementations, for example for searches and many kinds of (filtered) traversals. So basically my question is: does this already exist? I searched a bit but did not find anything. And: is this even a useful idea? I really like the Iterator trait, and the num crate seems like a good idea, too.
Hi! I proposed their stabilization, but I’m pretty sure at least some of these impls existed before I was involved. As far as I know there is no problem with relaxing these implicit bounds, it just didn’t occur to us (the libs team) at the time. Would you like to send a pull request?
you can use if-let for that: if let Ok(value) = may_fail() { dbg!(value) } else { println!("oh no something went wrong!") } if let works on more then just results, you can do pattern matching with it, just like with match.
I will do that in a moment :)
Hey, nice to see other small games in this space! I recently posted [a Pong game](https://www.reddit.com/r/rust/comments/bv41o9/a_pong_game_with_wasmbindgen_websys_and_jssys/) with a similar stack.
How is the readability? I often struggle with these books writing style, but another rust book, "Programming Rust" I found to be _excellent_. The writing style kept me engaged, somehow making it not dry. How does this book feel on that tone?
Hi Nico you can still add yourself to the waitlist plus we're opening up more spaces based on demand.
Another option is something like `let particals = Cell::from_mut(&amp;mut *self.particals).as_slice_of_cell();` which turns `&amp;mut Vec&lt;Partical&gt;` into `&amp;[Cell&lt;Partical&gt;]`. That way, because you only have shared `&amp;_` references and no exclusive/mutable reference `&amp;mut _`, you can have the nested loop without without any borrow conflict. The trade-off is that you can’t access for example `sp.x` directly, instead you have to use `Cell`’s methods with something like this: `sp.set(Partical { x: a_x * args.dt, y: a_y * args.dt, ..sp.get() })`. (If `Partical` cannot be `Copy` consider making it implement `Default` and use `.take()` instead of `.get()`.) * https://doc.rust-lang.org/std/cell/struct.Cell.html#method.from_mut * https://doc.rust-lang.org/std/cell/struct.Cell.html#method.as_slice_of_cells These methods will likely be stable in Rust 1.37. At the moment you need to use Nightly. (Or copy-paste their `unsafe` implementation into your code.) By the way, when asking for help with a bit of code, it would be nice to make that code self-contained and running on https://play.rust-lang.org/. That way a response can also include (modified) running code.
println! prints to the standard output, while eprintln! prints to the [stderr](https://en.wikipedia.org/wiki/Standard_streams). Those are unixy concept, one primary noticeable difference is that if you redirect your programs output by default only stdout gets redirected, stderr is still output to the terminal. If you want to add logging infrastructure to your application you might want to check out [log](https://crates.io/crates/log) for your libraries and applications and [env_logger](https://crates.io/crates/env_logger) for actually doing the logging in your application (sidenote: reddit is only letting me post one post per seven minutes, probably because im new and have no karma, which is slightly annoying..)
The solution described in the article has similar wost-case noise on caller side, but has zero noise when compiler finds out that passed argument implements Blanket only once.
depends on what apps can be build with those X times more performance gains as opposed to other out of date languages like Scala and Kotlin, once its clear no other mode can get the job done, rust will be only language that will remain on Cloud.
Man I was all excited for a moment. I thought you made some type of "visual novel" for Rust, full of Artwork and junk. I don't even want this level of "Learning Rust" books _(massively happy with Programming Rust)_, but I might have to pick up an actual Manga Guide to Rust lol.
It's probably not what you want to hear, but I'd also look at [Programming Rust](http://shop.oreilly.com/product/0636920040385.do) and [Rust in Action](http://shop.oreilly.com/product/0636920040385.do), whose author is also a Redditor. From the three Packt books, I'd probably pick the last one, because its author contributes to the compiler and some open-source crates. But in general I've heard bad things about Packt publications, and I wouldn't get one of their books without a very good reason.
I do own some of the actual “manga guides”, and they’re pretty great to be honest.
Here is the pull request. https://github.com/rust-lang/rust/pull/61584
/u/matklad is there a future where this crate grows a *no_std* compatible variant?
You can also have both, a \`main.rs\` and a \`lib.rs\` in your project. Keep in mind that the \`main.rs\` is used when you invoke \`cargo run\` and the \`lib.rs\` is used when you invoke \`cargo test\`.
I think no_std should just work for unsync version. I am not sure what to do with sync version though, as it needs ability to block the thread until some event occurs, and that requires a syscall. Do you think that just the unsync half would be useful?
I'm liking the effort to port even lower level libraries because it'll encourage rust in 'unusual' platforms which is usually the excuse for 'highly portable C projects' to discount rust immediately.
Nice, another WASM Tetris: [https://xuu.github.io/wasm-tetris/](https://xuu.github.io/wasm-tetris/)
Django's is a good example.
Oh no! I'm in town till the 15th. Some other time :)
/u/__fmease__ is right, but to answer your direct question, \`cargo rustc\` is what you use to pass something through to just your crate, and \`RUSTFLAGS\` is what you use to pass something to every crate.
Do you want next to produce a new iterator? I don’t understand what you’re asking after.
I haven't come across cells before, that's good to know. Thanks for the heads up about the playground also, will do.
I have regretted every Packt book purchase I ave ever made.
I added myself to the waitlist, and it seems I have a space now :)
Makes me wish they'd gone with another publisher. Packt has pretty poor quality control.
&gt; how e.g. linux uses -fno-strict-aliasing to essentially use a different language than standard C A lot of this is largely due to compiler writers unilaterally changing the meaning of "undefined behavior" from what it originally. It was meant as "the result of doing X is not defined to not require emulating any specific behavior". How it's used nowadays is "a single instance of doing X allows the compiler to change the entire rest of the program completely" (and I wish I was exaggerating here).
Not the OP but I think their point is that Rust is simpler without the ability to write `#[no_std]`, that is, `#[no_std]` itself is a feature of the Rust language, and removing that simplifies the language, while allowing people to write `#![no_std]` makes the language more complex.
\&gt; But this still odd to me that you always need to declare an iterator with mut, even you never change it to other iterator. This, I think, is your main point. Is weird, I know. For example adding a vector is like this: fn main() { let mut a = vec![1, 2, 3]; let mut b = vec![4, 5, 6]; a.append(&amp;mut b); assert_eq!(a, [1, 2, 3, 4, 5, 6]); assert_eq!(b, []); } The thing is that rust like to inform you, ALL THE TIME and by triplicate what is happening behind your backs. &amp;#x200B; Also, mutation on rust is not bad. I come to rust after F# so this was a shock, but the thing is rust make mutation controlable. And honestly, imperative and mutating code is much nicer a lot of time.
I'm working in a [relational language](http://tablam.org) and researching about it (the relational model, how (in-memory) databases work, columnar data, building programming languages) have been very fun. And still, somehow is a reachable project to make a sql-like language for in-memory structures. I move slowly because my main work is full and come to rust AND also do this, but I see a small team to make a decent first implementation of this.
&gt; Rust Programming By Example Even `Rust Programming By Example`?
Nice one. I just tried it and the ball got stuck in the panel. RIP headphones lol Nice idea hosting it on a github page, will do that next :)
Wow this stuff is pretty cool. I modified your setup a bit so I could make a kind of "dictionary" to search in the whole map. I arrived at [this](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=4d0531f2f8714628b2076ded9dcc37d2) and I think I found a bug in `range`'s implementation: if you change the second element of the range tuple from `Included` to `Excluded` the "chlorine" assert will fail either way. I'm actually impressed it doesn't respect the enum variant.
you're welcome ;) look forward to seeing you there.
Another time maybe, you're always welcome.
If you keep ABI compatibility (which I expect to be the case here), existing ones will work fine.
&lt;3
Agreed, ["Programming Rust"](http://shop.oreilly.com/product/0636920040385.do)(http://shop.oreilly.com/product/0636920040385.do) is incredibly well-written and engaging, which is impressive given the depth they go into on a lot of the heavier Rust topics.
"Programming Rust" is, in my opinion, exactly how a programming book should be written.
In addition to what djugei mentioned, `info!` is from `log`, and its behaviour will depend on how the logger (if any) is configured. While `println!` and `eprintln!` will unconditionally write to stdout and stderr respectively, `info!` might write to stdout, or it might write to a file, or not write at all. It will also likely have additional context associated with it, like the log level (INFO) and a timestamp. A command line utility will likely use `println!` and `eprintln!` since it would be working with other tools that expect output on stdout and stderr in a known format. A longer-running service would use `info!` (and its cousins, `trace!`, `debug!`, `warn!` and `error!`) instead. (A command line tool might use the logging macros as well, but for diagnostic purposes, rather than anything to do with its core function.) `write!` is different from the others. It lets you write strings to an arbitrary value that implements `Write`. It might be a destination like stdout or stderr, or it might be a file, or it might be something like a [Cursor](https://doc.rust-lang.org/std/io/struct.Cursor.html) or a (compressing output stream)[https://docs.rs/flate2/1.0.7/flate2/write/struct.GzEncoder.html].
&gt; Hell, I sometimes get PRs or issues from people complaining that such and such doesn't work on some specific version of Rust nightly that was released ages ago. There are some nightly versions on which Rand does not compile, and it is not feasible to fix that.
I thought the readability was good. The author explained the trade offs of data structures well in a very good ordered manner without proofs or much computer science jargon. The author seems very “friendly” tone.
Obviously you're offering a greater breadth of services here, but for static site hosting specifically how would you compare Render to [Netlify](https://www.netlify.com)?
So, I've got the O'Reilly Rust book already. Would any of these be a good one to pick up to deepen my understanding of Rust?
And empty ones ;)
I'm trying to make a list of differences between this and [`std::sync::Once`](https://doc.rust-lang.org/std/sync/struct.Once.html) l, and as far as I can tell there are only two: * `Once` can only be used at the global scope -- but `Lazy` can be used even for fields. * There's an `unsync` variant whose use case is...well, I don't understand it super well yet, but it's there! * This seems to be a "unifying superset" API, kind of like the `notify` crate but over different implementations as opposed to different platforms. `std::sync::Once` could be a potential implementation of `once_cell::sync::OnceCell`, but doesn't have to be. Does that even sound right?
Huh? I wasn't talking about `rand`. And I wasn't saying that anyone _should_ be catering to that crowd. I'm saying that there are people who pin themselves to a specific nightly, and it invites a world of pain, and that _therefore you probably shouldn't do it._
I just wanted to provide another example of a dependency not working for some specific nightly, which can make pinning nightlies painful as you say.
The illustrations showing the layout of the data structures is really great.
Not an answer to your question, but [still very relevant](http://thomasburette.com/blog/2014/05/25/so-you-want-to-write-your-own-CSV-code/)
I read the Bloom homepage. He vomited like 8 TED talks.
Hi, I'm not sure what you are talking about, can you give more details please.
lazy_static has a feature to depend on spin-rs' Once implementation (https://docs.rs/spin/0.5.0/spin/struct.Once.html), which blocks the thread by spinning it. Maybe `once_cell` could do the same?
Does Render also support PostGIS like Heroku does? And Rust projects that consist of a workspace where one crate is the backend and one crate is the frontend, which is also written in Rust and should be compiled to wasm?
r/playrust will probably be more interested.
I must admit, I'm writing in Rust less than 60 hours a week.
C and C++ are equally unsuitable, for the same reasons; only subsets of those languages are used in ASIL domains. Maybe we're interpreting the top-level comment differently; I didn't take it to mean that Rust cannot be adopted (via an effort like Sealed Rust) in those domains.
Yeah I believe IEEE-754 is required by some appendix in newer standards (similarly integer division was defined in C99). But also I imagine MISRA needs to cope with the wild zoo of weird C compilers that hardware vendors foist on their customers :)
Thanks for once\_cell. Reading the docs (in the context of this thread) made me giggle because you go straight to the quarks. I probably would not have realized "what it is" as a pretty ordinary end-user. Maybe lead off with something like "OnceCell is useful for a variety of patterns: safe initialization of global data, lazy initialization of global data, and general purpose lazy evaluation." ? Looking forward to using it!
I am not too knowledgeable about this stuff, but what I've heard through the grapevine is that Slug is overrated.
It’s even offtopic there, they want /r/playrustservers
But the blockchain is a terrible idea [that doesn't work](https://www.theregister.co.uk/2018/11/30/blockchain_study_finds_0_per_cent_success_rate/). And it's an ecological nightmare too.
I definitely recommend [Programming Rust](http://shop.oreilly.com/product/0636920040385.do). It's worth every penny, the book is well written, with some humor. If you come from C/C++ the book makes some good parallels, and touches on subjects that are not presented in the Official Rust Book.
Yes, it's a good book, but I didn't want to insist since the OP had their mind on one of the three Packt books. I'm also pretty pumped up about Rust in Action, though.
&gt; "the result of doing X is not defined to not require emulating any specific behavior". &gt; "a single instance of doing X allows the compiler to change the entire rest of the program completely" To me these are equivalent statements with possibly a difference in tone and excitement. The typical interpretation in PLT and type theory of undefined behavior is that when you have UB you have a contradiction (e.g. you have proven that `Void` is inhabited). The compiler assumes that the code is sound and that there are no contradictions and eagerly tries to exploit these impossibilities (according to the spec) to generate more efficient code. The compiler vendors aren't actively trying to screw you, but the nature of an optimizing compiler, operating by the "hail of bullets" approach towards optimization and simplification passes, is that optimizations cascade and so taking advantage of UB may be unpredictable. As for the C language, I think its problems stems from 1) being fundamentally unsound, 2) having multiple implementations before specification. It is my understanding that many of the rules around UB were put in place to have better portability. We are not in the same situation as C and should have an easier time. I do however have little sympathy for Linus's point of view here of not following the C standard.
That makes sense, thanks. I can see why that would be useful.
I don't see why this would be the case. Cargo is able to link two versions of rand into the same binary so why cannot libc?
 I'm having a weird bug I can't figure out again: I have a module "logger" which defines a Trait "AnsiCode" and a macro that uses AnsiCode traitobjects as well as a few function that use the macro. If I'm now calling the macro from outside it complains that the trait isn't in scope - if I however edit the type to reflect it's position in the module the functions complain that there's no module logger in scope. How can I resolve this?
The average user doesn't care about how much the planet or its people are suffering. The average user only cares about how good your product is and how much they are suffering (which your product is unlikely to change). "Empower the world" and "improve the quality of global human life" is the same kind of stereotypical speech associated with TED talks (you probably know the negative steroptypes of TED talks...). To put it simply: the average user is too busy worrying about their next paycheck to worry about the "ecological crisis" or the "social crisis". If your product aims to change that, fine. As long as it does what they want it to do they don't really care either way.
If you didn't see, we put in a [policy](https://github.com/rayon-rs/rfcs/blob/master/accepted/rfc0003-minimum-rustc.md) of 1 year MSRV for Rayon now, so the [coming release](https://github.com/rayon-rs/rayon/pull/661) will require 1.26. There was never anything *special* about 1.13 -- it's just where we happened to snapshot our support at Rayon 1.0.
`Vec` doesn't implement `io::Read`. Try `&amp;*out.stdout` instead, since `&amp;[u8]` does implement `io::Read`. &gt; Now, I wish to not load all the output and parse progressively. I don't know what you mean by this, but your example (seems to) read the entire input into memory, and then parses everything, and stores all parsed results into memory too. I might suggest following the tutorial: https://docs.rs/csv/1.0.7/csv/tutorial/index.html
I think wrapping `out.stdout` in a [cursor](https://doc.rust-lang.org/std/io/struct.Cursor.html) will give it a `Read` impl
I know, although in my opinion even one year is too much considering the [Rust Survey](https://blog.rust-lang.org/2018/11/27/Rust-survey-2018.html#rust-toolchain) results. In practice, projects that want to stay on an old compiler are unlikely to care about updating their dependencies, and can pin them to older versions.
I was actually thinking about that. I wonder in the plaintext benchmark, for example, if the best scores would still look so clustered with better hardware/user-space network stacks/...
&gt; Even `Rust Programming By Example`? I admit I have not read that one. But I have read other Packt books by contributors to the project that the book is about, and they were universally awful. The closest thingI know of is the [tutorials section on the Rust users forum](https://users.rust-lang.org/c/tutorial), which people occasionally post book reviews to.
The internals forum is the best place to have preliminary RFC discussions. http://internals.rust-lang.org/
Oh, I misunderstood! Thanks for clearing it up.
I implemented a safe merge here: https://github.com/rayon-rs/rayon/blob/146000b/rayon-demo/src/mergesort/mod.rs#L111 It's not as performant as possible, but it's simple enough.
Related: &gt; which then can be used by LLVM XRay https://internals.rust-lang.org/t/xray-instrumentation-support/8939
Thanks so much for posting this! &amp;#x200B; Are there any other books you would recommend that use Rust to teach programming concepts? &amp;#x200B; Rust is my first deep dive into a language and a lot of Rust resources assume familiarity with CS/programming concepts. The Rust Book does a good job of this, but do you have any other suggestions?
There will probably be a good few blog posts once it gets into stable, and it will probably also make its way into the book eventually.
Hi, you are totally right, but this article was not destined to average users, it aimed at early adopters, contributors. Those who believe what we believe. It's fun you are mentioning TED talks because actually the plan of the blog post is articulated around the ideas from the following one: [https://www.youtube.com/watch?v=u4ZoJKF\_VuA](https://www.youtube.com/watch?v=u4ZoJKF_VuA) It really just a beta to show the world what we have worked on the past months and more importantly **why.**
Sustainability isn't personal politics though. It's a buzzword with merit attached to it. It's a hot topic these days.
Absolutely, I think the main think preventing most people from trying it out now is the fact that you can't use it with tokio, but that will be fixed as soon as std::future::Future is stabilized in the next release
Glad I could help, there's also a usb crate floating around that gets you a usb device emulation on Linux which might be helpful for setting up tests. Would that be helpful?
I love the message but I do think that that's now how you should be marketing your product. Many people do not care about those issues because they don't feel it's their responsibility, or they don't agree with them. Furthermore, your backend runs on Amazon so it's an easy attack vector to point out hypocrisy. Keep the message but change the marketing. Focus not just on replacing Google but improving on it. Google's monopolistic nature also has downsides. Google services are not portable for instance, and don't integrate well with external software.
Nice, I was also working on a Tetris clone [https://zirman.github.io/tet-rust/](https://zirman.github.io/tet-rust/)
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/coderradio] [Bloom - A free and open source 'Google' (in Rust)](https://www.reddit.com/r/CoderRadio/comments/bxjibo/bloom_a_free_and_open_source_google_in_rust/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
You can use the `runtime` crate with the tokio runtime, and then use the futures compatibility layer to make it work. It's not pretty, but if people want to try it out they definitely can! There are some compiler bugs still being worked out though, so you may run into a wall. (Using the tokio runtime is not required but some crates like hyper expect it to be used and won't work with the `runtime`'s default runtime.)
It focuses on C++, but the same principles apply to Rust. It's a quick read, and a great primer for someone looking to build something in Amethyst/SPECS.
This might prove helpful: https://rust-lang-nursery.github.io/futures-rs/blog/2018/08/17/toykio.html
&gt; Imitation is the sincerest of flattery. &gt; &gt; -- Charles Caleb Colton And therefore, in return I hope to see Rust borrowing SPARK from Ada ;)
What kind of games are there in the Bloom arcade? I saw this morning on Product Hunt, it seems a cool project congratulation. I didn't know it was made using rust. Will it be easy to self host it since it's open source?
You're looking for r/playrust. This is the Rust Programming Language subreddit.
There has been a talk on the history https://youtu.be/K_wnB9ibCMg
The Once is pretty different, so that’s why it is not present in the comparison table in the docs. Once allows you to execute some function only once. OnceCell allows you to get a &amp; reference to a value which set only once. In other words, you can’t “just” use Once for global state, you need some unsafe code to actually set the state. OnceCell wraps that unsafe code in a safe API.
I have a fairly complete one I did a while back. I would like to port it to wasm. https://github.com/camccar/RustTetris
Perfect, thanks !
Not yet, but it's something we're considering for the future.
Some differences: 1. We serve all content on [Brotli](https://en.wikipedia.org/wiki/Brotli), making your sites download faster. 2. Teams are free on Render, so you don't have to pay $45/month to collaborate with someone on your site. 3. We have free email and live chat support (for now!), vs $1000/month for Netlify. Render is newer, so we haven't built out forms and password protection (both paid features on Netlify), but they're coming.
If I was developing an industrial-strength application, I'd totally agree with you. But right now, I'm more in a "toying around" phase where an easy API and the option to compile to WASM are more important to me. Correct me if i'm wrong, but especially the latter one would be broken by using FFTW or IPP bindings ? I right now used chfft for it's easy API. Someone made a benchmark, not sure what it's worth: https://github.com/termoshtt/fft-bench
rand 0.7.0-pre.0 was published today (like, an hour ago as of this comment). See: https://github.com/rust-lang/crates.io-index/commit/5241634eb2e7ffb9cf3bd0e187da2101c2e5830a I think what happened was one of your dependencies earlier in the build ended up using that version, and then a later dependency tried to build 0.6.5 which was incompatible with the earlier 0.7.0 build. (Just a guess, I haven't looked too deeply at how rustc handles dependency conflicts like that). Presumably the rand devs caught this, because shortly after that crate was yanked: https://github.com/rust-lang/crates.io-index/commit/36d12c6ec6dfa6b1eb05d5f9ccab4ebdea20f8f5 And thus your build was fixed. Your workaround works because it must have forced the earlier dependency to use 0.6.5 instead of 0.7.0. *shrug* at least that's what it looks like.
Deleted my other comment; I think I have a better idea as to what happened. It was the sub-crates like rand_isaac, rand_hc, etc. Those all had new publishes 3 hours ago. For example: https://github.com/rust-lang/crates.io-index/commit/b877b057ac68bda05db8dce08ab076b5dc8aeaaa If you look at your build log, you can see rustc downloads and attempts to compile those new versions. For example, 0.1.2 for rand_isaac. Those versions were all yanked later by the rand devs, probably for the reason you discovered.
There are two general solutions to this. First, you could include `use logger::AnsiCode;` inside the macro itself, so it could refer to that. Second, you could just always use the absolute path `crate::logger::AnsiCode` rather than `AnsiCode` any time it's used inside the macro. This is the solution I usually go with - since the macro's written once and used many times, being extra explicit shouldn't be too much of a problem.
You might also be interested in tokio-trace, although that's designed more for distributed tracing systems like Jaeger and isn't automatic. If your system could plug into tokio-trace to remove the need for hand-annotations that could be really cool :)
&gt; shouldn't that be prevented with semver and Cargo.lock? In this case, it's the fault of diesel. Diesel doesn't publish their Cargo.lock, because it's gitignored at the root of the diesel repo: https://github.com/diesel-rs/diesel/blob/fcf690dd415695b70aaa8674b97e62dffd738dd4/.gitignore#L2 That's potentially a bug, because it means Cargo.lock isn't committed for diesel_cli or any of their other binaries (rust binary projects should commit a Cargo.lock). And semver didn't help because the rand devs pushed a bad patch version on their sub-crates. That can happen from time to time.
using \`logger::AnsiCode\` inside the macro fails because the macro is inside logger itself and it doesn't know that it's inside a module called logger (i think?). But putting use \`logger::Ansicode\` inside prompted the compiler to suggest \`crate::logger::AnsiCode\` which essentially is both things you suggested combined :D thanks - works like a charm and no, being explicit isn't bad at all here it's just needed for one type declaration.
Unlike Go, Rust does not claim to be easy for beginners. Rust has a learning curve that is harder to grasp than most other languages. Rust is a relatively new language and does not always have a wrapper in every unique functionality you'd need. All of the "api developers" are volunteers who are doing this on their free time. They are slowly trying to update their functions to be more useful, but haven't had enough time to work on making your particular functionality more user friendly. If you'd like a particular functionality to be more user friendly, you can feel free to donate money to the creators of the functionality. I'm sure they'd happily work with you, if they were actually paid do to it.
That's going to be pretty inconvenient if Rust has to wait for them to end the borrow
Because libc links c libraries, and C libraries don’t do symbol versioning like cargo does for Rust libraries.
🤣
Hi, Thank you for the kind words. Currently the only game available on Arcade is 2048: [https://github.com/gabrielecirulli/2048](https://github.com/gabrielecirulli/2048) Good documentation regarding self hosting is planned for the next release :) [https://gitlab.com/groups/bloom42/-/epics/5](https://gitlab.com/groups/bloom42/-/epics/5)
It works but only for money that makes the game theory work. 99.999% of blockchain projects are vaporwear and scams
This is an _excellent_ idea! I had a similar though after reading https://www.joyfulbikeshedding.com/blog/2019-01-31-full-system-dynamic-tracing-on-linux-using-ebpf-and-bpftrace.html. Being able to insert things like USDT tracepoints would also be so handy (see for example [`rust-usdt`](https://github.com/Fiedzia/rust-usdt), [#6816](https://github.com/rust-lang/rust/issues/6816), [RFC #875](https://github.com/rust-lang/rfcs/issues/875), and [#14031](https://github.com/rust-lang/rust/pull/14031)).
* PostGIS is coming soon. * We support Rust WASM for static site compilation!
Hi, &amp;#x200B; I would love to understand the mental and boilerplate overhead of using Rust's *actix et al* to something like Haskell's *servant/Yesod/Warp.* I dont know either of those languages (learning Haskell currently, it is a tough nut). When would you use actix, and when would you try to focus down on Haskell based solutions?
&gt;Tell me what you think and about things I can improve! Running `rustfmt` and `clippy` is usually a good first step. :)
Now lets hope Rust borrows stuff from Ada - like design by contract
Lots of golang open source projects also don’t get money from their users and yet are very readable and easy to use. The point being made here is that rust seems unnecessarily complex. I personally even find Haskell easier to understand sometimes than rust!
&gt;That's going to be pretty inconvenient if Rust has to wait for them to end the borrow I hope they are cloning instead
As far as I understand, that is the price of having a safe compiled language with garbage collection being done at compile time.
I think Rust programmers would prefer to encode things as invariants using the type system and it is already possible to exclude invariants. For instance, there is a crate to wrap floating point numbers to implement the Ord trait on them only if they are ordered. It does this by checking the float on creation.
You mean like smart usage of trait requirements, ensuring memory safety, and const functions (which is still being worked on)?
A build script shouldn't be downloading anything. Doing that generally makes it impossible to audit the source code that goes into the build. Instead, there needs to be a separate script that does the downloading, that can be run separately before the build.
I gave `snafu` a chance recently, and quickly got really tired of adding `.with( SomeContext )` everywhere, to the point I had to write about it: https://github.com/RustSec/advisory-db/pull/104/files For application code, where I don't care about good enumerability of my errors, I'll keep using `failure`. For libraries, I'd go with manual enums or maybe gave `snafu` a chance again? Maybe?
Haskell and Go are both languages with a GC. Rust has the ownership system, and requires you to know the owner of all memory in your program. When you use a library, you therefore can't expect the library to manage its own internal memory by itself. You'll have to know the library's ownership model, at least on the high level dictated by the API. Libraries in Rust will never be drop-in because of that. By using Rust you're trading off ease of use for speed and correctness.
&gt;ode things as invariants using the type system and it is already possible to exclude invariants. For instance, there is a crate to wrap floating point numbers to implement the Ord trait on them only if they are ordered. It does this by checking the float on creatio Example?
Isn't that sort of the plan for Sealed Rust? I hope it gets there. Seems like a good thing to have two fairly different options in that space.
I'm confused :-). &gt; I gave snafu a chance recently, and quickly got really tired of adding .with( SomeContext ) everywhere, to the point I had to write about it: https://github.com/RustSec/advisory-db/pull/104/files That's security advisory for `portaudio`. And it's not `.with(SomeContext)`, but `.context(SomeContext { foo })`, which I guess you meant? I don't find it that verbose, but YMMV. Please don't use `failure` for libraries, it's very annoying.
If you can find it, sure.
If you want to read the data as it is output by your process, you need use the spawn() method of Command instead of the output() method. output() only returns after the process terminates.
Wrong link. Fixed. https://internals.rust-lang.org/t/thoughts-on-error-context-in-error-handling-libraries &gt; And it's not What if you don't have any additional context? It's very verbose (anyway, just look into link I've posted).
If you're interested in the underlying future and Tokio ecosystem, /u/jonhoo made a great stream making the tour of the ecosystem here: https://youtu.be/9_3krAQtD2k (note: it's 4h long). You can also check out the docs of https://tokio.rs/ If you want to play with some code, you could try some async web frameworks e.g. https://github.com/rustasync/tide (still very early development, focuses on exploring std::future usage and async/await) or https://github.com/actix/actif-web (that reached recently v1.0).
See [https://github.com/rust-random/rand/issues/818](https://github.com/rust-random/rand/issues/818)
How is that an improvement? Now you have to move the iterator twice on every iteration plus you have to deal with destructuring the tuple
From what I've gathered, all of the fuss was simply about separating the product from being associated from *any* movement at all, right? Like, from a brand's point of view. I don't really care about this topic since you're free to do whatever you want with your project, but I read the post and felt like it's pretty passive aggressive against men specifically. Pointing out "Cis Het **Men**" and a "threat" to their masculinity, and so on. Idk if the author did this subconsciously or not, but it seemed kinda one-sided. An "us vs- them" mentality. Is that the direction you intend to take your community in?
Speaking as a CHM: Nah, it's not one sided.
eh... to be honest If someone can recommend a better book I'm all for it, I didn't mean to give the impression I'm not interested in other books, so any recommendation is good. Any way, I think I've got that book already as an E-book when some functional programming stuff came up in humble bundle and nabbed the whole thing (as in all the books) for dirt cheap.
I just don't understand why it's only men that could care about separating a brand from movements though, that's all. And what it has to do with masculinity?
Thank you! Seems like a good idea to start getting used to linting right from the beginning of learning rust. I hated getting used to it after having programmed in a language for a while ..
Wow. Those are some fast loading data grids. Nice work. I notice on Firefox, horizontal scrolling works, but vertical scrolling does not. How are you handling paging, or are you?
The moment when politics and ideology hits software project is the moment of death of this project because it means that, regardless what the authors say, the ideology became more important than the code. Rip amethyst [`]
For sure. I've been using `rustfmt` from the start so I haven't formed any opinions on what code should look like, it's great.
But mom said it's my turn on the affine type system 😤😤😤
Check out the [contracts](https://crates.io/crates/contracts) crate.
It's not _only_, but it is usually majority. Basically, all of life is politics. Even saying "let's not talk about politics" _is a political act_. It's saying that you're okay with the status quo, and don't want to talk about a future where things are different in any way. But the status quo is that people around the world are harassed and killed for being members of the groups that Pride is trying to support. Yes, even in your own country. I don't even need to know where you live. It happens in every country. You don't have to feel guilty about who you are or what you didn't know in the past, but you have to understand that this is the reality that many people face. If even _one_ person is facing that, shouldn't you do at least your small part to change things? And if entire communities all across the globe are facing it, doesn't it make the situation that much more dire? I think so. I hope you think about it for yourself.
The type in question is [`ordered_float::NotNan`](https://docs.rs/ordered-float/1.0.2/ordered_float/struct.NotNan.html) from the [ordered-float](https://github.com/reem/rust-ordered-float) crate.
In some instances this can be okay. After all, unless you are vendoring your dependencies, cargo is already downloading a lot of crates as part of your build. We trust it because of HTTPS and checksums and faith. If the same consideration is going into the build script, then I can accept it, even if I don't like it. Uncontrolled access from a build script nonetheless still poses an issue if you want to completely vendor your dependencies. Ideally, the to-be-downloaded stuff should instead be pulled down prior to publishing and included as an artifact inside the crate.
Hey, look at that, another F# to Rust convert 👋.
I never said that I was against it, so idk what you're talking about. I'm not anti-pride, or any other movement like that. I just tried to understand why straight men specifically were pointed out in a bad way. It doesn't look very welcoming, does it? You can be against associating a brand with a movement even if you're not a straight man.
Ideology is an intrinsic part of any software project, especially open source ones. Open source projects exist because their creators held certain ideals in high regard. Supporting Pride and the movement that it represents is a subset of our organization’s overarching ideology to make all members in our community feel welcome and safe from hostility.
I understood that &amp;.
Sone languages have explored expressing pre and post conditions using a form of [refinement types](https://en.wikipedia.org/wiki/Refinement_type), such as F* ([example](https://www.fstar-lang.org/tutorial/tutorial.html#sec-some-syntactic-sugar-for-refinement-types-and-lemmas)) and Liquid Haskell ([example](http://ucsd-progsys.github.io/liquidhaskell-tutorial/03-basic.html)). Found related discussions in the RFC repo, mostly focused on ranges. - [Numerical Constrained Types](https://github.com/rust-lang/rfcs/issues/1621) - [Range types for integers (or refinement types?)](https://github.com/rust-lang/rfcs/issues/671) Both link to [const generics](https://github.com/rust-lang/rust/issues/44580) in their most recent comments.
Maybe `Cargo.toml` should contain a list of downloadable content (with checksums!) to facilitate downloads. This way we could even drop networking capabilities (using eg. Linux namespaces/containers) during build phase.
I wrote a post [comparing ADA invariants vs ATS type system](https://bluishcoder.co.nz/2018/01/10/capturing-program-invariants-in-ats.html) a while back. ADA does have some nice features that are worth looking at how similar things could be done in Rust.
Entered thread to make sure this was here.
It's more like weak reference so it's fine
Is that worth a read even after having read [the rust programming language ](https://doc.rust-lang.org/book/)?
&gt; Entered thread Did anyone *Send* you here in this *Thread*?
One current weakness is the lack of const generics in Rust. While we can bound creation on integer ranges, we can't universally represent that contract through a type without some weird typesystem hackiness like typenum. Once const generics lands I think we wont have many issues using refinement types in this way.
I share your sentiment, however LGBT is neither an ideology nor inherently political. So far neither Amethyst nor Rust at large has done anything politically or ideologically motivated (afaik at least).
Having read both, I think both are great. IMO, 'Programming Rust' provides solid narrative to go along with the material, and does a good job drawing parallels to C/C++ and Python so you can better understand the internals of the language. It was a good read.
That's a bad opinion. Sorry you're the sort of person that believes software suddenly becomes bad when it supports a progressive social movement.
I think it's disingenuous to claim you really don't care when you're clearly objecting to the tone of the post.
Use public fields unless memory safety demands otherwise. Rust's default here is a flub. Use indexes/identifiers/etc instead of holding on to actual references to data elsewhere. Both of these things will keep the borrow checker out of your face.
That's a complete non-sequitur. For example, Vim asks its users to support development aid in Uganda. A completely ideological move, nothing to do with code. Are you mourning its loss as well?
Mutability is not so bad in Rust. In fact, I'd say Rust is one of the best languages for using mutability, because it manages it really well. You can also write in a more functional style with immutable data and recursion, but I'd suggest to not be too dogmatic about it. If mutation is the best way to do something, then use it.
Sorry if I expressed myself badly. What I meant was that I don't care about them supporting pride. I did care about the tone of the post.
These conversations are always touchy too, as I often see a comment like yours *(which seems very reasonable to me)* and then the other side throws out the sarcastic comment about how you're trying to make CISHET out to be victims or something. Argh, sad to see this type of stuff being discussed here.
This might be stretching the definition of "easy" but... I'm working on a data structure that deduplicates "equal" elements. I thought it'd be neat if it optimised `map` so that the function is only called once per unique element. Is it valid to do this for any of the `Fn`-style traits? I wasn't quite sure if the guarentees of `Fn` was strong enough for it to be valid.
Amen
So for example, if I had some kind of "RecordSet" instead of having references in an Vec&lt;Obj&gt; I'd rather have of Vec&lt;Id&gt; and then get the data from some kind of Database in which I can pull/push data when needed but never own it in the structures themselves? I'm not really worrying about performance as performance are probably not my biggest worry considering I come from Python and anything running in Rust should be much faster than non optimized python code.
Rust is pushing for improved software safety through better engineering; that's political. Demanding rights for people is political, and also good
rust has had an explicitly pro-marginalized-people CoC from the beginning, idk what you were expecting
Yeah something like that. That's actually the basics for how all that hot new ECS stuff works. You can move to that full pile of crazy eventually, once you get used to things, but you can also take just a bit of the benefit with just a bit of the effort right out of the gate.
the post seemed eloquent and friendly to me? what tone are you worried about, exactly
I think it's absolutely wonderful that Amethyst supports pride!
I think if you feel like a part doesn't apply to you, you shouldn't take it to be directed towards you. &gt; When June rolls around and cis het males start complaining If you don't complain, the latter obviously doesn't apply to you. It might read like "all cis het men complain", but that's definitely not what was meant here.
Amethyst.rs reminds me of this: [https://www.youtube.com/watch?v=lpzVc7s-\_e8](https://www.youtube.com/watch?v=lpzVc7s-_e8)
The paragraph addressed to Cis Het Men only says that they are sometimes unfairly treated by LGBT people and assures them that the project is in no way hostile to them, though. If anything, I'd argue it is meant to prevent people from feeling it's passive-aggressive.
KISS.
Being able to ignore a political issues is a privilege of those who don’t suffer or benefit (even unwillingly) from the status quo. E.g. As a white person living in a western country, I’m free to not care about racism. In the case of LGBT rights, that would be the privilege of cisgendered, heterosexual people. Now STEMs and in our case programming are very heavily dominated by men, and women there face significant amounts of misogyny already, hence the focus on cishet men.
&gt;Speaking as a CHM: Nah, it's not one sided. &amp;#x200B; If you're unironically referring to yourself as CHM, I have some bad news for you.
&gt;Implementation is the sincerest form of flattery. &gt; &gt;\-- Peter Deutsch
I mean.. you say that, but.. If "Movember" rolls around and I say something like: &gt; When Movember rolls around and all the gay women start complaining Would you _honestly_ not think that would be taken as offensive towards gay women?
Give it to me straight doc! I can't take the suspense!!
\_shrug\_ Maybe you have a point. I like to not think too much of it all.
&gt; I like to not think too much of it all. Agreed. I just like to see equality in our phrasing. Usually reversals seem pretty bad, as in my comparison. Take care :)
MCU and Rust. My two favorite things. This is the ultimate joke. 10/10
You can change how indexing works, but you cannot change how assignment itself works.
Yes mutability and the whole borrow checker idea is good in itself. My point is more that most programming language most programmers went through got us used to write programs that can fail in so many ways but usually don't because we do our best to make it work. In Rust, it's kinda the opposite, the compiler will do its best to prevent from shooting ourselves in the foot. Following the [Shoot yourself in the foot in programming languages](http://www.toodarkpark.org/computers/humor/shoot-self-in-foot.html) Rust would be: You aim at your foot with the, press the trigger and the gun tells you that the lifetime of the bullet has to live at least until your foot is destroyed and a lifetime parameter is required. And the gun simply doesn't fire.
&gt; Flat-earthism is the stupidest form of flattery. &gt; &gt; -- Peter Deutsch
The pattern of providing proxy objects in C++ requires overloading the assignment operator. This is not possible in Rus because assignment closely relates to the concept of moving, and ownership could get very funky. You could use the proxy objects in a slightly uglier way by writing element_ref.set_value(Thing::new()); Alternatively you could just write container.set(n, Thing::new());
Half of that section is explaining how the LGBT community doesn't always engage constructively with the rest of society. I didn't think it had a passive-aggressive tone.
came here to say this
I very strongly suspect that Google X-Ray pluged into Dapper/Census, though thats guesswork, but its the only sane thing to do in a lights-out operations environment. So yeah, absolutely tying into tokio-trace should be a first-class goal.
I'm interested indeed. This sort of detailed tracing is what I've been adhocing to do my rustup investigations (e.g with rs\_tracing) and a systematic approach would be &lt;3. I'd be delighted to put some time into collaboration.
Its 2019 bro. Cis Het Men have been cancelled. Its June and its its illegal to be straight.
&gt; progressive social movement embracing and extending mental illness? Nah.
I think [HashMap's Entry](https://doc.rust-lang.org/std/collections/hash_map/enum.Entry.html) is pretty close to what you want.
Nice; We're still in the sync/threaded model in rustup, but basically looking at the same problem for the next unpack speed improvement - our tar processing logic, read IO, and decompression is all same-thread, so moving the decompression to a thread-back Read implementor would be useful (until 1.37 or so I guess... but then urgh rewrite...)
Multi-channel signed distance fields is a technique, which rasterizes glyphs with distance information to low-resolution texture, which is then used to render high-quality text. This is my first Rust side project and I always wanted to write something, which is font related :). Enjoy!
&gt;Give it to me straight doc! I can't take the suspense!! \&gt;&gt;Give it to me \&gt;&gt;Straight
If possible (and the script is not generating a platform dependent url from hundreds of permutations), this sounds like a good idea. And: You can totally make a build-dep crate right now that uses custom cargo metadata and downloads and checks stuff for you! Once people use it more tooling can be built around it.
You've added "all" to the statement though. Take that out, and suddenly we're talking about those gay women who take issue with suicide and cancer awareness.
At least this comes with guarantees about Rust's longevity.
Oh wow, it's amazing. How many times I had to deal with it without realization I could have done what you just did.
Immediately-called closures are a really nice way to factor out repetition. Code like let mut fn = || { stuff; and; things; }; fn(); fn(); has exactly the same effects as stuff; and; things; stuff; and; things; including access to all of the variables in the containing scope, with the slight bonuses of letting you name that block of code and use `?` for error propagation. You can add a parameter if you have multiple, slightly different blocks.
I think one of us has misunderstood the other, since I just [tried this](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=4c7bf11dc39fe56ca0cda1197695aa4e), and it seems to achieve the same effect.
Why do you think I would want more than one Deref impl per type?
Dunno, but if you wanted to, you wouldn't be able to.
Would be great to post instructions for how people can test it.
It will be fine as long as we don't need to change anything.
Can we make Rust communist? Pleeease..
I have worked in almost 12 languages now, the last one F3. I say without doubt rust is the MOST mind-bending of all. &amp;#x200B; The first 2 months for me was very brutal. I think I advance by millimeters, but retreat by meters. Have worked in so many languages probably work very hard against me... &amp;#x200B; \---- &gt; what's a good way to develop in rust because I tried to The **first** and more important thing: learn the rust way. Rust is more different to other Langs, that try to "bring" your knowledge will work against you. It WILL be useful, but not yet. &amp;#x200B; **Second**, rust is not about the borrow checker (that is like say Haskell is about type inference). The borrow checker is a "validator". &amp;#x200B; Rust is about **ownership,** how **pass the ball(**data, pointers**),** and how avoid to get in a bad situation. So the mindset is "this thing where belong? how have it? how pass it?". &amp;#x200B; For example, I get hit often by things alike: fn bad() -&gt; &amp;String { &amp;"hey".to_string() } because somewhere get lost the "how have it?" and I try to pass stuff from "thin air". &amp;#x200B; **Third,** not afraid of clone, boxing, rc or imperative code. I hate how rust suddenly have turning me in somebody that "care" about performance and optimizations. I'm porting some F# code and I tell you: I have copied, cloned, allocate so much everywhere, but never see it before. &amp;#x200B; Now, I try to ".clone()" or ".to\_string()" and is like I was committing a sin. This block me for some time. Now, I put in mind "Relax, you have use JS, Python..." when the urge to be efficient happens... &amp;#x200B; Eventually you learn how do better code. Certainly rust push towards certain style in build APIs and that is the hard part, but eventually it click.
Remember the difference between no_std _libraries_ and no_std _binaries_. A no_std library (and no `alloc`) is a much simpler thing. No specifying BTreeMap, for example. Just using the basics in core and exporting `extern "C"` functions. (And if memory allocation isn't allowed in many of these cases anyway, not having alloc is perfectly reasonable.) It seems like a fine starting point to me.
Ah, corrected, thanks. I still stand by my statement though. It's not a statement that I could say and not be hung for, in my view.
Dear Gay/Lesbian/Bisexual/Trans/Queer(Questioning?)/Asexual/I'm-sorry-but-I-Can't-keep-up-with-the-ever-growing-list-of-identities-that-fall-under-this-umbrella— I find so many of you to be immensely talented developers, helpful, and knowledgeable. The rust community simply wouldn't be what it is without your contributions. My interactions with nearly everyone in this community are, generally, overwhelmingly positive. I couldn't care less about the recognition of pride month. I *am* slightly put off by the fact that, if, for example, members of the community wanted to recognize and celebrate service members on memorial day, there would almost certainly be strong objections in doing so. This example doesn't serve to illustrate the reverence with which I hold military members, rather, the ideological/culture war that lurks beneath all of these sorts of discussions. There are multiple ways to address these sorts of ideological differences. One is to make it acceptable to endorse or recognize things that may be controversial to more than one "side" (to use a grossly oversimplified term for lack of a better term), or to simply abstain from these sort of celebrations in general. What is happening in practice is that these sort of ideological/cultural endorsements are dictated by a single, often very vocal and politically active side. Regarding the straw-manning of CIS HET males (admittedly, I don't know what all those words mean, but I assume they're referring to people like me): - I don't care about who assumes the dominant role in your relationship - I don't care about your genitals - I don't assume you're attracted to me - I assume you have children similarly to how other human beings have children - I don't care about your sex life (I don't particularly care about *anyone's* sex life, except my own) - I have never inquired about any of these things, ever, and if I were so inclined, I know how to use google. - I have never *once* witnessed any of these things in any public forum where rust is involved. Or programming more generally. Or literally anywhere. However, if these things are happening, I suggest you address it with the individuals doing it. Fundamentally, I would like to see a mutual respect for people. Like you, I don't like to be stereotyped, straw-manned, talked down to or dismissed because on my identity, and I'd like to see principled stances on issues like these. That is all. :)
I think you are right. There is very likely always enough difference for the DTO to be justified so at some point, you will probably have to make a decision about the trade-off.
Btw I think your solution is very clever, taking advantage of the `IntoIterator` that comes with `Option&lt;T&gt;`. So thank you again :) Out of curiosity, is there a way to unflatten? Like, could I get the `slice::IterMut` out from the `Flatten` object?
They are posted on the pr in the blurb at the top of it...
Oh my bad , for some reason it was not rendering on my phone but is on my desktop. Not sure what's up with that.
Unfortunately `Flatten` doesn't give access to the internal iterator; I don't really see why it shouldn't, I guess it just hasn't been considered before. I don't see anything wrong with not keeping the iterator always wrapped in `.flatten()` either; in general it'd be a bit of a footgun to do this since you're going to be throwing away uniterated data when the `Flatten` is dropped but in this case since each iterator only yields zero or one items it's fine: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=df565fa15681e695c4a3d09ca9fe3988
Can you elaborate? Your question doesn't really make sense as it stands; the semantics of the `Fn*` traits don't imply anything about what they *have* to be called with besides the argument types.
Will there be any use for `tokio` once async / await hits stable? Is there any advantage to learning futures w/ combinators now, or will the ecosystem shift to `.await` and be equivalent in performance?
&gt;I come from Python and anything running in Rust should be much faster &gt;Rc boxes but having boxes everywhere sound annoying. And I feel that when I box everything I'm probably doing it wrong even if it end up working. One big thing that helped me was when I realized that Everything in python is in a `Rc&lt;Box&lt;_&gt;&gt;`, and that every ref to a python var is a `Rc::Clone(_)`. So if my rust algorithm needs several of them, that is not being slow. Rather Every time my rust algorithm didn't need them it is being fast.
&gt; all of the fuss was simply about not wanting the product to be associated with any movement at all, right? no, it was about a bunch of boring programmers getting freaked out by the concept of any social change and having no way to express that except "ahem. excuse me, sir. this post, it seems, very partisan, and i am upset. please, stop bringing politics into the workplace"
turn on your monitor
Unless they are borrowing it mutably
It sounds like you're asking if `Fn` is guaranteed to be pure (A given input always results in the same output). That is not the case. However, that doesn't really stop you from doing what you want, you'd just have to note in your documentation something that using impure functions may give unexpected results.
The paging is not yet restored. I'm still working on it.
&gt; Dear Gay/Lesbian/Bisexual/Trans/Queer(Questioning?)/Asexual/I'm-sorry-but-I-Can't-keep-up-with-the-ever-growing-list-of-identities-that-fall-under-this-umbrella— Like can you not start off with a kinda offensive joke? Just LGBT+ is fine. &gt; I have never once witnessed any of these things in any public forum where rust is involved Congrats for not seeing it? That's the reason that section is specifically targeted to cisgender and hetersexual men. They just kinda don't see it. The internet is a pretty toxic place to be LGBT+. If you aren't pretty actively at least showing token support, it gets especially bad very fast. I'm a transwoman, and using the internet really fucking sucks. Hell, life really fucking sucks. Amethyst doing this makes me feel so much safer and happier to be part of the community. &gt;Fundamentally, I would like to see a mutual respect for people. Like you, I don't like to be stereotyped, straw-manned, talked down to or dismissed because on my identity, and I'd like to see principled stances on issues like these. Then don't compare the GOD AWFUL experiences of LGBT people to... a paragraph that is literally just directed a cis het men? There's nothing wrong with that paragraph. I get you probably don't view yourself as any "-phobic", and honestly I know that's the not the best term. But if you constantly minimize the issues LGBT people face, speak negatively of any effort to help them ("pride is too political for XYZ"), and just kinda shitpost microaggressions (I assume you'll laugh at me for using that word), what *exactly* is the conclusion I'm supposed to draw? I don't care if you support LGBT+ people "in a vacuum". This essay and pride overall really helps them, and you're trying to take that away.
I really appreciate the continued improvements these guys a making to this already excellent Rust IDE plugin,
This is about as silly as people who think racism is just not seeing race. Or, that 'negative stereotypes' is sort of peak racism. It's absolutely fine to talk about demographics generally. This post is about LGBT+ people and their experiences, but obviously nobody is going to complain about that (LGBT+ people recognize the importance of collective organization, most other people don't care). A lot of cis het men say pretty offensive stuff. They are the main source of just kinda "shitty comment that I'll get mocked for calling out and it's too much work to explain how it's shitty, even using the term microaggression will get me laughed at". Some of them feel pretty attacked when their masculinity is challenged. This isn't wrong to say, and refusing to call out demographic issues makes them impossible to actually address. If it doesn't apply to you, just move on. This isn't demonizing men, and it's trying its absolute best to give a sliver of understanding to the topic to a kind of people that are generally very out of the loop on. &gt;not wanting the product to be associated with any movement at all, right There is no "default politics". If you don't do anything, you're supporting the status quo, including the massive amounts of shitty comments and behaviors around LGBT+ people. &gt; An "us vs- them" mentality. Is that the direction you intend to take your community in? Oh come on. Give me a break. It's not "us vs them", it's "us and them". We have different experiences that need to be shared. Understanding our differences is not the same as dividing us; it's literally the only way we can come together.
&gt; care about separating a brand from movements though When that movement significantly helps a marginalized demographic, it tends to be that the only people that "care" too much about the aesthetic of separating them are those that don't know or don't care about the benefit that movement does. And CHM are sort of the peak of that. You can obviously not be that and think that way, but that kind of "concern of exact language to the point of grinding the conversation to a halt" is just another tactic to derail the conversation.
&gt; having your existence be so aggressively considered the default that you get offended when it's given a name
Seriously, I really hope people who "don't care" or even "just want politics out of their stuff" can really get a sense of how unimaginably important these posts are for LGBT+ people like me. This is just amazing to see.
Don't worry, Reddit comments implement Sync
I don’t agree with your interpretation of my words, and I apologize if you found my light-hearted joke offensive. That said, I want to reiterate one thing: I do not oppose the celebration of pride within the amethyst or greater rust community.
Yeah, seems fine. It’s very similar to what Mutex does.
I'm seeing a lot of `unwrap` in documentation and I wonder in which cases I can use unwrap and in which cases I should be using `?` or a match instead.
Nit: &gt; To paraphrase Chris Kluwe: watching a Pride Parade isn’t going to make you start lusting after your best same-sex friend. If anything, it might give you a better fashion sense. Isn't associating gay people with better fashion also off-putting?
So, just to confirm: Is this only an msdf renderer in rust or is the actual msdf generation also written in rust?
This is a really interesting concept. Thanks for posting that implementation.
Ah yes also that Rust is a fairly new language and still doesn't have a huge ecosystem around it but I'd say it matured well. &gt; Now, I try to ".clone()" or ".to_string()" and is like I was committing a sin. This block me for some time. Now, I put in mind "Relax, you have use JS, Python..." when the urge to be efficient happens... Ahah, I work mostly in python and as much as python can be quite good for development and design. I love python but the platform I work on is a clusterfuck of bad design decision. It admittedly improved over the years but if it didn't have such a big community I wouldn't waste my time with this. Considering that, I believe even the worst design decision in Rust would make things faster than what I develop on a day to day basis. Btw, while reading some code today I learned about the `Into` and `From` trait. And I find this so cool.
&gt; Don't worry, Reddit comments implement [Sync](/r/redditsync) I can't tell if that was intentional or not.
Totally agree. Doesn't belong here in /r/rust exactly, but I'd like to point out [The Go Programming Language](https://www.gopl.io/) by Donovan &amp; Kernighan, and also [Fluent Python](http://shop.oreilly.com/product/0636920032519.do) by Ramalho. Both are also written as programming books should be written IMO.
Totally agree. Doesn't belong here in /r/rust exactly, but I'd like to point out The Go Programming Language by Donovan &amp; Kernighan, and also Fluent Python by Ramalho. Both are also written as programming books should be written IMO.
Use `unwrap` or `expect` when you are OK with the fact that an `Err` or `None` case will crash your entire process without the possibility of a recovery. In practice this means you should only use it when you're sure the value is always valid - e.g when you add something to a hashmap and immediately get a reference to the element. Use `?` and other error handling methods whenever something can actually fail. (Of course, in the real world people are lazier [or more efficient with their time] than that.)
Tokio and async tackle more or less completely separate issues. Async/await adds a shared set of traits for asynchronous operations and a more readable syntax for writing asynchronous code, while Tokio implements a runtime that allows running `Future`s in multiple threads. Tokio (or something else like it) will be required for most async code too.
&gt; I think I've got that book already as an E-book when some functional programming stuff came up Which one? Rust in Action isn't out yet. Programming Rust is pretty good too, though.
It's funny, I didn't like the "Cis Het Male" part either (cause I am one and the tone was off putting) but then I read your post and now I'm fine with it. People should object to celebrating war. Fuck anyone who signs up to kill poor people in exchange for free college.
&gt; That's the reason that section is specifically targeted to cisgender and hetersexual men. They just kinda don't see it. Hey thanks for that. I'll be sure to continue never noticing anything ever again, doing my duty as a "Cis Het Man". Pretty great to have LGTBQ+ people reducing whole groups to their gender identity/sexual orientation. Equality in action I guess. &gt; Then don't compare the GOD AWFUL experiences of LGBT people to... a paragraph that is literally just directed a cis het men? There's nothing wrong with that paragraph. Addressing it to all "Cis Het Men" isn't doing it any favours honestly.
No. It's a tool for FALGSC though.
I spent like an hour this morning beating my head against this too, starting up a new actix-web project. It looks like was a problem deep in the rand dependency tree, and some releases had to get yanked to resolve it. It'll be really cool when core stuff like `rand` and family get to 1.0, and this happens a bit less.
Looks like we won't then. Lot's of talk, no code..
Would it be useful to learn tokio now or wait until it moves to futures 0.3 ?
Haskell and Rust have different approaches to safety. Haskell's is the pure functional approach: nothing is mutable, ever. Mutation is the path of madness; disallowing it completely allows Haskell to reason about computation in very different ways, like lazy evaluation, and even mathematical proofs of correctness in some cases. Rust's is a rather more flexible approach: mutation can be safe, but it's usually not. You need to demonstrate to the compiler that you're doing it right. On the one hand, this doesn't enable fancy lazy-evaluated code generation. On the other, you can still make use of algorithms that require mutable data, which are sometimes much faster and/or simpler than their functional counterparts.
I got curious about what makes furry shaming ideological. I mean I understand that is no apolitical organization, but being furry isn't ideological, it's not queer. Nor is being a dick against furries, even if it hurts the code of conduct, it's just impolite. I mean what am I missing?
The README says it does both rendering and rasterisation
I've always disliked how various social/political agendas get mixed in with technical projects. I am generally not comfortable around LGBT people; not because I'm not secure in my masculinity, or because I am a hateful person, but because everything seems to gravitate towards LGBT agendas, and I hold a personal belief that traditional families are the foundation of a strong nation. So naturally I've see LGBT movements as somewhat of a threat. Unfortunately, holding such an opinion has resulted in me being ridiculed on more than one occasion.
I find it peculiar how someone voicing the concern that code of conduct do not explicitly say that one cannot be harassed or prosecuted for one's consciousness is somehow too divisive to have a discussion on, but demeaning entire demographic of people based on their immutable characteristics is somewhat okey. Or even encouraged here. And later I'm told there is no bias. [https://www.economist.com/open-future/2018/08/17/the-dangers-of-illiberal-liberalism](https://www.economist.com/open-future/2018/08/17/the-dangers-of-illiberal-liberalism)
Who said it was an improvement. I just said it was possible. The comment I replied to said "it wouldn't make much sense". My point was just that iterators like this do exist (though I've not seen them in rust).
&gt; Use public fields unless memory safety demands otherwise. Rust's default here is a flub. It wasn't clear to me from the start, but I assume you meant "use public fields instead of getters"?
I can't help you much, I only know specs works with Send + Sync data and some (all?) OpenGL functions have to be called from the thread the Context was initialized in. You can (but shouldn't) implement Send and Sync for your struct but you would be throwing part of Rust's type system out the window and would be swimming (and probably drowning) in unsafe waters. You could also put it inside a Mutex or RWLock, I don't know how it would interact with OpenGL. I think storing a Vec&lt;Vertex&gt; is the simplest solution but you have to test the performance. OpenGL is quite old and was design for single threaded applications in mind, Vulkan on the other hand is meant for multi-threading but you'd have to learn another api, there is also gfx in Rust trying to abstract multiple graphics backend, I don't know much about it but maybe it can be useful to you.
I don't think checksums belong in Cargo.toml, I would rather prefer them to be generated by cargo and stored in Cargo.lock
To me (as a CHM) it comes off as sort of patronizing. But. I'm sure there's no way to win. If the essay hadn't included the conciliatory stuff, people would see it as picking a fight. If it didn't call out CHMs specifically, it would be received better by them but at the cost of failing to make an important point. At some point you have to call a spade a spade. On the other hand... on the off-chance anyone is wondering *which parts* I had a gut reaction to and saw as patronizing, I noted two: "(Non-CHMs can skip this part)" and "Your Masculinity is not Threatened" (specifically the fact that it's in large text). Interestingly, neither of those is core to the essay, and they could be removed without really compromising the message. While I'm not totally sure, that nonessentialness may be *why* I reacted negatively to them: they felt like "rubbing it in".
Definitely, I found that the topics were covered in more depth in Programming Rust. I read it after reading the Official Book, and it helped me get a hold of a lot more features of Rust. Rust in Action looks promising also, and you can find some bits online to give you an idea of what it will offer.
Oh. You're right!
&gt; Regarding the straw-manning of CIS HET males (admittedly, I don't know what all those words mean, but I assume they're referring to people like me): Cisgender, heterosexual; they're not exactly obscure jargon. I had a negative reaction to the original post too, but you don't need to defend yourself by refusing to learn the terminology.
Yes. The compiler understands "split borrows", where you borrow two fields of a struct at a time and the borrows play nice. It can't follow that distinction when getters are used, so borrow checker gripes a lot more.
I've taken the liberty to generalize it slightly. I'm sure there are ways to get rid of the \`Default\` bound, for example by using a \`MaybeUninit\` or storing a mutable reference to the value, if the container isn't supposed to create a value on the fly.
There's a borrowing/ownership joke somewhere in there...
To be honest, I've expected a bit more interesting content (e.g. communicating directly with the camera via GPIO / I2C / whatever) - using Rust solely for executing another command is an overkill IMO and it'd be better off with Bash.
&gt; &gt; Programming Rust &gt;
Please educate yourself on what Memorial day actually is. The word is kind of a hint here. You can acknowledge those who have died in service whilst being against war, it's not a dichotomy like that. Also, signing up for the military isn't "volunteering to kill poor brown people in exchange for college". What the actual fuck?
Note that nightly Rust has const generics.
Personally I lean towards the "avoiding politics is not possible or desirable" side, but I'm going to criticize your analogy. Supporting development aid in Uganda is not really ideological, at least in the sense the OP meant, because there's no opposition; there's almost nobody who actually thinks it's bad to help needy children in Uganda. (I'm sure you can find someone who does, and they might see it as ideological, but for everyone else...) People do vary in their willingness to actually donate money, but since random charity donation requests are ubiquitous in our culture, the one in Vim doesn't feel like it's trying to pressure you to donate or guilt you if you don't.
 *ideology* &gt; 1a : a manner or the content of thinking characteristic of an individual, group, or culture [marriam webster] Choosing to shame a furry is an ideological choice, *your* personal ideology, not theirs.
&gt; Also, signing up for the military isn't "volunteering to kill poor brown people in exchange for college". What the actual fuck? Has been for 18 years.
I would probably argue that such errors should manifest in an assertion failure rather than a return code. But the best solution, of course, is to encode such contracts in the type system. However, when `Err` is returned, it is often because there are external preconditions that the caller has no chance of checking up-front. Almost always I/O-related, but it can also be something like converting a less-structured "thing" to a more-structured "thing" (parsing). Errors are hard. :-)
Definitely, I found that the topics were covered in more depth in Programming Rust. I read it after reading the Official Book, and it helped me get a hold of a lot more features of Rust. Rust in Action looks promising also, and you can find some bits online to give you an idea of what it will offer.
&gt; Cisgender, heterosexual; they're not exactly obscure jargon. Just to jump in: They are for some non-native speakers. At least I had to look it up and the first reaction was: "CIS HET male" should that read "This hate male"? I had no idea.
 #[derive(Copy, Clone)]
These are [documentation tests](https://doc.rust-lang.org/rustdoc/documentation-tests.html), an amazing feature to ensure the code examples in comments are valid code.
As mentioned, these are [documentation tests](https://doc.rust-lang.org/rustdoc/documentation-tests.html). I would highly recommend editing them enough to get them to compile, so that you can have the guarantee that they'll stay relevant with the source. If you don't want to do this, you can specify these should be ignored as tests with the following annotation: ```ignore &lt;code&gt; If the examples do something with hardware and shouldn't be run, but could be compiled to check for validity, there's a second annotation I would recommend instead: ```no_run &lt;code&gt;
I have no problem with Pride months nor Amethyst being part of it. I had to look up "CIS HET male" (non-native speaker, never heard this before). People on the amethyst discord were always friendly, I never had a single (non-technical) problem with the project. One general thing though: I too try to avoid "political" projects such as these. Why? Because although I do not care about anyone's sexual preferences at all and I only care about my own sexual life (and that of my partner) I simply feel overwhelmed by all the terminology I have to learn that has nothing to do with the code. I don't want to insult anyone by e.g. not using the right pronouns... yet I - again as a non-native speaker - fell down that pit once or twice - without malicious intent that is. I do not marginalize people, I don't care whether you're LBGT (+?), a vegetarian, a communist, a jihadist or a nazi as long as you don't do harm to anyone (around me - where I can influence it). Of course I have my own believes but I am very open-minded, meaning that I'm basically only against suppression of anyone (no matter if minority or not - e.g. in some countries the majority is suppressed by a tiny minority around a dictator) But, after a days work I simply have no energy left for such interpersonal conflicts. Hence I am always silent and just read in discord. If I feel like it, I open a PR etc. but I don't have the energy to dive into the community as I had when I was younger.
The absolute best bit of this is that you can write the extra pieces to make it compile, and then hide them from the documentation to avoid the noise you were avoiding by writing only half the code in the first place. Brilliant idea on someone's part.
Oh, I knew they existed, but didn't know that this was compiled by default! Great to know, thanks!
&gt; I've always disliked how various social/political agendas get mixed in with technical projects. As long as you profit from the status quo it's easy to hold this position. When the status quo leads to discrimination of yourself - often assisted by technology - that gets harder. &gt; but because everything seems to gravitate towards LGBT agendas This is only correct if you ignore that current society is for the most part anti-lgbt. It's like sitting there in 1960 and saying "you know, we have many problems in this country, why do we talk about black people all the time?" and not acknowledging that almost every discourse is about the problems of white people, but you don't notice, cause that's what you expect it to be. &gt; So naturally I've see LGBT movements as somewhat of a threat. Nothing about this is naturally, cause it implies that LGBT is a choice and the alternative choice would be a "traditional family". Since it isn't a choice this is wrong. &gt; Unfortunately, holding such an opinion has resulted in me being ridiculed on more than one occasion. People get attacked for being LGBT. Physically attacked. Psychology attacked. Literally hunted. Parts of society see this rightfully as a bigger problem than "we loose the traditional family". There are many valid alternatives to "traditional families" as foundation for a "strong nation", so even if we agree that loosing it really happens that's a far less pressing problem.
That would be a rookie mistake
Im don't think a link has attached to your comment.
What would be the easiest way to make my program try to find and bind to a free port on localhost? I am suspecting that there is an easier way than iterating manually and building strings for the bind-method
The terminology is pretty new, and not very much widespread outside of the US. I remember only a couple of years ago, no one really used these words. Actually, what was even more interesting for me is that while I knew about 'cis' being used recently, this trio of words are completely new to me and this is the first time I heard it. I'd say, outside of the US, it's a really obscure jargon yet...and we don't even have an equivalent for it in some of the languages I speak, so there's that. I doubt this person wanted to use that sentence to defend themselves, rather the just wanted to clarify that they haven't heard of this terminology either, which just shows that it is kinda new and obscure yet. Give it a few more years.
While this is good and all, the whole CHM thing is a bit too targeted, isn't it? Have you never had to deal with a cis hetero girl asking the same questions to you? Or discriminating you in the same way? I sure had met girls like that before, and it felt horrible being judged, or looked down upon. It doesn't really matter whether it's a 'male' or 'female' who does the bad things...it shouldn't. So why specifically call out just one side of the coin, and ignore the other? Because it happens much more rarely? (perhaps it does, I didn't look into it, I only have my own experiences to speak about)...to me it happened about equally....so just address 'cishet' in general instead of calling out males especially? I don't know, inclusivity, exclusivity, politics are hard, and I personally just want to accept everyone as who they are and love them for what they choose to be(As long as they do not harm anyone with it).
Yes. Only dependencies are: rayon, glium, cgmath and rusttype.
Checksums for content of your dependencies would need to be part of Cargo.toml though, since Cargo.lock is not part of a published crate IIRC. Only generating the checksums on first build would kind of defeat their purpose in a lot of cases.
It looks good! I think it was me who misunderstood you 😅
This seems like a perfectly reasonable explanation, what's with the downvotes?
Man, I'd love to hear this.
Honestly as a non-American, it looks to me like much of the anti-gay mindset and the constant calling for less of that seems to be from and mostly contained in an American bubble/echo chamber. As a person from another country, particularly a Central/Western European one, all the anti-homosexuality and racism just seems unreal/far away. &amp;#x200B; Personal anecdote on other sexualities: In grade 4-5 it was becoming obvious one of my classmates was gay. Sure most students in our class (full disclosure: including me) teased him a bit for maybe 2-3 weeks and he teased us back about other things. To him and us as kids just discovering our sexuality back then it was pretty funny and a just another part of that discovery process. That didn't mean he was excluded from anything in the clusterfuck that is school during puberty and even years later when I met him for the first time in years after we went to different schools we had a normal conversation, caught up a bit etc. (turns out he had taken up the "stereotypical gay" profession of hairdresser and apparently he was/is happy with it). &amp;#x200B; Personal anecdote on "other races": Growing in a relatively small provincial town (35-40k people) I had seen \~4-5 black people \[1\] during my first 15-16 years of life. We then went on a one-day school trip to "the big city" a few hours away where we also had a few hours of free time in the evening to explore the party streets. I have to admit it was pretty strange to see so many people with such different skin colour but that went away within minutes and I could interact with them like any other person. It was a pretty fun evening. &amp;#x200B; &amp;#x200B; And you know what I attribute these experiences to? A proper ***secular*** upbringing by my parents and not growing up in an echo chamber where everything is about "the troops", AKA "you too have to grow up into a MANLY muscular bodybuilder type wearing fatigues and carrying guns to go abroad and shoot brown people etc etc". &amp;#x200B; My parents actually brought me up with the motto: "What does it matter what colour anyones skin is or whether they are homo/hetero? It doesn't. Be polite to others and you will (hopefully) be treated the same. Also, we don't care what kind of person you bring home someday, whether it's a woman or another man or whether they're black or white or something else." The only thing they (especially my mother) don't want me to "bring home" are those stereotypical "stuck-up bitches" or ridiculous airheads you sometimes see in some TV programs. &amp;#x200B; &amp;#x200B; In conclusion, don't assume everyone is "minimizing/ignoring LGBT issues" etc. because those are not universal for everyone and everywhere. A big part of people's perception is the context/environment in which they grew up in and in which they live now. &amp;#x200B; &amp;#x200B; \[1\] Note: I don't use the term "African American" because their skin colour has/had nothing to do with America.
&gt; ~~Un~~fortunately, holding such an opinion has resulted in me being ridiculed on more than one occasion. Fixed that for you.
I need help, the "Borrow checker have you in a headlock " happened to me. What i'm trying to is reading from a file, finding all the "special" words, replacing them with something else. I'm stuck at borrowed string assignment in a loop with the return value of .replace function. I'm only a simple c programmer, probably doing everything wrong. :( //... let mut data = String::new(); let _err = buff_rd.read_to_string(&amp;mut data); let mut special_words: Vec&lt;&amp;str&gt; = Vec::new(); //... for symbol in special_words { let symbol_parsed = parse_symbol(&amp;symbol, mcu_pattern); data = data.replace(symbol, &amp;symbol_parsed); //FIXME: cant assign like this! } let _err = buff_wr.write_fmt(format_args!("{}", &amp;mut data));
Thanks for the post, OP. Shame these comments are a garbage fire.
This entire post is the target of vote brigading. Also lots of "I have nothing against gay rights but I don’t understand why straight men are being targeted."
can you give an example of this?
A Xi editor front-end written in rust would be cool. The orbtk gui library looks pretty interesting and feels faster than some other guis while using less ram. Azul could work too.
Hey, I am the author and I am totally stoked by your review and comments, especially since this was my first book (ever) - Thanks! Of course if any of you has questions about the process with Packt or the book's contents, feel free to message me :) ❤️
Amazing service!! Been loving it so far :)
I could not agree more with what you said. I'm from Ireland the only country in the world to legalise same sex marriage through a referendum and all of this seems otherworldly to me as well. Why are straight, white men (moi) being specifically called out as one indivisible group in this exactly? Why are they saying my masculinity isn't being attacked (whatever that means)? Why aren't women straight women called out? For reference the referendum in Ireland was pretty evenly split between men / women as in they voted Yes / No in about the same ratio. &gt;African American This term is one of the most disgustingly racist and ignorant terms you could use imho. Why are 6th or 7th generation black person not just American? Why *African* American, are they not fully American or something? Why is it a 2nd generation white person just called American and not European American (or something equally silly)? Africa isn't a country either, a person from northern Morocco is, from my experience, no more black than a person from southern Spain or Italy. TL;DR Americans are kinda weird when it comes to sexuality / race.
The weird thing is that you have to write #[no_std], and leaving it out isn’t possible.
&gt; Cisgender If you stopped 100 people on any random street in the (English speaking) country I'm from I doubt 1 could answer what it is. I can't even lmao.
I'm always shocked by how many people in the opensource world have a furry as their profile pic. Is Furry-ism (if that's a word) just big in the American software community or something? because it's completely non existent where I'm from, so much so that I probably wouldn't even know what a furry was without Reddit and the Github profile pics.
As long as you treat everyone with equal respect, you should be fine. If you call someone with a wrong pronoun unintentionally, and they respond disrespectfully, that's on them; you didn't know.
I think you're missing a link. Additionally, unless we're particularly concerned with the space the proxy uses, why not just Option?
I think that you should keep non-tech stuff out of rust as much as possible, but that the way to do this is to specifically address it from time to time. That way you reassure people that they are welcome and they don't have to worry. And then we can all get back to work :)
bind can also take a `(&amp;str, u16)` tuple. I don't know of other ways than iterating though.
I am from the US but I live in western Europe in a major city with an enormous queer scene. Two weeks ago my friends were attacked on the street for being visibly queer. My friends who are of color experience racism here all the time. This line that white straight European programming men have that these are "American" problems that don't impact them is the most bald-faced ignorance. Learn a little bit about what the people around you experience.
Awesome! I had been meaning to rewrite [msdfgen](https://github.com/Chlumsky/msdfgen) in Rust for over a year now but never had the time. Glad someone else here knows about multi-channel SDFs.
There is a fundamental desire for humans to categorise things, however when it comes to sexuality it's just not necessary or good to do so. You can only target LGBT people if you define them as different to "normal". I think we should aim for a world where categorisation by sexuality something society doesn't do. Same with race. Unfortunately that isn't the case at the moment and so we have to talk about it. I do agree with what other people have said about how in the USA these things are more political. In the UK being gay isn't so associated with being on one side or the other of a political argument (obv we had things like section 28). May be it is because of the focus on individual freedom in America, where society encourages people to define themselves as a free individual, rather than as a member of society, and so people try harder to forge an individual identity.
If you sampled 100 people from a Western population you would expect 1 of them to *be* trans, statistically. You reveal your own ignorance and not much else.
Your "shoot yourself in the foot" description for Rust sounds like excellent Quote of the Week material.
I kinda feel that this thread is OT for rust, but I kinda like that people talk about this stuff. I'd like to say that as someone who isn't a CSM, it's really good to listen to people who are about their concerns. Even though there has been persecution in the past/present, that doesn't mean that most people have good intentions and that problems that arise can be solved with dialogue. Same for race, where I am part of the majority.
This is less using something in rust and more how to launch external programs via rust. I was hoping that this would have been some library that someone made an ffi interface for, or maybe written a library in rust that directly talked to the GPIO pins.
Just prefix the lines you want to hide with `#`
/r/playrust
yikes
Agreed, best rust programming book out there. I’ve made my way about 1/3 through this book and am thoroughly enjoying it so far too, it has a good flow.
I think I've made it quite clear that I was relying on personal anecdotes to form my opinion and that LGBT issues don't exist the same for everyone everywhere or are not equally visible. Certainly where I grew up, have lived in the past and live now there were no attacks on LGBT people that I'm aware of. Probably because over here people have more important things to do than being dicks to each other. &amp;#x200B; As an example I don't know of any LGBT people at my university. Maybe there are some or maybe not, I have no idea and I don't really care either way, since other peoples' sexualities don't impact me in any way. &amp;#x200B; And to be quite honest I have better things to do than *inserting myself in other peoples' business as an outsider*.
I think you’ve done a great job, congratulations. I secretly aspire to own and read all the rust books and so far yours is only the second one that qualifies in the ‘holiday page turner’ category 😉
I would say that implementation is quite minimal: cubic bezier curves are not supported, the order of contours currently matters, shapes are not simplified when they are smaller than the size of a rendered pixel, etc. There are a lot of things which can be improved.
I'm sad to say that I forgot \`Option\` existed. Such a useful type.
Can you explain how supporting the LGBTQ+ movement is "embracing and extending mental illness"?
It's a promising start, at least.
The fact that you don't know any queer people, or about the violence that is done to them, doesn't mean it doesn't exist. You don't live in some uniquely enlightened society where "people have more important things to do" - you are just ignorant of problems that don't impact you. And that's one of the points of awareness raising efforts like these pride flags: to make you aware of the reality. Queer people exist in all of these communities and are, today, in your society, being subjected to negative experiences and even violence by people who aren't queer, often in ways that are tacitly supported by systems of authority. Your ignorance of this is not a virtue.
Personally I find this amazing: I've been remembered several times to update some parts of my doc when my API changed.
So good you say it twice.
true!
It should be - but I don't have the energy to deal with the discussion afterwards. Although English is a rather easy language I tend to form sentences that are not clearly defined and then people jump based on assumptions. In real life I never had any such problem and I have quite a few gay friends and acquaintances. To be more precise here: I would wish both sides were more open and not always thinking that the other one wants harm done. (I am not speaking about clear intentions, but unclear written words)
Since I'm not part of the LGBT community and don't have any desire to be, I think it would be disingenious for me to pretend I were part of it. Furthermore there already loads of people from such communities "raising awareness" and the (IMHO real problem) religious-conservative old fucks (M/F) in power today are gonna die off on their own in time. This will bring about ***gradual change*** to societies all over the world over the next few years/decades which is good because people generally have adverse reactions to changes they perceive as being forced on them. &amp;#x200B; Also, I'm very much aware that LGBT people are a reality, I just don't know any myself in person and since people don't have neon signs over their heads advertising their sexuality, I don't think I would notice.
I agree, this is a really useful feature. My only ask would be a way to avoid duplicating this hidden setup ceremony code for different doc tests to keep the src readable.
Actually, I thought it could be a simpler way of interacting directly with the camera. By the way thanks for the review.
I was not able to find any library that can directly interact with the RPi camera, that's why I wrote this program to understand the concept of the camera as well as interacting with it. By the way thanks for you concern.
The potential “gotcha” here is that drops aren’t guaranteed to run. If any part of that code panics at any point, the assignment doesn’t “actually happen”.
At least on Linux, if you try to `bind` on port 0, you will get a dynamically assigned port. See [this SO question](https://stackoverflow.com/questions/7531591/getting-unused-port-number-in-c-dynamically-when-running-server-process). Not sure if there is a equivalent of `getsockname` in Rust's stdlib to then find out that assigned port. In the worst case, you will need to use libc.
Cool, didn't know that – but I want a port between 60,000 and max :(
 [https://doc.rust-lang.org/stable/rustdoc/documentation-tests.html#hiding-portions-of-the-example](https://doc.rust-lang.org/stable/rustdoc/documentation-tests.html#hiding-portions-of-the-example)
Support people voice is different that support people health. However, we could argue that on this case it's also people health. That both I think.
You need to serialize them somehow. I'd look into [Serde](https://serde.rs/).
Maybe defining a declarative macro would work, if you can figure out the scoping rules of doc tests?
Every time I tried to dress more fashionably at the office my gay colleague would casually just roll up looking fabulous with no effort. GRRRRRRRRRRR.
You are right, I added it now.
Reply edited to include the link. I'm using an \`Option\`
As a rust newbie coming from most Scala I tried to write a version in a more functional way like you sugested, but it becomes messy. I cannot propagate errors from within a closure with \`?\` so I had to either unwrap or return a collection of Result which is not what OP asks. Here is my try: fn load_data(filename: &amp;str) -&gt; io::Result&lt;HashMap&lt;String, String&gt;&gt; { let file = File::open(&amp;filename)?; let hashmap = io::BufReader::new(file) .lines() .map(|l| l.unwrap()) .map(|l| { let mut iter = l.split(','); (iter.next().unwrap().to_string(), iter.next().unwrap().to_string(), ) }) .collect(); Ok(hashmap) } Is there are better way to do this? &amp;#x200B; Also like OP I'm surprised that in his for-loop this works: let line = line?; let mut iter = line.split(","); but this doesn't: let mut iter = line?.split(","); ^^^^^ - temporary value is freed at the end of this statement | creates a temporary which is freed while still in use Could anyone explain this?
The unwrap mimics op's behavior, since indexing into a vector will panic if the index is out of bounds
Thank you for elaborating :) I think I have to give both a real spin - it just takes insane amounts of time to start with either one. I am stuck with Functors these days... :/
Protocol Buffers
I agree it's great to have doc blocks compiled, but I wished to be able to disable this more than once, especially when developing on my old slow laptop while traveling and just compiling tests on each test run cost me cpu and battery.
I don't think there's an idiomatic way of dealing this this. I'm doing something simmilar for the purpose of communication between a NodeJS server and Rust client on the same machine. I ended up using protocol buffers, because it lets you create a schema file that describes the data and ensures correctnes (to some degree). But at the time of writing this protobuf crate for rust doesn't support serde serialization so it's a bit of a hassle to get it working. If you don't care about schema and correctnes you could try and look into [CBOR](https://cbor.io/), there's a [crate with serde support](https://crates.io/crates/serde_cbor).
&gt; Hey thanks for that. I'll be sure to continue never noticing anything ever again, doing my duty as a "Cis Het Man" Seriously, why do you have to be so antagonistic and difficult? I wish I could pretend we're on the same team, but at the slightest knock of not using the right words you instantly back into mockingly doing nothing. This conversation doesn't matter for you, but it really matters for me, and I'm trying my best. Even a token understanding of that would go a long way.
&gt; "I have nothing against gay rights but I don’t understand why straight men are being targeted." Well why are they? When my country voted to give same sex couples the right to marriage men and women voted Yes in about the ratio.
I understand why you might have this view, and it's one I'm sure that is shared by a lot of people. That's okay. But it's made from the perspective of someone that probably isn't oppressed or shunned because of who they are. For most programmers, politics is something they don't have to engage with if they don't feel like it. For more marginal groups in society, not engaging with politics isn't an option. Their very right to exist depends on being political and maintaining a political discourse. From this perspective, not engaging in politics is not apolitical - it actively helps to maintain the status quo on which some groups of people are oppressed. I'm not saying that it's your moral imperative to be at the front of the crowd, working for social justice every day. But I do think it's important to be comradely towards those struggling for equality, and that means both appreciating and demonstrating your support for their struggle. In this context, Amethyst is absolutely right to reach out a hand to the Pride movement and demonstrate their support - because doing so will have a positive impact on the lives of many in the community. Let me put this another way: would you object to the Amethyst community publicly supporting another cause? Perhaps poverty in Africa or homelessness, to name a few? I wouldn't, and I think it would take quite an unreasonable person to object to that. It's not like it's hurting anybody. Well, this is the same thing. Apologies for the lecture, I hope it helps clarify what's going on here.
&gt; I am slightly put off by the fact that, if, for example, members of the community wanted to recognize and celebrate service members on memorial day, there would almost certainly be strong objections in doing so. From my experience, this could be due to the fact that LGBT pride celebrations and memorial day celebrations and similar have different goals. Memorial day etc. is the time of *paying respect* to people, which is certainly noble, but it doesn't really serve to improve the quality of life of those people. LGBT celebrations are for *showing support*. That is, stating that you support the rights of LGBT community, sending a message to members of such community that they can just be themselves with no fear and sending a message to homophobes that you do not approve of their actions. The hope is that this results in a tangible decrease of instances of harassment because at least some small amount of homophobic people either genuinely change their mind or more likely, after seeing the amount of support for LGBT people they no longer feel comfortable harassing them for fear of backlash from supportive straight people. In short, there is a belief that LGBT celebrations lead to tangible improvement to the society, whereas memorial day is a nice tradition, but does not have a major positive impact on people's lives. For this reason one may insist of celebrating the former but be indifferent to the latter. I'm not saying this is the correct reasoning and that you should agree with it - I'm not sure if I do. I'm just saying that people in favor of celebrating LGBT pride and not memorial day usually have a non-malicious reason for doing so.
I'm unsure about what happens: this compiles fine: fn main() { let mut s = String::from("Hello world!"); s = s.replace("world", "guys"); assert_eq!(s, "Hello guys!"); }
People have different experiences, and weirdly LGBT+ tend to report significantly worse experiences than everyone else, since they actually have to deal with it. That's why you need to listen to their experiences. I have plenty of awful, awful stories as well; some in the last year. I was originally writing them out, but don't really wanna do that work rn. My point (not opposing to yours) is that supporting LGBT+ people in a liberal tolerant (you do you) way is great and important, but not a pass for anything else you do. You can still make very hurtful comments, you can still oppose movements that help those people, you can still minimize the diffulties the face, and all that is probably out of ignorance. But you have some responsibility to educate yourself or at least take a sideline when the conversation is about experiences that aren't your own, including discussions on the amount of harassment and daily issues that LGBT+ people face.
Sorry for the stupid question but what is the advantages of using this instead of lazy_static? Is avoiding macro good to make the code simpler or easier to debug?
Im really happy with this post, I feel even better about choosing amethyst for my projects! But Im sad that at times like these I am reminded that the Rust community isnt that different from the rest of reddit
Really looking forward to using this. I do wish that they stayed with the snake case style though. I understand the reasoning of remaining consistent with the official API, but it makes to end dev use different coding styles.
Author here. I originally had a pic of Pidgeotto hair in there with a caption of "Stop doing this!", but it proved impossible to position correctly in the post, so I'm afraid the joke was lost. It's hard to deny that quite a few gay peeps in Pride Parades look fucking sharp, though. On top of having a 12-pack. How is that even possible?
You’re looking for wheedling little points to complain about; if you didn’t take the statement at face value, then I don’t fucking believe you for a second that you actually were fine with the logo change.
I have misgendered multiple people in the past by accident. In all of these cases a simple "Oh, right, sorry" was sufficient. I would say that it's extremely rare that you find a really nit-picky person that will assume your intent was to offend them, even when that was not the case.
No, it's a form of rhetorical defense against those that spend their time railing against the LGBT+ community. So many haters, so focussing on fashion can be a nice escape from that hate.
These days we use these stereotypes to empower ourselves, at least thats how I see it
AFAICT you're not disagreeing with GP. They specifically promoted speaking out in favor of marginalized groups. In your terms, I think the idea of "one big statement" is to create a space where said groups do have the privilege of disengaging with politics, because they know that sanity already prevails in that context, so they can indeed just get work done.
Maybe you made some incorrect assumptions about me 😉
I just answered that question right above in the thread. Support for marriage equality in the general population isn’t the topic, Amethyst users are mostly game devs, so that’s the population targeted by this post, and those are mostly men. As for marriage equality, a quick google seems to show that women tend to support it more than men in many of the countries that have implemented it. For example [this article](https://www.nouvelobs.com/rue89/rue89-mariage-homosexuel/20130115.RUE2466/pourquoi-les-femmes-soutiennent-plus-le-mariage-gay-que-les-hommes.amp) says 59% of women supported it in France and 36% opposed it vs 46% of men in favor and 50% against. It also points out that this trend also exists in the US and the UK. Misogyny and homophobia are two sides of the same coin, it’s not surprising that women generally show more support for LGBT rights.
It only mimics the unwrap on`iter.next()`, not the unwrap in `.map(|l| l.unwrap())` though, that would be propagated in OP's solution by `let line = line?;`.
Exactly this. Supporting the Pride movement means that better software can be written without members of the development community being bothered by all of the shitty stuff that goes on elsewhere in the world.
It's because of the whole new architecture they created (stopping with actor and doing something like Finagle around services). I am sure it avoid many values to be created and instead use the borrow even more.
[removed]
Yeah, I will do the `Vec&lt;Vertex&gt;` just to finish my game, even if it's not performant. And I will propably start doing something with `vulkano`, maybe port the game or remake it.
Well, the program you call can interface with a RPi camera. You might be able to find the source code for that online somewhere. If you are lucky, it's written with a library interface instead of just all being stuffed into the executable. Then you can either create ffi bindings -- which if you only want raw unsafe C bindings is easy with bindgen, though creating more idiomatic rust bindings from that can take a bit of effort sometimes -- or maybe reimplment it yourself, though reimplmentation can be a lot more work and isn't always worth it. Depending on your needs and the time you want to invest it could be that just calling an external program is good enough for your use case. Just keep in mind it usually isn't the best solution.
&gt;(Non-CHMs can skip this part) Mainly because I was writing directly to a specific audience. My apologies, I didn't intend it to be patronizing. &gt;specifically the fact that it's in large text The thing I wrote it in only gave me h1 and h2. =( These issues almost always start by a cishet man complaining about Pride, so I do think that part is rather important. In the past four days, I've had extended conversations with four different people who objected to the logo change. All were cishet men, all objected only because they felt weirded out by the thought of two dudes doing it. I'm curious why you think I'm rubbing in, though? I honestly don't know.
\&gt; The compiler error messages provided were leaving me in wonder how do I interpret this message? Please file bugs!
yikes
Ufff.... As my example is kind of simple, isn't there a way to transform the strings and the vector to one big slice of bytes and just send them over the socket? Endianness should not play a role if I treat it as a sequence of bytes and ensure with a small package header that the data is reconstructed correctly (meaning ID and Timestamp have a fixed length, then follows a u64 representing the payload's length, then the payload itself)
Thanks for your explanation,very helpful.
I'm glad. Please know you are welcome on our Discord and forums, and we actively keep it a safe space for everyone.
&gt;The problem with using an option is that you have to wrap your values with \`Some\` when using DerefMut Ah yes, that is a bit of an issue. I was originally working on this problem were the type was known to be `Clone+Sized`, and I had an "original" value to put in the proxy, so this didn't occur to me.
You still can't make a struct that is bounded by const generics. Unifying array lengths was just merged the other day. There are still ICEs. We will have const generics probably within a month or so after all the initial churn is worked out.
\&gt; You still can't make a struct that is bounded by const generics &amp;#x200B; Of course you can. &amp;#x200B; \&gt; There are still ICEs. &amp;#x200B; Yep, the feature is unstable, and even when using it you get a warning telling you that's not fully functional yet.
Apologies that you ended up being the target of this. Perhaps it should have been a general comment on the post.
You aren't going to going to get eviscerated for using the wrong pronoun. Like I said in the essay, I'm super gay and I fuck up pronouns sometimes. I will also be one of the first people to defend \*you\* if someone did tear into you over an honest mistake. Just do your best, be respectful and honest, and you won't have any problems.
I just thought of it but if your meshes are static you could also make a static Vec&lt;Mesh&gt; and just give an index to your entities. There is still the OpenGL thread problem but specs's system can be called single threaded if I remember correctly. That's a bit hacky but for a small game it should be ok.
My bad, I was thinking of this issue: https://github.com/rust-lang/rust/issues/60818. It seems it was resolved at this point.
As /u/K900_ said: use serde. It'll make it easy to turn the struct into a JSON/toml/yaml/msgpack/whatever byte slice and send it along. What you're describing is just re-implementing the above with some off-the-cuff format.
I suggest you take another read. I found it rather refreshing as a cishet dude to be talked to in a way that was understanding, which is unfortunately not something very common online. Given, it's never the responsibility of a minority group to explain themselves in a polite way, but it certainly is nice to see.
I'm curious too. I was specifically trying to communicate that ya'll are sometimes treated unfairly by us. If your masculinity is not threatened by a logo change, that last section doesn't apply to you. Would you be ok with the tone if I had made that more explicit?
It's a "voxel game", so these meshes are actually Chunks of the World terrain, they have to be 'editable', but why would they have to be \`static\`? Couldn't it be a normal \`Vec\` with id's being indices?
Dude, I even linked to the articles explaining those terms. Did you bother to read them?
Serde (already recommended by others) together with [bincode](https://crates.io/crates/bincode) should do exactly what you want.
Serde with serde\_cbor ;) You probably want the [serde_cbor::to_vec](https://docs.rs/serde_cbor/0.9.0/serde_cbor/fn.to_vec.html) method.
It looks like you got an answer. I have an unsolicited FYI: you don't need to [define pi](https://github.com/juliangaal/mpu6050/blob/master/src/lib.rs#L76) yourself, it's defined in [`core`](https://doc.rust-lang.org/core/f32/consts/constant.PI.html).
I might be wrong but I don't think you can give something to a system that is not inside the ecs and you have to use systems to iterate. If not for that of course you could just keep it in your main function, do your ecs stuff and iterate over this Vec before or after.
I was essentially asking if Fn was pure, which would imply that I can call the closure fewer times and still produce an equivalent iterator.
There’s any number of ways you can do this with serde. Depends on your usecase. Does it need to be versioned? How complex is your data structure? Is the message size a factor? Do you need to support multiple commands? How hard will it be to get callers to upgrade if you make changes? Serde provides some nice macros to work around most situations. And you can always roll your own ser/de functions if you can’t make it work outta the box. I’ve used the bincode and json serde crates for this in the past. Both work great. Bincode can serialize nested structs/enums (and I’m guessing most serde crates do?) which is nice if both the sender and receiver share the same Rust code.
I would just wait until it stabilizes.
I'm wondering if that difference in impure functions is surprising enough that I shouldn't overload the normal "map" (and have a seperate "dedup_map" or something) or whether it matters since the normal use case is going to be 99% pure functions.
&gt;I mean what am I missing? Shaming of a subculture is an ideological choice. It doesn't just affect the individual, but the subculture. Someone else who has a furry avatar will see that joke. Your personal ideology perpetuates the general ideology that it is ok to shame someone for having an anthropomorphic unicorn as their avatar. Why contribute to an ideology with the sole purpose of making people feel ashamed?
No, it's already communist.
If it's a small non-production project one could use the master branch of Rust-proto if which supports serde: https://github.com/stepancheg/rust-protobuf/blob/master/README.md#serde_derive-support
Heh, definitely not just in America. Some quick Googling should give you a much better idea of the culture and scope.
&gt;Have you never had to deal with a cis hetero girl asking the same questions to you? Very, very rarely. I also cannot recall any cishet women objecting to Pride, or a logo change. I do know of certain radical groups of women that strongly believe transgender women are not real women, but that is the closest I can think of, and I do not have any personal experience with those groups. This is partially due to my being a gay male; a gay woman could better speak to this. Do you agree that there is a problem in the cishet male community, though?
Serialization is the name for this process, and it isn't a trivial problem, lots of ways to do it with various pros/cons. You could for instance, using unsafe, just get the actual bytes of that data structure and send them, then cast that back into the struct on the other side. This is very efficient in terms of runtime, it takes no work to serialize and deserialize. But, if machines have differing endianness, it won't work, if the programs have different compilers that packed the structs different, it won't work work, there is no versioning data, and the data sent over the wire will be larger than it could be. For these reasons, this method is rarely used outside of debug scenarios. &amp;#x200B; Serde is the most popular rust crate for serialization jobs, and you can plug in different methods of serialization. bincode and protocol buffers are common ones for efficiency both in terms of runtime and size of data sent over the wire, when you don't care if the packets sent are human readable.
The issue was never about race, gender or sexuality. The issue people had was that they wanted a fully neutral project. Writing an article where they wildly guess the gender, sexuality and so on of the people they were arguing againt makes it feel very questionable. Those sections didn't have to be mentioned at all because they are not related to the issue at hand. No one said anything against anti-pride during the arguments in their Discord server.
Wow I like this idea of open-source Google-like suit of apps, I did try out the android app and I think it needs a design refresh, is this something you consider in the future? I'm an Android developer and I wouldn't mind contributing
thanks, I had some issue with it, I don't remember exactly...Replaced my constant now though ;)
&gt;The issue was never about race, gender or sexuality. This is not correct. The issue is most definitely about sexuality. &gt;Writing an article where they wildly guess the gender, sexuality and so on of the people they were arguing againt makes it feel very questionable. I was quite clear about to whom I was writing. Why exactly makes you think I was guessing wildly? &gt;Those sections didn't have to be mentioned at all because they are not related to the issue at hand. I guess we'll have to agree to disagree there. &gt; No one said anything against anti-pride during the arguments in their Discord server. This is most definitely not correct.
Wrong subreddit my dude. This one is about the Rust programming language.
I do agree, and I do not mind the idea of talking openly about these things, and including them everywhere, at all. It makes the world more colorful, and I like that. All communities have problems...with other communities, or even internally. I got hate from both opposing communities, and my own group as well. It's just everywhere. Sometimes I get more support from a straight male than from a lesbian lady....labelling and forming groups is good and all, but don't ever forget that while our beliefs, problems we face, desires and interests may make us similar or like-minded, we are all unique, different from each other no matter how similar we may find each other.... Anyway, before I got on a large tangent, I agree, communities always will have problems, and we just all need to learn to be more open towards everyone's preferences, while also being more strict about not accepting discrimination and harmful behaviour.
Ok thank you so much.
Just serialize your struct to a byte slice and write it out to the stream... That's the simplest way, but you need to take care to deserialize the bytes into struct on the receiving side. Using other libraries will simplify and take care of most things for you
This is _gold_, who the heck is downvoting _gold_?!
[bincode](https://crates.io/crates/bincode) provides a trivial serialization/deserialization format. It doesn't contain names, every field in a tuple or a struct is written one by one, isize/usize is 64-bit, enums are u32 instead of usize, and collections (strings and sequences) are a 64-bit length then every element.
I feel like splitting rand into multiple crates only brought more pain than value.
You absolutely can. Check out the tests in `src/lib.rs` - https://github.com/gngeorgiev/fut_pool_rs
Derive serde::Serialize and serde::Deserialize for your type, then use the serde_json crate to serialize your type to the tcp stream as json. json is great for your use case because it's easy to use across language boundaries. Protocol buffers may also work for you. AFIK protocol buffers require some extra build time dependencies and add some complexity. bincode nice for rust-only projects, but language interop is probably more difficult when using bincode.
The reference count of all these comments is unbelievable
Encode it into a format like JSON, MessagePack, Protobuf, etc.
This subreddit is dedicated to Rust the programming language. The subreddit you probably meant to post in is r/playrust.
Thank you for letting me know!
That's where I find there is a problem with rust which is the same problem as c++ mainly. Ease of use versus speed and correctness. There should be no trade-off. In fact there should be tool support to ensure the ease of use is guaranteed in a sense. That would be a higher level of quality assurance and long-term maintainability. As it stands, I got one reply stating the problem falls on me since I should be donating money to have others tweak functionality to my requirements, but that's a very limited view since the scope of the problem is much wider than that. In order for a programming language to remain popular, it must be easy to use at the very least. If rust places itself in a niche where it proclaims itself only for elitist programmers, I wish it a quick death and for c, c++, and golang to live long. That's not what I really want however. I totally appreciate the speed and correctness. I have been able to find snippets to do many common things and reuse them effectively. REUSING existing rust librairies quickly is debatable now. It depends on the complexity of the crate. That complexity in a crate is a risk. That's the point I want to raise. I believe the api complexity level for each crate should be rated somehow. The lower the complexity, the higher popularity it will achieve naturally. grpc is high-complexity. grpc-rs is high-complexity. flatbuffers is easy to use, but to integrate into grpc c++ and rust is high-complexity. I think crates should be rated for setup/integration difficulty also. This is what this whole discussion is all about. It's not about shitting on rust, but providing constructive criticism in order to have more hands using rust to get shit done whether beginner or not. gtk-rs is easy to install and use hexdump is easy to install and use rust and qt examples pave a path to follow. setup is tricky, but using it from rust is achievable with effort, but reasonable complexity. Less productive than using c++ for achieving gui's. It shouldn't be this difficult. golang and qt examples pave a path to follow. setup is tricky, but using it from golang is reasonably productive from the start. The complexity level is low. These are the kinds of ratings we need for every rust crate not just grpc-rs. The best person to rate the crate maintainers themselves. I don't think github's star ratings are clear enough either. There should be more criteria with which one may rate crates/golang packages/c++ libs on github itself. This would help different levels of users to navigate to the appropriate set of developer resources geared for their level. it will also naturally bring out more popularity with the easier to use packages for the different languages.
Vec&lt;T&gt; is not an array. Vec&lt;T&gt; has a constant size, 3 words: T\*, len, capacity. An array has size size\_of(T)\*n, where n is the length, depending on alignment.
Not to start anything, but to explain something that might interest you and others reading this: The "lgbt letter soup" joke has been used by homophobes to dismiss and belittle the lgbt community for quite some time now, what you see as a light-hearted joke, we see it as a marker for a certain kind of behaviour. So you can joke if you want, I'm obviously not telling you how to act, but hope that by sharing some insight on this you can better decide for yourself how to act.
&gt; If rust places itself in a niche where it proclaims itself only for elitist programmers, I wish it a quick death. Rust is a systems programming language. If you are a systems programmer, then Rust is *much* easier than what you were doing before with C/C++. In C++, you still had to keep track of memory ownership, but you did so in your head and in informal comments. Rust came along and formally offloaded the cognitive burden to the borrow checker. So for systems programmers, Rust is *way* easier, because it helps you do things you were already doing. If you are *not* a systems programmer, then you likely have never thought about memory ownership before, and so it strikes you as unnecessary, and you don't understand why people might want that. That is OK -- Rust just does not fit your niche. &gt; REUSING existing rust librairies quickly is debatable now. It depends on the complexity of the crate. That complexity in a crate is a risk. I would venture that you are mostly used to thinking of libraries as external things that your code calls into, separate from your main program. In systems programming it is different: you want to integrate the library *into* your program, usually as efficiently as possible. Rust helps make that easier. It doesn't fit the standard JS flow of mashing things together like a build system -- but that's intentional, because mashing things together doesn't produce reliable software. &gt; golang and qt examples pave a path to follow. setup is tricky, but using it from golang is reasonably productive from the start. Basically, the problem is that Rust doesn't seem to be the right tool for what you're trying to do. It is the right tool for what *I* am trying to do. At least for me, Go would be a step backwards. But that's OK -- Rust doesn't have to be everything to everybody. I would just accept that it's a systems programming language.
This \^ You will probably need to provide some information on boundaries. Sending the number of bytes over the stream or providing a flag prior to sending the object being sent to know the receiver knows what to expect. However, you probably want to use **serde** once this experiment is over.
&gt; When June rolls around and cis het males start complaining, I will usually dig into whywith some people. Inevitably, it almost always boils down to personal distaste for “gay shit”, which is usually code for “I’m not super secure in my identity”. You’re fine. I see this sentiment a lot, and I have mixed feelings about it. On the one hand, a lot of discussion about male fragility is really about shaming men into behaving better, which I'm all for :-D On the other hand, if we thought someone was _actually_ feeling insecure in their identity -- and that they weren't just co-opting identity language to derail a conversation -- then a reaction like "you're fine" might be invalidating or hurtful.
I didn’t (it wasn’t obvious that it was a link).
Since you stated a requirement to interoperate with python, check out grpc-rs also check out c++ grpc, golang grpc also check out c++ flatbuffers and golang flatbuffers. For that simple structure, you could use grpc-rs and even without using streams. The moment you want something long-lasting or with much higher amounts of data to push however, you should be investigating grpc streaming. c++ and golang are reasonable to use for that. rust solutions for that at present are much too difficult to use. Good luck.
You sound much more experienced than me with this... At the moment I'm grabbing data from a database and serialising it into JSON, which is then passed over to an API of sorts that requires JSON. I have a new limitation which is that the response cannot exceed 1MB, meaning I need to split up the payload into several responses (due to the architecture I can just send several messages and it's handled fine). How best to go about this? At the moment I'm guessing the maximum "average" size of each item, serialising `1MB / guessed_size` items, then converting to bytes and checking if it's exceeded 1MB or not, and if so doing the dance again. It's, ahem, it's not pretty.
Also important to note that if you decide to, you can't just transfer the bytes if the struct contains a pointer (e.g. `Box` or `Vec`), as the data being pointed to won't magically be at the destination machine.
I was talking about my implementation :)
yes, good point. you would have to handle that manually. Also worth nothing that not all serializers can handle data structures with cycles in them. So if you must have cycles, it will limit your choices.
There are some trolls downvoted to the bottom, but I feel like the vast majority of this thread (and this subreddit broadly) is like a shining city on a hill compared to how this conversation would be handled in most other places. I see people being [charitable to each other](https://www.reddit.com/r/rust/comments/bxloxy/pride_essay_for_the_amethyst_community/eq9p7xu/?context=3) here, and that makes me smile.
That's completely irrelevant. I'm noting that the methods are associated with Vec&lt;T&gt;, and have to be instantiated for every T since there are no bounds on Vec. But these instantiations are done lazily as needed, and you're not using an infinite number of Ts with your vecs, which is why Vec&lt;T&gt; doesn't generate an infinite amount of machine code. Which is the exact same reason why arrays don't either.
Thank you! How can we make it better?
I mean, you also have shit like [this](https://www.reddit.com/r/rust/comments/bxloxy/pride_essay_for_the_amethyst_community/eq92urn/) being upvoted. Don’t get me wrong, this community is a lot better than most, but it’s still a programming community on reddit.
Fair.
[This](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=152b04dff6ec1e2a48ad51269c1a6cb4) seems to work for me. use std::io::{Result, Error, ErrorKind}; use std::net::TcpListener; fn main() -&gt; Result&lt;()&gt; { let listener = (60000u16 .. u16::max_value()) .find_map( |port| { TcpListener::bind(("0.0.0.0", port)).ok() }) .ok_or(Error::new(ErrorKind::Other, "no port found"))?; println!("port: {}", listener.local_addr()?.port()); Ok(()) }
Good news and bad news. Good news: from that crate I discovered the `udev` crate as a maintained fork of `libudev`. Unfortunately, it turns out `tokio-udev` does not (re?)export `udev::Enumerator`, meaning I would still need `udev`. I'll file an issue for it, but in the meantime I switched over to `udev`.
Have you tried using the Kafka StreamConsumer? That way you could avoid polling manually. Though I haven't tried how well streams integrate with Actix.
This announcement was made on June 4, and it seems that the beginnings of this rewrite came about as a result of Issue [\#3504](https://github.com/prisma/prisma/issues/3504) (high RAM usage), as well as a desire to be free of the Java VM dependency (from Scala) for Prisma 2 to be used as a library. GitHub says the [codebase](https://github.com/prisma/prisma) is currently using ~10% Rust, and they have some nice things to say about it. Always exciting to see Rust's benefits being useful for major projects!
My personal preference is to avoid macros if at all possible, as they make the code harder to understand for both humans and IDEs. With lazy static, it wasn't possible until very recently, when const-fn got powerful enough to express this pattern. Additionally, `once_cell` is more versatile than lazy_static: * there's non-`Sync` version * it works not only for statics, but for local variables as well * with `OnceCell`, you additionally can make lazy fields
I mean it says more about straight men refusing to be fashionable because it "hurts" their masculinity.
This is what I would recommend as well for a relatively simple way to get off the ground. You will probably want to prefix your serialized data with a length.
Indeed! Anybody can send buffer any way they'd wish to, but without schema (or some method of enveloping the data as structure) for deserialization, it just becomes very hard to manage (i.e. one person or small group maintains network library). I also agree with you a great amount in regards to the fact that not all endpoints are using same languages (the conveniences of passing around Schema and having them compile/build data structure for each endpoints), so having Protobuf which is supported for many languages are a plus. Also, rather than REST and URI-based (which is why people suggests serializing to JSON) which routes to specific URI so automatically unwraps the data structure specific to that endpoint request, but sometimes I prefer RPC (gRPC) with Protobuf 3 (not supported yet on Rust I think) will take care of the routing for internal service-to-service communications.
I will be civil: I stated I appreciate rust and what it brings to the table. I have identified a painpoint with it. I am expressing that painpoint with critieria to better identify, possibly measure that pain....levels of complexity of code, levels of configuring, levels of building, levels of installing...etc... Constructive criticisms and recommendations to further reduce the pain and continue using rust: Tools to measure and rate code. Tools to constrain complexity of code before accepting and publishing as a public crate on crates.io. CIVIL SWITCH OFF: You said:"Rust is a systems programming language. If you are a systems programmer, then Rust is much easier than what you were doing before with C/C++." and you also said: "I would just accept that it's a systems programming language, and that you want to do higher-level application development." These statements are rather condescending and elitist. You've assumed I haven't done any systems programming. You've assumed that rust is only for programming systems. Get your head out of the sand. This discussion was not about that. It's about reusability. It's about long-term maintainability. You are not the only software developer out there writing systems. The software needs to survive much longer than you will live your lifetime. You have to apply effort with that point of view always no matter what language you express your system implementation in.
&gt; Seriously, why do you have to be so antagonistic and difficult? cause it's the internet and I'm a sarcastic asshole. &gt; Even a token understanding of that would go a long way. I get that, but &gt; I wish I could pretend we're on the same team, but at the slightest knock of not using the right words you instantly back into mockingly doing nothing. I'm not insulting you, but you are repeatedly lumping every CHM together and saying we're against you
The only potential issue here is that let element_ref = container.get_mut(n); *element_ref = new_thing(); requires `*element_ref` to refer to an existing value which is then destroyed on the assignment while let element_ref = container.get_mut(n); element_ref.set_value(Thing::new()); does not require such a value out of thing air.
The reason you see a lot of `unwrap` in documentation is that the documentation is probably trying to highlight other parts of the code, not error handling, and so it makes the example code shorter. In a real-world situation you might have much more robust error handling depending on your use case.
Oh, knock off the self pity bullshit. How about just saying "Oh, no, I didn't see them. I'll give them a read."
This is super interesting. There doesn't [seem to be](https://en.wikipedia.org/wiki/Merge_sort) a straightforward in-place implementation for merge sort, so if you can't do it in place then I guess you'll always have to use `unsafe` to temporarily copy elements into your working space. If you really wanted to do a safe version, you could try an approach where you build up a sorted `Vec` of indexes rather than a sorted `Vec` of actual elements. ("Use a vec of indexes" is a pretty common strategy when you're trying to do complicated things in safe code.) Then in your final step you could execute the "swap cycles" implied by the `Vec`. For example, if the resulting sorted indexes are `vec![2, 4, 3, 0, 1]`. Then you have two cycles: the 0-2-3 cycle and the 1-4 cycle. You execute the first one by doing swap(0, 2) and then swap(2, 3), and you execute the second one with just swap(1, 4). You might use an extra `Vec&lt;bool&gt;` to mark the indexes that have been swapped already, or there might be some clever trick that lets you avoid that, I'm not sure. I'm actually not sure which version would perform better. On the one hand, using indexes requires some extra indirection when you make comparisons, and executing a bunch of individual swaps wouldn't be as fast as doing a single `ptr::copy_nonoverlapping` at the end or something like that. On the other hand, if the objects you're sorting are very large, you might get some savings by only needing to move them once at the very end. It could vary from case to case? One thing to note is that the current version of your unsafe code probably contains some undefined behavior. The underlying issue is that `mem::uninitialized` is extremely difficult or impossible to use correctly, particularly when you're creating uninitialized values of arbitrary types. For example, if `T` is `bool`, you run into the problem that creating any `bool` that isn't `0` or `1` is per se undefined behavior. The docs for [`mem::MaybeUninit`](https://doc.rust-lang.org/std/mem/union.MaybeUninit.html) go into much more detail about this problem, and about what's being done to fix it in the future. I think in this case, you can avoid needing `mem::unitialized` by doing a `ptr::read` instead of a `mem::replace`.
I don't think we can come to an agreement. For the kind of code I am maintaining, the lifetimes and borrowing systems are *extremely* valuable for long-term maintainability. My experience with maintaining things is that they become riddled with implicit invariants after many people make small changes over time. Having ownership explicit removes the possibility for many of the footguns that I've experienced over the years, and lets me be much more confident when refactoring. So the things that you are complaining about are actually *positives* for me. Considering Python, Go, Javascript, Typescript, Rust, and C++, I think that Rust code is the most maintainable, precisely because of the very things that you've identified as pain points. So it really does not make sense to me to suggest that Rust steer people away from what I perceive as the primary benefit of using it. You could, for example, make "Go-like" Rust libraries that have completely separate heaps and entirely manage memory by sharing reference-counted structures. Then that library would be very easy to plug in, because it would basically turn off the borrow checker. But if you're turning off the borrow checker, why would you use a language with a borrow checker? &gt; These statements are rather condescending and elitist. I don't think that saying "Rust is for systems programming" is elitist. There is no value judgement in "systems programming" being better than "application development." It's like saying "Erlang is for writing distributed systems." You can certainly write other programs in Erlang, but the Erlang language was designed to make writing distributed systems easier. Similarly, Rust is designed to make systems programming easier. That's why the language stresses things like zero-cost abstractions: it could have used heavier abstractions that would be easier to use, like Go does, but then it wouldn't have been a good fit for systems programming.
Seeing as everyone's pointing you at crates, here's [how you might do it in pure std Rust](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=fc5aea8c89982f5622b75714289918c6), with full control over the on-the-wire format. Try not to do that if you can help it.
I changed `?` handling in tests in 1.32.0 and no one got around to update the doctests yet. I intend to do so for Results and I also extended doctests to allow `?` for Options if you return `Some(())`.
Brilliant!
You don't have to take everything personally
The `Fn` traits make no such guarantees; the difference lies only in what you can do with the values captured by the closure. Any function may do any kind of I/O. You can, of course, document the fact that the function *should* be pure since it might only be called once per unique element.
The code that you gave compiles fine, so I'm guessing you're omitting something that borrows `data` before the loop. If not, could you show us the full error you get?
I'm not seeing a problem with the code you've shown. I suspect that the second `...` hides another place where `data` is used...
The affine type system is your turn on?
I think Sealed Rust was focusing on providing *specifications* and *vetting* a subset of the language and core library APIs. At the moment, there is no specifications of the Rust language, nor a full proof that its guarantees are actually withheld (there are proofs for subsets of the language). This is a necessary step to gain credibility in the safety-critical space. Furthermore, in the safety-critical space, there are expensive vetting processes (certification) required from the toolchain. The toolchain must be proven to work *end-to-end* for a full list of constructs. If there's a bug in the handling of closures in some corner cases, for example, this is not a show-stopper... it can be handled by forbidding closures or porting back a minimal patch and vetting the toolchain again. Thus the second goal is to identify a subset of the language and core APIs for which to undergo the certification process, and provide tooling (in this case the compiler) to ensure that only vetted elements are used in the applications which require the certification. There's probably also some vetted process for handling any change to the toolchain, and documentation about the vetting itself which must be kept for auditing purposes, etc... but I was never big on the administrative side of things ;)
Trans and cis have been opposites since Latin. That said, it is understandable since while we have numerous words with the trans- prefix, I've personally only heard cis- in the context of gender and chemistry.
Interestingly, an early incarnation of Rust had [typestate](https://stackoverflow.com/q/3210025/147192) where pre-conditions and post-conditions under the form of boolean predicates would be tracked. Unfortunately, this mechanism suffered from composition issues: a function from library A does not know the predicates from library B, so any result of this function is "stripped". Expressing typestate with types, however, does not suffer from this problem. The function from library A can take any `T` satisfying a number of *traits* and return a `U` (the result of apply certain operations to `T`) which maintains exactly the properties that `T` can provide after such a sequence of operations. It's still not perfect: applying `x / 2 + 1` to an even T may not result in a statically known to be even T... but it's better than typestate.
&gt; If any part of that code panics at any point, the assignment doesn’t “actually happen”. [drop gets called on panics?...](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=76eb31895f1059dd084e6bd7800aeff5) The only way for it not to happen would be to call `std::mem::forget` on it, for it to exist in a reference cycle via `Rc` or `Arc`, leaking `Box::into_raw`, or calling `Box::leak` Which, afaik, is why drops "aren't guaranteed", because it's possible from safe code, that behavior must be safe. That said, those aren't exactly normal/common situations and anyone doing them should know that a lot of types require `Drop` to work.
No word processor, no spreadsheet, no presentations, no way to import or export contacts, a display-only calendar (no events, no reminders, no subscriptions), gallery doesn't display portrait orientation very well, no sync client for the drive or gallery that I can find. Seems more like an alpha than a beta to me, but it looks nice so far. Targeting developers rather than end users at this point makes sense.
I you want, I could transfer the original repos over to the usb-rs org, so that the org-owned ones are not marked as forks.
Actually, I hope it borrows SPARK, which an advanced version of contracts so to say. In general, design by contracts emphasize run-time checking of pre-conditions and post-conditions. SPARK goes one step further, and emphasize compile-time checking of pre-conditions and post-conditions: - The callee implementation is checked to guarantee that the post-conditions are verified as long as the pre-conditions are verified. - The caller implementation is checked to guarantee that the arguments it passes to the callee verify the pre-conditions and in exchange it leverages the guaranteed post-conditions to check its own implementation. There is already a proof of concept, called [Prusti](http://www.pm.inf.ethz.ch/research/prusti.html) developed by ETH Zurich. It uses the Rust procedural macro system to annotate the code and analyze it at compile-time. It's pretty promising!
Is there a repo/crate for that?
If there's one, I don't know about it. I remember seeing code, but it may have been in the paper itself.
Huge
I am afraid to disagree about racism. I would expect, from its history, France to be relatively open. We've been invaded by Romans, Franks, British, Maures, Vikings, etc... so that the people today are quite a melting pot. I personally always find it hard to take any racist seriously: given the blend of bloods going on, the idea of a "French" race is quite ludicrous to me. And yet. I have several friends with great-grandparents or grandparents from the Maghreb. They were born in France, identify as French, and are an integral part of the French culture. Their skin is slightly more tanned than average, but surely it cannot be a problem? Well, it's mostly not. Except that they are less likely to get accepted in clubs, more likely to attract the attention of the police, most likely to warrant extra scrutiny at the customs checks, etc... It's a litany of small anecdotes which look innocuous in isolation, but keep accumulating to form a pattern until they become statistically significant. On a positive note, it seems to be getting better with newer generations, so there's hope :)
Visual Studio Code gang?
This is the coolest thing I've ever seen
I have read a few chapters in "The Rust Programming Language" (TRPL) and I am almost done reading "Programming Rust" (PR) (after taking half a year break halfway through the book because work got in the way) I found PR to be a way better and enjoyable than TRPL. I think it's great that a resource like TRPL is available for free, but I really didn't enjoy the writing style. At the time I started reading it, it said that is was for experienced programmers, therefore I think it spoke down to the reader with sentences like this, that should be should be totally unnecessary : &gt;An if expression allows us to branch our code depending on conditions. We provide a condition and then state, “If this condition is met, run this block of code. If the condition is not met, do not run this block of code.” and &gt;It’s often useful to execute a block of code more than once. For this task, Rust provides several *loops*. A loop runs through the code inside the loop body to the end and then starts immediately back at the beginning. It also had quite shallow explanations of some of the harder concepts in Rust. Compare this to PR which is *really* in depth and has great and thorough explanations for the harder concepts of Rust. I simply cannot recommend this book enough. The authors really know their stuff. The book's examples are based on Rust 1.17 so maybe reading the 2018 Edition Guide is a good addition to this book. &amp;#x200B; Again I really respect the work that Klapnik and Nichols put in their book and many people enjoy it very much, their writing style just wasn't for me and I didn't mind paying for the excellent alternative. &amp;#x200B; As for Rust in Action I have read the first 5 chapters of the MEAP. I find it really enjoyable as the book is very hands-on and project based. &amp;#x200B; I cannot speak of the three books you're originally asking about, but I can say that I have had some quite bad experienced with Packt Publishing in the past (Although Python Machine Learning by Sebastian Raschka was excellent). Often the code will not compile and their books generally feel rushed (bad/no proofreading, formatting, editing etc).
Totally pleased to see this.
**Reminder: civility, courtesy, respect.** --- In general, I would prefer to avoid contentious discussions on r/rust. The combination of anonymity and lack of moderation tools on Reddit too often results in toxic discussions of little value, which quickly spiral out of control. As mentioned by u/richhyd, [though](https://www.reddit.com/r/rust/comments/bxloxy/pride_essay_for_the_amethyst_community/eq9ektx): &gt; I think that you should keep non-tech stuff out of rust as much as possible, but that the way to do this is to specifically address it from time to time. That way you reassure people that they are welcome and they don't have to worry. And then we can all get back to work :) So I am willing to give this post a try, and I will invest time in monitoring it. I have, and will, relentlessly enforce the rules of r/rust and the Rust community on this post. This is a sensitive subject, so I encourage participants to tread carefully and assume good will.
Lmaoo
As the maintainer of \[graphql-client\]([https://github.com/graphql-rust/graphql-client](https://github.com/graphql-rust/graphql-client)) and someone interested in the development of the GraphQL Rust ecosystem, I really hope this will translate into contributions to the open source crates - we already have good foundations, but with async-await coming up and a little help, Rust could be one of the best languages to work with GraphQL .
You want r/playrust
I use VSCode for Rust after using Spacemacs for awhile
Hi. I'm trying to square root a float, but for some reason I'm not sure how. I really thought: let mut a = 4.0; println!("{}", a.sqrt()); would work. I checked answers online, and they said to use std::num::Float, but that gives an error. How do I take the square root of a number?
`4.0` could be either an `f32` or an `f64`. Usually type inference will figure out which one, but `sqrt()` is defined for both so it doesn't help. You need to specify in one of these ways: let a: f64 = 4.0; let a = 4.0f64; println!("{}", f64::sqrt(a));
Not sure how reliable [Wikipedia is](https://en.wikipedia.org/wiki/Transgender#Population_figures) on the topic, so take these with a grain of salt: - European Union: 0.3% - United States: 0.5%-0.6% So indeed 1 out of 100 is about the right order of magnitude.
Okay, thanks!
I originally avoided this because I think Entry is very awkward to use as an API, especially in my context where the keys are contigious numbers. However, as [sellibitze](https://www.reddit.com/user/sellibitze/) mentioned, doing it the other way potentially involves creating an extra element to be able to provide the pointer. I might have to go with something like Entry to avoid that, even though it feels rather cumbersome.
If your CVS is really large, maybe try SVN or Git :)
&gt;12-pack Google says it's a box of 12 beer cans or bottles :thinking:
Does debugging work yet? That’s a showstopper for me - I personally won’t use it until that is working.
https://github.com/erickt/rust-serialization-benchmarks You're looking for Bincode, ProtocolBuffers, Cap'n'Proto etc.
Debugging works quite well with CLion.
The militaries of the first world are hated because they often kill poor people in pursuit of economic conquest. Gay people are hated because of a personal choice they make in who they sleep with. Conflating the two is ridiculous.
&gt;and honestly I know that's the not the best term. But if you constantly minimize the issues LGBT people face, speak negatively of any effort to help them ("pride is too political for XYZ"), and just kinda shitpost microaggressions (I assume you'll laugh at me for using that word), what &gt; &gt;exactly &gt; &gt; is the conclusion I'm supposed to draw? I don't care if you support LGBT+ people "in a vacuum". This essay and pride overall really helps them, and you're trying to take that away. CUT &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; MY COCK OFF
&gt;If you're unironically referring to yourself as CHM, I have some bad news for you. If you're unironically referring to yourself as CHM, I have some bad news for you.